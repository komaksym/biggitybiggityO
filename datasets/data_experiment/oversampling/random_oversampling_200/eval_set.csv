code,complexity
"a,k=map(int,input().split())
p=[]
for n in range(2,a+1):
	for i in range(2,int(n**0.5)+1):
		if n%i==0:
			break
	else:
		p.append(n)
c=0
for i in range(0,len(p)-1):
	n=p[i]+p[i+1]+1
	for i in range(2,int(n**0.5)+1):
		if n%i==0:
			break
	else:
		if n<=a:
			c+=1
if c>=k:
	print(""YES"")
else:
	print(""NO"")
",O(n)
"class Solution(object):
    def constructGridLayout(self, n, edges):
        def bfs(u):
            dist = [0]*n
            dist[u] = 1
            q = [u]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[v]:
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                q = new_q
            return dist
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        mn = min(len(x) for x in adj)
        corners = [u for u in range(n) if len(adj[u]) == mn]
        dist1 = bfs(corners[0])
        corners.sort(key=lambda x: dist1[x])
        dist2 = bfs(corners[1])
        c = dist1[corners[1]]
        r = n//c
        result = [[0]*c for _ in range(r)]
        for u in range(n):
            i = ((dist1[u]+dist2[u])-(1+c))//2
            j = (dist1[u]-1)-i
            result[i][j] = u
        return result",O(n)
"class Solution(object):
    def minimumAbsDifference(self, arr):
        result = []
        min_diff = float(""inf"")
        arr.sort()
        for i in range(len(arr)-1):
            diff = arr[i+1]-arr[i]
            if diff < min_diff:
                min_diff = diff
                result = [[arr[i], arr[i+1]]]
            elif diff == min_diff:
                result.append([arr[i], arr[i+1]])
        return result",O(nlogn)
"import heapq



class Solution(object):
    def minOperations(self, nums, k):
        result = 0
        heapq.heapify(nums)
        while nums:
            if nums[0] >= k:
                break
            mn1 = heapq.heappop(nums)
            mn2 = heapq.heappop(nums)
            heapq.heappush(nums, 2*mn1+mn2)
            result += 1
        return result",O(nlogn)
"class Solution(object):
    def decodeString(self, s):
        n, curr, nums, strs = 0, [], [], []
        for c in s:
            if c.isdigit():
                n = n*10 + ord(c)-ord('0')
            elif c.isalpha():
                curr.append(c)
            elif c == '[':
                nums.append(n)
                strs.append(curr)
                n, curr = 0, []
            elif c == ']':
                strs[-1].extend(curr*nums.pop())
                curr = strs.pop()
        return """".join(curr)",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def inorderTraversal(self, root):
        result, curr = [], root
        while curr:
            if curr.left is None:
                result.append(curr.val)
                curr = curr.right
            else:
                node = curr.left
                while node.right and node.right != curr:
                    node = node.right

                if node.right is None:
                    node.right = curr
                    curr = curr.left
                else:
                    result.append(curr.val)
                    node.right = None
                    curr = curr.right

        return result


",O(n)
"l,r=map(int,input().split())
j=r-l+1

if j==3:
	if l%2==0:
		print(l,l+1,l+2)
	else:
		print(-1)
elif j>3:
	if l%2==0:print(l,l+1,l+2)
	else:print(l+1,l+2,l+3)
else:print(-1)",O(1)
"class Solution(object):
    def maxDistance(self, colors):
        result = 0
        for i, x in enumerate(colors):
            if x != colors[0]:
                result = max(result, i)
            if x != colors[-1]:
                result = max(result, len(colors)-1-i)
        return result",O(n)
"k=int(input())
a=[]
for i in range(0,12):
    s=9*pow(10,i)*(i+1)
    if k<=s:
        break
    else:
        k-=s
pos=i+1
num=(pow(10,pos-1)+(k//pos)-1)
if k%pos==0:
    print(str(num)[-1])
else:
    print(str(num+(0 if pos==1 else 1))[(k%pos)-1])
",O(logn)
"import os,sys,math
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192

def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:
        return len(a)

def solve():
    n,m,k=In()
    rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)]
    for i in range(n):
        z=list(In())
        for j in range(m-1):
            rt[i][j]=z[j]
    for i in range(n-1):
        z=list(In())
        for j in range(m):
            do[i][j]=z[j]

    dp=[[0]*m for i in range(n)]
    if k%2==1:
        for i in range(n):
            print(*[-1]*m)
        return
    k//=2
    for op in range(k):
        dp_next=[[P]*m for i in range(n)]
        for i in range(n):
            for j in range(m):
                ans=Inf
                if i!=0:
                    ans=min(ans,dp[i-1][j]+do[i-1][j])
                if j!=0:
                    ans=min(ans,dp[i][j-1]+rt[i][j-1])
                if i!=n-1:
                    ans = min( ans , dp[i+1][j]+do[i][j])
                if j!=m-1 :
                    ans=min( ans , dp[i][j+1]+rt[i][j])
                dp_next[i][j]=ans

        for i in range(n):
            for j in range(m):
                dp[i][j]=dp_next[i][j]

    for i in range(n):
        for j in range(m):
            print(2*dp[i][j],end=' ')
        print()

def main():
    T=1
    for i in range(T):
        solve()

M = 998244353
P = 1000000007
Inf=float('inf')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(n ^ 3)
"n,k = map(int,input().split())
s = input()
c=0
for i in range(len(s)):
	if s[:i]==s[-i:]:
		c=i
print(s+s[c:]*(k-1))",O(n ^ 2)
"class Solution2(object):
    def coloredCells(self, n):
        return (1+(1+2*(n-1)))*n//2*2-(2*n-1)",O(1)
"import sys, copy

n, m = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
res = [0] * (max(arr) + 1)
for i in arr:
    res[i] += 1
ans = 0
for d in range(1, m + 1):
    temp = copy.deepcopy(res)
    cnt = 0
    for i in range(len(temp)):
        while temp[i] >= d:
            temp[i] -= d
            cnt += 1
    if cnt >= n:
        ans = max(ans, d)
print(ans)
",O(nlogn)
"from __future__ import division
from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
n, m = rints()
a, cur, ans = rints()[::-1], 2, -1

for i in range(n - 2):
    cur = max(cur, i + 2)
    for j in range(cur, n):
        if a[i] - a[j] > m:
            break

        cur += 1
        v = (a[i] - a[j - 1]) / (a[i] - a[j])
        ans = max(ans, v)

print(ans)
",O(nlogn)
"l, r = map(int, input().split(' '))
n1 = bin(l)[2:]
n2 = bin(r)[2:]
if l==r:
    print(0)
elif len(n1) < len(n2):
    print(int(len(n2)*'1', 2))
else:
    index = 0
    for i in range(len(n1)):
        if n1[i] != n2[i]:
            index = i
            break
    print(int((len(n1)-index)*'1', 2))
",O(logn)
"import collections
from functools import cmp_to_key

import sys
def getIntList():
    return list(map(int, input().split()))

import bisect

base = 10**9  + 7
def get2k(k) :
    f = 2
    b = 1
    r = 1
    while k>=b:
        if k &b >0:
            r = r*f % base
        b*=2
        f = f*f % base
    return r

x, k = getIntList()
if x ==0:
    print(0)
    sys.exit()
t2k = get2k(k)

r = x *   t2k *2 - t2k + 1
r = r% base
print(r)
",O(logn)
"import sys
import os

def solve(slimes):
    if len(slimes) == 1:
        return slimes[0]

    havePos = False
    haveNeg = False

    for s in slimes:
        if s > 0:
            havePos = True
        elif s < 0:
            haveNeg = True

    if havePos and haveNeg:
        return sum(map(abs, slimes))
    elif not havePos:
        m = max(slimes)
        return sum(list(map(abs, slimes))) + 2 * m
    elif not haveNeg:
        m = min(slimes)
        return sum(list(map(abs, slimes))) - 2 * m
    else:
        return 0

def main():
    n = int(input())
    slimes = list(map(int, input().split()))
    print(solve(slimes))

if __name__ == '__main__':
    main()",O(n)
"class Solution(object):
    def minAddToMakeValid(self, S):
        add, bal, = 0, 0
        for c in S:
            bal += 1 if c == '(' else -1
            if bal == -1:
                add += 1
                bal += 1
        return add + bal",O(n)
"from sys import stdin,stdout
input=stdin.readline
t=1
for _ in range(t):
    n=int(input())
    x=input()
    c=0
    ans=0
    for i in x:
        if i=='x':
            c+=1
        else:
            ans+=max(0,c-2)
            c = 0
    ans+=max(0,c-2)
    print(ans)",O(n)
"class Solution2(object):
    def differenceOfSums(self, n, m):
        return (n+1)*n//2 - 2*(((n//m+1)*(n//m)//2)*m)",O(1)
"class Node(object):
    def __init__(self, value):
        self.val = value
        self.next = self.prev = None


class Solution(object):

    def __init__(self):
        self.__head = self.__tail = Node(-1)
        self.__head.next = self.__tail
        self.__tail.prev = self.__head
        self.__size = 0

    def get(self, index):
        if 0 <= index <= self.__size // 2:
            return self.__forward(0, index, self.__head.__next__).val
        elif self.__size // 2 < index < self.__size:
            return self.__backward(self.__size, index, self.__tail).val
        return -1

    def addAtHead(self, val):
        self.__add(self.__head, val)

    def addAtTail(self, val):
        self.__add(self.__tail.prev, val)

    def addAtIndex(self, index, val):
        if 0 <= index <= self.__size // 2:
            self.__add(self.__forward(0, index, self.__head.__next__).prev, val)
        elif self.__size // 2 < index <= self.__size:
            self.__add(self.__backward(self.__size, index, self.__tail).prev, val)

    def deleteAtIndex(self, index):
        if 0 <= index <= self.__size // 2:
            self.__remove(self.__forward(0, index, self.__head.__next__))
        elif self.__size // 2 < index < self.__size:
            self.__remove(self.__backward(self.__size, index, self.__tail))

    def __add(self, preNode, val):
        node = Node(val)
        node.prev = preNode
        node.next = preNode.__next__
        node.prev.next = node.next.prev = node
        self.__size += 1
        
    def __remove(self, node):
        node.prev.next = node.__next__
        node.next.prev = node.prev
        self.__size -= 1
        
    def __forward(self, start, end, curr):
        while start != end:
            start += 1
            curr = curr.__next__
        return curr
    
    def __backward(self, start, end, curr):
        while start != end:
            start -= 1
            curr = curr.prev
        return curr",O(n)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0] * 2 for _ in range(n + 1)]

        for i in range(n - 1, -1, -1):
            for buying in [True, False]:
                if buying:
                    buy = dp[i + 1][False] - prices[i] if i + 1 < n else -prices[i]
                    cooldown = dp[i + 1][True] if i + 1 < n else 0
                    dp[i][1] = max(buy, cooldown)
                else:
                    sell = dp[i + 2][True] + prices[i] if i + 2 < n else prices[i]
                    cooldown = dp[i + 1][False] if i + 1 < n else 0
                    dp[i][0] = max(sell, cooldown)

        return dp[0][1]
",O(n)
"class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) < len(nums)
",O(n)
"import math

SPACE = ' '

def get_data(file_name):
    result = list()
    state = 0
    data = list()

    try:
        for line in open(file_name, 'r').readlines():
            line = line.strip()
            if state == 0:
                if line == 'Input':
                    data = list()
                    state = 1
                elif line == 'Answer':
                    state = 2
            elif state == 1:
                data += list(map(int, line.split(SPACE)))
                state = 11
            elif state == 11:
                data += list(map(int, line.split(SPACE)))
                state = 0
            elif state == 2:
                data.append(float(line))
                result.append(data)
                state = 0
    except FileNotFoundError:
        print(f'File {file_name} not found.')
    return result

def time(d=None, v=None, v0=0, steady=False):
    if steady:
        return d / v

    if d is None:

        return (v - v0) / ACCEL

    if v is None:
        v = vel(d=d, v0=v0)
    return (2 * d) / (v + v0)

def dist(t=None, v=None, v0=0, steady=False):
    if steady:
        return v * t

    if t is None:

        return (pow(v, 2) - pow(v0, 2)) / (2 * ACCEL)

    return (1 / 2) * (v + v0) * t

def vel(d=None, t=None, v0=0, steady=False):
    if steady:
        return d / t

    if d is None:

        return t * ACCEL - v0

    return pow(2 * d * ACCEL + v0 ** 2, 1 / 2)

def can_ignore_sign(v, w, d):
    return v <= w or d <= dist(v=w)

def ignore_sign(v, w, l):
    dmax = dist(v=v)
    if l <= dmax:
        return time(d=l)
    return time(v=v) + time(d=l - dmax, v=v, steady=True)

def get_time(a, v, l, d, w):
    global ACCEL
    ACCEL = a

    if can_ignore_sign(v, w, d):
        return ignore_sign(v, w, l)

    tmax, dmax = time(v=v), dist(v=v)
    tlim_max, dlim_max = time(v=v, v0=w), dist(v=v, v0=w)
    if dmax + dlim_max <= d:

        res = tmax + time(d=d - dmax - dlim_max, v=v, steady=True) + tlim_max
    else:

        res = time(v=w) + time(v=vel(d=(d - dist(v=w)) / 2, v0=w), v0=w) * 2

    x = d + dist(v=v) - dist(v=w)
    if x >= l:

        res += time(d=l - d, v0=w)
        return res
    return res + time(v=v, v0=w) + time(d=l - x, v=v, steady=True)

if __name__ == '__main__':
    a, v = map(int, input().split())
    l, d, w = map(int, input().split())
    print(get_time(a, v, l, d, w))
",O(1)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
import bisect
T = int(input())
r = 1
prime = [2]

for i in range(3,4*10**3,2):
    flag = False
    if i%2==0: continue
    for j in range(3,int(i**0.5)+1,2):
        if i%j==0:
            flag = True
            break
    if not flag:  prime.append(i)

def primefactor(num):

    index = 0
    output = []

    while num>=prime[index]**2:

        times = 0
        while num%prime[index]==0:
            num = num // prime[index]
            times += 1
        if times&1:  output.append(prime[index])
        index += 1

    if num>1: output.append(num)

    return tuple(output)

while r<=T:
    n,k = map(int,input().split())
    arr = list(map(int,input().split()))

    seg = 1
    fact = {}
    left = [[0 for j in range(k+1)] for i in range(n)]
    dp = [[300000 for j in range(k+1)] for i in range(n)]

    stack = [0]
    for i in range(n):
        factor = primefactor(arr[i])
        if factor in fact:
            bisect.insort(stack,fact[factor]+1)

        fact[factor] = i

        for j in range(k+1):
            if j<len(stack):  left[i][j] = stack[-j-1]

    for i in range(n):
        for j in range(k+1):
            for t in range(j+1):
                l = left[i][t]
                if l>0:
                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])
                else:
                    dp[i][j] = 1

    print(dp[-1][-1])
    r += 1",O(n ^ 3)
"if __name__ == '__main__':
    nums = input().split()
    n = int(nums[0])
    v = int(nums[1])

    if n < v+2:
        print(n - 1)
    else:
        print(int(v-1 + (n-v)*(n-v+1)/2))",O(1)
"from sys import stdin

memo = {}
def max_splits(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    if n in memo:
        return memo[n]
    result = 4 * max_splits(n - 1) + 1
    memo[n] = result
    return result

t = int(stdin.readline())
for i in range(t):
    n, k = [int(s) for s in stdin.readline().strip().split()]

    min_splits = 1
    path_count = 3

    if n > 75:
        print(""YES"", n - 1)
        continue

    square_size = n - 1
    max_buffer = max_splits(square_size)

    while min_splits + path_count <= k and square_size > 0:
        min_splits += path_count
        max_buffer += (4 * path_count - (2 * path_count + 1)) * max_splits(square_size - 1)
        path_count = 2 * path_count + 1
        square_size -= 1

    if min_splits <= k <= min_splits + max_buffer:
        print(""YES"", square_size)
    else:
        print(""NO"")
",O(n ^ 2)
"import sys
input = sys.stdin.readline
from collections import *

def judge(x):
    ins = [0]*n
    outs = defaultdict(list)

    for u, v, c in edges:
        if c>x:
            ins[v] += 1
            outs[u].append(v)

    q = deque([v for v in range(n) if ins[v]==0])
    cnt = 0

    while q:
        v = q.popleft()
        cnt += 1

        for nv in outs[v]:
            ins[nv] -= 1

            if ins[nv]==0:
                q.append(nv)

    return cnt==n

def binary_search():
    l, r = 0, 10**9+10

    while l<=r:
        m = (l+r)//2

        if judge(m):
            r = m-1
        else:
            l = m+1

    return l

n, m = map(int, input().split())
edges = []
idx = defaultdict(lambda : deque([]))

for i in range(m):
    u, v, c = map(int, input().split())
    u -= 1
    v -= 1
    edges.append((u, v, c))
    idx[10**6*u+v].append(i+1)

k = binary_search()
ins = [0]*n
outs = defaultdict(list)
removed = []

for u, v, c in edges:
    if c>k:
        ins[v] += 1
        outs[u].append(v)
    else:
        removed.append((u, v))

q = deque([v for v in range(n) if ins[v]==0])
order = [-1]*n
cnt = 0

while q:
    v = q.popleft()
    order[v] = cnt
    cnt += 1

    for nv in outs[v]:
        ins[nv] -= 1

        if ins[nv]==0:
            q.append(nv)

change = []

for u, v in removed:
    if order[v]<order[u]:
        change.append(idx[10**6*u+v].popleft())

print(k, len(change))
print(*change)",O(nlogn)
"n=int(input())
a=[*map(int,input().split())]
b=[0]*n
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",O(n ^ 2)
"class Solution(object):
    def canChoose(self, groups, nums):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
        
        def KMP(text, pattern, start):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(start, len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1

        pos = 0
        for group in groups:
            pos = KMP(nums, group, pos)
            if pos == -1:
                return False
            pos += len(group)
        return True",O(n)
"class Solution(object):
    def findKthNumber(self, n, k):
        result = 0

        cnts = [0] * 10
        for i in range(1, 10):
            cnts[i] = cnts[i - 1] * 10 + 1

        nums = []
        i = n
        while i:
            nums.append(i % 10)
            i /= 10

        total, target = n, 0
        i = len(nums) - 1
        while i >= 0 and k > 0:
            target = target*10 + nums[i]
            start = int(i == len(nums)-1)
            for j in range(start, 10):
                candidate = result*10 + j
                if candidate < target:
                    num = cnts[i+1]
                elif candidate > target:
                    num = cnts[i]
                else:
                    num = total - cnts[i + 1]*(j-start) - cnts[i]*(9-j)
                if k > num:
                    k -= num
                else:
                    result = candidate
                    k -= 1
                    total = num-1
                    break
            i -= 1

        return result",O(logn)
"n, t = [int(item) for item in input().split(' ')]
cont, ans = list(), 2
for i in range(n):
    hCenter, hLen = [float(item) for item in input().split(' ')]

    cont.append([hCenter - hLen / 2, hCenter + hLen / 2])

cont.sort(key=lambda item: item[0])

for i in range(n - 1):
    gap = cont[i+1][0] - cont[i][1]
    if gap > t:
        ans += 2
    elif gap == t:
        ans += 1

print(ans)
",O(nlogn)
"import pandas as pd



def Solution(employees: pd.DataFrame) -> pd.DataFrame:
    return employees.assign(salary=2*employees[""salary""])",O(n)
"n=int(input())
print(n**2+(n-1)**2)",O(1)
"class Solution(object):
    def totalStrength(self, strength):
        MOD = 10**9+7
        curr = 0
        prefix = [0]*(len(strength)+1)
        for i in range(len(strength)):
            curr = (curr+strength[i])%MOD
            prefix[i+1] = (prefix[i]+curr)%MOD
        stk, result = [-1], 0
        for i in range(len(strength)+1):
            while stk[-1] != -1 and (i == len(strength) or strength[stk[-1]] >= strength[i]):
                x, y, z = stk[-2]+1, stk.pop(), i-1
                result = (result+(strength[y]*((y-x+1)*(prefix[z+1]-prefix[y])-(z-y+1)*(prefix[y]-prefix[max(x-1, 0)]))))%MOD
            stk.append(i)
        return result",O(n)
"n = int(input())
a = [int(i) for i in input().split()]
c = 0
for i in range(n):
    if a[i] > c:
        print(i+1)
        break
    else:
        c = max(a[i]+1, c)
else:
    print(-1)
",O(n)
"import collections


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def treeQueries(self, root, queries):
        def iter_dfs(root):
            top = collections.defaultdict(lambda: [0]*2)
            depth, height = {}, {}
            stk = [(1, (root, 0))]
            while stk:
                step, (curr, d) = stk.pop()
                if step == 1:
                    if not curr:
                        continue
                    stk.append((2, (curr, d)))
                    stk.append((1, (curr.right, d+1)))
                    stk.append((1, (curr.left, d+1)))
                elif step == 2:
                    h = 1+max((height[curr.left.val] if curr.left else 0), 
                              (height[curr.right.val] if curr.right else 0))
                    if h > top[d][0]:
                        top[d][0], top[d][1] = h, top[d][0]
                    elif h > top[d][1]:
                        top[d][1] = h
                    depth[curr.val], height[curr.val] = d, h
            return top, depth, height

        top, depth, height = iter_dfs(root)
        return [(depth[q]-1)+(top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",O(n)
"
import collections


class Solution(object):
    def canBeEqual(self, target, arr):
        return collections.Counter(target) == collections.Counter(arr)


",O(n)
"class Solution(object):
    def subStrHash(self, s, power, modulo, k, hashValue):
        h, idx = 0, -1
        pw = pow(power, k-1, modulo)
        for i in reversed(range(len(s))):
            if i+k < len(s):
                h = (h-(ord(s[i+k])-ord('a')+1)*pw)%modulo
            h = (h*power+(ord(s[i])-ord('a')+1))%modulo
            if h == hashValue:
                idx = i
        return s[idx:idx+k]",O(n)
"from bisect import bisect_right,bisect_left
n,c_tv,c_es=map(int,input().split())
start=[]
end=[]
add=0
for _ in range(n):
    l,r=map(int,input().split())
    add+=(r-l)
    start.append(l)
    end.append(r)
start.sort()
end.sort()
ans=add*c_es+n*c_tv
M=10**9+7
v=[0]*(n+1)
for i in range(n):
    indx=bisect_left(end,start[i])-1
    k=indx
    while k>=0 and (start[i]-end[k])*c_es<c_tv and v[k]==1:
        k-=1
    if k==-1:
        continue
    if (start[i]-end[k])*c_es<c_tv:
        ans-=c_tv-(start[i]-end[k])*c_es
        v[k]=1
print(ans%M)",O(nlogn)
"class Solution2(object):
    def minOperationsToFlip(self, expression):
        stk = [[None]*3]
        for c in expression:                                
            if c == '(':                                            
                stk.append([None]*3)
            elif c in {')', '0', '1'}:
                if c == ')':
                    dp0, dp1, _ = stk.pop()
                else:
                    dp0, dp1 = int(c != '0'), int(c != '1')
                if stk[-1][2] == '&':
                    stk[-1] = [min(stk[-1][0], dp0),
                               min(stk[-1][1]+dp1, min(stk[-1][1], dp1)+1),
                               None]
                elif stk[-1][2] == '|':
                    stk[-1] = [min(stk[-1][0]+dp0, min(stk[-1][0], dp0)+1),
                               min(stk[-1][1], dp1),
                               None]
                else: 
                    stk[-1] = [dp0, dp1, None]
            else:
                stk[-1][2] = c
        return max(stk[0][0], stk[0][1])",O(n)
"class Solution:
    def numDecodings(self, s: str) -> int:

        def dfs(i):
            if i == len(s):
                return 1
            if s[i] == '0':
                return 0

            res = dfs(i + 1)
            if i < len(s) - 1:
                if (s[i] == '1' or
                   (s[i] == '2' and s[i + 1] < '7')):
                    res += dfs(i + 2)

            return res

        return dfs(0)
",O(2 ^ n)
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n,m=zzz()
arr = zzz()
s = sum(arr)
idx = [[] for i in range(m)]
for i in range(n):
    idx[arr[i]%m].append(i)

j=0
for i in range(m):
    while len(idx[i])>n//m:
        while True:
            if j<i:j+=1
            elif len(idx[j%m])>=n//m:
                j+=1
            else:break
        last = idx[i].pop()
        arr[last]+=(j-i)%m
        idx[j%m].append(last)
print(sum(arr)-s)
print(*arr)
",O(n)
"class SortedList:
    def __init__(self, iterable=None, _load=200):

        if iterable is None:
            iterable = []
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))
n,x,y=map(int,input().split())
xx=[]
for i in range(n):
    xx.append(tuple(map(int,input().split())))

xx.sort()

mod=10**9+7
tv=SortedList()
end=[]
c=0
an=0
for i in xx:

    if not len(tv):
        tv.add(i[1])
        an+=x+(i[1]-i[0])*y
    else:
        if tv[0]>=i[0]:
            tv.add(i[1])
            an =(an+ x + (i[1] - i[0]) * y)%mod
        else:
            pp=tv.bisect_left(i[0])-1
            tt=tv[pp]
            del tv[pp]
            tv.add(i[1])
            an=(an+min(x,(i[0]-tt)*y)+(i[1]-i[0])*y)%mod

print(an)",O(nlogn)
"x, y, z, t1, t2, t3 = [int(i) for i in input().split()]
if abs(z-x)*t2 + 3 * t3 + abs(x-y)*t2 <= abs(x-y)*t1:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):
        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
            if visited in lookup:
                return lookup[visited]

            mask = 1
            for i in range(maxChoosableInteger):
                if visited & mask == 0:
                    if i + 1 >= desiredTotal or \
                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):
                        lookup[visited] = True
                        return True
                mask <<= 1
            lookup[visited] = False
            return False

        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
            return False

        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})",O(n!)
"t = int(input())

for iter in range(t):
    n, k = map(int, input().split())
    if n >= 50:
        if k == 0:
            print(""YES "" + str(n))
        else:
            print(""YES "" + str(n - 1))
    else:
        a = [0] * (n + 1)
        b = [0] * (n + 1)
        c = [0] * (n + 1)
        a[0] = 0
        b[n] = 1
        c[n] = 0

        for i in range(1, n + 1):
            a[i] = 4 * a[i - 1] + 1
        for i in range(n - 1, -1, -1):
            b[i] = b[i + 1] * 2 + 1
        for i in range(n - 1, -1, -1):
            c[i] = c[i + 1] + b[i + 1]

        res = -1
        for d in range(n + 1):
            if c[d] <= k and k <= a[n] - a[d] * b[d]:
                res = d

        if res == -1:
            print(""NO"")
        else:
            print(""YES "" + str(res))
",O(logn)
"n,s=map(int,input().split())
mins=s
my_dict={}
mylist=[]
while(n):
	person,floor=map(int,input().split())
	mylist.append(person+floor)
	n-=1
val=max(mylist)
if(val<mins):
	print(mins)
else:
	print(val)",O(n)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush

from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")

n=L()[0]
A=sorted(L())
if A==[1]*n:
    print(*A[:n-1],2)
else:
    print(1,*A[:-1])

endtime = time.time()
",O(nlogn)
"n=int(input())
dict1={}
for i in range(n-1):
    x,y=map(int,input().split())
    try:
        dict1[y].append(x)
    except:
        KeyError
        dict1[y]=[x]
    try:
        dict1[x].append(y)
    except:
        KeyError
        dict1[x]=[y]
arr=list(map(int,input().split()))
if(arr[0]!=1):
    print(""No"")
else:
    j=0
    i=1
    flag=0
    while(i<n and j<n):
        if(arr[j] in dict1[arr[i]]):
            i+=1
        else:
            j+=1
    if(i!=n and j==n):
        print('No')
    else:
        print('Yes')
",O(n)
"import collections



class Solution(object):
    def findMatrix(self, nums):
        result = []
        cnt = collections.Counter()
        for x in nums:
            if cnt[x] == len(result):
                result.append([])
            result[cnt[x]].append(x)
            cnt[x] += 1
        return result",O(n)
"from collections import defaultdict

def E1():

    mod = 10 ** 9 + 7

    comb = [[1]]
    for i in range(1, 1010):
        x = [1]
        for j in range(1, i):
            x.append((comb[i - 1][j - 1] + comb[i - 1][j]) % mod)
        x.append(1)
        comb.append(x)

    dp = [1]
    for i in range(1, 1010):
        r = 0
        for k in range(i):
            r += dp[k] * comb[i - 1][k]
            r %= mod
        dp.append(r)

    m, n = map(int, input().split())

    ns = [0 for __ in range(m)]
    for j in range(n):
        temp = input()
        s = [int(i) for i in temp]
        for i in range(m):
            ns[i] |= s[i] << j

    dd = defaultdict(int)
    for e in ns:
        dd[e] += 1

    ans = 1
    for b in dd.values():
        ans = ans * dp[b] % mod

    print(ans)

if __name__=='__main__':
    E1()
",O(n ^ 2)
"n = int(input())

print(0, 0, n)
",O(1)
"from heapq import heappop, heappush

n, m, k = [int(i) for i in input().split()]
if k % 2 == 1:
    for _ in range(n):
        print("" "".join([""-1""] * m))
    exit()

E_right = []
for i in range(n):
    E_right.append([int(j) for j in input().split()])

E_down = []
for i in range(n - 1):
    E_down.append([int(j) for j in input().split()])

P = [[0 for _ in range(m)] for _ in range(n)]
new_P = [[0 for _ in range(m)] for _ in range(n)]

for k in range(k // 2 + 1):
    for i in range(n):
        for j in range(m):
            possible = []
            if i - 1 >= 0:
                e = E_down[i - 1][j]
                possible.append(P[i - 1][j] + e)

            if i + 1 < n:
                e = E_down[i][j]
                possible.append(P[i + 1][j] + e)

            if j - 1 >= 0:
                e = E_right[i][j - 1]
                possible.append(P[i][j - 1] + e)

            if j + 1 < m:
                e = E_right[i][j]
                possible.append(P[i][j + 1] + e)

            new_P[i][j] = min(possible)

    tmp = P
    P = new_P
    new_P = tmp

for i in range(n):
    print("" "".join(str(s * 2) for s in new_P[i]))
",O(n ^ 3)
"from math import *
k,n,s,p = map(int,input().split())
sheetsforone = ceil(n/s)
sheetsfork = sheetsforone*k
packs = ceil(sheetsfork/p)
print(int(packs))",O(1)
"import os,sys
from io import BytesIO,IOBase

def solve(s,t):
    if len(t) == 1:
        if s.count(t[0]):
            return 'YES'
        return 'NO'
    for i in range(1,len(t)):
        dp = [[-1000]*(i+1) for _ in range(len(s)+1)]
        dp[0][0] = 0
        for j in range(len(s)):
            dp[j+1] = dp[j][:]
            for k in range(i+1):
                if k != i and s[j] == t[k]:
                    dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k])
                if abs(dp[j][k]+i) < len(t) and s[j] == t[dp[j][k]+i]:
                    dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1)
        for l in range(len(s)+1):
            if dp[l][-1] == len(t)-i:
                return 'YES'
    return 'NO'

def main():
    for _ in range(int(input())):
        s = input().strip()
        t = input().strip()
        print(solve(s,t))

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(n ^ 3)
"import math
n=int(input())
lst = list(map(int, input().strip().split(' ')))
s=input()
for j in range(n):
    lst[j]=[lst[j],j+1]
lst.sort()
stk=[]
i=0
for j in range(2*n):
    if s[j]=='0':
        stk.append(lst[i][1])
        print(lst[i][1],end="" "")
        i+=1

    else:
        print(stk[-1],end="" "")
        stk.pop()
",O(nlogn)
"class Solution(object):
    def discountPrices(self, sentence, discount):
        result = []
        i = 0
        while i < len(sentence):
            j = sentence.find(' ', i)
            if j == -1: j = len(sentence)
            if sentence[i] == '$' and j-(i+1) > 0 and all(sentence[k].isdigit() for k in range(i+1, j)):
                cnt = reduce(lambda x, y: x*10+int(y), (sentence[k] for k in range(i+1, j)), 0)
                result.append(""${:d}.{:02d}"".format(*divmod(cnt*(100-discount), 100)))
            else:
                for k in range(i, j):
                    result.append(sentence[k])
            if j != len(sentence):
                result.append(' ')
            i = j+1
        return """".join(result)",O(n)
"n=int(input())
l=list(map(int,input().split()))
l.sort()
for x in range(1,n):
	if l[x]>l[0]:
		print(l[x])
		break
else:
	print('NO')",O(nlogn)
"n = int(input())

if(n>=0):
    print(n)
    exit()
else:
    n=str(abs(n))
    n1=int(n[:len(n)-1])

    temp=n[len(n)-1]

    n2=n[:len(n)-2]

    n2=int(n2+temp)

if(n1<=n2):
    if(n1!=0):
        print('-'+str(n1))
    else:
        print(0)
else:
    if(n2!=0):
        print('-'+str(n2))
    else:
        print(0)",O(1)
"class Solution(object):
    def isNumber(self, s):
        transition_table = [[-1,  0,  3,  1,  2, -1],    
                            [-1,  8, -1,  1,  4,  5],    
                            [-1, -1, -1,  4, -1, -1],    
                            [-1, -1, -1,  1,  2, -1],    
                            [-1,  8, -1,  4, -1,  5],    
                            [-1, -1,  6,  7, -1, -1],    
                            [-1, -1, -1,  7, -1, -1],    
                            [-1,  8, -1,  7, -1, -1],    
                            [-1,  8, -1, -1, -1, -1]]    

        state = 0
        for char in s:
            inputType = InputType.INVALID
            if char.isspace():
                inputType = InputType.SPACE
            elif char == '+' or char == '-':
                inputType = InputType.SIGN
            elif char.isdigit():
                inputType = InputType.DIGIT
            elif char == '.':
                inputType = InputType.DOT
            elif char == 'e' or char == 'E':
                inputType = InputType.EXPONENT

            state = transition_table[state][inputType]

            if state == -1:
                return False

        return state == 1 or state == 4 or state == 7 or state == 8",O(n)
"from random import randint

mod = 10**9 + 7
d = {}
n, m, l = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
def go(i, j, k):
    val = i * 40401 + j * 201 + k
    ret = 0
    if val in d:
        return d[val]
    elif i < n and j < m and k < l:
        ret = max(a[i] * b[j] + go(i + 1, j + 1, k), b[j] * c[k] + go(i, j + 1, k + 1), c[k] * a[i] + go(i + 1, j, k + 1))
    elif i < n and j < m:
        ret = a[i] * b[j] + go(i + 1, j + 1, k)
    elif j < m and k < l:
        ret = b[j] * c[k] + go(i, j + 1, k + 1)
    elif k < l and i < n:
        ret = c[k] * a[i] + go(i + 1, j, k + 1)
    d[val] = ret
    return ret

a.sort(reverse = True)
b.sort(reverse = True)
c.sort(reverse = True)
print(go(0, 0, 0))
",O(n ^ 3)
"n, m = map(int, input().split())
arr = list(map(int, input().split()))
d = {}
i = 1
for x in arr:
	if len(d) == m:
		break
	d[x] = i
	i += 1
if len(d) == m:
	print(min(d.values()), max(d.values()))
else:
	print(-1,-1)
",O(n)
"import sys
input = sys.stdin.readline

n=int(input())
P=list(map(int,input().split()))
mod=998244353

INV=[None]*(n+1)
for i in range(1,n+1):
    INV[i]=pow(i,mod-2,mod)

BLA=P.count(-1)

if BLA==0 or BLA==1:
    ANS=0
else:
    LEFT=BLA*(BLA-1)//2*INV[BLA]%mod
    AVEP=BLA*(BLA-1)//2*pow(BLA-1,mod-2,mod)

    ANS=LEFT*AVEP%mod

y=1
for i in range(BLA):
    y=y*(BLA-i)%mod

KOSUU=pow(y,mod-2,mod)
BLALIST=[1]*(n+1)
NONBLA=[]
BLANUM=[0]*n
for i in range(n):
    if P[i]!=-1:
        BLALIST[P[i]]=0
        BLANUM[i]=BLANUM[i-1]
        NONBLA.append(P[i])

    else:
        BLANUM[i]=BLANUM[i-1]+1

BLALIST[0]=0
for i in range(1,n+1):
    BLALIST[i]=BLALIST[i-1]+BLALIST[i]

if BLA!=0:
    for i in range(n):
        if P[i]!=-1:
            ANS=(ANS+(BLANUM[i]*(BLA-BLALIST[P[i]])+(BLA-BLANUM[i])*BLALIST[P[i]])*INV[BLA])%mod

A=NONBLA

if A==[]:
    print(ANS)
    sys.exit()

n=len(A)
MAXA=max(A)
MINA=min(A)

BIT=[0]*(MAXA-MINA+2)

for i in range(n):
    bitobje=A[i]-MINA+1

    x=bitobje
    while x!=0:
        ANS=(ANS-BIT[x])%mod
        x-=(x&(-x))

    x2=MAXA-MINA+1

    while x2!=0:

        ANS=(ANS+BIT[x2])%mod
        x2-=(x2&(-x2))

    y=bitobje
    while y<=MAXA-MINA+1:
        BIT[y]+=1
        y+=(y&(-y))

print(ANS)
",O(nlogn)
"n = int(input())
l = list(map(int, input().split()))
to = l.index(max(l))
ok = 1
for i in range(1, to):
    if (l[i] <= l[i - 1]):
        ok = 0
        break
for i in range(to + 1, n):
    if (l[i] >= l[i - 1]):
        ok = 0
        break
if ok:
    print('YES')
else:
    print('NO')",O(n)
"class Solution(object):
    def getNoZeroIntegers(self, n):
        a, curr, base = 0, n, 1
        while curr: 
            if curr % 10 == 0 or (curr % 10 == 1 and curr != 1):
                a += base
                curr -= 10 
            a += base
            base *= 10
            curr //= 10
        return [a, n-a]",O(logn)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,m = map(int,input().split())

A = [None]*n
lo,hi = 1<<32,-1<<32
for i in range(n):
    A[i] = list(map(int,input().split()))
    lo = min(min(A[i]), lo)
    hi = max(max(A[i]), hi)

best = -1
ans = [-1,-1]

def possible(x):
    global best, ans

    M = [-1]*(1<<m)

    for i in range(n):
        mask = 0
        for j in range(m):
            if A[i][j] >= x:
                mask += (1<<j)
        M[mask] = i

    for m0 in range(1<<m):
        if M[m0] == -1:
            continue

        for m1 in range(1<<m):
            if M[m1] == -1:
                continue

            if m0 | m1 == (1<<m) - 1:
                if best < x:
                    best = x
                    ans = [M[m0]+1, M[m1]+1]

                return True
    return False

possible(hi)
possible(lo)

while lo+1 < hi:
    mid = (lo+hi)//2
    if possible(mid):
        lo = mid
    else:
        hi = mid

print(*ans)
",np
"
class TrieNode(object):
    def __init__(self):
        self.is_string = False
        self.leaves = {}


class Solution(object):

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        cur = self.root
        for c in word:
            if not c in cur.leaves:
                cur.leaves[c] = TrieNode()
            cur = cur.leaves[c]
        cur.is_string = True

    def search(self, word):
        node = self.childSearch(word)
        if node:
            return node.is_string
        return False

    def startsWith(self, prefix):
        return self.childSearch(prefix) is not None

    def childSearch(self, word):
        cur = self.root
        for c in word:
            if c in cur.leaves:
                cur = cur.leaves[c]
            else:
                return None
        return cur


",O(n)
"n,m = map(int, input().split())
b = [int(s) for s in input().split()]
g = [int(s) for s in input().split()]
ans = 0
maxb2, maxb = sorted(b)[-2:]
ming = min(g)
if maxb > ming:
    ans = -1
else:
    ans += sum(b)*m
    ans += (sum(g)-ming)-(maxb*(m-1))
    if ming > maxb:
        ans += ming-maxb2
print(ans)",O(nlogn)
"import itertools
from functools import reduce



class Solution(object):
    def getSneakyNumbers(self, nums):
        def f(check):
            return reduce(lambda accu, x: accu^x, (x for x in itertools.chain(nums, range(n)) if check(x)), 0)

        n = len(nums)-2
        x_xor_y = f(lambda _: True)
        bit = x_xor_y&-x_xor_y
        return [f(lambda x: x&bit == 0), f(lambda x: x&bit != 0)]",O(n)
"from math import *
import sys

input = sys.stdin.readline

def bin_search(arr, n):

	pos = -1

	for i in range(35, -1, -1):
		jump = (1 << i)

		if (pos + jump) >= len(arr):
			continue

		if arr[pos + jump] <= n-1:
			pos += jump

	return len(arr) - pos - 1

def main():
	n, m = [int(x) for x in input().split(' ')]

	vert = []
	for i in range(n):
		vert.append(int(input()))

	hor = []
	for i in range(m):
		col1, col2, row = [int(x) for x in input().split(' ')]

		if col1 != 1:
			continue

		hor.append((col2))

	vert.append(1000000000)

	vert = sorted(vert)
	hor = sorted(hor)

	best = int(1e10)

	for i in range(len(vert)):
		cur_ans = bin_search(hor, vert[i]) + i
		best = min(best, cur_ans)

	print(best)

if __name__ == ""__main__"":
	main()",O(nlogn)
"def primecheck(x):
	cnt=0
	for i in range(2,x//2 +1):
		if x%i == 0:
			cnt+=1
			break
	if cnt :
		return 1
	else:
		return 0

n = int(input())
for i in range(4,n):
	if primecheck(i) == 1 and primecheck(n-i) == 1:
		print(str(i) + "" ""+ str(n-i))
		break",O(1)
"def sum(n):
    return (n * (n + 1)) // 2

def range_sum(left, right):
    return sum(right) - sum(left - 1)

def binary_search(k, n):
    low, high, mid = 1, k, 0

    while low <= high:
        mid = (low + high) // 2
        s = range_sum(mid, k)

        if s == n:
            return k - mid + 1
        elif s > n:
            low = mid + 1
        else:
            high = mid - 1

    return k - low + 2

n, k = map(int, input().split(' '))
if n == 1:
    print(0)
elif n <= k:
    print(1)
else:
    n -= 1
    k -= 1

    if n > sum(k):
        print(-1)
    else:
        print(binary_search(k, n))
",O(logn)
"n, m = map(int, input().split())
k = list(map(int, input().split()))
p = list(map(int, input().split()))
a = 0
b = 0
ans = 0
while a != n and b != m:
    if p[b] >= k[a]:
        ans += 1
        a += 1
        b += 1
    else:
        a += 1
print(ans)
",O(n)
"n = int(input())
print(0, 0, n)",O(1)
"N,L,H,d = map(int, input().split())

l = list(map(int, input().split()))
e = 0
for i in range(1 << N ):
    k = []
    for j in range(N):
        if i >> j & 1:
            k.append(l[j])
    if len(k)>0:
        maz = max(k)
        mins = min(k)
        sums = sum(k)
        if sums >= L and sums <=H:
            if maz - mins >=d:
                e+=1
print(e)",np
"n = int(input())
if n == 1:
    print(5)
else:
    print(25)
",O(1)
"from math import sin, pi
n, r = map(int, input().split())

def p(n, r):
    return 2 * n * r * sin(pi / n)

le = 0; ri = r * 1000
while ri - le > 1e-9:
    m = (ri + le) / 2
    if p(n, r + m) < n * m * 2:
        ri = m
    else:
        le = m
print(m)",O(1)
"class Solution(object):
    def moveZeroes(self, nums):
        pos = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[i], nums[pos] = nums[pos], nums[i]
                pos += 1

    def moveZeroes2(self, nums):
        nums.sort(cmp=lambda a, b: 0 if b else -1)",O(n)
"import collections


class Solution(object):
    def distinctSubseqII(self, S):
        MOD = 10**9+7
        result, dp = 0, [0]*26
        for c in S:
            result, dp[ord(c)-ord('a')] = (result+((result+1)-dp[ord(c)-ord('a')]))%MOD, (result+1)%MOD
        return result",O(n)
"import collections


class Solution(object):
    def numSquarefulPerms(self, A):
        def dfs(candidate, x, left, count, result):
            count[x] -= 1
            if left == 0:
                result[0] += 1
            for y in candidate[x]:
                if count[y]:
                    dfs(candidate, y, left-1, count, result)
            count[x] += 1

        count = collections.Counter(A)
        candidate = {i: {j for j in count if int((i+j)**0.5) ** 2 == i+j} 
                           for i in count}

        result = [0]
        for x in count:
            dfs(candidate, x, len(A)-1, count, result)
        return result[0]",O(n!)
"class Solution(object):
    def minSwaps(self, s):
        def cost(s, x): 
            diff = 0 
            for c in s:
                diff += int(c) != x
                x ^= 1
            return diff//2
    
        ones = s.count('1')
        zeros = len(s)-ones 
        if abs(ones-zeros) > 1:
            return -1
        if ones > zeros:
            return cost(s, 1)
        if ones < zeros:
            return cost(s, 0)
        return min(cost(s, 1), cost(s, 0))",O(n)
"import collections

import sys

N = int(input())
p = [int(x) for x in input().split()]

G = collections.defaultdict(list)

for i, v in enumerate(p):
    u = i + 2
    G[u].append(v)
    G[v].append(u)

root = 1

colors = [0] * (N + 1)
counts = [0] * (N + 1)

q = [root]
parents = [0] * (N+1)
vis = [0] * (N+1)
while q:
    u = q.pop()
    if vis[u]:
        colors[parents[u]] += colors[u]
        continue
    children = [v for v in G[u] if v != parents[u]]
    for v in children:
        parents[v] = u

    if children:
        vis[u] = True
        q.append(u)
        q.extend(children)
    else:
        vis[u] = True
        colors[u] = 1
        colors[parents[u]] += 1

colors.sort()
print(' '.join(map(str, colors)))
",O(n ^ 2)
"actions, end_total_candies = [int(i) for i in input().split()]
candies = 1
if(actions == 1):
    print(0)
else:
    for i in range(1, actions):
        candies = candies + i + 1

        if(candies >= end_total_candies + (actions - i - 2)):
            print(candies - end_total_candies)
            exit()
",O(logn)
"class Solution(object):
    def evenProduct(self, nums):
        result = (len(nums)+1)*len(nums)//2
        cnt = 0
        for x in nums:
            cnt = cnt+1 if x%2 else 0
            result -= cnt
        return result",O(n)
"import math

n, r = map(int, input().split())
angle = math.pi / n
s = math.sin(angle)

print('%.8f' % (r * s / (1 - s)))
",O(1)
"ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())
if ax > bx:
    ax, bx = bx, ax
    ay, by = by, ay
if ax > cx:
    ax, cx = cx, ax
    ay, cy = cy, ay
if bx > cx:
    bx, cx = cx, bx
    by, cy = cy, by
ans = []
for i in range(min(ay, by, cy), max(ay, by, cy) + 1):
    ans.append([bx, i])
for i in range(ax, bx):
    ans.append([i, ay])
for i in range(bx + 1, cx + 1):
    ans.append([i, cy])
print(len(ans))
for x in ans:
    print(x[0], x[1])
",O(1)
"class Solution(object):

    def __init__(self, value, k):
        self.__value = value
        self.__k = k
        self.__cnt = 0

    def consec(self, num):
        if num == self.__value:
            self.__cnt += 1
        else:
            self.__cnt = 0
        return self.__cnt >= self.__k",O(1)
"class Solution3(object):
    def hIndex(self, citations):
        return sum(x >= i + 1 for i, x in enumerate(sorted(citations, reverse=True)))",O(nlogn)
"n = int(input())
a = []
for i in range(1, n + 1):
    l, r = map(int, input().split())
    a.append([l, -r, i])
a.sort()
hh = a[0][1]
wahh = max(-1, a[0][2])
for i in range(1, n):
    if a[i][1] >= hh:
        print(a[i][2], wahh)
        exit()
    else:
        hh = a[i][1]
        wahh = a[i][2]
print(-1, -1)
",O(nlogn)
"n = int(input())
l = []
for i in range(n):
    x, y = map(int, input().split())
    l += [(x + y, x - y)]
l.sort()
r = -2000000000
a = 0
for u in l:
    if u[1] >= r:
        a += 1
        r = u[0]
print(a)
",O(nlogn)
"def push(d, u, v):
    if u not in d:
        d[u] = []
    if v not in d:
        d[v] = []
    d[u].append(v)
    d[v].append(u)

def push_v(d, u, val):
    if u not in d:
        d[u] = 0
    d[u] += val

n, k = map(int, input().split())
g    = {}

for _ in  range(n-1):
    u, v = map(int, input().split())
    push(g, u, v)

deg1 = []
used = [0] * (n+1)

for u in g:
    if len(g[u]) == 1:
        used[u]  = 1
        deg1.append(u)

flg = True
while k > 0:
    if k >= 1 and len(deg1) < 3:
        flg=False
        break

    cnt = {}
    for u in deg1:
        for v in g[u]:
            if used[v] == 0:
                push_v(cnt, v, 1)

    for v in deg1:
        used[v] = 1

    deg1 = []

    for v, val in cnt.items():
        if val < 3:
            flg=False
            break
        deg1.append(v)

    if flg==False:
        break
    k-=1

if flg==True and len(deg1) > 1:
    flg=False

if flg==False:
    print('NO')
else:
    print('YES')
",O(nlogn)
"class Solution(object):
    def findTilt(self, root):
        def postOrderTraverse(root, tilt):
            if not root:
                return 0, tilt
            left, tilt = postOrderTraverse(root.left, tilt)
            right, tilt = postOrderTraverse(root.right, tilt)
            tilt += abs(left-right)
            return left+right+root.val, tilt

        return postOrderTraverse(root, 0)[1]",O(n)
"class Solution(object):
    def isGoodArray(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result = nums[0]
        for num in nums:
            result = gcd(result, num)
            if result == 1:
                break
        return result == 1",O(n)
"def chnge(last,cap,ini=(0,0)):
    for i in range(ini[1],last[1]):
        fin[i][ini[0]:last[0]] = [cap]*(last[0]-ini[0])

x1,y1,x2,y2,x3,y3 = map(int,input().split())
a = (max(x1,y1),[x1,y1],""A"")
b = (max(x2,y2),[x2,y2],""B"")
c = (max(x3,y3),[x3,y3],""C"")
m = max(a[0],b[0],c[0])
fin = [[""*"" for i in range(m)] for j in range(m)]

if (x1*y1 + x2*y2 + x3*y3)!=m**2:
    print(-1)
else:
    l = sorted([a]+[b]+[c],reverse = True)
    l[0][1].sort(reverse=True)
    chnge(l[0][1],l[0][2])
    ini=[0,l[0][1][1]]
    last = l[1][1]
    if m in [ini[0]+last[0],ini[1]+last[1]] and (ini[0]+last[0]+ini[1]+last[1])<=2*m:
        last = [ini[0]+last[0],ini[1]+last[1]]
    else:
        last = [ini[0] + last[1], ini[1] + last[0]]
    chnge(last,l[1][2],ini)
    chr = l[2][2]
    print(m)
    for i in fin:
        print("""".join(i).replace(""*"",chr))",np
"import re
import string
import math

letter_number_pattern = ""[a-zA-Z]*[0-9]*""

alpha = dict(zip(range(1,28), string.ascii_uppercase))
decimals = dict(zip(string.ascii_uppercase, range(1,27)))

alpha_len = len(alpha)

def letter_to_decimal(n):
    exponents = []
    pow_i = 0
    while True:
        if n // (26**pow_i) > 26:
            exponents.append(1)
            n = n - (26**pow_i)
            pow_i += 1
        else:
            exponents.append(n // (26**pow_i))
            n = n - ((n // (26**pow_i)) * (26**pow_i))
            break
    pow_i = pow_i - 1
    while n != 0:
        t = n // (26**pow_i)
        n = n - (t * (26 ** pow_i))
        exponents[pow_i] = exponents[pow_i] + t
        pow_i = pow_i - 1
    result = ''.join(list(map(lambda x: alpha[x], reversed(exponents))))
    return result

def letters_to_deci(letters):
    total_sum = 0
    pows = list(reversed(range(len(letters))))
    for i in range(len(letters)):
        total_sum += decimals[letters[i]] * (26**pows[i])
    return total_sum

input_cells = []

n_lines = input()
for i in range(int(n_lines)):
    input_cells.append(input())

for cell in input_cells:
    all_matches = re.findall(letter_number_pattern, cell)[:-1]
    if len(all_matches) == 2:
        rows = int(re.search(""[0-9]*$"", all_matches[0]).group())
        cols = int(re.search(""[0-9]*$"", all_matches[1]).group())
        converted_cols = letter_to_decimal(cols)
        print(""%s%s"" % (converted_cols, rows))
    elif len(all_matches) == 1:
        rows = re.match(""[A-Z]*"", all_matches[0]).group()
        cols = re.search(""[0-9]*$"", all_matches[0]).group()
        converted_rows = letters_to_deci(rows)
        print(""R%sC%s"" % (cols, converted_rows))
    else:
        pass",O(n)
"import collections


class Solution(object):
    def findLeastNumOfUniqueInts(self, arr, k):
        count = collections.Counter(arr)
        result, count_count = len(count), collections.Counter(iter(count.values()))
        for c in range(1, len(arr)+1): 
            if k < c*count_count[c]:
                result -= k//c
                break
            k -= c*count_count[c]
            result -= count_count[c]                
        return result",O(n)
"import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

n,m = mints()
a = list(mints())
b = list(mints())
l = [None]*(n+m)
r = [None]*(n+m)
c = [0]*(n+m)
x = None
for i in range(len(a)):
	l[i] = x
	if b[i] == 1:
		x = i
x = None
for i in range(len(a)-1,-1,-1):
	r[i] = x
	if b[i] == 1:
		x = i
for i in range(len(a)):
	if b[i] == 0:
		aa = a[i]
		ll = l[i]
		rr = r[i]
		if ll == None:
			if rr != None:
				c[rr] += 1
		elif rr == None:
			c[ll] += 1
		else:
			if aa-a[ll] <= a[rr]-aa:
				c[ll] += 1
			else:
				c[rr] += 1

for i in range(len(a)):
	if b[i] == 1:
		print(c[i], end=' ')
",O(n)
"class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2:
            return False

        def dfs(i, target):
            if i >= len(nums):
                return target == 0
            if target < 0:
                return False

            return dfs(i + 1, target) or dfs(i + 1, target - nums[i])

        return dfs(0, sum(nums) // 2)
",O(2 ^ n)
"from sys import stdin, stdout

def pair_of_lines(n, xy_a):
    if len(xy_a) <= 3:
        return 'YES'

    p1, p2, p3 = xy_a[0], xy_a[1], xy_a[2]
    if judge(p1, kstr(p1, p2),xy_a):
        return 'YES'
    if judge(p1, kstr(p1, p3),xy_a):
        return 'YES'
    if judge(p2, kstr(p2, p3), xy_a):
        return 'YES'
    return 'NO'

def kstr(xy1, xy2):
    cx, cy = xy1[0], xy1[1]
    x, y = xy2[0], xy2[1]
    dx = x - cx
    dy = y - cy
    k = ''
    if dx == 0:
        k = str(x) + '/y'
    elif dy == 0:
        k = 'x/' + str(y)
    else:
        g = gcd(dx, dy)
        dx //= g
        dy //= g
        k = str(dx) + '/' + str(dy)
    return k

def judge(p, k, xy_a):

    rl = []
    for xy in xy_a:
        if p[0] == xy[0] and p[1] == xy[1]:
            continue
        if kstr(p, xy) != k:
            rl.append(xy)

    if len(rl) > 2:
        ck = kstr(rl[0], rl[1])
        for i in range(2, len(rl)):
            if ck != kstr(rl[0], rl[i]):
                return False

    return True

def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)

try:
    n = int(stdin.readline())
    xy_a = []
    for _ in range(n):
        xy_a.append(list(map(int, stdin.readline().split())))
    res = pair_of_lines(n, xy_a)
    stdout.write(res)
except Exception as e:
  print(e)
",O(nlogn)
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2024)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])",O(n ^ 3)
"n, U = list(map(int, input().split()))
E = list(map(int, input().split()))

ind_i = 0
prev_ind_k = ind_i + 2

maxi_efficiency = -1
turn = 0
for ind_i in range(0, n - 2):
    ind_j = ind_i + 1
    prev_ind_k = max(prev_ind_k, ind_i + 2)
    Ei = E[ind_i]
    Ej = E[ind_j]
    for ind_k in range(prev_ind_k, n + 1):

        if ind_k == n:
            prev_ind_k = n - 1
            break
        Ek = E[ind_k]
        if (Ek - Ei) > U:
            prev_ind_k = ind_k - 1
            break

        efficiency = (Ek - Ej) / (Ek - Ei)

        if efficiency > maxi_efficiency:

            maxi_efficiency = efficiency

print(maxi_efficiency)
",O(nlogn)
"class Solution(object):
    def sumDistance(self, nums, s, d):
        MOD = 10**9+7
        for i in range(len(nums)):
            nums[i] += d if s[i] == 'R' else -d
        nums.sort()
        return reduce(lambda x, y: (x+y)%MOD, ((i-(len(nums)-(i+1)))*x for i, x in enumerate(nums)))",O(nlogn)
"from sys import stdin
s=stdin.readline()
for ln in range(len(s),0,-1):
    for L in range(len(s)-ln+1):
        if s[L:L+ln] in s[L+1:]:
            print(ln)
            exit()
print(0)",O(n ^ 3)
"def main():
    input()
    acc = {0: 0}
    for p, c in zip(list(map(int, input().split())),
                    list(map(int, input().split()))):
        adds = []
        for b, u in acc.items():
            a = p
            while b:
                a, b = b, a % b
            adds.append((a, u + c))
        for a, u in adds:
            acc[a] = min(u, acc.get(a, 1000000000))
    print(acc.get(1, -1))

if __name__ == '__main__':
    main()
",np
"import sys
input = sys.stdin.readline

n, k = map(int, input().split())
s = input()[:-1]
left, right = 0, n
while left < right:
    mid = right - (right - left) // 2
    A = [[0] * (n + 2) for _ in range(k)]

    for c in range(k):
        A[c][n] = A[c][n + 1] = n + 1
        L = 0
        for i in range(n - 1, -1, -1):
            if s[i] == '?' or ord(s[i]) - ord('a') == c: L += 1
            else: L = 0
            A[c][i] = i + mid if L >= mid else A[c][i + 1]

    dp = [n + 1] * (1 << k)
    dp[0] = 0
    for mask in range(1 << k):
        for i in range(k):
            if mask >> k & 1: continue
            t = mask | 1 << i
            dp[t] = min(dp[t], A[i][dp[mask]])
    if dp[-1] <= n: left = mid
    else: right = mid - 1
print(left)",np
"n, m, k, l = map(int, input().split())
k += l
x = (k + m - 1) // (m);
if m * x > n:
    print(-1)
else:
    print(x)",O(1)
"class Solution(object):
    def minimumOperations(self, nums):
        return sum(x%3 != 0 for x in nums)",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def getAllElements(self, root1, root2):
        def inorder_gen(root):
            result, stack = [], [(root, False)]
            while stack:
                root, is_visited = stack.pop()
                if root is None:
                    continue
                if is_visited:
                    yield root.val
                else:
                    stack.append((root.right, False))
                    stack.append((root, True))
                    stack.append((root.left, False))
            yield None
        
        result = []
        left_gen, right_gen = inorder_gen(root1), inorder_gen(root2)
        left, right = next(left_gen), next(right_gen)
        while left is not None or right is not None:
            if right is None or (left is not None and left < right):
                result.append(left)
                left = next(left_gen)
            else:
                result.append(right)
                right = next(right_gen)
        return result",O(n)
"import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
l,r=list(map(int,input().split()))
if l==r:
    print(0)
else:
    a=bin(l)[2:]
    b=bin(r)[2:]
    x=len(a)
    y=len(b)
    if x!=y:
        ans=0
        for i in range(y):
            ans+=(2**i)
        print(ans)
    else:
        for i in range(x):
            if a[i]!=b[i]:
                ind=i
                break
        l=x-ind
        ans=0
        for i in range(l):
            ans+=(2**i)
        print(ans)
",O(logn)
"from sys import stdin,stdout
input=stdin.readline

def count(audrey,imba,banget):
    return((imba-audrey-1)%(banget-1))

n,q=map(int,input().split())
L=list(map(int,input().split()))
maxi=max(L)
indexmax=L.index(maxi)
P=[]
for i in range(indexmax):
    P.append((L[0],L[1]))
    if L[0]<L[1]:
        L.append(L.pop(0))
    else:
        L.append(L.pop(1))
Y=tuple(L[1:])
for p in range(q):
    m=int(input())
    if m<=indexmax:
        print(str(P[m-1][0])+' '+str(P[m-1][1]))
    else:
        stdout.write(str(maxi)+' '+str(Y[count(indexmax,m,n)])+'\n')",O(n)
"import sys
from array import array
import typing as Tp

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def main():
    l, r, k = map(int, input().split())

    valid_bits, is_valid_bits = [], [0] * 1024

    for bit in range(1024):
        if bin(bit).count('1') <= k:
            valid_bits.append(bit)
            is_valid_bits[bit] = 1

    mod = 998244353

    def solve(ub):
        dp = array('i', [0]) * 1024
        dp_cnt = array('i', [0]) * 1024
        next_dp = array('i', [0]) * 1024
        next_dp_cnt = array('i', [0]) * 1024
        boundary_dp, b_bit = 0, 0

        for e, digit in zip(range(len(str(ub)) - 1, -1, -1), map(int, str(ub))):
            base = pow(10, e, mod)

            for bit in valid_bits:
                for d in range(10):
                    nextbit = bit | (1 << d)
                    if is_valid_bits[nextbit]:
                        next_dp[nextbit] = (
                            next_dp[nextbit] + dp[bit]
                            + base * d * dp_cnt[bit]
                        ) % mod

                        next_dp_cnt[nextbit] += dp_cnt[bit]
                        if next_dp_cnt[nextbit] >= mod:
                            next_dp_cnt[nextbit] -= mod

            for d in range(digit):
                nextbit = b_bit | (1 << d)
                if is_valid_bits[nextbit]:
                    next_dp[nextbit] = (
                        next_dp[nextbit] + boundary_dp + base * d
                    ) % mod
                    next_dp_cnt[nextbit] += 1

            b_bit |= (1 << digit)
            boundary_dp = (boundary_dp + base * digit) % mod

            for i in valid_bits:
                dp[i] = next_dp[i]
                dp_cnt[i] = next_dp_cnt[i]
                next_dp[i] = next_dp_cnt[i] = 0

            dp[0], dp_cnt[0] = 0, 1
            dp[1] = dp_cnt[1] = 0

        return (sum(dp) + (boundary_dp if is_valid_bits[b_bit] else 0)) % mod

    print((solve(r) - solve(l - 1)) % mod)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"tam,q = [int(i) for i in input().split()]
t = input()
s = t

posi = -1

for j in range(tam-1):
    if(t[:j+1] == t[tam - j -1:]):
        posi = j

add = t[posi+1:]

for j in range(q-1):
    s += add

print(s)
",O(n ^ 2)
"class Solution(object):
    def longestBeautifulSubstring(self, word):
        result = 0
        l = cnt = 1
        for i in range(len(word)-1):
            if word[i] > word[i+1]:
                l = cnt = 1
            else:
                l += 1
                cnt += int(word[i] < word[i+1])
            if cnt == 5:
                result = max(result, l)
        return result",O(n)
"a = list(input())
b = int(input())
a.sort(reverse=True)

ans=''
while a:
    for i in range(len(a)):
        temp=''
        x=ans+a[i]+temp.join(sorted(a[:i]+a[i+1:]))
        if int(x)<=b:
            ans+=a[i]
            a=a[:i]+a[i+1:]
            break
print(int(ans))",O(n ^ 3)
"import math
import sys

def minPut(n):
    return math.ceil((-1 + math.sqrt(1-4*(-n*2))) / 2)
def nCandies(n):
    return int(n*(n+1)/2)

actions, candies = map(int, sys.stdin.readline().split())

put = minPut(candies)
putCandies = nCandies(put)

eat = putCandies - candies

while put + eat < actions:
    eat += put + 1
    put += 1

print(eat)",O(logn)
"import sys
input=sys.stdin.readline
def getsum(BITTree,i):
    i=i+1
    s = 0
    while i > 0:
        s += BITTree[i]
        i -= i & (-i)
    return(s)
def updatebit(BITTree , n , i ,v):
    i=i+1
    while i <= n:
        BITTree[i] += v
        i += i & (-i)

n=int(input())
lista=[int(i) for i in input().split()]
invercount=0
bitTree=[0]*(n+2)
for k in reversed(lista):
        updatebit(bitTree,n+1,k,1)
        counter=getsum(bitTree,k-1)
        invercount+=counter
m=int(input())
for i in range(m):
    l,r=map(int,input().split())
    summa=((r-l+1)*(r-l))/2
    if (invercount+summa)%2:
        print('odd')
        invercount=1
    else:
        print('even')
        invercount=0
",O(n ^ 2)
"from collections import Counter
import sys
input = sys.stdin.readline
n = int(input())
a = list(map(int, input().split()))
mod = 998244353
a.sort()
dp = [1] + [0] * n
for i in range(1, n + 1):
    x, pt = 1, i - 2
    while pt >= 0 and 2 * a[pt] > a[i - 1]:
        x = x * (n - pt - 2) % mod
        pt -= 1
    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod
print(dp[-1])",O(n ^ 3)
"from collections import Counter


class Solution2(object):
    def lengthOfLongestSubstringKDistinct(self, s, k):
        counter = Counter()
        left, max_length = 0, 0
        for right, char in enumerate(s):
            counter[char] += 1
            while len(counter) > k:
                counter[s[left]] -= 1
                if counter[s[left]] == 0:
                    del counter[s[left]]
                left += 1
            max_length = max(max_length, right-left+1)
        return max_length",O(n)
"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        mp = defaultdict(int)
        for i in range(len(numbers)):
            tmp = target - numbers[i]
            if mp[tmp]:
                return [mp[tmp], i + 1]
            mp[numbers[i]] = i + 1
        return []
",O(n)
"class Solution2(object):
    def balanceBST(self, root):
        def inorderTraversalHelper(node, arr):
            if not node:
                return
            inorderTraversalHelper(node.left, arr)
            arr.append(node.val)
            inorderTraversalHelper(node.right, arr)
        
        def sortedArrayToBstHelper(arr, i, j):
            if i >= j:
                return None
            mid = i + (j-i)//2
            node = TreeNode(arr[mid])
            node.left = sortedArrayToBstHelper(arr, i, mid)
            node.right = sortedArrayToBstHelper(arr, mid+1, j)
            return node
        
        arr = []
        inorderTraversalHelper(root, arr)
        return sortedArrayToBstHelper(arr, 0, len(arr))",O(n)
"candies = 0
n, k = map(int,input().split())
summ = 0
if k == 0:
    for i in range (n-1,-1,-1):
        summ = summ + 1
        candies = candies + summ
        if candies == i:
            print(i)
            break

if k != 0:
    for i in range (n-1,-1,-1):
        summ = summ + 1
        candies = candies + summ
        if candies - i == k:
            print(i)
            break
",O(logn)
"import collections
import itertools


class Solution(object):
    def movesToChessboard(self, board):
        N = len(board)
        result = 0
        for count in (collections.Counter(list(map(tuple, board))), \
                      collections.Counter(zip(*board))):
            if len(count) != 2 or \
               sorted(count.values()) != [N/2, (N+1)/2]:
                return -1

            seq1, seq2 = count
            if any(x == y for x, y in zip(seq1, seq2)):
                return -1
            begins = [int(seq1.count(1) * 2 > N)] if N%2 else [0, 1]
            result += min(sum(int(i%2 != v) for i, v in enumerate(seq1, begin)) \
                          for begin in begins) / 2
        return result",O(n ^ 2)
"class Solution(object):
    def longestNiceSubarray(self, nums):
        result = left = curr = 0
        for right in range(len(nums)):
            while curr&nums[right]:
                curr ^= nums[left]
                left += 1
            curr |= nums[right]
            result = max(result, right-left+1)
        return result",O(n)
"class Solution(object):
    def countArrangement(self, N):
        def countArrangementHelper(n, arr):
            if n <= 0:
                return 1
            count = 0
            for i in range(n):
                if arr[i] % n == 0 or n % arr[i] == 0:
                    arr[i], arr[n-1] = arr[n-1], arr[i]
                    count += countArrangementHelper(n - 1, arr)
                    arr[i], arr[n-1] = arr[n-1], arr[i]
            return count

        return countArrangementHelper(N, list(range(1, N+1)))",O(n!)
"import itertools

def q121a_v2():
	good_num_arr = generate_47_arr()
	num = int(input())
	for element in good_num_arr:
		if(num % element == 0):
			print(""YES"")
			return
	print(""NO"")

def generate_47_arr():
	arr = []
	for digits in range(1, 4):
		arr += itertools.product(""47"", repeat=digits)
	for i in range(len(arr)):
		arr[i] = int("""".join(list(arr[i])))
	arr.append(4444444444)
	return arr

q121a_v2()",O(1)
"n=int(input())
a=list(map(int,input().split()))
a.sort()

total_money=sum(a)
i_have=0
reaming=total_money-i_have
cnt=0
for i in range(n-1,-1,-1):
    reaming=total_money-i_have
    if i_have>reaming:
        break
    i_have+=a[i]
    cnt+=1
print(cnt)",O(nlogn)
"import sys
input = sys.stdin.readline

n,m,k=map(int,input().split())
P=[input().strip() for i in range(n)]
S=[input().split() for i in range(m)]

for i in range(m):
    S[i][1]=int(S[i][1])-1

PDICT=dict()
for i in range(n):
    PDICT[P[i]]=i

E=[]

for i in range(m):
    x=S[i][0]
    LIST=[]

    for j in range(1<<k):
        t=""""
        for l in range(k):
            if (1<<l) & j != 0:
                t+=""_""
            else:
                t+=x[l]

        if t in PDICT:
            LIST.append(PDICT[t])

    if not (S[i][1] in LIST):
        print(""NO"")
        exit()

    else:
        s=S[i][1]
        for l in LIST:
            if l==s:
                continue
            else:
                E.append((s,l))

EDGEIN=[0]*n
EDGEOUTLIST=[[] for i in range(n)]
for x,y in E:
    EDGEIN[y]+=1
    EDGEOUTLIST[x].append(y)

from collections import deque
QUE = deque()

for i in range(n):
    if EDGEIN[i]==0:
        QUE.append(i)

TOP_SORT=[]
while QUE:
    x=QUE.pop()
    TOP_SORT.append(x)
    for to in EDGEOUTLIST[x]:
        EDGEIN[to]-=1
        if EDGEIN[to]==0:
            QUE.appendleft(to)

if len(TOP_SORT)==n:
    print(""YES"")
    print(*[i+1 for i in TOP_SORT])
else:
    print(""NO"")
",np
"class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        l, r = 0, len(matrix) - 1
        while l < r:
            for i in range(r - l):
                top, bottom = l, r

                topLeft = matrix[top][l + i]

                matrix[top][l + i] = matrix[bottom - i][l]

                matrix[bottom - i][l] = matrix[bottom][r - i]

                matrix[bottom][r - i] = matrix[top + i][r]

                matrix[top + i][r] = topLeft
            r -= 1
            l += 1
",O(n ^ 2)
"x, k = map(int, input().split())
mod = 10**9+7
e = (x * pow(2, k, mod)) % mod
s = (e - pow(2, k, mod)) % mod
f = lambda x: (x*(x+1))%mod
ans = ((f(e) - f(s)) * pow(2, k*(mod-2), mod))%mod
print(ans if x != 0 else 0)",O(logn)
"n, k = map(int, input().split())
ps = list(map(int, input().split()))

g = [None for i in range(256)]
f = [None for i in range(256)]
ans = []
for i in range(n):
    p = ps[i]
    if g[p] is not None:
        ans.append(g[p])
        f[p] = 1
    else:
        gb= 0
        for j in range(k):
            ind = p - j
            if f[ind] is not None:
                gb = ind +1
                break
            if ind <= 0:
                break
            if j == k-1:
                gb = ind
        ans.append(gb)
        for j in range(k):
            if gb+j >= 256:
                break
            if f[gb + j] is None:
                g[gb+j] = gb
            else:
                break
        f[gb] = 1
        f[p] = 1
print(' '.join([str(i) for i in ans]))",O(n ^ 2)
"x, k = map(int, input().split())
if x == 0:
    print(0)
else:
    mod = 1000000007
    ans = x * pow(2, k + 1, mod) - pow(2, k, mod) + 1
    print(ans % mod)
",O(logn)
"import math
n, k = map(int, input().split())

q = int(-3 + math.sqrt(9 + 8*(n+k)))//2

r = n-q

print(r)",O(1)
"n, m = map(int, input().split())
print(m // n + (1 if m % n else 0))
",O(1)
"n = int(input())
lst = list(map(int, input().split()))
cur = 1
if n == 1:
    print(1)
    exit()
if lst[cur] > lst[cur - 1]:
    a = [1]
elif lst[cur] < lst[cur - 1]:
    a = [5]
else:
    a = [3]
pr = False
while cur != n:
    cnt = 0

    if lst[cur] > lst[cur - 1]:
        while cur != n and lst[cur] > lst[cur - 1]:
            cnt += 1
            cur += 1
        for i in range(cnt - 1):
            a.append(a[-1] + 1)
            if a[-1] >= 5:
                print(-1)
                exit()
        if n != cur and lst[cur] == lst[cur - 1]:
            a.append(a[-1] + 1)
        else:
            a.append(5)

    elif lst[cur] < lst[cur - 1]:
        while cur != n and lst[cur] < lst[cur - 1]:
            cnt += 1
            cur += 1
        for i in range(cnt - 1):
            a.append(a[-1] - 1)
            if a[-1] <= 1:
                print(-1)
                exit()
        if n != cur and lst[cur] == lst[cur - 1]:
            a.append(a[-1] - 1)
        else:
            a.append(1)
    else:
        while cur != n and lst[cur] == lst[cur - 1]:
            cnt += 1
            cur += 1

        for i in range(cnt - 1):
            if a[-1] < 3:
                a.append(a[-1] + 1)
            else:
                a.append(a[-1] - 1)

        if cur != n and lst[cur] > lst[cur - 1]:
            if a[-1] == 1:
                a.append(2)
            else:
                a.append(1)
        else:
            if a[-1] == 5:
                a.append(4)
            else:
                a.append(5)
print(*a)
",O(n ^ 2)
"from sys import stdin,stdout
def count(audrey,imba,banget):
    return((imba-audrey-1)%(banget-1))

n,q=map(int,input().split())
L=list(map(int,input().split()))
maxi=max(L)
indexmax=L.index(maxi)
P=[]
for i in range(indexmax):
    P.append((L[0],L[1]))
    if L[0]<L[1]:
        L.append(L.pop(0))
    else:
        L.append(L.pop(1))
Y=tuple(L[1:])
for p in range(q):
    m=int(stdin.readline())
    if m<=indexmax:
        print(str(P[m-1][0])+' '+str(P[m-1][1]))
    else:
        stdout.write(str(maxi)+' '+str(Y[count(indexmax,m,n)])+'\n')",O(n)
"import operator
from functools import reduce


class Solution2(object):
    def xorOperation(self, n, start):
        return reduce(operator.xor, (i for i in range(start, start+2*n, 2)))",O(n)
"class Solution(object):
    def arrayNesting(self, nums):
        result = 0
        for num in nums:
            if num is not None:
                start, count = num, 0
                while nums[start] is not None:
                    temp = start
                    start = nums[start]
                    nums[temp] = None
                    count += 1
                result = max(result, count)
        return result",O(n)
"class Solution(object):
    def minimumDeletions(self, nums):
        i, j = nums.index(min(nums)), nums.index(max(nums))
        if i > j:
            i, j = j, i
        return min((i+1)+(len(nums)-j), j+1, len(nums)-i)",O(n)
"n, m = map(int, input().split())

a = []

def is_center(a, y, x):
    count1 = count2 = count3 = count4 = 0

    y1 = y
    x1 = x
    while True:
        y2 = y1 - 1
        if y2 < 0:
            break
        c = a[y2][x]
        if c == ""W"":
            break
        count1 += 1
        y1 = y2

    y1 = y
    x1 = x
    while True:
        y2 = y1 + 1
        if y2 == n:
            break
        c = a[y2][x]
        if c == ""W"":
            break
        count2 += 1
        y1 = y2

    y1 = y
    x1 = x
    while True:
        x2 = x1 - 1
        if x2 < 0:
            break
        c = a[y1][x2]
        if c == ""W"":
            break
        count3 += 1
        x1 = x2

    y1 = y
    x1 = x
    while True:
        x2 = x1 + 1
        if x2 == m:
            break
        c = a[y1][x2]
        if c == ""W"":
            break
        count4 += 1
        x1 = x2

    return count1 == count2 == count3 == count4 and a[y][x] == ""B""

for k in range(n):
    s = input()
    a.append(s)

for y in range(n):
    c = False
    for x in range(m):
        if is_center(a, y, x):
            print(y+1, x+1)
            c = True
            break
    if c:
        break
",O(n ^ 2)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n = int(input())
*a, = map(int, input().split())
dp = [[0 for i in range(n + 1)] for j in range(n + 1)]
for i in range(n):
    dp[0][i] = a[i]
for i in range(1, n):
    for j in range(n - i + 1):
        dp[i][j] = dp[i - 1][j] ^ dp[i - 1][j + 1]
for i in range(1, n):
    for j in range(n - i):
        dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i - 1][j + 1])
for i in range(int(input())):
    l, r = map(int, input().split())
    print(dp[r - l][l - 1])",O(n ^ 2)
"class Solution(object):
    def __init__(self):
        self.min = None
        self.stack = []

    def push(self, x):
        if not self.stack:
            self.stack.append(0)
            self.min = x
        else:
            self.stack.append(x - self.min)
            if x < self.min:
                self.min = x

    def pop(self):
        x = self.stack.pop()
        if x < 0:
            self.min = self.min - x

    def top(self):
        x = self.stack[-1]
        if x > 0:
            return x + self.min
        else:
            return self.min

    def getMin(self):
        return self.min",O(1)
"class Solution2(object):

    def __init__(self):
        self.__books = []


    def book(self, start, end):
        i = bisect.bisect_left(self.__books, (start, 1))
        if i < len(self.__books) and self.__books[i][0] == start:
            self.__books[i] = (self.__books[i][0], self.__books[i][1]+1)
        else:
            self.__books.insert(i, (start, 1))

        j = bisect.bisect_left(self.__books, (end, 1))
        if j < len(self.__books) and self.__books[j][0] == end:
            self.__books[j] = (self.__books[j][0], self.__books[j][1]-1)
        else:
            self.__books.insert(j, (end, -1))

        result, cnt = 0, 0
        for book in self.__books:
            cnt += book[1]
            result = max(result, cnt)
        return result",O(n ^ 2)
"import itertools


class Solution(object):
    def dietPlanPerformance(self, calories, k, lower, upper):
        total = sum(itertools.islice(calories, 0, k))
        result = int(total > upper)-int(total < lower)
        for i in range(k, len(calories)):
            total += calories[i]-calories[i-k]
            result += int(total > upper)-int(total < lower)
        return result",O(n)
"import itertools

n = int(input())
a = []
for i in range(4):
    a.append([input() for _ in range(n)])
    if i < 3:
        assert input() == ''

best = 4*n*n
for p in itertools.permutations(a):
    for s in range(2):
        count = 0
        for i in range(4):
            for r in range(n):
                for c in range(n):
                    if p[i][r][c] != str((s + (i//2 + r) + (i % 2 + c)) % 2):
                        count += 1
        best = min(best, count)
print(best)
",O(n ^ 2)
"class Solution(object):
    def minCost(self, s, cost):
        result = accu = max_cost = 0
        for i in range(len(s)):
            if i and s[i] != s[i-1]:
                result += accu-max_cost
                accu = max_cost = 0
            accu += cost[i]
            max_cost = max(max_cost, cost[i])
        result += accu-max_cost
        return result",O(n)
"class Solution(object):
    def maxSubarraySumCircular(self, A):
        total, max_sum, cur_max, min_sum, cur_min = 0, -float(""inf""), 0, float(""inf""), 0
        for a in A:
            cur_max = max(cur_max+a, a)
            max_sum = max(max_sum, cur_max)
            cur_min = min(cur_min+a, a)
            min_sum = min(min_sum, cur_min)
            total += a
        return max(max_sum, total-min_sum) if max_sum >= 0 else max_sum",O(n)
"class Solution2(object):
    def averageOfSubtree(self, root):
        def dfs(node):
            if not node:
                return [0]*3
            left = dfs(node.left)
            right = dfs(node.right)
            return [left[0]+right[0]+node.val,
                    left[1]+right[1]+1,
                    left[2]+right[2]+int((left[0]+right[0]+node.val)//(left[1]+right[1]+1) == node.val)]
        
        return dfs(root)[2]",O(n)
"import sys
n=int(input())

i=0
ANS=[]
while n>0:
    if n==3:
        ANS=ANS+[2**i,2**i,3*2**i]
        break
    x=(n+1)//2
    ANS=ANS+[2**i]*x
    n=n-x
    i+=1

for a in ANS:
    print(a,end="" "")
",O(logn)
"x, k = list(map(int,input().split()))
m = 10**9 + 7
if x==0:
    print(0)
else:
    print((pow(2,k+1,m)*x - pow(2,k,m)+1) % m)",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def maxAncestorDiff(self, root):
        result = 0
        stack = [(root, 0, float(""inf""))]
        while stack:
            node, mx, mn = stack.pop()
            if not node:
                continue
            result = max(result, mx-node.val, node.val-mn)
            mx = max(mx, node.val)
            mn = min(mn, node.val)
            stack.append((node.left, mx, mn))
            stack.append((node.right, mx, mn))
        return result",O(n)
"class Solution(object):
    def racecar(self, target):
        dp = [0] * (target+1)
        for i in range(1, target+1):
            k = i.bit_length()

            if i == 2**k-1:
                dp[i] = k
                continue

            dp[i] = k+1 + dp[2**k-1 - i]

            for j in range(k-1):
                dp[i] = min(dp[i], k+j+1 + dp[i - 2**(k-1) + 2**j])

        return dp[-1]",O(nlogn)
"import random



class Solution(object):
    def putMarbles(self, weights, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        for i in range(len(weights)-1):
            weights[i] += weights[i+1]
        weights.pop()
        result = 0
        nth_element(weights, (k-1)-1, compare=lambda a, b: a > b)
        result += sum(weights[i] for i in range(k-1))
        nth_element(weights, (k-1)-1)
        result -= sum(weights[i] for i in range(k-1))
        return result",O(n)
"n=int(input())
l=[input() for i in range(n)]

s=sorted(l,key=len)
for i in range(1,n):
    if s[i-1] not in s[i]:
        print(""NO"")
        exit()

print(""YES"")
for i in s:
    print(i)
",O(nlogn)
"n,l,r,x=map(int,input().split())
num=list(map(int,input().split()))
ans=0
for i in range(2**n):
    st=bin(i)[2:]
    st='0'*(n-len(st))+st
    if st.count('1')>=2:
        pt=[]
        for i in range(len(st)):
            if st[i]=='1':
                pt.append(num[i])
        if sum(pt)<=r and sum(pt)>=l and max(pt)-min(pt)>=x:
            ans+=1
print(ans)",np
"n, m = map(int, input().split())

for i in range(n):
    s = input()
    left = s.find('B')
    if left != -1:
        right = s.rfind('B')
        c = (right - left) // 2 + 1
        print(i + c, left + c)
        break
",O(n ^ 2)
"read = lambda: map(int, input().split())
n, k = read()
s = input()
c = [0] * 26
for i in range(n):
    if s[i] <= chr(ord('A') + k - 1):
        c[ord(s[i]) - ord('A')] += 1
print(min(c[:k]) * k)",O(n)
"n,k = map(int,input().split())
if k>n+n-1:
    print(0)
    exit(0)
if k-1<=n:
    ml = 1
    mr = k-1
    print((mr-ml+1)//2)
else:
    mr = n
    ml = k-n
    print((mr-ml+1)//2)",O(1)
"import collections



class Solution(object):
    def minSteps(self, s, t):
        cnt1, cnt2 = collections.Counter(s), collections.Counter(t)
        return sum((cnt1-cnt2).values())+sum((cnt2-cnt1).values())",O(n)
"import bisect
import copy
import decimal
import fractions
import functools
import heapq
import itertools
import math
import random
import sys
from collections import Counter,deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap)-1)
def _heappushpop_max(heap, item):
    if heap and item < heap[0]:
        item, heap[0] = heap[0], item
        heapq._siftup_max(heap, 0)
    return item
from math import gcd as GCD
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N,Q=map(int,readline().split())
P=Prime(5*10**5)
mebius=[0]+[P.Mebius(i) for i in range(1,5*10**5+1)]
cnt=[0]*(5*10**5+1)
ans=0
A=list(map(int,readline().split()))
used=[False]*(N)
for _ in range(Q):
    q=int(readline())-1
    prime=list(P.Factorize(A[q]).keys())
    l=len(prime)
    for bit in range(1<<l):
        s=1
        for i in range(l):
            if bit>>i&1:
                s*=prime[i]
        if used[q]:
            cnt[s]-=1
            ans-=cnt[s]*mebius[s]
        else:
            ans+=cnt[s]*mebius[s]
            cnt[s]+=1
    if used[q]:
        used[q]=False
    else:
        used[q]=True
    print(ans)",np
"class Solution(object):
    def movesToMakeZigzag(self, nums):
        result = [0, 0]
        for i in range(len(nums)):
            left = nums[i-1] if i-1 >= 0 else float(""inf"")
            right = nums[i+1] if i+1 < len(nums) else float(""inf"")
            result[i%2] += max(nums[i] - min(left, right) + 1, 0)
        return min(result)",O(n)
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        def backtrack(i, total):
            if i ==len(nums):
                return  total == target

            return (backtrack(i + 1, total + nums[i]) +
                    backtrack(i + 1, total - nums[i]))

        return backtrack(0, 0)
",O(2 ^ n)
"import sys,atexit
from io import BytesIO
inp = BytesIO(sys.stdin.buffer.read())
input = lambda:inp.readline().decode('ascii')
buf = BytesIO()
sys.stdout.write = lambda s: buf.write(s.encode('ascii'))
atexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue()))

n,m = map(int,input().split())
if m%2 == 0:
    steps = []
    for j in range(m//2):
        for i in range(n):
            steps.append((j,i))
            steps.append((m-j-1,n-i-1))
else:
    steps = []
    for j in range(m//2):
        for i in range(n):
            steps.append((j,i))
            steps.append((m-j-1,n-i-1))
    l = 0
    r = n-1
    mid = m//2
    while l<=r:
        steps.append((mid,l))
        if l != r:
            steps.append((mid,r))
        l += 1
        r -= 1

for x,y in steps:
    print(y+1,x+1)
",O(n ^ 2)
"import math
def getdt():
    return map(int,input().split())
def calc(v0,v,a,x):
    t = (v - v0)/a
    x0 = v0 * t + 0.5*a*t*t
    if x0>=x:
        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a)
    return (x0,t)
def go(v0,v,a,x):
    x0,t = calc(v0,v,a,x)
    return t + (x-x0)/v
a,v = getdt()
l,d,w = getdt()
if w>v:
    w = v
x,t = calc(0,w,a,d)
if x==d:
    print(go(0,v,a,l))
else:
    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))
",O(1)
"n, m = map(int, input().split())
x = list(list(map(int , input())) for i in range(n))
res = [0] * m
for i in range(n):
	for j in range(m):
		res[j] += x[i][j]

for i in range(n):
	ok = 1
	for j in range(m):
		if res[j] == 1 and x[i][j] == 1:
			ok = 0
			break
	if ok:
		print(""YES"")
		exit()
print(""NO"")
",O(n ^ 2)
"
import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    return students.rename(columns={
        ""id"" : ""student_id"",
        ""first"" : ""first_name"",
        ""last"" : ""last_name"",
        ""age"" : ""age_in_years"",
    })
",O(n)
"import sys
import copy
input = sys.stdin.readline
n,k=map(int,raw_input().split())
C=list(raw_input().strip())
def JUDGE(C):
    ANS_one=0
    ANS_zero=0
    for c in C:
        if c==""0"":
            ANS_zero+=1
        else:
            break
    for c in C[::-1]:
        if c==""0"":
            ANS_zero+=1
        else:
            break
    for c in C:
        if c==""1"":
            ANS_one+=1
        else:
            break
    for c in C[::-1]:
        if c==""1"":
            ANS_one+=1
        else:
            break
    if ANS_zero>=n-k or ANS_one>=n-k:
        return 1
    else:
        return 0
if JUDGE(C)==1:
    print(""tokitsukaze"")
    sys.exit()
if k>=n-1:
    print(""quailty"")
    sys.exit()
if k<n/2:
    print(""once again"")
    sys.exit()
CAN1=copy.copy(C)
CAN2=copy.copy(C)
if C[0]==""0"":
    for i in range(1,k+1):
        CAN1[i]=""1""
else:
    for i in range(1,k+1):
        CAN1[i]=""0""
if C[-1]==""0"":
    for i in range(n-1,n-k-1,-1):
        CAN2[i]=""1""
else:
    for i in range(n-2,n-k-2,-1):
        CAN2[i]=""0""
if JUDGE(CAN1)==1 and JUDGE(CAN2)==1:
    print(""quailty"")
    sys.exit()
else:
    print(""once again"")
    sys.exit()",O(n)
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
	print(""?"", xr + cb, cb)
	ans11 = input()
	print(""?"", xr, cb)
	if ans11 == ans00:
		ans01 = input()
		if ans01 == '1':
			a += cb
			b += cb
	else:
		ans00 = input()
		if ans11 == '1':
			b += cb
		else:
			a += cb
		xr += cb
	cb //= 2
print(""!"", a, b)
",O(1)
"n,m=map(int,input().split())
s=input()
t=input()
if n==1:
	if s==t or s=='*':
		print('YES')
	else:
		print('NO')
elif s.count('*')==0:
	if s==t:
		print('YES')
	else:
		print('NO')
elif n>m+1:
	print('NO')
else:
	l=s.split('*')
	x=t[:len(l[0])]
	y=t[-len(l[1]):]
	if (l[0]==x and l[1]==y) or (s[:1]=='*' and l[1]==y) or (l[0]==x and s[-1:]=='*'):
		print('YES')
	else:
		print('NO')",O(n)
"n=int(input())
a=[int(i) for i in input().split()]
a.sort()
tot = 0
d={}
for i in range(len(a)):
    if a[i] not in d:
        tot+=1
        for j in range(i+1,len(a),1):
            if a[j]%a[i] == 0:
                d[a[j]]=1
print(tot)",O(n ^ 2)
"class Solution(object):
    def findSubtreeSizes(self, parent, s):
        def iter_dfs():
            lookup = [[] for _ in range(26)]
            result = [1]*len(parent)
            stk = [(1, 0)]
            while stk:
                step, u = stk.pop()
                if step == 1:
                    lookup[ord(s[u])-ord('a')].append(u)
                    stk.append((2, u))
                    for v in reversed(adj[u]):
                        stk.append((1, v))
                elif step == 2:
                    for v in adj[u]:
                        result[lookup[ord(s[v])-ord('a')][-1] if lookup[ord(s[v])-ord('a')] else u] += result[v]
                    lookup[ord(s[u])-ord('a')].pop()
            return result
        
        adj = [[] for _ in range(len(parent))]
        for v, u in enumerate(parent):
            if u != -1:
                adj[u].append(v)
        return iter_dfs()",O(n)
"class Solution(object):
    def maximizeSum(self, nums, k):
        return max(nums)*k+k*(k-1)//2",O(n)
"class Solution(object):
    def isRectangleOverlap(self, rec1, rec2):
        def intersect(p_left, p_right, q_left, q_right):
            return max(p_left, q_left) < min(p_right, q_right)

        return (intersect(rec1[0], rec1[2], rec2[0], rec2[2]) and
                intersect(rec1[1], rec1[3], rec2[1], rec2[3]))",O(1)
"class Solution(object):
    def totalNQueens(self, n):
        def dfs(row):
            if row == n:
                return 1
            result = 0
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                result += dfs(row+1)
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False
            return result

        result = []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        return dfs(0)",O(n!)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"import sys
input = sys.stdin.readline
from collections import deque

n,q=map(int,input().split())
A=deque(map(int,input().split()))
Q=[int(input()) for i in range(q)]

ANS=[0]

for l in range(10**5+1):
    x=A.popleft()
    y=A.popleft()

    ANS.append((x,y))

    if x>y:
        A.appendleft(x)
        A.append(y)
    else:
        A.appendleft(y)
        A.append(x)

ANS0=A[0]
B=list(A)[1:]

for q in Q:
    if q<=10**5+1:
        print(*ANS[q])
    else:
        print(ANS0,B[(q-10**5-2)%(n-1)])
",O(n)
"
class Solution(object):
    def defangIPaddr(self, address):
        result = []
        for c in address:
            if c == '.':
                result.append(""[.]"")
            else:
                result.append(c)
        return """".join(result)
",O(n)
"n,m=(int(x) for x in input().split())
sequence=input().split()[:n]
fingerprint=input().split()[:m]
print("" "".join(i for i in sequence if i in fingerprint))",O(n ^ 2)
"n = int(input())
a = list(map(int, input().split()))

dp = [[False] * (n + 1) for i in range(n + 1)]

def solve(l, r):
    if dp[l][r]:
        return dp[l][r]
    if r - l == 1:
        dp[l][r] = (a[l], 1)
        return dp[l][r]
    tmp = 10 ** 9
    for i in range(l + 1, r):
        if solve(l, i)[0] == -1 or solve(i, r)[0] == -1:
            tmp = min(tmp, dp[l][i][1] + dp[i][r][1])
        elif solve(l, i) == solve(i, r):
            tmp = solve(l, i)[0] + 1
            dp[l][r] = (tmp, 1)
            return dp[l][r]
        else:
            tmp = min(tmp, 2)
    dp[l][r] = (-1, tmp)
    return dp[l][r]

solve(0, n)
print(dp[0][n][1])",O(n ^ 3)
"class Solution2(object):
    def amountPainted(self, paint):
        points = collections.defaultdict(list)
        for i, (s, e) in enumerate(paint):
            points[s].append((True, i))
            points[e].append((False, i))
        sl = SortedList()
        result = [0]*len(paint)
        prev = -1
        for pos in sorted(points.keys()):
            if sl:
                result[sl[0]] += pos-prev
            prev = pos
            for t, i in points[pos]:
                if t:
                    sl.add(i)
                else:
                    sl.remove(i)
        return result


class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda x: 0,
                 query_fn=lambda x, y: y if x is None else x+y,
                 update_fn=lambda x, y: y):
        self.tree = [None]*(2*N)
        self.lazy = [None]*len(self.tree)
        self.base = len(self.tree)//2
        self.H = (self.base-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])
        self.count = [1]*(2*N)
        for i in reversed(range(1, N)):
            self.count[i] = self.count[2*i] + self.count[2*i+1]

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val*self.count[x])
        if x < self.base:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def __push(self, x):
        n = 2**self.H
        while n != 1:
            y = x // n
            if self.lazy[y] is not None:
                self.__apply(y*2, self.lazy[y])
                self.__apply(y*2 + 1, self.lazy[y])
                self.lazy[y] = None
            n //= 2

    def update(self, L, R, h):
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x])

        if L > R:
            return
        L += self.base
        R += self.base
        self.__push(L) 
        self.__push(R) 
        L0, R0 = L, R
        while L <= R:
            if L & 1:
                self.__apply(L, h)
                L += 1
            if R & 1 == 0:
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R):
        result = None
        if L > R:
            return result

        L += self.base
        R += self.base
        self.__push(L)
        self.__push(R)
        while L <= R:
            if L & 1:
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0:
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result",O(nlogn)
"import collections



class Solution(object):
    def isPossibleToSplit(self, nums):
        return all(v <= 2 for v in collections.Counter(nums).values())",O(n)
"class Solution(object):
    def removeTrailingZeros(self, num):
        return num[:next(i for i in reversed(range(len(num))) if num[i] != '0')+1]",O(n)
"class Solution(object):
    def isPowerOfFour(self, num):
        return num > 0 and (num & (num - 1)) == 0 and \
               ((num & 0b01010101010101010101010101010101) == num)",O(1)
"

class Solution(object):
    def minimumRemoval(self, beans):
        beans.sort()
        return sum(beans) - max(x*(len(beans)-i)for i, x in enumerate(beans))
",O(nlogn)
"class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1)

    def add(self, i, val):
        i += 1
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret



class Solution(object):
    def minMovesToMakePalindrome(self, s):
        idxs = [[] for _ in range(26)]
        for i, c in enumerate(s):
            idxs[ord(c)-ord('a')].append(i)
        targets, pairs = [0]*len(s), []
        for c, idx in enumerate(idxs):
            for i in range(len(idx)//2):
                pairs.append((idx[i], idx[~i]))
            if len(idx)%2:
                targets[idx[len(idx)//2]] = len(s)//2
        pairs.sort()
        for i, (l, r) in enumerate(pairs):
            targets[l], targets[r] = i, (len(s)-1)-i
        bit = BIT(len(s))
        result = 0
        for i in targets:
            result += i-bit.query(i-1) 
            bit.add(i, 1)
        return result",O(nlogn)
"n,m = map(int,input().split())
x = [0]*(n+1)
for i in range(n):
    x[i] = int(input())
x[n] = 1000000000
vert = []
for i in range(m):
    x1,x2,y = map(int,input().split())
    if x1 == 1:
        vert.append(x2)
vert.sort()
x.sort()
cur = 0
minicount = n+m
k = len(vert)
for i in range(n+1):
    while cur < k:
        if x[i] <= vert[cur]:
            break
        cur += 1
    minicount = min(minicount,k-cur+i)
print(minicount)
",O(nlogn)
"class Solution(object):
    def decompressRLElist(self, nums):
        return [nums[i+1] for i in range(0, len(nums), 2) for _ in range(nums[i])]",O(n)
"class Solution(object):
    def threeEqualParts(self, A):
        total = sum(A)
        if total % 3 != 0:
            return [-1, -1]
        if total == 0:
            return [0, len(A)-1]

        count = total//3
        nums = [0]*3
        c = 0
        for i in range(len(A)):
            if A[i] == 1:
                if c % count == 0:
                    nums[c//count] = i
                c += 1

        while nums[2] != len(A):
            if not A[nums[0]] == A[nums[1]] == A[nums[2]]:
                return [-1, -1]
            nums[0] += 1
            nums[1] += 1
            nums[2] += 1
        return [nums[0]-1, nums[1]]",O(n)
"class Solution(object):
    def plusOne(self, digits):
        for i in reversed(range(len(digits))):
            if digits[i] == 9:
                digits[i] = 0
            else:
                digits[i] += 1
                return digits
        digits[0] = 1
        digits.append(0)
        return digits",O(n)
"from math import ceil

def solve(n, k):
	if k == 1:
		return n - 1
	if k == 2:
		if n > 1:
			return n - 1
		else:
			return -1
	if k == 3:
		if n > 2:
			return n - 1
		else:
			return -1
	if k in {4, 5}:
		if n > 1:
			return n - 2
		else:
			return -1

	if 2 * n + 1 <= len(bin(3 * k)[2:]):
		return -1
	else:
		return n - ceil((len(bin(3 * k)[2:]) - 1) / 2)

for i in range(int(input())):
	n, k = map(int, input().split())
	a = solve(n, k)
	if a == -1:
		print('NO')
	else:
		print('YES', a)
",O(n)
"class Solution(object):
    def maximumUnits(self, boxTypes, truckSize):
        boxTypes.sort(key=lambda x: x[1], reverse=True)
        result = 0
        for box, units in boxTypes:
            if truckSize > box:
                truckSize -= box
                result += box*units
            else:
                result += truckSize*units
                break
        return result",O(nlogn)
"class Solution:
    def myPow(self, x: float, n: int) -> float:
        def helper(x, n):
            if x == 0:
                return 0
            if n == 0:
                return 1

            res = helper(x * x, n // 2)
            return x * res if n % 2 else res

        res = helper(x, abs(n))
        return res if n >= 0 else 1 / res
",O(logn)
"f, d, s = [int(i) for i in input().split()]
filters = [int(i) for i in input().split()]
filters.sort(reverse=True)

freeSockets = s
usedFilters = 0
for i in range(len(filters)):
    if freeSockets >= d:
        break
    usedFilters += 1
    freeSockets += filters[i]-1

if freeSockets >= d:
    print(usedFilters)
else:
    print(-1)
",O(nlogn)
"n, p = map(int, input().split())
a = list(map(int, input().split()))
t = 0
k = 0
for i in range(n):
    k += a[i]
s = 0
for i in range(0, n-1):
    s += a[i]
    t = max(t, s%p + (k - s)%p)
print(t)
",O(n)
"def Solution(N, Q, wariors_strength, arrows):

    prefix_sum = [0]
    for strength in wariors_strength:
        prefix_sum.append(prefix_sum[-1]+strength)
    prefix_sum.pop(0)
    arrow_so_far = 0
    for arrow in arrows:
        arrow_so_far += arrow
        if arrow_so_far >= prefix_sum[-1]:
            print(N)
            arrow_so_far = 0
        else:
            idx = binarySearch_LowerBound(prefix_sum, arrow_so_far)
            print(N-idx)

def binarySearch_LowerBound(arr, key):
    l = 0
    r = len(arr)-1

    while l <= r:
        mid = (l+r)//2
        if arr[mid] == key:
            return mid+1
        elif arr[mid] > key:
            r = mid-1
        else:
            l = mid+1
    return r+1

N, Q = map(int, input().split())
wariors_strength = list(map(int, input().split()))
arrows = list(map(int, input().split()))

Solution(N, Q, wariors_strength, arrows)
",O(nlogn)
"i=int(input())
d=i%2+8;print(d,i-d)",O(1)
"r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))

dp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

for i in range(r+1):
    dp[i][0][0] = 0
for i in range(g+1):
    dp[0][i][0] = 0
for i in range(b+1):
    dp[0][0][i] = 0

dp[1][1][0] = ls_r[0] * ls_g[0]
dp[0][1][1] = ls_g[0] * ls_b[0]
dp[1][0][1] = ls_r[0] * ls_b[0]

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            res1 = 0
            res2 = 0
            res3 = 0
            if i-1>=0 and j-1>=0:
                res1 += dp[i-1][j-1][k] + ls_r[i-1] * ls_g[j-1]
            if i-1>=0 and k-1>=0:
                res2 += dp[i-1][j][k-1] + ls_r[i-1] * ls_b[k-1]
            if j-1>=0 and k-1>=0:
                res3 += dp[i][j-1][k-1] + ls_g[j-1] * ls_b[k-1]
            dp[i][j][k] = max(res1,res2,res3)
print(dp[r][g][b])",O(n ^ 3)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"class Solution:
    def climbStairs(self, n: int) -> int:

        def dfs(i):
            if i >= n:
                return i == n
            return dfs(i + 1) + dfs(i + 2)

        return dfs(0)
",O(2 ^ n)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        def dfs(i):
            if i == len(nums) - 1:
                return True
            end = min(len(nums) - 1, i + nums[i])
            for j in range(i + 1, end + 1):
                if dfs(j):
                    return True
            return False

        return dfs(0)
",O(n!)
"import math

t = int(input())

def eval_(n, k):
    level = 0.5*math.log2(3*k+1)
    if n > 30:
        cond = (level - n) > 0
    else:
        cond = (3*k+1) > 4**n
    if cond:
        return ""NO""
    elif n == 2 and k == 3:
        return ""NO""
    else:
        level = math.floor(level)

        if n > 5:

            temp = 1 + 0.5*math.log2(3*(k-1) + 1)
            if n > temp:
                return ""YES "" + str(n - 1)
            else:
                return ""YES  0""
        else:
            delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)//3
            start = (4**(level)-1)//3
            if k <=(start+delta):
                return ""YES "" + str(n - level)
            else:
                return ""YES "" + str(n - level-1)

for i in range(t):
    (n, k) = [int(i) for i in input().split()]
    print(eval_(n, k))",O(1)
"import sys
sys.stderr = sys.stdout

from math import inf

def explorer(n, m, k, R, C):
    if k % 2:
        return None

    G = [[0] * m for _ in range(n)]
    G_ = [[0] * m for _ in range(n)]
    for _ in range(k // 2):
        for i in range(n):
            for j in range(m):
                x = inf
                if i > 0:
                    x = min(x, G[i-1][j] + 2*C[i-1][j])
                if i + 1 < n:
                    x = min(x, G[i+1][j] + 2*C[i][j])
                if j > 0:
                    x = min(x, G[i][j-1] + 2*R[i][j-1])
                if j + 1 < m:
                    x = min(x, G[i][j+1] + 2*R[i][j])
                G_[i][j] = x
        G, G_ = G_, G
    return G

def main():
    n, m, k = readinti()
    R = readintll(n)
    C = readintll(n-1)
    G = explorer(n, m, k, R, C)
    if G:
        print(llstr(G))
    else:
        s = ' '.join('-1' for _ in range(m))
        print('\n'.join(s for _ in range(n)))

def readint():
    return int(input())

def readinti():
   return map(int, input().split())

def readintt():
   return tuple(readinti())

def readintl():
   return list(readinti())

def readinttl(k):
    return [readintt() for _ in range(k)]

def readintll(k):
    return [readintl() for _ in range(k)]

def lstr(l):
    return ' '.join(map(str, l))

def llstr(ll):
    return '\n'.join(map(lstr, ll))

def log(*args, **kwargs):
    print(*args, **kwargs, file=sys.__stderr__)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"n = int(input())
l = list(map(int,input().split()))
c1 = 0
c2 = 0
for i in l:
    if i % 2 == 0:
        c1+=1
    else:
        c2+=1

for i in range(len(l)-1,-1,-1):
    if l[i] % 2 == 0:
        lasteven = i
        break
for i in range(len(l)-1,-1,-1):
    if l[i] % 2 != 0:
        lastodd = i
        break
if c1 == 1:
    print(lasteven + 1)
else:
    print(lastodd + 1)
",O(n)
"n = int(input())
a = list(map(int, input().split()))

a = sorted(a)
ans = 0
b = [0] * n
for i in range(n):
    if b[i] == 0:
        ans += 1
        for j in range(i, n):
            if a[j] % a[i] == 0:
                b[j] = 1
print(ans)
",O(n ^ 2)
"for _ in range(int(input())):
    n = int(input())
    li = sorted(list(map(int, input().split())))
    print(min(li[n - 2] - 1, n - 2))
",O(nlogn)
"n,x=map(int,input().split())
a=[]
k={}
for _ in range(n):
    p,q=map(int,input().split())
    if p not in k:
        k[p]=1
    a.append([p,q])
a.sort()
k=sorted(k)
p=[]
k=k[::-1]
for i in k:
    for j in a:
        if j[0]==i:
            p.append(j)
print(p.count(p[x-1]))",O(nlogn)
"class Solution2(object):
    def triangleNumber(self, nums):
        result = 0
        nums.sort()
        for i in range(len(nums)-2):
            if nums[i] == 0:
                continue
            k = i+2
            for j in range(i+1, len(nums)-1):
                while k < len(nums) and nums[i] + nums[j] > nums[k]:
                    k += 1
                result += k-j-1
        return result",O(n ^ 2)
"class Solution(object):
    def splitArray(self, nums):
        if len(nums) < 7:
            return False

        accumulated_sum = [0] * len(nums)
        accumulated_sum[0] = nums[0]
        for i in range(1, len(nums)):
            accumulated_sum[i] = accumulated_sum[i-1] + nums[i]
        for j in range(3, len(nums)-3):
            lookup = set()
            for i in range(1, j-1):
                if accumulated_sum[i-1] == accumulated_sum[j-1] - accumulated_sum[i]:
                    lookup.add(accumulated_sum[i-1])
            for k in range(j+2, len(nums)-1):
                if accumulated_sum[-1] - accumulated_sum[k] == accumulated_sum[k-1] - accumulated_sum[j] and \
                   accumulated_sum[k - 1] - accumulated_sum[j] in lookup:
                    return True
        return False",O(n ^ 2)
"class Solution:
    def __init__(self):
        self.map = {}

    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if head is None:
            return None
        if head in self.map:
            return self.map[head]

        copy = Node(head.val)
        self.map[head] = copy
        copy.next = self.copyRandomList(head.next)
        copy.random = self.map.get(head.random)
        return copy
",O(n)
"class Solution(object):
    def minimumRefill(self, plants, capacityA, capacityB):
        result = 0 
        left, right = 0, len(plants)-1
        canA, canB = capacityA, capacityB
        while left < right: 
            if canA < plants[left]:
                result += 1
                canA = capacityA
            canA -= plants[left]
            if canB < plants[right]:
                result += 1
                canB = capacityB
            canB -= plants[right]
            left, right = left+1, right-1
        if left == right:
            if max(canA, canB) < plants[left]:
                result += 1
        return result",O(n)
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp=[[[-1 for i in range(205)] for j in range(205)] for k in range(205)]
def recurser(x,y,z):
    if (x>=R and y>=G) or (y>=G and z>=B) or (z>=B and x>=R):
        return 0
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    maxi=0
    if x<R and y<G:
        maxi=max(maxi,r[x]*g[y]+recurser(x+1,y+1,z))
    if y<G and z<B:
        maxi=max(maxi,g[y]*b[z]+recurser(x,y+1,z+1))
    if z<B and x<R:
        maxi=max(maxi,r[x]*b[z]+recurser(x+1,y,z+1))
    dp[x][y][z]=maxi
    return maxi
print(recurser(0,0,0))",O(n ^ 3)
"n = int(input())
ans = (2 * (n - 1) ** 2) + 2 * n - 1
print(ans)
",O(1)
"def add(num):
    if(num<=1):
        return 0
    return (num*(num-1))//2

n,k=map(int,input().split())

a=list(map(int,input().split()))
pre=[a[0]]
base=(2**(k))-1
hb=2**(k-1)
for i in range(1,n):
    pre.append(a[i]^pre[-1])

cnt=dict()
cnt[0]=[0,0]

for i in range(n):
    if(pre[i]>=hb):
        if(base-pre[i] not in cnt):
            cnt[base-pre[i]]=[0,0]
        cnt[base-pre[i]][1]+=1
    else:
        if(pre[i] not in cnt):
            cnt[pre[i]]=[0,0]
        cnt[pre[i]][0]+=1
cnt1=0

for i in cnt.values():
    sum1=i[0]+i[1]
    cnt1+=add(sum1//2)
    cnt1+=add((sum1+1)//2)
cnt1+=sum(cnt[0])//2

print((n*(n+1))//2 - cnt1)
",O(n)
"import sys
from collections import defaultdict

reader = (map(int, line.split()) for line in sys.stdin)
input = reader.__next__

n, m = input()

vals = set()
locs = defaultdict(list)
for i in range(n):
    for pos, v in enumerate(input()):
        vals.add(v)
        locs[v].append((pos, i))

masks = [0] * n
full = (1<<m) - 1
met = {0:0}
for v in sorted(vals, reverse=True):
    for pos, i in locs[v]:
        curr_mask = masks[i] = masks[i] | (1<<pos)
        met[curr_mask] = i
        complement = full ^ curr_mask
        if complement in met:
            print(i+1, met[complement]+1)
            sys.exit()",np
"class Solution(object):
    def maxLengthBetweenEqualCharacters(self, s):
        result, lookup = -1, {}
        for i, c in enumerate(s):
            result = max(result, i-lookup.setdefault(c, i)-1)
        return result",O(n)
"class Solution2(object):
    def tribonacci(self, n):
        a, b, c = 0, 1, 1
        for _ in range(n):
            a, b, c = b, c, a+b+c
        return a",O(logn)
"a=int(input())
b=str(a)
c=[]
for i in range(2,a+1):
    if(a%i==0):
        c.append(i)

l=0
for j in c:
    r=str(j)
    t=len(r)
    o=0
    for p in r:
        if(p==""4"" or p==""7""):
            o=o+1
    if(o==t):
        l=l+1
if(l>0):
    print(""YES"")
else:
    print(""NO"")
",O(1)
"import sys

class fenwick():

    def __init__(self, n):
        self.n = n
        self.data = [0]*(n+1)

    def to_sum(self, i):

        s = 0
        while i > 0:
            s += self.data[i]
            i -= (i & -i)
        return s

    def add(self, i, x):

        while i <= self.n:
            self.data[i] += x
            i += (i & -i)

    def get(self, i, j):

        return self.to_sum(j)-self.to_sum(i-1)

def input():
    return sys.stdin.buffer.readline()

n = int(input())
permutation = list(map(int, input().split()))
seq = [(permutation[i], i + 1) for i in range(n)]
seq.sort(reverse=True)

m = int(input())
query = [tuple(map(int, input().split())) for i in range(m)]

WHOLE_INVERSION = 0
fenwick_1 = fenwick(n)

for value, index in seq:
    WHOLE_INVERSION += fenwick_1.get(1, index)
    fenwick_1.add(index, 1)

for l, r in query:
    d = r - l + 1
    WHOLE_INVERSION += d*(d-1)//2
    if WHOLE_INVERSION % 2 != 0:
        print(""odd"")
    else:
        print(""even"")
",O(n ^ 2)
"import sys
input = sys.stdin.readline
n = int(input())
s = list(map(int,input().split()))
c = list(map(int,input().split()))
d = {}
for i in range(n-1):
    ans = 10**12
    for j in range(i+1,n):
        if s[i] < s[j]:
            ans = min(ans,c[i]+c[j])

    d[i] = ans

ans = 10**12
for i in range(n-2):
    for j in range(i+1,n-1):
        if s[i] < s[j]:
            ans = min(ans,c[i]+d[j])

if ans == 10**12:
    print(-1)

else:
    print(ans)",O(n ^ 2)
"n = int(input())
s = input()
x = s.count('0')
if s == '0':
    print('0')
else:
    print('1' + '0'*x)",O(n)
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        n, d = map(int, input().strip().split())
        x = list(map(int, input().strip().split()))
        ans = set()
        for i in range(n):
            for z in [-d, d]:
                y = x[i] + z
                dmin = min(abs(y - xi) for xi in x)
                if dmin == d:
                    ans.add(y)
        print(len(ans))

solver()",O(n)
"import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate

int1 = lambda x: int(x) - 1
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
ilele = lambda: map(int,input().split())
alele = lambda: list(map(int, input().split()))
ilelec = lambda: map(int1,input().split())
alelec = lambda: list(map(int1, input().split()))
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

from functools import lru_cache

n,l,r,x = ilele()
A = alele()
A.sort()

@lru_cache(None)
def fun(pos = 0,sm = -1,la = -1,tot = 0):
    if pos == n:
        if tot >= l and tot <= r and la  > 0 and  (la - sm) >= x:
            return 1
        return 0
    if sm == -1:
        return fun(pos+1,A[pos],-1,A[pos]) + fun(pos+1,sm,la,tot)
    elif la == -1:
        return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot)
    else:
        return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot)

print(fun())
",np
"parent = [i for i in range(int(1e5 + 2))]
def findSet(u):
    if parent[u] != u:
        parent[u] = findSet(parent[u])
    return parent[u]

def unionSet(u, v):
    up = findSet(u)
    vp = findSet(v)
    parent[up] = vp

if __name__ == '__main__':
    n, a, b = map(int, input().split())
    lst = list(map(int, input().split()))
    temp = {lst[i]: i for i in range(n)}
    for i in range(n):
        if a - lst[i] in temp:
            unionSet(i, temp[a - lst[i]])
        else:
            unionSet(i, n)
        if b - lst[i] in temp:
            unionSet(i, temp[b - lst[i]])
        else:
            unionSet(i, n + 1)

    pa = findSet(n)
    pb = findSet(n + 1)
    if pa == pb:
        print('NO')
    else:
        print('YES')
        lst = [0 if findSet(i) == pb else 1 for i in range(n)]
        print(*lst)",O(n)
"n, q = map(int, input().split())
for _ in range(q):
    u = int(input())
    s = input()
    for comm in s:
        k = 1
        while True:
            if k & u:
                break
            k <<= 1
        if comm == 'L':
            if k != 1:
                u -= k
                u += (k>>1)
        elif comm == 'R':
            if k != 1:
                u += (k>>1)
        elif comm == 'U':
            nu = u - k
            nu |= (k<<1)
            if nu <= n:
                u = nu
    print(u)",np
"from math import gcd

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def func(l,r):
    if l==1:
        l+=1
    if r-l<2:
        return -1

    if l&1:
        if r-l>2:
            l+=1
            return '{} {} {}'.format(l,l+1,l+2)
        else:
            if gcd(l,l+2)!=1:
                return '{} {} {}'.format(l,l+1,l+2)
            return -1
    return '{} {} {}'.format(l, l + 1, l + 2)

def main():
    l,r=map(int,input().split())
    print(func(l,r))
    return

if __name__ == '__main__':
    main()
",O(1)
"class Solution(object):
    def totalNQueens(self, n):
        def dfs(row):
            if row == n:
                return 1
            result = 0
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                result += dfs(row+1)
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False
            return result

        result = []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        return dfs(0)",O(n!)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        pass



class Solution(object):
    def removeNodes(self, head):
        stk = []
        while head:
            while stk and stk[-1].val < head.val:
                stk.pop()
            if stk:
                stk[-1].next = head
            stk.append(head)
            head = head.__next__
        return stk[0]",O(n)
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

def mapin():
    return map(int, input().split())

s = list(input())
n = len(s)
l = [1]
for i in range(n-1):
    if(s[i]!= s[i+1]):
        l[-1]+=1
    else:
        l.append(1)

ans = max(l)
if(len(l)>1):
    if(s[0]!= s[-1]):
        ans = max(ans, l[0]+l[-1])

print(ans)
",O(n)
"class Solution(object):
    def minimumScore(self, s, t):
        right = [-1]*len(s) 
        j = len(t)-1
        for i in reversed(range(len(s))):
            if j >= 0 and t[j] == s[i]:
                j -= 1
            right[i] = j
        result = j+1
        left = 0 
        for i in range(len(s)):
            result = max(min(result, right[i]-left+1), 0)
            if left < len(t) and t[left] == s[i]:
                left += 1
        result = min(result, len(t)-left)
        return result",O(n)
"from math import ceil

n, k = list(map(int, input().strip().split()))
r = 2*n
g = 5*n
b = 8*n

print(ceil(r/k)+ceil(g/k)+ceil(b/k))",O(1)
"import sys
input = sys.stdin.readline
out = sys.stdout
t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if len(set(a)) == 1:
        out.write(str(a[0])+"" ""+str(a[0])+"" ""+str(a[0])+"" ""+str(a[0])+""\n"")
    else:
        a.sort()
        g1 = False
        d = {}
        mx = 10001
        for i in a:
            if i not in d.keys():
                d[i] = 1
            else:
                d[i] += 1
            if d[i] == 4:
                g1 = True
                if i < mx:
                    mx = i
        if g1:
            out.write(str(mx)+"" ""+str(mx)+"" ""+str(mx)+"" ""+str(mx)+""\n"")
        else:
            res = []
            for k in d.keys():
                if d[k] >= 2:
                    res.append(k)
            m = len(res)
            minj = 0
            for j in range(m - 1):
                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):
                    minj = j
            out.write(str(res[minj])+"" ""+str(res[minj])+"" ""+str(res[minj+1])+"" ""+str(res[minj+1])+""\n"")",O(nlogn)
"class Solution(object):
    def reorderSpaces(self, text):
        text = list(text)
        space_count, word_count = 0, 0
        for i, c in enumerate(text):
            if c == ' ':
                space_count += 1
            elif i == 0 or text[i-1] == ' ':
                word_count += 1

        left, i = 0, 0
        while i < len(text):
            has_word = False
            while i < len(text) and text[i] != ' ':
                text[left], text[i] = text[i], text[left]
                left += 1
                i += 1
                has_word = True
            if has_word:
                left += 1 
            i += 1

        equal_count = space_count//(word_count-1) if word_count-1 > 0 else 0
        extra_count = space_count%(word_count-1) if word_count-1 > 0 else space_count
        right, i = len(text)-1-extra_count, len(text)-1
        while i >= 0:
            has_word = False
            while i >= 0 and text[i] != ' ':
                text[right], text[i] = text[i], text[right]
                right -= 1
                i -= 1
                has_word = True
            if has_word:
                right -= equal_count 
            i -= 1
        return """".join(text)",O(n)
"a, b = input().split()
a = int(a)
b = int(b)
s = a ^ b
cnt = 0
while s != 0:
    s = int(s / 2)
    cnt = cnt + 1
print((2 ** cnt) - 1)",O(logn)
"from collections import Counter
import math
l=list(input())
l1=list(input())
a=Counter(l)
b=Counter(l1)
if a['+']<b['+'] or a['-']<b['-']:
	print(""0"")
	exit()
else:
	a1=a['+']-b['+']
	b1=a['-']-b['-']
s=(math.factorial(a1+b1))//((math.factorial(a1))*(math.factorial(b1)))
s1=float(2**(a1+b1))
print(s/s1)",np
"def ask(a, b):
    print(""?"", a, b, flush=True)
    return int(input()) <= 0

def solve(M):
    a, b = 0, 0
    less = ask(0, 0)

    for i in range(M - 1, -1, -1):
        bit = 1 << i

        if less:
            if not ask(a | bit, b | bit):
                b |= bit
                less = ask(a, b)
            elif ask(a | bit, b):
                a |= bit
                b |= bit
        else:
            if ask(a | bit, b | bit):
                a |= bit
                less = ask(a, b)
            elif ask(a | bit, b):
                a |= bit
                b |= bit

    print(""!"", a, b, flush=True)

if __name__ == '__main__':
    solve(30)
",O(logn)
"import sys
import bisect
import heapq

from collections import defaultdict as dd
from collections import deque
from collections import Counter as c
from itertools import combinations as comb
from bisect import bisect_left as bl, bisect_right as br, bisect

mod = pow(10, 9) + 7
mod2 = 998244353
def data(): return sys.stdin.readline().strip()

def out(var): sys.stdout.write(var)

def l(): return list(map(int, data().split()))

def sl(): return list(map(str, data().split()))

def sp(): return map(int, data().split())

def ssp(): return map(str, data().split())

def l1d(n, val=0): return [val for i in range(n)]

def l2d(n, m, val=0): return [[val for i in range(n)] for j in range(m)]

n = int(data())
arr = l()
dp = [[0 for j in range(500)] for i in range(500)]
dp2 = [0 for i in range(501)]
for i in range(n):
    dp[i][i] = arr[i]
i = n-2
while ~i:
    j = i+1
    while j < n:
        dp[i][j] = -1
        for k in range(i, j):
            if (~dp[i][k] and dp[i][k]) == dp[k+1][j]:
                dp[i][j] = dp[i][k]+1
        j += 1
    i -= 1
for i in range(1, n+1):
    dp2[i] = pow(10, 9)
    for j in range(i):
        if ~dp[j][i-1]:
            dp2[i] = min(dp2[i], dp2[j]+1)
out(str(dp2[n]))
",O(n ^ 3)
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**10
mod = 10**9+7
dd = [(0,-1),(1,0),(0,1),(-1,0)]
ddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    x,k = LI()
    if x == 0:
        return 0
    t = pow(2,k+1,mod) * x % mod
    d = pow(2,k,mod) - 1

    return (t + mod - d) % mod

print(main())
",O(logn)
"class Solution(object):
    def subArrayRanges(self, nums):
        result = 0
        stk = []
        for i in range(len(nums)+1):
            x = nums[i] if i < len(nums) else float(""inf"")
            while stk and nums[stk[-1]] <= x:
                j = stk.pop()
                k = stk[-1] if stk else -1
                result += nums[j]*(j-k)*(i-j)
            stk.append(i)
        stk = []
        for i in range(len(nums)+1):
            x = nums[i] if i < len(nums) else float(""-inf"")
            while stk and nums[stk[-1]] >= x:
                j = stk.pop()
                k = stk[-1] if stk else -1
                result -= nums[j]*(j-k)*(i-j)
            stk.append(i)
        return result",O(n)
"n,m=map(int,input().split())
c=list(map(int,input().split()))
a=list(map(int,input().split()))
j,res=0,0
for i in range(n):
    if j < m:
        if c[i] <= a[j]:
            j+=1
            res+=1
print(res)",O(n)
"from collections import Counter

n, k = map(int, input().split())

for p in range(n+1):
    if p*(p+1)//2 - (n-p) == k:
        print(n-p)
        break
",O(n)
"def maxXORInRange(L, R):
    LXR = L ^ R

    msbPos = 0
    while (LXR):
        msbPos += 1
        LXR >>= 1

    maxXOR, two = 0, 1

    while (msbPos):
        maxXOR += two
        two <<= 1
        msbPos -= 1

    return maxXOR

L, R = map(int, input().split())
print(maxXORInRange(L, R))
",O(logn)
"n = int(input())
i = 0
s = 0
while True:
	temp = (i+1)*9*(10**i)
	if s + temp <= n:
		s += temp
		i += 1
	else:
		break
tc = n - s

nd = tc//(i+1) - 1
tc -= (nd+1)*(i+1)
f = 10**i + nd
if tc != 0:
	print(str(10**i+nd+1)[tc-1])
else:
	print(str(10**i+nd)[-1])
",O(logn)
"class Solution:
    left_check = staticmethod(lambda val, limit: val < limit)
    right_check = staticmethod(lambda val, limit: val > limit)

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        if (not self.isValid(root.left, root.val, self.left_check) or
            not self.isValid(root.right, root.val, self.right_check)):
            return False

        return self.isValidBST(root.left) and self.isValidBST(root.right)

    def isValid(self, root: Optional[TreeNode], limit: int, check) -> bool:
        if not root:
            return True
        if not check(root.val, limit):
            return False
        return (self.isValid(root.left, limit, check) and
                self.isValid(root.right, limit, check))
",O(n ^ 2)
"import sys,os,io,time,copy,math
from functools import lru_cache
if os.path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

def main():
    n,k=map(int,input().split())
    arr=[]
    for i in range(n):
        x,y=map(int,input().split())
        arr.append((x,y))
        arr.sort(key=lambda x:(x[0],-x[1]),reverse=True)
    req=arr[k-1]
    count=0
    for a in arr:
        if a==req:
            count+=1
    print(count)

main()
",O(nlogn)
"import os
from sys import stdin
from math import inf

dx = [1, 0, -1, 0]
dy = [0, 1, 0, -1]

def solve(tc):
    N, M, K = map(int, stdin.readline().split())

    wx = [[] for j in range(N)]
    for i in range(N):
        wx[i] = list(map(int, stdin.readline().split()))

    wy = [[] for i in range(N-1)]
    for i in range(N-1):
        wy[i] = list(map(int, stdin.readline().split()))

    if K & 1:
        for i in range(N):
            for j in range(M):
                print(-1, end=' ')
            print()
        return

    mem = [[[0 for i in range(M)] for j in range(N)] for k in range(K+1)]

    half = K // 2
    for kk in range(1, half+1):
        for yy in range(N):
            for xx in range(M):
                mem[kk][yy][xx] = inf

                for d in range(4):
                    y = yy + dy[d]
                    x = xx + dx[d]

                    if y < 0 or y >= N or x < 0 or x >= M:
                        continue

                    if d == 0:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wx[yy][xx]*2)
                    elif d == 1:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wy[yy][xx]*2)
                    elif d == 2:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wx[yy][x]*2)
                    else:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wy[y][xx]*2)

    for yy in range(N):
        for xx in range(M):
            print(mem[half][yy][xx], end=' ')
        print()

tcs = 1

tc = 1
while tc <= tcs:
    solve(tc)
    tc += 1
",O(n ^ 3)
"l, r = map(int, input().split())
target, final = l ^ r, 1
while target:
    target >>= 1
    final <<= 1
print(final - 1)
",O(logn)
"class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = [1] * (len(nums))

        prefix = 1
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]
        postfix = 1
        for i in range(len(nums) - 1, -1, -1):
            res[i] *= postfix
            postfix *= nums[i]
        return res
",O(n)
"import collections


class Solution(object):
    def numSquarefulPerms(self, A):
        def dfs(candidate, x, left, count, result):
            count[x] -= 1
            if left == 0:
                result[0] += 1
            for y in candidate[x]:
                if count[y]:
                    dfs(candidate, y, left-1, count, result)
            count[x] += 1

        count = collections.Counter(A)
        candidate = {i: {j for j in count if int((i+j)**0.5) ** 2 == i+j} 
                           for i in count}

        result = [0]
        for x in count:
            dfs(candidate, x, len(A)-1, count, result)
        return result[0]",O(n!)
"import math
def lucky(x):
    return (list(set(list(str(x)))) in [[""4""],[""7""],[""4"",""7""],[""7"",""4""]])
a = int(input())
true = False
for i in range(1, math.ceil(math.sqrt(a))+1):
    if a % i == 0:
        if lucky(i) or lucky(a//i):
            true = True
            break
print(""YES"" if true else ""NO"")",O(1)
"class Solution(object):
    def grayCode(self, n):
        result = [0]
        for i in range(n):
            for n in reversed(result):
                result.append(1 << i | n)
        return result",O(2 ^ n)
"class Solution(object):
    def maxSumDivThree(self, nums):
        dp = [0, 0, 0]
        for num in nums:
            for i in [num+x for x in dp]:
                dp[i%3] = max(dp[i%3], i)
        return dp[0]",O(n)
"n, q = map(int, input().split(' '))
a = list(map(int, input().split(' ')))

def p(c_k, r):
    l = 0
    while r - l > 1:
        z = (r + l) // 2
        if pr_a[z] > c_k:
            r = z
        else:
            l = z
    return l

pr_a = []
for i in range(n):
    pr_a.append(a[i])
    if i > 0:
        pr_a[i] += pr_a[i - 1]
k = list(map(int, input().split(' ')))
c_k = 0
ans = []
for qq in range(q):
    c_k += k[qq]
    l = p(c_k, n - 1)
    if pr_a[l] <= c_k:
        l += 1
    if c_k >= pr_a[n - 1]:
        c_k = 0
        l = 0
    ans.append(str(n - l))
print('\n'.join(ans))
",O(nlogn)
"n = int(input())
map1 = [list(input()) for i in range(n)]
map2 = [list(input()) for i in range(n)]

def vFlip (m):
    return([list(reversed(i)) for i in m])

def hFlip(m):
    return(list(reversed(m)))

def rotate(m):
    return(list(zip(*reversed(m))))

def check():
    global map1
    for i in range(4):
        if map1 == map2:
            return(True)
        if vFlip(map1)==map2:
            return(True)
        if hFlip(map1)==map2:
            return(True)
        if vFlip(hFlip(map1))==map2:
            return(True)
        map1 = rotate(map1)
    return(False)

print('YES' if check() else 'NO')",O(n ^ 2)
"import itertools


class Solution(object):
    def distanceBetweenBusStops(self, distance, start, destination):
        if start > destination:
            start, destination = destination, start
        s_to_d = sum(itertools.islice(distance, start, destination))
        d_to_s = sum(itertools.islice(distance, 0, start)) + \
                 sum(itertools.islice(distance, destination, len(distance)))
        return min(s_to_d, d_to_s)",O(n)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sufficientSubset(self, root, limit):
        if not root:
            return None
        if not root.left and not root.right:
            return None if root.val < limit else root
        root.left = self.sufficientSubset(root.left, limit-root.val)
        root.right = self.sufficientSubset(root.right, limit-root.val)
        if not root.left and not root.right:
            return None
        return root
",O(n)
"class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        return max(self.helper(nums[1:]),
                   self.helper(nums[:-1]))

    def helper(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]

        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])

        return dp[-1]
",O(n)
"class Solution(object):
    def numSubarrayProductLessThanK(self, nums, k):
        if k <= 1: return 0
        result, start, prod = 0, 0, 1
        for i, num in enumerate(nums):
            prod *= num
            while prod >= k:
                prod /= nums[start]
                start += 1
            result += i-start+1
        return result",O(n)
"from math import *
from collections import *
from random import *
from decimal import Decimal
from heapq import *
from bisect import *
import sys
input=sys.stdin.readline
sys.setrecursionlimit(10**5)
def lis():
    return list(map(int,input().split()))
def ma():
    return map(int,input().split())
def inp():
    return int(input())
def st1():
    return input().rstrip('\n')
t=1
while(t):
    t-=1
    r,g,b=ma()
    rl=lis()
    gl=lis()
    bl=lis()
    rl.sort()
    bl.sort()
    gl.sort()
    dp= [[[0]*(b+1)for i in range(g+1)] for j in range(r+1)]
    for i in range(r+1):
        for j in range(g+1):
            for k in range(b+1):
                if(i+j+k<2):
                    continue
                if(i and j):
                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rl[i-1]*gl[j-1])
                if(j and k):
                    dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gl[j-1]*bl[k-1])
                if(i and k):
                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rl[i-1]*bl[k-1])
    print(dp[r][g][b])
",O(n ^ 3)
"n, m, k = list(map(int, input().split()))
f = list(map(int, input().split()))
f.sort()

fs = 0
ptr = len(f) - 1
while ptr >= 0:
    if m <= k:
        print(fs)
        exit()
    k -= 1
    k += f[ptr]
    fs += 1
    ptr -= 1

if m <= k:
    print(fs)
else:
    print(-1)",O(nlogn)
"import collections


class Solution(object):
    def shortestCompletingWord(self, licensePlate, words):
        def contains(counter1, w2):
            c2 = collections.Counter(w2.lower())
            c2.subtract(counter1)
            return all([x >= 0 for x in list(c2.values())])

        result = None
        counter = collections.Counter(c.lower() for c in licensePlate if c.isalpha())
        for word in words:
            if (result is None or (len(word) < len(result))) and \
               contains(counter, word):
                result = word
        return result",O(n)
"import sys
from collections import deque
n=int(input())
visited=[False for i in range(n+1)]
dp=[0 for i in range(n+1)]
l=[[] for i in range(n+1)]
for i in range(n-1):
    a,b=map(int,input().split())
    l[a].append(b)
    l[b].append(a)
b=list(map(int,input().split()))
s=[1]
visited[1]=True
c=1
c1=0
t=True
while len(s)!=n :
    aux=0
    for i in l[s[c1]]:
        if not visited[i]:
            visited[i]=True
            dp[i]=1
            aux+=1
    for i in range(c,c+aux):
        if dp[b[i]]==1:
            s.append(b[i])
            dp[b[i]]=0
        else:
            print(""No"")
            t=False
            break
    else:
        c+=aux
        c1+=1
        continue
    break
if t:
    print(""Yes"")
",O(nlogn)
"n = int(input())-1
x, y = 1, 9
while n > x * y: n,x,y = n-x*y,x+1,y*10
a = str(10 ** (x - 1) + n // x)[n%x]
print(a)",O(logn)
"import collections



class Solution(object):
    def countInterestingSubarrays(self, nums, modulo, k):
        cnt = collections.Counter([0])
        result = prefix = 0
        for x in nums:
            if x%modulo == k:
                prefix = (prefix+1)%modulo
            result += cnt[(prefix-k)%modulo]
            cnt[prefix] += 1
        return result",O(n)
"

class Solution(object):
    def removeStars(self, s):
        result = []
        for c in s:
            if c == '*':
                result.pop()
            else:
                result.append(c)
        return """".join(result)
",O(n)
"mod = 1000000000 + 7

n, m = map(int, input().split())

if n == 0:
    print(0)
    exit()

ans = n * 2
ans %= mod

if m:
    t = 1
    x = 2
    while m > 0:
        if m & 1:
            t = t * x % mod
        x = x * x % mod
        m >>= 1
    ans -= 1
    ans = (t * ans + 1) % mod

print(ans)",O(logn)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = set()
        posDiag = set()
        negDiag = set()

        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue

                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                board[r][c] = ""Q""

                backtrack(r + 1)

                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"def possible(a,index,a1,b):
    rem = []
    for i in range(len(a)):
        if i != index:
            rem.append(a[i])

    a3 = a1[:]
    rem.sort()
    a3.append(a[index])
    a3.extend(rem)
    a2 = ''
    for i in a3:
        a2 += str(i)

    if int(a2) <= b:
        return True

    return False

def main():
    a = list(map(int,input()))
    b = int(input())

    a.sort(reverse = True)
    a1 = []
    for pos in range(len(a)):
        for i in range(len(a)):
            if possible(a,i,a1,b):
                a1.append(a[i])
                a.pop(i)
                break

    for i in a1:
        print(i,end = '')

main()
",O(n ^ 3)
"a1, a2, b1, b2, c1, c2 = map(int, input().split())
l = max([a1, a2, b1, b2, c1, c2])

if (a1*a2 + b1*b2 + c1*c2 != l**2):
    print(-1)
else:
    if a1 > a2:
        a1, a2 = a2, a1
    if b1 > b2:
        b1, b2 = b2, b1
    if c1 > c2:
        c1, c2 = c2, c1

    if a2 == b2 and b2 == c2:
        print(l)
        for i in range(a1):
            print('A'*a2)
        for i in range(b1):
            print('B'*b2)
        for i in range(c1):
            print('C'*c2)
    else:
        ls = [[a1, a2, 'A'], [b1, b2, 'B'], [c1, c2, 'C']]

        if b2 == l:
            ls[0], ls[1] = ls[1], ls[0]
        if c2 == l:
            ls[0], ls[2] = ls[2], ls[0]

        valid = True
        if ls[1][0] == ls[2][0]:
            pass
        elif ls[1][1] == ls[2][1]:
            ls[1][0], ls[1][1] = ls[1][1], ls[1][0]
            ls[2][0], ls[2][1] = ls[2][1], ls[2][0]
        elif ls[1][0] == ls[2][1]:
            ls[2][0], ls[2][1] = ls[2][1], ls[2][0]
        elif ls[1][1] == ls[2][0]:
            ls[1][0], ls[1][1] = ls[1][1], ls[1][0]
        else:
            valid = False

        if (ls[1][0] + ls[0][0] != l) or (ls[1][1] + ls[2][1] != l):
            valid = False

        if not valid:
            print(-1)
        else:
            print(l)

            for i in range(ls[0][0]):
                print(ls[0][2] * l)
            for i in range(ls[1][0]):
                print(ls[1][2] * ls[1][1] + ls[2][2] * ls[2][1])
",np
"k=int(input())
i=0
r=1
while(k>=r):
    r+=9*(i+1)*10**i
    i+=1
r=r-(9*i*10**(i-1))
ans=str(((k-r)//i)+10**(i-1))[(k-r)%i]
print(ans)",O(logn)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        self.next = None

    def __repr__(self):
        if self is None:
            return ""Nil""
        else:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def connect(self, root):
        head = root
        while head:
            cur = head
            while cur and cur.left:
                cur.left.next = cur.right
                if cur.__next__:
                    cur.right.next = cur.next.left
                cur = cur.__next__
            head = head.left

",O(n)
"first = [int(i) for i in input()]
second = [int(i) for i in input()]

pref_dists = [
    [0] + [int(0 != c) for c in second],
    [0] + [int(1 != c) for c in second]
]
for i in range(1, len(second) + 1):
    pref_dists[0][i] += pref_dists[0][i - 1]
    pref_dists[1][i] += pref_dists[1][i - 1]

total = 0
for i, c in enumerate(first):
    end = len(second) - (len(first) - i)
    total += pref_dists[c][end + 1] - pref_dists[c][i]
print(total)
",O(n)
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort()
g.sort()
b.sort()

dp=[[[0 for i in range(B+1)] for j in range(G+1)] for i in range(R+1)]

for i in range(1,R+1):
    for j in range(1,G+1):
        dp[i][j][0]=dp[i-1][j-1][0]+r[i-1]*g[j-1]

for j in range(1,G+1):
    for k in range(1,B+1):
        dp[0][j][k]=dp[0][j-1][k-1]+b[k-1]*g[j-1]

for i in range(1,R+1):
    for k in range(1,B+1):
        dp[i][0][k]=dp[i-1][0][k-1]+r[i-1]*b[k-1]

for i in range(1,R+1):
    for j in range(1,G+1):
        for k in range(1,B+1):
            if max(r[i-1],g[j-1],b[k-1])==r[i-1]:
                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])
            elif max(r[i-1],g[j-1],b[k-1])==g[j-1]:
                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i][j-1][k-1]+g[j-1]*b[k-1])
            else:
                dp[i][j][k]=max(dp[i][j-1][k-1]+b[k-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])

print(dp[R][G][B])
",O(n ^ 3)
"import math
n,k=map(int,input().split())
n-=1
k-=1
if n>(k*(k+1))//2:
    print(-1)
else:
    l=-1
    r=k+1
    while r>l+1:
        m=(l+r)//2
        if n>(m*(2*k-m+1))//2:
            l=m
        else:
            r=m
    print(r)
",O(logn)
"import sys
N, M = map(int, input().split())

Ans = [None]*(N*M)
for i in range(1, N*M+1):
    if i % 2:
        a, b = divmod(i//2, M)
    else:
        a, b = divmod(N*M - i//2, M)
    Ans[i-1] = (a+1, b+1)
for a in Ans:
    sys.stdout.write('{} {}\n'.format(*a))",O(n ^ 2)
"n = int(input())
leafs = set()
other = {}
other_indices = []
s = 0
for i, a in enumerate(map(int, input().split())):
    if a == 1:
        leafs.add(i)
    else:
        other[i] = a
        other_indices.append(i)
    s += a

if not other:

    print(""NO"")
    exit(0)

other_indices.sort(key=lambda index: other[index])
other_indices = [other_indices[-1]] + other_indices[:-1]

edges = []
for i1, i2 in zip(other_indices, other_indices[1:]):
    edges.append((i1, i2))
    other[i1] -= 1
    if other[i1] == 0:
        del other[i1]
    other[i2] -= 1
    if other[i2] == 0:
        del other[i2]

diam = len(other_indices) + min(2, len(leafs))

has_start = has_end = False

while leafs:
    if len(other) == 0:
        print(""NO"")
        exit(0)
    l = leafs.pop()
    if not has_start and other.get(other_indices[0], 0):
        i = other_indices[0]
        has_start = True
    elif not has_end and other.get(other_indices[-1], 0):
        i = other_indices[-1]
        has_end = True
    else:
        i = next(iter(other))
    edges.append((l, i))
    other[i] -= 1
    if other[i] == 0:
        del other[i]

print(""YES"", diam - 1)
print(len(edges))
for x, y in edges:
    print(x+1, y+1)
",O(nlogn)
"s=input()
for ln in range(len(s),0,-1):
    for L in range(len(s)-ln+1):
        if s[L:L+ln] in s[L+1:]:
            print(ln)
            exit()
print(0)
",O(n ^ 3)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import gcd, ceil

def prod(a, mod=10**9+7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

for _ in range(int(input()) if not True else 1):
    n = int(input())

    a = list(map(int, input().split()))

    mod =  10**9 + 7
    twopow = [1]*(10**5+69)
    for i in range(1, 10**5+69):
        twopow[i] = (twopow[i-1] * 2) % mod
    count = [0]*100069
    for i in a:
        count[i] += 1
    multiples = [0]*100069
    for i in range(1, 10**5+1):
        for j in range(i, 10**5+1, i):
            multiples[i] += count[j]
    gcd_of = [0]*100069
    for i in range(10**5, 0, -1):
        gcd_of[i] = (twopow[multiples[i]] - 1) % mod
        for j in range(2*i, 10**5+1, i):
            gcd_of[i] -= gcd_of[j]
    print(gcd_of[1] % mod)",np
"class Solution(object):
    def isSubstringPresent(self, s):
        lookup = [[False]*26 for _ in range(26)]
        for i in range(len(s)-1):
            lookup[ord(s[i])-ord('a')][ord(s[i+1])-ord('a')] = True
        return any(lookup[ord(s[i+1])-ord('a')][ord(s[i])-ord('a')]  for i in range(len(s)-1))
import collections",O(n)
"from copy import deepcopy
a = list(map(int, list(input())))
b = list(map(int, list(input())))
cnt1 = [0] * 10; cnt2 = [0] * 10
ans = []
if (len(a) != len(b)):
    print(''.join(map(str,sorted(a, reverse=True))))
    exit()
for i in range(len(b) + 1):
    ok = 1
    tmp = deepcopy(a)
    for j in range(i):
        if b[j] in tmp:
            tmp.pop(tmp.index(b[j]))
        else:
            ok = 0
            break
    if not ok: continue
    pls = -1
    ind = -1
    for j in range(len(tmp)):
        if (tmp[j] < b[i]):
            if (tmp[j] > pls):
                ind = j
                pls = tmp[j]
    if pls == -1 and len(tmp) != 0: continue
    else:
        if (len(tmp) > 0): tmp.pop(ind)
        if i == len(b): ans.append(''.join(map(str, b[:i:])))
        else: ans.append(''.join(map(str, b[:i:])) + str(pls) + ''.join(map(str, sorted(tmp, reverse=True))))
print(max(ans))",O(n ^ 3)
"import collections


class Solution2(object):
    def countPairs(self, root, distance):
        def dfs(distance, node):
            if not node:
                return 0, collections.Counter()
            if not node.left and not node.right:
                return 0, collections.Counter([0])
            left, right = dfs(distance, node.left), dfs(distance, node.right)
            result = left[0]+right[0]
            for left_d, left_c in left[1].items():
                for right_d,right_c in right[1].items():
                    if left_d+right_d+2 <= distance:
                        result += left_c*right_c
            return result, collections.Counter({k+1:v for k,v in (left[1]+right[1]).items()})
        
        return dfs(distance, root)[0]",O(n)
"class Solution:
    def isValid(self, s: str) -> bool:
        while '()' in s or '{}' in s or '[]' in s:
            s = s.replace('()', '')
            s = s.replace('{}', '')
            s = s.replace('[]', '')
        return s == ''
",O(n ^ 2)
"class Solution2(object):
    def cloneTree(self, root):
        def dfs(node):
            if not node:
                return None
            copy = Node(node.val)
            for child in node.children:
                copy.children.append(dfs(child))
            return copy
        
        return dfs(root)",O(n)
"import os,sys,math
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192

def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:
        return len(a)

def solve():
    n,m,k=In()
    rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)]
    for i in range(n):
        z=list(In())
        for j in range(m-1):
            rt[i][j]=z[j]
    for i in range(n-1):
        z=list(In())
        for j in range(m):
            do[i][j]=z[j]

    dp=[[0]*m for i in range(n)]
    if k%2==1:
        for i in range(n):
            print(*[-1]*m)
        return
    k//=2
    dp_next=[[P]*m for i in range(n)]
    for op in range(k):
        for i in range(n):
            for j in range(m):
                ans=Inf
                if i!=0:
                    ans=min(ans,dp[i-1][j]+do[i-1][j])
                if j!=0:
                    ans=min(ans,dp[i][j-1]+rt[i][j-1])
                if i!=n-1:
                    ans = min( ans , dp[i+1][j]+do[i][j])
                if j!=m-1 :
                    ans=min( ans , dp[i][j+1]+rt[i][j])
                dp_next[i][j]=ans

        for i in range(n):
            for j in range(m):
                dp[i][j]=dp_next[i][j]

    for i in range(n):
        for j in range(m):
            print(2*dp[i][j],end=' ')
        print()

def main():
    T=1
    for i in range(T):
        solve()

M = 998244353
P = 1000000007
Inf=float('inf')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(n ^ 3)
"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        nums.sort()
        return nums[len(nums) - k]
",O(nlogn)
"import sys
a = list(map(int, sys.stdin.readlines()[1][:-1].split()))
mx = 0
for i in range(len(a)):
	if a[i] > mx:
		print(i+1)
		sys.exit(0)
	mx = max(mx,a[i] + 1)
print(-1)",O(n)
"class Solution(object):
    def numberOfUniqueGoodSubsequences(self, binary):
        MOD = 10**9+7
        ends0, ends1 = 0, 0
        has_zero = False
        for b in binary:
            if b == '1':
                ends1 = (ends0+ends1+1)%MOD 
            else:
                ends0 = (ends0+ends1)%MOD 
                has_zero = True
        return (ends0+ends1+int(has_zero))%MOD",O(n)
"class Solution(object):
    def totalSteps(self, nums):
        dp = [0]*len(nums) 
        stk = []
        for i in reversed(range(len(nums))):
            while stk and nums[stk[-1]] < nums[i]:
                dp[i] = max(dp[i]+1, dp[stk.pop()])
            stk.append(i)
        return max(dp)",O(n)
"x, y, z, t1, t2, t3 = map(int, input().split())
dp = abs(x - y) * t1;
dl = abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3;
if dp < dl:
    print(""NO"")
else:
    print(""YES"")
",O(1)
"n, m, k = list(map(int, input().split()))
a = list(map(int, input().split()))
ret = 0
for i in range(m):
	cur = 0
	for j in range(i, n):
		if j % m == i:
			cur = max(0, cur)
			cur -= k
		cur += a[j]
		ret = max(ret, cur)
print(ret)
",O(n ^ 2)
"from collections import Counter
class Solution3(object):
    def findDuplicates(self, nums):
        return [elem for elem, count in list(Counter(nums).items()) if count == 2]",O(n)
"import collections



class Solution(object):
    def largestInteger(self, nums, k):
        if k == len(nums):
            return max(nums)
        cnt = collections.defaultdict(int)
        for x in nums:
            cnt[x] += 1
        if k == 1:
            return max(x for x, v in cnt.items() if v == 1) if any(v == 1 for v in cnt.values()) else -1
        result = -1
        if cnt[nums[0]] == 1:
            result = max(result, nums[0])
        if cnt[nums[-1]] == 1:
            result = max(result, nums[-1])
        return result",O(n)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

for t in range(ii()):
    n, k = mi()
    if n == 1:
        ans = 'YES 0' if k == 1 else 'NO'
    elif n == 2:
        if k <= 2:
            ans = 'YES 1'
        elif k == 3 or k > 5:
            ans = 'NO'
        else:
            ans = 'YES 0'
    elif n <= 32 and k > (4 ** n - 1) // 3:
        ans = 'NO'
    else:
        c, x = 0, n
        p2 = 2
        while x > 0:
            if c + p2 - 1 > k:
                break
            c += p2 - 1
            x -= 1
            p2 *= 2
        ans = 'YES %d' % (x,)
    print(ans)
",O(n)
"class Solution2(object):
    def countOfPairs(self, n, x, y):
        x, y = x-1, y-1
        result = [0]*n
        for i in range(n):
            for j in range(i+1, n):
                result[min(abs(i-j), abs(i-x)+1+abs(y-j), abs(i-y)+1+abs(x-j))-1] += 2
        return result",O(n ^ 2)
"class Solution(object):
    def calculateTime(self, keyboard, word):
        lookup = {c:i for i, c in enumerate(keyboard)}
        result, prev = 0, 0
        for c in word:
            result += abs(lookup[c]-prev)
            prev = lookup[c]
        return result",O(n)
"import sys
input = lambda: sys.stdin.readline().rstrip()

from collections import deque, defaultdict
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = ''
            for j in range(k):
                if i>>j&1:
                    ans = ''.join([ans, s[j]])
                else:
                    ans = ''.join([ans, '_'])
            Ans.add(ans)
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = 1
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = 0
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag == 0 or not T:
        print('NO')
    else:
        print('YES')
        print(*[t+1 for t in T], sep = ' ')

main()",np
"[n, l, r, x] = list(map(int, input().strip().split()))
Cs = list(sorted(map(int, input().strip().split())))
probs = 0

for i in range(1, 2**n):
    currsub = [ Cs[j] for j in range(n) if (i & (1 << j))]
    probs += (len(currsub) > 1 and l <= sum(currsub) <= r and currsub[-1] - currsub[0] >= x)

print(probs)",np
"n,k=map(int,input().split())
s=[["".""]*n for i in range(4)]
if k%2==0:
  for j in range(1,n-1):
    if k==0:
      break
    s[1][j]=""
    s[2][j]=""
    k-=2
else:
  cen=n//2
  s[1][cen]=""
  k-=1
  for i in range(1,3):
    for j in range(1,cen):
      if k>0:
        k-=2
        s[i][j]=s[i][-j-1]=""
if k==0:
  print(""YES"")
  for i in range(4):
    print("""".join(s[i]))
else:
  print(""NO"")",O(n)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"import collections



class Solution(object):
    def countNonDecreasingSubarrays(self, nums, k):
        result = cnt = 0
        dq = collections.deque()
        right = len(nums)-1
        for left in reversed(range(len(nums))):
            while dq and nums[dq[-1]] < nums[left]:
                l = dq.pop()
                r = dq[-1]-1 if dq else right
                cnt += (r-l+1)*(nums[left]-nums[l])
            dq.append(left)
            while cnt > k:
                cnt -= nums[dq[0]]-nums[right]
                if dq[0] == right:
                    dq.popleft()
                right -= 1
            result += right-left+1
        return result",O(n)
"n=int(input())
a=list(map(int, input().rstrip().split()))
a.sort()
sum1=0
rem=sum(a)
i=len(a)-1
c=0
while(sum1<=rem):
    sum1+=a[i]
    rem=sum(a)-sum1
    i-=1
    c+=1
print(c)",O(nlogn)
"class Solution(object):
    def merge(self, intervals):
        intervals.sort()
        result = []
        for interval in intervals:
            if not result or interval[0] > result[-1][1]:
                result.append(interval)
            else:
                result[-1][1] = max(result[-1][1], interval[1])
        return result",O(nlogn)
"class Solution3(object):
    def frogPosition(self, n, edges, t, target):
        def dfs(G, target, t, node, parent):
            if not t or not (len(G[node])-(parent != 0)):
                return int(node == target)
            result = 0
            for child in G[node]:
                if child == parent:
                    continue
                result = dfs(G, target, t-1, child, node)
                if result:
                    break
            return result*(len(G[node])-(parent != 0))
        
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)
        choices = dfs(G, target, t, 1, 0)
        return 1.0/choices if choices else 0.0",O(n)
"import bisect
import itertools


class Solution(object):
    def minArea(self, image, x, y):
        def binarySearch(left, right, find, image, has_one):
            while left <= right: 
                mid = left + (right - left) / 2
                if find(image, has_one, mid): 
                    right = mid - 1
                else:
                    left = mid + 1
            return left


        searchColumns = lambda image, has_one, mid: any([int(row[mid]) for row in image]) == has_one
        left = binarySearch(0, y - 1, searchColumns, image, True)
        right = binarySearch(y + 1, len(image[0]) - 1, searchColumns, image, False)

        searchRows = lambda image, has_one, mid: any(map(int, image[mid])) == has_one
        top = binarySearch(0, x - 1, searchRows, image, True)
        bottom = binarySearch(x + 1, len(image) - 1, searchRows, image, False)

        return (right - left) * (bottom - top)",O(nlogn)
"class Solution2(object):
    def wiggleSort(self, nums):
        nums.sort()
        med = (len(nums) - 1) // 2
        nums[::2], nums[1::2] = nums[med::-1], nums[:med:-1]",O(nlogn)
"from bisect import bisect_left

def readint():
    return int(input())

def readline():
    return [int(c) for c in input().split()]

def main():
    MAX = 10**9
    n, m = readline()
    v = sorted([readint() for _ in range(n)])

    h = []
    for _ in range(m):
        x1, x2, _ = readline()
        if x1 == 1:
            h.append(x2)
    h.sort()

    lh = len(h)
    if lh == 0:
        print(0)
    elif n == 0:
        print(lh - bisect_left(h, MAX))
    else:
        mn = n + lh - bisect_left(h, MAX)
        for i in range(n):
            mn = min(mn, lh - bisect_left(h, v[i]) + i)
        print(mn)

if __name__ == '__main__':
    main()
",O(nlogn)
"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        arr = []

        def dfs(node):
            if not node:
                return

            dfs(node.left)
            arr.append(node.val)
            dfs(node.right)

        dfs(root)
        return arr[k - 1]
",O(n)
"class Solution(object):
    def createTargetArray(self, nums, index):
        for i in range(len(nums)):
            for j in range(i):
                if index[j] >= index[i]:
                    index[j] += 1
        result = [0]*(len(nums))
        for i in range(len(nums)):
            result[index[i]] = nums[i]
        return result",O(n ^ 2)
"for _ in range(int(input())):
    a,b=map(int,input().split())
    ans=int(0)
    while a and b:
        a,b=min(a,b),max(a,b)
        ans,b=ans+b//a,b%a
    print(ans)
",O(1)
"class Solution(object):
    def findMode(self, root):
        def inorder(root, prev, cnt, max_cnt, result):
            if not root:
                return prev, cnt, max_cnt

            prev, cnt, max_cnt = inorder(root.left, prev, cnt, max_cnt, result)
            if prev:
                if root.val == prev.val:
                    cnt += 1
                else:
                    cnt = 1
            if cnt > max_cnt:
                max_cnt = cnt
                del result[:]
                result.append(root.val)
            elif cnt == max_cnt:
                result.append(root.val)
            return inorder(root.right, root, cnt, max_cnt, result)

        if not root:
            return []
        result = []
        inorder(root, None, 1, 0, result)
        return result",O(n)
"class Solution(object):
    def removeElement(self, A, elem):
        i, last = 0, len(A) - 1
        while i <= last:
            if A[i] == elem:
                A[i], A[last] = A[last], A[i]
                last -= 1
            else:
                i += 1
        return last + 1",O(n)
"class Solution(object):
    def maxScoreIndices(self, nums):
        result = []
        mx = zeros = 0
        total = sum(nums)
        for i in range(len(nums)+1):
            zeros += ((nums[i-1] if i else 0) == 0)
            if zeros+(total-(i-zeros)) > mx:
                mx = zeros+(total-(i-zeros))
                result = []
            if zeros+(total-(i-zeros)) == mx:
                result.append(i)
        return result",O(n)
"import sys
import math

def main():
    i = sys.stdin.readlines()

    n = int(i[0].strip())
    points = []
    for pi in range(n):
        p = i[pi + 1]
        x, y = p.strip().split()
        points.append([int(x), int(y)])

    if n < 5:
        print('YES')
        return

    st = [False] * n

    def run(first, second):
        dx = first[0] - second[0]
        dy = first[1] - second[1]

        for i, p in enumerate(points):
            if st[i]:
                continue
            if dx == 0:
                if p[0] == first[0]:
                    st[i] = True
            elif dy == 0:
                if p[1] == first[1]:
                    st[i] = True
            else:

                if ((p[0] - first[0]) * dy) == (p[1] - first[1]) * dx:
                    st[i] = True

    def check(fi, si):
        for i in range(n):
            st[i] = i == fi or i == si

        run(points[fi], points[si])

        fi = None
        si = None
        for i in range(n-1):
            if not st[i]:
                fi = i
                for j in range(i+1, n):
                    if not st[j]:
                        si = j
                        break
                break
        if fi is None or si is None:
            return True

        st[fi] = True
        st[si] = True
        run(points[fi], points[si])
        return not (False in st)

    if check(0, 1) or check(0, 2) or check(1, 2):
        print('YES')
    else:
        print('NO')

main()",O(nlogn)
"import itertools


class Solution(object):
    def fib(self, N):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) \
                     for col in ZB] for row in A]

        T = [[1, 1],
             [1, 0]]
        return matrix_mult([[1, 0]], matrix_expo(T, N))[0][1]",O(logn)
"n,a,b = list( map(int, input().split()))

if min(a,b) >1:
    print('NO')
    exit()

m = max(a,b)

if m == 1:
    if n == 1:
        print('YES')
        print(0)
        exit()
    elif n < 4:
        print('NO')
        exit()
    else:
        print('YES')
        for row in range(n):
            line = ['0']*n
            if row >0:
                line[row-1] = '1'
            if row <n-1:
                line[row+1] = '1'
            print(''.join(line))
    exit()

print('YES')

if a == 1:
    c = '1'
    d = '0'
else:
    c = '0'
    d = '1'
for row in range(n):
    if row < m-1:
        line = [c]*n
    else:
        line = [c]*(m-1)+ [d]*(n-m+1)
    line[row] = '0'

    print(''.join(line))
",O(n ^ 2)
"class Solution2(object):
    def __init__(self):
        self.__nH = 0
        self.__nO = 0
        self.__cv = threading.Condition()

    def hydrogen(self, releaseHydrogen):
        with self.__cv:
            while (self.__nH+1) - 2*self.__nO > 2:
                self.__cv.wait()
            self.__nH += 1
            releaseHydrogen()
            self.__cv.notifyAll()

    def oxygen(self, releaseOxygen):
        with self.__cv:
            while 2*(self.__nO+1) - self.__nH > 2:
                self.__cv.wait()
            self.__nO += 1
            releaseOxygen()
            self.__cv.notifyAll()",O(1)
"class Solution2(object):
    def longestMonotonicSubarray(self, nums):
        result = cnt1 = cnt2 = 1
        for i in range(1, len(nums)):
            cnt1 = cnt1+1 if nums[i-1] < nums[i] else 1
            cnt2 = cnt2+1 if nums[i-1] > nums[i] else 1
            result = max(result, cnt1, cnt2)
        return result",O(n)
"from collections import Counter

def main():
    n, m = map(int, input().split())
    l = list(map(int, input().split()))
    p = l.index(m)
    le, ri = Counter(), Counter()
    c = 0
    le[0] = ri[0] = 1
    for i in range(p + 1, n):
        if l[i] < m:
            c += 1
        else:
            c -= 1
        ri[c] += 1
    c = 0
    for i in range(p - 1, -1, -1):
        if l[i] < m:
            c -= 1
        else:
            c += 1
        le[c] += 1
    res = 0
    for c, x in le.items():
        res += x * (ri[c] + ri[c - 1])
    print(res)

if __name__ == '__main__':
    main()
",O(nlogn)
"n = int(input())
s = input()
t = 0
mn = 0
for i in s:
    if i == '-':
        t-=1
    else:
        t+=1
    mn = min(mn, t)
print(-mn+t)",O(n)
"import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
def power(a,b,z):
    if b==0:
        return 1
    temp=power(a,b//2,z)
    if b%2==0:
        return (temp*temp)%z
    return (a*temp*temp)%z
x,k=list(map(int,input().split()))
if x==0:
    print(0)
else:
    z=(10**9)+7
    n=(power(2,k+1,z)*x)%z
    m=power(2,k,z)
    print((n-m+1)%z)",O(logn)
"n,m=map(int,input().split())
listi=[]
for i in range(0,n):
    string=input()
    listi.append(string)
rownum=0
flag=False
for row in listi:

    for letter in row:
            if(""B"" in row):
                p=row.index(""B"")

                s=row[::-1]
                q=abs(m-s.index(""B"")-1)

                if(p==q):
                    print(rownum+1,row.index(row[p])+1)
                    flag=True
                    break
                mr=(q+p)/2

                length=abs(q-p+1)

                rn= rownum + length//2

                print(rn+1,int(mr+1))
                flag=True
                break

    if(flag==True):
        break

    rownum+=1
",O(n ^ 2)
"import math
import sys
from collections import deque

def scan() -> list:
    return list(map(int, sys.stdin.readline().strip().split()))

def solution() -> None:

    n, k = scan()
    print(round(n+1.5-math.sqrt(2*(n+k)+2.75)))

if __name__ == '__main__':
    solution()
",O(logn)
"import os
import sys
from math import *
from collections import *
from fractions import *
from bisect import *
from heapq import*
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

def possible(x):
    days=n-x
    tot=days*(days+1)//2

    return tot-x<=k

n,k=value()

low=0
high=n

while(low<=high):

    mid=(low+high)//2

    if(possible(mid)):
        high=mid-1
    else:
        low=mid+1

print(low)
",O(logn)
"class Solution2(object):
    def findErrorNums(self, nums):
        result = [0] * 2
        for i in nums:
            if nums[abs(i)-1] < 0:
                result[0] = abs(i)
            else:
                nums[abs(i)-1] *= -1
        for i in range(len(nums)):
            if nums[i] > 0:
                result[1] = i+1
            else:
                nums[i] *= -1
        return result",O(n)
"import math
n  = int(input())

for i in range(n):
    l,r = [*map(int, input().split())]
    l-=1
    war1 = math.ceil(l/2)
    if(l%2 == 1):
        war1 = -1*war1

    war2 = math.ceil(r/2)
    if(r%2 == 1):
        war2 = -1*war2

    print(war2-war1)",O(1)
"def solve():
  r, g, b = map(int, input().split());R,G,B = sorted(list(map(int, input().split()))),sorted(list(map(int, input().split()))),sorted(list(map(int, input().split())));dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
  for i in range(r+1):
    for j in range(g+1):
      for k in range(b+1):
        if i+j+k<2:continue
        if i>0 and j>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
        if i>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
        if j>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
  return dp[r][g][b]
print(solve())",O(n ^ 3)
"from math import sin
pi = 3.141592653589793238462643383279502884197
n, r = map(int,input().split())
theta = 2*pi / n
R = r / (1-sin(theta/2))
print(R-r)",O(1)
"num=int(input())

vals=list(map(int,input().split()))

vals.sort()

flag=0

for i in vals:
    if i>vals[0]:
        print(i)
        flag=1
        break

if flag==0:
    print('NO')
",O(nlogn)
"import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))

def num():
	return map(int , input().split())

def nu():
	return int(input())

n,s=num()
cc=0
for i in range(n,0,-1):
	cc+=s//i
	s=s%i
print(cc)",O(1)
"import sys
sys.setrecursionlimit(200000)
input=sys.stdin.readline

def solve(r,g,b,R,G,B):
    if (r==0 and g==0) and (r==0 and b==0) and (g==0 and b==0):
        return 0
    if z[r][g][b]!=-1:
        return z[r][g][b]
    d,e,f=0,0,0
    if r!=0 and g!=0:
        d=R[r-1]*G[g-1]+solve(r-1,g-1,b,R,G,B)
    if r!=0 and b!=0:
        e=R[r-1]*B[b-1]+solve(r-1,g,b-1,R,G,B)
    if b!=0 and g!=0:
        f=B[b-1]*G[g-1]+solve(r,g-1,b-1,R,G,B)
    z[r][g][b]=max(d,e,f)
    return z[r][g][b]

r,g,b=map(int,input().rstrip().split())
R=sorted(map(int,input().rstrip().split()))
G=sorted(map(int,input().rstrip().split()))
B=sorted(map(int,input().rstrip().split()))
z=[[[ -1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
print(solve(r,g,b,R,G,B))",O(n ^ 3)
"import os, sys, atexit
from cStringIO import StringIO as BytesIO

sys.stdout = BytesIO()
atexit.register(lambda: os.write(1, sys.stdout.getvalue()))
input = BytesIO(os.read(0, os.fstat(0).st_size)).readline

rints = lambda: [int(x) for x in input().split()]
rstr = lambda: input().strip()
rstr_2d = lambda n: [rstr() for _ in range(n)]

n, m = rints()
grid = rstr_2d(n)
row = [[[] for _ in range(m)] for _ in range(n)]
col = [[[] for _ in range(m)] for _ in range(n)]
visr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0
visc = [[-1 for _ in range(m)] for _ in range(n)]

for i in range(n):
    be, en = -1, -1
    for j in range(m):
        if grid[i][j] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    row[i][k] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            row[i][k] = [be, en]

for i in range(m):
    be, en = -1, -1
    for j in range(n):
        if grid[j][i] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    col[k][i] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            col[k][i] = [be, en]

for i in range(n):
    for j in range(m):
        if grid[i][j] == '*':
            all += 1
            hor = min(row[i][j][1] - j, j - row[i][j][0])
            ver = min(col[i][j][1] - i, i - col[i][j][0])
            if hor <= ver:
                ver = hor
            else:
                hor = ver

            if hor > 0 and ver > 0:
                out.append('%d %d %d' % (i + 1, j + 1, hor))
                visr[i][j - ver] = j + ver
                visc[i - hor][j] = i + hor

dis = set()
for i in range(n):
    j, ma = 0, -1
    while j < m:
        ma = max(ma, visr[i][j])
        if ma >= j:
            dis.add((i, j))

        j += 1

for i in range(m):
    j, ma = 0, -1
    while j < n:
        ma = max(ma, visc[j][i])
        if ma >= j:
            dis.add((j, i))

        j += 1

if len(dis) != all:
    print(-1)
else:
    sys.stdout.write('%d\n%s' % (len(out), '\n'.join(out)))
",O(n ^ 2)
"import math

n = int(input())

beacons = {}
sortedKeys = [0]*n

for i in range(n):
    a, b = map(int, input().split(' '))
    sortedKeys[i] = a
    beacons[a] = b

sortedKeys.sort()
maxA = sortedKeys[-1]

sumBeacons = [0]*(maxA+1)
count = 0
for a in range(maxA+1):
    sumBeacons[a] = count

    if a in beacons:
        count += 1

f = [0]*(n+1)
minF = math.inf
for i in range(1, n+1):
    a = sortedKeys[i-1]
    b = beacons[a]
    end = max(0, a-b)
    numDestroyed = sumBeacons[a] - sumBeacons[end]
    f[i] = numDestroyed
    if i-numDestroyed > 0:
        f[i] += f[(i-1)-numDestroyed]

    minF = min(minF, f[i]+n-i)

print(minF)",O(n)
"n = int(input())
a = list(map(int, input().split()))
ans = 0
sum = 0
mp = {}
for i in range(n):
    x = a[i]
    ans += (x * i) - sum;
    ans -= (mp.get(x - 1, 0));
    ans -= (-mp.get(x + 1, 0));
    mp[x] = mp.get(x, 0) + 1;
    sum += x;
print(ans)",O(nlogn)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,k=map(int,input().split())
s=list(map(str, input()))
dic={}
for i in range(n):
    if s[i]==""("":
        arrStack.my_push([i,""(""])
    else:
        if arrStack.my_peak()[1]==""("":
            index=arrStack.my_peak()[0]
            dic[index]=1
            dic[i]=1
            k-=2
            arrStack.my_pop()
    if k==0:
        break
ans =""""
for i in range(n):
    if i in dic:
        ans+=s[i]
print(ans)
",O(n)
"class Solution(object):
    def mergeTriplets(self, triplets, target):
        result = [0]*3
        for t in triplets:
            if all(t[i] <= target[i] for i in range(3)):
                result = [max(result[i], t[i]) for i in range(3)]
        return result == target",O(n)
"import sys
import bisect
from bisect import bisect_left as lb
from bisect import bisect_right as rb
input_=lambda: sys.stdin.readline().strip(""\r\n"")
from math import log
from math import gcd
from math import atan2,acos
from random import randint
sa=lambda :input_()
sb=lambda:int(input_())
sc=lambda:input_().split()
sd=lambda:list(map(int,input_().split()))
sflo=lambda:list(map(float,input_().split()))
se=lambda:float(input_())
sf=lambda:list(input_())
flsh=lambda: sys.stdout.flush()

mod=10**9+7
mod1=998244353
gp=[]
cost=[]
dp=[]
mx=[]
ans1=[]
ans2=[]
special=[]
specnode=[]
a=0
kthpar=[]
def dfs2(root,par):
    if par!=-1:
        dp[root]=dp[par]+1
    for i in range(1,20):
        if kthpar[root][i-1]!=-1:
            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]
    for child in gp[root]:
        if child==par:continue
        kthpar[child][0]=root
        dfs(child,root)

ans=0
b=[]
vis=[]
tot=0
def dfs(root):
    global tot,vis,gp
    for child in gp[root]:
        if vis[child]==0:
            tot+=1
            vis[child]=1
            dfs(child)
pre=[[] for i in range(3)]
def hnbhai(tc):
    n=sb()
    d,num=0,1
    while num<=n:
        num+=9*(d+1)*(10**d)
        d+=1
    num-=9*(d)*(10**(d-1))
    ans=str(10**(d-1)+(n-num)//d)
    print(ans[(n-num)%d])
for _ in range(1):
    hnbhai(_+1)
",O(logn)
"class Solution(object):
    def maxRepeating(self, sequence, word):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if len(sequence) < len(word):
            return 0

        prefix = getPrefix(word)
        result, count, j, prev = 0, 0, -1, -1
        for i in range(len(sequence)):
            while j > -1 and word[j+1] != sequence[i]:
                j = prefix[j]
            if word[j+1] == sequence[i]:
                j += 1
            if j+1 == len(word):     
                count = count+1 if i-prev == len(word) else 1
                result = max(result, count)
                j, prev = -1, i
        return result",O(n)
"class Solution(object):
    def maximumDifference(self, nums):
        result, prefix = 0, float(""inf"")
        for x in nums: 
            result = max(result, x-prefix)
            prefix = min(prefix, x)
        return result if result else -1",O(n)
"input()
a=list(map(int,input().split()))
n=len(a)
u=n
for i in range(n):
	j=i
	k=0
	while a[j]>0:
		k+=1
		t=j
		j=a[j]-1
		a[t]=0
	if k>0:
		u+=1-k%2
s='Petr'
if u%2>0:
	s='Um_nik'
print(s)
",O(nlogn)
"import sys as _sys

_sys.setrecursionlimit(2**14)

_cache = dict()

class _SortedSeqs:

    def __init__(self, seqs):
        self.seqs = tuple(tuple(sorted(seq)) for seq in seqs)

    def __hash__(self):
        return id(self)

def compute_max_area(r_seq, g_seq, b_seq):
    sorted_seqs_obj = _SortedSeqs((r_seq, g_seq, b_seq))
    seqs_sizes = tuple(map(len, sorted_seqs_obj.seqs))
    return _compute_max_area(sorted_seqs_obj, seqs_sizes)

def _compute_max_area(sorted_seqs_obj, seqs_sizes):
    cache_key = (sorted_seqs_obj, seqs_sizes)
    if cache_key in _cache.keys():
        return _cache[cache_key]

    seqs = sorted_seqs_obj.seqs
    nonempty_seqs_n = _how_many_nonempty(seqs_sizes)

    if nonempty_seqs_n < 2:
        ab_seqs_indices_list = []

    elif nonempty_seqs_n == 2:
        ab_seqs_indices = [i for i, seq_size in enumerate(seqs_sizes) if seq_size > 0]
        ab_seqs_indices_list = [ab_seqs_indices]

    else:
        assert nonempty_seqs_n == 3
        seqs_indices_sorted_by_size = [
            i for i, seq in sorted(
                enumerate(seqs),
                key=lambda pair: (pair[1][seqs_sizes[pair[0]]-1], seqs_sizes[pair[0]])
            )
        ]
        ab_seqs_indices_1 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[0]
        ab_seqs_indices_2 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[1]
        ab_seqs_indices_list = [ab_seqs_indices_1, ab_seqs_indices_2]

    max_areas_variants = []
    for a_seq_index, b_seq_index in ab_seqs_indices_list:
        a_seq_last = seqs[a_seq_index][seqs_sizes[a_seq_index]-1]
        b_seq_last = seqs[b_seq_index][seqs_sizes[b_seq_index]-1]
        new_seqs_sizes = list(seqs_sizes)
        new_seqs_sizes[a_seq_index] -= 1
        new_seqs_sizes[b_seq_index] -= 1
        max_area = _compute_max_area(sorted_seqs_obj, tuple(new_seqs_sizes))
        max_area += a_seq_last * b_seq_last
        max_areas_variants.append(max_area)

    max_area = max(max_areas_variants, default=0)

    _cache[cache_key] = max_area
    return max_area

def _how_many_nonempty(seqs_sizes):
    return len([size for size in seqs_sizes if size > 0])

def main():
    r_n, g_n, b_n = map(int, input().split())
    r_seq = tuple(map(int, input().split()))
    g_seq = tuple(map(int, input().split()))
    b_seq = tuple(map(int, input().split()))
    result = compute_max_area(r_seq, g_seq, b_seq)
    print(result)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"class Solution:
    def rob(self, nums: List[int]) -> int:

        def dfs(i):
            if i >= len(nums):
                return 0
            return max(dfs(i + 1),
                       nums[i] + dfs(i + 2))

        return dfs(0)
",O(2 ^ n)
"class Solution2(object):
    def maxLength(self, arr):
        def bitset(s):
            result = 0
            for c in s:
                if result & power[ord(c)-ord('a')]:
                    return 0
                result |= power[ord(c)-ord('a')]
            return result
    
        bitsets = [bitset(x) for x in arr]
        result = 0
        for i in range(power[len(arr)]):
            curr_bitset, curr_len = 0, 0
            while i:
                j = i & -i 
                i ^= j
                j = log2[j] 
                if not bitsets[j] or (curr_bitset & bitsets[j]):
                    break
                curr_bitset |= bitsets[j]
                curr_len += len(arr[j])
            else:
                result = max(result, curr_len)
        return result",O(2 ^ n)
"l,r=map(int,input().split())
r1=len(bin(r))-3
l1=len(bin(l))-3
ans=0
while(l>0):
    if l1==r1:
        r-=(1<<l1)
        l-=(1<<l1)
    else:
        ans=(1<<(r1+1))-1
        break

    z1=min(l,r)
    z2=max(l,r)
    l,r=z1,z2
    r1 = len(bin(r)) - 3
    l1 = len(bin(l)) - 3

if ans==0:
    if l1==r1:
        if r==1:
            print(1)
        else:
            print(0)
    else:
        print((1<<(r1+1))-1)

else:
    print(ans)
",O(logn)
"def Sort(x):
	if len(x) == 1:
		return x

	a = Sort(x[:len(x) // 2])
	b = Sort(x[len(x) // 2:])

	c = []
	i = 0
	j = 0
	while (i < len(a))and(j < len(b)):
		if a[i] < b[j]:
			c.append(a[i])
			i += 1
		else:
			c.append(b[j])
			j += 1

	c = c + b[j:]
	c = c + a[i:]

	return c

input()
m = [int(i) for i in input().split(' ')]

newm = Sort(m)
count = 0
for i in range(len(m)):
 if newm[i] != m[i]:
  count += 1

if count / 2 <= 1:
 print('YES')
else:
 print('NO')
",O(nlogn)
"from math import gcd
def t_prime(n):
    if n == 1:        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:            return False
    return True
primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))
if k == 1: print(0);exit()
for i in range(n):
    for j in range(i):
        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)
powers = set();count = 0;outLs = [];pgood = []
for p in primes:
    curr = [];    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:            v2 //= p
        if v2 == 1:   curr.append(v);   powers.add(v)
    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)
order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])
if len(order) == 0:    print(0); exit()
if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1;    need = -1;    last = []
    for v in l:
        if v in powers:            continue
        v2 = v;        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):  extra = v;     last = primesn;    need = len(last);   assert need >= 2
    if need == -1 or 2 * need + 1 > k:  print(0);   exit()
    other = [];    out = [extra]
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:   works = True;           break
        if works:       out.append(a);   out.append(b)
        else:       other.append(a);      other.append(b)
    assert len(out) == 2 * need + 1;    assert (k - 2 * need - 1) % 2 == 0; ret = out + other[:(k - 2*need - 1)];    assert len(ret) == k; print(' '.join(map(str,ret)));    exit()
out = [];need = k
for i in range(len(order)):
    assert need != 1

    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0

assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",np
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"class DoublyLinkedList:
    def __init__(self, val, next=None, prev=None):
        self.val = val
        self.next = next
        self.prev = prev

class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        head = DoublyLinkedList(tokens[0])
        curr = head

        for i in range(1, len(tokens)):
            curr.next = DoublyLinkedList(tokens[i], prev=curr)
            curr = curr.next

        while head is not None:
            if head.val in ""+-*/"":
                l = int(head.prev.prev.val)
                r = int(head.prev.val)
                if head.val == '+':
                    res = l + r
                elif head.val == '-':
                    res = l - r
                elif head.val == '*':
                    res = l * r
                else:
                    res = int(l / r)

                head.val = str(res)
                head.prev = head.prev.prev.prev
                if head.prev is not None:
                    head.prev.next = head

            ans = int(head.val)
            head = head.next

        return ans
",O(n)
"n = int(input())
a = [0]*n;

def fun(n,ptr1):
	global a

	if n == 1:
		a[ptr1] = 1;

	elif n == 2:

		a[ptr1] = 1;
		ptr1+=1;
		a[ptr1] = 2;
	elif n == 3:
		a[ptr1] = 1;
		ptr1 +=1;
		a[ptr1] = 1;
		ptr1+=1;
		a[ptr1]=3;

	else:
		itera = n - n//2;

		for i in range(itera):
			a[ptr1] = 1;
			ptr1+=1;

		fun(n//2,ptr1);
		for i in range((n//2)):
			a[ptr1] = 2*a[ptr1];
			ptr1+=1;

fun(n,0);
for i in a:
	print(i,end="" "");

print();",O(n)
"class Solution2(object):
    def rotate(self, nums, k):
        def apply_cycle_permutation(k, offset, cycle_len, nums):
            tmp = nums[offset]
            for i in range(1, cycle_len):
                nums[(offset + i * k) % len(nums)], tmp = tmp, nums[(offset + i * k) % len(nums)]
            nums[offset] = tmp

        k %= len(nums)
        num_cycles = gcd(len(nums), k)
        cycle_len = len(nums) / num_cycles
        for i in range(num_cycles):
            apply_cycle_permutation(k, i, cycle_len, nums)",O(n)
"def check(x, y):
    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])

n = int(input())
a = [list(input()) for i in range(n)]
b = [list(input()) for i in range(n)]
for i in range(4):
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = b[::-1]
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = [s[::-1] for s in b]
    c = [['' for t in range(n)] for u in range(n)]
    for t in range(n):
        for u in range(n):
            c[t][u] = b[u][n - t - 1]
    b = c[:]
    if check(a, b):
        print('Yes')
        exit(0)
print('No')",O(n ^ 2)
"class Solution(object):
    def clumsy(self, N):
        if N <= 2:
            return N
        if N <= 4:
            return N+3
        
        if N % 4 == 0:
            return N+1
        elif N % 4 <= 2:
            return N+2
        return N-1",O(1)
"import heapq

def doxor(a, b):
    cnt = 0
    for i in range(len(a)):
        for j in range(len(a[0])):
            cnt += a[i][j] ^ b[i][j]
    return cnt

n = int(input())

a, b = [], []
for i in range(n):
    ai, bi = [], []
    for j in range(n):
        if i % 2 == 0:
            ai.append(j % 2)
            bi.append((j % 2) ^ 1)
        else:
            ai.append((j % 2) ^ 1)
            bi.append(j % 2)
    a.append(ai)
    b.append(bi)

board = []
board.append([list(map(int, list(input()))) for _ in range(n)])
input()
board.append([list(map(int, list(input()))) for _ in range(n)])
input()
board.append([list(map(int, list(input()))) for _ in range(n)])
input()
board.append([list(map(int, list(input()))) for _ in range(n)])

a_cnts = []
b_cnts = []
for b0 in board:
    heapq.heappush(a_cnts, doxor(b0, a))
    heapq.heappush(b_cnts, doxor(b0, b))

print(heapq.heappop(a_cnts) + heapq.heappop(a_cnts) +
      heapq.heappop(b_cnts) + heapq.heappop(b_cnts))
",O(n ^ 2)
"class Solution(object):
    def maxIncreasingGroups(self, usageLimits):
        def inplace_counting_sort(nums, reverse=False): 
            if not nums:
                return
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()

        usageLimits = [min(x, len(usageLimits)) for x in usageLimits]
        inplace_counting_sort(usageLimits)
        result = curr = 0
        for x in usageLimits:
            curr += x
            if curr >= result+1:
                curr -= result+1
                result += 1
        return result",O(n)
"s = input()
ans = 0
for i in range(len(s)):
    for j in range(i + 1, len(s)):
        cur = s[i:j]
        if cur in s[:(j - 1)] or cur in s[(i + 1):]:
            ans = max(ans, j - i)
print(ans)
",O(n ^ 3)
"class Solution2(object):
    def maxScore(self, nums):
        dp = [0]*len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                dp[i] = max(dp[i], dp[j]+(i-j)*nums[i])
        return dp[-1]",O(n ^ 2)
"k1,k2,k3 = map(int, input().strip().split(' '))
l=[k1,k2,k3]
if min(k1,k2,k3)==1:
    print('yes')
elif l.count(2)>=2:
    print('yes')
elif l.count(3)==3:
    print('yes')
elif l.count(4)==2 and l.count(2)==1:
    print('yes')
else:
    print('no')",O(1)
"class Solution(object):
    def minMaxDifference(self, num):
        def f(dst):
            result = 0
            base = 1
            while base <= num:
                base *= 10
            base //= 10
            src = -1
            while base:
                d = num//base%10
                if src == -1 and d != dst:
                    src = d
                result += base*(dst if d == src else d)
                base //= 10
            return result
    
        return f(9)-f(0)",O(logn)
"n,a,b=map(int,input().split())
l=[int(x) for x in input().split()]
l.sort()
print(l[b]-l[b-1])",O(nlogn)
"import math

def get_line(x1, y1, x2, y2):
    a = x2 - x1
    b = y1 - y2
    c = x1 * (y2 - y1) - y1 * (x2 - x1)

    g = math.gcd(math.gcd(a, b), c)
    a //= g
    b //= g
    c //= g
    return a, b, c

n = int(input())
xy = []

for i in range(n):
    x, y = [int(x) for x in input().split()]
    xy.append((x, y))

if n <= 3:
    print(""YES"")
    exit()

def check(x1, y1, x2, y2, xy):
    a1, b1, c1 = get_line(x1, y1, x2, y2)
    other_point = None
    cnt_other = 0
    a2, b2, c2 = 0, 0, 0
    for i in range(len(xy)):
        x, y = xy[i]

        if a1 * y + b1 * x + c1 != 0:
            if other_point is None:
                other_point = x, y
                cnt_other = 1
            elif cnt_other == 1:
                cnt_other = 2
                a2, b2, c2 = get_line(*other_point, x, y)
            else:
                if a2 * y + b2 * x + c2 != 0:
                    return False
    return True

if check(*xy[0], *xy[1], xy[2:]):
    print(""YES"")
elif check(*xy[1], *xy[2], [xy[0]] + xy[3:]):
    print(""YES"")
elif check(*xy[0], *xy[2], [xy[1]] + xy[3:]):
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"import math

line = input().split()
N = int(line[0])
K = int(line[1])

n = (-3 + math.sqrt(9+4*(2*N+2*K)))/2

print(int(N-n))
",O(logn)
"class Solution(object):
    def beautySum(self, s):
        result = 0 
        for i in range(len(s)):
            lookup = [0]*26
            for j in range(i, len(s)):
                lookup[ord(s[j])-ord('a')] += 1
                result += max(lookup) - min(x for x in lookup if x)
        return result",O(n ^ 2)
"n,m=map(int,input().split())
c=input().split()
col=[0]*n
for i in range(len(c)):
    col[int(c[i])-1]+=1
print(min(col))",O(n ^ 2)
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    arr = list(map(int, input().split()))
    color = [0] * n
    arr.sort()

    ans = 0
    for i in range(n):
        if color[i]:
            continue
        ans += 1
        for j in range(i, n):
            if arr[j] % arr[i] == 0:
                color[j] = ans

    print(ans)

    return 0

main()
",O(n ^ 2)
"class Solution(object):
    def generate(self, numRows):
        result = []
        for i in range(numRows):
            result.append([])
            for j in range(i + 1):
                if j in (0, i):
                    result[i].append(1)
                else:
                    result[i].append(result[i - 1][j - 1] + result[i - 1][j])
        return result

    def generate2(self, numRows):
        if not numRows: return []
        res = [[1]]
        for i in range(1, numRows):
            res += [list(map(lambda x, y: x + y, res[-1] + [0], [0] + res[-1]))]
        return res[:numRows]

    def generate3(self, numRows):
        if numRows == 0: return []
        if numRows == 1: return [[1]]
        res = [[1], [1, 1]]

        def add(nums):
            res = nums[:1]
            for i, j in enumerate(nums):
                if i < len(nums) - 1:
                    res += [nums[i] + nums[i + 1]]
            res += nums[:1]
            return res

        while len(res) < numRows:
            res.extend([add(res[-1])])
        return res",O(n ^ 2)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"class Solution:
    def checkValidString(self, s: str) -> bool:
        n = len(s)
        memo = [[None] * (n + 1) for _ in range(n + 1)]

        def dfs(i, open):
            if open < 0:
                return False
            if i == n:
                return open == 0
            if memo[i][open] is not None:
                return memo[i][open]

            if s[i] == '(':
                result = dfs(i + 1, open + 1)
            elif s[i] == ')':
                result = dfs(i + 1, open - 1)
            else:
                result = (dfs(i + 1, open) or
                          dfs(i + 1, open + 1) or
                          dfs(i + 1, open - 1))

            memo[i][open] = result
            return result

        return dfs(0, 0)
",O(n ^ 2)
"s=input()
length=len(s)
answer=[ ]
for i in range (0,length):
    for j in range(i+1,length+1):
        k=s[i:j]
        co=0
        for u in range (0,length):
            if(s[u:].startswith(k)):
                co+=1
        if(co>=2):

            answer.append(len(k))
if(len(set(s))==length):
    print('0')
else:
    print(max(answer))
",O(n ^ 3)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = set()
        posDiag = set()
        negDiag = set()

        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue

                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                board[r][c] = ""Q""

                backtrack(r + 1)

                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"def solve(i, j, k):
    if (i < 0 and j < 0) or (j < 0 and k < 0) or (i < 0 and k < 0):
        return 0
    if dp[i][j][k] != -1:
        return dp[i][j][k]
    ans = 0
    if i >= 0 and j >= 0:
        ans = max(ans, rs[i] * gs[j] + solve(i - 1, j - 1, k))
    if i >= 0 and k >= 0:
        ans = max(ans, rs[i] * bs[k] + solve(i - 1, j, k - 1))
    if j >= 0 and k >= 0:
        ans = max(ans, bs[k] * gs[j] + solve(i, j - 1, k - 1))
    dp[i][j][k] = ans
    return ans

a, b, c = map(int, input().split())
rs = sorted(list(map(int, input().split())))
gs = sorted(list(map(int, input().split())))
bs = sorted(list(map(int, input().split())))
dp = [[[-1 for x in range(c + 1)] for y in range(b + 1)] for z in range(a + 1)]
print(solve(a - 1, b - 1, c - 1))
",O(n ^ 3)
"class Solution(object):
    def subsetXORSum(self, nums):
        result = 0
        for x in nums:
            result |= x
        return result * 2**(len(nums)-1)",O(n)
"n=int(input())
arr=list(map(int, input().split()))
dict={}
rawsum=0
a=n-1
b=1
for i in range(n):
    if i == 0:
	    rawsum = rawsum - (arr[i] * (a))
	    a-=1
    elif i == n - 1:
        rawsum = rawsum + (arr[i] * (b))
        b+=1
    else:
        rawsum = rawsum + (arr[i] * (b))
        rawsum = rawsum - ((arr[i] * (a)))
        a-=1
        b+=1
i=n-1
while i>=0:
    if dict.get(arr[i])==None:
        dict[arr[i]]=1
    else:
        dict[arr[i]]=dict[arr[i]]+1
    s=arr[i]-1
    g=arr[i]+1
    if dict.get(s)!=None:
        rawsum+=dict[s]
    if dict.get(g)!=None:
        rawsum-=dict[g]
    i-=1
print(rawsum)",O(nlogn)
"import math
from math import factorial

def combination(n,r):
    return float(factorial(n)) / float(factorial(r)) / float(factorial(n-r))

a = input()
ap = a.count('+')
am = a.count('-')
b = input()
bp = b.count('+')
bm = b.count('-')
n = b.count('?')
x = float(ap - bp)
y = float(am - bm)
if (x < 0 or y < 0 or x+y != n):
    print(0.0)
else:
    print(combination(n,x)/(1<<n))
",np
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

zz = ( (1,-1), (0,2), (1,-1) )
now = (0,0)
for i in range(N):
    print(now[0],now[1])
    now = ( now[0] + zz[i%3] [0] , now[1] + zz[i%3][1])
",O(n)
"import sys;input = sys.stdin.readline
inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]

r,g,b = ip()
R = [0]+ip()
G = [0]+ip()
B = [0]+ip()
R.sort()
G.sort()
B.sort()
dp = [[[0]*201 for i in range(201)] for j in range(201)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            x = dp[i-1][j-1][k] + R[i]*G[j] if i*j else 0
            y = dp[i][j-1][k-1] + G[j]*B[k] if j*k else 0
            z = dp[i-1][j][k-1] + R[i]*B[k] if i*k else 0
            dp[i][j][k] = max(dp[i][j][k],x,y,z)
print(dp[r][g][b])
",O(n ^ 3)
"import bisect
n=int(input())
s=list(map(int,input().split()))
c=list(map(int,input().split()))
ans=10**18
for mid in range(1,n-1):
  l1=[c[i] for i in range(mid) if s[i]<s[mid]]+[10**18]
  l2=[c[i] for i in range(mid+1,n) if s[i]>s[mid]]+[10**18]
  ans=min(ans,min(l1)+c[mid]+min(l2))
if ans>=10**18:
  print(-1)
else:
  print(ans)",O(n ^ 2)
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
from queue import PriorityQueue as pq
n,m=map(int,input().split())
l=list(map(int,input().split()))
x=dc(int)
c=0
p=0

for i in l:
    x[i]+=1
    f=1
    for i in range(1,n+1):
        if x[i]==0:
            f=0
            break
    if f:
        p+=1
        for i in range(1,n+1):
            x[i]-=1

print(p)",O(n ^ 2)
"class Solution3(object):

    def __init__(self):
        self.stack = []

    def push(self, x):
        if self.stack:
            current_min = min(x, self.stack[-1][0])
            self.stack.append((current_min, x))
        else:
            self.stack.append((x, x))

    def pop(self):
        return self.stack.pop()[1]

    def top(self):
        return self.stack[-1][1]

    def getMin(self):
        return self.stack[-1][0]",O(1)
"from sys import stdin
input = stdin.buffer.readline

n=int(input())
arr=[int(x) for x in input().split()]

arr.sort()
s=set(arr)
flag=False
for ele in arr:
    for i in range(31):
        if ((ele-2**i) in s) and ((ele+2**i) in s):
            ans=[ele,ele-2**i,ele+2**i]
            flag=True
            break
    if flag:
        break
if flag:
    print(3)
    print(*ans)
    exit()
for ele in arr:
    for i in range(31):
        if (ele+2**i) in s:
            ans=[ele,ele+2**i]
            flag=True
            break
    if flag:
        break
if flag:
    print(2)
    print(*ans)
else:
    print(1)
    print(arr[0])",O(nlogn)
"def main():
    k = int(input())
    n = []
    a = []
    for i in range(k):
        line = [int(x) for x in input().split()]
        ni = line[0]
        ai = []
        n.append(ni)
        a.append(ai)
        for j in range(ni):
            ai.append(line[1 + j])
    answer, c, p = solve(k, n, a)
    if answer:
        print(""Yes"")
        for i in range(k):
            print(c[i], p[i] + 1)
    else:
        print(""No"")

def solve(k, n, a):
    asum, sums = calc_sums(k, n, a)
    if asum % k != 0:
        return False, None, None
    tsum = asum / k
    num_map = build_num_map(k, n, a)
    masks = [None]*(1 << k)
    answer = [False]*(1 << k)
    left = [0]*(1 << k)
    right = [0]*(1 << k)
    for i in range(k):
        for j in range(n[i]):
            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict())
            if found:
                answer[mask] = True
                masks[mask] = path
    for mask_right in range(1 << k):
        if not masks[mask_right]:
            continue
        zeroes_count = 0
        for u in range(k):
            if (1 << u) > mask_right:
                break
            if (mask_right & (1 << u)) == 0:
                zeroes_count += 1
        for mask_mask in range(1 << zeroes_count):
            mask_left = 0
            c = 0
            for u in range(k):
                if (1 << u) > mask_right:
                    break
                if (mask_right & (1 << u)) == 0:
                    if (mask_mask & (1 << c)) != 0:
                        mask_left = mask_left | (1 << u)
                    c += 1
            joint_mask = mask_left | mask_right
            if answer[mask_left] and not answer[joint_mask]:
                answer[joint_mask] = True
                left[joint_mask] = mask_left
                right[joint_mask] = mask_right
                if joint_mask == ((1 << k) - 1):
                    return build_answer(k, masks, left, right)
    if answer[(1 << k) - 1]:
        return build_answer(k, masks, left, right)
    return False, None, None

def build_answer(k, masks, left, right):
    c = [-1] * k
    p = [-1] * k
    pos = (1 << k) - 1
    while not masks[pos]:
        for key, val in masks[right[pos]].items():
            c[key] = val[0]
            p[key] = val[1]
        pos = left[pos]
    for key, val in masks[pos].items():
        c[key] = val[0]
        p[key] = val[1]
    return True, c, p

def build_num_map(k, n, a):
    result = dict()
    for i in range(k):
        for j in range(n[i]):
            result[a[i][j]] = (i, j)
    return result

def find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):
    if (mask & (1 << i)) != 0:
        if i == i_origin and j == j_origin:
            return True, mask, path
        else:
            return False, None, None
    mask = mask | (1 << i)
    a_needed = tsum - (sums[i] - a[i][j])
    if a_needed not in num_map:
        return False, None, None
    i_next, j_next = num_map[a_needed]
    path[i_next] = (a[i_next][j_next], i)
    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)

def calc_sums(k, n, a):
    sums = [0] * k
    for i in range(k):
        for j in range(n[i]):
            sums[i] = sums[i] + a[i][j]
    asum = 0
    for i in range(k):
        asum = asum + sums[i]
    return asum, sums

if __name__ == ""__main__"":
    main()
",np
"def factorial(n):
    result = 1
    for i in range(2, n+1):
        result *= i
    return result

commands = input().strip()
received = input().strip()
n = len(commands)
positive = 0
negative = 0
count = 0
for i in range(n):
    if commands[i] == ""+"":
        positive += 1
    else:
        negative += 1
    if received[i] == ""+"":
        positive -= 1
    elif received[i] == ""-"":
        negative -= 1
    else:
        count += 1
cases = 2**count
probability = 0.0
if positive >= 0 and negative >= 0:
    probability = (factorial(count)/(factorial(positive)*factorial(negative)))/cases

print(""{0:.9f}"".format(probability))",np
"n=int(input())
a=int(input())

s=0
t=a
b=[]
for i in range(n):
    s+=t%10
    b.append(t%10)
    t//=10

b.reverse()

i=2
ans=False

if(s==0): ans=True
while(i<=s):

    if(s%i!=0):
        i+=1
        continue
    l=s//i
    c=0
    su=0
    for j in range(n):
        if(su>l):
            break
        else:
            su+=b[j]
            if(su==l):
                su=0
                c+=1
    if(c==i):
        ans=True

    i+=1
if(ans): print(""YES"")
else:print(""NO"")",O(n ^ 2)
"n = int(input())
ans = [(0, 0)]
for i in range(1, n):
    ans.append((0, i))
    ans.append((i, 0))
    ans.append((0, -i))
    ans.append((-i, 0))
for i in range(n):
    print(str(ans[i][0]) + ' ' + str(ans[i][1]))
",O(n)
"class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []



class Solution(object):
    def moveSubTree(self, root, p, q):
        def iter_find_parents(node, parent, p, q, is_ancestor, lookup):
            stk = [(1, [node, None, False])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, parent, is_ancestor = params
                    if node in (p, q):
                        lookup[node] = parent
                        if len(lookup) == 2:
                            return is_ancestor
                    stk.append((2, [node, is_ancestor, reversed(node.children)]))
                else:
                    node, is_ancestor, it = params
                    child = next(it, None)
                    if not child:
                        continue
                    stk.append((2, [node, is_ancestor, it]))
                    stk.append((1, [child, node, is_ancestor or node == p]))
            assert(False)
            return False

        lookup = {}
        is_ancestor = iter_find_parents(root, None, p, q, False, lookup)
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not is_ancestor:
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root",O(n)
"k = int(input())
ch = 0
i = 0
r = 1
while k > r - 1:
    r += 9 * (i + 1) * 10 ** i
    i += 1
r -= 9 * i * 10 ** (i - 1)

print(str((k - r) // i + 10 ** (i - 1))[(k - r) % i]  )
",O(1)
"
class Solution(object):
    def maxSubArray(self, nums):
        result, curr = float(""-inf""), float(""-inf"")
        for x in nums:
            curr = max(curr+x, x)
            result = max(result, curr)
        return result
",O(n)
"class Solution(object):
    def countGoodStrings(self, low, high, zero, one):
        MOD = 10**9+7
        result = 0
        dp = [0]*(high+1)
        dp[0] = 1
        for i in range(1, high+1):
            if i >= zero:
                dp[i] = (dp[i]+dp[i-zero])%MOD
            if i >= one:
                dp[i] = (dp[i]+dp[i-one])%MOD
            if i >= low:
                result = (result+dp[i])%MOD
        return result",O(n)
"class Solution(object):
    def minSwap(self, A, B):
        dp_no_swap, dp_swap = [0]*2, [1]*2
        for i in range(1, len(A)):
            dp_no_swap[i%2], dp_swap[i%2] = float(""inf""), float(""inf"")
            if A[i-1] < A[i] and B[i-1] < B[i]:
                dp_no_swap[i%2] = min(dp_no_swap[i%2], dp_no_swap[(i-1)%2])
                dp_swap[i%2] = min(dp_swap[i%2], dp_swap[(i-1)%2]+1)
            if A[i-1] < B[i] and B[i-1] < A[i]:
                dp_no_swap[i%2] = min(dp_no_swap[i%2], dp_swap[(i-1)%2])
                dp_swap[i%2] = min(dp_swap[i%2], dp_no_swap[(i-1)%2]+1)
        return min(dp_no_swap[(len(A)-1)%2], dp_swap[(len(A)-1)%2])",O(n)
"def f(n):
    k=2
    while k*k<=n:
        if n%k==0:
            return False
        k+=1
    return True
n,k=map(int,input().split())
a=[]
x=0
for i in range(2,n+1):
    if f(i):
        a.append(i)
for i in range(len(a)-2):
    if a[i]+a[i+1]+1 in a:
        x+=1
if x>=k:
    print('YES')
else:
    print('NO')
",O(n)
"x, k = map(int, input().split())
mod = 1000000007
if (k == 0):
    print((2 * x) % mod)
elif (x == 0):
    print(0)
else:
    ans = ((2 * x - 1) * pow(2, k, mod) + 1) % mod
    print(ans)
",O(logn)
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        def backtrack(i, total):
            if i ==len(nums):
                return  total == target

            return (backtrack(i + 1, total + nums[i]) +
                    backtrack(i + 1, total - nums[i]))

        return backtrack(0, 0)
",O(2 ^ n)
"from sys import stdin, stdout, setrecursionlimit
from collections import deque, defaultdict
from bisect import bisect_left

def check(temp):
	if len(temp) < 2:
		return False
	else:
		s = sum(temp)
		if s >= l and s <= r:
			if temp[-1] - temp[0] >= x:
				return True
			else:
				return False
		else:
			return False

def brute(index, temp):
	global count

	if index == n:
		if check(temp):
			count += 1

	else:
		temp.append(arr[index])
		brute(index + 1, temp)
		temp.pop()
		brute(index + 1, temp)

n, l, r, x = list(map(int, stdin.readline().split()))
arr = list(map(int, stdin.readline().split()))
arr.sort()
count = 0
temp = []
brute(0, temp)
print(count)
",np
"s=input()
s1=input()
l=[]
l1=[]
for x in s :
    l.append(int(x))
for x in s1 :
    l1.append(int(x))
d={}
for x in l :
    d[x]=d.get(x,0)+1
f=False
if len(s1)>len(s) :
    l=sorted(l)
    l=l[::-1]
    print("""".join(map(str,l)))
    exit()
ans=[0]*len(s)

ki=0
i=0
while(i<len(l1)) :
    f=True
    for j in range(max(l1[i],ki),-1,-1) :
        if d.get(j,-1)>0 :
            ans[i]=j
            d[j]-=1
            f=False
            if j!=l1[i] :

                ki=9
            break

    if f :

        for i1 in range(i-1,-1,-1) :
            f1=False
            for j in range(max(l1[i1],ki)-1,-1,-1) :
                if d.get(j,-1)>0 :
                    d[ans[i1]]+=1
                    ans[i1]=j
                    d[j]-=1
                    f1=True
                    i=i1
                    ki=9
                    break
            if f1 :
                break
            else :
                d[ans[i1]]+=1
                ans[i1]=0
    i+=1

print("""".join(map(str,ans)))
",O(n ^ 3)
"from math import factorial, pow

def wifi(s1, s2):
    count1, count2, count3 = 0, 0, 0
    for i in range(len(s1)):
        if s1[i] == '+':
            count1 += 1
        elif s1[i] == '-':
            count2 += 1
        if s2[i] == ""+"":
            count1 -= 1
        elif s2[i] == '-':
            count2 -= 1
        else:
            count3 += 1
    if count1 < 0 or count2 < 0:
        return '{:.9f}'.format(0)
    q = factorial(count1 + count2) / (factorial(count1) * factorial(count2))
    r = q / pow(2, count3)
    return r

t1 = input()
t2 = input()
print(wifi(t1, t2))
",np
"import collections
import heapq


class Solution3(object):
    def medianSlidingWindow(self, nums, k):
        def lazy_delete(heap, to_remove, sign):
            while heap and sign*heap[0] in to_remove:
                to_remove[sign*heap[0]] -= 1
                if not to_remove[sign*heap[0]]:
                    del to_remove[sign*heap[0]]
                heapq.heappop(heap)

        min_heap, max_heap = [], []
        for i in range(k):
            if i%2 == 0:
                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))
            else:
                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))
        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]
        to_remove = collections.defaultdict(int)
        for i in range(k, len(nums)):
            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))
            if nums[i-k] > -max_heap[0]:
                heapq.heappush(min_heap, -heapq.heappop(max_heap))
            to_remove[nums[i-k]] += 1
            lazy_delete(max_heap, to_remove, -1)
            lazy_delete(min_heap, to_remove, 1)
            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)
        return result",O(nlogn)
"import math

[n,k]=[int(i) for i in input().split()]

if(n==1):
	print(0)
else:

	r=int(math.sqrt(9+8*(k+n)))
	y=(-3+r)//2
	print(n-y)
",O(logn)
"class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        stones.sort()
        n = len(stones)

        while n > 1:
            cur = stones.pop() - stones.pop()
            n -= 2
            if cur > 0:
                l, r = 0, n
                while l < r:
                    mid = (l + r) // 2
                    if stones[mid] < cur:
                        l = mid + 1
                    else:
                        r = mid
                pos = l
                n += 1
                stones.append(0)
                for i in range(n - 1, pos, -1):
                    stones[i] = stones[i - 1]
                stones[pos] = cur

        return stones[0] if n > 0 else 0
",O(n ^ 2)
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

n,m = map(int, input().split())
a = []
for i in range(n):
    ai = list(map(int, input().split()))
    a.append(ai)

def check(mid):
    mask = (1<<m)-1
    s = set()
    d = dict()
    for i in range(n):
        state = 0
        for j in range(m):
            if a[i][j] >= mid:
                state += 1<<j
        if state in s:
            continue
        s.add(state)
        k = state
        while k>=0:
            k &= state
            d[k] = i
            k -= 1
        need = mask^state
        if need in d:
            q1, q2 = d[need], i
            if q1 > q2:
                q1, q2 = q2, q1
            return True, (q1, q2)
    return False, (-1, -1)

left = 0
right = 10**9+1
i,j = 0, 0
while right-left>1:
    mid = (right+left)//2
    flag, (q1, q2) = check(mid)
    if flag:
        left = mid
        i,j = q1, q2
    else:
        right = mid
print(i+1, j+1)
",np
"k,n,s,p = map(int,input().split())
x = (n+s-1)//s
x *= k
print((x+p-1)//p)
",O(1)
"class Solution2(object):
    def isDecomposable(self, s):
        found, i = False, 0
        while i < len(s):
            l = 1
            for j in range(i+1, min(i+3, len(s))):
                if s[j] != s[i]:
                    break
                l += 1
            if l < 2:
                return False
            if l == 2:
                if found:
                    return False
                found = True
            i += l  
        return found",O(n)
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort

from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal

INF = 10001
mod = int(1e9) + 7

n=int(data())
a=mdata()
ans=[n]
dp1=[[0]*n for i in range(n)]
dp2=[[n]*n for i in range(n)]
for i in range(n-1,-1,-1):
    dp1[i][i]=a[i]
    dp2[i][i]=1
    for j in range(i+1,n):
        for k in range(i,j):
            if dp1[i][k] == dp1[k+1][j] != 0:
                dp1[i][j] = dp1[i][k] + 1
                dp2[i][j] = 1
            dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + 1][j])
out(dp2[0][n-1])",O(n ^ 3)
"def check(x: int) -> (int, int):
    vis = {}
    for i, array in enumerate(a):
        t = 0
        for j, val in enumerate(array):
            if val >= x:
                t |= 1 << j
        vis[t] = i
    if (1 << m) - 1 in vis:
        return vis[(1 << m) - 1], vis[(1 << m) - 1]
    for i in range(1, (1 << m) - 1):
        for j in range(1, (1 << m) - 1):
            if i in vis and j in vis and i | j == (1 << m) - 1:
                return vis[i], vis[j]
    return -1, -1

if __name__ == '__main__':
    n, m = map(int, input().split())
    a = []
    for i in range(n):
        a.append(list(map(int, input().split())))
    l = 0
    r = int(1e9)
    while l <= r:
        mid = l + r >> 1
        if check(mid) != (-1, -1):
            l = mid + 1
        else:
            r = mid - 1
    ans = check(r)
    print(""%d %d"" % (ans[0] + 1, ans[1] + 1))
",np
"n, m = list(map(int,input().split()))
x = list(map(int,input().split()))
t = list(map(int,input().split()))
arr = []
pep = {}
for i in range(n+m):
    if t[i] == 0:
        arr.append(i)
        pep[x[i]] = 0
    else:
        for j in arr:
            pep[x[j]] = i
        arr = []
for i in range(n+m-1, -1, -1):
    if t[i] == 0:
        arr.append(i)
    else:
        for j in arr:
            if abs(x[j] - x[i]) <= abs(x[pep[x[j]]] - x[j]):
                pep[x[j]] = i
        arr = []
ans = []
for i in range(n+m):
    if t[i]:
        ans.append(1)
    else:
        ans.append(0)
for i in pep:
    ans[pep[i]] += 1
for i in ans:
    if i:
        print(i-1, end = ' ')
",O(n ^ 2)
"k=int(input(""""))
t=0
if k==0:
    print(""Invalid input"")
    exit()
d=0
e=0
n=5
while(1):
    u=9*n*(10**n)+1-(10**n)-9*k
    if u>0:
        d+=1
        if e>0:
            u=i
            break
        n=n-1
    elif u<0:
        i=u
        e+=1
        if d>0:
            n=n+1
            break
        n=n+1
    else:
        print(9)
        exit()
import math
u=abs(u)
u=u//9
m=u//n
p=u%(n)
if p==0:
    q=10**(n-1)+m-1
    o=q%10
else:
    q = 10**(n-1) + m
    o=((q//(10**(n-p)))%10)
print(o)",O(logn)
"x,k = map(int,input().split())
if(x==0):
    print(0)
    exit(0)
m = 10**9+7
p = pow(2,k+1,m)
q = pow(2,k,m)
a = (x*p-q+1)%m
print(a)
",O(logn)
"class Solution2(object):

    def __init__(self):
        self.__arr = []
        self.__op = [1, 0]

    def append(self, val):
        self.__arr.append((val-self.__op[1])*pow(self.__op[0], MOD-2, MOD)%MOD) 

    def addAll(self, inc):
        self.__op[1] = (self.__op[1]+inc) % MOD

    def multAll(self, m):
        self.__op = [(self.__op[0]*m) % MOD, (self.__op[1]*m) % MOD]

    def getIndex(self, idx):
        if idx >= len(self.__arr):
            return -1
        a, b = self.__op
        return (self.__arr[idx]*a + b) % MOD",O(1)
"import sys
input = sys.stdin.readline

RI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]
rw = lambda : input().strip().split()
from collections import defaultdict as df

import random

infinite = float('inf')

t=int(input())

for _ in range(t):
    n,k=RI()
    s=input()

    mini=n

    test=""RGB""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""GBR""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""BRG""*(k//3 + 5)
    for i in range(n-k+1):
        count=0

        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    print(mini)
",O(n ^ 2)
"class Solution2(object):
    def lengthOfLastWord(self, s):
        return len(s.strip().split("" "")[-1])",O(n)
"import sys
input = sys.stdin.readlines()
n = int(input[0].strip())
m = 10**9 + 7
curr = [0] * (n+20)
last = [0] * (n+20)
curr[0] = 1
for s in range(1,n):
    last, curr = curr, last
    if input[s]=='f\n':
        curr[0] = 0
        for i in range(len(last)-1):
            curr[i+1] = last[i]
    elif input[s]=='s\n':
        curr[-1] = 0
        for i in range(len(last)-2, -1, -1):
            curr[i] = (curr[i+1] + last[i]) % m
s = 0
for x in curr:
    s = (s + x) % m
print(s)",O(n ^ 2)
"def sum(l):
    s=0
    for i in range(len(l)):
        s+=l[i]
    return s

n=int(input())
cns=list(map(int,input().split()))
xs,nm,c=0,0,0
cns.append(0)
while(xs<=nm):
    m=max(cns)
    cns.remove(m)
    xs+=m
    nm=sum(cns)
    c+=1
print(c)
",O(nlogn)
"import collections


class Solution(object):
    def majorityElement(self, nums):
        def boyer_moore_majority_vote():
            result, cnt = None, 0
            for x in nums:
                if not cnt:
                    result = x
                if x == result:
                    cnt += 1
                else:
                    cnt -= 1
            return result

        return boyer_moore_majority_vote()",O(n)
"class Solution(object):
    def stoneGameVIII(self, stones):
        for i in range(len(stones)-1):
            stones[i+1] += stones[i]
        return reduce(lambda curr, i: max(curr, stones[i]-curr), reversed(range(1, len(stones)-1)), stones[-1])",O(n)
"from math import *

n=int(input())
A = list(map(int,input().split()))
ans =-1
maxs = 0
for j in range(n):
    if(A[j] > maxs):
        ans = j+1
        break
    else:
        maxs = max(maxs,A[j]+1)
print(ans)",O(n)
"class Solution(object):
    def arithmeticTriplets(self, nums, diff):
        lookup = set(nums)
        return sum((x-diff in lookup) and (x-2*diff in lookup) for x in nums)

import collections",O(n)
"n,m=map(int,input().split())

vert=[]

for i in range(n):
    v=int(input())
    vert.append(v)

horz=[]

for i in range(m):
    x1,x2,y=map(int,input().split())
    if x1==1:
        horz.append(x2)

vert.sort()
horz.sort()

vert.append(1000000000)

def next(k,a,x):
    while k<len(a) and a[k]<x:
        k+=1
    return k

num=next(0,horz,vert[0])

ans=len(horz)-num

for i in range(1,len(vert)):
    num2=next(num,horz,vert[i])
    t=i+len(horz)-num2
    if t<ans: ans=t
    num=num2

print(ans)
",O(nlogn)
"import sys
from collections import defaultdict

input = sys.stdin.readline

n, m = map(int, input().split())

vals = set()
locs = defaultdict(list)
for i in range(n):
    inp = map(int, input().split())
    for pos, v in enumerate(inp):
        vals.add(v)
        locs[v].append((pos, i))

masks = [0] * n
full = (1<<m) - 1
met = {0:0}
for v in sorted(vals, reverse=True):
    for pos, i in locs[v]:
        curr_mask = masks[i] = masks[i] | (1<<pos)
        met[curr_mask] = i
        complement = full ^ curr_mask
        if complement in met:
            print(i+1, met[complement]+1)
            sys.exit()",np
"class Solution(object):
    def splitLoopedString(self, strs):
        tmp = []
        for s in strs:
            tmp += max(s, s[::-1])
        s = """".join(tmp)

        result, st = ""a"", 0
        for i in range(len(strs)):
            body = """".join([s[st + len(strs[i]):], s[0:st]])
            for p in strs[i], strs[i][::-1]:
                for j in range(len(strs[i])):
                    if p[j] >= result[0]:
                        result = max(result, """".join([p[j:], body, p[:j]]))
            st += len(strs[i])
        return result",O(n ^ 2)
"from sys import stdin,stdout
from itertools import accumulate
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n,x=lst()
    a=lst()
    ans=0
    s=set(a)
    if len(s) != n:
        print(0)
        continue
    for i in range(n):
        v=a[i]
        a[i]&=x
        if a[i] in s and v!=a[i]:

            ans=1
            break
    if ans==1:print(1)
    elif len(set(a))==n:print(-1)
    else:print(2)",O(n)
"class Solution2(object):
    def findTheWinner(self, n, k):
        def f(idx, n, k):
            if n == 1:
                return 0
            return (k+f((idx+k)%n, n-1, k))%n
        
        return f(0, n, k)+1",O(n)
"import sys
k=int(input())
if type(k)!=int or k<=0 or k>pow(10,12) :
        print(""wrong input. try again"")
        sys.exit()
lim_init=lim=decimal=9
c=0
while True:
        c+=1
        if k<=lim:
                diff=lim-k
                pos=diff%c
                diff=int(diff/c)
                diff=decimal-diff
                print(''.join(list(reversed(str(diff))))[pos])
                break
        else:
                decimal = int(str(lim_init)*(c+1))
                lim+=int(str(lim_init)+'0'*c)*(c+1)
",O(logn)
"n = int(input())
b = []
bb =[]
for i in range(n):
    x=int(input())
    idx = 0
    for j in range(len(b)):
        nxt = b[j] ^ x
        if nxt < x :
            x = nxt
            idx ^= bb[j]
    if x == 0:
        cnt = 0
        v = []
        for k in range(2000):
            if idx & (1 << k) :
                v.append(k)
        print(len(v),end=' ')
        for e in v:
            print(e,end=' ')
        print()
    else :
        print(0)
        idx ^= 1 << i
        b.append(x)
        bb.append(idx)
",np
"class Solution(object):
    def totalNQueens(self, n):
        def dfs(row):
            if row == n:
                return 1
            result = 0
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                result += dfs(row+1)
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False
            return result

        result = []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        return dfs(0)",O(n!)
"class Solution(object):
    def maximumGap(self, nums):
        if len(nums) < 2:
            return 0

        max_val, min_val = max(nums), min(nums)
        gap = max(1, (max_val - min_val) / (len(nums) - 1))
        bucket_size = (max_val - min_val) / gap + 1
        bucket = [{'min':float(""inf""), 'max':float(""-inf"")} \
                    for _ in range(bucket_size)]

        for n in nums:
            if n in (max_val, min_val):
                continue
            i = (n - min_val) / gap
            bucket[i]['min'] = min(bucket[i]['min'], n)
            bucket[i]['max'] = max(bucket[i]['max'], n)

        max_gap, pre_bucket_max = 0, min_val
        for i in range(bucket_size):
            if bucket[i]['min'] == float(""inf"") and \
                bucket[i]['max'] == float(""-inf""):
                continue
            max_gap = max(max_gap, bucket[i]['min'] - pre_bucket_max)
            pre_bucket_max = bucket[i]['max']
        max_gap = max(max_gap, max_val - pre_bucket_max)

        return max_gap",O(n)
"import sys
n=int(input())
ind=0
dig=0
for i in range(1,12):
    dig+=i*10**(i-1)*9

    if dig>n:
        ind=i-1
        rt=dig-i*10**(i-1)*9
        break
n-=rt
no=10**ind

if n==0:
    print(9)
    sys.exit()
u=n
n-=(n//(ind+1))*(ind+1)
no+=max(0,(u//(ind+1))-1)

if n==0:
    print(str(no)[-1])
else:
    no+=1
while(n>0):
    if n<=ind+1:
        e=str(no)
        print(e[n-1])
    n-=ind+1
    no+=1
",O(logn)
"class Solution2(object):
    def postorderTraversal(self, root):
        result, stack = [], [(root, False)]
        while stack:
            root, is_visited = stack.pop()
            if root is None:
                continue
            if is_visited:
                result.append(root.val)
            else:
                stack.append((root, True))
                stack.append((root.right, False))
                stack.append((root.left, False))
        return result",O(n)
"from math import sqrt
n, r = input().split()
n = int(n)
r = int(r)
x = []
arr = []
inpArr = input().split("" "")
for i in inpArr:
    x.append(int(i))

for i in range(n):
    arr.append(r)
    for j in range(i):
        if (abs(x[j] - x[i]) <= (r * 2)):
            arr[i] = max(arr[i], (arr[j] + sqrt((r*r*4)-((x[j] - x[i])*(x[j] - x[i])))  ))
arr1 = []
for i in arr:
    arr1.append(str(i))
print("" "".join(arr1))
",O(n ^ 2)
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n = inp()
s = []
for _ in range(4):
    tmp = [input() for i in range(n)]
    if _<3: input()
    s.append(tmp)
res = INF
for pt in itertools.combinations(range(4),2):
    cnt = 0
    for k in range(4):
        f = 1 if k in pt else 0
        for i in range(n):
            for j in range(n):
                if (i+j+f)%2 != int(s[k][i][j]): cnt += 1
    res = min(res, cnt)
print(res)",O(n ^ 2)
"class Solution(object):
    def boxDelivering(self, boxes, portsCount, maxBoxes, maxWeight):
        dp = [0]*(len(boxes)+1)
        left, cost, curr = 0, 1, 0
        for right in range(len(boxes)):
            if right == 0 or boxes[right][0] != boxes[right-1][0]:
                cost += 1
            curr += boxes[right][1]
            while right-left+1 > maxBoxes or \
                  curr > maxWeight or \
                  (left+1 < right+1 and dp[left+1] == dp[left]): 
                curr -= boxes[left][1]
                if boxes[left+1][0] != boxes[left][0]:
                    cost -= 1
                left += 1
            dp[right+1] = dp[(left-1)+1] + cost
        return dp[len(boxes)]",O(n)
"n=int(input())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
ha={}
for i in range(n):
    ha[a[i]]=i
removed=0
out=""""
for i in range(n):
    if ha[b[i]]<removed:
        out+=""0 ""
    else:
        out+=str(ha[b[i]]-removed+1)+"" ""
        removed=ha[b[i]]+1
print(out[:-1])",O(n)
"from math import *
n = int(input())
if n%2==0:
    print(n-8,n-(n-8))
else:
    print((n-9),n-(n-9))
",O(1)
"a=''.join(reversed(sorted(input())))
b=int(input())
r=''
while len(a)>0:
    for i in range(len(a)):
        n=r+a[i]+''.join(sorted(a[:i]+a[i+1:]))
        if int(n)<=b:
            r+=a[i]
            a=a[:i]+a[i+1:]
            break
print(r)",O(n ^ 3)
"
from collections import defaultdict
from operator import getitem


class Solution(object):
    def longestWord(self, words):
        _trie = lambda: defaultdict(_trie)
        trie = _trie()
        for i, word in enumerate(words):
            reduce(getitem, word, trie)[""_end""] = i

        stack = list(trie.values())
        result = """"
        while stack:
            curr = stack.pop()
            if ""_end"" in curr:
                word = words[curr[""_end""]]
                if len(word) > len(result) or (len(word) == len(result) and word < result):
                    result = word
                stack += [curr[letter] for letter in curr if letter != ""_end""]
        return result

",O(n)
"class Solution(object):
    def wateringPlants(self, plants, capacity):
        result, can = len(plants), capacity
        for i, x in enumerate(plants):
            if can < x:
                result += 2*i
                can = capacity
            can -= x
        return result",O(n)
"class Solution(object):
    def colorRed(self, n):
        result = [[1, 1]]
        for i in range(2, n+1):
            if i%2 == n%2:
                result.extend([i, j] for j in range((1 if i%4 == n%4 else 3), 2*i, 2))
            else:
                result.append([i, (2 if i%4 == (n-1)%4 else 1)])
        return result",O(n ^ 2)
"import sys
input = sys.stdin.readline

n, m, k = map(int, input().split())
A = [[0] * (m) for _ in range(n)]
B = [[0] * (m) for _ in range(n)]
for i in range(n):
    tmp = list(map(int, input().split()))
    for j in range(m - 1):
        A[i][j + 1] = tmp[j]
for i in range(n - 1):
    tmp = list(map(int, input().split()))
    for j in range(m):
        B[i + 1][j] = tmp[j]

if k % 2:
    ans = [[-1] * m for _ in range(n)]
    for a in ans:
        print(*a)
    sys.exit()
ans = [[0] * m for _ in range(n)]
lim = k // 2
dp = [[[float(""inf"")] * (lim + 1) for _ in range(m)] for _ in range(n)]
for i in range(n):
    for j in range(m):
        dp[i][j][0] = 0

for k in range(1, lim + 1):
    for i in range(n):
        for j in range(m):
            if i: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + B[i][j])
            if j: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + A[i][j])
            if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + B[i + 1][j])
            if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + A[i][j + 1])
for i in range(n):
    for j in range(m):
        ans[i][j] = dp[i][j][-1] * 2
for a in ans:
    print(*a)",O(n ^ 3)
"n,l,r,x=map(int,input().split())
c=list(map(int,input().split()))
ans=0
for i in range(0,2**n):
    v=[]
    for j in range(n):
        if i & (1<<j):v.append(c[j])
    if sum(v)>=l and sum(v)<=r and (max(v)-min(v)>=x): ans+=1
print(ans)",np
"class Solution(object):
    def rob(self, root):
        def robHelper(root):
            if not root:
                return (0, 0)
            left, right = robHelper(root.left), robHelper(root.right)
            return (root.val + left[1] + right[1], max(left) + max(right))

        return max(robHelper(root))",O(n)
"n=int(input())
a=list(map(int,input().split()))
grip=[[-1]*(n-i) for i in range(n)]
grip[0]=a.copy()
for level in range(1,n):
    for left in range(n-level):
        for split in range(level):
            pl=grip[level-split-1][left]
            pr=grip[split][left+level-split]
            if pl==pr!=-1:
                grip[level][left]=pl+1
pref=[0]*(n+1)
for p in range(1,n+1):
    x=n
    for j in range(p):
        l=pref[j]
        r=grip[p-j-1][j]
        if r==-1:
            r=p-j
        else:
            r=1
        x=min(x,l+r)
    pref[p]=x
print(pref[-1])
",O(n ^ 3)
"class Solution(object):
    def deleteString(self, s):
        if all(x == s[0] for x in s):
            return len(s)
        dp2 = [[0]*(len(s)+1) for i in range(2)] 
        dp = [1]*len(s) 
        for i in reversed(range(len(s)-1)):
            for j in range(i+1, len(s)):
                dp2[i%2][j] = dp2[(i+1)%2][j+1]+1 if s[j] == s[i] else 0
                if dp2[i%2][j] >= j-i:
                    dp[i] = max(dp[i], dp[j]+1)
        return dp[0]",O(n ^ 2)
"import sys
def ask(i):
    print('?', i + 1)
    sys.stdout.flush()
    a_i = int(input())
    return a_i
def answer(i):
    print('!', i + 1 if i != -1 else -1)
    sys.exit()

def has_intersection(l1, r1, l2, r2):
    if l1 <= l2 and r2 <= r1:
        return True
    if l2 <= l1 and r1 <= r2:
        return True
    return False

n = int(input())
assert n >= 2 and n % 2 == 0
if (n // 2) % 2 == 1:
    answer(-1)
else:
    assert n % 4 == 0
    l1 = 0
    r1 = n // 2
    a_l1 = ask(l1)
    a_r1 = ask(r1)
    if a_l1 == a_r1:
        answer(0)
    a_l2 = a_r1
    a_r2 = a_l1

    while True:
        m1 = (l1 + r1) // 2
        m2 = (m1 + n // 2) % n
        a_m1 = ask(m1)
        a_m2 = ask(m2)
        if a_m1 == a_m2:
            answer(m1)
        if has_intersection(a_l1, a_m1, a_l2, a_m2):
            r1 = m1
            a_r1 = a_m1
            a_r2 = a_m2
        else:
            assert has_intersection(a_m1, a_r1, a_m2, a_r2)
            l1 = m1
            a_l1 = a_m1
            a_l2 = a_m2

assert False
",O(logn)
"import sys
input = sys.stdin.readline
n, m = map(int, input().split())

MOD = m
MAX_N = 10**3

fac = [1] + [0] * MAX_N
for i in range(1, MAX_N+1):
    fac[i] = fac[i-1] * (i) % MOD

fac_inv = [1] + [0] * MAX_N

fac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD)
for i in range(MAX_N, 1, -1):
    fac_inv[i-1] = fac_inv[i] * i % MOD

def mod_nCr(n, r):
    if n < r or n < 0 or r < 0:
        return 0
    tmp = fac_inv[n-r] * fac_inv[r] % MOD
    return tmp * fac[n] % MOD

pow2 = [0] * (n+1)
pow2[0] = 1
for i in range(1, n+1):
    pow2[i] = pow2[i-1] * 2 % MOD

table = [[0] * 500 for _ in range(500)]
for i in range(500):
    for j in range(i+1):
        table[i][j] = mod_nCr(i, j)

dp = [[0] * (n+1) for _ in range(n)]
for i in range(n):
    dp[i][i+1] = pow2[i]
for i in range(n-1):
    for j in range(i // 2 + 1, n-1):
        if dp[i][j] == 0:
            continue
        dp[i][j] %= MOD
        for k in range(1, n-j):
            if i + k + 1 >= n:
                break

            dp[i+k+1][j+k] += dp[i][j] * pow2[k-1] * table[k + j][k]

ans = sum(dp[-1]) % MOD
print(ans)",O(n ^ 3)
"s=input()
n=len(s)
l=[[0,0,0] for i in range(n)]
ans=0
x=int(s[0])%3
if(x==0):
    ans+=1
else:
    l[0][x]=1
for i in range(1,n):
    x=int(s[i])%3
    if(x==0):
        ans+=1
        continue

    if(l[i-1][3-x]>0):
        ans+=1
        l[i][3-x]=0
        l[i][x]=0
    else:
        if(l[i-1][x]!=0):
            l[i][1]=1
            l[i][2]=1
        else:
            l[i][x]=1

print(ans)",O(n)
"x= int(input(""""))
print(int((x/2)*3))",O(1)
"import sys
import io, os
import math
from heapq import *
gcd = math.gcd
sqrt = math.sqrt
ceil = math.ceil

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
def print(x, end):
    sys.stdout.write(str(x) + end)
def strinp(testcases):
    k = 5
    if (testcases == -1 or testcases == 1):
        k = 1
    f = str(input())
    f = f[2:len(f) - k]
    return f
def ind(ch):
    return ord(ch)-ord(""a"")
def cleanarr(arr):
    n = len(arr)

    arr.sort()
    c = []
    curr=[arr[0], 1]
    for i in range(n - 1):
        if (arr[i] != arr[i + 1]):
            if(curr[1]>=2):
                c.append(curr)
            curr=[arr[i+1],1]
        else:
            curr[1] += 1
    if(curr[1]>=2):
        c.append(curr)
    return c
def main():
    t=int(input())
    for _ in range(t):
        n=int(input())
        arr=list(map(int, input().split()))
        g=arr[0]
        c=cleanarr(arr)
        if(n>=40000):
            f=0
            for i in range(len(c)):
                if(c[i][1]>=4):
                    f=c[i][0]
                    break
            print(f,"" "")
            print(f,"" "")
            print(f,"" "")
            print(f,""\n"")
            continue
        mi=10**18
        pair=[-1,-1]
        for i in range(len(c)):
            if(c[i][1]>=4):
                pair=[c[i][0],c[i][0]]
                break
            if(i==len(c)-1):
                break
            a=c[i][0]
            b=c[i+1][0]
            if(mi==10**18):
                pair=[a,b]
                mi=0
                continue
            if ((((pair[0]+pair[1])**2)*a*b)-(((a+b)**2)*pair[0]*pair[1])>0):
                pair=[a,b]
        print(pair[0],"" "")
        print(pair[0],"" "")
        print(pair[1],"" "")
        print(pair[1],""\n"")
main()",O(nlogn)
"import math
from decimal import Decimal

def sum2(s, e):
    return sum1(e) - sum1(s - 1) - (e - s)

def sum1(i):
    return i * (i + 1) / 2

line = input().split()
n = Decimal(line[0])
k = Decimal(line[1])
if(n == 1):
    print(0)
elif(k > n):
    print(1)
elif(sum2(Decimal(2),k) < n):
    print(-1)
else:
    c = 2 * n + k - k * k
    discriminant = (9 - 4 * c).sqrt()
    tmp = discriminant / 2
    const = Decimal(3/2)
    res1 = math.floor(const + tmp)
    res2 = math.floor(const - tmp)
    res1 = max(res1, res2)
    print(k - res1 + 1);",O(logn)
"n=int(input())
l=[int(x) for x in input().split()]
ans=0;
while len(l)>0:
	a=l[0]
	l=l[1:]
	ans+=l.index(a)
	l.remove(a)
print(ans)",O(n ^ 2)
"n = int(input())
x, y = map(int, input().split())

if abs(x - 1) + abs(y - 1) <= abs(x - n) + abs(y - n):
    print('White')
else:
    print('Black')
",O(1)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: x[1])
        n = len(intervals)
        dp = [0] * n
        dp[0] = 1

        def bs(r, target):
            l = 0
            while l < r:
                m = (l + r) >> 1
                if intervals[m][1] <= target:
                    l = m + 1
                else:
                    r = m
            return l

        for i in range(1, n):
            idx = bs(i, intervals[i][0])
            if idx == 0:
                dp[i] = dp[i - 1]
            else:
                dp[i] = max(dp[i - 1], 1 + dp[idx - 1])
        return n - dp[n - 1]
",O(nlogn)
"class Solution(object):
    def minimumDifference(self, nums, k):
        nums.sort()
        return min(nums[i]-nums[i-k+1] for i in range(k-1, len(nums)))",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import collections
import itertools
import bisect
import heapq

import random

def main():
    pass

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def primeFactorsCount(n):
    cnt=0
    while n % 2 == 0:
        cnt+=1
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            cnt+=1
            n = n // i
    if n > 2:
        cnt+=1
    return (cnt)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)

def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)

def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum

def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m

def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)

def p2(n):
    c = 0
    while (n % 2 == 0):
        n //= 2
        c += 1
    return c

def seive(n):
    primes = [True] * (n + 1)
    primes[1] = primes[0] = False
    i = 2
    while (i * i <= n):
        if (primes[i] == True):
            for j in range(i * i, n + 1, i):
                primes[j] = False
        i += 1
    pr = []
    for i in range(0, n + 1):
        if (primes[i]):
            pr.append(i)
    return pr

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

def denofactinverse(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (pow(fac, m - 2, m))

def numofact(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (fac)

def sod(n):
    s = 0
    while (n > 0):
        s += n % 10
        n //= 10
    return s

n=int(input())
l=list(map(int,input().split()))
inv=0
for i in range(1,n):
    for j in range(0,i):
        if(l[j]>l[i]):
            inv+=1

for i in range(0,int(input())):
    f,r=map(int,input().split())
    p=(r-f+1)//2

    inv+=p%2

    if(inv%2):
        print(""odd"")
    else:
        print(""even"")
",O(n ^ 2)
"import os,sys
from io import BytesIO,IOBase

def main():
    n,c = map(int,input().split())
    a = list(map(int,input().split()))
    nums = [[0] for _ in range(500001)]
    freq,minus = [0]*500001,0
    for i in a:
        if i == c:
            minus += 1
        else:
            freq[i] += 1
            nums[i].append(freq[i]-minus)
    tot = minus
    suff = [i[:] for i in nums]
    for i in range(500001):
        for j in range(len(nums[i])-2,0,-1):
            suff[i][j] = max(suff[i][j],suff[i][j+1])
    freq,ans = [0]*500001,tot
    for i in a:
        if i == c:
            continue
        freq[i] += 1
        ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot)
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(n)
"from math import gcd

def t_prime(n):
    if n == 1:
        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:
            return False
    return True

primes = [i for i in range(2,10**5) if t_prime(i)]
pset = set(primes)

n, k = map(int, input().split())
l = list(map(int, input().split()))

if k == 1:
    print(0)
    exit()

for i in range(n):
    for j in range(i):
        u, v = l[i], l[j]
        poss = gcd(u,v)
        poss2 = max(u,v)//poss
        smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:
            primes.append(smol)
            pset.add(smol)

powers = set()

count = 0
outLs = []
pgood = []
for p in primes:
    curr = []
    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:
            v2 //= p
        if v2 == 1:
            curr.append(v)
            powers.add(v)
    if len(curr) > 1:
        count += len(curr)
        outLs.append(curr)
        pgood.append(p)

order = [(len(lis), lis) for lis in outLs]
order.sort(key = lambda x: x[0])

if len(order) == 0:
    print(0)
    exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []

    for v in l:
        if v in powers:
            continue

        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2

    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()

    other = []
    out = [extra]

    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k

    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1

    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0

assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:
        break

    if v in powers:
        continue

    v2 = v
    for p in pgood:
        while v2 % p == 0:
            v2 //= p
    if v2 == 1:
        out.append(v)
        need -= 1

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)
",np
"class Solution(object):
    def maxSatisfied(self, customers, grumpy, X):
        result, max_extra, extra = 0, 0, 0
        for i in range(len(customers)):
            result += 0 if grumpy[i] else customers[i]
            extra += customers[i] if grumpy[i] else 0
            if i >= X:
                extra -= customers[i-X] if grumpy[i-X] else 0
            max_extra = max(max_extra, extra)
        return result + max_extra",O(n)
"class Solution(object):
    def isValid(self, S):
        stack = []
        for i in S:
            if i == 'c':
                if stack[-2:] == ['a', 'b']:
                    stack.pop()
                    stack.pop()
                else:
                    return False
            else:
                stack.append(i)
        return not stack",O(n)
"class Solution:
    def climbStairs(self, n: int) -> int:

        def dfs(i):
            if i >= n:
                return i == n
            return dfs(i + 1) + dfs(i + 2)

        return dfs(0)
",O(2 ^ n)
"class Solution(object):
    def minStartValue(self, nums):
        min_prefix, prefix = 0, 0
        for num in nums:
            prefix += num
            min_prefix = min(min_prefix, prefix)
        return 1-min_prefix",O(n)
"class Solution2(object):
    def distributeCandies(self, n, limit):
        return sum(min(limit, n-i)-max((n-i)-limit, 0)+1 for i in range(max(n-2*limit, 0), min(limit, n)+1))",O(n)
"class Solution(object):
    def equalSubstring(self, s, t, maxCost):
        left = 0
        for right in range(len(s)):
            maxCost -= abs(ord(s[right])-ord(t[right]))
            if maxCost < 0:
                maxCost += abs(ord(s[left])-ord(t[left]))
                left += 1
        return (right+1)-left",O(n)
"a, b = map(int, input().split())
print((b+a-1)//a)
",O(1)
"from math import inf

if True:
    n,m,k = map(int,input().split())
    cosp = [[int(x) for x in input().split()]+[inf] for _ in range(n)]
    cosv = [[int(x) for x in input().split()]for _ in range(n-1)]+[[inf]*m]
    if k%2==1:
        for _ in range(n):
            print(*[-1]*m)

    else:
        dp = [[0]*m for i in range(n)]
        xx,yy = [0,0,1,-1],[1,-1,0,0]
        for _ in range(k//2):
            dp1 = [[inf]*m for _ in range(n)]
            for i in range(n):
                for j in range(m):
                    for kk in range(4):
                        x1,y1 = i+xx[kk],j+yy[kk]
                        if kk < 2:
                            if kk==1:
                                edge = cosp[i][j-1]
                            else:
                                edge=cosp[i][j]
                        else:
                            if kk==3 :
                                edge = cosv[i-1][j]
                            else:
                                edge = cosv[i][j]
                        if edge != inf:
                            dp1[i][j] = min(dp1[i][j],2*edge+dp[x1][y1])
            dp = dp1[:]
        for i in dp:
            print(*i)",O(n ^ 3)
"class Solution2(object):
    def maximumOddBinaryNumber(self, s):
        n = s.count('1')
        return """".join(['1']*(n-1)+['0']*(len(s)-n)+['1'])",O(n)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = 0
        posDiag = 0
        negDiag = 0
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            nonlocal col, posDiag, negDiag
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if ((col & (1 << c)) or (posDiag & (1 << (r + c)))
                    or (negDiag & (1 << (r - c + n)))):
                    continue
                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = ""Q""

                backtrack(r + 1)

                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"n,m=map(int,input().split())
s=[]
st=set()
cst=set()
for i in range(n):
    s.append(input())
    for j in range(len(s[i])):
        if s[i][j]=='
            st.add((i,j))
for i in range(1,n-1):
    for j in range(1,m-1):
        if s[i-1][j-1]!='
            continue
        if s[i - 1][j ] != '
            continue
        if s[i-1][j+1]!='
            continue
        if s[i][j-1]!='
            continue
        if s[i][j+1]!='
            continue
        if s[i+1][j-1]!='
            continue
        if s[i+1][j]!='
            continue
        if s[i+1][j+1]!='
            continue
        cst.add((i-1,j))
        cst.add((i - 1, j-1))
        cst.add((i - 1, j+1))
        cst.add((i + 1, j))
        cst.add((i + 1, j-1))
        cst.add((i + 1, j+1))
        cst.add((i , j+1))
        cst.add((i , j-1))
if len(cst)==len(st):
    print('YES')
else:
    print('NO')",O(n ^ 2)
"from math import *
a, vm = map(int, input().split())
l, d, vd = map(int, input().split())
if vm <= vd or sqrt(2 * a * d) <= vd:
    if vm ** 2 / (2 * a) >= l:
        ans = sqrt(2 * l / a)
    else:
        ans = vm / a + (l - vm ** 2 / (2 * a)) / vm
else:
    s1 = (vm ** 2 - vd ** 2) / (2 * a)
    if s1 >= (l - d):
        ans = (sqrt(4 * (vd ** 2) + 8 * a * (l - d)) - 2 * vd) / (2 * a)
    else:
        ans = (vm - vd) / a + (l - d - s1) / vm
    v1 = sqrt((2 * a * d + vd ** 2) / 2)
    if v1 <= vm:
        ans = ans + v1 / a + (v1 - vd) / a
    else:
        s1 = d - (vm ** 2 - vd ** 2) / (2 * a) - (vm ** 2) / (2 * a)
        ans = ans + vm / a + (vm - vd) / a + s1 / vm
print('%.12f' % ans)
",O(1)
"class Solution(object):
    def bestClosingTime(self, customers):
        result = mx = curr = 0
        for i, x in enumerate(customers):
            curr += 1 if x == 'Y' else -1
            if curr > mx:
                mx = curr
                result = i+1
        return result",O(n)
"import os
from io import BytesIO, IOBase
import sys

def main():
    n=int(input())
    a=[]
    for i in range(n):
        x,y=map(int,input().split())
        a.append((x,0))
        a.append((y,1))
    a.sort()
    ans,s=[0]*n,[]
    for x,y in a:
        if y:
            ans[len(s)-1]+=x-s[-1][0]+1-s[-1][1]
            z=s.pop()
            if s!=[]:
                s[-1][1]+=(x-z[0]+1)
        else:
            s.append([x,0])
    print(*ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(nlogn)
"import sys
import math
import collections
import bisect
import string
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    s1=list(get_string())
    s2=list(get_string())
    count=0
    ans=[]
    lower=string.ascii_lowercase
    np=0
    for i in lower:
        if s1.count(i)!=s2.count(i):
            np+=1
            break
    if np>0:
        print(-1)
        continue
    pos=dict()
    for i in range(n):
        if s1[i] in pos:
            pos[s1[i]].append(i)
        else:
            pos[s1[i]]=[i]
    for i in range(n):
        if s1[i]==s2[i]:
            continue
        else:
            row=pos[s2[i]]
            no=0
            for j in range(len(row)):
                if row[j]>i:
                    no=row[j]
                    break
            for j in range(no,i,-1):
                ans.append(j)
            s1.pop(no)
            s1.insert(i,s2[i])

            pos = dict()
            for j in range(n):
                if s1[j] in pos:
                    pos[s1[j]].append(j)
                else:
                    pos[s1[j]] = [j]
    print(len(ans))
    print(*ans)",O(n ^ 2)
"n=int(input())
l=list(map(int,input().split()))
l.sort()
vis=[0]*n
ans=0
for i in range(n):
    if(vis[i]==0):
        ans+=1
        x=l[i]
        for j in range(n):
            if l[j]%x==0:
                vis[j]=1
print(ans)",O(n ^ 2)
"def valid(k, mid):
    return (2*k - mid - 1) * mid // 2 + 1

def binary_search(n, k):
    l, r = 0, k-1
    while (l <= r):
        mid = l+r >> 1
        if (valid(k, mid) < n):
            l = mid+1
        else:
            r = mid-1
    return r+1

def main():
    n, k = map(int, input().split())
    res = binary_search(n, k)
    print(-1 if res == k else res)

main()
",O(logn)
"n = int(input())

r = []
for _ in range(n):
    a,b,c,d = map(int,input().split())
    r.append(sum([a,b,c,d]))

thomas = r[0]
print(sorted(r, reverse=True).index(thomas)+1)
",O(n)
"from math import *
from cmath import *
from itertools import *
from decimal import *
from fractions import *
from sys import *
from types import CodeType, new_class

k, n, s, p = map(int, input().split())
print((k*(n//s + (n%s != 0))) // p + ((k*(n//s + (n%s != 0))) % p != 0))",O(1)
"import sys
readline = sys.stdin.readline

def gcd(a, b):
    while b:
        a, b = b, a%b
    return a

def prsh(N):
    prime = [2]
    for L in range(3,N):
        for p in prime:
            if not L % p:
                break
            if p > L**(1/2):
                prime.append(L)
                break
    return prime
limit = 59
prime = prsh(limit+1)
C = set([tuple()])
Cp = []
for i in range(2, limit+1):
    if i >= 30 and i in prime:
        Cp.append(i)
        continue
    for k in C.copy():
        if all(gcd(ki, i) == 1 for ki in k):
            kn = tuple(list(k) + [i])
            C.add(kn)

INF = 10**9+7

N = int(readline())
A = list(map(int, readline().split()))
Ao = A[:]
A.sort()
ans = INF
Ans = None
for ci in C:
    tc = [1]*(N-len(ci)) + list(ci) + Cp
    for j in range(8):
        res = 0
        for a, t in zip(A, tc[j:]):
            res += abs(a-t)
        if ans > res:
            ans = res
            Ans = tc[j:j+N]
buc = [[] for _ in range(limit+1)]
for a, an in zip(A, Ans):
    buc[a].append(an)
AA = []
for ao in Ao:
    AA.append(buc[ao].pop())

print(*AA)",np
"def main():
    def update(l, r, i, res):
        j = 0
        while j < i:
            if res[j] is None:
                r[j] -= 1
                if r[j] < 0:
                    return False
            j += 1
        j += 1
        while j < n:
            if res[j] is None:
                l[j] -= 1
                if l[j] < 0:
                    return False
            j += 1
        return True

    ilist = {1}
    n = int(input())
    res = [None] * n
    cur = n
    l = [int(x) for x in input().split()]
    r = [int(x) for x in input().split()]

    while ilist and (sum(l) != 0 or sum(r) != 0):
        ilist = set()
        for i in range(n):
            if l[i] == r[i] == 0 and res[i] is None:
                res[i] = cur
                ilist.add(i)
        for i in ilist:
            check = update(l, r, i, res)
            if not check:
                return False
        cur -= 1
    if not ilist:
        return False
    for i in range(n):
        if res[i] is None:
            res[i] = cur
    return res

if __name__ == '__main__':
    res = main()
    if not res:
        print('NO')
    else:
        print('YES')
        for x in res:
            print(x, end=' ')",O(n ^ 2)
"from sys import stdin

add = lambda a, b: (a + b) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, i * 2 + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])

print(sum(mem[-1][k]) % mod)
",np
"from math import *
a,v=list(map(int,input().split()))
l,d,w=list(map(int,input().split()))
if v>w:
    s1=w**2/2/a
    if d<=s1:
        s=min(v**2/2/a,l)
        t=sqrt(2*s/a)+(l-s)/v
    else:
        t=sqrt(2*s1/a)
        s2=min((d-s1)/2,(v**2-w**2)/(2*a))
        if s2==(d-s1)/2:
            t+=2*(sqrt(2*(s1+s2)/a)-sqrt(2*s1/a))
        else:
            t+=2*(v-w)/a+(d-s1-2*s2)/v
        s3=min((v**2-w**2)/2/a,l-d)
        t+=sqrt(2*(s3+s1)/a)-sqrt(2*s1/a)+(l-d-s3)/v
else:
    s=min(v**2/2/a,l)
    t=sqrt(2*s/a)+(l-s)/v
print(t)",O(1)
"n, v = map(int, input().strip().split())
answer = 0
n -= 1
if n <= v:
    print(n)
else:
    answer =v

    for i in range(1,n-v + 1):

        answer += (i + 1)
    print(answer)",O(n)
"class ArrayReader(object):
   def compareSub(self, l, r, x, y):
       pass

   def length(self):
       pass

class Solution(object):
    def getIndex(self, reader):
        left, right = 0, reader.length()-1
        while left < right:
            mid = left + (right-left)//2
            if reader.compareSub(left, mid, mid if (right-left+1)%2 else mid+1, right) >= 0:
                right = mid
            else:
                left = mid+1
        return left",O(logn)
"class Solution(object):
    def beautifulIndices(self, s, a, b, k):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    yield i-j
                    j = prefix[j]

        result = []
        if not (len(a) <= len(s) and len(b) <= len(s)):
            return result
        lookup = list(KMP(s, b))
        j = 0
        for i in KMP(s, a):
            while j < len(lookup) and lookup[j] < i-k:
                j += 1
            if j < len(lookup) and lookup[j] <= i+k:
                result.append(i)
        return result",O(n)
"class Solution(object):
    def stoneGame(self, piles):
        if len(piles) % 2 == 0 or len(piles) == 1:
            return True

        dp = [0] * len(piles)
        for i in reversed(range(len(piles))):
            dp[i] = piles[i]
            for j in range(i+1, len(piles)):
                dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])
        return dp[-1] >= 0",O(n ^ 2)
"n, m = map(int, input().split())
A = list(map(int, input().split()))
L = [0]*n
for i in range(m):
    L[A[i]-1] += 1
print(min(L))",O(n ^ 2)
"class Solution(object):
    def makeArrayPositive(self, nums):
        MAX_VAL = 10**18
        result = 0
        prev1 = nums[0]+nums[1]
        prev2 = nums[0]
        max_prev3 = 0
        for i in range(2, len(nums)):
            prefix = prev1+nums[i]
            if prefix-max_prev3 <= 0:
                prefix = prev1+MAX_VAL
                result += 1
            max_prev3 = max(max_prev3, prev2)
            prev1, prev2 = prefix, prev1
        return result",O(n)
"
import collections


class Solution(object):
    def fourSumCount(self, A, B, C, D):
        A_B_sum = collections.Counter(a+b for a in A for b in B)
        return sum(A_B_sum[-c-d] for c in C for d in D)

",O(n ^ 2)
"n = int(input())

b = [int(_) for _ in input().split()]

e = [[-1] * (n+1) for _ in range(2024)]

d = [[] for _ in range(n)]

for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])",O(n ^ 3)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

n = INT()
arr = LIST()

i = 0
p = []
while 2**i <= 10**18:
    p.append(2**i)
    i = i+1

d = {}
s1= set()
for i in arr:
    s1.add(i)
    if i not in d :
        d[i] = 1
    else:
        d[i]+=1

s2 = set()
for i in s1 :
    flag = False
    for j in p :
        x = j - i
        k = -1
        try:
            k = d[x]
        except :
            k = -1
        if k != -1:
            if x == i and d[i] == 1 :
                continue
            else:
                flag = True
                break
    if flag == False:
        s2.add(i)

res = 0
for i in s2 :
    res+=d[i]
print(res)
",O(nlogn)
"a = input()
b = input()
la = [int(x) for x in a]
res = []
la.sort()
la = la[::-1]
lb = [int(x) for x in b]
cnt = [0] * 20

def check():
    tres = 0
    for x in range(len(res)):
        tres *= 10
        tres += int(res[x])
    return tres <= int(b)
if len(a) < len(b):
    for i in range(len(la)):
        print(la[i], end = '')
    print()
else:
    for i in range(len(la)):
        cnt[la[i]] += 1
    flag = 0
    for i in range(len(lb)):
        if flag == 0 and cnt[lb[i]]:
            res.append(lb[i])
            cnt[lb[i]] -= 1
        else:
            flag = i - 1
            for j in range(lb[i] - 1, -1, -1):
                if cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
                    break
            for j in range(9, -1, -1):
                while cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
            break
    while not check():
        temp = []
        cnt = [0] * 20
        for x in range(flag):
            temp.append(res[x])
            cnt[res[x]] -= 1
        for i in la:
            cnt[i] += 1

        res = temp

        for v in range(lb[flag] - 1, -1, -1):
            if cnt[v]:
                res.append(v)
                cnt[v] -= 1
                break
        for v in range(9, -1, -1):
            while cnt[v]:
                res.append(v)
                cnt[v] -= 1

        flag -= 1
    for i in range(len(res)):
        print(res[i], end = '')
    print()
",O(n ^ 3)
"n = int(input())
x,y = map(int,input().split())
num = x - 1 + y - 1
num2 = n - x + n - y
ans = num <= num2
if ans:
    print(""White"")
else:
    print(""Black"")
",O(1)
"import itertools



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def leafSimilar(self, root1, root2):
        def dfs(node):
            if not node:
                return
            if not node.left and not node.right:
                yield node.val
            for i in dfs(node.left):
                yield i
            for i in dfs(node.right):
                yield i
        return all(a == b for a, b in
                   itertools.zip_longest(dfs(root1), dfs(root2)))",O(n)
"class Solution(object):
    def findRelativeRanks(self, nums):
        sorted_nums = sorted(nums)[::-1]
        ranks = [""Gold Medal"", ""Silver Medal"", ""Bronze Medal""] + list(map(str, list(range(4, len(nums) + 1))))
        return list(map(dict(list(zip(sorted_nums, ranks))).get, nums))",O(nlogn)
"import collections
import itertools



class Solution(object):
    def maxJumps(self, arr, d):
        def dp(arr, d, i, left, right, lookup):
            if lookup[i]:
                return lookup[i]
            lookup[i] = 1
            for j in itertools.chain(left[i], right[i]):
                lookup[i] = max(lookup[i], dp(arr, d, j, left, right, lookup)+1)
            return lookup[i]

        left, decreasing_dq = [[] for _ in range(len(arr))], collections.deque()
        for i in range(len(arr)):
            if decreasing_dq and i - decreasing_dq[0] == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
                if left[i] and arr[left[i][-1]] != arr[decreasing_dq[-1]]:
                    left[i] = []
                left[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)
        right, decreasing_dq = [[] for _ in range(len(arr))], collections.deque()
        for i in reversed(range(len(arr))):
            if decreasing_dq and decreasing_dq[0] - i == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
                if right[i] and arr[right[i][-1]] != arr[decreasing_dq[-1]]:
                    right[i] = []
                right[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)

        lookup = [0]*len(arr)
        return max(map(lambda x: dp(arr, d, x, left, right, lookup), range(len(arr))))",O(n)
"class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):
        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
            if visited in lookup:
                return lookup[visited]

            mask = 1
            for i in range(maxChoosableInteger):
                if visited & mask == 0:
                    if i + 1 >= desiredTotal or \
                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):
                        lookup[visited] = True
                        return True
                mask <<= 1
            lookup[visited] = False
            return False

        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
            return False

        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})",O(n!)
"a = list(map(int,input().split()))
b = list(map(int,input().split()))
c = list(map(int,input().split()))
a,b,c= sorted([a,b,c])

path = []
for i in range(min(a[1],b[1],c[1]) , max(a[1],b[1],c[1]) + 1):
    path.append((b[0],i))
for i in range(a[0],b[0]+1):
    path.append((i,a[1]))
for i in range(b[0],c[0]+1):
    path.append((i,c[1]))

print(len(set(path)))
for i in set(path):
    print(*i)
",O(1)
"import os,sys
from io import BytesIO,IOBase
from array import array

def main():
    n,M = map(int,input().split())
    comb = [[0]*(n+1) for _ in range(n+1)]
    comb[0][0] = 1
    for i in range(1,n+1):
        for j in range(i+1):
            comb[i][j] = (comb[i-1][j]+comb[i-1][j-1])%M

    dp = [array('i',[0]*(n+1)) for _ in range(n+1)]

    for i in range(1,n+1):
        dp[i][0] = pow(2,i-1,M)
    for j in range(1,n+1):
        for i in range(3,n+1):
            for x in range(1,i-1):
                dp[i][j] = (dp[i][j]+dp[i-1-x][j-1]*dp[x][0]*comb[i-j][x])%M
    su = 0
    for i in range(n+1):
        su = (su+dp[n][i])%M
    print(su)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(n ^ 3)
"k = int(input().split()[1])
l = sorted(map(int, input().split()))

res = set()
for i in l:
    if i % k != 0 or i / k not in res:
        res.add(i)

print(len(res))
",O(nlogn)
"class Solution(object):
    def isValidSerialization(self, preorder):
        def split_iter(s, tok):
            start = 0
            for i in range(len(s)):
                if s[i] == tok:
                    yield s[start:i]
                    start = i + 1
            yield s[start:]

        if not preorder:
            return False

        depth, cnt = 0, preorder.count(',') + 1
        for tok in split_iter(preorder, ','):
            cnt -= 1
            if tok == 
                depth -= 1
                if depth < 0:
                    break
            else:
                depth += 1
        return cnt == 0 and depth < 0",O(n)
"n=int(input())
a=list(map(int,input().split()))
if sum(a[i]==i+1 for i in range(n))>=n//1000:print(""Petr"")
else:print(""Um_nik"")
",O(nlogn)
"n=int(input())
l=list(map(int,input().split()))
m=l[:]
m.sort()
f=1
c=0
for i in range(n):
    if(l[i]!=m[i]):
        c+=1
    if(c>2):
        f=0
        break
if(f==0):
    print(""NO"")
else:
    print(""YES"")
",O(nlogn)
"
class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children


class Solution(object):
    def levelOrder(self, root):
        if not root:
            return []
        result, q = [], [root]
        while q:
            result.append([node.val for node in q])
            q = [child for node in q for child in node.children if child]
        return result

",O(n)
"class Solution:
    def countSubstrings(self, s: str) -> int:
        res = 0

        for i in range(len(s)):
            for j in range(i, len(s)):
                l, r = i, j
                while l < r and s[l] == s[r]:
                    l += 1
                    r -= 1
                res += (l >= r)

        return res
",O(n ^ 3)
"class Solution(object):
    def elementInNums(self, nums, queries):
        result = []
        for t, i in queries:
            t %= 2*len(nums)
            if t+i < len(nums):
                result.append(nums[t+i])
            elif i < t-len(nums):
                result.append(nums[i])
            else:
                result.append(-1)
        return result",O(n)
"q = int(input())
otvet = []
for i in range(q):
    g = input().split()
    n = int(g[0])
    m = int(g[1])
    k = int(g[2])
    if n < 0:
        n = -n
    if m < 0:
        m = -m
    if m > k or n > k:
        otvet.append(-1)
    elif m % 2 == k % 2 and n % 2 == k % 2:
        otvet.append(k)
    elif m % 2 == k % 2 or n % 2 == k % 2:
        otvet.append(k - 1)
    else:
        otvet.append(k - 2)
for i in otvet:
    print(i)
",O(1)
"lis = list(map(int,input().split()))
if lis[2] <= lis[0] and lis[2] <= lis[1]:
	if ((lis[0]+lis[1]) - lis[2]) < lis[3]:
		print(lis[3] - ((lis[0]+lis[1]) - lis[2]))
	elif sum(lis) == 0:
		print(-1)
	elif lis[0] == 0 and lis[1] == 0 and lis[2] == 0 :
		print(lis[3])
	else:
		print(-1)
else:
	print(-1)
",O(1)
"def ints():
 return map(int,input().split())
n,m=ints()
c=ints()
aa=[0]*(n+1)
for cc in c:
 aa[cc]+=1
print(min(aa[1:]))
",O(n ^ 2)
"x=int(input())
s=input()

def substring(x,s):
    count=0
    ans=0

    for i in range(x):
        if s[i]==""x"":
            count+=1
        else:
            if count>=3:
                ans+=count-2
            count=0
    if count>=3:
        ans+=count-2

    return ans
print(substring(x,s))",O(n)
"def read(type = 1):
    if type:
        file = open(""input.dat"", ""r"")
        n = int(file.readline())
        a = list(map(int, file.readline().split()))
        b = file.readline()
        file.close()
    else:
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        b = input().strip()
    return n, a, b

def solve():
    sol = 0
    e = 0
    big = 0
    g = 0
    for i in range(n):
        if b[i] == ""W"":
            big = 1
            sol += 3 * a[i]
            e += a[i]
        if b[i] == ""G"":
            sol += 5 * a[i]
            e += a[i]
            g += 2*a[i]
        if b[i] == ""L"":
            sol += a[i]
            e -= a[i]
            if e < 0:
                if big:
                    sol -= 3 * e
                else:
                    sol -= 5 * e
                e = 0
        g = min(g, e)
    if e:
        sol -= 2*g
        sol -= (e-g)
    return int(sol)

n, a, b = read(0)
sol = solve()
print(sol)",O(n)
"class Solution3(object):
    def longestPath(self, parent, s):
        def dfs(s, adj, u, result):
            top2 = [0]*2
            for v in adj[u]:
                l = dfs(s, adj, v, result)
                if s[v] == s[u]:
                    continue
                if l > top2[0]:
                    top2[0], top2[1] = l, top2[0]
                elif l > top2[1]:
                    top2[1] = l
            result[0] = max(result[0], top2[0]+top2[1]+1)
            return top2[0]+1
    
        
        adj = [[] for _ in range(len(s))]
        for i in range(1, len(parent)):
            adj[parent[i]].append(i)
        result = [0]
        dfs(s, adj, 0, result)
        return result[0]",O(n)
"import sys
input = sys.stdin.readline

n = int(input())
mod = pow(10, 9) + 7
a = list(map(int, input().split()))
l = 100000
cnt = [0] * (l + 1)
for i in a:
    cnt[i] += 1
pow2 = [1]
for _ in range(l):
    pow2.append(2 * pow2[-1] % mod)
ans = pow2[n] - 1
x = [-1] * (l + 1)
for i in range(2, l + 1):
    c = cnt[i]
    xi = x[i]
    for j in range(2 * i, l + 1, i):
        c += cnt[j]
        x[j] -= xi
    ans += xi * (pow2[c] - 1) % mod
    ans %= mod
print(ans)",np
"class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        def dfs(i, flag):
            if i == len(nums):
                return 0 if flag else -1e6
            if flag:
                return max(0, nums[i] + dfs(i + 1, True))
            return max(dfs(i + 1, False), nums[i] + dfs(i + 1, True))
        return dfs(0, False)
",O(2 ^ n)
"from math import factorial
s1=input()
s2=input()
n=0
x1=0
for i in range(len(s1)):
    if s1[i]=='+':
        x1+=1
    else:
        x1-=1
x2=0
for i in range(len(s2)):
    if s2[i]=='+':
        x2+=1
    elif s2[i]=='?':
        n+=1
    else:
        x2-=1
x=abs(x1-x2)
if x>n:
    print(0)
elif x==n:
    print(1/2**n)
else:
    if (n-x)%2==1:
        print(0)
    else:
        print((factorial(n)//(factorial((n-x)//2)*factorial(n-(n-x)//2)))/2**n)",np
"class Solution3(object):
    def maxOutput(self, n, edges, price):
        def iter_dfs():
            dp = [0]*n 
            stk = [(1, 0, -1)]
            while stk:
                step, u, p = stk.pop()
                if step == 1:
                    stk.append((2, u, p))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, v, u))
                elif step == 2:
                    dp[u] = price[u]
                    for v in adj[u]:
                        if v == p:
                            continue
                        dp[u] = max(dp[u], dp[v]+price[u])
            return dp
        
        def iter_dfs2():
            result = 0
            stk = [(0, -1, 0)]
            while stk:
                u, p, curr = stk.pop()
                result = max(result, curr, dp[u]-price[u])
                top2 = [[curr, p], [0, -1]]
                for v in adj[u]:
                    if v == p:
                        continue
                    curr = [dp[v], v]
                    for i in range(len(top2)):
                        if curr > top2[i]:
                            top2[i], curr = curr, top2[i]
                for v in adj[u]:
                    if v == p:
                        continue
                    stk.append((v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u]))
            return result
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = iter_dfs()
        return iter_dfs2()",O(n)
"class Solution2(object):
    def countQuadruplets(self, nums):
        right = [[0]*(len(nums)+1) for _ in range(len(nums))]
        for j in range(len(nums)):
            for i in reversed(range(j+1, len(nums))):
                right[j][i] = right[j][i+1] + int(nums[i] > nums[j])
        result = 0
        for k in range(len(nums)):
            left = 0
            for j in range(k):
                if nums[k] < nums[j]:
                    result += left*right[j][k+1]
                left += int(nums[k] > nums[j])
        return result",O(n ^ 2)
"class Solution(object):
    def minLength(self, s):
        stk = []
        for c in s:
            if stk and ((stk[-1] == 'A' and c == 'B') or (stk[-1] == 'C' and c == 'D')):
                stk.pop()
                continue
            stk.append(c)
        return len(stk)",O(n)
"class Solution2(object):
    def deleteTreeNodes(self, nodes, parent, value):
        result = [1]*nodes
        for i in reversed(range(1, nodes)):
            value[parent[i]] += value[i]
            result[parent[i]] += result[i] if value[i] else 0
        return result[0]",O(n)
"import os,sys
from io import BytesIO,IOBase
from collections import Counter

def main():
    n,k = map(int,input().split())
    a = input().split()
    a1 = list(map(int,a))
    dct = [Counter() for _ in range(11)]
    for i in range(n):
        dct[len(a[i])][a1[i]%k] += 1
    ans = 0
    for i in range(n):
        x = a1[i]
        for j in range(1,11):
            x = (x*10)%k
            if x:
                ans += dct[j][k-x]
            else:
                ans += dct[j][0]
        if not (a1[i]*(pow(10,len(a[i]),k)+1))%k:
            ans -= 1
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(nlogn)
"class Solution(object):
    def sumOfBeauties(self, nums):
        right = [nums[-1]]*len(nums)
        for i in reversed(range(2, len(nums)-1)):
            right[i] = min(right[i+1], nums[i])
        result, left = 0, nums[0]
        for i in range(1, len(nums)-1):
            if left < nums[i] < right[i+1]:
                result += 2
            elif nums[i-1] < nums[i] < nums[i+1]:
                result += 1
            left = max(left, nums[i])
        return result",O(n)
"class Solution(object):
    def numPermsDISequence(self, S):
        dp = [1]*(len(S)+1)
        for c in S:
            if c == ""I"":
                dp = dp[:-1]
                for i in range(1, len(dp)):
                    dp[i] += dp[i-1]
            else:
                dp = dp[1:]
                for i in reversed(range(len(dp)-1)):
                    dp[i] += dp[i+1]
        return dp[0] % (10**9+7)",O(n ^ 2)
"print(""? 0 0"", flush=True)
res = input()
i = 1
a = 0
b = 0
for i in range(29,-1,-1):
	print(""?"",(a^(1<<i)), b, flush=True)
	res1 = input()
	print(""?"",a, (b^(1<<i)), flush=True)
	res2 = input()
	if res1 == res2:
		if res == '1':
			a ^= (1<<i)
		else:
			b ^= (1<<i)
		res = res1
	elif res1 == '-1':
		a ^= (1<<i)
		b ^= (1<<i)
print(""!"", a, b, flush=True)",O(1)
"from sys import stdin, stdout

N = 55

f = [0]
for i in range(1, N):
    f.append(f[-1]*4 + 1)
    if f[-1] > 1e18:
        break

t = int(stdin.readline().strip().split()[0])

for ca in range(0, t):
    n, m = [int(x) for x in stdin.readline().strip().split()]
    if n > 31:
        stdout.write(""YES {}\n"".format(n-1))
    else:

        start = 0
        found = False
        res = -1
        for i in range(1, n+1):
            start += 2**i -1
            end = start
            for k in range(1, i+1):
                end += f[n-k] * (2**(k+1) - 3)
            if m >= start and m <= end:
                found = True
                res = i
                break
        if found:
            stdout.write(""YES {}\n"".format(n-res))
        else:
            stdout.write(""NO\n"")
",O(logn)
"class Window(object):
    def __init__(self):
        self.__count = collections.defaultdict(int)

    def add(self, x):
        self.__count[x] += 1

    def remove(self, x):
        self.__count[x] -= 1
        if self.__count[x] == 0:
            self.__count.pop(x)
            
    def size(self):
        return len(self.__count)


class Solution2(object):
    def subarraysWithKDistinct(self, A, K):
        window1, window2 = Window(), Window()
        result, left1, left2 = 0, 0, 0
        for i in A:
            window1.add(i)
            while window1.size() > K:
                window1.remove(A[left1])
                left1 += 1
            window2.add(i)
            while window2.size() >= K:
                window2.remove(A[left2])
                left2 += 1
            result += left2-left1
        return result",O(n)
"class Solution4(object):
    def maxIncreasingGroups(self, usageLimits):
        def check(l):
            return all((i+1)*i//2 <= prefix[len(usageLimits)-(l-i)] for i in range(1, l+1))

        usageLimits.sort()
        prefix = [0]*(len(usageLimits)+1)
        for i in range(len(usageLimits)):
            prefix[i+1] = prefix[i]+usageLimits[i]
        left, right = 1, len(usageLimits)
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"import sys
n,a,b = list(map(int, input().split()))

if a>1 and b>1:
	print('NO')
	sys.exit(0)

if n==3 and a==1 and b==1:
	print('NO')
	sys.exit(0)

if n==2 and a==1 and b==1:
	print('NO')
	sys.exit(0)

t = [[0 for i in range(n)] for j in range(n)]

comp = max(a,b)

for i in range(comp-1, n-1):
	t[i][i+1] = 1
	t[i+1][i] = 1

if b>1:
	for i in range(n):
		for j in range(n):
			if i!=j:
				t[i][j] = 1-t[i][j]
print('YES')
for i in range(n):
	print("""".join(map(str, t[i])))
",O(n ^ 2)
"n = int(input())
if n==0:
    print(0)
elif n%2==1:
    print((n+1)//2)
else:
    print(n+1)",O(1)
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:

        def dfs(i, j):
            if i == len(nums):
                return 0

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            return LIS

        return dfs(0, -1)
",O(2 ^ n)
"from math import gcd
n, x, y = map(int, input().split())

def solve(n, x, y):
    g = gcd(x, y)
    if gcd(x, y) != 1:
        return solve(n // g + 1, x // g, y // g) * (n % g) + solve(n // g, x // g, y // g) * (g - n % g)
    ans = 0
    for s in [0, 1]:
        dp = [-n, -n]
        dp[s] = 0
        for i in range(x + y):
            dp = [max(dp[0], dp[1]), dp[0] + (n // (x + y)) + (i * x % (x + y) < n % (x + y))]
        ans = max(ans, dp[s])
    return ans

print(solve(n, x, y))",np
"ii=lambda:int(input())
kk=lambda:map(int, input().split())
ll=lambda:list(kk())

from math import log
l,r=kk()
i=msb = int(max(log(l,2),log(r,2)))
while ((2**i)&l) == ((2**i)&r):
	i-=1
	if i == -1:
		break
i+=1
print(2**i-1)",O(logn)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"for _ in range(int(input())):
    n,m=map(int,input().split())

    a=[[int(x) for x in input().split()] for j in range(n)]

    x=[[a[i][j] for i in range(n)] for j  in range(m)]
    x.sort(key=lambda xx:-max(xx))
    dp=[[0 for i in range(1<<n)] for j in range(m+1)]
    an=0

    for i in range(m):
        for prev in range(1<<n):
            for pres in range(1<<n):

                for j in range(n):

                    ma=0
                    if prev^pres!=prev+pres:
                        continue
                    for st in range(n):

                        if pres&(1<<st):
                            ma+=x[i][(st+j)%n]

                    dp[i+1][pres^prev]=max(dp[i+1][pres^prev],dp[i][prev]+ma)

    print(dp[m][(1<<n)-1])",np
"import sys
input = sys.stdin.readline

r, g, b, = [int(_) for _ in input().split()]
R = [int(_) for _ in input().split()]
G = [int(_) for _ in input().split()]
B = [int(_) for _ in input().split()]
R = sorted(R, reverse=True)
G = sorted(G, reverse=True)
B = sorted(B, reverse=True)

dp = []
for i in range(r+1):
    sdp = [[0]*(b+1) for _ in range(g+1)]
    dp.append(sdp)

answer = 0
for nb_taken in range(r+g+b):
    if nb_taken % 2:
        continue

    for i in range(nb_taken+1):
        if i > r:
            break
        for j in range(nb_taken-i-b, nb_taken-i+1):
            if j > g:
                break
            k = nb_taken-i-j
            if k > b:
                continue
            if i+j < k or i+k < j or j+k < i:
                continue

            if i < r and j < g:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + R[i]*G[j])

                answer = max(answer, dp[i+1][j+1][k])
            if i < r and k < b:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + R[i]*B[k])

                answer = max(answer, dp[i+1][j][k+1])
            if j < g and k < b:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + G[j]*B[k])

                answer = max(answer, dp[i][j+1][k+1])

print(answer)
",O(n ^ 3)
"class Solution:
    def findMin(self, nums: List[int]) -> int:
        return min(nums)
",O(n)
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

a = {0:0}

for i in range(n):
    b = a.copy()
    for p in a.items():
        d = gcd(p[0], l[i])
        cost = p[1] + c[i]
        if d not in b: b[d] = cost
        elif b[d] > cost: b[d] = cost
    a = b

if 1 not in a: a[1] = -1
print(a[1])
",np
"n = int(input())
a = list(map(int,input().split()))
mod = 10**9+7
b = [0 for i in range(1<<20)]
for i in range(n):
  b[a[i]] += 1
for i in range(20):
  for j in range(1<<20):
    if j&1<<i == 0:
      b[j] += b[j|1<<i]
ans = 0
for i in range(1<<20):
  cnt = str(bin(i)).count(""1"")
  if cnt%2 == 0:
    ans += pow(2,b[i],mod)-1
  else:
    ans -= pow(2,b[i],mod)-1
  ans %= mod
print(ans)",np
"x = int(input())
print(0,0,x)",O(1)
"xs = [int(x) for x in input().split()]

res = 0
for i in range(14):
    newxs = xs[:]
    newxs[i] = 0
    for j in range(14):
        newxs[j] += xs[i] // 14

    for j in range(xs[i] % 14):
        newxs[(i + 1 + j) % 14] += 1

    res = max(res, sum(val for val in newxs if val % 2 == 0))

print(res)
",O(1)
"class Solution2(object):
    def findWords(self, words):
        keyboard_rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']
        single_row_words = []
        for word in words:
            for row in keyboard_rows:
                if all(letter in row for letter in word.lower()):
                    single_row_words.append(word)
        return single_row_words",O(n)
"class Solution:
    def countBits(self, n: int) -> List[int]:
        return [bin(i).count('1') for i in range(n + 1)]
",O(n)
"import sys, heapq

n, x = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
res = dict().fromkeys(set(arr), 0)
for i in arr:
    res[i] += 1
can = False
for i in res:
    if res[i] >= 2:
        can = True
        break
if can:
    print(0)
else:
    res = dict().fromkeys([i for i in range(max(arr) + 1)])
    for i in res:
        res[i] = []
    for i in range(n):
        temp = set()
        now = arr[i]
        cnt = 0
        while True:
            added = False
            before = len(temp)
            temp.add(now)
            after = len(temp)
            if before == after:
                break
            heapq.heappush(res[now], cnt)
            now = now & x
            cnt += 1
    ans = 9876543210
    for i in res:
        if len(res[i]) >= 2:
            ans = min(ans, heapq.heappop(res[i]) + heapq.heappop(res[i]))
    print(ans if ans != 9876543210 else -1)",O(n)
"n, m = map(int, input().split())
x1 = -1
x2 = -1
y1 = -1
y2 = -1
for i in range(n):
    s = input()
    for j in range(m):
        if s[j] == 'B':
            if x1 == -1:
                x1 = j + 1
            x2 = max(x2, j + 1)
            if y1 == -1:
                y1 = i + 1
            y2 = i + 1
print((y1 + y2) // 2, (x1 + x2) // 2)",O(n ^ 2)
"n, d, k = map(int, input().split())
num = d+2

def solve():
  global num
  if n == 1: return 'NO'
  if n == 2:
    if d != 1:
      return 'NO'
    else:
      return ""YES\n1 2""
  if k < 2: return 'NO'
  if d > n-1: return 'NO'

  depth = [min(i, d-i) for i in range(d+1)]
  ans = [(i+1, i+2) for i in range(d)]

  def dfs(v, depth):
    global num
    if depth == 0: return
    for i in range(k-1):
      if len(ans) == n-1: return
      v2 = num
      num += 1
      ans.append((v, v2))
      dfs(v2, depth-1)

  for v in range(d+1):
    if depth[v] == 0: continue
    for i in range(k-2):
      if len(ans) == n-1: break
      v2 = num
      num += 1
      ans.append((v+1, v2))
      if depth[v] > 1: dfs(v2, depth[v]-1)

  if len(ans) < n-1: return ""NO""
  return ""YES\n%s""%""\n"".join([""%d %d""%i for i in ans])

print(solve())",O(n ^ 2)
"import collections


class Solution(object):

    def __init__(self):
        self.__left, self.__right = collections.deque(), collections.deque()   

    def pushFront(self, val):
        self.__left.appendleft(val)
        self.__balance()        

    def pushMiddle(self, val):
        if len(self.__left) > len(self.__right):
            self.__right.appendleft(self.__left.pop())
        self.__left.append(val)

    def pushBack(self, val):
        self.__right.append(val)
        self.__balance()

    def popFront(self):
        val = (self.__left or collections.deque([-1])).popleft()
        self.__balance()
        return val

    def popMiddle(self):
        val = (self.__left or [-1]).pop()
        self.__balance()
        return val

    def popBack(self):
        val = (self.__right or self.__left or [-1]).pop()
        self.__balance()
        return val

    def __balance(self):
        if len(self.__left) > len(self.__right)+1:
            self.__right.appendleft(self.__left.pop())
        elif len(self.__left) < len(self.__right):
            self.__left.append(self.__right.popleft())",O(1)
"class Solution(object):
    def alternatingSubarray(self, nums):
        result = l = -1
        for i in range(len(nums)-1):
            if l != -1 and nums[i-1] == nums[i+1]:
                l += 1
            else:
                l = 2 if nums[i+1]-nums[i] == 1 else -1
            result = max(result, l)
        return result",O(n)
"import itertools



class Solution2(object):
    def minCost(self, nums, cost):
        def f(x):
            return sum(abs(y-x)*c for y, c in zip(nums, cost))
    
        def check(x):
            return x+1 == len(idxs) or f(nums[idxs[x]]) < f(nums[idxs[x+1]])

        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        left, right = 0, len(idxs)-1
        while left <= right:
            mid = left+(right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return f(nums[idxs[left]])",O(nlogn)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteMiddle(self, head):
        dummy = ListNode()
        dummy.next = head
        slow = fast = dummy
        while fast.__next__ and fast.next.__next__:
            slow, fast = slow.__next__, fast.next.__next__
        slow.next = slow.next.__next__
        return dummy.__next__",O(n)
"class Solution2(object):
    def getNoZeroIntegers(self, n):
        return next([a, n-a] for a in range(1, n) if '0' not in '{}{}'.format(a, n-a))",O(nlogn)
"a = input()
b = input()
l = a.count(""+"")-a.count(""-"")
k = b.count(""?"")
if k==0:
    if (b.count(""+"")-b.count(""-""))==l:
        print(1)
    else:
        print(0)
else:
    n=2**k
    r=k
    c=[]
    t=0
    while r>=0:
        c.append(r-t)
        t+=1
        r-=1
    import math
    d=[]
    for i in range(k+1):
        d.append((math.factorial(k))//(math.factorial(i)*math.factorial(k-i)))
    f = b.count(""+"")-b.count(""-"")
    if l-f in c:
        print((d[c.index(l-f)])/sum(d))
    else:
        print(0)",np
"class Solution(object):
    def getMinimumDifference(self, root):
        def inorderTraversal(root, prev, result):
            if not root:
                return (result, prev)

            result, prev = inorderTraversal(root.left, prev, result)
            if prev: result = min(result, root.val - prev.val)
            return inorderTraversal(root.right, root, result)

        return inorderTraversal(root, None, float(""inf""))[0]",O(n)
"class Node(object):
    def __init__(self, val=0, left=None, right=None, next=None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next


class Solution(object):
    def connect(self, root):
        head = root
        pre = Node(0)
        cur = pre
        while root:
            while root:
                if root.left:
                    cur.next = root.left
                    cur = cur.__next__
                if root.right:
                    cur.next = root.right
                    cur = cur.__next__
                root = root.__next__
            root, cur = pre.__next__, pre
            cur.next = None
        return head",O(n)
"import sys
I=sys.stdin.readlines()
N,M,K=map(int,I[0].split())
S=[I[i+1][:-1] for i in range(N)]
D=dict()
for i in range(N):
  D[S[i]]=i
T=[I[i+N+1].split() for i in range(M)]
for i in range(M):
  T[i][1]=int(T[i][1])-1
G=[[] for i in range(N)]
C=[0]*N
for i in range(M):
  for j in range(K):
    if S[T[i][1]][j]!='_' and S[T[i][1]][j]!=T[i][0][j]:
      print('NO')
      exit()
  for j in range(1<<K):
    t=''.join(['_' if j&(1<<k) else T[i][0][k] for k in range(K)])
    x=D.get(t,-1)
    if x!=-1 and x!=T[i][1]:
      G[T[i][1]].append(x)
      C[x]+=1
P=[]
Q=[]
F=[1]*N
for i in range(N):
  if C[i]==0 and F[i]:
    Q.append(i)
  while len(Q):
    v=Q.pop()
    F[v]=0
    P.append(v+1)
    for i in range(len(G[v])):
      C[G[v][i]]-=1
      if C[G[v][i]]==0:
        Q.append(G[v][i])
if len(P)==N:
  print('YES')
  print(*P)
else:
  print('NO')
",np
"n , m = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
diff = [0] * n
for i in range(n):
	if a[i] < m:
		diff[i] = -1
	if a[i] > m:
		diff[i] = 1

aim = a.index(m)
left = {}
right = {}
suml = 0
for i in reversed(range(aim + 1)):
	suml += diff[i]
	if not suml in left:
		left[suml] = 0
	left[suml] += 1

sumr = 0
for i in range(aim, n):
	sumr += diff[i]
	if not sumr in right:
		right[sumr] = 0
	right[sumr] += 1

ans = 0
for i in left:
	wk1 = -i
	if wk1 in right:
		ans += left[i] * right[wk1]
	wk1 = 1 - i
	if wk1 in right:
		ans += left[i] * right[wk1]

print(ans)
",O(nlogn)
"import os
import sys
from math import *
from collections import *

from bisect import *
from io import BytesIO, IOBase

def vsInput():
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA = ""abcdefghijklmnopqrstuvwxyz/""
M = 1000000007
EPS = 1e-6

def Ceil(a, b):
    return a // b + int(a % b > 0)

def value():
    return tuple(map(int, input().split()))

def array():
    return [int(i) for i in input().split()]

def Int():
    return int(input())

def Str():
    return input()

def arrayS():
    return [i for i in input().split()]

n = int(input())
s = input()
ans = 0
cnt = 0
for x in s:
    if x == ""x"":
        cnt += 1
        if cnt >= 3:
            ans += 1
    else:
        cnt = 0
print(ans)
",O(n)
"l = list(sorted(list(map(int,input().split()))))
if min(l) == 1 or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==4 and l[2]==4) or(l[0]==2 and l[1] == 2):
    print(""Yes"")
else:
    print(""No"")",O(1)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        def dfs(i):
            if i == len(nums) - 1:
                return True
            end = min(len(nums) - 1, i + nums[i])
            for j in range(i + 1, end + 1):
                if dfs(j):
                    return True
            return False

        return dfs(0)
",O(n!)
"class Solution(object):
    def countArrangement(self, N):
        def countArrangementHelper(n, arr):
            if n <= 0:
                return 1
            count = 0
            for i in range(n):
                if arr[i] % n == 0 or n % arr[i] == 0:
                    arr[i], arr[n-1] = arr[n-1], arr[i]
                    count += countArrangementHelper(n - 1, arr)
                    arr[i], arr[n-1] = arr[n-1], arr[i]
            return count

        return countArrangementHelper(N, list(range(1, N+1)))",O(n!)
"n,k = [int(s) for s in input().split()]
p = [int(s) for s in input().split()]

map = {}
res = []

for pi in p:
    if map.get(pi) is None:
        key = pi
        for j in range(pi, pi-k, -1):
            if j < 0: break
            if map.get(j) is None:
                key = j
            else:
                if map[j] >= pi-k+1: key = map[j]
                break
        for j in range(pi, key-1, -1):
            if map.get(j):
                break
            map[j] = key
    res.append(map[pi])

print(*res, sep="" "")
",O(n ^ 2)
"class Solution(object):
    def maxSizeSlices(self, slices):
        def maxSizeSlicesLinear(slices, start, end):
            dp = [[0]*(len(slices)//3+1) for _ in range(2)]
            for i in range(start, end):
                for j in reversed(range(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1)):
                    dp[i%2][j] = max(dp[(i-1)%2][j], dp[(i-2)%2][j-1] + slices[i])
            return dp[(end-1)%2][len(slices)//3]
        
        return max(maxSizeSlicesLinear(slices, 0, len(slices)-1),
                   maxSizeSlicesLinear(slices, 1, len(slices)))",O(n ^ 2)
"import math
def max_sub(arr,n):
	dp = [0]*n
	dp[0] = arr[0]
	for i in range(1,n):
		dp[i] = max(dp[i-1]+arr[i],arr[i])
	return max(0,max(dp))
n,m,k = map(int,input().split())
arr = list(map(int,input().split()))
q = -math.inf
dp = [0]*(300100)
for i in range(300100):
	dp[i] = [q]*(11)
if (m==1):
	for i in range(n):
		arr[i]= arr[i]-k
	print(max_sub(arr,n))
else:
	for i in range(n):
		dp[i][1] = arr[i]-k
		for j in range(m):
			if (i-1<0 or dp[i-1][j]==q):
				continue
			if ((j+1)%m!=1):
				dp[i][(j+1)%m] = dp[i-1][j]+arr[i]
			else:
				dp[i][(j+1)%m] = max(arr[i]-k,dp[i-1][j]+arr[i]-k)
	ma=0
	for i in range(n):

		for j in range(m):

			ma = max(ma,dp[i][j])

	print(ma)",O(n ^ 2)
"class Solution(object):
    def waysToSplitArray(self, nums):
        total = sum(nums)
        result = curr = 0
        for i in range(len(nums)-1):
            curr += nums[i]
            result += int(curr >= total-curr)
        return result",O(n)
"import sys
input = sys.stdin.readline

n, a, b = [int(i) for i in input().split()]
h = sorted([int(i) for i in input().split()])
Vasya = h[:b]
Petya = h[b:]
print(Petya[0] - Vasya[-1])
",O(nlogn)
"modulo = int(1e9+7)
n = int(input())
arr = [input() for i in range(n)]
dp = [1]
for i in range(n):
    if arr[i] == 'f':
        dp.append(0)
        continue;
    for j in range(1, len(dp)):
        dp[j] = (dp[j] + dp[j-1]) % modulo
print(dp[-1])",O(n ^ 2)
"class Solution2(object):
    dp = {}

    def getKth(self, lo, hi, k):
        def power_value(x):
            y, result = x, 0
            while x > 1 and x not in Solution2.dp:
                result += 1
                if x%2:
                    x = 3*x + 1
                else:
                    x //= 2
            Solution2.dp[y] = result + (Solution2.dp[x] if x > 1 else 0)
            return Solution2.dp[y], y
        
        return sorted(list(range(lo, hi+1)), key=power_value)[k-1]",O(nlogn)
"from math import *
a,r = map(int,input().split())
x = list(map(int,input().split()))
y = [0]*a
for i in range(a):
    h = r
    for j in range(i):
        if abs(x[i]-x[j])<=2*r:
            h = max(h,sqrt((2*r)**2 - (x[i]-x[j])**2)+y[j])
    y[i] = h
    print(h, end = "" "")
",O(n ^ 2)
"import math

n=int(input())

for _ in range(n):
    a,b=map(int,input().split())
    ans=0
    while a>0 and b>0:
        if a>=b:
            ans+=a//b
            a=a%b
        else:
            ans+=b//a
            b=b%a
    print(ans)
",O(1)
"import math

n, m, k = list(map(int, input().split()))
arr = list(map(int, input().split()))

part_sum = [0]
for i in range(n):
	part_sum.append(part_sum[-1] + arr[i])

part_sum_add = [[] for _ in range(m)]
min_in_part_sum_add = [[] for _ in range(m)]
for shift in range(m):
	count_blocks = math.ceil((n - shift) / m + 1)
	for i in range(n + 1):
		cur_part_sum = part_sum[i] + k * (count_blocks - ((i - shift) // m))
		if i == 0 or cur_part_sum < prev_min_in_part_sum_add:
			cur_min_in_part_sum_add = cur_part_sum
		else:
			cur_min_in_part_sum_add = prev_min_in_part_sum_add

		part_sum_add[shift].append(cur_part_sum)
		min_in_part_sum_add[shift].append(cur_min_in_part_sum_add)
		prev_min_in_part_sum_add = cur_min_in_part_sum_add

max_result = 0
for i in range(1, n + 1):
	current_shift = i % m
	current_min = min_in_part_sum_add[current_shift][i]
	current_ans = part_sum_add[current_shift][i] - current_min

	if current_ans > max_result:
		max_result = current_ans

print(max_result)",O(n ^ 2)
"def aburrimin(x, y, n, m, costder, costaba, dp):
    dists = []
    vals = []
    if x != 0:
        dis = costder[y][x-1]
        dists.append(dis)
        vals.append(dis+dp[y][x-1])
    if y != 0:
        dis = costaba[y-1][x]
        dists.append(dis)
        vals.append(dis+dp[y-1][x])
    if y < n-1:
        dis = costaba[y][x]
        dists.append(dis)
        vals.append(dis+dp[y+1][x])
    if x < m-1:
        dis = costder[y][x]
        dists.append(dis)
        vals.append(dis+dp[y][x+1])

    mindis = min(dists)
    return min(mindis+dp[y][x],min(vals))

def solvecaso():
    n,m,k = map(int,input().split())
    costder = [[int(x) for x in input().split()] for _ in range(n)]
    costaba = [[int(x) for x in input().split()] for _ in range(n-1)]
    if k%2:
        for i in range(n):
            for j in range(m):
                print(-1, end=' ')
            print()
        return -1
    k //= 2

    for ren in range(len(costder)):
        for col in range(len(costder[ren])):
            costder[ren][col] *= 2
    for ren in range(len(costaba)):
        for col in range(len(costaba[ren])):
            costaba[ren][col] *= 2

    dp = [[0 for _ in range(m)] for _ in range(n)]
    dptemp = [[0 for _ in range(m)] for _ in range(n)]

    for i in range(k):
        for y in range(n):
            for x in range(m):
                dptemp[y][x] = aburrimin(x, y, n, m, costder, costaba, dp)
        dp, dptemp = dptemp, dp

    for ren in dp:
        for num in ren:
            print(num, end=' ')
        print()

    return 0

if __name__ == ""__main__"":

    solvecaso()
",O(n ^ 3)
"class Solution(object):
    def minimumSwaps(self, nums):
        min_idx = min(range(len(nums)), key=nums.__getitem__)
        max_idx = max(reversed(range(len(nums))), key=nums.__getitem__)
        return ((len(nums)-1)-max_idx)+min_idx-int(max_idx < min_idx)",O(n)
"import sys, math, queue

MOD = 998244353
sys.setrecursionlimit(1000000)

n, m, k = map(int, input().split())
a = list(map(int, input().split()))

dp = [[-10**20 for i in range(m)] for i in range(n)]
dp[0][0] = a[0]-k

for i in range(1, n):
	for j in range(m):
		if j == 0:
			dp[i][j] = max(dp[i-1][m-1]+a[i], a[i])-k
		else:
			dp[i][j] = dp[i-1][j-1]+a[i]

ans = 0
for i in range(n):
	ans = max(ans, max(dp[i]))
print(ans)",O(n ^ 2)
"nums = [0, 1]
dp = [0, 1]
class Solution(object):
    def getMaximumGenerated(self, n):
        if n+1 > len(dp):
            for i in range(len(nums), n+1):
                if i%2 == 0:
                    nums.append(nums[i//2])
                else:
                    nums.append(nums[i//2] + nums[i//2+1])
                dp.append(max(dp[-1], nums[-1]))
        return dp[n]",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    head = None
    def sortedListToBST(self, head):
        current, length = head, 0
        while current is not None:
            current, length = current.__next__, length + 1
        self.head = head
        return self.sortedListToBSTRecu(0, length)

    def sortedListToBSTRecu(self, start, end):
        if start == end:
            return None
        mid = start + (end - start) / 2
        left = self.sortedListToBSTRecu(start, mid)
        current = TreeNode(self.head.val)
        current.left = left
        self.head = self.head.__next__
        current.right = self.sortedListToBSTRecu(mid + 1, end)
        return current",O(n)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def removeStones(self, stones):
        MAX_ROW = 10000
        union_find = UnionFind(2*MAX_ROW)
        for r, c in stones:
            union_find.union_set(r, c+MAX_ROW)
        return len(stones) - len({union_find.find_set(r) for r, _ in stones})",O(n)
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush

from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect, insort
from time import perf_counter
from fractions import Fraction
import copy
from copy import deepcopy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A: print(*ele,end=""\n"")

n=L()[0]
A=L()
A.sort()
if A[-1]==1:
    A[-1]=2
else:
    A[-1]=1
    A.sort()
print(*A)",O(nlogn)
"from math import factorial
s1,s2=input(),input()
a=s1.count('+')-s2.count('+')
b=s1.count('-')-s2.count('-')
if(a<0 or b<0):
    print(0)
    exit(0)
ans=factorial(a+b)/factorial(a)/factorial(b)
ans/=(2**(a+b))
print(""%.10f""%ans)
",np
"for _ in range(int(input())):
    i, j = map(int, input().split())
    i -= 1
    print((j//2 * (j//2 + 1) - i//2 * (i//2 + 1)) -
          (((j - j//2) * (j - j//2)) - ((i - i//2) * (i - i//2))))",O(1)
"class Solution3(object):
    def isDecomposable(self, s):
        found, l = False, 0
        for i, c in enumerate(s):
            if not l or c != s[i-1]:
                if l:
                    return False
                l = 1
                continue
            l += 1
            if l == 2:
                if i == len(s)-1 or s[i] != s[i+1]:
                    if found:
                        return False
                    found, l = True, 0
            elif l == 3:
                 l =  0
        return found",O(n)
"class Solution(object):
    def numberOfSteps (self, num):
        result = 0
        while num:
            result += 2 if num%2 else 1
            num //= 2
        return max(result-1, 0)",O(logn)
"n, m = map(int, input().split(' '))

distances = list(map(int, input().split(' ')))
taxiDriver = list(map(int, input().split(' ')))

people = []
drivers = []
result = [0] * m

for i in range(len(distances)):
  if(taxiDriver[i]):
    drivers.append(distances[i])
  else:
    people.append(distances[i])

j = 0

for person in people:
  if (j + 1) < len(drivers):
    while (j + 1) < len(drivers) and (drivers[j] - person) < (person - drivers[j + 1]) :
      j += 1

    result[j] += 1
  else:
    result[j] += 1

print(' '.join(map(str, result)))
",O(nlogn)
"class Solution3(object):
    def deleteString(self, s):
        MOD, P = 10**9+7, (113, 109)
        def hash(i, j):
            return [(prefix[idx][j+1]-prefix[idx][i]*power[idx][j-i+1])%MOD for idx in range(len(P))]

        if all(x == s[0] for x in s):
            return len(s)

        power = [[1] for _ in range(len(P))]
        prefix = [[0] for _ in range(len(P))]
        for x in s:
            for idx, p in enumerate(P):
                power[idx].append((power[idx][-1]*p)%MOD)
                prefix[idx].append((prefix[idx][-1]*p+(ord(x)-ord('a')))%MOD)
        dp = [1]*len(s) 
        for i in reversed(range(len(s)-1)):
            for j in range(1, (len(s)-i)//2+1):
                if hash(i, i+j-1) == hash(i+j, i+2*j-1):
                    dp[i] = max(dp[i], dp[i+j]+1)
        return dp[0]",O(n ^ 2)
"n, k = map(int, input().split())
l = list(map(int, input().split()))
cost = l[n - 1] - l[0]
if k == 1:
	print(cost)
else:
	diff = [0 for _ in range(n - 1)]
	for i in range(n - 1):
		diff[i] = l[i + 1] - l[i]

	diff = sorted(diff)
	diff.reverse()
	print(cost - sum(diff[:k - 1]))",O(nlogn)
"n=int(input())
ls=list(map(int,input().split()))
ls.sort()
if ls.count(min(ls))==len(ls):
	print('NO')
for i in range(n):
	if ls[i]!=min(ls):
		print(ls[i])
		break
",O(nlogn)
"import itertools
import bisect


class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):
        jobs = sorted(zip(endTime, startTime, profit))
        dp = [(0, 0)]
        for e, s, p in jobs:
            i = bisect.bisect_right(dp, (s+1, 0))-1
            if dp[i][1]+p > dp[-1][1]:
                dp.append((e, dp[i][1]+p))
        return dp[-1][1]",O(nlogn)
"n = int(input())
ans = 1+n//2
print(ans)
",O(1)
"class Solution(object):
    def isIsomorphic(self, s, t):
        if len(s) != len(t):
            return False

        s2t, t2s = {}, {}
        for p, w in zip(s, t):
            if w not in s2t and p not in t2s:
                s2t[w] = p
                t2s[p] = w
            elif w not in s2t or s2t[w] != p:
                return False
        return True",O(n)
"def solve():
    l, r = map(int, input().split())

    ans = l^r
    j = 0
    while 1<<j <= ans:
        ans |= 1<<j
        j += 1

    print(ans)

solve()
",O(logn)
"import os
import sys
from io import BytesIO, IOBase

def main():
    l,r=map(int,input().split("" ""))
    n=len(bin(r)[2:])
    ans=0
    for x in range(0,n+1):
        if (r>>x)&1==1 and (l>>x)&1==0:
            ans=max(ans,(1<<x)^((1<<x)-1))
    print(ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(logn)
"class Solution(object):
    def maxNumber(self, n):
        return (1<<(n.bit_length()-1))-1",O(1)
"class Solution(object):
    def lastMarkedNodes(self, edges):
        def bfs(root):
            new_root = -1
            dist = [-1]*len(adj)
            dist[root] = 0
            q = [root]
            while q:
                new_root = q[0]
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[v] != -1:
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                q = new_q
            return dist, new_root
            
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        _, u = bfs(0)
        dist1, v = bfs(u)
        dist2, _ = bfs(v)
        return [u if dist1[w] > dist2[w] else v for w in range(len(adj))]",O(n)
"import collections



class Queue(object):
    def __init__(self):
        self.data = collections.deque()

    def push(self, x):
        self.data.append(x)

    def peek(self):
        return self.data[0]

    def pop(self):
        return self.data.popleft()

    def size(self):
        return len(self.data)

    def empty(self):
        return len(self.data) == 0








class Solution(object):
    def invertTree(self, root):
        if root is not None:
            nodes = Queue()
            nodes.push(root)
            while not nodes.empty():
                node = nodes.pop()
                node.left, node.right = node.right, node.left
                if node.left is not None:
                    nodes.push(node.left)
                if node.right is not None:
                    nodes.push(node.right)

        return root",O(n)
"class Solution(object):
    def totalNQueens(self, n):
        def dfs(row):
            if row == n:
                return 1
            result = 0
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                result += dfs(row+1)
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False
            return result

        result = []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        return dfs(0)",O(n!)
"n_extnson, n_dvics, n_sokts = list(map(int, input().split()))
extensions = list(map(int, input().split()))
extensions.sort(reverse=True)
devices_left = n_dvics - n_sokts
extnson_used = 0
i = 0
while devices_left > 0 and n_extnson > 0:
    devices_left += 1
    extnson_siez = extensions[i]
    devices_left -= extnson_siez
    extnson_used += 1
    n_extnson -= 1
    i += 1

if devices_left > 0:
    print(-1)
else:
    print(extnson_used)
",O(nlogn)
"n = int(input())
a = list(map(int, input().split()))
res = []
if n == 1:
    print(1)
    exit(0)

i = 0
if a[0] < a[1]:

    if i >= n - 2:
        res = [1]
        cur = 2
    else:
        if a[i + 1] < a[i + 2]:
            res = [1]
            cur = 2
        elif a[i + 1] > a[i + 2]:
            res = [1]
            cur = 5
        else:
            res = [1]
            cur = 2

elif a[0] > a[1]:

    if i >= n - 2:
        res = [5]
        cur = 4
    else:
        if a[i + 1] < a[i + 2]:
            res = [5]
            cur = 1
        elif a[i + 1] > a[i + 2]:
            res = [5]
            cur = 4
        else:
            res = [5]
            cur = 4

else:
    if i >= n - 2:
        res.append(1)
        cur = 2
    else:
        if a[i + 1] < a[i + 2]:
            res.append(2)
            cur = 1
        elif a[i + 1] > a[i + 2]:
            res.append(4)
            cur = 5
        else:
            res.append(2)
            cur = 3

for i in range(1, n - 1):
    if not (1 <= cur <= 5):
        print(-1)
        exit(0)
    res.append(cur)
    if a[i] > a[i + 1]:

        if i >= n - 2:
            cur -= 1
        else:
            if a[i + 1] < a[i + 2]:
                cur = min(cur - 1, 1)
            elif a[i + 1] > a[i + 2]:
                cur -= 1
            else:
                cur -= 1

    elif a[i] < a[i + 1]:

        if i >= n - 2:
            cur += 1
        else:
            if a[i + 1] < a[i + 2]:
                cur += 1
            elif a[i + 1] > a[i + 2]:
                cur = max(cur + 1, 5)
            else:
                cur += 1
    else:
        if i >= n - 2:
            if cur != 3:
                cur = 3
            else:
                cur = 2
        else:
            if a[i + 1] < a[i + 2]:
                if cur == 1:
                    cur = 2
                else:
                    cur = 1
            elif a[i + 1] > a[i + 2]:
                if cur == 5:
                    cur = 4
                else:
                    cur = 5
            else:
                if cur != 3:
                    cur = 3
                else:
                    cur = 2
if not (1 <= cur <= 5):
    print(-1)
    exit(0)
res.append(cur)
print(*res)",O(n)
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def solve(node, remain, adj, dp, n, m):
  if remain == 0:
    return 0

  key = (node + remain * n * m)
  mem = dp[key]
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1,
            adj, dp, n, m) + x[1], adj[node]))
  dp[key] = ans
  return ans

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = [-1] * (n*m*(k/2+1))

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2, adj, dp, n, m) * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"import collections


class Solution2(object):
    def lastSubstring(self, s):
        count = collections.defaultdict(list)
        for i in range(len(s)):
            count[s[i]].append(i)

        max_c = max(count.keys())
        starts = {}
        for i in count[max_c]:
            starts[i] = i+1
        while len(starts)-1 > 0:
            lookup = set()
            next_count = collections.defaultdict(list)
            for start, end in starts.items():
                if end == len(s): 
                    lookup.add(start)
                    continue
                next_count[s[end]].append(start)				
                if end in starts: 
                    lookup.add(end)			
            next_starts = {}
            max_c = max(next_count.keys())
            for start in next_count[max_c]:
                if start not in lookup:
                    next_starts[start] = starts[start]+1
            starts = next_starts
        return s[next(iter(starts.keys())):]",O(n)
"import random



class Solution(object):
    def miceAndCheese(self, reward1, reward2, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        for i in range(len(reward1)):
            reward1[i] -= reward2[i]
        nth_element(reward1, k-1, compare=lambda a, b: a > b)
        return sum(reward2)+sum(reward1[i] for i in range(k))",O(n)
"k=int(input())
i=0
r=1
while(k>=r):
    r+=9*(i+1)*10**i
    i+=1
r=r-(9*i*10**(i-1))
ans=str(((k-r)//i)+10**(i-1))[(k-r)%i]
print(ans)",O(1)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if self.isSafe(r, c, board):
                    board[r][c] = ""Q""
                    backtrack(r + 1)
                    board[r][c] = "".""

        backtrack(0)
        return res

    def isSafe(self, r: int, c: int, board):
        row = r - 1
        while row >= 0:
            if board[row][c] == ""Q"":
                return False
            row -= 1

        row, col = r - 1, c - 1
        while row >= 0 and col >= 0:
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col -= 1

        row, col = r - 1, c + 1
        while row >= 0 and col < len(board):
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col += 1
        return True
",O(n!)
"import collections


class Solution(object):
    def findLHS(self, nums):
        lookup = collections.defaultdict(int)
        result = 0
        for num in nums:
            lookup[num] += 1
            for diff in [-1, 1]:
                if (num + diff) in lookup:
                    result = max(result, lookup[num] + lookup[num + diff])
        return result",O(n)
"class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:

        def dfs(i):
            if i >= len(cost):
                return 0
            return cost[i] + min(dfs(i + 1), dfs(i + 2))

        return min(dfs(0), dfs(1))
",O(2 ^ n)
"val=10**9
n,m=map(int,input().split())
arr1=[]
for i in range(n):
    x=int(input())
    arr1.append(x)
arr1.append(val)
arr2=[]
ans=val
finalval=0
arr1.sort()
for i in range(m):
    x1,x2,y=map(int,input().split())
    if(x1==1):
        if(x2==val):
            finalval+=1
        else:
            if(len(arr1)>0 and x2>=arr1[0]):
                arr2.append(x2)
arr2.sort()
i=0
j=0
while(i<len(arr1) and j<len(arr2)):
    if(arr1[i]>arr2[j]):
        j+=1
    elif(arr1[i]==arr2[j]):
        temp1=len(arr2)-j

        ans=min(i+temp1,ans)
        i+=1
    else:
        temp1=len(arr2)-j

        ans=min(i+temp1,ans)
        i+=1

ans=min(i,ans)
print(ans+finalval)
",O(nlogn)
"def solve(n, a):
    a = sorted(a)
    col = [False for i in range(n)]
    count = 0
    for i in range(n):
        if not col[i]:
            count += 1
            col[i] = True
            for j in range(n):
                if a[j] % a[i] == 0:
                    col[j] = True
    return count

n = int(input())
a = list(map(int, input().split()))
print(solve(n, a))",O(n ^ 2)
"from math import factorial
n, mod = map(int, input().split())
def binom(n, m):    return factorial(n) // factorial(m) // factorial(n-m)
def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):sign = 1 if (i-k)%2 == 0 else -1;ans += sign * binom(k, i) * (i**x);ans %= mod
    return ans
def f(x, k):    return (foo(x, k) * pow(2, x-k, mod)) % mod
ans = 0
for i in range((n+1)//2):ans = (ans + f(n-i, i+1));ans %= mod
print(ans)",O(n ^ 3)
"class Solution2(object):
    def printLinkedListInReverse(self, head):
        nodes = []
        while head:
            nodes.append(head)
            head = head.getNext()
        for node in reversed(nodes):
            node.printValue()",O(n)
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    t=int(input())
    tup=[]
    for _ in range(t):
        l,r=inar()
        tup.append([l,r])
    tup.sort()
    l=tup[0][0]
    r=tup[0][1]
    prefix=[[l,r]]
    for i in range(1,t):
        if l>tup[i][1] or r<tup[i][0]:
            prefix.append([-1,-1])
            for j in range(i+1,t):
                prefix.append([-1, -1])
            break

        l=max(l,tup[i][0])
        r=min(r,tup[i][1])
        prefix.append([l,r])
    l = tup[-1][0]
    r = tup[-1][1]
    suffix = []
    for i in range(t):
        suffix.append([-1,-1])
    suffix[-1][0]=l
    suffix[-1][1]=r
    for i in range(t-2,-1,-1):
        if l > tup[i][1] or r < tup[i][0]:
            break

        l = max(l, tup[i][0])
        r = min(r, tup[i][1])
        suffix[i][0]=l
        suffix[i][1]=r
    ans=0
    for i in range(t):
        if i==0:
            ans=max(ans,abs(suffix[i+1][0]-suffix[i+1][1]))
            continue
        if i==t-1:
            ans=max(ans,abs(prefix[i-1][0]-prefix[i-1][1]))
            continue
        prefix_l=prefix[i-1][0]
        prefix_r=prefix[i-1][1]
        suffix_l=suffix[i+1][0]
        suffix_r=suffix[i+1][1]
        l=max(prefix_l,suffix_l)
        r=min(prefix_r,suffix_r)
        ans=max(ans,max(0,r-l))
    print(ans)

if __name__ == '__main__':
    main()
",O(n)
"class Solution(object):
    def distinctAverages(self, nums):
        lookup = set()
        nums.sort()
        left, right = 0, len(nums)-1
        while left < right:
            lookup.add(nums[left]+nums[right])
            left, right = left+1, right-1
        return len(lookup)",O(nlogn)
"n = int(input())
a = str(input())
b = str(input())
k = True
result = 0
for i in range(n):
    if a[i] == b[i]:
        if k == False:
            result += 1
        k = True
    else:
        if k == False and z != a[i]:
            result += 1
            k = True
        elif k == False and z == a[i]:
            result += 1
        else:
            k = False
            z = a[i]
if k == False:
    result += 1
print(result)",O(n)
"from sys import stdin

n, m = map(int, stdin.readline().split())
ans, p, all = [], [1 << i for i in range(n - 2, -1, -1)] + [1], set(range(1, n + 1))
num, cur, i = 1, 0, 0

while i < len(p) and m > 0 and num <= n:
    cur += p[i]
    if cur >= m:
        m -= (cur - p[i])
        cur = 0
        ans.append(num)
        all.discard(num)
    num += 1
    i += 1

print(' '.join(map(str, ans + sorted(all)[::-1])))
",np
"parent = [i for i in range(int(1e5 + 10))]
def findSet(u):
    if parent[u] != u:
        parent[u] = findSet(parent[u])
    return parent[u]

def unionSet(u, v):
    up = findSet(u)
    vp = findSet(v)
    parent[up] = vp

if __name__ == '__main__':
    n, a, b = map(int, input().split())
    lst = list(map(int, input().split()))
    temp = {lst[i]: i for i in range(n)}
    for i in range(n):
        if a - lst[i] in temp:
            unionSet(i, temp[a - lst[i]])
        else:
            unionSet(i, n)
        if b - lst[i] in temp:
            unionSet(i, temp[b - lst[i]])
        else:
            unionSet(i, n + 1)

    if findSet(n) == findSet(n + 1):
        print('NO')
    else:
        print('YES')
        tmp = findSet(n + 1)
        lst = [0 if findSet(i) == tmp else 1 for i in range(n)]
        print(*lst)",O(n)
"import random



class Solution(object):
    def makeSubKSumEqual(self, arr, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        l = gcd(k, len(arr))
        result = 0
        for i in range(l):
            vals = [arr[j] for j in range(i, len(arr), l)]
            nth_element(vals, len(vals)//2)
            result += sum(abs(v-vals[len(vals)//2]) for v in vals)
        return result",O(n)
"n = int(input())
x,y = map(int,input().split())
if max(x-1,y-1) > max(n-x,n-y):
    print(""Black"")
else:
    print(""White"")
",O(1)
"def getsum(n):
    return ((1 << (2*n)) - 1) // 3

def b(n, k):
    l = n - 1
    r = max(0, l - 41)
    while True:
        mid = (l + r) // 2
        count = getsum(n - mid)
        if count <= k:
            l = mid
        else:
            r = mid
        if l - r <= 1:
            break
        del count
    g = getsum(n - r)
    if g < k:
        del g
        return None
    elif g == k:
        del g
        return r
    return l

t = int(input())
for i in range(t):
    n, k = map(int, input().split())
    min_side = b(n, k)
    if min_side is None:
        print('NO')
        continue
    k -= getsum(n - min_side)
    if n == 2 and min_side == 1 and k == 2:
        print('NO')
        continue
    num_squares = (1 << (n - min_side)) * 2 - 1
    if k >= num_squares:
        print('YES ' + str(min_side - 1))
    else:
        print('YES ' + str(min_side))",O(logn)
"class Solution2(object):
    def maxLength(self, arr):
        def bitset(s):
            result = 0
            for c in s:
                if result & power[ord(c)-ord('a')]:
                    return 0
                result |= power[ord(c)-ord('a')]
            return result
    
        bitsets = [bitset(x) for x in arr]
        result = 0
        for i in range(power[len(arr)]):
            curr_bitset, curr_len = 0, 0
            while i:
                j = i & -i 
                i ^= j
                j = log2[j] 
                if not bitsets[j] or (curr_bitset & bitsets[j]):
                    break
                curr_bitset |= bitsets[j]
                curr_len += len(arr[j])
            else:
                result = max(result, curr_len)
        return result",O(2 ^ n)
"x, y, z, t1, t2, t3 = map(int, input().split())
lift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3
stairs = t1 * abs(x - y)
if lift <= stairs:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"class Solution(object):
    def toHex(self, num):
        if not num:
            return ""0""

        result = []
        while num and len(result) != 8:
            h = num & 15
            if h < 10:
                result.append(str(chr(ord('0') + h)))
            else:
                result.append(str(chr(ord('a') + h-10)))
            num >>= 4
        result.reverse()

        return """".join(result)",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def btreeGameWinningMove(self, root, n, x):
        def count(node, x, left_right):
            if not node:
                return 0
            left, right = count(node.left, x, left_right), count(node.right, x, left_right)
            if node.val == x:
                left_right[0], left_right[1] = left, right
            return left + right + 1

        left_right = [0, 0]
        count(root, x, left_right)
        blue = max(max(left_right), n-(sum(left_right)+1))
        return blue > n-blue",O(n)
"import collections
import itertools
import heapq



class Solution(object):
    def mostFrequentIDs(self, nums, freq):
        result = []
        cnt = collections.Counter()
        max_heap = []
        for x, f in zip(nums, freq):
            cnt[x] += f
            heapq.heappush(max_heap, (-cnt[x], x))
            while max_heap and -max_heap[0][0] != cnt[max_heap[0][1]]:
                heapq.heappop(max_heap)
            result.append(-max_heap[0][0] if max_heap else 0)
        return result",O(nlogn)
"from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop,heapify
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

from itertools import accumulate
from functools import lru_cache

M = mod = 998244353
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)

def li():return [int(i) for i in input().rstrip('\n').split()]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n')]
def li3():return [int(i) for i in input().rstrip('\n')]

a = val()
b = val()

n = len(str(a))

a = [int(i) for i in str(a)]
a.sort()
if len(str(b)) > n:

    print(*sorted(a, reverse = 1), sep = '')
    exit()

b = str(b)
b = [int(i) for i in b]

def makenum(s):return int(''.join(str(e) for e in s))

def givemax(a, b):
    if len(a) > len(b):return a
    elif len(b) > len(a):return b
    else:
        for j in range(len(a)):
            if a[j] > b[j]:return a
            elif b[j] > a[j]:return b
        return a

@lru_cache(None)
def dp(l, equal = 1):

    if len(l) == 1:return str(-float('inf')) if l[0] > b[-1] and equal else str(l[0])
    if not equal:return ''.join(str(e) for e in sorted(l, reverse = 1))
    ans = ''
    l = list(l)
    curr = b[n - len(l)]
    for i in range(len(l)):
        if l[i] < curr and dp(tuple(l[:i] + l[i + 1:]), 0) != '-inf':
            ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 0))
        elif l[i] == curr and dp(tuple(l[:i] + l[i + 1:]), 1) != '-inf':
            ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 1))

    return str(ans)

print(dp(tuple(a), 1))",O(n ^ 3)
"import itertools


class Solution(object):
    def minSwaps(self, grid):
        result = 0
        for target in reversed(range(1, len(grid))):
            row_idx = len(grid)-1-target
            while row_idx < len(grid):
                row = grid[row_idx]
                if not sum(itertools.islice(row, len(row)-target, len(row))):
                    break
                row_idx += 1
            else:
                return -1
            while row_idx != len(grid)-1-target:
                grid[row_idx], grid[row_idx-1] = grid[row_idx-1], grid[row_idx]
                result += 1
                row_idx -= 1
        return result",O(n ^ 2)
"class Solution(object):
    def minDistance(self, height, width, tree, squirrel, nuts):
        def distance(a, b):
            return abs(a[0] - b[0]) + abs(a[1] - b[1])

        result = 0
        d = float(""inf"")
        for nut in nuts:
            result += (distance(nut, tree) * 2)
            d = min(d, distance(nut, squirrel) - distance(nut, tree))
        return result + d",O(n)
"class Solution(object):
    def longestSemiRepetitiveSubstring(self, s):
        result = left = prev = 0
        for right in range(len(s)):
            if right-1 >= 0 and s[right-1] == s[right]:
                left, prev = prev, right
            result = max(result, right-left+1)
        return result",O(n)
"class Solution2(object):
    def minimumCost(self, nums):
        def topk(a, k):
            result = [float(""inf"")]*k
            for x in a:
                for i in range(len(result)):
                    if x < result[i]:
                        result[i], x = x, result[i]
            return result

        return nums[0]+sum(topk((nums[i] for i in range(1, len(nums))), 2))",O(n)
"import math
def f(n,k):
    if k==1:
        return (n*(n+1))//2
    a=math.floor(math.log(n,k))
    b=sum(k**i for i in range(a+1))
    c=sum((i+1)*k**i for i in range(a+1))
    if n<b:
        return c-(b-n)*(a+1)
    else:
        return c+(n-b)*(a+2)
n,s=map(int,input().split())
if s==(n*(n+1))//2:
    print(""Yes"")
    a=[str(i+1) for i in range(n-1)]
    print("" "".join(a))
elif s>(n*(n+1))//2:
    print(""No"")
elif s<2*n-1:
    print(""No"")
else:
    mini=1
    maxi=n-1
    curr=1
    while True:
        a,b=f(n,curr),f(n,curr+1)
        if b>s:
            mini=curr+1
            curr=math.ceil((curr+maxi)/2)
        elif a<=s:
            maxi=curr-1
            curr=(curr+mini)//2
        else:
            opt=curr+1
            break
    depths=[0,1]+[0]*(n-1)
    ins=1
    ind=2
    while True:
        a=min(opt**(ind-1),n-ins)
        depths[ind]=a
        ind+=1
        ins+=a
        if ins==n:
            break
    left=s-b
    far=ind-1
    bulk=ind-1
    if depths[bulk]==1:
        bulk-=1
    while left>0:
        if far+1-bulk<=left:
            far+=1
            left-=far-bulk
            depths[far]+=1
            depths[bulk]-=1
            if depths[bulk]==1:
                bulk-=1
        else:
            depths[bulk]-=1
            depths[bulk+left]+=1
            left=0
    verts=[None]*far
    sumi=0
    for i in range(far):
        verts[i]=list(range(sumi+1,sumi+1+depths[i+1]))
        sumi+=depths[i+1]
    out=""""
    for i in range(1,far):
        for j in range(len(verts[i])):
            out+=str(verts[i-1][j//opt])+"" ""
    print(""Yes"")
    print(out)",O(n)
"def solve(n, v):
    fuel = min(n - 1, v)
    cost = fuel
    for i in range(2, n):
        if fuel >= n - 1:
            break
        fuel += 1
        cost += i
    return cost

n, v = map(int, input().split())
print(solve(n, v))
",O(n)
"import collections
import heapq


class Solution(object):
    def avoidFlood(self, rains):
        lookup = collections.defaultdict(list)
        i = len(rains)-1
        for lake in reversed(rains):
            lookup[lake].append(i)
            i -= 1
        result, min_heap = [], []
        for i, lake in enumerate(rains):
            if lake:
                if len(lookup[lake]) >= 2:
                    lookup[lake].pop()
                    heapq.heappush(min_heap, lookup[lake][-1])
                result.append(-1)
            elif min_heap:
                j = heapq.heappop(min_heap)
                if j < i:
                    return []
                result.append(rains[j])
            else:
                result.append(1)
        return result if not min_heap else []",O(nlogn)
"n,m=map(int,input().split())
l=list()
r=list()
for _ in range(m):
    a,b=map(int,input().split())
    l.append(a)
    r.append(b)
for i in range(n):
    if(i%2==0):
        print(0,end='')
    else:
        print(1,end='')
",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def sortLinkedList(self, head):
        tail, curr, head.next = head, head.next, None
        while curr:
            if curr.val > 0:
                curr.next, tail.next, tail, curr = None, curr, curr, curr.next
            else:
                curr.next, head, curr = head, curr, curr.next
        return head",O(n)
"import sys
input=lambda:sys.stdin.readline().rstrip()

h,w=map(int,input().split())
s=[list("".""*(w+2))]+[list("".""+input()+""."") for _ in range(h)]+[list("".""*(w+2))]
b=[[0]*(w+2)for _ in range(h+2)]
c=[[0]*(w+2)for _ in range(h+2)]
for i in range(1,h+2):
  for j in range(1,w+2):
    if s[i][j]==""*"":
      b[i][j]=b[i-1][j]+1
      c[i][j]=c[i][j-1]+1
for i in range(h,-1,-1):
  for j in range(w,-1,-1):
    if s[i][j]==""*"":
      b[i][j]=min(b[i][j],b[i+1][j]+1)
      c[i][j]=min(c[i][j],c[i][j+1]+1)
ans=[]
for i in range(1,h+1):
  for j in range(1,w+1):
    t=min(b[i][j],c[i][j])-1
    if t>0:
      ans.append((i,j,t))
b=[[0]*(w+2)for _ in range(h+2)]
c=[[0]*(w+2)for _ in range(h+2)]
for i,j,t in ans:
  b[i-t][j]+=1
  b[i+t+1][j]-=1
  c[i][j-t]+=1
  c[i][j+t+1]-=1
for i in range(h+1):
  for j in range(w+1):
    b[i+1][j]+=b[i][j]
    c[i][j+1]+=c[i][j]
    if i!=0 and j!=0:
      if (b[i][j]+c[i][j]>0)!=(s[i][j]==""*""):
        print(-1)
        exit()

print(len(ans))
for i in ans:print(*i)",O(n ^ 2)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        dp = [False] * n
        dp[-1] = True

        for i in range(n - 2, -1, -1):
            end = min(n, i + nums[i] + 1)
            for j in range(i + 1, end):
                if dp[j]:
                    dp[i] = True
                    break
        return dp[0]
",O(n ^ 2)
"a, b = map(int, input().split())
arr = list(map(int, input().split()))
mn = float(""inf"")
for i in range(1, a+1):
    mn = min(mn, arr.count(i))

print(mn)
",O(n ^ 2)
"import itertools
from functools import reduce


class Solution(object):
    def minDominoRotations(self, A, B):
        intersect = reduce(set.__and__, [set(d) for d in zip(A, B)])
        if not intersect:
            return -1
        x = intersect.pop()
        return min(len(A)-A.count(x), len(B)-B.count(x))",O(n)
"def good(max_branch, s, n):
    nodes = 0
    can = 1
    lowest_s = 0
    depth = 1
    while(nodes < n):
        added = min(n - nodes, can)
        lowest_s += added * depth
        nodes += added
        can *= max_branch
        depth += 1
    return lowest_s <= s

n, s = map(int, input().split())

if s < 2 * n - 1 or s * 2 > n * (n + 1):
    print('No')
else:
    lo, hi = 1, n
    while lo < hi:
        mid = (lo + hi) >> 1
        if good(mid, s, n) == False:
            lo = mid + 1
        else:
            hi = mid

    max_branch = lo

    level_size = [1] * (n + 1)
    node_level = [i for i in range(n + 1)]
    cur_node = n
    cur_level = 1
    cur_sum = n * (n + 1) // 2
    can = 1
    while cur_sum > s:
        if level_size[cur_level] == can:
            cur_level += 1
            can *= max_branch

        if cur_sum - (cur_node - cur_level) < s:
            cur_level = cur_node - (cur_sum - s)

        node_level[cur_node] = cur_level
        level_size[cur_level] += 1
        cur_sum -= cur_node - cur_level
        cur_node -= 1

    node_list = [[] for _ in range(n + 1)]
    for i in range(1, n + 1):
        node_list[node_level[i]].append(i)

    pre = 0
    children = [0] * (n + 1)
    parent = [-1] * (n + 1)
    seen_nodes = 1
    for level in range(2, n + 1):
        idx = 0
        if not node_list[level - 1]:
            assert seen_nodes == n
            break
        cur_father = node_list[level - 1][0]
        for node in node_list[level]:
            if children[cur_father] == max_branch:
                idx += 1
                cur_father = node_list[level - 1][idx]
            children[cur_father] += 1
            parent[node] = cur_father
            seen_nodes += 1

    print('Yes')
    print(*parent[2:])
",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def levelOrder(self, root):
        if root is None:
            return []
        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            current = next_level
            result.append(vals)
        return result

",O(n)
"def lower_bound(n, k):
    low = 1
    high = k
    while low < high:
        mid = low + (high - low) // 2
        pipes = mid * k - (mid + 2) * (mid - 1) // 2
        if pipes >= n:
            high = mid
        else:
            low = mid + 1
    return low

def main():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        ans = lower_bound(n, k)
        if ans == k:
            print(-1)
        else:
            print(ans)

if __name__ == ""__main__"":
    main()",O(logn)
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums)

        while l < r:
            m = l + ((r - l) // 2)
            if nums[m] >= target:
                r = m
            elif nums[m] < target:
                l = m + 1
        return l if (l < len(nums) and nums[l] == target) else -1
",O(logn)
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))
candies=[]
for i in range(n):
    candies.append(n-l[i]-r[i])
left=[]
for i in range(n):
    guys=0
    for j in range(i):
        if candies[j]>candies[i]:
            guys+=1
    left.append(guys)
right=[]
for i in range(n):
    guys=0
    for j in range(i,n):
        if candies[j]>candies[i]:
            guys+=1
    right.append(guys)
if left==l and right==r:
    print(""YES"")
    candiesstr=""""
    for i in range(n):
        candiesstr+=str(candies[i])+"" ""
    print(candiesstr[:len(candiesstr)-1])
else:
    print(""NO"")",O(n ^ 2)
"I = lambda: map(int, input().split())

n, l, r, x = I()
C, k = [*I()], 0

for i in range(2 ** n):
    W = [w for w, b in zip(C, bin(i)[2:].zfill(n)) if b == '1']
    if l <= sum(W) <= r and max(W) - min(W) >= x:
        k += 1

print(k)",np
"
class Solution(object):
    def containsNearbyDuplicate(self, nums, k):
        lookup = {}
        for i, num in enumerate(nums):
            if num not in lookup:
                lookup[num] = i
            else:
                if i - lookup[num] <= k:
                    return True
                lookup[num] = i
        return False

",O(n)
"R = lambda: map(int, input().split())
n, m, k = R()
cls = [list(i for i, x in enumerate(map(int, input())) if x) for _ in range(n)]
dp = [[n * m] * (k + 1) for i in range(n + 1)]
dp.append([0] * (k + 1))
for i in range(n):
    row = cls[i]
    c2l = [m + 1] * (m + 1)
    c2l[0] = row[-1] - row[0] + 1 if row else 0
    c2l[len(row)] = 0
    for r in range(len(row)):
        for l in range(r + 1):
            c2l[len(row) - (r - l + 1)] = min(c2l[len(row) - (r - l + 1)], row[r] - row[l] + 1)
    for j in range(k + 1):
        for c, l in enumerate(c2l):
            if j + c <= k and l < m + 1:
                dp[i][j] = min(dp[i][j], dp[i - 1][j + c] + l)
print(min(dp[n - 1]))",O(n ^ 3)
"cases = int(input())
while cases:
    cases -= 1
    a, b = map(int, input().split())

    ans = 0
    while a > 0 and b > 0:
        if a < b:
            a, b = b, a
        ans += a//b
        a = a % b

    print(ans)
",O(1)
"from math import sqrt
n, k = map(int, input().split())
a = 1
b = -1 * (2*n + 3)
c = n * (n + 1) - 2 * k

res = (-1 * b) - sqrt((b * b) - 4 * a * c)
res = res / 2
res = int(res)
print(res)
",O(logn)
"class Solution2(object):
    def evaluateTree(self, root):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
        }
        
        def dfs(node):
            if node.left == node.right:
                return node.val
            return OP[node.val](dfs(node.left), dfs(node.right))

        return dfs(root)",O(n)
"class Solution(object):
    def minCost(self, nums, x):
        def accumulate(a):
            for i in range(len(a)-1):
                a[i+1] += a[i]
            return a

        i = min(range(len(nums)), key=lambda x: nums[x])
        nums = nums[i:]+nums[:i]
        left, right = [-1]*len(nums), [len(nums)]*len(nums)
        stk = []
        for i in range(len(nums)):
            while stk and nums[stk[-1]] > nums[i]:
                right[stk.pop()] = i
            if stk:
                left[i] = stk[-1]
            stk.append(i)
        diff2 = [0]*(len(nums)+1)
        diff2[0] = (+1)*sum(nums)            
        diff2[1] = x                         
        diff2[-1] += (-1)*nums[0]            
        for i in range(1, len(nums)):
            l, r = i-left[i], right[i]-i
            diff2[min(l, r)] += (-1)*nums[i] 
            diff2[max(l, r)] += (-1)*nums[i] 
            diff2[l+r] += (+1)*nums[i]       
        return min(accumulate(accumulate(diff2)))",O(n)
"a=input()
n=len(a)
for i in range(n-1,-1,-1):
    b=sorted([a[j:j+i] for j in range(n-i+1)])
    if True in [b[j]==b[j-1] for j in range(1,n-i+1)]:
        print(i)
        break",O(n ^ 3)
"from sys import stdin, stdout
ti = lambda : stdin.readline().strip()
os = lambda i : stdout.write(str(i) + '\n')
ma = lambda fxn, ti : map(fxn, ti.split())
ol = lambda arr : stdout.write(' '.join(element for element in arr) + '\n')
olws = lambda arr : stdout.write(''.join(element for element in arr) + '\n')

class Digit:
	def __init__(self):
		self.count = {}

	def increment(self, k):
		if self.count.has_key(k):
			got = self.count[k]
			self.count[k] += 1
		else:
			self.count[k] = 1

	def found(self, k):
		if self.count.has_key(k):
			return self.count[k]
		else:
			return 0

n, mod = ma(int, ti())
array = ma(int, ti())

ans = 0
digits = [None]*11
for i in range(11):
	digits[i] = Digit()

for i in range(n):
	temp = array[i]%mod

	for j in range(10):
		temp *= 10
		temp %= mod

		digits[j+1].increment(temp)

for i in range(n):
	temp = array[i]
	count = 0
	while temp>0:
		temp /= 10
		count += 1

	find = mod-array[i]%mod
	find %= mod
	ans += digits[count].found(find)

for i in range(n):
	temp1 = array[i]%mod
	temp2 = array[i]

	while temp2 > 0:
		temp2 /= 10
		temp1 *= 10
		temp1 %= mod

	if ((temp1 + array[i])%mod == 0):
		ans -= 1

os(ans)",O(nlogn)
"mod = int(1000000007)

def somaPa(nSteps):
    if nSteps == 0:
        return 0
    return (1 + nSteps) * nSteps / 2

def diminui(step):
    return (pow(2, step, mod) - 2) % mod

x, k = map(int, raw_input().split())

if x == 0:
    print(0)
else:
    pot = pow(2, k + 1, mod)
    inv = pow(2, mod - 2, mod)

    big = (x * pot) % mod
    small = (big - diminui(k + 1) ) % mod

    print(int((( ( (big + small) % mod)  * inv ) % mod)))
",O(logn)
"class Solution(object):
    def arraySign(self, nums):
        flag = 0
        for x in nums:
            if not x:
                return 0
            if x < 0:
                flag ^= 1
        return -1 if flag else 1",O(n)
"class Solution(object):

    def __init__(self):
        self.__s = []

    def next(self, price):
        result = 1
        while self.__s and self.__s[-1][0] <= price:
            result += self.__s.pop()[1]
        self.__s.append([price, result])
        return result",O(1)
"import math
def getx(n):
    return math.floor(math.sqrt(n))
def getans(n,x):
    l1=[i for i in range(n,0,-1)]
    l2=[]
    i=0
    while(i<n):
        l2=l2+sorted(l1[i:i+x])
        i+=x
    return l2
n=int(input())
a=getx(n)
ans=getans(n,a)
ans1=[str(i) for i in ans]
print(' '.join(ans1))",O(n)
"n,l,r,x = map(int,input().split())
c = list(map(int,input().split()))
ans = 0

for mask in range(1 << n):
    a = []
    for bit in range(n):
        if mask & (1 << bit):
           a.append(c[bit])
    if len(a) >= 2 and max(a) - min(a) >= x and l <= sum(a) and sum(a) <= r:
        ans += 1
print(ans)
",np
"class Solution(object):
    def addStrings(self, num1, num2):
        result = []
        i, j, carry = len(num1) - 1, len(num2) - 1, 0

        while i >= 0 or j >= 0 or carry:
            if i >= 0:
                carry += ord(num1[i]) - ord('0')
                i -= 1
            if j >= 0:
                carry += ord(num2[j]) - ord('0')
                j -= 1
            result.append(str(carry % 10))
            carry /= 10
        result.reverse()

        return """".join(result)

    def addStrings2(self, num1, num2):
        length = max(len(num1), len(num2))
        num1 = num1.zfill(length)[::-1]
        num2 = num2.zfill(length)[::-1]
        res, plus = '', 0
        for index, num in enumerate(num1):
            tmp = str(int(num) + int(num2[index]) + plus)
            res += tmp[-1]
            if int(tmp) > 9:
                plus = 1
            else:
                plus = 0
        if plus:
            res += '1'
        return res[::-1]",O(n)
"n, k = map(int, raw_input().split())
a = map(int, raw_input().split())
for i in range(n):
    ai = a[i]
    nai = ((1<<k) - 1)^ai
    if nai < ai:
        a[i] = nai

from collections import Counter
C = Counter()
C[0] += 1
S = 0
cnt = 0
for j, ai in enumerate(a):
    nai = ((1<<k) - 1)^ai
    v1, v2 = C[S^ai], C[S^nai]
    if v1 <= v2:
        cnt += j + 1 - v1
        S ^= ai
        C[S] += 1
    else:
        cnt += j + 1 - v2
        S ^= nai
        C[S] += 1
print(cnt)
",O(n)
"
import collections


class Solution(object):
    def customSortString(self, S, T):
        counter, s = collections.Counter(T), set(S)
        result = [c*counter[c] for c in S]
        result.extend([c*counter for c, counter in counter.items() if c not in s])
        return """".join(result)

",O(n)
"from collections import defaultdict
n, s = int(input()), []
for i in range(n):
  a = [int(x) for x in input().split()]
  s += [(a[0], 0), (a[1], 1)]
s.sort()
now = 0
rev = defaultdict(int)
for a,b in zip(s, s[1:]):

  if(a[1] == 0):
    now += 1

    rev[now] += b[0] - a[0]
    if b[1] == 1:

      rev[now] += 1

  else:
    now -= 1

    if b[0] != a[0]:
      rev[now] += b[0] - a[0]
      if b[1] == 0:

        rev[now] -= 1

for i in range(1, n+1):
  print(rev[i], end="" "")",O(nlogn)
"class Solution(object):
    def fractionToDecimal(self, numerator, denominator):
        result = """"
        if (numerator > 0 and denominator < 0) or (numerator < 0 and denominator > 0):
            result = ""-""

        dvd, dvs = abs(numerator), abs(denominator)
        result += str(dvd / dvs)
        dvd %= dvs

        if dvd > 0:
            result += "".""

        lookup = {}
        while dvd and dvd not in lookup:
            lookup[dvd] = len(result)
            dvd *= 10
            result += str(dvd / dvs)
            dvd %= dvs

        if dvd in lookup:
            result = result[:lookup[dvd]] + ""("" + result[lookup[dvd]:] + "")""

        return result",O(n)
"from math import log
n,k=map(int,input().split())
s=list(map(int,input().split()))
ans=0
for j in range(11):
    d=dict()
    z=10**j
    for i in s:
        y=i*z
        u=y%k
        if u in d:
            d[u]+=1
        else:
            d.update({u:1})
    for i in s:
        y=i
        lg=int(log(i,10))+1
        lg=10**lg
        if lg==z:
            d[(y*z)%k]-=1
            x=(k-y%k)
            if y%k==0:
                x=0
            if x in d:
                ans+=d[x]
            d[(y*z)%k]+=1
print(ans)
",O(nlogn)
"a = [0 for i in range(0, 256)]
n,k = input().split(' ')
k = int(k)
for c in input().split(' '):
        c = int(c)
        if a[c] != 0:
            print(a[c]-1, end=' ')
        else:
            for x in range(c, c-k, -1):
                if a[x] == 0:
                    i = x
                else:
                    if c-a[x]+1<k:
                        i = a[x]-1
                    break
                if x == 0:
                    break
            for x in range(int(i), c+1):
                a[x] = i + 1
            print(i, end=' ')
",O(n ^ 2)
"n, m = map(int, input().split())
A = list(map(int, input().split()))
from collections import Counter
C = Counter(A)

def is_ok(x):
    cnt = 0
    for v in C.values():
        cnt += v//x
    if cnt >= n:
        return True
    else:
        return False

ok = 0
ng = 1000
while ok+1 < ng:
    c = (ok+ng)//2
    if is_ok(c):
        ok = c
    else:
        ng = c
print(ok)
",O(nlogn)
"import sys

n, s = map(int, input().split())

ok, ng = 10**18+100, -1
while abs(ok - ng) > 1:
    mid = (ok + ng) >> 1
    if mid - sum(map(int, str(mid))) >= s:
        ok = mid
    else:
        ng = mid

print(max(0, n - ok + 1))
",O(logn)
"n,m = map(int,input().split())
d = {x:0 for x in range(m)}
l = []
for _ in range(n):
    s = input()
    for x in range(m):
        if s[x]== '1': d[x]+=1
    l.append(s)
for x in l:
    t=0
    for y in range(m):
        if x[y] =='1':
            if d[y] ==1:t = 1;break
    if t==0: print('YES');exit()
print('NO')",O(n ^ 2)
"n, q = map(int, input().split())
A = list(map(int, input().split()))
K = list(map(int, input().split()))
from itertools import accumulate
C = [0]+A
C = list(accumulate(C))
total = 0
ans = [0]*q
import bisect
for i, k in enumerate(K):
    total += k
    j = bisect.bisect_right(C, total)
    if j != n+1:
        ans[i] = n-(j-1)
    else:
        ans[i] = n
        total = 0
print(*ans, sep='\n')
",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from heapq import heapify,heappush as hp,heappop as hpop
def check(x,y):
    if 0<=x<=n-1 and 0<=y<=m-1:
        return True
    return False
n,m,k=map(int,input().split())
l1=[]
l2=[]
for i in range(n):
    l1.append(list(map(int,input().split())))
for  i in range(n-1):
    l2.append(list(map(int,input().split())))
inf=10**18
dp=[[[inf]*21 for i in range(m)] for j in range(n)]
for i in range(n):
    for j in range(m):
        if check(i,j+1):
            dp[i][j][1]=min(l1[i][j],dp[i][j][1])
        if check(i,j-1):
            dp[i][j][1]=min(l1[i][j-1],dp[i][j][1])
        if check(i+1,j):
            dp[i][j][1]=min(l2[i][j],dp[i][j][1])
        if check(i-1,j):
            dp[i][j][1]=min(l2[i-1][j],dp[i][j][1])
for x in range(2,k//2+1):
    for i in range(n):
        for j in range(m):
            if check(i,j+1):
                dp[i][j][x]=min(l1[i][j]+dp[i][j+1][x-1],dp[i][j][x])
            if check(i,j-1):
                dp[i][j][x]=min(l1[i][j-1]+dp[i][j-1][x-1],dp[i][j][x])
            if check(i+1,j):
                dp[i][j][x]=min(l2[i][j]+dp[i+1][j][x-1],dp[i][j][x])
            if check(i-1,j):
                dp[i][j][x]=min(l2[i-1][j]+dp[i-1][j][x-1],dp[i][j][x])

ans=[[inf]*m for i in range(n)]
for i in range(n):
    for j in range(m):
        if k%2:
            ans[i][j]=-1
            continue
        ans[i][j]=2*dp[i][j][k//2]
for i in ans:
    print(*i)
",O(n ^ 3)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

    def __repr__(self):
        if self:
            serial = []
            queue = [self]

            while queue:
                cur = queue[0]

                if cur:
                    serial.append(cur.val)
                    queue.append(cur.left)
                    queue.append(cur.right)
                else:
                    serial.append(

                queue = queue[1:]

            while serial[-1] == 
                serial.pop()

            return repr(serial)

        else:
            return None

class Solution(object):
    def recoverTree(self, root):
        return self.MorrisTraversal(root)

    def MorrisTraversal(self, root):
        if root is None:
            return
        broken = [None, None]
        pre, cur = None, root

        while cur:
            if cur.left is None:
                self.detectBroken(broken, pre, cur)
                pre = cur
                cur = cur.right
            else:
                node = cur.left
                while node.right and node.right != cur:
                    node = node.right

                if node.right is None:
                    node.right =cur
                    cur = cur.left
                else:
                    self.detectBroken(broken, pre, cur)
                    node.right = None
                    pre = cur
                    cur = cur.right

        broken[0].val, broken[1].val = broken[1].val, broken[0].val

        return root

    def detectBroken(self, broken, pre, cur):
        if pre and pre.val > cur.val:
            if broken[0] is None:
                broken[0] = pre
            broken[1] = cur",O(n)
"class Solution(object):
    def superPow(self, a, b):
        def myPow(a, n, b):
            result = 1
            x = a % b
            while n:
                if n & 1:
                    result = result * x % b
                n >>= 1
                x = x * x % b
            return result % b

        result = 1
        for digit in b:
            result = myPow(result, 10, 1337) * myPow(a, digit, 1337) % 1337
        return result",O(n)
"class Solution2(object):
    def deleteString(self, s):
        def getPrefix(pattern, start):
            prefix = [-1]*(len(pattern)-start)
            j = -1
            for i in range(1, len(pattern)-start):
                while j != -1 and pattern[start+j+1] != pattern[start+i]:
                    j = prefix[j]
                if pattern[start+j+1] == pattern[start+i]:
                    j += 1
                prefix[i] = j
            return prefix

        if all(x == s[0] for x in s):
            return len(s)
        dp = [1]*len(s) 
        for i in reversed(range(len(s)-1)):
            prefix = getPrefix(s, i) 
            for j in range(1, len(prefix), 2):
                if 2*(prefix[j]+1) == j+1:
                    dp[i] = max(dp[i], dp[i+(prefix[j]+1)]+1)
        return dp[0]",O(n ^ 2)
"n, m, k, l = map(int, input().split())
if (k+l+m-1)//m*m > n:
    print(-1)
else:
    print((k+l+m-1)//m)
",O(1)
"n, k = map(int, input().split())
values, single, l, r = [int(i) for i in input().split()], set(), -1, -1
for i in range(n):
    single.add(values[i])
    if len(single) == k:
        l, r = 1, i + 1
        break
single = set()
for i in range(r - 1, max(-1, l - 2), -1):
    single.add(values[i])
    if len(single) == k:
        l = i + 1
        break

if len(single) < k:
    print(-1, -1)
else:
    print(l, r)
",O(n)
"import sys
import math
import itertools
import functools
import collections
import operator

def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def wr(arr): return ' '.join(map(str, arr))
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=1):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)

n, k = mi()
t = math.ceil(math.sqrt(2 * (n + k) + 2.25) - 1.5)
print(n - t)
",O(logn)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

Q, = getIntList()
for _ in range(Q):
    N, M, K  = getIntList()
    if max(N,M) >K:
        print(-1)
        continue
    r = K
    if N%2!= K%2:
        r-=1
    if M%2!= K%2:
        r-=1
    print(r)
",O(1)
"import bisect

tmp = input().split()
n = int(tmp[0])
k = int(tmp[1])

scores = list()
times = list()
for i in range(n):
    tmp = input().split()
    scores.append(int(tmp[0]))
    times.append(int(tmp[1]))

sorted_scores = sorted(zip(scores, times), key=lambda y : (y[0], -y[1]), reverse=True)

ans = 1
i = k-2
while i>=0 and (sorted_scores[i] == sorted_scores[k-1]):
    ans = ans + 1
    i = i - 1

i = k
while i < n and (sorted_scores[i] == sorted_scores[k-1]):
    ans = ans + 1
    i = i + 1

print(ans)",O(nlogn)
"class Solution:
    def numDecodings(self, s: str) -> int:

        def dfs(i):
            if i == len(s):
                return 1
            if s[i] == '0':
                return 0

            res = dfs(i + 1)
            if i < len(s) - 1:
                if (s[i] == '1' or
                   (s[i] == '2' and s[i + 1] < '7')):
                    res += dfs(i + 2)

            return res

        return dfs(0)
",O(2 ^ n)
"def I(): return(list(map(int,input().split())))
n,l,r,x=I()
c=I()
l1=list(range(2**n))
ans=0
for j in l1:
	s=0
	num=0
	ma=0
	mi=100000000
	for i in range(n):
		if (j & 1<<i):
			num+=1
			s+=c[i]
			ma=max(c[i],ma)
			mi=min(c[i],mi)

	if s<=r and l<=s and(ma-mi>=x) and num>=2 :
		ans+=1
print(ans)
",np
"class Solution2(object):
    def placedCoins(self, edges, cost):
        def dfs(u, p):
            arr = [cost[u]]
            for v in adj[u]:
                if v == p:
                    continue
                arr.extend(dfs(v, u))
                arr.sort()
                if len(arr) > 5:
                    arr = arr[:2]+arr[-3:]
            result[u] = 1 if len(arr) < 3 else max(arr[0]*arr[1]*arr[-1], arr[-3]*arr[-2]*arr[-1], 0)
            return arr
                
        adj = [[] for _ in range(len(cost))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*len(cost)
        dfs(0, -1)
        return result",O(nlogn)
"
class Solution(object):
    def minPartitions(self, n):
        return int(max(n))
",O(n)
"import sys, os

numbs = [int(x) for x in sys.stdin.buffer.read().split()]
n = numbs.pop(0)

base = []
out = []

for i in range(n):
    x = numbs[i]
    how = 0

    for b,rep in base:
        if x.bit_length() == b.bit_length():
            x ^= b
            how ^= rep

    if x:
        how |= 1 << i

        a = 0
        b = len(base)
        while a < b:
            c = a + b >> 1
            if base[c][0] > x:
                a = c + 1
            else:
                b = c
        base.insert(a, (x, how))

        out.append(0)
    else:
        outind = len(out)
        out.append(-1)

        y = bin(how).encode('ascii')
        ylen = len(y)
        for i in range(2,len(y)):
            if y[i] == 49:
                out.append(ylen - 1 - i)
        out[outind] = len(out) - 1 - outind

os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))
",np
"class Solution(object):

    def __init__(self, n):
        self.__size = n
        self.__rows = [[0, 0] for _ in range(n)]
        self.__cols = [[0, 0] for _ in range(n)]
        self.__diagonal = [0, 0]
        self.__anti_diagonal = [0, 0]

    def move(self, row, col, player):
        i = player - 1
        self.__rows[row][i] += 1
        self.__cols[col][i] += 1
        if row == col:
            self.__diagonal[i] += 1
        if col == len(self.__rows) - row - 1:
            self.__anti_diagonal[i] += 1
        if any(self.__rows[row][i] == self.__size,
               self.__cols[col][i] == self.__size,
               self.__diagonal[i] == self.__size,
               self.__anti_diagonal[i] == self.__size):
            return player

        return 0",O(1)
"k=int(input())
i=0
r=1
while(k>=r):
    r+=9*(i+1)*10**i
    i+=1
r=r-(9*i*10**(i-1))
ans=str(((k-r)//i)+10**(i-1))[(k-r)%i]
print(ans)
",O(logn)
"class Solution(object):
    def countSeniors(self, details):
        return sum(x[-4:-2] > ""60"" for x in details)",O(n)
"from collections import deque

m, k = list(map(int, input().split()))

G = [set() for _ in range(m + 1)]

q, nq = deque(), deque()

for _ in range(m - 1):
    u, v = list(map(int, input().split()))
    G[u].add(v)
    G[v].add(u)

for u in range(1, m + 1):
    if len(G[u]) == 1:
        q.append(u)

step = 0
removed = 0
ok = True

while removed < m - 1:
    each = {}
    for u in q:
        nxt = G[u].pop()
        G[nxt].remove(u)
        each[nxt] = each.get(nxt, 0) + 1
        removed += 1
        if len(G[nxt]) == 0:
            break
        if len(G[nxt]) == 1:
            nq.append(nxt)
    if any(v < 3 for k,v in each.items()):
        ok = False
        break
    q, nq = nq, deque()
    step += 1

if ok and step == k and removed == m - 1:
    print('Yes')
else:
    print('No')
",O(nlogn)
"class Solution(object):
    def checkPossibility(self, nums):
        modified, prev = False, nums[0]
        for i in range(1, len(nums)):
            if prev > nums[i]:
                if modified:
                    return False
                if i-2 < 0 or nums[i-2] <= nums[i]:
                    prev = nums[i]   


                modified = True
            else:
                prev = nums[i]
        return True",O(n)
"n = int(input())
A = [0] + list(map(int,input().split()))

vec = []
for i in range(1, n+1) :
	vec = vec + [[A[i], i]]
list.sort(vec)
list.reverse(vec)

if vec[0][0] == 1 :
	print(""NO"")
	exit(0)

dia = 0
path = [vec[0][1]]
ans = []
bol, col, idx = 1, 1, 0
for i in vec[1:] :

	if i[0] != 1 :
		ans = ans + [[path[-1], i[1]]]
		dia = dia+1
		A[path[-1]] = A[path[-1]]-1
		path += [i[1]];
		A[path[-1]] = A[path[-1]]-1
	else :
		if col == 1:
			dia = dia+1
			col = 0
			A[path[0]] -= 1
			ans = ans+ [[path[0], i[1]]]
		elif bol == 1:
			dia = dia+1
			bol = 0
			A[path[-1]] -= 1
			ans = ans + [[path[-1], i[1]]]
		else :
			while idx < len(path) and A[path[idx]] == 0 :
				idx = idx+1
			if idx == len(path) :
				print(""NO"")
				exit(0)
			A[path[idx]] = A[path[idx]] - 1;
			ans = ans + [[path[idx], i[1]]]

print(""YES"", dia)
print(len(ans))
for i in ans :
	print(i[0], i[1])
",O(nlogn)
"class Solution(object):
    def countAlternatingSubarrays(self, nums):
        result = curr = 0
        for i in range(len(nums)):
            if i-1 >= 0 and nums[i-1] == nums[i]:
                curr = 0
            curr += 1
            result += curr
        return result",O(n)
"class Solution(object):
    def minChanges(self, s):
        return sum(s[i] != s[i+1] for i in range(0, len(s), 2))",O(n)
"casas, tubos = map(int, input().strip().split())

def bs(c, t):
    l, r = 0, t-1
    while l <= r:
        mid = l+r >> 1
        if ((2*t - mid - 1)*mid)//2+1 < c:
            l = mid+1
        else:
            r = mid-1
    return r+1

res = bs(casas, tubos)
print(-1 if res == tubos else res)
",O(logn)
"def suma(n):
    return n*(n+1)//2

def sumaij(i, j):
    if i <= 1:
        return suma(j)
    return suma(j) - suma(i-1)

def bin_search_solution(n, k):
    st, end = 1, k
    while st < end:
        mid = (st+end)//2
        s = sumaij(mid, k)
        if s == n:
            return k - mid + 1
        if s > n:
            st = mid + 1
        else:
            end = mid
    return k - st + 2

def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    elif k >= n:
        print(1)
    else:
        n -= 1
        k -= 1

        if suma(k) < n:
            print(-1)
        else:
            res = bin_search_solution(n, k)
            print(res)

if __name__ == '__main__':
    solve()
",O(logn)
"class Solution(object):
    def minimumScore(self, nums, edges):
        def is_ancestor(a, b):
            return left[a] <= left[b] and right[b] <= right[a]

        def iter_dfs():
            cnt = 0
            left = [0]*len(nums)
            right = [0]*len(nums)
            stk = [(1, (0, -1))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p = args
                    left[u] = cnt
                    cnt += 1
                    stk.append((2, (u, p)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, (v, u)))
                elif step == 2:
                    u, p = args
                    for v in adj[u]:
                        if v == p:
                            continue
                        nums[u] ^= nums[v]
                    right[u] = cnt
            return left, right
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        left, right = iter_dfs()
        result = float(""inf"")
        for i in range(1, len(nums)):
            for j in range(i+1, len(nums)):
                if is_ancestor(i, j):
                    a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j]
                elif is_ancestor(j, i):
                    a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i]
                else:
                    a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j]
                result = min(result, max(a, b, c)-min(a, b, c))
        return result",O(n ^ 2)
"a, b = map(int, input().split())
print(""1""*a)
print(int(""1"" + (""0"" * a)) - int(""1"" * a))",O(1)
"class Solution2(object):
    def largestValues(self, root):
        result = []
        curr = [root]
        while any(curr):
            result.append(max(node.val for node in curr))
            curr = [child for node in curr for child in (node.left, node.right) if child]
        return result",O(n)
"class Solution(object):
    def numberOfPoints(self, nums):
        nums.sort()
        result = 0
        curr = nums[0]
        for i in range(1, len(nums)):
            if nums[i][0] <= curr[1]:
                curr[1] = max(curr[1], nums[i][1])
            else:
                result += curr[1]-curr[0]+1
                curr = nums[i]
        result += curr[1]-curr[0]+1
        return result",O(nlogn)
"n = int(input())
a = sorted(map(int , input().split()))
ans = 0
for i in range(n):
    f = 1
    for j in range(i):
        if a[i] % a[j] == 0:
            f = 0
            break
    ans += f
print(ans)",O(n ^ 2)
"class Solution2(object):
    def countOfSubstrings(self, word, k):
        VOWELS = set(""aeiou"")
        def count(k):
            def update(i, d):
                if word[i] not in VOWELS:
                    curr2[0] += d
                    return
                x = ord(word[i])-ord('a')
                if cnt[x] == 0:
                    curr1[0] += 1
                cnt[x] += d
                if cnt[x] == 0:
                    curr1[0] -= 1

            result = 0
            cnt = [0]*26
            curr1, curr2 = [0], [0]
            left = 0
            for right in range(len(word)):
                update(right, +1)
                while curr1[0] == len(VOWELS) and curr2[0] >= k:
                    result += len(word)-right
                    update(left, -1)
                    left += 1
            return result

        return count(k)-count(k+1)",O(n)
"class Solution(object):
    def countSubarrays(self, nums, k):
        result = total = left = 0
        for right in range(len(nums)):
            total += nums[right]
            while total*(right-left+1) >= k:
                total -= nums[left]
                left += 1
            result += right-left+1
        return result",O(n)
"def d(n):
    ret = 0
    n = list(str(n))
    for i in range(len(n)):
        ret += int(n[i])
    return ret

def main():
    n, s = map(int, input().split())

    l, h = 0, n
    for i in range(2000):
        m = (l + h) // 2
        if m - d(m) >= s:
            h = m
        else:
            l = m

    for i in range(-100, 100):
        t = m + i
        if t < 0 or t > n:
            continue
        if abs(t - d(t)) >= s:
            print(n - t + 1)
            exit()
    print(0)

if __name__ == '__main__':
    main()
",O(logn)
"import collections


class Solution(object):
    def canArrange(self, arr, k):
        count = collections.Counter(i%k for i in arr)
        return (0 not in count or not count[0]%2) and \
                all(k-i in count and count[i] == count[k-i] for i in range(1, k) if i in count)",O(n)
"import os, sys
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def getInt(): return int(input())
def getStrs(): return input().split()
def getInts(): return list(map(int,input().split()))
def getStr(): return input()
def listStr(): return list(input())
def getMat(n): return [getInts() for _ in range(n)]
def isInt(s): return '0' <= s[0] <= '9'

squares = set([i*i for i in range(1,4000)])

p = [i for i in range(10**7+1)]
for i in range(1,10**7+1):
    if p[i] == i:
        for sq in squares:
            if i*sq > 10**7: break
            p[i*sq] = i

for _ in range(getInt()):
    N, K = getInts()
    A = getInts()
    new = 10**8
    A = [p[A[i]] for i in range(N)]
    dp = [N]*(K+1)
    dp[0] = 0
    used = [set()]*(K+1)
    for i in range(N):
        for j in range(K,-1,-1):
            if dp[j] == N: continue
            if A[i] in used[j]:
                if j < K and dp[j+1] > dp[j]:
                    dp[j+1] = dp[j]
                    used[j+1] = used[j]
                dp[j] += 1
                used[j] = set([A[i]])
            else:
                used[j].add(A[i])
    print(min(dp)+1)
",O(n ^ 3)
"ser = [0, 1]
def fib(n):
    i = 1
    while i < n:
        ser.append(i)
        i = ser[-1] + ser[-2]
    if i != n:
        return -1
    else:
        return len(ser)

n = int(input())
a, b, c = 0, 0, 0
ans = 1
if n == 0:
    ans = 1
elif n == 1:
    a = 1
elif n == 2:
    a = 1
    b = 1
elif n == 3:
    a = 1
    b = 1
    c = 1
else:
    ans = fib(n)
    if ans != -1:
        a = ser[ans-2]
        b = ser[ans-2]
        c = ser[ans-3]
if ans != -1:
    print(a, b, c)
else:
    print(""I'm too stupid to solve this problem"")
",O(1)
"r,g,b = map(int,input().split())
R = sorted([*map(int,input().split())],reverse=True)
G= sorted([*map(int,input().split())],reverse=True)
B = sorted([*map(int,input().split())],reverse=True)
mem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)]
def dp(i,j,k):
    p = (i==r)+(j==g)+(k==b)
    if(p>1):
        return 0
    if(mem[i][j][k]!=-1):
        return mem[i][j][k]
    ans = 0
    if(i==r):
        ans = dp(i,j+1,k+1)+G[j]*B[k]
        return ans
    elif(j==g):
        ans = dp(i+1,j,k+1)+R[i]*B[k]
    elif(k==b):
        ans = dp(i+1,j+1,k)+R[i]*G[j]
    else:
        ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k])
    mem[i][j][k] = ans
    return ans
print(dp(0,0,0))",O(n ^ 3)
"class Solution(object):
    def secondGreaterElement(self, nums):
        result, stk1, stk2 = [-1]*len(nums), [], []
        for i, x in enumerate(nums):
            while stk2 and nums[stk2[-1]] < x:
                result[stk2.pop()] = x
            tmp = []
            while stk1 and nums[stk1[-1]] < x:
                tmp.append(stk1.pop())
            stk1.append(i)
            for x in reversed(tmp):
                stk2.append(x)
        return result",O(n)
"from math import factorial as fact

a = input()
b = input()

aplus = a.count('+')
aminus = len(a) - aplus

bplus = b.count('+')
bminus = b.count('-')
bjolly = len(b) - bplus - bminus

if bplus > aplus or bminus > aminus:
    print(0)
else:
    c = aplus-bplus
    res = fact(bjolly) / fact(bjolly-c) / fact(c) / 2**bjolly
    print(res)
",np
"class SegmentTree:
    def __init__(self, N, A):
        self.n = N
        while (self.n & (self.n - 1)) != 0:
            self.n += 1
        self.build(N, A)

    def build(self, N, A):
        self.tree = [float('-inf')] * (2 * self.n)
        for i in range(N):
            self.tree[self.n + i] = A[i]
        for i in range(self.n - 1, 0, -1):
            self.tree[i] = max(self.tree[i << 1], self.tree[i << 1 | 1])

    def query(self, l, r):
        res = float('-inf')
        l += self.n
        r += self.n + 1
        while l < r:
            if l & 1:
                res = max(res, self.tree[l])
                l += 1
            if r & 1:
                r -= 1
                res = max(res, self.tree[r])
            l >>= 1
            r >>= 1
        return res

class Solution:
    def maxSlidingWindow(self, nums, k):
        n = len(nums)
        segTree = SegmentTree(n, nums)
        output = []
        for i in range(n - k + 1):
            output.append(segTree.query(i, i + k - 1))
        return output
",O(nlogn)
"n=int(input())
s=input()
l=[]
total=0
p=0
for i in range(0,450):
    sum1=0
    flag=1
    r=0
    for k in range(n):
        sum1=sum1+int(s[k])
        if(sum1>i):
            flag=0
        if(sum1==i):
            sum1=0
            r=r+1
    if(r>=2 and sum1==0 and flag==1):
        print(""YES"")
        p=1
        break
if(p==0):
    print(""NO"")",O(n ^ 2)
"import itertools

n, l, r, x = map(int, input().split())
C = list(map(int, input().split()))

ans = 0
for i in range(2, n+1):
  for c in itertools.combinations(C, i):
    d = sum(c)
    if d < l or d > r:
      continue
    if max(c) - min(c) < x:
      continue
    ans += 1

print(ans)",np
"class Solution(object):
    def lengthOfLastWord(self, s):
        length = 0
        for i in reversed(s):
            if i == ' ':
                if length:
                    break
            else:
                length += 1
        return length",O(n)
"class Solution(object):
    def isConvex(self, points):
        def det(A):
            return A[0][0]*A[1][1] - A[0][1]*A[1][0]

        n, prev, curr = len(points), 0, None
        for i in range(len(points)):
            A = [[points[(i+j) % n][0] - points[i][0], points[(i+j) % n][1] - points[i][1]] for j in (1, 2)]
            curr = det(A)
            if curr:
                if curr * prev < 0:
                    return False
                prev = curr
        return True",O(n)
"n,d,k = [int(x) for x in input().strip().split(' ')]
l = []
i = 1
if n<=d:
	print(""NO"")
elif k==1:
	if n>2:
		print(""NO"")
	elif n==2:
		print(""YES"")
		print(1,2)
else:
	n+=1
	flag = False
	while i<min(d+1,n):
		l.append(str(i)+"" ""+str(i+1))
		i+=1
	i+=1
	cnt1=0
	cnt2=1
	se=[[2,d+1,1]]
	while cnt1<cnt2:
		start = se[cnt1][0]
		end = se[cnt1][1]
		mode = se[cnt1][2]

		kk = 3
		while (i<n) and (kk<=k):
			if i<n and not flag:
				j = start

				while i<n and j<end:
					if mode==1:
						c = min(j-start+1,end-j)
					else:
						c = min(end-j,d-end+j)
					if c>1:
						se.append([i,i+c-1,2])
						cnt2+=1
					ki=j
					while i<n and c>0:
						l.append(str(ki)+"" ""+str(i))

						c-=1
						ki=i
						i+=1
					j+=1

			else:
				flag = True
				break
			kk+=1
		cnt1+=1
	if i<n or flag:

		print(""NO"")
	else:
		print(""YES"")
		print('\n'.join(l))",O(n ^ 2)
"class Solution2(object):
    def getImportance(self, employees, id):
        result, q = 0, collections.deque([id])
        while q:
            curr = q.popleft()
            employee = employees[curr-1]
            result += employee.importance
            for id in employee.subordinates:
                q.append(id)
        return result",O(n)
"def flipH(A,N):
    B=[[0 for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            B[i][j]=A[i][N-j-1]
    return B

def flipV(A,N):
    B=[[0 for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            B[i][j]=A[N-i-1][j]
    return B

def rotate90(A):
    ans = zip(*A[::-1])
    ans=list(map(list,ans))
    return ans

def check(A,B,N):
    for i in range(N):
        for j in range(N):
            if A[i][j]!=B[i][j]:
                return False
    return True

N=int(input())
A=[]
X=[]
for i in range(N):
    A.append(list(input()))
for i in range(N):
    X.append(list(input()))
B=flipH(A,N)
C=flipV(A,N)
flag=False
for i in range(4):
    if check(A,X,N) or check(B,X,N) or check(C,X,N):
        flag=True
        break
    else:
        A=rotate90(A)
        B=rotate90(B)
        C=rotate90(C)
if flag:
    print(""Yes"")
else:
    print(""No"")",O(n ^ 2)
"
import pandas as pd



def Solution(players: pd.DataFrame) -> List[int]:
    return list(players.shape)
",O(1)
"MAXN = 200001

def less_sum(s, m):
    n = len(s)
    a = 0
    b = 0
    res = 0
    last = 0

    count = [0 for i in range(-MAXN, MAXN+1)]

    count[0] = 1
    x = 0
    last = 1

    for i in range(n):
        if s[i] > m:
            b += 1
        else:
            a += 1
        x = a-b

        if s[i] > m:
            last -= count[x+1]
        else:
            last += count[x]

        res += last
        count[x] += 1
        last += 1

    return res

n, m = map(int, input().split(' '))
s = list(map(int, input().split(' ')))[0:n]

print(less_sum(s, m) - less_sum(s, m-1))",O(nlogn)
"class Solution:
    def checkValidString(self, s: str) -> bool:
        n = len(s)
        dp = [[False] * (n + 1) for _ in range(n + 1)]
        dp[n][0] = True

        for i in range(n - 1, -1, -1):
            for open in range(n):
                res = False
                if s[i] == '*':
                    res |= dp[i + 1][open + 1]
                    if open > 0:
                        res |= dp[i + 1][open - 1]
                    res |= dp[i + 1][open]
                else:
                    if s[i] == '(':
                        res |= dp[i + 1][open + 1]
                    elif open > 0:
                        res |= dp[i + 1][open - 1]
                dp[i][open] = res

        return dp[0][0]
",O(n ^ 2)
"q=int(input())

for e in range(q):
    x,y,k=map(int,input().split())
    x,y=abs(x),abs(y)
    x,y=max(x,y),min(x,y)

    if(x%2!=k%2):
        k-=1
        y-=1

    if(x>k):
        print(-1)
        continue
    if((x-y)%2):
        k-=1
        x-=1
    print(k)
",O(1)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()

        def dfs(i, prev):
            if i == len(intervals):
                return 0
            res = dfs(i + 1, prev)
            if prev == -1 or intervals[prev][1] <= intervals[i][0]:
                res = max(res, 1 + dfs(i + 1, i))
            return res

        return len(intervals) - dfs(0, -1)
",O(2 ^ n)
"import sys
input = sys.stdin.readline

n = int(input())
a = sorted(list(set(map(int, input().split()))))
n = len(a)
used = [0] * n
cnt = 0
for i in range(n):
    if not used[i]:
        used[i] = 1
        cnt += 1
        for j in range(i + 1, n):
            if a[j] % a[i] == 0:
                used[j] = 1
print(cnt)
",O(n ^ 2)
"from itertools import combinations

[n,l,r,x] = [int(x) for x in input().split()]
c = [int(x) for x in input().split()]
c.sort()
k = 0

from itertools import combinations

for i in range(n) :
	for j in range(i+1,n) :
		if ( c[j] - c[i] ) >= x :
			if sum(c[i:j+1]) < l :
				continue
			elif  (c[i] + c[j]) > r :
				continue
			else :
				if (c[i] + c[j]) >= l and (c[i] + c[j]) <= r :
					k += 1
				for p in range(1,j-i) :
					for m in combinations(c[i+1:j],p) :
						if (sum(m)+c[i] +c[j]) >= l and (sum(m)+c[i] +c[j]) <= r :
							k+=1

print(k)
",np
"n,k = list(map(int,input().split()))
start = k-1
end = 1

def bsearch(start,end):
    if start<end:
        return start
    else:
        mid = start-(start-end)//2
        val = ((k-1)*k//2) - ((mid-1)*mid//2) +1
        if val==n:
            return mid
        elif val>n:
            end = mid+1
        else:
            start = mid-1
        return bsearch(start,end)

ans = bsearch(start,end)

if ans == 0:
    print(-1)
elif n==1:
    print(0)
else:
    print(k-ans)
",O(logn)
"class Solution(object):
    def pushDominoes(self, dominoes):
        force = [0]*len(dominoes)

        f = 0
        for i in range(len(dominoes)):
            if dominoes[i] == 'R':
                f = len(dominoes)
            elif dominoes[i] == 'L':
                f = 0
            else:
                f = max(f-1, 0)
            force[i] += f

        f = 0
        for i in reversed(range(len(dominoes))):
            if dominoes[i] == 'L':
                f = len(dominoes)
            elif dominoes[i] == 'R':
                f = 0
            else:
                f = max(f-1, 0)
            force[i] -= f

        return """".join('.' if f == 0 else 'R' if f > 0 else 'L'
                       for f in force)",O(n)
"from __future__ import division
from sys import stdin, stdout
from collections import Counter

def write(x):
    stdout.write(str(x) + ""\n"")

n, c = map(int, stdin.readline().split())
a = map(int, stdin.readline().split())
assert len(a) == n

tel = Counter()
target_count_last = Counter()
targets = 0
best = 0

for num in a:
    if num == c:
        targets += 1
    else:
        since_last = targets - target_count_last[num]
        target_count_last[num] = targets
        tel[num] = max(0, tel[num] - since_last)
        tel[num] += 1
        best = max(best, tel[num])

write(targets + best)
",O(n)
"import collections


class Solution(object):
    def numIdenticalPairs(self, nums):
        return sum(c*(c-1)//2 for c in collections.Counter(nums).values())",O(n)
"import sys

n, m = [int(w) for w in input().split()]
x = [int(w) for w in input().split()]
t = [int(w) for w in input().split()]

if m == 1:
    print(n)
    sys.exit(0)

p = []
tx = []
for i in range(n+m):
    (tx if t[i] == 1 else p).append(x[i])

a = [0] * m
i = 0
for pi in p:
    while i < m-1 and pi > (tx[i]+tx[i+1])/2:
        i += 1
    a[i] += 1

print("" "".join(str(ai) for ai in a))
",O(nlogn)
"import math
a=input()
b=input()
c=int(0)
d=int(0)
q=int(0)
for i in range(len(a)):
    if a[i]==""+"":
        c+=1
    elif a[i]==""-"":
        c-=1
for i in range(len(b)):
    if b[i]==""+"":
        d+=1
    elif b[i]==""-"":
        d-=1
    else:
        q+=1
if c == d:
    print((math.factorial(q)/(math.factorial(q/2)*math.factorial(q/2)))/(2**q))
else:
    mx=d+q
    mn=d-q
    if c>mx or c<mn:
        print(0.0)
    else:
        ans=c-d
        if ans > 0:
            print((math.factorial(q)/(math.factorial(((q-ans)/2)+ans)*math.factorial((q-ans)/2)))/(2**q))
        else:
            print((math.factorial(q)/(math.factorial((q-ans)/2)*math.factorial(((q-ans)/2)+ans)))/(2**q))",np
"import collections
import heapq


class Solution(object):
    def scheduleCourse(self, courses):
        courses.sort(key=lambda t_end: t_end[1])
        max_heap = []
        now = 0
        for t, end in courses:
            now += t
            heapq.heappush(max_heap, -t)
            if now > end:
                now += heapq.heappop(max_heap)
        return len(max_heap)",O(nlogn)
"s = input()
sLen, ans = len(s), 0

for i in range(sLen):
    for till1 in range(i + 1, sLen + 1):
        till2 = till1 + 1
        for j in range(i + 1, sLen):
            if till2 > sLen:
                break
            sub1 = s[i:till1]
            sub2 = s[j:till2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            till2 += 1

print(ans)",O(n ^ 3)
"class Solution(object):
    def largestPerimeter(self, nums):
        nums.sort()
        prefix = sum(nums)
        for i in reversed(range(2, len(nums))):
            prefix -= nums[i]
            if prefix > nums[i]:
                return prefix+nums[i]
        return -1",O(nlogn)
"n,s=list(map(int,input().split()))
if n-sum([int(x) for x in str(n)])<s:
    print(0)
else:
    def check(n):

        return (n-sum([int(x) for x in str(n)]))>=s
    start=1
    end=n
    mid=(start+end)//2
    while mid !=end and mid!=start:

        if check(mid):
            end=mid
            mid=(start+end)//2
        else:
            start=mid
            mid = (start + end) // 2

    print(n-end+1)
",O(logn)
"n, a, b, c, t = map(int, input().split())
l = list(map(int, input().split()))
f = [0] * 1001
for i in l: f[i] -= -1
tmp = 0
tmp2 = 0
for i in range(1, t):
    tmp += (t - i) * f[i]
tmp = n * a + tmp * c - tmp * b
print(max(n * a, tmp))",O(n)
"import sys, collections

n, k = map(int, sys.stdin.readline().split())
left = 0
right = n + 1
while left < right:
    mid = (left + right) // 2
    candy = n - mid
    total = (candy * (candy + 1)) // 2 - mid
    if total < k:
        right = mid
    elif total > k:
        left = mid + 1
    else:
        print(mid)
        break",O(logn)
"class Solution2(object):
    def reinitializePermutation(self, n):
        if n == 2:
            return 1
        result, i = 0, 1
        while not result or i != 1:
            i = (i*2)%(n-1)
            result += 1
        return result",O(n)
"from math import ceil
def test(f):
    for i in range(n):
        if (r1+ f) > f * lift[i]:
            return 0
        f -= (r1 + f) / lift[i]
        if (r1+ f) > f * land[i + 1]:
            return 0
        f -= (r1 + f) / land[i + 1]
    return 1
p=int(input())
total_wgt=int(input());r1=total_wgt
lift=list(map(int,input().split()))
land=list(map(int,input().split()));n=len(land);ans=1e20
lift+=[lift[0]];land+=[land[0]]
l=0.0;r=1e20
for i in range(1000):
  mid=(l+r)/2.0

  if test(mid):r=mid
  else:l=mid
if r<1e19:
    print('%.17f' %r)
else:
    print(-1)
",O(n)
"k = int(input())
s = k
i = 1
number_digits = 1
while s - (i * (9 * 10 ** (i - 1))) > 0:
    number_digits = number_digits + 1
    s = s - (i * (9 * 10 ** (i - 1)))
    i += 1
v = (s - 1) // number_digits
s = s - v * number_digits
ans = 10 ** (number_digits - 1) + v
ans = str(ans)
fans = ans[s - 1]
print(fans)
",O(logn)
"yellow, blue = map(int, input().split())
y, g, b = map(int, input().split())

count = 0

yt = y * 2 + g
bt = g + b * 3

yc = yellow - yt
if yc < 0:
    count += abs(yc)

bc = blue - bt
if bc < 0:
    count += abs(bc)

print(count)
",O(1)
"xa, ya = map(int, input().split())
xb, yb = map(int, input().split())
xc, yc = map(int, input().split())
if (xb, yb) < (xa, ya):
    xa, ya, xb, yb = xb, yb, xa, ya
if (xc, yc) < (xa, ya):
    xa, ya, xc, yc = xc, yc, xa, ya
if xb > xc:
    xb, yb, xc, yc = xc, yc, xb, yb
d = 1 if ya <= yc else -1
if ya <= yb <= yc or ya >= yb >= yc:
    print(xc - xa + abs(yc - ya) + 1)
    for x in range(xa, xb):
        print(x, ya)
    for y in range(ya, yc, d):
        print(xb, y)
    for x in range(xb, xc + 1):
        print(x, yc)
elif yb < min(ya, yc):
    print(xc - xa + max(ya, yc) - yb + 1)
    for x in range(xa, xc + 1):
        print(x, min(ya, yc))
    for y in range(yb, min(ya, yc)):
        print(xb, y)
    if ya < yc:
        for y in range(ya + 1, yc + 1):
            print(xc, y)
    else:
        for y in range(yc + 1, ya + 1):
            print(xa, y)
else:
    print(xc - xa + yb - min(ya, yc) + 1)
    for x in range(xa, xc + 1):
        print(x, max(ya, yc))
    for y in range(max(ya, yc) + 1, yb + 1):
        print(xb, y)
    if ya < yc:
        for y in range(ya, yc):
            print(xa, y)
    else:
        for y in range(yc, ya):
            print(xc, y)
",O(1)
"from math import gcd
import sys
input=sys.stdin.readline
from collections import defaultdict as dd
m=int(input())
d=dd(int)
l=[]
for i in range(m):
    s=input().split()[0]
    a=0
    b=0
    c=0
    n=len(s)
    ind=0
    for i in range(1,n):
        if(s[i]=='+'):
            ind=i+1
            break
        a=a*10+int(s[i])
    for i in range(ind,n):
        if(s[i]==')'):
            ind1=i+2
            break
        b=b*10+int(s[i])
    for i in range(ind1,n):
        c=c*10+int(s[i])
    a=a+b
    g=gcd(a,c)
    a=a//g
    c=c//g
    d[(a,c)]+=1
    l.append((a,c))
for i in l:
    print(d[i],end="" "")
",O(n)
"import re
input()
print(sum(len(f)-2 for f in re.findall('x{3,}',input())))",O(n)
"r,g,b = map(int,input().split())
R = list(map(int,input().split()))
G = list(map(int,input().split()))
B = list(map(int,input().split()))
R.sort()
G.sort()
B.sort()
dp = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
def solve(r,g,b):
	if ((r==0 and g==0) or (g==0 and b==0) or (b==0 and r==0)):
		return 0
	if dp[r][g][b]==-1:
		if r==0:
			ans =  G[g-1]*B[b-1]+solve(r,g-1,b-1)
		elif g==0:
			ans =  R[r-1]*B[b-1]+solve(r-1,g,b-1)
		elif b==0:
			ans =  G[g-1]*R[r-1]+solve(r-1,g-1,b)
		else:
			ans =  max(G[g-1]*B[b-1]+solve(r,g-1,b-1),G[g-1]*R[r-1]+solve(r-1,g-1,b),R[r-1]*B[b-1]+solve(r-1,g,b-1))
		dp[r][g][b] = ans
	return dp[r][g][b]
ans = solve(r,g,b)
print(ans)",O(n ^ 3)
"n,kk=map(int,input().split())
s=input()
if(s==s[::-1] or s!=s[::-1]):
    k=""""
    l=0
    for i in reversed(range(1,n)):
        k=s[i]+k

        if(s.startswith(k)):
            l=len(k)
    ss=s[l:]
    fs=s+(ss*(kk-1))
    print(fs)
",O(n ^ 2)
"import sys

def ask(x):
    print('? %d'%x)
    sys.stdout.flush()
    x=int(input())
    return x

n=int(input())
t=n//2
if t&1:
    print('! -1')
    sys.stdout.flush()
    sys.exit()
l=1
r=n
while l<r:
    mid=(l+r)>>1
    if ask(mid)>=ask((mid+t-1)%n+1):
        r=mid
    else:
        l=mid+1
print('! %d'%l)
sys.stdout.flush()
",O(logn)
"pw = [1, 4]
for i in range(2, 32):
    pw.append(pw[i - 1] * 4)
t = int(input())
for cas in range(t):
    n, k = map(int, input().split())
    last = 1
    path = 1
    ans = n
    i = 0
    while True:
        if((pw[i + 1] - 1) // 3 > k):
            ans -= i
            last = k - (pw[i] - 1) // 3
            break
        i = i + 1
        path *= 2
    sp = path * 2 - 1
    if((ans < 0) or ((ans == 0) and (last > 0))):
        print(""No"")
        continue
    sq = path * path - sp
    if (ans == 1) and (last > sq) and (last < sp):
        print(""No"")
        continue
    elif (ans == 1) and (last >= sp):
        ans = ans - 1
    print(""Yes"", ans)
",O(1)
"import math
k = int(input())

flag = True
i = 0
value=0

if(k <= 9):
    print(k)

else:
    while(flag):
        a = 9 * pow(10, i) * (i+1)
        if(k >= a):
            k -= a
            value+=9 * pow(10, i)
            i+=1
        else:
            n=int(math.ceil(k/(i+1)))
            value+=n
            index=k%(i+1)-1
            print(str(value)[index])
            flag=False
",O(logn)
"

class Solution(object):
    def repeatedCharacter(self, s):
        lookup = set()
        for c in s:
            if c in lookup:
                break
            lookup.add(c)
        return c
",O(n)
"class Solution(object):
    def getLastMoment(self, n, left, right):
        return max(max(left or [0]), n-min(right or [n]))",O(n)
"n, m = map(int, input().split())
buf = []
for i in range(n//2):
    for j in range(m):
        buf.append(f'{i + 1} {j + 1}\n')
        buf.append(f'{n - i} {m - j}\n')

if n % 2 == 1:
    for j in range(m // 2):
        buf.append(f'{n // 2 + 1} {j + 1}\n')
        buf.append(f'{n // 2 + 1} {m - j}\n')
    if m % 2 == 1:
        buf.append(f'{n//2 + 1} {m//2 + 1}\n')
print(*buf, sep='')",O(n ^ 2)
"class Solution2(object):
    def findSecretWord(self, wordlist, master):
        def solve(H, possible):
            min_max_group, best_guess = possible, None
            for guess in possible:
                groups = [[] for _ in range(7)]
                for j in possible:
                    if j != guess:
                        groups[H[guess][j]].append(j)
                max_group = max(groups, key=len)
                if len(max_group) < len(min_max_group):
                    min_max_group, best_guess = max_group, guess
            return best_guess

        H = [[sum(a == b for a, b in zip(wordlist[i], wordlist[j]))
                  for j in range(len(wordlist))]
                  for i in range(len(wordlist))]
        possible = list(range(len(wordlist)))
        n = 0
        while n < 6:
            guess = solve(H, possible)
            n = master.guess(wordlist[guess])
            possible = [j for j in possible if H[guess][j] == n]",O(n ^ 2)
"import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def minMalwareSpread(self, graph, initial):
        initial_set = set(initial)
        clean = [i for i in range(len(graph)) if i not in initial_set]
        union_find = UnionFind(len(graph))
        for i in range(len(clean)):
            for j in range(i+1, len(clean)):
                if graph[clean[i]][clean[j]] == 1:
                    union_find.union_set(clean[i], clean[j])
        union_size = collections.Counter(union_find.find_set(i) for i in range(len(graph)))
        
        shared_union = collections.defaultdict(set)
        for i in initial:
            for j in clean:                  
                if graph[i][j] == 1:
                    x = union_find.find_set(j)
                    shared_union[x].add(i)

        result, total = float(""inf""), float(""-inf"")
        for i in initial:
            lookup = set()
            curr = 0
            for j in clean:                  
                if graph[i][j] == 1:
                    x = union_find.find_set(j)
                    if len(shared_union[x]) == 1 and \
                       x not in lookup:
                        curr += union_size[x]
                        lookup.add(x)
            if curr > total or \
               (curr == total and i < result):
                total = curr
                result = i
        return result",O(n ^ 2)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def rotateRight(self, head, k):
        if not head or not head.__next__:
            return head

        n, cur = 1, head
        while cur.__next__:
            cur = cur.__next__
            n += 1
        cur.next = head

        cur, tail = head, cur
        for _ in range(n - k % n):
            tail = cur
            cur = cur.__next__
        tail.next = None

        return cur",O(n)
"n,k=map(int,input().split())
a=list(map(int,input().split()))
a.sort()
slow,fast=0,0
while fast<n:
    if a[slow]==a[fast]:
        fast+=1
    elif abs(a[slow]-a[fast])<=k:
        a[slow]=0
        slow+=1
    else:
        slow+=1
ans=0
for i in a:
    if i!=0:
        ans+=1
print(ans)",O(nlogn)
"from sys import  stdin
input=stdin.readline
from  collections import defaultdict
def num(s):
    l,r=0,0
    for i in s:
        if l==0 and i=="")"":
            r+=1
        elif i==""("":
            l+=1
        elif l and i=="")"":
            l-=1
    return (l,r)

def f(mp,cnt):
    ans=0

    for l in cnt:

        if l.count(0)<1:
            continue
        if l!=(0,0) and l==l[::-1]:
            continue

        t=mp[l[::-1]]
        t2=mp[l[::-1]]
        ans+=t
        if t and l!=l[::-1]:
            mp[l]-=1
    return ans

cnt=[]
mp=defaultdict(int)
for i in range(int(input())):
    s=input()
    l=num(s)

    cnt.append(l)
    mp[l]+=1
print(f(mp,cnt))",O(n)
"s = input()
res = 0
for i in range(len(s)):
    for j in range(i,len(s)):
        for f in range(i+1,len(s)):
            if len(s) >= f + j-i:
                if (s[i:j]== s[f:f+j-i]):
                    res = max(res,j - i)

print(res)",O(n ^ 3)
"n = int(input())
l = list(map(int, input().split()))
odd = 0
for i in range(n):
    for j in range(i, n):
        if(l[i]>l[j]): odd ^= 1

m = int(input())
ans = []
for i in range(m):
    ll, r = map(int, input().split())
    k = r-ll+1
    if( (k*(k-1)/2) %2): odd ^= 1
    ans.append( ""odd"" if odd else ""even"")

print('\n'.join(ans))",O(n ^ 2)
"n,a,b=map(int,input().split())
if a>n:
    print('NO')
    exit()
if b>n:
    print(""NO"")
    exit()
if a==1  and b==1:
    if n==2 or n==3:
        print('NO')
        exit()
if n==1 and a>1 or n==1 and b>1:
    print('NO')
    exit()
if min(a,b)>1:
    print('NO')
    exit()

def check(mat):
    vis=[0]*n
    cnt=0
    for i in range(n):
        if vis[i]==0:
            q=[i]
            cnt+=1
            vis[i]=1
            while q:
                t=q.pop(0)
                for j in range(n):
                    if mat[t][j]==1 and vis[j]==0:
                        vis[j]=1
                        q.append(j)
        return cnt
mat=[[0 for i in range(n)] for j in range(n)]
m=max(a,b)
j=1
for i in range(n):
    if j<n:
        mat[i][j]=1
        mat[j][i]=1
    j+=1
for i in range(m-1):
    curr=n-i-1
    for j in range(n):
        if mat[curr][j]==1:
            mat[curr][j]=0
            mat[j][curr]=0
if b==1:
    print('YES')
    for i in range(n):
        print(*mat[i],sep='')

else:
    print('YES')
    for i in range(n):
        for j in range(n):
            mat[i][j]=1-mat[i][j]
    for i in range(n):
        mat[i][i]=0
    for i in range(n):
        print(*mat[i],sep='')",O(n ^ 2)
"n, m, k, l = map(int, input().split())
cnt = (k + l + m - 1) // m
if cnt * m > n:
    print(-1)
else:
    print(cnt)",O(1)
"n,m = map(int,input().split())

print(n*""8"")
print((n-1)*""1""+""2"")",O(1)
"ceil1 = lambda a, b: (a + b - 1) // b
n = int(input())
sq = int(n ** .5)
sq2, ans, cur = ceil1(n, sq), [], 0

for i in range(sq2 - 1):
    cur += sq
    ans.extend([x for x in range(cur, cur - sq, -1)])

ans.extend([x for x in range(n, cur, -1)])
print(' '.join(map(str, ans)))
",O(n)
"def rotate(L):
    L1 = ['' for i in range(n)]
    for i in range(n):
        for j in range(n):
            L1[n - j - 1] += L[i][j]
    return L1

def flip_v(L):
    L1 = []
    for i in range(n):
        L1.append(L[i][::-1])
    return L1

def flip_h(L):
    L1 = []
    for i in range(n):
        L1.append(L[n - i - 1])
    return L1

n = int(input())
L = []
M = []
for i in range(n):
    L.append(input())
for i in range(n):
    M.append(input())
L1 = rotate(L)
L2 = rotate(L1)
L3 = rotate(L2)
L4 = flip_v(L)
L5 = flip_h(L)
L6 = rotate(L4)
L7 = rotate(L6)
L8 = rotate(L7)
L9 = rotate(L5)
L10 = rotate(L9)
L11 = rotate(L10)
if L == M or L1 == M or L2 == M or L3 == M or L4 == M or L5 == M or L6 == M or L7 == M or L8 == M or L9 == M or L10 == M or L11 == M:
    print('Yes')
else:
    print('No')",O(n ^ 2)
"def reach_max(n, k):
    return n * k + 1 - n * (n + 1) // 2

n, k = map(int, input().split())

if n == 1:
    print(0)
    exit()

lo, hi = 1, k - 1

if n > reach_max(hi, k):
    print(-1)
    exit()

while lo < hi:
    mid = (lo + hi) // 2
    if reach_max(mid, k) < n:
        lo = mid + 1
    else:
        hi = mid

print(lo)",O(logn)
"def binarySearch (N,l,r,x):
    if r >= l:
        mid = l + (r - l)//2
        Temp = (mid*(mid+1))//2
        if Temp-x == N-mid:
            return N-mid
        elif Temp-x > N-mid:
            return binarySearch(N,l, mid-1, x)
        else:
            return binarySearch(N,mid + 1, r, x)
    else:
        return -1
n,k=list(map(int,input().split()))
print(binarySearch (n,0,n,k))",O(logn)
"import sys

try:

    def check(n):
        count1=0
        s=""""
        while(n!=0):
            if n%2:
                count1+=1
                s=""1""+s
            else:
                s=""0""+s
            n//=2
        return s

    def solve(flag,n,l):
        temp_ans=0
        for i in range(n):
            y=(z[flag]^int(l[i],2) )
            b=bin(y)
            temp_ans+=b.count(""1"")
            flag=not(flag)

        return temp_ans

    n=int(input())
    l1 = [input() for y in range(n)]
    temp=input()
    l2 = [input() for y in range(n)]
    temp=input()
    l3 = [input() for y in range(n)]
    temp=input()
    l4 = [input() for y in range(n)]

    z=[]
    s=0
    for i in range(n):
       if i%2==1:
           s+=(2**i)
    z.append(s)
    z.append( z[0] ^ (2**n-1) )
    ans=m=sys.maxsize
    for i in range(2,17):
        s=check(i)
        if s.count(""1"")==2:
            s=(4-len(s))*""0""+s
            res=sys.maxsize
            for i in range(4):
                if i==0:
                    x=l1
                elif i==1:
                    x=l2
                elif i==2:
                    x=l3
                else:
                    x=l4

                if s[i]==""1"":
                    res+=min(res,solve(1,n,x))
                else:
                    res+=min(res,solve(0,n,x))
            ans=min(ans,res-m)
    print(ans)

except EOFError:
    pass",O(n ^ 2)
"class Solution(object):
    def numberOfAlternatingGroups(self, colors):
        k = 3
        result = curr = left = 0
        for right in range(len(colors)+k-1):  
            if right-left+1 == k:
                result += int(curr == k-1)
                curr -= int(colors[left] != colors[(left+1)%len(colors)])
                left += 1
            curr += int(colors[right%len(colors)] != colors[(right+1)%len(colors)])
        return result",O(n)
"class Solution:
    def climbStairs(self, n: int) -> int:
        cache = [-1] * n
        def dfs(i):
            if i >= n:
                return i == n
            if cache[i] != -1:
                return cache[i]
            cache[i] = dfs(i + 1) + dfs(i + 2)
            return cache[i]

        return dfs(0)
",O(n)
"n=int(raw_input())

ans=[]
p=1
fin=n
while len(ans)<n-1:
	for i in range(fin-(n/(2**p))):
		ans.append(2**(p-1))
		fin-=1
	p+=1

if 2**(p-2) + 2**(p-1) <=n:
	ans.append(2**(p-1) + 2**(p-2))
else:
	ans.append(2**(p-1))

s="" "".join(str(x) for x in ans)

print(s)
",O(nlogn)
"import bisect
xzy=[10,190,2890,38890,488890,5888890,68888890,788888890,8888888890,98888888890,1088888888890,11888888888890]
k=int(input())
digits=bisect.bisect_left(xzy,k)
if k==10:
    print(1)
elif k>10:
    apu=k-xzy[digits-1]
    modulo=apu%(digits+1)
    dlj=apu//(digits+1)
    output=10**(digits)+dlj
    list1=[i for i in str(output)]
    print(list1[modulo])
else:
    print(k)
",O(logn)
"n,A,B,C,T=map(int,input().split())
t=list(map(int,input().split()))
if(B>C):
    print(n*A)
else:
    c=0
    t.sort()
    for i in t:
        c+=(T-i)*(C-B)+A
    print(c)",O(n)
"from sys import stdin
n=int(stdin.readline().strip())
s=list(map(int,stdin.readline().strip().split()))
s.sort()
f=False
z=s.count(0)
p=0
for i in range(2,n):
    if s[i]==s[i-1] and s[i-1]==s[i-2]:
        f=True
for i in range(1,n):
    if s[i]==s[i-1]:
        p+=1
        if i-2>=0 and s[i-2]==s[i-1]-1:
            f=True
y=sum(s)
t=(n)*(n-1)//2
r=y-t
if r%2==0 or f or y==0 or z>=2 or p>=2:
    print(""cslnb"")
else:
    print(""sjfnb"")
",O(nlogn)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()

        def dfs(i, prev):
            if i == len(intervals):
                return 0
            res = dfs(i + 1, prev)
            if prev == -1 or intervals[prev][1] <= intervals[i][0]:
                res = max(res, 1 + dfs(i + 1, i))
            return res

        return len(intervals) - dfs(0, -1)
",O(2 ^ n)
"import os
import sys
from io import BytesIO, IOBase
import heapq as h
from bisect import bisect_left, bisect_right
import time

from types import GeneratorType
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd, deque as dq, Counter as dc
import string
from math import sqrt

def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())

def getMat(n):
    return [getInts() for _ in range(n)]

def isInt(s):
    return '0' <= s[0] <= '9'

MOD = 10**9 + 7

def t_from_s_a_u(s,a,u):
    return (-2*u + sqrt(4*u*u + 8*s*a))/(2*a)

def solve():
    A, V = getInts()
    L, D, W = getInts()
    if V <= W or W**2 >= 2*A*D:

        if V**2 >= 2*A*L:
            return sqrt(2*L/A)
        else:
            dist_1 = (V**2)/(2*A)
            T1 = 2*dist_1/V
            dist_2 = L - dist_1
            T2 = dist_2/V
            return T1+T2
    else:

        dist_1 = (W**2)/(2*A)
        T1 = sqrt(2*dist_1/A)
        rem_dist = D - dist_1
        dist_A = (V**2 - W**2)/(2*A)
        if 2*dist_A >= rem_dist:

            TA = 2*t_from_s_a_u(rem_dist/2,A,W)
        else:
            TA1 = 2*(V-W)/A
            SA1 = (V+W)*(V-W)/A
            SA2 = rem_dist - SA1
            TA2 = SA2/V
            TA = TA1 + TA2
        T1 += TA

        if V**2 - W**2 >= 2*A*(L-D):

            return T1 + t_from_s_a_u(L-D,A,W)
        else:
            dist_2 = (V**2 - W**2)/(2*A)
            T2 = 2*dist_2/(V+W)
            dist_3 = L - D - dist_2
            T3 = dist_3/V

            return T1+T2+T3
    return

print(solve())
",O(1)
"class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        n = len(height)
        res = 0

        for i in range(n):
            leftMax = rightMax = height[i]

            for j in range(i):
                leftMax = max(leftMax, height[j])
            for j in range(i + 1, n):
                rightMax = max(rightMax, height[j])

            res += min(leftMax, rightMax) - height[i]
        return res
",O(n ^ 2)
"class Solution2_Recu(object):
    def minTime(self, n, edges, hasApple):
        def dfs(graph, par, node, has_subtree):
            result, extra = 0, int(hasApple[node])
            for nei in graph[node]:
                if nei == par:
                    continue
                count = dfs(graph, node, nei, hasApple)
                result += count
                extra |= bool(count)
            return result+extra
        
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        return 2*max(dfs(graph, -1, 0, hasApple)-1, 0)",O(n)
"l,r = map(int,input().split())

a = ""{0:062b}"".format(l)
b = ""{0:062b}"".format(r)

n = len(a)
i = 0

if (l == r):
    print(0)
else:
    while (i<n and a[i] == b[i]):
        i += 1
    print(2**(62-i) - 1)",O(logn)
"from copy import copy

a = list(map(int, input().split()))

ans = 0
for i in range(14):
    b = copy(a)
    b[i] = 0

    for j in range(1, 14 + 1):
        b[(i + j) % 14] += (a[i] - 1) // 14 + ((a[i] - 1) % 14 + 1 > j - 1)

    ans = max(ans, sum(el * (el % 2 == 0) for el in b))

print(ans)
",O(1)
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
left = 0
right = 10**9+1
ans = (0, 0)
while left < right:
    mid = (left + right) // 2
    masks = {}
    for i in range(n):
        mask = 0
        for j in a[i]:
            mask <<= 1
            if j >= mid:
                mask += 1
        masks[mask] = i
    ok = False
    for m1 in masks:
        for m2 in masks:
            if m1 | m2 == ((1 << m) - 1):
                ok = True
                ans = (masks[m1]+1, masks[m2]+1)
                break
        if ok:
            break
    if ok:
        left = mid+1
    else:
        right = mid
print(ans[0], ans[1])
",np
"class Solution(object):
    def sumGame(self, num):
        cnt = total = 0
        for i in range(len(num)):
            if num[i] == '?':
                cnt += (-1 if i < len(num)//2 else 1)
            else:
                total += (int(num[i]) if i < len(num)//2 else -int(num[i]))
        return True if cnt%2 else total != cnt//2*9",O(n)
"tmp = input().split()
n = int(tmp[0])
m = int(tmp[1])

a = list()
b = list()
diff = list()
for i in range(n):
    tmp = input().split()
    a.append(int(tmp[0]))
    b.append(int(tmp[1]))
    diff.append(a[i] - b[i])

diff.sort(reverse=True)

sum_a = sum(a)
i = 0
while sum_a > m and i < n:
    sum_a = sum_a - diff[i]
    i = i + 1

if i >= n and sum_a > m:
    print(-1)
else:
    print(i)",O(nlogn)
"def chk(n):
    return int(n**0.5+0.1)**2 == n
for _ in range(int(input())):
    n = int(input())
    if n % 2 == 0 and chk(n//2) or n % 4 == 0 and chk(n//4):
        print(""YES"")
    else:
        print(""NO"")
",O(1)
"class Solution3(object):
    def rotate(self, nums, k):
        count = 0
        start = 0
        while count < len(nums):
            curr = start
            prev = nums[curr]
            while True:
                idx = (curr + k) % len(nums)
                nums[idx], prev = prev, nums[idx]
                curr = idx
                count += 1
                if start == curr:
                    break
            start += 1",O(n)
"class Solution2(object):
    def catchMaximumAmountofPeople(self, team, dist):
        result = j = 0
        for i in range(len(team)):
            if not team[i]:
                continue
            while j < i-dist:
                j += 1
            while j <= min(i+dist, len(team)-1):
                if team[j] == 0:
                    break
                j += 1
            if j <= min(i+dist, len(team)-1):
                result += 1
                j += 1
        return result",O(n)
"class Solution(object):
    def findWinningPlayer(self, skills, k):
        result = cnt = 0
        for i in range(1, len(skills)):
            if skills[result] < skills[i]:
                result = i
                cnt = 0
            cnt += 1
            if cnt == k:
                return result
        return result",O(n)
"a=input()
b=input()

if len(b)>len(a):

    l=[int(i) for i in a]
    l.sort()
    l=l[::-1]
    temp=[str(i) for i in l]
    s=''.join(temp)
    print(s)

else:
    d={}

    for i in a:

        if i not in d:

            d[i]=1
        else:

            d[i]=d[i]+1

    def find(i):

        global flag
        if i in d and d[i]>0:

            d[i]=d[i]-1

            return(i)

        for j in range(int(i),-1,-1):

            flag=1

            j=str(j)

            if j in d and d[j]>0:

                d[j]=d[j]-1

                return(j)

    def fun(d):

        l=[]
        for i in d:

            if d[i]>0:

                l=l+[int(i)]*d[i]
        l.sort()
        l=l[::-1]
        temp=[str(i) for i in l]

        s=''.join(temp)

        return(s)

    def fun2(x):

        global new
        for i in range(x-1,-1,-1):

            temp=new[i]
            for j in range(int(temp)-1,-1,-1):

                j=str(j)

                if j in d and d[j]>0:

                    new=new[:i]+str(j)
                    d[j]=d[j]-1

                    d[temp]=d[temp]+1

                    return(new)

            d[temp]=d[temp]+1

    flag=0
    new=''
    for i in range(len(b)):

        if flag==0:

            temp=find(b[i])

            if temp==None:

                new=fun2(i)

                new=new+fun(d)

                break

            else:
                new=new+temp

        else:

            new=new+fun(d)
            break

    print(new)
",O(n ^ 3)
"import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from collections import Counter
from collections import defaultdict as dd
from collections import deque

flush = lambda: stdout.flush()
stdstr = lambda: stdin.readline()
stdint = lambda: int(stdin.readline())
stdpr = lambda x: stdout.write(str(x))
stdmap = lambda: map(int, stdstr().split())
stdarr = lambda: list(map(int, stdstr().split()))

mod = 1000000007

n,m = stdmap()
arr =  stdarr()

if(n > m):
    print(0)
else:
    c = Counter(arr)
    d1 = list(sorted(c.values()))

    days = 0
    for i in range(1, 101):
        br = False
        d = d1.copy()

        people = 0
        done = False

        while(1):
            if(people >= n):

                days = i
                done = True
                break
            else:
                if(len(d) == 0):
                    break
                curr = d[-1]//i

                d.pop()

                people += curr

        if(done):
            days = i

    print(days)",O(nlogn)
"class Solution(object):
    def rangeBitwiseAnd(self, m, n):
        while m < n:
            n &= n - 1
        return n",O(1)
"def GSB(x):
	counter=0
	while x!=0:
		counter+=1
		x=x>>1
	return counter

problems,minimum,maximum,difference=[int(x) for x in input().split()]
array=[int(x) for x in input().split()]
combinations=[int(x) for x in range(2**problems)]
total=0

for i in combinations:
	checker=[x for x in array]+['a']
	j=0
	z=GSB(i)
	check=1
	while j!=z and i!=0:
		if i&1==1:
			checker[j]='a'
			check+=1
		i=i>>1
		j+=1
	for i in range(check):
		checker.remove('a')
	checker.sort()
	if minimum<=sum(checker)<=maximum and len(checker)>=2 and checker[-1]-checker[0]>=difference:
		total+=1
print(total)",np
"debug = 0
BIG = 10 ** 9 + 1

input = raw_input

def prof(f):
    return f

def report(f):
    def new_f(x):
        res = f(x)

        return res

    return new_f if debug else f

def mcheck(a, pairs):
    m = len(a[0])
    allm = 2 ** m - 1

    subs = {i: {i} for i in range(allm + 1)}

    for i in range(allm + 1):
        for j in range(i):
            if i | j == i:
                subs[i].add(j)

    mx = [max(aa) for aa in a]

    @prof
    def check(v):
        masks = {0: -1}
        done = [False] * (allm + 1)
        for i, aa in enumerate(a):
            if mx[i] < v:
                continue
            c = sum(1 << b for b in range(len(aa)) if aa[b] >= v)

            if not done[c]:
                for cc in subs[c]:
                    if allm - cc in masks:
                        other = masks[allm - c]
                        pairs[v] = i, other
                        return True
                    masks[cc] = i
                    done[cc] = True

        return False

    return check

@prof
def go():
    n, m = map(int, input().split())

    a = []

    uniq = set()
    for _ in range(n):
        aa = tuple(map(int, input().split()))

        a.append(aa)
        uniq.update(aa)

    uniq = sorted(uniq)
    pairs = {0: (0, 0)}
    check = mcheck(a, pairs)
    l = 0
    r = len(uniq) - 1
    while l != r:
        if debug: print(l, r)
        if l + 1 == r:
            if check(uniq[r]):
                l = r
            else:
                r = l
            continue
        c = (l + r) // 2
        if check(uniq[c]):
            l = c
        else:
            r = c

    l = uniq[l]
    if debug: print(l, pairs[l])
    if l not in pairs:
        check(l)
    a = pairs[l][0]
    b = pairs[l][1]
    if b == -1:
        b = a

    print(""%d %d"" % (a + 1, b + 1))

go()
",np
"n=2*int(input())
a=list(map(int,input().split()))
z=0
for i in range(0,n-1,2):
    if a[i]!=a[i+1]:
        for j in range(i+1,n):
            if a[j]==a[i]:
                z+=j-i-1
                a.pop(j)
                a.insert(i+1,a[i])
print(z)",O(n ^ 2)
"class Solution(object):
    def calculateTax(self, brackets, income):
        result = prev = 0
        for u, p in brackets:
            result += max((min(u, income)-prev)*p/100.0, 0.0)
            prev = u
        return result",O(n)
"class Solution(object):
    def jump(self, A):
        jump_count = 0
        reachable = 0
        curr_reachable = 0
        for i, length in enumerate(A):
            if i > reachable:
                return -1
            if i > curr_reachable:
                curr_reachable = reachable
                jump_count += 1
            reachable = max(reachable, i + length)
        return jump_count",O(n)
"line = input().split()
l = int(line[0])
r = int(line[1])

diff = (r ^ l)
print(pow(2, diff.bit_length()) - 1)
",O(logn)
"class Solution2(object):
    def nthPersonGetsNthSeat(self, n):
        dp = [0.0]*2
        dp[0] = 1.0 
        for i in range(2, n+1):
            dp[(i-1)%2] = 1.0/i+dp[(i-2)%2]*(i-2)/i
        return dp[(n-1)%2]",O(n)
"class Solution(object):
    def numTrees(self, n):
        if n == 0:
            return 1

        def combination(n, k):
            count = 1
            for i in range(1, k + 1):
                count = count * (n - i + 1) / i
            return count

        return combination(2 * n, n) - combination(2 * n, n - 1)",O(n)
"from sys import stdout
from sys import stdin
def get():
    return stdin.readline().strip()
def getf(sp = "" ""):
    return [int(i) for i in get().split(sp)]
def put(a, end = ""\n""):
    stdout.write(str(a) + end)
def putf(a, sep = "" "", end = ""\n""):
    stdout.write(sep.join([str(i) for i in a]) + end)

from math import log
from bisect import bisect_right as br, bisect_left as bl

def main():
    n, k = getf()
    a = getf()
    rem = [[] for i in range(11)]
    ln = [0] * n
    for i in range(n):
        ln[i] = int(log(a[i], 10)) + 1
        rem[ln[i]] += [a[i] % k]
    for i in range(11):
        rem[i].sort()
    ans = 0
    for i in range(n):
        res = 0
        for add_len in range(1, 11):
            cur_rem = ((a[i] % k) * pow(10, add_len, k)) % k
            need_rem = (k - cur_rem) % k
            sz = len(rem[add_len])
            l = bl(rem[add_len], need_rem)
            r = br(rem[add_len], need_rem)
            if(l > sz - 1):
                continue
            if(rem[add_len][l] == need_rem):
                res += (r - l)
        if((a[i] + (a[i] % k) * pow(10, ln[i], k)) % k == 0):
            res -= 1
        ans += res
    put(ans)
main()
",O(nlogn)
"from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

def mapin():
    return map(int, input().split())

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
x, k = mapin()
p = 1000000007
if(x == 0):
    print(0)
else:
    a = power(2, k, p)

    b = x+x-1
    b %= p
    a = (a*b) % p
    a += 1
    a %= p
    print(a)",O(logn)
"n,k = map(int, input().split())
P = list(map(int, input().split()))
C = list(map(int, input().split()))
Q = []
for i, p in enumerate(P):
    Q.append((p, i))
Q.sort()
q = []
import heapq
heapq.heapify([])
s = 0
ans = [0]*n
if k > 0:
    for p, i in Q:
        ans[i] = s+C[i]
        if len(q) == k:
            if q[0] <= C[i]:
                v = heapq.heappop(q)
                heapq.heappush(q, C[i])
                s -= v
                s += C[i]
        else:
            heapq.heappush(q, C[i])
            s += C[i]
    print(*ans)
else:
    for p, i in Q:
        ans[i] = C[i]
    print(*ans)
",O(nlogn)
"def solution():
    v = list()

    n = int(input())
    for _ in range(n):
        s = input()
        p = s.find('C')

        if s[0] == 'R' and s[1].isdigit() and p > 1:
            r = int(s[1:p])
            c = int(s[(p + 1):])

            v.clear()
            while c > 0:
                if c % 26 == 0:
                    v.append('Z')
                    c = (c - 1) // 26
                else:
                    v.append(chr(ord('A') + (c % 26 - 1)))
                    c //= 26

            v.reverse()
            print(""%s%d"" % ("""".join(v), r))

        else:
            c = 0
            p = 0
            while p < len(s):
                if s[p].isdigit():
                    break
                c = c * 26 + (ord(s[p]) - ord('A') + 1)
                p += 1

            print(""R%sC%d"" % (s[p:], c))

if __name__ == ""__main__"":
    solution()
",O(n)
"class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        if not intervals:
            return [newInterval]

        n = len(intervals)
        target = newInterval[0]
        left, right = 0, n - 1

        while left <= right:
            mid = (left + right) // 2
            if intervals[mid][0] < target:
                left = mid + 1
            else:
                right = mid - 1

        intervals.insert(left, newInterval)

        res = []
        for interval in intervals:
            if not res or res[-1][1] < interval[0]:
                res.append(interval)
            else:
                res[-1][1] = max(res[-1][1], interval[1])
        return res
",O(n)
"import itertools
import heapq


class Solution(object):
    def mincostToHireWorkers(self, quality, wage, K):
        result, qsum = float(""inf""), 0
        max_heap = []
        for r, q in sorted([float(w)/q, q] for w, q in zip(wage, quality)):
            qsum += q
            heapq.heappush(max_heap, -q)
            if len(max_heap) > K:
                qsum -= -heapq.heappop(max_heap)
            if len(max_heap) == K:
                result = min(result, qsum*r)
        return result",O(nlogn)
"class Solution2(object):
    def numWays(self, n, k):
        if n == 0:
            return 0
        elif n == 1:
            return k
        ways = [0] * n
        ways[0] = k
        ways[1] = (k - 1) * ways[0] + k
        for i in range(2, n):
            ways[i] = (k - 1) * (ways[i - 1] + ways[i - 2])
        return ways[n - 1]",O(n)
"from sys import stdin

def solve(tc):
    k = int(stdin.readline().strip())
    cmp = 9
    ndigit = 1

    while k>(cmp*ndigit):
        k -= cmp*ndigit
        cmp *= 10
        ndigit += 1

    num = (10**(ndigit-1)) + ((k-1) // ndigit)
    pos = (k-1) % ndigit

    print(str(num)[pos])
    pass

LOCAL_TEST = not __debug__
if LOCAL_TEST:
    infile = __file__.split('.')[0] + ""-test.in""
    stdin = open(infile, 'r')

tcs = (int(stdin.readline().strip()) if LOCAL_TEST else 1)
tc = 1
while tc <= tcs:
    solve(tc)
    tc += 1",O(1)
"digit = int(input())

if int(digit) <= 9:
    print(digit)
    exit()

start_range = 1
end_range = 9

power = 1
digit_count = 2
while not (start_range <= digit and digit <= end_range):
    start_range = end_range + 1
    end_range = 9 * 10**power * digit_count + start_range - 1
    power += 1
    digit_count += 1

offset_number = (digit - start_range) // (digit_count - 1)

number = str(10**(power - 1) + offset_number)

offset_digit = (digit - start_range) % (digit_count - 1)

print(f""{number[offset_digit]}"")
",O(logn)
"class Solution2(object):
    def numberOfAlternatingGroups(self, colors):
        return sum(colors[i] != colors[(i+1)%len(colors)] != colors[(i+2)%len(colors)] for i in range(len(colors)))",O(n)
"import sys

IS_LOCAL = False

def readMultiple(f):
    return f(map(int, input().split()))

def main():
    n = 3
    a = [1, 2, -4]

    if not IS_LOCAL:
        n = int(input())
        a = readMultiple(list)

    for i, x in enumerate(a):
        if x >= 0:
            a[i] = -x - 1

    cnt_neg = 0
    for x in a:
        if x < 0:
            cnt_neg += 1

    b = sorted([(abs(x), i) for i, x in enumerate(a)])
    if cnt_neg % 2 == 1:
        ind = b[n-1][1]
        a[ind] = -a[ind] - 1

    print(' '.join(map(str, a)))

if __name__ == ""__main__"":
    if len(sys.argv) > 1 and sys.argv[1] == 'True':
        IS_LOCAL = True
    main()
",O(nlogn)
"import sys
input_file = sys.stdin

[n,m] = list(int(x) for x in input_file.readline().split())
stacks = list(int(x) for x in input_file.readline().split())
stacks.sort()

ans = 0
cur_stack = 0
cur_h = 0

while cur_stack < n:
    ans += 1
    if stacks[cur_stack] >= cur_h + 1:
        cur_h += 1
    cur_stack += 1
ans += stacks[-1] - cur_h

print(sum(stacks) - ans)
",O(nlogn)
"def isValid(field, y, x):
	for i in range(3):
		for j in range(3):
			if i == 1 and j == 1:
				continue
			if field[y + i][x + j] == '.':
				return False
	return True
def fill(field, y, x):
	for i in range(3):
		for j in range(3):
			if i == 1 and j == 1:
				continue
			cur[y + i][x + j] = '
n, m = list(map(int, input().split()))
sig = []
cur = []
for i in range(n):
	sig += [list(input())]
	cur += [["".""] * m]

for i in range(n - 2):
	for j in range(m - 2):
		if isValid(sig, i, j):
			fill(cur, i, j)

if sig == cur:
	print(""YES"")
else:
	print(""NO"")",O(n ^ 2)
"class Solution(object):
    def intToRoman(self, num):
        numeral_map = {1: ""I"", 4: ""IV"", 5: ""V"", 9: ""IX"", \
                       10: ""X"", 40: ""XL"", 50: ""L"", 90: ""XC"", \
                       100: ""C"", 400: ""CD"", 500: ""D"", 900: ""CM"", \
                       1000: ""M""}
        keyset, result = sorted(numeral_map.keys()), []

        while num > 0:
            for key in reversed(keyset):
                while num / key > 0:
                    num -= key
                    result += numeral_map[key]

        return """".join(result)",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def maxDepth(self, root):
        if root is None:
            return 0
        else:
            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1",O(n)
print(int(input())//2*3),O(1)
"class Solution(object):
    def orderlyQueue(self, S, K):
        if K == 1:
            return min(S[i:] + S[:i] for i in range(len(S)))
        return """".join(sorted(S))",O(n ^ 2)
"def main():
    import sys
    import collections
    input = sys.stdin.readline
    n, m, K = map(int, input().split())

    A = [input().rstrip() for i in range(n)]

    B = [list(input().rstrip().split()) for i in range(m)]

    alpha = 'abcｄ'

    D = dict()
    for i, x in enumerate(A):
        D[x] = i

    G = [set() for i in range(n)]
    X = [set() for i in range(n)]

    for i in range(m):
        a, b = B[i]
        b = int(b)
        flag = False
        for j in range(2**K):
            x = []
            for k in range(K):
                if (j >> k) % 2 == 1:
                    x.append('_')
                else:
                    x.append(a[k])
            x = ''.join(x)
            if x in D:
                if D[x] == b-1:
                    flag = True
                    continue
                else:
                    G[b-1].add(D[x])
                    X[D[x]].add(b-1)
        if flag:
            continue
        else:
            print(""NO"")
            exit(0)
    X = [len(X[i]) for i in range(n)]
    ANS = []
    s = set()
    q = collections.deque()
    for i in range(n):
        if X[i] == 0:
            q.append(i)
            s.add(i)

    while(q):
        if len(ANS) == n:
            print(""NO"")
            exit(0)
        x = q.popleft()
        ANS.append(x+1)
        for y in G[x]:
            if X[y] == 0:
                continue
            else:
                X[y] -= 1
                if X[y] == 0:
                    q.append(y)
    if len(ANS) == n:
        print(""YES"")
        print(*ANS)
    else:
        print(""NO"")

main()
",np
"import collections


class Solution(object):
    def pathSum(self, nums):
        class Node(object):
            def __init__(self, num):
                self.level = num/100 - 1
                self.i = (num%100)/10 - 1
                self.val = num%10
                self.leaf = True

            def isParent(self, other):
                return self.level == other.level-1 and \
                       self.i == other.i/2

        if not nums:
            return 0
        result = 0
        q = collections.deque()
        dummy = Node(10)
        parent = dummy
        for num in nums:
            child = Node(num)
            while not parent.isParent(child):
                result += parent.val if parent.leaf else 0
                parent = q.popleft()
            parent.leaf = False
            child.val += parent.val
            q.append(child)
        while q:
            result += q.pop().val
        return result",O(n)
"a,b=list(map(int,input().split()))
c,d=(((b+1)//2)-1,(b-a-1))
print(c if d<0 else c-d if c>d else 0)
",O(1)
"index = int(input())

total = 9
n = 1

while index > total:
    total += (n + 1) * (10**n) * 9
    n += 1
last = 10**(n - 1)
total -= n * 9 * last
index = index - total

r = index % (n)
k = index // n

number = last + k

if r == 0:
    print(str(number - 1)[n-1])
else:
    print(str(number)[r - 1])
",O(logn)
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int,sys.stdin.readline().strip().split()))

for i in range (0, n):
    if a[i] >= 0:
        a[i] = - a[i] - 1

if n % 2 == 1:
    i = a.index(min(a))
    a[i] = - a[i] - 1

a = list(map(str,a))
print("" "".join(a))
",O(n)
"n , s = map(int,input().split())
a = [0] * (n+1)
for _ in range(n-1) :
    u , v=map(int, input().split())
    a[u] += 1
    a[v] += 1
print(2.0*s/a.count(1))",O(n)
"def min_sub_array(day, k):
    if not day:
        return [0] * (k + 1)
    n = len(day)
    best = [float('inf')] * (n + 1)
    best[0] = 0
    best[1] = 1
    for size in range(2, n + 1):
        for i in range(n + 1 - size):
            best[size] = min(best[size], day[i + size - 1] - day[i] + 1)
    output = [0] * (k + 1)
    for i in range(k + 1):
        if n - i > 0:
            output[i] = best[n - i]
    return output

N, M, K = map(int, input().split())

day = [i for i, val in enumerate(input()) if val == '1']
best = min_sub_array(day, K)

for _ in range(N - 1):
    day = [i for i, val in enumerate(input()) if val == '1']
    new_day_best = min_sub_array(day, K)

    new_best = [float('inf')] * (K + 1)
    for i in range(K + 1):
        for j in range(i + 1):
            new_best[i] = min(new_best[i], new_day_best[j] + best[i - j])
    best = new_best
print(best[K])
",O(n ^ 3)
"n,m=map(int,input().split())
a=[int(input(),2)for _ in range(n)]

s=t=0
for x in a:
    t|=s&x
    s|=x
print(('YES','NO')[all(x&s&~t for x in a)])",O(n ^ 2)
"n, m = map(int,input().split())
r=0
c=0
f= 1
for i in range(n):
    s = input()
    if  f and ""B"" in s:
        f = 0
        ci = s.index('B')
        cc = s.count(""B"")
        r = i+1+cc//2
        c = ci+cc//2+1
print(r,c)",O(n ^ 2)
"def A(n):
	return (4**n-1)//3

L = 31

T = int(input())
for _ in range(T):
	n,k = [int(_) for _ in input().split()]

	if n > L:
		print(""YES"",n-1)
		continue

	if k > A(n):
		print(""NO"")
		continue

	E = 1
	M = 0
	R = 0
	while n >= 0:
		M += E

		I = 2*E-1
		E = 2*E+1

		n -= 1
		R += I*A(n)

		if M <= k and k <= M+R: break

	if n >= 0: print(""YES"",n)
	else: print(""NO"")
",O(logn)
"class Solution(object):
    def licenseKeyFormatting(self, S, K):
        result = []
        for i in reversed(range(len(S))):
            if S[i] == '-':
                continue
            if len(result) % (K + 1) == K:
                result += '-'
            result += S[i].upper()
        return """".join(reversed(result))",O(n)
"k=int(input())
a=[]
for i in range(0,12):
    s=9*pow(10,i)*(i+1)
    if k<=s:
        break
    else:
        k-=s
pos=i+1
num=(pow(10,pos-1)+(k//pos)-1)
if k%pos==0:
    print(str(num)[-1])
else:
    print(str(num+(0 if pos==1 else 1))[(k%pos)-1])
",O(1)
"import bisect
import sys
input=sys.stdin.readline

import collections
import heapq
t=1
p=10**9+7
def ncr_util():

    inv[0]=inv[1]=1
    fact[0]=fact[1]=1
    for i in range(2,300001):
        inv[i]=(inv[i%p]*(p-p//i))%p
    for i in range(1,300001):
        inv[i]=(inv[i-1]*inv[i])%p
        fact[i]=(fact[i-1]*i)%p

def solve():
    ans,a,b=0,0,0
    mul=2**60
    for i in range(60,-1,-1):

        ch1,ch2=0,0
        if a+mul<=l:

            a+=mul
            ch1=1
        if  b+mul<=l:

            b+=mul
            ch2=1
        if ch1^ch2==1:
            ans+=mul
        elif ch1==0 and ch2==0:
            if a+mul<=r:
                a+=mul
                ans+=mul
            elif b+mul<=r:
                b+=mul
                ans+=mul

        mul//=2

    return ans

for _ in range(t):

    l,r=map(int,input().split())

    print(solve())
",O(logn)
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def lcm(a, b):
    return (a * b) / gcd(a, b)

def main():

    n=int(input())
    a=[]
    for i in range(n):
        a.append(list(map(int, input().split())))
    d={}
    if n==1:
        print('YES')
        return
    vis=[0]*n
    for i in range(1,n):
        num=abs(a[i][1]-a[0][1])
        den=abs(a[i][0]-a[0][0])
        k=1
        k=gcd(num, den)
        num//=k
        den//=k
        if ((a[i][1]-a[0][1])*(a[i][0]-a[0][0]))<0:
            num*=-1
        if (num, den) in d:
            d[(num, den)].append(i)
        else:
            d[(num, den)]=[i]
    maxx=0

    for i in d.keys():
        if len(d[i])>maxx:
            maxx=len(d[i])
            ki=i
    vis[0]=1
    for i in d[ki]:
        vis[i]=1
    t=[]
    for i in range(n):
        if not vis[i]:
            t.append(i)
    f=1
    if len(t)>1:
        num=abs(a[t[0]][1]-a[t[1]][1])
        den=abs(a[t[0]][0]-a[t[1]][0])
        k = 1
        k=gcd(num, den)
        num//=k
        den//=k
        if (a[t[0]][1]-a[t[1]][1])*(a[t[0]][0]-a[t[1]][0])<0:
            num*=-1
        m=(num, den)
        for i in range(2, len(t)):
            num = abs(a[t[i]][1] - a[t[0]][1])
            den = abs(a[t[i]][0] - a[t[0]][0])
            k=gcd(num, den)
            num //= k
            den //= k
            if (a[t[0]][1] - a[t[i]][1]) * (a[t[0]][0] - a[t[i]][0]) < 0:
                num *= -1
            if (num,den)!=m:
                f=0
    if f:
        print('YES')
    else:
        d = {}
        if n == 1:
            print('YES')
            return
        vis = [0] * n
        a[0], a[1]=a[1], a[0]
        for i in range(1, n):
            num = abs(a[i][1] - a[0][1])
            den = abs(a[i][0] - a[0][0])
            k = 1
            k = gcd(num, den)
            num //= k
            den //= k
            if ((a[i][1] - a[0][1]) * (a[i][0] - a[0][0])) < 0:
                num *= -1
            if (num, den) in d:
                d[(num, den)].append(i)
            else:
                d[(num, den)] = [i]
        maxx = 0

        for i in d.keys():
            if len(d[i]) > maxx:
                maxx = len(d[i])
                ki = i
        vis[0] = 1
        for i in d[ki]:
            vis[i] = 1
        t = []
        for i in range(n):
            if not vis[i]:
                t.append(i)
        f = 1
        if len(t) > 1:
            num = abs(a[t[0]][1] - a[t[1]][1])
            den = abs(a[t[0]][0] - a[t[1]][0])
            k = 1
            k=gcd(num, den)
            num //= k
            den //= k
            if (a[t[0]][1] - a[t[1]][1]) * (a[t[0]][0] - a[t[1]][0]) < 0:
                num *= -1
            m = (num, den)
            for i in range(2, len(t)):
                num = abs(a[t[i]][1] - a[t[0]][1])
                den = abs(a[t[i]][0] - a[t[0]][0])
                k = 1
                k=gcd(num, den)
                num //= k
                den //= k
                if (a[t[0]][1] - a[t[i]][1]) * (a[t[0]][0] - a[t[i]][0]) < 0:
                    num *= -1
                if (num, den) != m:
                    f = 0
        if f:
            print('YES')
        else:
            print('NO')

    return

if __name__ == ""__main__"":
    main()",O(nlogn)
"t = int(input())
for i in range(t):
    n, m = [int(item) for item in input().split()]
    mat = []
    col = [[] for _ in range(m)]
    for j in range(n):
        line = [int(item) for item in input().split()]
        for k, item in enumerate(line):
            col[k].append(item)
        mat.append(line)
    colmax = []
    for line in col:
        colmax.append([max(line), line])
    colmax.sort(reverse=True)
    colmax = colmax[:n]
    ans = 0
    for j in range(n ** (n-1)):
        index = j
        rot = [0]
        for k in range(n-1):
            rot.append(index % n)
            index //= n
        ret = 0
        for l in range(n):
            val = 0
            for k in range(len(colmax)):
                val = max(val, colmax[k][1][(l + rot[k]) % n])
            ret += val
        ans = max(ans, ret)
    print(ans)",np
"class Solution(object):
    def countAsterisks(self, s):
        result = cnt = 0
        for c in s:
            if c == '|':
                cnt = (cnt+1)%2
                continue
            if c == '*' and cnt == 0:
                result += 1
        return result",O(n)
"import sys

def solve(n, m, grid):
    for i, row in enumerate(grid):
        for j, cell in enumerate(row):
            if cell == 0:
                continue
            must = cell == 1
            if i >= n - 2 or j >= m - 2:
                if must:
                    return 'NO'
                continue
            for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]:
                if grid[i + di][j + dj] == 0:
                    if must:
                        return 'NO'
                    break
            else:
                for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]:
                    grid[i + di][j + dj] = 2
                grid[i][j] = 2
    return 'YES'

n, m = list(map(int, input().split()))
grid = [['.
print(solve(n, m, grid))
",O(n ^ 2)
"class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        count = defaultdict(int)
        for num in nums:
            count[num] += 1

        res = []
        for i in range(len(nums)):
            count[nums[i]] -= 1
            if i and nums[i] == nums[i - 1]:
                continue

            for j in range(i + 1, len(nums)):
                count[nums[j]] -= 1
                if j - 1 > i and nums[j] == nums[j - 1]:
                    continue
                target = -(nums[i] + nums[j])
                if count[target] > 0:
                    res.append([nums[i], nums[j], target])

            for j in range(i + 1, len(nums)):
                count[nums[j]] += 1
        return res
",O(n ^ 2)
"class Solution(object):
    def isOneBitCharacter(self, bits):
        parity = 0
        for i in reversed(range(len(bits)-1)):
            if bits[i] == 0:
                break
            parity ^= bits[i]
        return parity == 0",O(n)
"import collections


class ListNode(object):
    def __init__(self, key, value, freq):
        self.key = key
        self.val = value
        self.freq = freq
        self.next = None
        self.prev = None


class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 


class Solution2(object):

    def __init__(self, capacity):
        self.__capa = capacity
        self.__size = 0
        self.__min_freq = float(""inf"")
        self.__freq_to_nodes = collections.defaultdict(LinkedList)
        self.__key_to_node = {}

    def get(self, key):
        if key not in self.__key_to_node:
            return -1
        value = self.__key_to_node[key].val
        self.__update(key, value)
        return value

    def put(self, key, value):
        if self.__capa <= 0:
            return

        if key not in self.__key_to_node and self.__size == self.__capa:
            del self.__key_to_node[self.__freq_to_nodes[self.__min_freq].head.key]
            self.__freq_to_nodes[self.__min_freq].delete(self.__freq_to_nodes[self.__min_freq].head)
            if not self.__freq_to_nodes[self.__min_freq].head:
                del self.__freq_to_nodes[self.__min_freq]
            self.__size -= 1
        self.__update(key, value)
        
    def __update(self, key, value):
        freq = 0
        if key in self.__key_to_node:
            old_node = self.__key_to_node[key]
            freq = old_node.freq
            self.__freq_to_nodes[freq].delete(old_node)
            if not self.__freq_to_nodes[freq].head:
                del self.__freq_to_nodes[freq]
                if self.__min_freq == freq:
                    self.__min_freq += 1
            self.__size -= 1

        freq += 1
        self.__min_freq = min(self.__min_freq, freq)
        self.__key_to_node[key] = ListNode(key, value, freq)
        self.__freq_to_nodes[freq].append(self.__key_to_node[key])
        self.__size += 1",O(1)
"from sys import stdin
from bisect import *

rints = lambda: [int(x) for x in stdin.readline().split()]
rints_2d = lambda n: [rints() for _ in range(n)]
n, mem, pos, power = int(input()), [1], [], []
a = sorted(rints_2d(n))

for x, y in a:
    pos.append(x)
    power.append(y)

for i in range(1, n):
    ix = bisect_left(pos, pos[i] - power[i]) - 1
    if ix == -1:
        mem.append(1)
    else:
        mem.append(mem[ix] + 1)

print(n - max(mem))
",O(n)
"class Solution2(object):
    def preorderTraversal(self, root):
        result, stack = [], [(root, False)]
        while stack:
            root, is_visited = stack.pop()
            if root is None:
                continue
            if is_visited:
                result.append(root.val)
            else:
                stack.append((root.right, False))
                stack.append((root.left, False))
                stack.append((root, True))
        return result",O(n)
"class Solution:
    def countSubstrings(self, s: str) -> int:

        def manacher(s):
            t = '
            n = len(t)
            p = [0] * n
            l, r = 0, 0
            for i in range(n):
                p[i] = min(r - i, p[l + (r - i)]) if i < r else 0
                while (i + p[i] + 1 < n and i - p[i] - 1 >= 0
                       and t[i + p[i] + 1] == t[i - p[i] - 1]):
                    p[i] += 1
                if i + p[i] > r:
                    l, r = i - p[i], i + p[i]
            return p

        p = manacher(s)
        res = 0
        for i in p:
            res += (i + 1) // 2
        return res
",O(n)
"import os, sys
from io import BytesIO, IOBase
from math import log2, ceil, sqrt, gcd
from _collections import deque
import heapq as hp
from bisect import bisect_left, bisect_right
from math import cos, sin

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

mod = 10 ** 9 + 7

def ask(x, y):
    print('?', x, y, flush=True)
    return int(input())

a = b = 0
cond = ask(a, b)
for i in range(29, -1, -1):
    if cond:
        x = a + (1 << i)
        y = b + (1 << i)
        n_cond = ask(x, y)
        if cond == n_cond:
            if cond == 1:
                n_cond1 = ask(x, b)
            else:
                n_cond1 = ask(a, y)

            if cond != n_cond1:
                a = x
                b = y

        else:
            if cond == 1:
                a = x
            else:
                b = y
            cond = ask(a, b)
    else:
        x = a + (1 << i)
        y = b + (1 << i)
        n_cond = ask(x, b)
        if n_cond == -1:
            a = x
            b = y
print('!', a, b, flush=True)
",O(logn)
"import  math
s=str(input())
s2=str(input())
p,m,res,ans,temp,i=0,0,0,0,0,0
p=s.count(""+"")
m=s.count(""-"")
q=s2.count(""+"")
w=s2.count(""-"")
pr,mr=p-q,m-w
if pr <0 or mr<0:
    print(""%.12f""%0)
else:
    temp=pr+mr
    if temp==0:
        print('%.12f'%1)
    else:
        i=pow(2,temp)
        res=math.factorial(temp)/(math.factorial(pr)*math.factorial(mr))
        ans=res/i
        print(""%.12f""%ans)
",np
"class Solution(object):
    def addedInteger(self, nums1, nums2):
        return max(nums2)-max(nums1)",O(n)
"s = input()
def is_pal(s):
      if s == s[::-1]:
            return True
      else:
            return False
if not is_pal(s):
      print(len(s))
else:
      not_eq = False
      for i in range(len(s)-1):
            if s[i] != s[i+1]:
                  print(len(s)-1)
                  not_eq = True
                  break
      if not not_eq:
            print(0)",O(n)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"def isValid(arr, l, r, x):
	return l <= sum(arr) <= r and max(arr)-min(arr) >= x

n, l, r, x = map(int, input().strip().split())
arr = list(map(int, input().strip().split()))
valid = 0

for i in range(1, 1<<n):
	s = str(bin(i))[2:].rjust(n, '0')
	temp = []
	for j in range(n):
		if s[j] == '1':
			temp.append(arr[j])
	if isValid(temp, l, r, x):
		valid += 1
print(valid)",np
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
from collections import defaultdict
from itertools import permutations

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,k=map(int,sys.stdin.readline().split())

mod=998244353
dp=[[0,0,0,0] for x in range(k+3)]
dp[1][0]=1
dp[1][1]=1
dp[2][2]=1
dp[2][3]=1
newdp=[[0,0,0,0] for x in range(k+3)]
for i in range(n-1):

    for j in range(k+1):
        newdp[j+1][1]+=dp[j][0]
        newdp[j+1][3]+=dp[j][0]
        newdp[j+1][2]+=dp[j][0]
        newdp[j][0]+=dp[j][0]
        newdp[j][1]+=dp[j][1]
        newdp[j+1][3]+=dp[j][1]
        newdp[j+1][2]+=dp[j][1]
        newdp[j+1][0]+=dp[j][1]
        newdp[j][1]+=dp[j][2]
        newdp[j+2][3]+=dp[j][2]
        newdp[j][2]+=dp[j][2]
        newdp[j][0]+=dp[j][2]
        newdp[j][1]+=dp[j][3]
        newdp[j][3]+=dp[j][3]
        newdp[j+2][2]+=dp[j][3]
        newdp[j][0]+=dp[j][3]

        for a in range(3):
            for b in range(4):
                newdp[a+j][b]%=mod
    for a in range(k+3):
        for b in range(4):
            dp[a][b]=newdp[a][b]
            newdp[a][b]=0
ans=sum(dp[k])
ans%=mod
print(ans)",np
"n=int(input())
li=[]
for i in range(1,n+1):
    if n%i==0:
        li.append(i)
p=0
for t in li:
    l=[m for m in str(t)]
    if set(l)=={'4'} or set(l)=={'7'} or set(l)=={'4','7'}:
        p+=1
if p>0:
    print('YES')
else:
    print('NO')",O(1)
"import os,sys
from io import BytesIO, IOBase

def main():
    n,m = map(int,input().split())
    x = ((n-5)//4+((n-5)%4!=0))
    if n <= 5:
        a,b = '5','5'
    else:
        a = '5'*(x+1)
        b = '4'*x+'5'
    print(a,b)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",O(1)
"d = {}
n = int(input())
for _ in range(n):
	a,x = map(int,input().split())
	d[a] = x
m = int(input())
for _ in range(m):
	b,y = map(int,input().split())
	if b in d:
		d[b] = max(y,d[b])
	else:
		d[b] = y
count = 0
for i in d:
	count += d[i]
print(count)",O(nlogn)
"from sys import stdin, stdout
import heapq
from collections import defaultdict
import math
import bisect

def main():
    n,m,k = list(map(int, stdin.readline().split()))
    right = []
    for _ in range(n):
        right.append(list(map(int, stdin.readline().split())))
    down = []
    for _ in range(n-1):
        down.append(list(map(int, stdin.readline().split())))
    if k % 2 == 1:
        for _ in range(n):
            stdout.write("" "".join([""-1"" for _ in range(m)])+""\n"")
        return
    dp = [[0 for _ in range(m)] for _ in range(n)]
    for x in range(1, (k//2) + 1):
        tmp = [[math.inf for _ in range(m)] for _ in range(n)]
        for i in range(n):
            for j in range(m):
                if i:
                    tmp[i][j] = min(tmp[i][j], dp[i-1][j] + 2 * down[i-1][j])
                if i < n-1:
                    tmp[i][j] = min(tmp[i][j], dp[i + 1][j] + 2 * down[i][j])
                if j:
                    tmp[i][j] = min(tmp[i][j], dp[i][j - 1] + 2 * right[i][j - 1])
                if j < m-1:
                    tmp[i][j] = min(tmp[i][j], dp[i][j + 1] + 2 * right[i][j])
        dp = tmp

    for i in range(n):
        stdout.write("" "".join([str(x) for x in dp[i]]) + ""\n"")

main()",O(n ^ 3)
"from heapq import heappush, heappop
n,k = map(int, input().split())
powers = list(map(int, input().split()))
coins = list(map(int, input().split()))

A = []
ans = [0] * n
for i in range(n):
    A.append((powers[i], coins[i], i))
A.sort()
h = []
total = 0
for i in range(n):
    _,c,idx = A[i]
    ans[idx] = total + c
    if len(h) < k:
        heappush(h, c)
        total += c
    elif h and h[0] < c:
        total -= heappop(h)
        heappush(h, c)
        total += c

for x in ans:
    print(x, end="" "")
print()
",O(nlogn)
"import collections
from functools import reduce



class Solution(object):
    def getSum(self, nums):
        def count(d):
            result = 0
            cnt = collections.defaultdict(int)
            prefix = collections.defaultdict(int)
            for x in nums:
                c = (cnt[x-d]+1)%MOD
                cnt[x] = (cnt[x]+c)%MOD
                total = (prefix[x-d]+x*c)%MOD
                prefix[x] = (prefix[x]+total)%MOD
                result = (result+total)%MOD
            return result
    
        MOD = 10**9+7
        return (count(+1)+count(-1)-reduce(lambda accu, x: (accu+x)%MOD, nums, 0))%MOD",O(n)
"class Solution(object):
    def minSideJumps(self, obstacles):
        result, lanes = 0, set([2])
        for i in range(len(obstacles)-1):
            lanes.discard(obstacles[i+1])
            if lanes:
                continue
            result += 1
            lanes = set(j for j in range(1, 4) if j not in [obstacles[i], obstacles[i+1]])
        return result",O(n)
"n, m, k = map(int, input().split())
arr = [int(x) for x in input().split()]
modulo = 0
tmp = 0
op = 1
cur = (arr[0] - 1) // k
for i in range(m):
    if (arr[i] - 1 - modulo) // k != cur:
        modulo += tmp
        cur = (arr[i] - 1 - modulo) // k
        tmp = 0
        op += 1
    tmp += 1
print(op)",O(n)
"import sys
input = sys.stdin.readline

def main():
    n,m = map(int,input().split())
    a = []
    for _ in [0]*n:
        a.append(list(map(int,input().split())))

    ok = 0
    ng = 10**9+1
    judge = pow(2,m)-1
    dg = 1000

    while ng-ok > 1:
        mid = (ng+ok)//2
        tank = set()
        for i in range(n):
            r = 0
            for j in range(m):
                r *= 2
                if a[i][j] >= mid:
                    r += 1
            tank.add(r)

        for p in tank:
            for q in tank:
                if p|q == judge:
                    ok = mid
                    break
        if ok != mid:
            ng = mid

    tank = set()
    res = []
    for i in range(n):
        r = 0
        for j in range(m):
            r *= 2
            if a[i][j] >= ok:
                r += 1
        if not r in tank:
            res.append(i*dg+r)
        tank.add(r)

    for p in res:
        for q in res:
            if (p%dg)|(q%dg) == judge:
                print(p//dg+1,q//dg+1)
                return

if __name__ == '__main__':
    main()",np
"n, m = list(map(int, input().split()))
a = list(map(int, input().split()))
b = list(map(int, input().split()))
lst = []
for i in range(len(a)):
    if (a[i] in b):
        lst.append(a[i])
if (len(lst) == 0):
    pass
else:
    print(*lst)
",O(n ^ 2)
"class Solution(object):
    def countGoodRectangles(self, rectangles):
        result = mx = 0
        for l, w in rectangles:
            side = min(l, w)
            if side > mx:
                result, mx = 1, side
            elif side == mx:
                result += 1
        return result",O(n)
"s = input()

mc = -1

for i in range(len(s)):
	for j in range(i+1, len(s)):
		cu = 0
		for cu in range(len(s)-max(i, j)):
			if s[i+cu] == s[j+cu]:
				mc = max(mc, cu)
			else:
				break

print(mc + 1)
",O(n ^ 3)
"class Solution(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        return [words[i] for i in range(n) if i == 0 or groups[i-1] != groups[i]]",O(n)
"from itertools import*

moves =[(x*mx,y*my) for mx,my,(x,y) in product( (-1,1),(-1,1), ( (1,2),(2,1) ) )]

def ac(l,x):
	if l==0: return 0
	return l[x] if 0<=x<len(l) else 0

def work():
	x=1
	while x:
		x=0
		for r in range(len(a)):
			for c in range(len(a[0])):
				if not a[r][c] and sum(ac(ac(a,r+dr),c+dc) for dr,dc in moves)>=4:
					a[r][c]=1
					x=1

for n in [int(input())]:

	cand=set()

	for i in range(1000):
		for x,y in ( (0,i),(i,0),(i,1),(-i,0),(-i,1),(0,-i) ):
			if x==0 or x%3!=1:
				if n==len(cand): break
				cand.add((x,y))

	assert len(cand)==n

	for x,y in cand: print(x,y)
",O(1)
"from collections import defaultdict
from sys import stdin
input = stdin.readline
def check(mid, m):
    d = defaultdict(int)
    for idx, i in enumerate(a):
        string = ''
        for j in i:
            if j >= mid:
                string+='1'
            else:
                string+='0'
        d[int(string, 2)] = idx
    for i in d.keys():
        for j in d.keys():
            if i|j == 2**m - 1:
                 return [d[i], d[j]]
    return []
def binarySearch(lo, hi, m):
    ans = []
    while lo < hi:
        mid = lo + (hi-lo+1)//2
        x = check(mid, m)
        if x:
            lo = mid
            ans = [x[0]+1, x[1]+1]
        else:
            hi = mid-1
    mid = lo + (hi-lo+1)//2
    x = check(mid, m)
    if x:
        ans = [x[0]+1, x[1]+1]
    return ans
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
print(*binarySearch(0, 10**9, m))",np
"class Solution(object):
    def triangularSum(self, nums):
        def exp_mod(p, mod):
            result = [p]
            while result[-1]*p%10 != result[0]:
                 result.append(result[-1]*p%10)
            return [result[-1]]+result[:-1]

        def inv_mod(x, mod):
            y = x
            while y*x%10 != 1:
                y = y*x%10
            return y

        def factor_p(x, p, cnt, diff):
            if x == 0:
                return x, cnt
            while x%p == 0:
                x //= p
                cnt += diff
            return x, cnt
    
        EXP = {p:exp_mod(p, 10) for p in (2, 5)} 
        INV = {i:inv_mod(i, 10) for i in range(1, 10) if i%2 and i%5} 
        result = 0
        nCr = 1
        cnt = {2:0, 5:0}
        for i in range(len(nums)):
            if not cnt[2] and not cnt[5]:
                result = (result + nCr*nums[i])%10
            elif cnt[2] and not cnt[5]:
                result = (result + nCr*EXP[2][cnt[2]%len(EXP[2])]*nums[i])%10
            elif not cnt[2] and cnt[5]:
                result = (result + nCr*EXP[5][cnt[5]%len(EXP[5])]*nums[i])%10
            mul, cnt[2] = factor_p((len(nums)-1)-i, 2, cnt[2], 1)
            mul, cnt[5] = factor_p(mul, 5, cnt[5], 1)
            div, cnt[2] = factor_p(i+1, 2, cnt[2], -1)
            div, cnt[5] = factor_p(div, 5, cnt[5], -1)
            nCr = nCr*mul%10
            nCr = nCr*INV[div%10]%10
        return result",O(n)
"import sys
input = sys.stdin.readline
import heapq

R, G, B = map(int, input().split())
r = [int(item) for item in input().split()]
g = [int(item) for item in input().split()]
b = [int(item) for item in input().split()]
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
nr = len(r)
ng = len(g)
nb = len(b)

dp = [[[0] * (nb+1) for _ in range(ng+1)] for _ in range(nr+1)]
ans = 0
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if (i + j + k) % 2 == 1:
                continue
            if i > 0 and j > 0:

                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + r[i-1] * g[j-1])
            if j > 0 and k > 0:

                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1] + g[j-1] * b[k-1])
            if i > 0 and k > 0:

                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1] + b[k-1] * r[i-1])
            ans = max(ans, dp[i][j][k])

print(ans)",O(n ^ 3)
"def f(n,s):
 d=[-n,-n];d[s]=0
 for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
 return d[s]
import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))
",np
"class Solution(object):
    def findPrimePairs(self, n):
        def linear_sieve_of_eratosthenes(n):
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf 

        spf = linear_sieve_of_eratosthenes(n)
        return [[i, n-i] for i in range(2, n//2+1) if spf[i] == i and spf[n-i] == n-i]",O(n)
"class Solution(object):
    def readBinaryWatch(self, num):
        def bit_count(bits):
            count = 0
            while bits:
                bits &= bits-1
                count += 1
            return count

        return ['%d:%02d' % (h, m) for h in range(12) for m in range(60)
                if bit_count(h) + bit_count(m) == num]

    def readBinaryWatch2(self, num):
        return ['{0}:{1}'.format(str(h), str(m).zfill(2))
                for h in range(12) for m in range(60)
                if (bin(h) + bin(m)).count('1') == num]",O(1)
"n = int(input())
arr = list(map(int,input().split()))
arr.sort()
if n>=2 and  arr[0]==arr[1]==0:
	print(""cslnb"")
else:
	flag=0
	for i in range(n-2):
		if arr[i]==arr[i+1]==arr[i+2]:
			flag=1
			break
	if flag==1:
		print(""cslnb"")
	else:
		flag=0
		ind=0
		for i in range(n-1):
			if arr[i]==arr[i+1]:
				ind = i
				flag+=1
		if flag==1 and ind>0 and arr[ind-1]==arr[ind]-1:
			print(""cslnb"")

		elif flag>=2:
			print(""cslnb"")
		else:
			safe = 0
			for i in range(n):

				if arr[i]-i>=0:
					safe+=arr[i]-i

			if safe%2==0:
				print(""cslnb"")
			else:
				print(""sjfnb"")",O(nlogn)
"class Solution(object):
    def getRow(self, rowIndex):
        result = [0] * (rowIndex + 1)
        for i in range(rowIndex + 1):
            old = result[0] = 1
            for j in range(1, i + 1):
                old, result[j] = result[j], old + result[j]
        return result

    def getRow2(self, rowIndex):
        row = [1]
        for _ in range(rowIndex):
            row = [x + y for x, y in zip([0] + row, row + [0])]
        return row

    def getRow3(self, rowIndex):
        if rowIndex == 0: return [1]
        res = [1, 1]

        def add(nums):
            res = nums[:1]
            for i, j in enumerate(nums):
                if i < len(nums) - 1:
                    res += [nums[i] + nums[i + 1]]
            res += nums[:1]
            return res

        while res[1] < rowIndex:
            res = add(res)
        return res",O(n ^ 2)
"x, k = map(int, input().split())
if x == 0:
    print(0)
    exit()
mod = 10**9+7
ans = 1+(2*x-1)*pow(2, k, mod)
print(ans%mod)
",O(logn)
"n , k = map(int, input().split())
l = list(map(int,input().split()))
l.sort()
a = 0
i = 0
while i<(n-1):
    j = i+1
    while j<n and l[j]==l[i]:
        j+=1
    if j==n:
        break
    else:
        if l[j]<=l[i]+k:
            a+=(j-i)
    i = j
print(n-a)",O(nlogn)
"import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

L, R = map(int, input().split())

for i in range(64, -1, -1):
    if L & (1 << i) != R & (1 << i):
        print((1 << (i+1)) - 1)
        exit(0)
print(0)",O(logn)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
n, k = map(int, input().split())
b = []
d=dict()
e=dict()
for i in range(n):
    a, t = map(int, input().split())
    b.append([a,t,i+1])
b.sort(key= lambda x:x[1])
ans = 0
j = 0
curr = 1
currsum = 0
l=0
while(curr<=n):
    if curr-1 in d.keys():
        currsum-=d[curr-1]
        l-=e[curr-1]

    p=0
    while (j < n):
        if b[j][0] >= curr:
            currsum += b[j][1]
            if b[j][0] in d.keys():
                d[b[j][0]]+=b[j][1]
                e[b[j][0]]+=1
            else:
                d[b[j][0]] = b[j][1]
                e[b[j][0]] = 1

            l+=1
        if l==curr:
            j+=1
            break
        j+=1

    if j<=n and l==curr and currsum<=k:
        ans+=1
    else:
        break
    curr+=1
c=[]
j=0
l=0
while(j<n):
    if l==ans:
        break
    if b[j][0] >= ans:
        c.append(b[j][2])
        l+=1
    j+=1

print(ans)
print(ans)
print(*c)
",O(nlogn)
"class Solution(object):
    def resultArray(self, nums):
        a, b = [nums[0]], [nums[1]]
        for i in range(2, len(nums)):
            if a[-1] > b[-1]:
                a.append(nums[i])
            else:
                b.append(nums[i])
        return a+b",O(n)
"n, l, r, x = list(map(int, input().split("" "")))
c = sorted(list(map(int, input().split("" ""))))
ways = 0

for i in range(0, 2 ** n):
    temp = 0
    m = 10 ** 9 + 1
    M = -1
    for j in range(0, n):
        if i & 1 << j:
            temp += c[j]
            m = min(m, c[j])
            M = max(M, c[j])
    if temp >= l and temp <= r and (M - m) >= x:
        ways += 1

print(ways)
",np
"import sys

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()

def iinp(): return int(input())

def nninp(): return map(int, sys.stdin.readline().strip().split())

def llinp(): return list(map(int, sys.stdin.readline().strip().split()))

def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math

import random
from collections import OrderedDict
from fractions import Fraction

n,k=nninp()
s=ssinp()
ans=[]
lb=k//2
rb=k//2
for c in s:
    if(lb>0):
        if(c==""(""):
            lb-=1
        else:
            rb-=1
        ans.append(c)
    elif(rb>0):
        if(c=="")""):
            ans.append(c)
            rb-=1
    elif(lb==0 and rb==0):
        break
p(lts(ans))
",O(n)
"n = int(input())
d1 = {}
for _ in range(n):
  a, x = map(int, input().split())
  d1[a] = x
d2 = {}
m = int(input())
for _ in range(m):
  b, y = map(int, input().split())
  d2[b] = y
ans = 0
for key in set(d1.keys()) | set(d2.keys()):
  ans += max(d1.get(key, 0), d2.get(key, 0))
print(ans)",O(nlogn)
"print(int(input())//2 + 1)
",O(1)
"class Solution2(object):
    def checkIfCanBreak(self, s1, s2):
        return not {1, -1}.issubset(set(cmp(a, b) for a, b in zip(sorted(s1), sorted(s2))))",O(n)
"class Solution(object):
    def minimumArrayLength(self, nums):
        mn = min(nums)
        return (nums.count(mn)+1)//2 if all(x%mn == 0 for x in nums) else 1",O(n)
"class MinIdx_Segtree:
    def __init__(self, N, A):
        self.n = N
        self.INF = int(1e9)
        self.A = A
        while (self.n & (self.n - 1)) != 0:
            self.A.append(self.INF)
            self.n += 1
        self.tree = [0] * (2 * self.n)
        self.build()

    def build(self):
        for i in range(self.n):
            self.tree[self.n + i] = i
        for j in range(self.n - 1, 0, -1):
            a = self.tree[j << 1]
            b = self.tree[(j << 1) + 1]
            if self.A[a] <= self.A[b]:
                self.tree[j] = a
            else:
                self.tree[j] = b

    def update(self, i, val):
        self.A[i] = val
        j = (self.n + i) >> 1
        while j >= 1:
            a = self.tree[j << 1]
            b = self.tree[(j << 1) + 1]
            if self.A[a] <= self.A[b]:
                self.tree[j] = a
            else:
                self.tree[j] = b
            j >>= 1

    def query(self, ql, qh):
        return self._query(1, 0, self.n - 1, ql, qh)

    def _query(self, node, l, h, ql, qh):
        if ql > h or qh < l:
            return self.INF
        if l >= ql and h <= qh:
            return self.tree[node]
        a = self._query(node << 1, l, (l + h) >> 1, ql, qh)
        b = self._query((node << 1) + 1, ((l + h) >> 1) + 1, h, ql, qh)
        if a == self.INF:
            return b
        if b == self.INF:
            return a
        return a if self.A[a] <= self.A[b] else b

class Solution:
    def getMaxArea(self, heights, l, r, st):
        if l > r:
            return 0
        if l == r:
            return heights[l]
        minIdx = st.query(l, r)
        return max(max(self.getMaxArea(heights, l, minIdx - 1, st),
                       self.getMaxArea(heights, minIdx + 1, r, st)),
                   (r - l + 1) * heights[minIdx])

    def largestRectangleArea(self, heights):
        n = len(heights)
        st = MinIdx_Segtree(n, heights)
        return self.getMaxArea(heights, 0, n - 1, st)
",O(nlogn)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()

        def dfs(i, prev):
            if i == len(intervals):
                return 0
            res = dfs(i + 1, prev)
            if prev == -1 or intervals[prev][1] <= intervals[i][0]:
                res = max(res, 1 + dfs(i + 1, i))
            return res

        return len(intervals) - dfs(0, -1)
",O(2 ^ n)
"import operator
from functools import reduce


class Solution(object):
    def getXORSum(self, arr1, arr2):
        return reduce(operator.xor, arr1) & reduce(operator.xor, arr2)",O(n)
"class UnionFind(object): 
    def __init__(self, nums):
        self.set = list(range(len(nums)))
        self.rank = [0]*len(nums)
        self.size = nums[:]

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        self.size[y] += self.size[x]
        return True

    def total(self, x):
        return self.size[self.find_set(x)]



class Solution(object):
    def maximumSegmentSum(self, nums, removeQueries):
        result = [0]*len(removeQueries)
        lookup = [0]*len(nums)
        uf = UnionFind(nums)
        for i in reversed(range(1, len(removeQueries))): 
            q = removeQueries[i]
            lookup[q] = 1
            if q-1 >= 0 and lookup[q-1]:
                uf.union_set(q-1, q)
            if q+1 < len(nums) and lookup[q+1]:
                uf.union_set(q, q+1)
            result[i-1] = max(result[i], uf.total(q))   
        return result",O(n)
"from collections import defaultdict
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
slmii = lambda: sorted(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

def lcm(a, b): return (a * b) // gcd(a, b)

def main():

    n = ii()
    d = defaultdict(int)
    ll = defaultdict(list)
    rr = defaultdict(list)
    llst = []
    rlst = []
    lst = []
    for i in range(n):
        l, r = mii()
        lst.append([l,r])
        llst.append(l)
        rlst.append(r)
        ll[l].append(r)
        rr[r].append(l)
    left = max(llst)
    right = min(rlst)
    lleft = min(ll[left])
    lright = max(rr[right])
    lst.remove([left,lleft])
    pl = max(i[0] for i in lst)
    pr = min(i[1] for i in lst)
    mx = max(0,pr-pl)
    lst.append([left,lleft])
    lst.remove([lright,right])
    pl = max(i[0] for i in lst)
    pr = min(i[1] for i in lst)
    print(max(mx, max(0,pr-pl)))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(n)
"import sys
input=sys.stdin.readline
from math import *

l,r=map(int,input().split())

l=list(bin(l)[2:])
r=list(bin(r)[2:])
l=['0' for i in range(len(r)-len(l))]+l

s=""""
for i in range(len(r)):
    if l[i]==r[i]:
        s+=""0""
    else:
        s+=""1""*(len(r)-i)
        break
print(int(s,2))",O(logn)
"class Solution2(object):
    def rearrangeArray(self, nums):
        nums.sort()
        mid = (len(nums)-1)//2
        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]
        return nums",O(nlogn)
"def ct(s):
    a=[0]*26*2
    for i in s:
        if ord(i)<97:
            a[ord(i)-65]+=1
        else:
            a[ord(i)-97+26]+=1
    return max(a)
n=int(input())
s1=input()
ln=len(s1)
s1=ct(s1)
s2=ct(input())
s3=ct(input())
s=[s1,s2,s3]
for i in range(len(s)):
    if s[i]==ln and n==1: s[i]=ln-1
    else:s[i]=s[i]+n
    if s[i]>ln: s[i]=ln
s1=s[0]
s2=s[1]
s3=s[2]

s.sort()
if s[2]==s[1]:
    print('Draw')
elif s[-1]==s1:
    print('Kuro')
elif s[-1]==s2:
    print('Shiro')
elif s[-1]==s3:
    print('Katie')
",O(n)
"import sys

N, M, K, L = map(int, sys.stdin.readline().split())

if M * (N / M) - K < L:
  print(""-1"")
  sys.exit(0)

def solve(curr):
  return curr * M - K >= L

l = 0
r = N / M
while r - l > 1:
  mid = (r + l) / 2
  if solve(mid):
    r = mid
  else:
    l = mid

print(r)
",O(logn)
"def roll(i,j):
    ways = []
    if j:
        ways.append(2*hor[i][j-1] + grid[i][j-1])
    if m-1-j:
        ways.append(2*hor[i][j] + grid[i][j+1])
    if i:
        ways.append(2*ver[i-1][j] + grid[i-1][j])
    if n-1-i:
        ways.append(2*ver[i][j] + grid[i+1][j])
    return min(ways)

n , m , k = map(int, input().split())
hor = [list(map(int, input().split())) for _ in range(n)]
ver = [list(map(int, input().split())) for _ in range(n-1)]

grid = [[0]*m for _ in range(n)]
if k%2:
    for _ in range(n):
        print("" "".join([""-1""]*m))
else:
    for _ in range(k//2):
        new_grid = [[roll(i,j) for j in range(m)] for i in range(n)]
        grid = new_grid[:]
    for i in range(n):
        print("" "".join(map(str,grid[i])))",O(n ^ 3)
"import collections



class Solution3(object):
    def maxSelectedElements(self, nums):
        nums.sort()
        dp = collections.defaultdict(int)
        for x in nums:
            dp[x+1] = dp[x]+1
            dp[x] = dp[x-1]+1
        return max(dp.values())",O(nlogn)
"class Solution2(object):
    def equationsPossible(self, equations):
        graph = [[] for _ in range(26)]

        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '!':
                if x == y:
                    return False
            else:
                graph[x].append(y)
                graph[y].append(x)

        color = [None]*26
        c = 0
        for i in range(26):
            if color[i] is not None:
                continue
            c += 1
            stack = [i]
            while stack:
                node = stack.pop()
                for nei in graph[node]:
                    if color[nei] is not None:
                        continue
                    color[nei] = c
                    stack.append(nei)

        for eqn in equations:
            if eqn[1] != '!':
                continue
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if color[x] is not None and \
               color[x] == color[y]:
                return False
        return True",O(n)
"class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(gas) < sum(cost):
            return -1

        total = 0
        res = 0
        for i in range(len(gas)):
            total += (gas[i] - cost[i])

            if total < 0:
                total = 0
                res = i + 1

        return res
",O(n)
"import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))

def num():
	return map(int , input().split())

def nu():
	return int(input())

n,m=num()
a=li()
ind=-1
z=0
ll=sorted(a)
mx=ll[n-1]-1
cc=0
for i in range(n-2,-1,-1):
	if (ll[i] == 0):
		continue
	if(mx==0):
		cc += ll[i] - 1
		continue

	if(ll[i]>=mx):
		cc+=1
		mx-=1
		cc+=ll[i]-1
		ll[i]=1
	else:
		mx=ll[i]
		cc+=1
		mx-=1
		cc += ll[i] - 1
		ll[i] = 1

print(cc)",O(nlogn)
"n=int(input())
print('4 %s'%(n-4) if n%2==0 else '9 %s'%(n-9))",O(1)
"n = int(input())
print(n//2+n)",O(1)
"from collections import namedtuple
import sys

HS = namedtuple('HS', 'x1 x2 y')

n, m = [int(w) for w in input().split()]
vs = [int(input()) for _ in range(n)]
hs = [HS(*[int(w) for w in input().split()]) for _ in range(m)]

vs.sort()

hr = len([s for s in hs if s.x1 == 1 and s.x2 == 10**9])
hs = [s.x2 for s in hs if s.x1 == 1 and s.x2 < 10**9]
hs.sort()

r = hc = len(hs)
hi = vi = 0
for hi in range(hc):
    while vi < n and hs[hi] >= vs[vi]:
        vi += 1
    c = (hc - hi - 1) + vi
    if c < r:
        r = c

print(r + hr)
",O(nlogn)
"import sys
import math
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, sys.stdin.readline().strip().split())
def listinput(): return list(map(int, sys.stdin.readline().strip().split()))
n,m=minput()
x=listinput()
y=listinput()
xx=set(x)
yy=set(y)
common=xx.intersection(yy)
for i in x:
    if i in common:
        print(i,end=' ')",O(n ^ 2)
"num=int(input())

b=input()

if b=='0' or b=='1':
    print(b)

else:
    s=len(list(filter(lambda x:x=='0',b)))

    print('1'+'0'*s)",O(n)
"class Solution(object):
    def numberOfWays(self, n, x):
        MOD = 10**9+7

        dp = [0]*(n+1)
        dp[0] = 1
        for i in range(1, n+1):
            i_pow_x = i**x
            if i_pow_x > n:
                break
            for j in reversed(range(i_pow_x, n+1)):
                dp[j] = (dp[j]+dp[j-i_pow_x])%MOD
        return dp[-1]",O(n ^ 2)
"n = int(input())
d = {}
for _ in range(n):
  a, x = map(int, input().split())
  d[a] = x
m = int(input())
for _ in range(m):
  b, y = map(int, input().split())
  d[b] = max(d.get(b, 0), y)
print(sum(d.values()))",O(nlogn)
"from math import gcd

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""right"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\right\n"")

def func(left:int, right:int):
    if left == 1:
        left += 1
    if right - left < 2:
        return -1

    if left & 1:
        if right - left > 2:
            left += 1
            return '{} {} {}'.format(left, left + 1, left + 2)
        else:
            if gcd(left, left + 2) != 1:
                return '{} {} {}'.format(left, left + 1, left + 2)
            return -1
    return '{} {} {}'.format(left, left + 1, left + 2)

def main():
    left, right = map(int, input().split())
    print(func(left, right))
    return

if __name__ == '__main__':
    main()
",O(1)
"class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        def dfs(i, flag):
            if i >= len(nums) or (flag and i == len(nums) - 1):
                return 0

            return max(dfs(i + 1, flag),
                       nums[i] + dfs(i + 2, flag or i == 0))
        return max(dfs(0, True), dfs(1, False))
",O(2 ^ n)
"import sys

from bisect import bisect_right as lb
from collections import deque

from queue import PriorityQueue as pq
from math import *
input_ = lambda: sys.stdin.readline().strip(""\r\n"")
ii = lambda : int(input_())
il = lambda : list(map(int, input_().split()))
ilf = lambda : list(map(float, input_().split()))
ip = lambda : input_()
fi = lambda : float(input_())
ap = lambda ab,bc,cd : ab[bc].append(cd)
li = lambda : list(input_())
pr = lambda x : print(x)
prinT = lambda x : print(x)
f = lambda : sys.stdout.flush()
inv =lambda x:pow(x,mod-2,mod)
mod = 10**9 + 7

n,s = il()

l = s
h = n
ans = n+1

while (l<=h) :
    m = (l+h)//2

    t = 0

    for i in str(m) :
        t += int(i)

    if (m-t >= s) :
        ans = m
        h = m-1
    else :
        l = m+1

print(n-ans+1)
",O(logn)
"n,m=map(int,input().split())
arr=[]
for i in range(m):
  arr.append(list(map(int,input().split())))
k=0;ans=str()
for i in range(n):
  ans+=str(k^1)
  k=k^1
print(ans)
",O(n)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def swimInWater(self, grid):
        n = len(grid)
        positions = [None] * (n**2)
        for i in range(n):
            for j in range(n):
                positions[grid[i][j]] = (i, j)
        directions = ((-1, 0), (1, 0), (0, -1), (0, 1))

        union_find = UnionFind(n**2)
        for elevation in range(n**2):
            i, j = positions[elevation]
            for direction in directions:
                x, y = i+direction[0], j+direction[1]
                if 0 <= x < n and 0 <= y < n and grid[x][y] <= elevation:
                    union_find.union_set(i*n+j, x*n+y)
                    if union_find.find_set(0) == union_find.find_set(n**2-1):
                        return elevation
        return n**2-1",O(n ^ 2)
"n = int(input())
x, y = list(map(int,input().split()))
if x-1+y-1 <= n-x+n-y:
    print('White')
else:
    print('Black')",O(1)
"class Solution(object):
    def topKFrequent(self, nums, k):
        counts = collections.Counter(nums)
        buckets = [[] for _ in range(len(nums)+1)]
        for i, count in counts.items():
            buckets[count].append(i)

        result = []
        for i in reversed(range(len(buckets))):
            for j in range(len(buckets[i])):
                result.append(buckets[i][j])
                if len(result) == k:
                    return result
        return result",O(n)
"n = int(input())
res = []
multiplier = 1
while n > 1:
	new_n = n // 2
	res.extend((multiplier,)*(n-new_n))
	if n == 3:
		multiplier *= 3
	else:
		multiplier *= 2
	n = new_n
res.extend((multiplier,)*n)
print(*res)
",O(n)
"MAX_N = 1000
MOD = 10**9+7
dp = [[0]*MAX_N for _ in range(MAX_N)]
for i in range(len(dp)):
    dp[i][0] = 1
    for j in range(1, i+1):
        dp[i][j] = (dp[i-1][j-1] + dp[i-1][j])%MOD


class Solution(object):
    def numOfWays(self, nums):
        def iter_dfs(nums):
            result = [0]
            stk = [[1, [nums, result]]]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    nums, ret = params
                    if len(nums) <= 2:
                        ret[0] = 1
                        continue
                    left = [v for v in nums if v < nums[0]]
                    right = [v for v in nums if v > nums[0]]
                    ret[0] = dp[len(left)+len(right)][len(left)]
                    ret1, ret2 = [0], [0]
                    stk.append([2, [ret1, ret2, ret]])
                    stk.append([1, [right, ret2]])
                    stk.append([1, [left, ret1]])
                elif step == 2:
                    ret1, ret2, ret = params
                    ret[0] = ret[0]*ret1[0] % MOD
                    ret[0] = ret[0]*ret2[0] % MOD
            return result[0]

        return (iter_dfs(nums)-1)%MOD",O(n ^ 2)
"class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):
        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
            if visited in lookup:
                return lookup[visited]

            mask = 1
            for i in range(maxChoosableInteger):
                if visited & mask == 0:
                    if i + 1 >= desiredTotal or \
                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):
                        lookup[visited] = True
                        return True
                mask <<= 1
            lookup[visited] = False
            return False

        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
            return False

        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})",O(n!)
"class Solution(object):
    def findIndices(self, nums, indexDifference, valueDifference):
        mx_i = mn_i = 0
        for i in range(len(nums)-indexDifference):
            if nums[i] > nums[mx_i]:
                mx_i = i
            elif nums[i] < nums[mn_i]:
                mn_i = i
            if nums[mx_i]-nums[i+indexDifference] >= valueDifference:
                return [mx_i, i+indexDifference]
            if nums[i+indexDifference]-nums[mn_i] >= valueDifference:
                return [mn_i, i+indexDifference]
        return [-1]*2",O(n)
"class Solution(object):
    def pathInZigZagTree(self, label):
        count = 2**label.bit_length()
        result = []
        while label >= 1:
            result.append(label)
            label = ((count//2) + ((count-1)-label)) // 2
            count //= 2
        result.reverse()
        return result",O(logn)
"class Solution(object):
    def losingPlayer(self, x, y):
        return ""Alice"" if min(x, y//4)%2 else ""Bob""",O(1)
"class Solution:
    def isHappy(self, n: int) -> bool:
        slow, fast = n, self.sumOfSquares(n)
        power = lam = 1

        while slow != fast:
            if power == lam:
                slow = fast
                power *= 2
                lam = 0
            fast = self.sumOfSquares(fast)
            lam += 1
        return True if fast == 1 else False

    def sumOfSquares(self, n: int) -> int:
        output = 0

        while n:
            digit = n % 10
            digit = digit ** 2
            output += digit
            n = n // 10
        return output
",O(logn)
"import sys

class ADigitsSequenceEasyEdition:
    def solve(self):
        k = int(input()) + 1
        p = 1
        c = 0
        while c + p * (10 ** p - (10 ** (p - 1) if p > 1 else 0)) < k:
            c += p * (10 ** p - (10 ** (p - 1) if p > 1 else 0))
            p += 1
        k -= c
        bef = (10 ** (p - 1) if p > 1 else 0) + (k - 1) // p
        print(str(bef)[(k - 1) % p], end='')

solver = ADigitsSequenceEasyEdition()
input = sys.stdin.readline

solver.solve()
",O(logn)
"def maxXORInRange(L, R):

	LXR = L ^ R
	msbPos = 0
	while(LXR):

		msbPos += 1
		LXR >>= 1
	maxXOR, two = 0, 1

	while (msbPos):

		maxXOR += two
		two <<= 1
		msbPos -= 1

	return maxXOR

L, R = [int(i) for i in input().split()]
print(maxXORInRange(L, R))
",O(logn)
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    a = list(map(int, input().split()))
    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[i] > a[j]:
                cnt += 1
    even = cnt % 2 == 0
    q = int(input())
    for _ in range(q):
        l, r = map(int, input().split())
        len = r - l + 1
        pairs = len * (len-1) // 2
        if pairs % 2 == 1:
            even = not even
        if even:
            print('even')
        else:
            print('odd')

main()",O(n ^ 2)
"from math import factorial

send = input()
receive = input()

cntP = send.count(""+"")
cntN = send.count(""-"")

cnt1 = receive.count(""+"")
cnt2 = receive.count(""-"")

mark = receive.count(""?"")

total = pow(2, mark)

if cntP < cnt1 or cntN < cnt2:
    valid = 0
else:
    valid = factorial(mark) / factorial(mark - cntP + cnt1) / factorial(cntP - cnt1)
print(f""{valid / total:0.12f}"")
",np
"def solve():
    n = int(input())
    for d in [2,4]:
        if n % d != 0:
            continue
        temp = int((n//d) ** (0.5))
        temp -= 1
        while temp*temp < n//d:
            temp += 1
        if temp*temp == n//d:
            print(""YES"")
            return
    print(""NO"")
for _ in range(int(input())):
    solve()
",O(1)
"x,k = map(int, input().split())
mod = 10 ** 9 + 7
print(0 if x == 0 else (x * pow(2, k + 1, mod) - pow(2, k, mod) + 1 + mod) % mod)
",O(logn)
"import sys

def input():
	return sys.stdin.readline().rstrip()

def input_split():
	return [int(i) for i in input().split()]

x, y, z  = input_split()
arr_x = input_split()
arr_y = input_split()
arr_z = input_split()

x += 1
y += 1
z += 1

lengths = [x,y, z]
arrs = [arr_x, arr_y, arr_z ]

for a in arrs:
	a.sort()

dp = [[[0 for k in range(z)] for j in range(y)] for i in range(x)]

for i in range(1,x):
	for j in range(1,y):

		dp[i][j][0] = dp[i-1][j-1][0] + arr_x[i-1]*arr_y[j-1]

for j in range(1, y):
	for k in range(1, z):

		dp[0][j][k] = dp[0][j-1][k-1] + arr_y[j-1]*arr_z[k-1]

for i in range(1,x):
	for k in range(1,z):

		dp[i][0][k] = dp[i-1][0][k-1] + arr_x[i-1]*arr_z[k-1]

for i in range(1, x):
	for j in range(1, y):
		for k in range(1, z):
			opt1 = dp[i-1][j-1][k] + arr_x[i-1]*arr_y[j-1]
			opt2 = dp[i][j-1][k-1] + arr_y[j-1]*arr_z[k-1]
			opt3 = dp[i-1][j][k-1] + arr_x[i-1]*arr_z[k-1]

			dp[i][j][k] = max(opt1, opt2, opt3)

ans = dp[x-1][y-1][z-1]

print(ans)
",O(n ^ 3)
"n,v = [int(x) for x in input().strip().split("" "")]
if v>=(n-1):
	print(n-1)
else:
	print(n-1+((n-1-v)*(n-v)//2))
",O(1)
"import collections


class Solution(object):
    def findingUsersActiveMinutes(self, logs, k):
        lookup = collections.defaultdict(set)
        for u, t in logs:
            lookup[u].add(t)
        result = [0]*k
        for _, ts in lookup.items():
            result[len(ts)-1] += 1
        return result",O(n)
"import collections


class Solution(object):
    def countVowelSubstrings(self, word):
        VOWELS = set(""aeiou"")
        k = 5
        def atLeastK(word, k):
            cnt = collections.Counter()
            result = left = right = 0
            for i, c in enumerate(word):
                if c not in VOWELS:
                    cnt = collections.Counter()
                    left = right = i+1
                    continue
                cnt[c] += 1
                while len(cnt) > k-1:
                    cnt[word[right]] -= 1
                    if not cnt[word[right]]:
                        del cnt[word[right]]
                    right += 1
                result += right-left
            return result

        return atLeastK(word, k)",O(n)
"import random


class Solution(object):

    def __init__(self, nums):
        self.__nums = nums


    def reset(self):
        return self.__nums


    def shuffle(self):
        nums = list(self.__nums)
        for i in range(len(nums)):
            j = random.randint(i, len(nums)-1)
            nums[i], nums[j] = nums[j], nums[i]
        return nums",O(n)
"class Solution(object):
    def minMovesToCaptureTheQueen(self, a, b, c, d, e, f):
        if a == e and not (a == c and (b-d)*(f-d) < 0):
            return 1
        if b == f and not (b == d and (a-c)*(e-c) < 0):
            return 1
        if c+d == e+f and not (c+d == a+b and (c-a)*(e-a) < 0):
            return 1
        if c-d == e-f and not (c-d == a-b and (d-b)*(f-b) < 0):
            return 1
        return 2",O(1)
"import heapq
class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):
        min_heap = list(zip(startTime, endTime, profit))
        heapq.heapify(min_heap)
        result = 0
        while min_heap:
            s, e, p = heapq.heappop(min_heap)
            if s < e:
                heapq.heappush(min_heap, (e, s, result+p))
            else:
                result = max(result, p)
        return result",O(nlogn)
"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not inorder:
            return None

        root = TreeNode(preorder[0])
        mid = inorder.index(preorder[0])
        root.left = self.buildTree(preorder[1 : mid + 1], inorder[:mid])
        root.right = self.buildTree(preorder[mid + 1 :], inorder[mid + 1 :])
        return root
",O(n ^ 2)
"n,k=map(int,input().split())
low=1
high=n
import sys
while low<=high:
    mid=(low+high)//2
    if mid*(mid+1)//2 -(n-mid)>k:
        high=mid-1
    elif mid*(mid+1)//2-(n-mid)==k:
        print(n-mid)
        sys.exit()
    else :
        low=mid+1",O(logn)
"people,n=map(int,input().split())
a=list(map(int,input().split()))
a.sort()
d={}
tmp=[]
for i in range(n):
    if a[i] in d:
        d[a[i]]+=1
    else:
        d[a[i]]=1
d1={}
for i in d:
    if d[i] in d1:
        d1[d[i]]+=1
    else:
        d1[d[i]]=1
    tmp.append(d[i])
tmp.sort()
ans=0
for i in range(1,10001):
    x=people
    try:
        x-=d1[i]
    except:
        pass
    for j in d1:
        if j>i:
            x-=(j//i)*d1[j]
    if x<=0:
        ans=max(ans,i)
print(ans)",O(nlogn)
"from collections import deque

class Solution(object):

    def __init__(self):
        self.__k = 300
        self.__dq = deque()
        self.__count = 0

    def hit(self, timestamp):
        self.getHits(timestamp)
        if self.__dq and self.__dq[-1][0] == timestamp:
            self.__dq[-1][1] += 1
        else:
            self.__dq.append([timestamp, 1])
        self.__count += 1

    def getHits(self, timestamp):
        while self.__dq and self.__dq[0][0] <= timestamp - self.__k:
            self.__count -= self.__dq.popleft()[1]
        return self.__count",O(1)
"MAX=10**9
def main():

    n,m=readIntArr()
    arrs=[]
    for _ in range(n):
        arrs.append(readIntArr())

    def checkPossible(minB):
        binRepresentations=set()
        for arr in arrs:
            binRepresentations.add(convertToBinary(arr,minB))
        binList=list(binRepresentations)
        ii=jj=-1
        n=len(binList)
        for i in range(n):
            for j in range(i,n):
                if binList[i]|binList[j]==(1<<m)-1:
                    ii=binList[i]
                    jj=binList[j]
        if ii!=-1:
            ansi=ansj=-1
            for i in range(len(arrs)):
                b=convertToBinary(arrs[i],minB)
                if b==ii:
                    ansi=i
                if b==jj:
                    ansj=i

            return (ansi,ansj)
        else:
            return None

    def convertToBinary(arr,minB):
        b=0
        for i in range(m):
            if arr[i]>=minB:
                b|=(1<<i)
        return b

    minB=-1
    i=j=-1
    b=MAX
    while b>0:
        temp=checkPossible(minB+b)
        if temp==None:
            b//=2
        else:
            minB+=b
            i,j=temp
    i+=1;j+=1
    print('{} {}'.format(i,j))

    return

import sys
input=sys.stdin.buffer.readline

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))

def readIntArr():
    return [int(x) for x in input().split()]

def makeArr(*args):

    assert len(args) >= 2, ""makeArr args should be (default value, dimension 1, dimension 2,...""
    if len(args) == 2:
        return [args[0] for _ in range(args[1])]
    else:
        return [makeArr(args[0],*args[2:]) for _ in range(args[1])]

def queryInteractive(x,y):
    print('? {} {}'.format(x,y))
    sys.stdout.flush()
    return int(input())

def answerInteractive(ans):
    print('! {}'.format(ans))
    sys.stdout.flush()

inf=float('inf')
MOD=10**9+7

for _abc in range(1):
    main()",np
"import sys

input = sys.stdin.readline

def intersection(segs):
    end = float('inf')
    start = - float('inf')
    for l, r in segs:
        end = min(end, r)
        start = max(start, l)
    return start, end

def solve():
    n = int(input())
    segs = [tuple([int(x) for x in input().split(' ')]) for s in range(n)]
    starts = {}
    ends = {}
    x = intersection(segs)
    for l, r in segs:
        if r in starts:
            starts[r] = max(starts[r], l)
        else:
            starts[r] = l
        if l in ends:
            ends[l] = min(ends[l], r)
        else:
            ends[l] = r

    b = segs.copy()
    b.remove((x[0], ends[x[0]]))
    y = intersection(b)

    c = segs.copy()
    c.remove((starts[x[1]], x[1]))
    z = intersection(c)

    return max(x[1] - x[0], y[1] - y[0], z[1] - z[0], 0)

print(solve())
",O(n)
"import math
EPS = 1e-6

hhh = None

def solve():
    n, M = [int(x) for x in input().split()]

    if out_of_solution_bounds(n, M):
        print('No')
        return

    b = find_optimal_b(n, M)

    heights = fast_find_optimal_height_distribution(n, M, b)
    parents = build_tree(n, b, heights)
    print('Yes')
    print(*parents[1:])

def out_of_solution_bounds(n, M):
    return M < 2*n - 1 or (n * (n+1)) // 2 < M

def find_optimal_b(n, M):
    begin = 1
    end = n
    while begin != end:
        mid = (begin + end) // 2
        if get_min_H_given_b(n, mid) <= M:
            end = mid
        else:
            begin = mid + 1
    b = end
    return b

def get_min_H_given_b(n, b):
    if b == 1: return (n*(n+1)) // 2
    m = math.floor(math.log((b-1)*n+1) / math.log(b) + EPS)
    nl = round((b**m - 1) / (b - 1))
    return (m*b**(m+1) - (m+1)*b**m + 1) // (b - 1)**2 + (m+1) * (n - nl)

def fast_find_optimal_height_distribution(n, M, b):
    begin = 0
    end = n+1
    H_fn = lambda L : (L*(L+1))//2 + get_min_H_given_b(n - L, b) + (L > 0)*(n - L)

    while begin != end:
        mid = (begin + end) // 2
        if H_fn(mid) <= M:
            begin = mid + 1
        else:
            end = mid
    L = begin - 1

    if L == n:
        return [1 for _ in range(n)]

    unif_branch_h = uniform_height_distribution(n - L, b)
    if L == 0:
        h = unif_branch_h
    else:
        h = [int(i < L) for i in range(n)]
        for i, x in enumerate(unif_branch_h, 1):
            h[i] += x

    return locally_increase_H(h, M, b)

def uniform_height_distribution(n, b):
    h = [0 for _ in range(n)]
    h[0] = 1
    i = 0
    to_fill = n-1
    while to_fill > 0:
        i += 1
        h[i] = min(b*h[i-1], to_fill)
        to_fill -= h[i]
    return h

def locally_increase_H(h, M, b):
    i = 1
    while not (b * (h[i-1]) >= (h[i] - 1) and b * (h[i] - 1) >= (h[i+1] + 1)):
        i += 1

    H = sum(i*x for i, x in enumerate(h, 1))
    while H < M:
        if b * (h[i-1] - 1) >= (h[i] + 1):
            i -= 1
        else:
            while not b * (h[i] - 1) >= (h[i+1] + 1):
                i += 1
        h[i] -= 1
        h[i+1] += 1
        H += 1

    return h

def build_tree(n, b, h):
    p = [None for _ in range(n)]
    p[0] = 1

    i = 1
    j = 0
    for k in range(1, n):
        if j == h[i]:
            i += 1
            j = 0
        p[k] = k - j - h[i-1] + (j // b) + 1
        j += 1
    return p

if __name__ == '__main__':
    solve()
",O(n)
"class Solution(object):
    def divideArray(self, nums, k):
        nums.sort()
        return [nums[i:i+3] for i in range(0, len(nums), 3)] if all(nums[i+2]-nums[i] <= k for i in range(0, len(nums), 3)) else []",O(nlogn)
"from sys import stdin,stdout
from itertools import accumulate
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int,stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    a=lst()
    a.sort()
    s = set()
    for v in a:
        if (v % k != 0) or v // k not in s:
            s.add(v)
    print(len(s))",O(nlogn)
"n = int(input())
a = sorted(list(map(int,input().split())))
bal = 0
if a.count(0)>1:
    print('cslnb')
    exit()
if n-len(set(a))>1:
    print('cslnb')
    exit()
if n-len(set(a))==1:
    for i in range(1,n):
        if a[i]==a[i-1]:
            if a[i]-1 in a:
                print('cslnb')
                exit()
            break
if n==1:
    print('cslnb' if not a[0] % 2 else 'sjfnb')
    exit()

for i in range(n):
    bal+=a[i]-i
print('sjfnb'if bal%2 else 'cslnb')",O(nlogn)
"cards=list(input().split())
lm=[0]*9
lp=[0]*9
ls=[0]*9
for item in cards:
    if item[1]=='m':
        lm[int(item[0])-1]+=1
    elif item[1]=='p':
        lp[int(item[0])-1]+=1
    else :
        ls[int(item[0])-1]+=1
if max(lm)==3 or max(lp)==3 or max(ls)==3:
    print(0)
else :
    flag=0
    def seq_checker(li):
        flag=0
        for i in range(9):
            if flag==0:
                if lm[i]==1:
                    flag=1
            else :
                if lm[i]==1:
                    flag+=1
                else :
                    break
        return flag
    if seq_checker(lm)==3 or seq_checker(lp)==3 or seq_checker(ls)==3:
        print(0)
    elif max(lm)==2 or max(lp)==2 or max(ls)==2:
        print(1)
    else :
        m=0
        for i in range(0,7):
            m=max(sum(lm[i:i+3]),sum(lp[i:i+3]),sum(ls[i:i+3]),m)
        print(3-m)",O(n)
"import collections


class Solution(object):
    def findLucky(self, arr):
        count = collections.Counter(arr)
        result = -1
        for k, v in count.items():
            if k == v:
                result = max(result, k)
        return result",O(n)
"class Solution(object):
    def distanceTraveled(self, mainTank, additionalTank):
        USE, REFILL, DIST = 5, 1, 10
        cnt = min((mainTank-REFILL)//(USE-REFILL), additionalTank)
        return (mainTank+cnt*REFILL)*DIST",O(1)
"class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        result, local_max = 0, 0
        for n in nums:
            local_max = (local_max + 1 if n else 0)
            result = max(result, local_max)
        return result",O(n)
"class Solution(object):
    def arraysIntersection(self, arr1, arr2, arr3):
        result = []
        i, j, k = 0, 0, 0
        while i != len(arr1) and j != len(arr2) and k != len(arr3):
            if arr1[i] == arr2[j] == arr3[k]:
                result.append(arr1[i])
                i += 1
                j += 1
                k += 1
            else:
                curr = max(arr1[i], arr2[j], arr3[k])
                while i != len(arr1) and arr1[i] < curr:
                    i += 1
                while j != len(arr2) and arr2[j] < curr:
                    j += 1
                while k != len(arr3) and arr3[k] < curr:
                    k += 1
        return result",O(n)
"import os,sys;from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno();self.buffer = BytesIO();self.writable = ""x"" in file.mode or ""r"" not in file.mode;self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:break
            ptr = self.buffer.tell();self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE));self.newlines = b.count(b""\n"") + (not b);ptr = self.buffer.tell();self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:os.write(self._fd, self.buffer.getvalue());self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file);self.flush = self.buffer.flush;self.writable = self.buffer.writable;self.write = lambda s: self.buffer.write(s.encode(""ascii""));self.read = lambda: self.buffer.read().decode(""ascii"");self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
try:sys.stdin,sys.stdout=open('in.txt','r'),open('out.txt','w')
except:pass
ii1=lambda:int(sys.stdin.readline().strip())
is1=lambda:sys.stdin.readline().strip()
iia=lambda:list(map(int,sys.stdin.readline().strip().split()))
isa=lambda:sys.stdin.readline().strip().split()

from functools import lru_cache
from collections import defaultdict
from math import inf

n,m,k = iia()
A = [[0] * (m) for _ in range(n)]
B = [[0] * (m) for _ in range(n)]
for i in range(n):
    tmp = iia()
    for j in range(m - 1):
        A[i][j + 1] = tmp[j]
for i in range(n - 1):
    tmp = iia()
    for j in range(m):
        B[i + 1][j] = tmp[j]

if k%2:
    [print(*[-1]*m) for i in range(n)]
    sys.exit()
ans = [[0] * m for _ in range(n)]
lim = k // 2
dp = [[[inf] * (lim + 1) for _ in range(m)] for _ in range(n)]
for i in range(n):
    for j in range(m):
        dp[i][j][0] = 0

for k in range(1, lim + 1):
    for i in range(n):
        for j in range(m):
            if i: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + B[i][j])
            if j: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + A[i][j])
            if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + B[i + 1][j])
            if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + A[i][j + 1])
for i in range(n):
    for j in range(m):
        ans[i][j] = dp[i][j][-1] * 2
[print(*a) for a in ans]",O(n ^ 3)
"class Solution(object):
    def evenOddBit(self, n):
        def popcount(x):
            return bin(x)[2:].count('1')

        return [popcount(n&0b0101010101), popcount(n&0b1010101010)]",O(1)
"q = int(input())
for i in range(q):
    l, r = map(int, input().split())
    if l % 2 == 0:
        count = -((r - l + 1) // 2)
    else:
        count = ((r - l + 1) // 2)
    if (r - l + 1) % 2 == 0:
        print(count)
    else:
        if r % 2 == 0:
            print(count + r)
        else:
            print(count - r)",O(1)
"class Solution(object):
    def productExceptSelf(self, nums):
        if not nums:
            return []

        left_product = [1 for _ in range(len(nums))]
        for i in range(1, len(nums)):
            left_product[i] = left_product[i - 1] * nums[i - 1]

        right_product = 1
        for i in range(len(nums) - 2, -1, -1):
            right_product *= nums[i + 1]
            left_product[i] = left_product[i] * right_product

        return left_product",O(n)
"import sys

sys.setrecursionlimit(10**5)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def LI1(): return list(map(int1, sys.stdin.buffer.readline().split()))
def LLI1(rows_number): return [LI1() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
inf = 10**16

n, md = LI()

def nHr(hn, hr):
    return nCr(hn+hr-1, hr-1)

def nPr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_n-com_r]%md

def nCr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_r]%md*ifac[com_n-com_r]%md

n_max = 405
fac = [1]
for i in range(1, n_max+1): fac.append(fac[-1]*i%md)
ifac = [1]*(n_max+1)
ifac[n_max] = pow(fac[n_max], md-2, md)
for i in range(n_max-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%md
pw = [1]
for i in range(400): pw.append(pw[-1]*2%md)

dp = [[0]*(n//2+2) for _ in range(n+2)]
dp[0][0] = 1
for i in range(1, n+2):
    for j in range(1, n//2+2):
        v = 0
        for k in range(i-2, -1, -1):
            v += dp[k][j-1]*pw[i-k-2]*nCr(i-j, i-k-1)%md
        dp[i][j] = v%md

ans = sum(dp[-1])%md
print(ans)
",O(n ^ 3)
"class Solution(object):
    def interpret(self, command):
        result, i = [], 0
        while i < len(command):
            if command[i] == 'G':
                result += [""G""]
                i += 1
            elif command[i] == '(' and command[i+1] == ')':
                result += [""o""]
                i += 2
            else:
                result += [""al""]
                i += 4
        return """".join(result)",O(n)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        def dfs(i):
            if i == len(nums) - 1:
                return True
            end = min(len(nums) - 1, i + nums[i])
            for j in range(i + 1, end + 1):
                if dfs(j):
                    return True
            return False

        return dfs(0)
",O(n!)
"from sys import stdin
from math import factorial

n, mod = map(int, stdin.readline().split())

def binom(n, m):
    return factorial(n) // factorial(m) // factorial(n-m)

def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):
        sign = 1 if (i-k)%2 == 0 else -1
        ans += sign * binom(k, i) * (i**x)
        ans %= mod
    return ans

def f(x, k):
    return (foo(x, k) * pow(2, x-k, mod)) % mod

ans = 0
for i in range((n+1)//2):
    ans = (ans + f(n-i, i+1))
    ans %= mod
print(ans)
",O(n ^ 2)
"class Solution2(object):
    def grayCode(self, n):
        return [i >> 1 ^ i for i in range(1 << n)]",O(2 ^ n)
"n,k=map(int,input().strip().split())
d=(n-k)//2+1
x=['1' if (i+1)%d==0 else '0' for i in range(n)]
print(''.join(x))",O(n)
"import sys
input = sys.stdin.readline
from math import ceil, floor, factorial;

def swaparr(arr, a,b):
    temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp

def gcd(a,b):
    if a == 0:
        return b
    return gcd(b%a, a)

def nCr(n, k):
    if(k > n - k):
        k = n - k
    res = 1
    for i in range(k):
        res = res * (n - i)
        res = res / (i + 1)
    return int(res)

def upper_bound(a, x, lo=0):
    hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if a[mid] < x:
            lo = mid+1
        else:
            hi = mid
    return lo

def primefs(n):

    primes = {}
    while(n%2 == 0):
        primes[2] = primes.get(2, 0) + 1
        n = n//2
    for i in range(3, int(n**0.5)+2, 2):
        while(n%i == 0):
            primes[i] = primes.get(i, 0) + 1
            n = n//i
    if n > 2:
        primes[n] = primes.get(n, 0) + 1

    return primes

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0) :
        return 0
    while (y > 0) :
        if ((y & 1) == 1) :
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def swap(a,b):
    temp = a
    a = b
    b = temp
    return a,b

def find(x, link):
    p = x;
    while( p != link[p]):
        p = link[p];

    while( x != p):
        nex = link[x];
        link[x] = p;
        x = nex;
    return p;

def union(x, y, link, size):
    x = find(x, link)
    y = find(y, link)
    if size[x] < size[y]:
        x,y = swap(x,y)
    if x != y:
        size[x] += size[y]
        link[y] = x

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

MAXN = int(1e6 + 5)
def spf_sieve():
    spf[1] = 1;
    for i in range(2, MAXN):
        spf[i] = i;
    for i in range(4, MAXN, 2):
        spf[i] = 2;
    for i in range(3, ceil(MAXN ** 0.5), 2):
        if spf[i] == i:
            for j in range(i*i, MAXN, i):
                if spf[j] == j:
                    spf[j] = i;

def factoriazation(x):
    ret = {};
    while x != 1:
        ret[spf[x]] = ret.get(spf[x], 0) + 1;
        x = x//spf[x]
    return ret

def int_array():
    return list(map(int, input().strip().split()))

def str_array():
    return input().strip().split();

MOD = int(1e9)+7;
CMOD = 998244353;
INF = float('inf'); NINF = -float('inf');

n, l, r, x = int_array(); a = sorted(int_array());
ans = 0;
for mask in range( 1 << n):
    mx = NINF; mn = INF; sub = 0;
    for i in range(n):
        if (1 << i) & mask:
            sub += a[i];
            mx = max(mx, a[i]);
            mn = min(mn, a[i]);
    if sub >= l and sub <= r:
        if mx - mn >= x:
            ans += 1;
print(ans);",np
"import sys
n,d,k=map(int,input().split())
if(n<=d):
    print('NO')
    sys.exit()
if(k==1 and n>2):
    print('NO')
    sys.exit()

edgestot=[]
edges=[[] for i in range(n)]
tovisit=[]
for i in range(d):
    edgestot.append([i,i+1])
    tovisit.append([i+1,min(i+1,d-i-1)])
    edges[i].append(i+1)
    edges[i+1].append(i)
cur=d+1
while(cur<n and len(tovisit)>0):
    x=tovisit.pop()
    if(x[1]==0):
        continue
    while(len(edges[x[0]])<k and cur<n):
        tovisit.append([cur,x[1]-1])
        edgestot.append([cur,x[0]])
        edges[x[0]].append(cur)
        edges[cur].append(x[0])
        cur+=1

if(len(edgestot)==n-1):
    print('YES')
    for i in range(n-1):
        print(edgestot[i][0]+1,edgestot[i][1]+1)

else:
    print('NO')
",O(n ^ 2)
"import sys
def ask(x,y,rev):
	if (rev==0):
		print(""? %d %d""%(x,y))
	else:
		print(""? %d %d""%(y,x))
	sys.stdout.flush()
	if (rev==1):
		return -int(input())
	else:
		return int(input())

comp=ask(0,0,0)
nowa=0
nowb=0
rev=0
for i in range(29,-1,-1):
	if (comp<0):
		rev^=1
		nowa,nowb=nowb,nowa
		comp=-comp
	if comp>=0:
		comp=ask(nowa|(1<<i),nowb|(1<<i),rev)
		if (comp<0):
			nowa|=1<<i
			comp=ask(nowa,nowb,rev)
		else:
			tmp=ask(nowa|(1<<i),nowb,rev)
			if (tmp<0):
				nowa|=1<<i
				nowb|=1<<i
if (rev==1):
	nowa,nowb=nowb,nowa
print(""! %d %d""%(nowa,nowb))
",O(logn)
"class Solution(object):
    def resultsArray(self, nums, k):
        result = [-1]*(len(nums)-k+1)
        left = 0
        for right in range(len(nums)):
            if nums[right]-nums[left] != right-left:
                left = right
            if right-left+1 == k:
                result[left] = nums[right]
                left += 1
        return result",O(n)
"n,m,a,b = map(int,input().split())

if n%m==0:
    print(0)
else:
    k = n%m
    print(min(k*b,(m-k)*a))",O(n)
"class Solution(object):
    def numWays(self, n, k):
        if n == 0:
            return 0
        elif n == 1:
            return k
        ways = [0] * 3
        ways[0] = k
        ways[1] = (k - 1) * ways[0] + k
        for i in range(2, n):
            ways[i % 3] = (k - 1) * (ways[(i - 1) % 3] + ways[(i - 2) % 3])
        return ways[(n - 1) % 3]",O(n)
"class Solution(object):
    def doubleIt(self, head):
        if head.val >= 5:
            head = ListNode(0, head)
        curr = head
        while curr:
            curr.val = (curr.val*2)%10
            if curr.__next__ and curr.next.val >= 5:
                curr.val += 1
            curr = curr.__next__
        return head",O(n)
"l,r=map(int,input().split())
if(l==r):
    print(0)
else:
    if(r&(r-1)==0):
        print(r^(r-1))
    else:
        x=l^r
        p=1
        while(p<=x):
            p*=2
        print(p-1)",O(logn)
"
import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    return students.astype({""grade"" : int})
",O(n)
"R, G, B = map(int, input().split())
L = [sorted(map(int, input().split())) for _ in range(3)]

DP = [0] * ((R+1) * (G+1) * (B+1))
def idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b

for r in range(R+1):
	for g in range(G+1):
		for b in range(B+1):
			best = 0

			if r:
				if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]
				if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])

			if g and b:
				best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])

			DP[idx(r, g, b)] = best

print(max(DP))",O(n ^ 3)
"def solve(n, p, s):
    p.append((0, 0))
    p.sort()
    t = 0
    while p:
        x = p.pop()
        s, t = x[0], max(x[1], t + abs(s - x[0]))
    return t

n, s = [int(x) for x in input().split(' ')]
p = [tuple([int(x) for x in input().split(' ')]) for r in range(n)]

print(solve(n, p, s))",O(n)
"class Solution(object):
    def dailyTemperatures(self, temperatures):
        result = [0] * len(temperatures)
        stk = []
        for i in range(len(temperatures)):
            while stk and \
                  temperatures[stk[-1]] < temperatures[i]:
                idx = stk.pop()
                result[idx] = i-idx
            stk.append(i)
        return result",O(n)
"class Solution(object):
    def countSubstrings(self, s):
        def manacher(s):
            s = '
            P = [0] * len(s)
            C, R = 0, 0
            for i in range(1, len(s) - 1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P
        return sum((max_len+1)//2 for max_len in manacher(s))",O(n)
"n = int(input())
l = list(map(int,input().split()))
i = 0
p = []
while 2**i <= 10**18:
    p.append(2**i)
    i = i+1

d = {}
s = set()
for i in l:
    s.add(i)
    if i in d:
        d[i] += 1

    else:
        d[i] = 1

z = set()
for i in s:
    f = 1
    for j in p:
        e = j-i
        if e in s:
            if e == i and d[e] == 1:
                continue

            f = 0
            break

    if f:
        z.add(i)

ans = 0
for i in z:
    ans += d[i]

print(ans)",O(nlogn)
"import sys

int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def LI1(): return list(map(int1, sys.stdin.readline().split()))
def LLI1(rows_number): return [LI1() for _ in range(rows_number)]
def SI(): return sys.stdin.readline().rstrip()
inf = 10**16
md = 10**9+7

n, k = LI()
s = [-1 if c == ""?"" else ord(c)-97 for c in SI()]

def ok(m):
    nxt = [[n]*(n+1) for _ in range(k)]
    for j in range(k):
        cnt = 0
        ni = n
        nxtj = nxt[j]
        for i in range(n)[::-1]:
            if s[i] == -1 or s[i] == j: cnt += 1
            else: cnt = 0
            if cnt >= m: ni = i
            nxtj[i] = ni
    dp = [n+1]*(1 << k)
    dp[0] = 0
    for bit in range(1 << k):
        l = dp[bit]
        if l+m > n: continue
        for j in range(k):
            if bit >> j & 1: continue
            i = nxt[j][l]
            if i+m <= n:
                nbit = bit | 1 << j
                dp[nbit] = min(dp[nbit], i+m)
    return dp[-1] <= n

l, r = 0, n//k+1
while l+1 < r:
    m = (l+r)//2
    if ok(m): l = m
    else: r = m

print(l)
",np
"from math import factorial

def calc_arrangement(n, m):
    return(factorial(n) / factorial(n - m))

def calc_combination(n, m):
    return(calc_arrangement(n, m) / factorial(m))

str1 = list(input())
str2 = list(input())

n = 0
diff = 0

for i in range(len(str1)):
	if str1[i] == '+':
		diff += 1
	else:
		diff -= 1
	if str2[i] == '+':
		diff -= 1
	elif str2[i] == '-':
		diff += 1
	else:
		n += 1

if n == 0:
	if diff == 0:
		print(1.0)
	else:
		print(0.0)
elif n < abs(diff):
	print(0.0)
else:
	res = calc_combination(n, (n - diff) / 2) * (0.5 ** n)
	print(res)
",np
"input = __import__('sys').stdin.readline

n,m,k = map(int, input().split())
hor = [[int(x) for x in input().split()] for _ in ' ' * n]
ver = [[int(x) for x in input().split()] for _ in ' ' * (n - 1)]

if k % 2:
  for i in ' ' * n: print('-1 ' * m)
  exit()

mtx_old = [[0] * m for _ in ' ' * n]

def neighbours(x, y):
  a = 1e18
  b = 1e18
  c = 1e18
  d = 1e18
  if x > 0: a = hor[y][x - 1] * 2 + mtx_old[y][x - 1]
  if x < m - 1: b = hor[y][x] * 2 + mtx_old[y][x + 1]
  if y > 0: c = ver[y - 1][x] * 2 + mtx_old[y - 1][x]
  if y < n - 1: d = ver[y][x] * 2 + mtx_old[y + 1][x]
  return min(a, b, c, d)

for i in range(k // 2):
  mtx_new = [[0] * m for _ in ' ' * n]

  for x in range(m):
    for y in range(n):
      mtx_new[y][x] = neighbours(x, y)

  mtx_old = mtx_new

for row in mtx_old: print(*row)",O(n ^ 3)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if self.isSafe(r, c, board):
                    board[r][c] = ""Q""
                    backtrack(r + 1)
                    board[r][c] = "".""

        backtrack(0)
        return res

    def isSafe(self, r: int, c: int, board):
        row = r - 1
        while row >= 0:
            if board[row][c] == ""Q"":
                return False
            row -= 1

        row, col = r - 1, c - 1
        while row >= 0 and col >= 0:
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col -= 1

        row, col = r - 1, c + 1
        while row >= 0 and col < len(board):
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col += 1
        return True
",O(n!)
"class Solution(object):
    def countPalindromicSubsequence(self, s):
        first, last = [len(s)]*26, [-1]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        return sum(len(set(s[i] for i in range(first[c]+1, last[c]))) for c in range(26))",O(n)
"import sys, math

def mp():
    return list(map(int, input().split()))

def quer(x1, y1, x2, y2):
    if x1 > x2 or y1 > y2:
        return [0, 0]
    s = (x2 - (x1 - 1)) * (y2 - (y1 - 1))
    if s % 2 == 0:
        return [s // 2, s // 2]
    if (x1 + y1) & 1:
        return [s // 2 + 1, s // 2]
    return [s // 2, s // 2 + 1]

def main():
    q = int(input())
    for i in range(q):
        n, m = mp()
        x1, y1, x2, y2 = mp()
        s = quer(1, 1, n, m)
        s1 = quer(x1, y1, x2, y2)
        s[0] -= s1[0]
        s[1] += s1[0]

        x3, y3, x4, y4 = mp()
        xmn = max(x1, x3)
        xmx = min(x2, x4)
        ymn = max(y1, y3)
        ymx = min(y2, y4)
        s1 = quer(x3, y3, x4, y4)
        s[0] += s1[1]
        s[1] -= s1[1]
        s1 = quer(xmn, ymn, xmx, ymx)
        s[0] += s1[0]
        s[1] -= s1[0]
        print(*s[::-1])

debug = 0
if debug:
    file = open(""input.txt"", ""r"")
    input = file.readline
main()
if debug:
    file.close()",O(1)
"from collections import deque
from sys import stdin, stderr
lines = deque(line.strip() for line in stdin.readlines())

def nextline():
    return lines.popleft()

def types(cast, sep=None):
    return tuple(cast(x) for x in strs(sep=sep))

def ints(sep=None):
    return types(int, sep=sep)

def strs(sep=None):
    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))

def signum(n):
    return 1 if n > 0 else 0 if n == 0 else -1

def range_includes(i, j):
    s = signum(j - i)
    return range(i, j + s, s)

def main():

    first = ints()
    aCoords = tuple(first[i:i+2] for i in range(0, 8, 2))
    minX = min(aCoord[0] for aCoord in aCoords)
    minY = min(aCoord[1] for aCoord in aCoords)
    maxX = max(aCoord[0] for aCoord in aCoords)
    maxY = max(aCoord[1] for aCoord in aCoords)
    def inFirst(x, y):
        return x >= minX and x <= maxX and y >= minY and y <= maxY

    second = ints()
    bCoords = tuple(second[i:i+2] for i in range(0, 8, 2))
    minSum = min(sum(bCoord) for bCoord in bCoords)
    maxSum = max(sum(bCoord) for bCoord in bCoords)
    minDiff = min(bCoord[0] - bCoord[1] for bCoord in bCoords)
    maxDiff = max(bCoord[0] - bCoord[1] for bCoord in bCoords)
    def inSecond(x, y):
        return x + y >= minSum and x + y <= maxSum and x - y >= minDiff and x - y <= maxDiff

    for aCoord in aCoords:
        if inSecond(*aCoord):
            return True
    for i in range(-1, 3):
        c1 = bCoords[i]
        c2 = bCoords[i + 1]
        for x, y in zip(range_includes(c1[0], c2[0]), range_includes(c1[1], c2[1])):
            if inFirst(x, y):
                return True
    return False

if __name__ == '__main__':
    print(""YES"" if main() else ""NO"")
",O(1)
"class Solution2(object):
    def fallingSquares(self, positions):
        index = set()
        for left, size in positions:
            index.add(left)
            index.add(left+size-1)
        index = sorted(list(index))
        tree = SegmentTree(len(index), max, max, 0)
        max_height = 0
        result = []
        for left, size in positions:
            L, R = bisect.bisect_left(index, left), bisect.bisect_left(index, left+size-1)
            h = tree.query(L, R) + size
            tree.update(L, R, h)
            max_height = max(max_height, h)
            result.append(max_height)
        return result",O(nlogn)
"class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        numSet = set(nums)
        longest = 0

        for num in numSet:
            if (num - 1) not in numSet:
                length = 1
                while (num + length) in numSet:
                    length += 1
                longest = max(length, longest)
        return longest
",O(n)
"class Solution(object):
    def mySqrt(self, x):
        if x < 2:
            return x

        left, right = 1, x // 2
        while left <= right:
            mid = left + (right - left) // 2
            if mid > x / mid:
                right = mid - 1
            else:
                left = mid + 1

        return left - 1",O(logn)
"
import itertools



class Solution(object):
    def minCost(self, arr, brr, k):
        def cost():
            return sum(abs(x-y) for x, y in zip(arr, brr))

        result = cost()
        arr.sort()
        brr.sort()
        result = min(result, k+cost())
        return result
",O(nlogn)
"def comp(arr):
    for i in range(len(arr)-1):
        for j in range(0, len(arr)-i-1):
            if(arr[j] in arr[j+1]):
                arr[j], arr[j+1] = arr[j+1], arr[j]

    return arr[::-1]

t = int(input())
ans = 1
arr = []
for j in range(t):
    arr.append(input())

arr = comp(arr);

for j in range(0,t-1):
    if arr[j] not in arr[j+1]:
        ans = 0
        break;

if(ans == 0):
    print(""NO"")

else:
    print(""YES"")
    for j in arr:
        print(j)
",O(nlogn)
"k=int(input())
x=0
c=0
while(x<k):
    x+=9*(10**c)*(c+1)
    c+=1
p=(x-k)%c
k=((10**c)-int(((x-k)/c))-1)
k=str(k)
print(k[len(k)-(p)-1])",O(1)
"n = int(input())

x, y = map(int, input().split())

ans = (x - 1) + (y - 1) <= (n - x) + (n - y)
print('White' if ans else 'Black')
",O(1)
"class Solution(object):
    def numberOfCombinations(self, num):
        MOD = 10**9+7
        def find_longest_common_prefix(num):
            lcp = [[0]*(len(num)+1) for _ in range(len(num)+1)] 
            for i in reversed(range(len(lcp)-1)):
                for j in reversed(range(len(lcp[0])-1)):
                    if num[i] == num[j]:
                        lcp[i][j] = lcp[i+1][j+1]+1
            return lcp

        def is_less_or_equal_to_with_same_length(num, lcp, i, j, l):
            return lcp[i][j] >= l or num[i+lcp[i][j]] < num[j+lcp[i][j]]

        lcp = find_longest_common_prefix(num)
        dp = [[0]*len(num) for _ in range(len(num))] 
        dp[0][0] = int(num[0] != '0')
        for i in range(1, len(num)):
            dp[i][i] = dp[i-1][i-1]
            if num[i] == '0':
                continue
            accu = 0
            for l in range(len(num)-i+1):
                ni = i+l-1
                dp[ni][l-1] = accu 
                if i-l < 0:
                    continue
                if num[i-l] != '0' and is_less_or_equal_to_with_same_length(num, lcp, i-l, i, l):
                    dp[ni][l-1] = (dp[ni][l-1] + dp[i-1][l-1]) % MOD
                accu = (accu + dp[i-1][l-1]) % MOD
        return reduce(lambda total, x: (total+x)%MOD, dp[-1], 0)",O(n ^ 2)
"class Solution(object):
    def numberOfLines(self, widths, S):
        result = [1, 0]
        for c in S:
            w = widths[ord(c)-ord('a')]
            result[1] += w
            if result[1] > 100:
                result[0] += 1
                result[1] = w
        return result",O(n)
"n,k = map(int,input().split())
r = 0
for _ in range(n):
    h,m = map(int,input().split())
    t = 60*h+m
    if(t>r+k):
        break
    r = t+k+1
print(r//60,r%60)",O(n)
"T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889)
k = int(input())
a = 0
for i in T:
    if i - k > 0:
        a = T.index(i)
        break
temp = T[a] - k
x = temp % a
res = (10 ** a) - 1 - int(temp / a)
ans = int((res % (10 ** (x+1))) / (10 ** x))
print(ans)
",O(1)
"from sys import stdin, stdout

def binary_exp(x,n,prime):
	if n==0:
		return 1
	elif n==1:
		return x%prime
	else:
		temp=binary_exp(x,n//2,prime)
		temp=(temp*temp)%prime
		if n%2==0:
			return temp
		else:
			return ((x%prime)*temp)%prime

x,k = map(int, stdin.readline().rstrip().split())
if x==0:
	print(0)
else:
	val1=binary_exp(2,k+1,1000000007)
	val2=binary_exp(2,k,1000000007)
	val1=val1%1000000007
	val2=val2%1000000007

	ans=((val1*(x%1000000007))%1000000007 -(val2-1)%1000000007)%1000000007
	print(ans)",O(logn)
"string = input()
size = len(string)

ans_got = 0
for s in range(1,size)[::-1]:
    dic = {}
    for i in range(0,size-s+1):
        if(string[i:i+s] in dic):
            print(s)
            ans_got = 1
            break
        else:
            dic[string[i:i+s]] = 1
    if(ans_got == 1):
        break
if(ans_got == 0):
    print(0)",O(n ^ 3)
"MOD = int(1e9 + 7)
x, k = map(int, input().split())
if x == 0: print(0)
else: print((x * pow(2, k+1, MOD) - pow(2, k, MOD) + 1) % MOD)",O(logn)
"import math
def maxor(bawah, atas):
	if bawah == atas:
		return 0
	xor = bawah^atas
	pangkat2 = math.log(xor, 2)
	return 2**int(math.floor(pangkat2)+1) - 1
a=input().split()
print(maxor(int(a[0]),int(a[1])))",O(logn)
"N, K = input().split()
N, K = int(N), int(K)
P = [int(x) for x in input().split()]
A = [None]*256
A[0] = 0
for i in range(N):
    pn = P[i]
    if A[pn] is None:
        for j in range(K-1, -1, -1):
            if pn < j: continue
            if A[pn-j] is None:
                A[pn-j] = pn-j
                break
            else:
                if A[pn-j] + K - 1 >= pn:
                    break
        for jj in range(j, -1, -1):
            A[pn-jj] = A[pn-j]
print(*[A[P[i]] for i in range(N)])
",O(n ^ 2)
"class Solution(object):
    def firstDayBeenInAllRooms(self, nextVisit):
        MOD = 10**9+7

        dp = [0]*len(nextVisit)
        for i in range(1, len(dp)):
            dp[i] = (dp[i-1]+1+(dp[i-1]-dp[nextVisit[i-1]])+1)%MOD
        return dp[-1]",O(n)
"from collections import deque as de
import math
from collections import Counter as cnt
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def isPrime(n) :

	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):

    prime_factors = []

    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2

    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic

n=int(input())
pp=n
nn=n

pl=[]
nl=[]
while pp:
    pp-=1
    pl.append(input())
while nn:
    nn-=1
    nl.append(input())
ans=0
pmc=pl.count(""M"")
mc=nl.count(""M"")
if pmc < mc:
    ans+=mc -pmc
psc=pl.count(""S"")
sc=nl.count(""S"")
if psc < sc:
    ans+=sc -psc

plc=pl.count(""L"")
lc=nl.count(""L"")
if plc < lc:
    ans+=lc -plc

pxlc=pl.count(""XL"")
xlc=nl.count(""XL"")
if pxlc < xlc:
    ans+=xlc -pxlc

pxxlc=pl.count(""XXL"")
xxlc=nl.count(""XXL"")
if pxxlc < xxlc:
    ans+=xxlc -pxxlc

pxxxlc=pl.count(""XXXL"")
xxxlc=nl.count(""XXXL"")
if pxxxlc < xxxlc:
    ans+=xxxlc -pxxxlc

pxsc=pl.count(""XS"")
xsc=nl.count(""XS"")
if pxsc < xsc:
    ans+=xsc -pxsc

pxxsc=pl.count(""XXS"")
xxsc=nl.count(""XXS"")
if pxxsc < xxsc:
    ans+=xxsc -pxxsc

pxxxsc=pl.count(""XXXS"")
xxxsc=nl.count(""XXXS"")
if pxxxsc < xxxsc:
    ans+=xxxsc -pxxxsc
print(ans)
",O(n)
"import math

a, b = [int(x) for x in input().split()]
while a != 0 and b != 0:
    x = int(math.log(a, 2))
    y = int(math.log(b, 2))
    if x != y:
        break
    a = a & (~(1 << x))
    b = b & (~(1 << y))

if a == 0 and b == 0:
    print(0)
else:
    if b > a:
        a, b = b, a
    x = int(math.log(a, 2)) + 1
    b = (1 << x) - 1
    a = a | b
    print(a)
",O(logn)
"x, k = map(int, input().strip().split())
MOD = 10**9 + 7

def pow2(k):
    if k == 0:
        return 1
    if k == 1:
        return 2
    r = pow2(k // 2)
    r = r * r
    if k % 2 != 0:
        r *= 2
    return r % MOD

def calc(x, k):
    if x == 0:
        return 0
    if k == 0:
        return (2 * x) % MOD
    r = pow2(k) * (2 * x - 1) + 1
    return r % MOD

print(calc(x, k))",O(logn)
"from math import sin
n,r=[int(i) for i in input().split()]
pi=3.14159265359
print(r/((2*sin(pi*(1/2-1/n)))/(sin(2*pi/n))-1))",O(1)
"import sys
mod=10**9+7
n,q=map(int,sys.stdin.readline().split())
S=sys.stdin.readline().strip()
LR=[list(map(int,sys.stdin.readline().split())) for i in range(q)]

LIST=[0]
for s in S:
    if s==""1"":
        LIST.append(LIST[-1]+1)
    else:
        LIST.append(LIST[-1])

def count(m,n,mod):
    return (pow(2,m,mod)-1)*pow(2,n,mod)%mod

for l,r in LR:
    print(count(LIST[r]-LIST[l-1],r-l+1-LIST[r]+LIST[l-1],mod))
",O(n)
"import math
import time
from collections import defaultdict,deque,Counter
from sys import stdin,stdout
from bisect import bisect_left,bisect_right
from queue import PriorityQueue
import sys
t=1

for _ in range(t):
    r,g,b=map(int,stdin.readline().split())
    ra=list(map(int,stdin.readline().split()))
    ga=list(map(int,stdin.readline().split()))
    ba=list(map(int,stdin.readline().split()))
    ra.sort()
    ga.sort()
    ba.sort()
    dp=[[[0]*201 for _ in range(201)]for _ in range(201)]
    for i in range(r+1):
        for j in range(g+1):
            for k in range(b+1):
                if(i and j>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+ra[i-1]*ga[j-1])
                if(i and k>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+ra[i-1]*ba[k-1])
                if(k and j>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+ga[j-1]*ba[k-1])
    print(dp[r][g][b])
",O(n ^ 3)
"def main():
    n, m = map(int, input().split())
    def intCompare(x):
        if int(x) == m:
            return 0
        if int(x) < m:
            return -1
        return 1
    p = list(map(intCompare, input().split()))
    ret = 0
    ind = p.index(0)
    tem = 0
    ret0 = [0] * 400001
    ret1 = [0] * 400001
    set0 = set()
    for i in range(ind, -1, -1):
        tem += p[i]
        ret0[tem] += 1
        set0.add(tem)
    tem = 0
    for i in range(ind, n):
        tem += p[i]
        ret1[tem] += 1
    for i in set0:
        ret += ret0[i] * (ret1[-i] + ret1[1-i])
    print(ret)
    return 0
main()",O(nlogn)
"from copy import *
n,T=map(int,raw_input().split())
cl=set(())
di={(0,0,0,T):1}
for k in range(n):
    t,g=map(int,raw_input().split())
    an=deepcopy(di)
    for k in an:
        nc=list(k)
        nc[3]-=t
        nc[g-1]+=1
        if nc[3]>=0:
            nc=tuple(nc)
            if nc in di:
                di[nc] += an[k]
            else:
                di[nc] = an[k]
nd={(1,0,0,0):1,(0,1,0,1):1,(0,0,1,2):1}
mo=10**9+7
def nb(tu):

    if not(tu in nd):
        if tu[tu[3]]==0:
            nd[tu] =0
        else:
            nt=list(tu)
            nt[tu[3]]-=1
            nt[3]=(nt[3]+1)%3
            nt2=nt[:]
            nt2[3]=(nt2[3]+1)%3
            nd[tu]=(tu[tu[3]]*(nb(tuple(nt))+nb(tuple(nt2))))%mo
    return nd[tu]

print(sum(di[k]*(nb(k[:3]+(1,))+nb(k[:3]+(0,))+nb(k[:3]+(2,))) for k in di if k[3]==0)%mo)
",np
"class Solution(object):
    def checkPalindromeFormation(self, a, b):
        def is_palindrome(s, i, j):
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        def check(a, b):
            i, j = 0, len(b)-1
            while i < j:
                if a[i] != b[j]:
                    return is_palindrome(a, i, j) or is_palindrome(b, i, j)
                i += 1
                j -= 1
            return True

        return check(a, b) or check(b, a)",O(n)
"def binary(n,k):
    lower=1
    upper=n
    while(lower<upper):
        mid=(lower+upper)//2
        total=(mid*(mid+1))//2
        if n-mid==total-k:
            print(n-mid)
            break
        else:
            if n-mid>total-k:
                lower=mid+1
            else:
                upper=mid

n,k=map(int,input().split())
if n==1 and k==1:
    print(0)
else:
    binary(n,k)
",O(logn)
"import heapq



class Solution(object):
    def findMaxSum(self, nums1, nums2, k):
        result = [0]*len(nums1)
        min_heap = []
        idxs = list(range(len(nums1)))
        idxs.sort(key=lambda x: nums1[x])
        total = j = 0
        for i in range(len(idxs)):
            while nums1[idxs[j]] < nums1[idxs[i]]:
                total += nums2[idxs[j]]
                heapq.heappush(min_heap, nums2[idxs[j]])
                if len(min_heap) == k+1:
                    total -= heapq.heappop(min_heap)
                j += 1
            result[idxs[i]] = total            
        return result",O(nlogn)
"class Solution(object):
    def twoEggDrop(self, n):
        return int(math.ceil((-1+(1+8*n)**0.5)/2))",O(1)
"from os import path;import sys,time
mod = int(1e9 + 7)
from math import ceil, floor,gcd,log,log2 ,factorial,sqrt
from collections import defaultdict ,Counter , OrderedDict , deque;from itertools import combinations,permutations
from string import ascii_lowercase ,ascii_uppercase
from bisect import *;from functools import reduce;from operator import mul;maxx = float('inf')
I = lambda :int(sys.stdin.buffer.readline())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().strip('\n')
grid = lambda  r :[lint() for i in range(r)]
localsys = 0
start_time = time.time()

nCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r)
def ceill(n,x):
    return (n+x -1 )//x
T =0

def solve():
	arr = list(map(int , S()))
	s , cnt , ans = 0 , 0 ,0
	for i in arr:
		s , cnt = s + i , cnt + 1
		if i % 3 ==0 or cnt % 3 ==0 or s % 3 ==0:
			s , cnt,ans  =0 , 0 , ans + 1
	print(ans)

def run():
    if (path.exists('input.txt')):
        sys.stdin=open('input.txt','r')
        sys.stdout=open('output.txt','w')

run()
T = I() if T else 1
for _ in range(T):
    solve()

if localsys:
    print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",O(n)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = [False] * n
        posDiag = [False] * (n * 2)
        negDiag = [False] * (n * 2)
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if col[c] or posDiag[r + c] or negDiag[r - c + n]:
                    continue
                col[c] = True
                posDiag[r + c] = True
                negDiag[r - c + n] = True
                board[r][c] = ""Q""

                backtrack(r + 1)

                col[c] = False
                posDiag[r + c] = False
                negDiag[r - c + n] = False
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"from sys import stdin, stdout
import collections

N,M,K = [int(x) for x in stdin.readline().split()]
arr = [int(x) for x in stdin.readline().split()]

res = 0
for j in range(M):
    s = 0
    mini = 0
    for i in range(j,N):
        if i%M==j:
            mini = min(mini,s)
            s -= K

        s += arr[i]

        res = max(res,s-mini)

print(res)
",O(n ^ 2)
"import sys
import copy
lines = iter(sys.stdin)

def nexts():
    return next(lines)

def nextint():
    return int(nexts())

def snexts():
    return next(lines).split(' ')

def snextint():
    return map(int, snexts())

def array(length, base=0):
    return [base] * length

def matrix(length, width, base=0):
    return [[base] * width for _ in range(length)]

n, m = snextint()
grid = array(n, [])

for i in range(n):
    grid[i] = list(nexts())

grid2 = copy.deepcopy(grid)

for i in range(1, n - 1):
    for j in range(1, m - 1):

        if grid[i - 1][j] == '
            grid2[i - 1][j] = '.'
            grid2[i - 1][j + 1] = '.'
            grid2[i][j + 1] = '.'
            grid2[i + 1][j + 1] = '.'
            grid2[i + 1][j] = '.'
            grid2[i + 1][j - 1] = '.'
            grid2[i][j - 1] = '.'
            grid2[i - 1][j - 1] = '.'

match = True
for i in grid2:
    for ch in i:
        if ch == '
            match = False
            break

if match:
    print('YES')
else:
    print('NO')",O(n ^ 2)
"class Solution(object):
    def largest1BorderedSquare(self, grid):
        top, left = [a[:] for a in grid], [a[:] for a in grid]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if not grid[i][j]:
                    continue
                if i:
                    top[i][j] = top[i-1][j] + 1
                if j:
                    left[i][j] = left[i][j-1] + 1
        for l in reversed(range(1, min(len(grid), len(grid[0]))+1)):
            for i in range(len(grid)-l+1):
                for j in range(len(grid[0])-l+1):
                    if min(top[i+l-1][j],
                           top[i+l-1][j+l-1],
                           left[i][j+l-1],
                           left[i+l-1][j+l-1]) >= l:
                        return l*l
        return 0",O(n ^ 3)
"from sys import stdin

add = lambda a, b: (a % mod + b % mod) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, k + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])

print(sum(mem[-1][k]) % mod)
",np
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()

        def dfs(i, prev):
            if i == len(intervals):
                return 0
            res = dfs(i + 1, prev)
            if prev == -1 or intervals[prev][1] <= intervals[i][0]:
                res = max(res, 1 + dfs(i + 1, i))
            return res

        return len(intervals) - dfs(0, -1)
",O(2 ^ n)
"from sys import stdin, stdout
import sys
input=sys.stdin.readline

def solve(n, t, tasks):
    lo = 0
    hi = n

    res = []
    curr_res = 0

    tasks.sort(key=lambda x: x[1])

    while lo <= hi:
        mid = lo + (hi - lo) // 2

        valid_tasks = []
        for i in tasks:
            if i[0] >= mid:
                valid_tasks.append(i)

        can_do = False

        curr_sum = 0
        total_used = 0
        r = []
        for i in valid_tasks:
            curr_sum += i[1]
            total_used += 1
            r.append(i[2])
            if curr_sum > t:
                break
            elif total_used >= mid:
                can_do = True
                curr_res = mid
                res = r
                break
        if can_do:
            lo = mid + 1
        else:
            hi = mid - 1
    return curr_res, res

def main():
    n, t = (int(x) for x in input().split("" ""))
    tasks = []
    nums = n
    idx = 1
    while n:
        a_i, t_i = (int(x) for x in input().split("" ""))
        tasks.append((a_i, t_i, idx))
        idx += 1
        n -= 1

    res, res_arry = solve(nums, t, tasks)
    print(res)
    print(res)
    stdout.write("" "".join(map(str, res_arry)))
    stdout.write(""\n"")

if __name__ == ""__main__"":
    main()
",O(nlogn)
"class Solution(object):
    def minimumChairs(self, s):
        result = curr = 0
        for x in s:
            curr += +1 if x == ""E"" else -1
            result = max(result, curr)
        return result",O(n)
"l,r = [int(x) for x in input().split()]
if l==r or l+1==r:
    print(-1)
elif l%2==0:
    print(l,l+1,l+2)
elif l%2!=0 and r-l+1>3:
    print(l+1,l+2,l+3)
else:
    print(-1)",O(1)
"class Solution2(object):
    def maxPathSum(self, root):
        def dfs(node):
            if not node:
                return (float(""-inf""), 0)
            max_left, curr_left = dfs(node.left)
            max_right, curr_right = dfs(node.right)
            return (max(max_left, max_right, node.val+max(curr_left, 0)+max(curr_right, 0)),
                    node.val+max(curr_left, curr_right, 0))
        
        return dfs(root)[0]",O(n)
"import math
import sys
from decimal import Decimal

def main(l,r):

  if l==r:
    return 0

  val=1

  while val*2<=r:
    val*=2

  if val<=l:
    return main(l-val,r-val)
  else:
    return 2*val-1

l,r=list(map(int,input().split()))
print(main(l,r))
",O(logn)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if self.isSafe(r, c, board):
                    board[r][c] = ""Q""
                    backtrack(r + 1)
                    board[r][c] = "".""

        backtrack(0)
        return res

    def isSafe(self, r: int, c: int, board):
        row = r - 1
        while row >= 0:
            if board[row][c] == ""Q"":
                return False
            row -= 1

        row, col = r - 1, c - 1
        while row >= 0 and col >= 0:
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col -= 1

        row, col = r - 1, c + 1
        while row >= 0 and col < len(board):
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col += 1
        return True
",O(n!)
"if __name__ == ""__main__"":
    s = input().rstrip().split()
    N = int(s[0])
    K = int(s[1])
    a = list(map(int, list(input().rstrip().split())))

    diff = []
    for i in range(1, N):
        diff.append([i, a[i] - a[i - 1]])
    diff = sorted(diff, key = lambda x: -x[1])
    res = max(a) - min(a)

    k = 0
    while (k < K - 1 and k < len(diff)):
        res -= diff[k][1]

        k += 1
    print(res)",O(nlogn)
"import math

n, r = map(int, input().split())
x = list(map(int, input().split()))
y = [r]

for i in range(1, n):
    _y = r
    for j in range(i):
        if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]):
            _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j])))
    y.append(round(_y, 6))

print(' '.join(map(str, y)))
",O(n ^ 2)
"import sys
import math
import collections
import heapq
import decimal
input=sys.stdin.readline
n,m,k = map(int,input().split())
a=[]
for i in range(n):
    a.append(list(map(int,input().split())))
b=[]
for i in range(n-1):
    b.append(list(map(int,input().split())))
if(k%2==1):
    for i in range(n):
        for j in range(m):
            print(-1,end = "" "")
        print()
else:
    k//=2
    pre=[[0 for i in range(m)]for j in range(n)]
    for x in range(k):
        curr = [[float(""inf"") for i in range(m)]for j in range(n)]
        for i in range(n):
            for j in range(m):
                if(j>0):
                    curr[i][j]=min(curr[i][j],pre[i][j-1]+a[i][j-1])
                if(i<n-1):
                    curr[i][j]=min(curr[i][j],pre[i+1][j]+b[i][j])
                if(j<m-1):
                    curr[i][j]=min(curr[i][j],pre[i][j+1]+a[i][j])
                if(i>0):
                    curr[i][j]=min(curr[i][j],pre[i-1][j]+b[i-1][j])
        pre=curr[:]
    for i in range(n):
        for j in range(m):
            print(2*pre[i][j],end = "" "")
        print()",O(n ^ 3)
"n=int(input())
if(n<6):
    print(-1)
else:
    print(1,2)
    print(1,3)
    print(1,4)
    for i in range(4,n):
        print(2,i+1)

for i in range(n-1):
    print(1,i+1+1)",O(n)
"from sys import stdin, stdout
import math,sys,heapq
from itertools import permutations, combinations
from collections import defaultdict,deque,OrderedDict
from os import path
import random
import bisect as bi
def yes():print('YES')
def no():print('NO')
if (path.exists('input.txt')):

    sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
    def I():return (int(input()))
    def In():return(map(int,input().split()))
else:

    def I():return (int(stdin.readline()))
    def In():return(map(int,stdin.readline().split()))

def dict(a):
    d={}
    for x in a:
        if d.get(x,-1)!=-1:
            d[x]+=1
        else:
            d[x]=1
    return d
def find_gt(a, x):
    'Find leftmost value greater than x'
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:
        return -1

def cal(r,g,b,dp,R,G,B,nr,ng,nb):
    if dp[r][g][b]!=-1:
        return dp[r][g][b]
    best=0
    if r<nr and g<ng:
        best=max(best,cal(r+1,g+1,b,dp,R,G,B,nr,ng,nb)+R[r]*G[g])
    if r<nr and b<nb:
        best=max(best,cal(r+1,g,b+1,dp,R,G,B,nr,ng,nb)+R[r]*B[b])
    if g<ng and b<nb:
        best=max(best,cal(r,g+1,b+1,dp,R,G,B,nr,ng,nb)+B[b]*G[g])
    dp[r][g][b]=best
    return dp[r][g][b]
def main():
    try:
        nr,ng,nb=In()
        dp=[[[-1 for x in range(201)]for y in range(201)] for z in range(201)]
        R=list(In())
        G=list(In())
        B=list(In())
        R.sort(reverse=True)
        G.sort(reverse=True)
        B.sort(reverse=True)
        print(cal(0,0,0,dp,R,G,B,nr,ng,nb))
    except:
        pass

M = 998244353
P = 1000000007

if __name__ == '__main__':

    for _ in range(1):main()",O(n ^ 3)
"n , k = map(int, input().split())

l = 0
r = n
while r - l > 1:
    mid = (r + l) // 2
    a = n - mid
    if ((1 + a) * a) // 2 >= k + mid:
        l = mid
    else:
        r = mid
print(l)",O(logn)
"n=int(input())+1
if n<2:
    print(0)
elif n%2==0:
    print(n//2)
else:
    print(n)",O(1)
"class Solution2(object):
    def nextPermutation(self, nums):
        k, l = -1, 0
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                k = i

        if k == -1:
            nums.reverse()
            return

        for i in range(k+1, len(nums)):
            if nums[i] > nums[k]:
                l = i
        nums[k], nums[l] = nums[l], nums[k]
        nums[k+1:] = nums[:k:-1]",O(n)
"n,k=map(int,input().split())
l=input()
l=sorted(l)
ans=l[0]
sum=ord(l[0])
index=0
for j in range(1,n):
    if len(ans)<k:
        if ord(l[j])-ord(l[index])>1:
            ans=ans+l[j]
            sum=sum+ord(l[j])
            index=j
    else:
        break
if len(ans)==k:
    sum=sum-96*k
    print(sum)
else:
    print(-1)
",O(n)
"USE_STDIO = False

if not USE_STDIO:
    try: import mypc
    except: pass

def main():
    q,  = map(int, input().split(' '))
    for _ in range(q):
        n, m, k = map(int, input().split(' '))
        if n > k or m > k:
            print(-1)
        elif (n - m) % 2:
            print(k - 1)
        elif (n - k) % 2:
            print(k - 2)
        else:
            print(k)

if __name__ == '__main__':
    main()
",O(1)
"class Solution(object):
    def mostProfitablePath(self, edges, bob, amount):
        def iter_dfs():
            lookup = [[float(""-inf""), float(""inf"")] for _ in range(len(adj))]
            stk = [(1, (0, -1, 0))]
            while stk:
                step, (u, p, ah) = stk.pop()
                if step == 1:
                    stk.append((2, (u, p, ah)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, (v, u, ah+1)))
                elif step == 2:
                    if len(adj[u])+(u == 0) == 1:
                        lookup[u][0] = 0
                    if u == bob:
                        lookup[u][1] = 0
                    for v in adj[u]:
                        if v == p:
                            continue
                        lookup[u][0] = max(lookup[u][0], lookup[v][0])
                        lookup[u][1] = min(lookup[u][1], lookup[v][1])
                    if ah == lookup[u][1]:
                        lookup[u][0] += amount[u]//2
                    elif ah < lookup[u][1]:
                        lookup[u][0] += amount[u]
                    lookup[u][1] += 1
            return lookup[0][0]

        adj = [[] for _ in range(len(edges)+1)]
        lookup = [False]*len(adj)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"def f(n,s):
    d=[-n,-n];
    d[s]=0;
    for i in range(y//g):
        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)];
    return d[s];
import math;
n,x,y=map(int,input().split());
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));
y=y+x;
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np
"import sys

input = sys.stdin.readline

def get_input():
    n, m = [int(x) for x in input().split(' ')]
    digraph = [[] for _ in range(n + 1)]
    for _ in range(m):
        c1, c2 = [int(x) for x in input().split(' ')]
        digraph[c1].append(c2)

    return digraph

def dfs(graph, u=-1, v=-1):
    n = len(graph)

    pi = [None] * n
    color = ['white'] * n
    for node in range(1, n):
        if color[node] == 'white':
            cicle = dfs_visit(graph, node, color, pi, u, v)
            if cicle is not None:
                return cicle
    return None

def dfs_visit(graph, root, color, pi, u, v):
    stack = [root]

    while stack:
        current_node = stack[-1]

        if color[current_node] != 'white':
            stack.pop()
            color[current_node] = 'black'
            continue

        color[current_node] = 'grey'
        for adj in graph[current_node]:
            if (current_node, adj) == (u, v):
                continue

            if color[adj] == 'white':
                pi[adj] = current_node
                stack.append(adj)
            elif color[adj] == 'grey':
                cicle = [adj]
                while current_node != adj:
                    cicle.append(current_node)
                    current_node = pi[current_node]
                cicle.append(adj)
                return cicle
    return None

if __name__ == ""__main__"":
    digraph = get_input()
    cicle = dfs(digraph)
    if cicle is None:
        print(""YES"")
    else:
        cicle.reverse()
        for i in range(len(cicle) - 1):
            c = dfs(digraph, cicle[i], cicle[i + 1])
            if c is None:
                print(""YES"")
                break
        else:
            print(""NO"")
",O(n ^ 2)
"import sys
input = sys.stdin.readline

ok = set()
for i in range(114514):
    x = i * i
    ok.add(2 * x)
    ok.add(4 * x)

t = int(input())
for _ in range(t):
    n = int(input())
    ans = ""YES"" if n in ok else ""NO""
    print(ans)",O(1)
"

class Solution(object):
    def countElements(self, nums):
        mn = min(nums)
        mx = max(nums)
        return sum(mn < x < mx for x in nums)
",O(n)
"import sys
import math
input = sys.stdin.readline
from functools import cmp_to_key;

def pi():
    return(int(input()))
def pl():
    return(int(input(), 16))
def ti():
    return(list(map(int,input().split())))
def ts():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))
mod = 1000000007;
f = [];
def fact(n,m):
    global f;
    f = [1 for i in range(n+1)];
    f[0] = 1;
    for i in range(1,n+1):
        f[i] = (f[i-1]*i)%m;

def fast_mod_exp(a,b,m):
    res = 1;
    while b > 0:
        if b & 1:
            res = (res*a)%m;
        a = (a*a)%m;
        b = b >> 1;
    return res;

def inverseMod(n,m):
    return fast_mod_exp(n,m-2,m);

def ncr(n,r,m):
    if n < 0 or r < 0 or r > n: return 0;
    if r == 0: return 1;
    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;

def main():
    C();

def D():
    [n,m,k] = ti();
    w = [[] for i in range(n)];
    for i in range(n):
        w[i] = ts();

    mn = [[0 for j in range(k+1)] for i in range(n+1)];
    for i in range(1,n+1):
        for j in range(k+1):
            c = 0;
            st,en = -1,-1;
            for x in range(m):
                if w[i-1][x] == '1':
                    if c == j and st == -1: st = x;
                    if c < j: c += 1;
                    if c == j: en = x;
            mn[i][j] = en-st+1 if st != -1 and en != -1 else 0;
            st,en = -1,-1;
            c = 0;
            for x in range(m-1,-1,-1):
                if w[i-1][x] == '1':
                    if c == j and st == -1: st = x;
                    if c < j: c += 1;
                    if c == j: en = x;
            if st != -1 and en != -1 >= 0:
                mn[i][j] = min(mn[i][j], st-en+1);

    dp = [[9999999999999999 for j in range(k+1)] for i in range(n+1)];
    for i in range(k+1):
        dp[0][i] = 0;
    for i in range(1,n+1):
        for j in range(k+1):
            for x in range(k+1):
                if j-x >= 0:
                    dp[i][j] = min(dp[i][j], dp[i-1][j-x]+mn[i][x]);

    print(dp[n][k]);

def getCount(n):
    x = 1;
    count = 0;
    while n > 0:
        if n & 1 == 1:
            count += 1;
        n = n >> 1;
    return count;

def C():
    try:
        n = ts();
        k = pi();
        if k == 0:
            print(1);
            return;
        dp = [0 for i in range(1010)];
        for i in range(1010):
            if i == 0 or i == 1:
                continue;
            dp[i] = dp[getCount(i)]+1;
        fact(1010,mod);

        ans = 0;
        s = n;
        count = 0;
        for i in range(len(s)):
            if s[i] == '0': continue;
            for j in range(max(count,1),1010):
                if dp[j] == k-1:
                    ans = (ans+ncr(len(s)-i-1,j-count,mod))%mod;
                    if i == 0 and k == 1: ans = (ans+mod-1)%mod;
            count += 1;
        count = 0;
        for i in range(len(s)):
            if s[i] == '1': count += 1;
        if dp[count] == k-1: ans = (ans+1)%mod;

        print(ans);
    except: print(sys.exc_info()[0]);

main();",O(n)
"from math import pow
n=int(int(input())-1)
x=1
y=9
while n>x*y:
    n-=x*y
    x+=1
    y*=10
a=int(pow(10,x-1))+int(n/x)
z=str(a)
which=n%x
print(z[which])",O(logn)
"n = int(input())
ar = [int(i) for i in input().split()]

if n == 1:
    print(1)
    exit()

if ar[1] > ar[0]:
    li = [1]
elif ar[1] < ar[0]:
    li = [5]
else:
    li = [3]

c = 1
while c != n:
    j = 0

    if ar[c] > ar[c - 1]:
        while c != n and ar[c] > ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] + 1)
            if li[-1] == 6:
                print(-1)

                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] + 1)
        else:
            li.append(5)

    elif ar[c] < ar[c - 1]:
        while c != n and ar[c] < ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] - 1)
            if li[-1] == 0:
                print(-1)

                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] - 1)
        else:
            li.append(1)

    else:
        while c != n and ar[c] == ar[c - 1]:
            c += 1
            j += 1
        for i in range(j):
            if li[-1] > 3:
                li.append(li[-1] - 1)
            else:
                li.append(li[-1] + 1)
        if c != n and ar[c] > ar[c - 1]:
            if li[-2] == 1:
                li[-1] = 2
            else:
                li[-1] = 1
        elif c != n and ar[c] < ar[c - 1]:
            if li[-2] == 5:
                li[-1] = 4
            else:
                li[-1] = 5

if max(li) > 5 or min(li) < 1:
    print(-1)
else:
    print(*li)",O(n ^ 2)
"dat = ""硼磷碳磷溴硼氧磷氮硫氮氯氟溴硼磷碳硼硫碳氯溴硼磷碳硼硫溴硼磷碳硼氯碳硫溴硼磷碳硼氯溴硼氧硼硫碳硼氯氮磷氮硫碳氯氟溴硼氧磷氮硫碳氯氟溴硼磷碳硫碳氯溴硼氧硼硫碳氯氮硼氯碳硫氮磷氟溴硼磷碳氯溴硼氧硼氯碳硫氮磷氟溴硼磷碳硫溴硼氧硼硫碳氯氮磷氟溴硼磷碳氧硫氮氯氟溴硼磷溴硼硫碳硼氯碳磷溴硼硫碳硼氯溴硼氧硼磷碳硼氯氮磷碳氯氮硫氟溴硼氧磷碳氯氮硫氟溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟溴硼氧磷碳硫氮氯氟溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟氮硼磷碳硼硫碳氯溴硼氧氧磷氮硫氟碳氯氮磷碳硫氟溴硼磷碳硫碳氯氮硼硫碳硼氯碳磷溴硼磷碳硫碳氯氮硼硫碳硼氯溴硼磷碳氯氮硼硫碳硼氯碳磷溴硼磷碳氯氮硼硫碳硼氯溴硼磷碳硫氮硼硫碳硼氯碳磷溴硼磷碳硫氮硼硫碳硼氯溴硼磷碳氧硫氮氯氟氮硼硫碳硼氯碳磷溴硼磷氮硼硫碳硼氯溴硼硫碳磷碳氯溴硼氧硼磷碳氯氮硼氯碳磷氮硫氟溴硼硫碳氯溴硼氧硼氯碳磷氮硫氟溴硼磷碳硼氯碳硫氮硼硫碳磷碳氯溴硼磷碳硼氯氮硼硫碳磷碳氯溴硼磷碳硼氯碳硫氮硼硫碳氯溴硼磷碳硼氯氮硼硫碳氯溴硼磷碳硫碳氯氮硼硫碳磷碳氯溴硼氧硼磷碳氯氮硼氯碳磷氮硫氟氮硼磷碳硫碳氯溴硼氧磷碳硫氟碳氯溴硼氧硼氯碳磷氮硫氟氮硼磷碳氯溴硼磷碳硫氮硼硫碳磷碳氯溴硼氧硼硫碳氯氮磷氟氮硼硫碳磷碳氯溴硼磷碳硫氮硼硫碳氯溴硼磷氮硼硫碳氯溴硼硫碳磷溴硼氧硼磷碳氯氮硫氟溴硼硫碳氧磷氮氯氟溴硼硫溴硼磷碳硼氯碳硫氮硼硫碳磷溴硼磷碳硼氯氮硼硫碳磷溴硼磷碳硼氯碳硫氮硼硫碳氧磷氮氯氟溴硼磷碳硼氯氮硼硫溴硼磷碳硫碳氯氮硼硫碳磷溴硼氧硼磷碳氯氮硫氟氮硼磷碳硫碳氯溴硼磷碳氯氮硼硫碳磷溴硼磷碳氯氮硼硫溴硼磷碳硫氮硼硫碳磷溴硼氧硼磷碳硼硫碳氯氮磷碳硫氟溴硼磷碳氧硫氮氯氟氮硼硫碳磷溴硼磷氮硼硫溴硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟溴硼磷碳硼硫碳氯氮硼氯碳磷碳硫溴硼磷碳硼硫氮硼氯碳磷碳硫溴硼氯碳硫溴硼氧硼硫碳磷氮氯氟溴硼磷碳硼硫碳氯氮硼氯碳硫溴硼磷碳硼硫氮硼氯碳硫溴硼磷碳硫碳氯氮硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟氮硼磷碳硫碳氯溴硼磷碳氯氮硼氯碳磷碳硫溴硼氧硼氯碳硫氮磷氟氮硼氯碳磷碳硫溴硼氧磷碳氯氟碳硫溴硼氧硼硫碳磷氮氯氟氮硼磷碳硫溴硼磷碳氯氮硼氯碳硫溴硼磷氮硼氯碳硫溴硼氯碳磷溴硼氧硼磷碳硫氮氯氟溴硼磷碳硼硫碳氯氮硼氯碳磷溴硼磷碳硼硫氮硼氯碳磷溴硼氯碳氧磷氮硫氟溴硼氯溴硼磷碳硼硫碳氯氮硼氯碳氧磷氮硫氟溴硼磷碳硼硫氮硼氯溴硼磷碳硫碳氯氮硼氯碳磷溴硼氧硼磷碳硫氮氯氟氮硼磷碳硫碳氯溴硼磷碳氯氮硼氯碳磷溴硼氧硼磷碳硼氯碳硫氮磷碳氯氟溴硼磷碳硫氮硼氯碳磷溴硼磷碳硫氮硼氯溴硼磷碳氧硫氮氯氟氮硼氯碳磷溴硼磷氮硼氯溴硼硫碳磷碳氯氮硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟氮硼硫碳磷碳氯溴硼硫碳氯氮硼氯碳磷碳硫溴硼氧硼氯碳磷氮硫氟氮硼氯碳磷碳硫溴硼硫碳磷碳氯氮硼氯碳硫溴硼氧硼硫碳磷氮氯氟氮硼硫碳磷碳氯溴硼硫碳氯氮硼氯碳硫溴硼氧硼硫碳硼氯碳磷氮硫碳氯氟溴硼磷碳硫碳氯氮硼硫碳磷碳氯氮硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟氮硼磷碳硫碳氯氮硼硫碳磷碳氯溴硼氧磷碳硫氟碳氯氮硼氯碳磷碳硫溴硼氧硼氯碳磷氮硫氟氮硼磷碳氯氮硼氯碳磷碳硫溴硼氧磷碳氯氟碳硫氮硼硫碳磷碳氯溴硼氧硼硫碳磷氮氯氟氮硼磷碳硫氮硼硫碳磷碳氯溴硼氧磷碳硫氟碳氯氮硼氯碳硫溴硼磷氮硼硫碳氯氮硼氯碳硫溴硼氧硫碳氯氟碳磷溴硼氧硼磷碳硫氮氯氟氮硼硫碳磷溴硼硫碳氯氮硼氯碳磷溴硼硫氮硼氯碳磷溴硼硫碳磷氮硼氯碳硫溴硼硫碳磷氮硼氯溴硼硫碳氧磷氮氯氟氮硼氯碳硫溴硼硫氮硼氯溴硼氧硫碳氯氟碳磷氮硼磷碳硫碳氯溴硼氧硼磷碳硫氮氯氟氮硼磷碳硫碳氯氮硼硫碳磷溴硼氧磷碳硫氟碳氯氮硼氯碳磷溴硼磷碳氯氮硼硫氮硼氯碳磷溴硼氧磷碳氯氟碳硫氮硼硫碳磷溴硼磷碳硫氮硼硫碳磷氮硼氯溴硼磷碳硫氮硼硫碳氯氮硼氯碳磷溴硼氧磷碳硫碳氯氟溴磷碳硫碳氯溴硼氧磷氮硫氮氯氟氮磷碳硫碳氯溴硼磷碳硼硫碳氯氮磷碳硫碳氯溴硼磷碳硼硫氮磷碳硫碳氯溴硼磷碳硼氯碳硫氮磷碳硫碳氯溴硼磷碳硼氯氮磷碳硫碳氯溴硼氧硼硫碳硼氯氮磷氮硫碳氯氟氮磷碳硫碳氯溴硼氧磷氮硫碳氯氟氮磷碳硫碳氯溴硫碳氯溴硼氧磷氮硫氮氯氟氮硫碳氯溴硼磷碳氯氮硫碳氯溴硼磷碳硼硫氮硫碳氯溴硼磷碳硫氮硫碳氯溴硼磷碳硼氯氮硫碳氯溴硼磷碳氧硫氮氯氟氮硫碳氯溴硼磷氮硫碳氯溴硼硫碳硼氯碳磷氮磷碳硫碳氯溴硼硫碳硼氯氮磷碳硫碳氯溴硼氧硼磷碳硼氯氮磷碳氯氮硫氟氮磷碳硫碳氯溴硼氧磷碳氯氮硫氟氮磷碳硫碳氯溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟氮磷碳硫碳氯溴硼氧磷碳硫氮氯氟氮磷碳硫碳氯溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟氮硼磷碳硼硫碳氯氮磷碳硫碳氯溴硼氧氧磷氮硫氟碳氯氮磷碳硫氟氮磷碳硫碳氯溴硼硫碳硼氯碳磷氮硫碳氯溴硼硫碳硼氯氮硫碳氯溴硼磷碳氯氮硼硫碳硼氯碳磷氮硫碳氯溴硼氧磷碳氯氮硫氟氮硫碳氯溴硼磷碳硫氮硼硫碳硼氯碳磷氮硫碳氯溴硼氧磷碳硫氮氯氟氮硫碳氯溴硼磷碳氧硫氮氯氟氮硼硫碳硼氯碳磷氮硫碳氯溴硼磷氮硼硫碳硼氯氮硫碳氯溴磷碳氯溴硼氧磷氮硫氮氯氟氮磷碳氯溴硼硫碳氯氮磷碳氯溴硼磷碳硼硫氮磷碳氯溴硼磷碳硼氯碳硫氮磷碳氯溴硼磷碳硼氯氮磷碳氯溴硼磷碳硼氯碳硫氮硼硫碳氯氮磷碳氯溴硼氧磷氮硫碳氯氟氮磷碳氯溴氧磷氮硫氟碳氯溴硼氧磷氮硫氮氯氟氮氧磷氮硫氟碳氯溴氯溴硼磷碳硼硫氮氯溴硼磷碳硫氮磷碳氯溴硼氧硼硫碳氯氮磷氟氮磷碳氯溴硼磷碳硫氮氯溴硼磷氮氯溴硼硫碳磷氮磷碳氯溴硼硫碳硼氯氮磷碳氯溴硼硫碳氧磷氮氯氟氮磷碳氯溴硼硫氮磷碳氯溴硼磷碳硼氯碳硫氮硼硫碳磷氮磷碳氯溴硼氧磷碳硫氮氯氟氮磷碳氯溴硼磷碳硼氯碳硫氮硼硫碳氧磷氮氯氟氮磷碳氯溴硼磷碳硼氯氮硼硫氮磷碳氯溴硼硫碳磷氮硫碳氯溴硼氧硼磷碳氯氮硫氟氮硫碳氯溴硼硫碳磷氮氯溴硼硫氮氯溴硼磷碳硫氮硼硫碳磷氮磷碳氯溴硼磷碳硼氯氮硼硫碳磷氮硫碳氯溴硼磷碳硫氮硼硫碳磷氮氯溴硼磷氮硼硫氮氯溴磷碳硫溴硼氧磷氮硫氮氯氟氮磷碳硫溴硼磷碳硼硫碳氯氮磷碳硫溴硼磷碳硼硫氮磷碳硫溴硼氯碳硫氮磷碳硫溴硼磷碳硼氯氮磷碳硫溴硼磷碳硼硫碳氯氮硼氯碳硫氮磷碳硫溴硼氧磷氮硫碳氯氟氮磷碳硫溴氧磷氮氯氟碳硫溴硼氧磷氮硫氮氯氟氮氧磷氮氯氟碳硫溴硼磷碳氯氮磷碳硫溴硼氧硼氯碳硫氮磷氟氮磷碳硫溴硫溴硼磷碳硼氯氮硫溴硼磷碳氯氮硫溴硼磷氮硫溴硼氯碳磷氮磷碳硫溴硼硫碳硼氯氮磷碳硫溴硼磷碳硼硫碳氯氮硼氯碳磷氮磷碳硫溴硼氧磷碳氯氮硫氟氮磷碳硫溴硼氯碳氧磷氮硫氟氮磷碳硫溴硼氯氮磷碳硫溴硼磷碳硼硫碳氯氮硼氯碳氧磷氮硫氟氮磷碳硫溴硼磷碳硼硫氮硼氯氮磷碳硫溴硼氯碳磷氮硫碳氯溴硼氧硼磷碳硫氮氯氟氮硫碳氯溴硼磷碳氯氮硼氯碳磷氮磷碳硫溴硼磷碳硼硫氮硼氯碳磷氮硫碳氯溴硼氯碳磷氮硫溴硼氯氮硫溴硼磷碳氯氮硼氯碳磷氮硫溴硼磷氮硼氯氮硫溴氧硫氮氯氟碳磷溴硼氧磷氮硫氮氯氟氮氧硫氮氯氟碳磷溴硼硫碳氯氮磷碳硫溴硼氧硼氯碳磷氮硫氟氮磷碳硫溴硼氯碳硫氮磷碳氯溴硼氧硼硫碳磷氮氯氟氮磷碳氯溴硼硫碳氯氮硼氯碳硫氮磷碳硫溴硼磷碳硼硫氮硼氯碳硫氮磷碳氯溴氧磷氮硫氟碳氯氮磷碳硫溴硼氧磷氮硫氮氯氟氮氧磷氮硫氟碳氯氮磷碳硫溴磷碳硫氮氯溴硼磷碳硼硫氮磷碳硫氮氯溴磷碳氯氮硫溴硼磷碳硼氯氮磷碳氯氮硫溴硫氮氯溴硼磷氮硫氮氯溴磷溴硼硫碳硼氯氮磷溴硼硫碳氯氮磷溴硼硫氮磷溴硼氯碳硫氮磷溴硼氯氮磷溴硼硫碳氯氮硼氯碳硫氮磷溴硼硫氮硼氯氮磷溴磷氮硫碳氯溴硼硫碳硼氯氮磷氮硫碳氯溴磷氮氯溴硼硫氮磷氮氯溴磷氮硫溴硼氯氮磷氮硫溴磷氮硫氮氯溴硼磷氮磷"".split('溴')
d1, d2 = ""硼碳氮氧氟磷硫氯"", ""!&|()xyz""
for i in range(int(input())):
	s = dat[eval(""0b"" + ''.join(list(reversed(input()))))]
	for i in range(8): s = s.replace(d1[i], d2[i])
	print(s)
",O(n ^ 2)
"import os,sys
from io import BytesIO,IOBase
from collections import defaultdict,Counter
from copy import deepcopy

def main():
    n,c = map(int,input().split())
    a = list(map(int,input().split()))
    nums = defaultdict(lambda :[0])
    freq,minus = Counter(),0
    for i in a:
        if i == c:
            minus += 1
        else:
            freq[i] += 1
            nums[i].append(freq[i]-minus)
    tot = minus
    suff = deepcopy(nums)
    for i in nums:
        for j in range(len(nums[i])-2,0,-1):
            suff[i][j] = max(suff[i][j],suff[i][j+1])
    freq,ans = Counter(),tot
    for i in a:
        if i == c:
            continue
        freq[i] += 1
        ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot)
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(1)
"class Solution(object):
    def getCollisionTimes(self, cars):
        stk = []
        result = [-1.0]*len(cars)
        for i in reversed(range(len(cars))):
            p, s = cars[i]
            while stk and (cars[stk[-1]][1] >= s or 
                           0 < result[stk[-1]] <= float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])):
                stk.pop()
            if stk:
                result[i] = float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])
            stk.append(i)
        return result",O(n)
"n=int(input())
s=list(input())
t=list(input())

cnt=0
ans=[]
f1=0
for i in range(n):
    if s[i]==t[i]:
        continue
    f=0
    for j in range(i+1,n):
        if s[j]==t[i]:
            f=1
            for k in range(j,i,-1):
                s[k-1],s[k]=s[k],s[k-1]
                ans.append(k)
            break
    if f==0:
        print(-1)
        exit()

print(len(ans))
print(*ans)",O(n ^ 2)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n,m = mi()
a = li()
size = [0 for i in range(n)]
for i in range(m):
    size[a[i]-1] += 1
print(min(size))
",O(n ^ 2)
"def suma_o_resta(a, b):
	return (a & (1<<b))

def diferencia(s1, d):
	if s1:
		s1.sort()

		if s1[-1] - s1[0] >= d:

			return s1
		else:
			return diferencia(s1.remove(s1[-1]), d)
	return s1

def no_sets(v, n, l, r, d):
	s = []
	cont = 0
	for x in range(1<<n):
		for i in range(n):

			if suma_o_resta(x, i) > 0:

				s.append(v[i])
		s = diferencia(s, d)
		if s:
			if sum(s) >= l and sum(s) <= r:
				cont += 1
		s = []
	return cont;

n, l, r, x = map(int, input().split())

v = list(map(int, input().split()))

print(str(no_sets(v, n, l, r, x)))
",np
"n,k=map(int,input().split())
l,c=[],0
for _ in range(n):
	l.append(list(map(int,input().split())))
l.sort(reverse=True)
a,x,y=l[k-1][0],k-1,k-1
for i in range(k-2,-1,-1):
	if l[i][0]==a:
		x=i
	else:
		break
for i in range(k,n):
	if l[i][0]==a:
		y=i
	else:
		break
d=k-1-x
d=y-d
for i in range(y,x-1,-1):
	if l[i]==l[d]:
		c+=1
print(c)",O(nlogn)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = 0
        posDiag = 0
        negDiag = 0
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            nonlocal col, posDiag, negDiag
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if ((col & (1 << c)) or (posDiag & (1 << (r + c)))
                    or (negDiag & (1 << (r - c + n)))):
                    continue
                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = ""Q""

                backtrack(r + 1)

                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"class Solution(object):
    def divideString(self, s, k, fill):
        return [s[i:i+k] + fill*(i+k-len(s)) for i in range(0, len(s), k)]",O(n)
"class Solution(object):
    def minOperations(self, k):
        def isqrt(n):
            a, b = n, (n+1)//2
            while b < a:
                a, b = b, (b+n//b)//2
            return a

        def ceil_divide(a, b):
            return (a+b-1)//b
    
        x = isqrt(k)
        return (x-1)+(ceil_divide(k, x)-1)",O(logn)
"class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        res = []

        for i in range(len(intervals)):
            if newInterval[1] < intervals[i][0]:
                res.append(newInterval)
                return res + intervals[i:]
            elif newInterval[0] > intervals[i][1]:
                res.append(intervals[i])
            else:
                newInterval = [
                    min(newInterval[0], intervals[i][0]),
                    max(newInterval[1], intervals[i][1]),
                ]
        res.append(newInterval)
        return res
",O(n)
"class Solution(object):
    def smallestRangeI(self, A, K):
        return max(0, max(A) - min(A) - 2*K)",O(n)
"class Solution(object):
    def singleNumber(self, nums):
        x_xor_y = reduce(operator.xor, nums)
        bit =  x_xor_y & -x_xor_y
        result = [0, 0]
        for i in nums:
            result[bool(i & bit)] ^= i
        return result",O(n)
"S = input()
best = 0
for i in range(len(S)):
    for j in range(i+1, len(S)+1):
        s = S[i:j]
        c = 0
        for k in range(len(S)):
            if S[k:].startswith(s): c += 1
        if c >= 2:
            best = max(best, len(s))
print(best)",O(n ^ 3)
"class Solution(object):
    def minimumSwap(self, s1, s2):
        x1, y1 = 0, 0
        for i in range(len(s1)):
            if s1[i] == s2[i]:
                continue
            x1 += int(s1[i] == 'x')
            y1 += int(s1[i] == 'y')
        if x1%2 !=  y1%2: 
            return -1
        return (x1//2 + y1//2) + (x1%2 + y1%2)",O(n)
"n, pos, l, r = map(int, input().split())
result = abs(pos - l) + r - l + 2
if (l == 1):
    if (abs(pos - r) + 1 < result):
        result = abs(pos - r) + 1
if (r == n):
    if (abs(pos - l) + 1 < result):
        result = abs(pos - l) + 1
if (l == 1 and r == n):
    result = 0
if (abs(pos - r) + r - l + 2 < result):
    result = abs(pos - r) + r - l + 2
print(result)",O(1)
"class Solution(object):
    def isSelfCrossing(self, x):
        if len(x) >= 5 and x[3] == x[1] and x[4] + x[0] >= x[2]:
            return True

        for i in range(3, len(x)):
            if x[i] >= x[i - 2] and x[i - 3] >= x[i - 1]:
                return True
            elif i >= 5 and x[i - 4] <= x[i - 2] and x[i] + x[i - 4] >= x[i - 2] and \
                            x[i - 1] <= x[i - 3] and x[i - 5] + x[i - 1] >= x[i - 3]:
                return True
        return False",O(n)
"from math import *
a, vm = map(int, input().split())
l, d, vd = map(int, input().split())
if vm <= vd or sqrt(2 * a * d) <= vd:
    if vm ** 2 / (2 * a) >= l:
        ans = sqrt(2 * l / a)
    else:
        ans = vm / a + (l - vm ** 2 / (2 * a)) / vm
else:
    s1 = (vm ** 2 - vd ** 2) / (2 * a)
    if s1 >= (l - d):
        ans = (sqrt(4 * (vd ** 2) + 8 * a * (l - d)) - 2 * vd) / (2 * a)
    else:
        ans = (vm - vd) / a + (l - d - s1) / vm
    v1 = sqrt((2 * a * d + vd ** 2) / 2)
    if v1 <= vm:
        ans = ans + v1 / a + (v1 - vd) / a
    else:
        s1 = d - (vm ** 2 - vd ** 2) / (2 * a) - (vm ** 2) / (2 * a)
        ans = ans + vm / a + (vm - vd) / a + s1 / vm
print('%.12f' % ans)",O(1)
"class Solution(object):
    def minimumHammingDistance(self, source, target, allowedSwaps):
        def iter_flood_fill(adj, node, lookup, idxs):
            stk = [node]
            while stk:
                node = stk.pop()
                if node in lookup:
                    continue
                lookup.add(node)
                idxs.append(node)
                for child in adj[node]:
                    stk.append(child)

        adj = [set() for i in range(len(source))]
        for i, j in allowedSwaps:
            adj[i].add(j)
            adj[j].add(i)
        result = 0
        lookup = set()
        for i in range(len(source)):
            if i in lookup:
                continue
            idxs = []
            iter_flood_fill(adj, i, lookup, idxs)
            source_cnt = collections.Counter([source[i] for i in idxs])
            target_cnt = collections.Counter([target[i] for i in idxs])
            diff = source_cnt-target_cnt
            result += sum(diff.values())
        return result",O(n)
"class Solution(object):
    def minimumCardPickup(self, cards):
        lookup = {}
        result = float(""inf"")
        for i, x in enumerate(cards):
            if x in lookup:
                result = min(result, i-lookup[x]+1)
            lookup[x] = i
        return result if result != float(""inf"") else -1",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteNodes(self, head, m, n):
        head = dummy = ListNode(next=head)
        while head:
            for _ in range(m):
                if not head.__next__:
                    return dummy.__next__
                head = head.__next__
            prev = head
            for _ in range(n):
                if not head.__next__:
                    prev.next = None
                    return dummy.__next__
                head = head.__next__
            prev.next = head.__next__
        return dummy.__next__",O(n)
"import os,sys
from io import BytesIO, IOBase

def main():
    n = int(input())
    p = [list(map(float,input().split())) for _ in range(n)]
    y = 1<<n
    dp = [[0]*y for _ in range(n)]

    dp[0][y-1] = 1
    for i in range(y-2,-1,-1):
        mask = 1
        for j in range(n):
            if not mask&i:
                mask <<= 1
                continue
            mask1 = 1
            for k in range(n):
                if i&mask1:
                    mask1 <<= 1
                    continue
                dp[j][i] = max(dp[j][i],
                    dp[j][i|mask1]*p[j][k]+dp[k][i|mask1]*p[k][j])
                mask1 <<= 1
            mask <<= 1
    print(max(dp[i][1<<i] for i in range(n)))

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",np
"class TreeNode(object):
    def __init__(self, x):
        pass


class Solution(object):
    def lowestCommonAncestor(self, root, nodes):
        def iter_dfs(root, lookup):
            result = [0]
            stk = [(1, (root, result))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node or node in lookup:
                        ret[0] = node
                        continue
                    ret1, ret2 = [None], [None]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    if ret1[0] and ret2[0]:
                        ret[0] = node
                    else:
                        ret[0] = ret1[0] or ret2[0]
            return result[0]
        
        return iter_dfs(root, set(nodes))",O(n)
"n=int(input())+1
if n==1:
    print(0)
elif n%2:
    print(n)
else:
    print(n//2)",O(1)
"t=int(input())
for ca in range(t):
    asd=input().split()
    n=int(asd[0])
    k=int(asd[1])
    if n>=40:
        print(""YES ""+str(n-1))
    else:
        ans=-1
        for m in range(1,n+1):
            asd=(4**m-1)//3
            asd2=(2**m-1)**2
            asd2*=(4**(n-m)-1)//3
            asd+=asd2
            if asd>=k and m*m<=k:
                ans=n-m
                break
        if ans==-1:
            print(""NO"")
        else:
            print(""YES ""+str(ans))
",O(logn)
"from math import inf
n, m, k = map(int, input().split())
horizontal = []
vertical = []
for _ in range(n):
    horizontal.append(list(map(int, input().split())))
for _ in range(n - 1):
    vertical.append(list(map(int, input().split())))
if k & 1:
    ans = [""-1""] * m
    for _ in range(n):
        print(*ans)
else:
    grid = [[0 for i in range(m)] for j in range(n)]
    for _ in range(k // 2):
        X = [[inf for i in range(m)] for j in range(n)]
        for i in range(n):
            for j in range(m):
                if i >= 1:
                    X[i][j] = min(2 * vertical[i - 1][j] + grid[i - 1][j], X[i][j])
                if i < n - 1:
                    X[i][j] = min(2 * vertical[i][j] + grid[i + 1][j], X[i][j])
                if j >= 1:
                    X[i][j] = min(2 * horizontal[i][j - 1] + grid[i][j - 1], X[i][j])
                if j < m - 1:
                    X[i][j] = min(2 * horizontal[i][j] + grid[i][j + 1], X[i][j])

        grid = X[:]
    for _ in range(n):
        print(*grid[_])
",O(n ^ 3)
"import math

def sequence_split_up(sequence):
    ans=[0,0,0]
    for i in sequence:
        if i=='+':
            ans[0]+=1
        elif i=='-':
            ans[1]+=1
        elif i=='?':
            ans[2]+=1
    return ans

def probability():
    actual_sequence=sequence_split_up(drazil_send)
    sequence_received=sequence_split_up(dreamoon_received)
    total_len=sum(actual_sequence)
    actual_ans=actual_sequence[0]-actual_sequence[1]
    ans_received=sequence_received[0]-sequence_received[1]
    difference=actual_ans-ans_received
    no_of_blanks=sequence_received[2]
    if no_of_blanks==0:
        if actual_ans!=ans_received:
            return 0
        return 1
    if abs(difference)>no_of_blanks:
        return 0
    ans_set=[0,0]
    if difference>0:
        ans_set[0]+=difference
    elif difference<0:
        ans_set[1]+=abs(difference)
    blanks_left=no_of_blanks-abs(difference)
    ans_set[0]=ans_set[0]+blanks_left//2
    ans_set[1]=ans_set[1]+blanks_left//2
    x = (math.factorial(no_of_blanks)//(math.factorial(ans_set[0])*math.factorial(ans_set[1])))/math.pow(2,no_of_blanks)
    return x

drazil_send=input()
dreamoon_received=input()
print(""%.12f""%probability())
",np
"l,r=map(int,input().split())
lxr = l^r
msb = 0
while(lxr):
	msb+= 1
	lxr>>= 1
m = 0
t=1
while msb:
	m += t
	t <<= 1
	msb -= 1
print(m)
",O(logn)
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n,m=zzz()
arr = zzz()
s = sum(arr)
idx = [[] for i in range(m)]
for i in range(n):
    idx[arr[i]%m].append(i)
j=0
for i in range(m):
    while len(idx[i])>n//m:
        while j<i or len(idx[j%m])>=n//m:j+=1
        last = idx[i].pop()
        arr[last]+=(j-i)%m
        idx[j%m].append(last)
print(sum(arr)-s)
print(*arr)
",O(n)
"import sys
import math

prime=[True for _ in range(1000001)]

def solve():
    n,e,h,a,b,c=map(int,input().split())
    ans=1e9
    for i in range(1,1000001):
        su=0
        ntmp=n
        tmp1=e
        tmp2=h
        tmp1-=i
        tmp2-=i
        if (tmp1<0 or tmp2<0 or i>ntmp):
            break
        ntmp-=i
        su+=(c*i)
        if (ntmp==0):
            ans=min(ans,su)
            continue
        if (a<=b):
            if ((tmp1//2)>=ntmp):
                su+=int(a*ntmp)
                ntmp-=ntmp
            else:
                su+=int(a*(tmp1//2))
                ntmp-=(tmp1//2)
                if (ntmp<=(tmp2//3)):
                    su+=int(b*ntmp)
                    ntmp-=ntmp
                else:
                    su+=int(b*(tmp2//3))
                    ntmp-=(tmp2//3)
        else:
            if ((tmp2//3)>=ntmp):
                su+=int(b*ntmp)
                ntmp-=ntmp
            else:
                su+=int(b*(tmp2//3))
                ntmp-=(tmp2//3)
                if (ntmp<=(tmp1//2)):
                    su+=int(a*ntmp)
                    ntmp-=ntmp
                else:
                    su+=int(a*(tmp1//2))
                    ntmp-=(tmp1//2)
        if (ntmp==0):
            ans=min(ans,su)

    if (ans==1e9):
        print(""-1"")
    else:
        print(ans)

def main():
    n=int(input())
    s=input()
    m={}
    have={}
    cc=0
    for c in s:
        if (c not in m):
            m[c]=1
        else:
            m[c]+=1
    ct=len(m)
    l=0
    ans=1e9
    for i in range(0,n):
        if (s[i] not in have):
            have[s[i]]=0
            cc+=1
        have[s[i]]+=1
        while(l<=i and have[s[l]]>1):
            have[s[l]]-=1
            l+=1
        if (cc==ct):
            ans=min(ans,i-l+1)
    print(ans)

if __name__ == ""__main__"":
    main()",O(n)
"n, m = map(int, input().split())
boys = list(map(int, input().split()))
girls = list(map(int, input().split()))
boys.sort(reverse=True)
girls.sort(reverse=True)
s = sum(boys)
ma = max(boys)

res = 0
for i in range(0, m):

    if girls[i] < ma:
        print(-1)
        exit(0)
    res += s
    if (girls[i] == ma):
        girls[i] = 0
j = 0
usage = 0
for i in range(0, m):
    if (usage == m - 1):
        j += 1
    if (j >= n):
        print(-1)
        exit(0)

    res += max(0, girls[i] - boys[j])
    usage += 1
print(res)",O(nlogn)
"n,m=map(int,raw_input().split())
arr=[]
arr1=[]
for i in range(n):
	arr2=str(raw_input())
	arr.append(arr2)
	x1=[0]*m
	arr1.append(x1)
for i in range(n):
	for j in range(m):
		if(arr[i][j]=='
			if(arr[i][j+1]=='
				arr1[i][j]=1
				arr1[i+1][j]=1
				arr1[i+2][j]=1
				arr1[i+2][j+1]=1
				arr1[i+2][j+2]=1
				arr1[i+1][j+2]=1
				arr1[i][j+1]=1
				arr1[i][j+2]=1
flag=0

for i in range(n):
	for j in range(m):
		if(arr[i][j]==""
			flag=1
			break
	if(flag==1):
		break
if(flag==1):
	print(""NO"")
else:
	print(""YES"")",O(n ^ 2)
"import math
import random


class Solution(object):
    def minimizeError(self, prices, target):
        def kthElement(nums, k, compare=lambda a, b: a < b):
            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == k:
                    return
                elif new_pivot_idx > k:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
        
        errors = []
        lower, upper = 0, 0
        for i, p in enumerate(map(float, prices)):
            lower += int(math.floor(p))
            upper += int(math.ceil(p))
            if p != math.floor(p):
                errors.append(p-math.floor(p))
        if not lower <= target <= upper:
            return ""-1""

        lower_round_count = upper-target
        kthElement(errors, lower_round_count)
        result = 0.0
        for i in range(len(errors)):
            if i < lower_round_count:
                result += errors[i]
            else:
                result += 1.0-errors[i]
        return ""{:.3f}"".format(result)",O(n)
"n, k = [int(i) for i in input().split()]
for i in range(100*k+100*n):
    if i*(i+1) == (n+k-i)*2:
        print(n-i)
        break",O(n)
"class Solution3(object):
    def specialArray(self, nums):
        MAX_NUM = 1000
        def counting_sort(nums, reverse=False): 
            count = [0]*(MAX_NUM+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            result = [0]*len(nums)
            if not reverse:
                for num in reversed(nums): 
                    count[num] -= 1
                    result[count[num]] = num
            else:
                for num in nums: 
                    count[num] -= 1
                    result[count[num]] = num
                result.reverse()
            return result
    
        nums = counting_sort(nums, reverse=True) 
        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if nums[mid] <= mid:
                right = mid-1
            else:
                left = mid+1
        return -1 if left < len(nums) and nums[left] == left else left",O(n)
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        pass

    def __call__(self):
        s = list(input().strip())
        n = len(s)

        res = list()
        p = n - 1
        ones = 0
        zeros = 0
        while p >= 0:
            if s[p] == '0':
                zeros += 1
            elif s[p] == '1':
                ones += 1
            elif s[p] == '2':
                res.extend(['0'] * zeros)
                res.append('2')
                zeros = 0
            p -= 1
        res.extend(['1'] * ones)
        res.extend(['0'] * zeros)
        res.reverse()
        print(''.join(map(str, res)))

solver()()",O(n)
"class Solution2(object):
    def minOperations(self, nums, target):
        total = sum(nums)
        if total < target:
            return -1

        nums.sort()
        result = 0
        while target:
            x = nums.pop()
            if x <= target:
                target -= x
                total -= x
            elif total-x >= target:
                total -= x
            else:
                nums.append(x//2)
                nums.append(x//2)
                result += 1
        return result",O(nlogn)
"n = int(input())
k = set(""47"")
p = False
for i in range(1, n+1):
    if n%i == 0:
        if set(str(i)) <= k:
            p = bool(set(str(i)))
            break
if p == True:
    print(""YES"")
else:
    print(""NO"")",O(1)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"from sys import stdin
from math import factorial

n, mod = map(int, stdin.readline().split())

def binom(n, m):
    return factorial(n) // factorial(m) // factorial(n-m)

def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):
        sign = 1 if (i-k)%2 == 0 else -1
        ans += sign * binom(k, i) * (i**x)
        ans %= mod
    return ans

def f(x, k):
    return (foo(x, k) * pow(2, x-k, mod)) % mod

ans = 0
for i in range((n+1)//2):
    ans = (ans + f(n-i, i+1))
    ans %= mod
print(ans)",O(n ^ 2)
"def read4(buf):
    global file_content
    i = 0
    while i < len(file_content) and i < 4:
        buf[i] = file_content[i]
        i += 1

    if len(file_content) > 4:
        file_content = file_content[4:]
    else:
        file_content = """"
    return i






class Solution(object):
    def __init__(self):
        self.__buf4 = [''] * 4
        self.__i4 = 0
        self.__n4 = 0

    def read(self, buf, n):
        i = 0
        while i < n:
            if self.__i4 < self.__n4: 
                buf[i] = self.__buf4[self.__i4]
                i += 1
                self.__i4 += 1
            else:
                self.__n4 = read4(self.__buf4) 
                if self.__n4:
                    self.__i4 = 0
                else: 
                    break

        return i",O(n)
"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        nodes = []
        for lst in lists:
            while lst:
                nodes.append(lst.val)
                lst = lst.next
        nodes.sort()

        res = ListNode(0)
        cur = res
        for node in nodes:
            cur.next = ListNode(node)
            cur = cur.next
        return res.next
",O(nlogn)
"from sys import stdin, gettrace

if gettrace():
    inputi = input
else:
    def input():
        return next(stdin)[:-1]

    def inputi():
        return stdin.buffer.readline()

def main():
    r, g, b = map(int, inputi().split())
    rr = list(sorted(int(a) for a in inputi().split()))
    gg = list(sorted(int(a) for a in inputi().split()))
    bb = list(sorted(int(a) for a in inputi().split()))
    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
    res = 0
    for i in range(r, -1, -1):
        for j in range(g, -1, -1):
            for k in range(b, -1, -1):
                if i > 0 and j > 0:
                    dp[i-1][j-1][k] = max(dp[i-1][j-1][k], dp[i][j][k] + rr[i-1]*gg[j-1])
                if i > 0 and k > 0:
                    dp[i-1][j][k-1] = max(dp[i-1][j][k-1], dp[i][j][k] + rr[i-1]*bb[k-1])
                if j > 0 and k > 0:
                    dp[i][j-1][k-1] = max(dp[i][j-1][k-1], dp[i][j][k] + gg[j-1]*bb[k-1])
                res = max(res, dp[i-1][j-1][k], dp[i-1][j][k-1] , dp[i][j-1][k-1])
    print(res)

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"import sys
input = sys.stdin.readline
Q = int(input())
D = {""R"":0, ""G"":1, ""B"":2}
for _ in range(Q):
    N, K = map(int, input().split())
    S = input()
    mi = K
    for i in range(3):
        d = 0
        for j in range(N):
            if D[S[j]] != (i+j) % 3:
                d += 1
            if j >= K and D[S[j-K]] != (i+j-K) % 3:
                d -= 1
            if j >= K-1:
                mi = min(mi, d)
    print(mi)
",O(n)
"f=input
D,E=dict(),[eval(f())for i in range(int(f()))]
for e in E:D[e]=D.get(e,0)+1
for e in E:print(D[e])",O(n)
"global fact,inv_fact
def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):
	global fact, inv_fact

	max_n = min(max_n, mod - 1)

	fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
	fact[0] = 1
	for i in range(max_n):
		fact[i + 1] = fact[i] * (i + 1) % mod

	inv_fact[-1] = pow(fact[-1], mod - 2, mod)
	for i in reversed(range(max_n)):
		inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

make_nCr_mod()
def comb(n, r):
	mod=10**9+7
	global fact,inv_fact
	res = 1
	while n or r:
		a, b = n % mod, r % mod
		if a < b:
			return 0
		res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
		n //= mod
		r //= mod
	return res
def f():
	dp=[0]*(1000+100)
	dp[1]=1

	for i in range(2,len(dp)):
		o=bin(i).count(""1"")
		if o==1:
			dp[i]=2
		else:
			dp[i]+=dp[o]+1
	return dp

def bit(s,k):
	dp=f()
	l=[]
	ans=0
	ll=len(s)
	ans=0
	ones=0
	if k==0:
		return 1
	for i  in range(ll):
		if s[i]==""0"":
			continue
		else:
			for j in range(max(ones,1),1000):
				if dp[j]==k:
					ans=(ans+comb(ll-i-1,j-ones))%(10**9+7)
					if i==0 and k==1:
						ans-=1
		ones+=1
	if dp[ones]==k:
		ans+=1
	return (ans)%(10**9+7)

s=input().strip()
k=int(input())
print(bit(s,k))",O(n)
"import sys

input=lambda : sys.stdin.readline().strip()
char = [chr(i) for i in range(97,123)]
CHAR = [chr(i) for i in range(65,91)]
mp = lambda:list(map(int,input().split()))
INT = lambda:int(input())
rn = lambda:range(INT())

from math import ceil,sqrt,factorial,gcd

r,g,b = mp()
rl = sorted(mp(),reverse=True)
gl = sorted(mp(),reverse=True)
bl = sorted(mp(),reverse=True)

def solve(i,j,k):
	if dp_table[i][j][k] != -1:
		return dp_table[i][j][k]

	if i < r and j < g and k < b:
		m = max(solve(i+1,j+1,k)+(rl[i]*gl[j]), solve(i+1,j,k+1)+(rl[i]*bl[k]), solve(i,j+1,k+1)+(gl[j]*bl[k]))
		dp_table[i][j][k] = m
		return m

	elif i < r and j < g:
		m = solve(i+1,j+1,b) + rl[i]*gl[j]
		dp_table[i][j][k] = m
		return m

	elif i < r and k < b:
		m = solve(i+1,g,k+1) + (rl[i]*bl[k])
		dp_table[i][j][k] = m
		return m

	elif j < g and k < b:
		m = solve(r,j+1,k+1) + (gl[j]*bl[k])
		dp_table[i][j][k] = m
		return m
	else:
		return 0

dp_table = [[[-1]*(b+1) for j in range(g+1)] for k in range(r+1)]
res = solve(0,0,0)
print(res)
",O(n ^ 3)
"import collections
import functools



class Node(object):
    def __init__(self, val="" "", left=None, right=None):
        pass



class Solution(object):
    def checkEquivalence(self, root1, root2):
        def add_counter(counter, prev, d, val):
            if val.isalpha():
                counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d
            prev[0] = val
    
        def morris_inorder_traversal(root, cb):
            curr = root
            while curr:
                if curr.left is None:
                    cb(curr.val)
                    curr = curr.right
                else:
                    node = curr.left
                    while node.right and node.right != curr:
                        node = node.right
                    if node.right is None:
                        node.right = curr
                        curr = curr.left
                    else:
                        cb(curr.val)
                        node.right = None
                        curr = curr.right

        counter = collections.defaultdict(int)
        morris_inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1))
        morris_inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1))
        return all(v == 0 for v in counter.values())",O(n)
"from sortedcontainers import SortedList


class Solution2(object):
    def minimumCoins(self, prices):
        dp = [float(""inf"")]*(len(prices)+1)
        dp[0] = 0
        sl = SortedList()
        j = 0
        for i in range(len(prices)):
            sl.add((dp[i]+prices[i], i))
            while j+(j+1) < i:
                sl.remove(((dp[j]+prices[j], j)))
                j += 1
            dp[i+1] = sl[0][0]
        return dp[-1]",O(nlogn)
"import collections
import string

class Solution(object):
    def minDeletions(self, s):
        count = collections.Counter(s)
        result = 0
        lookup = set()
        for c in string.ascii_lowercase:
            for i in reversed(range(1, count[c]+1)):
                if i not in lookup:
                    lookup.add(i)
                    break
                result += 1
        return result",O(n)
"class Solution:
    def numDecodings(self, s: str) -> int:

        def dfs(i):
            if i == len(s):
                return 1
            if s[i] == '0':
                return 0

            res = dfs(i + 1)
            if i < len(s) - 1:
                if (s[i] == '1' or
                   (s[i] == '2' and s[i + 1] < '7')):
                    res += dfs(i + 2)

            return res

        return dfs(0)
",O(2 ^ n)
"class Solution2(object):
    def maximizeGreatness(self, nums):
        nums.sort()
        left = 0
        for right in range(len(nums)):
            if nums[right] > nums[left]:
                left += 1
        return left",O(n)
"
import bisect



class Solution(object):
    def minOperations(self, nums):
        def longest_non_increasing_subsequence(arr):
            result = []
            for x in arr:
                right = bisect.bisect_right(result, -x)
                if right == len(result):
                    result.append(-x)
                else:
                    result[right] = -x
            return len(result)
        
        return longest_non_increasing_subsequence(nums)
",O(nlogn)
"class Solution2(object):
    def plusOne(self, head):
        def reverseList(head):
            dummy = ListNode(0)
            curr = head
            while curr:
                dummy.next, curr.next, curr = curr, dummy.next, curr.next
            return dummy.__next__

        rev_head = reverseList(head)
        curr, carry = rev_head, 1
        while curr and carry:
            curr.val += carry
            carry = curr.val / 10
            curr.val %= 10
            if carry and curr.__next__ is None:
                curr.next = ListNode(0)
            curr = curr.__next__

        return reverseList(rev_head)",O(n)
"import collections



class Solution2(object):
    def maximumRobots(self, chargeTimes, runningCosts, budget):
        result = left = curr = 0
        dq = collections.deque()
        for right in range(len(chargeTimes)):
            while dq and chargeTimes[dq[-1]] <= chargeTimes[right]:
                dq.pop()
            dq.append(right)
            curr += runningCosts[right]
            while dq and chargeTimes[dq[0]]+(right-left+1)*curr > budget:
                if dq[0] == left:
                    dq.popleft()
                curr -= runningCosts[left]
                left += 1
            result = max(result, right-left+1)            
        return result",O(n)
"class Solution4(object):
    def rotate(self, nums, k):
        nums[:] = nums[len(nums) - k:] + nums[:len(nums) - k]",O(n)
"I=lambda:map(int,input().split())
n,s=I()
l=[0]
for i in range(n):
    q,w=I()
    q=q*60+w
    l+=[q]
if l[1]-l[0]>s:exit(print(0, 0))
for i in range(n):
    if l[i+1]-l[i]>2*s+1:
        l[i]+=s+1
        exit(print(l[i]//60,l[i]%60))
l[-1]+=s+1
print(l[-1]//60,l[-1]%60)",O(n)
"class Solution(object):
    def winnerOfGame(self, colors):
        cnt1 = cnt2 = 0
        for i in range(1, len(colors)-1):
            if not (colors[i-1] == colors[i] == colors[i+1]):
                continue
            if colors[i] == 'A':
                cnt1 += 1
            else:
                cnt2 += 1
        return cnt1 > cnt2",O(n)
"arra = []
arrb = []
arr = []
s = """"
temp = 1
value = ans = n = 0

def fill(myList = [], *args):
    for i in range(n):
        arra.insert(0,0)

def check():
    for i,j in zip(arra,arrb):
        if i == j:
            return 1
        else:
            return 0

def Engine1(num):
    if num > 1:
        Engine1(num // 2)
    arra.append( num%2 )
def Engine2(num):
    if num > 1:
        Engine2(num // 2)
    arrb.append( num%2 )

a,b = map(int,input().split())
Engine1(a)
Engine2(b)

n = abs(len(arra)-len(arrb))
if(len(arra)>len(arrb)):
    fill(arrb)
if(len(arra)<len(arrb)):
    fill(arra)

for i in range(len(arra)):
    if(check() == 0):
        break
    check()
    arra.pop(0)
    arrb.pop(0)

for i in range(len(arra)):
    ans += temp
    temp *= 2
print(ans)",O(logn)
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping
from itertools import groupby as gb
from fractions import Fraction as fr

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));
def ceildiv(x,y): return (x+y-1)//y

n=int(input())
if n==0:
    print(0)
else:
    if (n+1)%2:
        print(n+1)
    else:
        print((n+1)//2)
",O(1)
"n  = int(input())

a  = list(map(int, input().strip()))
b  = list(map(int, input().strip()))

res = 0

for j in range(n-1):
    if (a[j]== 0) and (a[j+1 ] == 1 ) and (b[j] == 1) and (b[j+1 ] == 0):
        res +=1
        a[j ] = 1
        a[j+1] = 0

    elif  (a[j]== 1) and (a[j+1] ==0 ) and (b[j] == 0) and (b[j+1 ] == 1):
        res +=1
        a[j ] = 0
        a[j+ 1] = 1

for j in range(n):
    if a[j] != b[j]:
        res += 1

print(res)",O(n)
"import random



class Solution(object):
    def outerTrees(self, trees):
        def dist(a, b):
            return ((a[0]-b[0])**2 + (a[1]-b[1])**2)**0.5

        def inside(c, p):
            return dist(c[0], p) < c[1]+EPS

        def circle_center(bx, by, cx, cy):
            B = bx*bx + by*by
            C = cx*cx + cy*cy
            D = bx*cy - by*cx
            return [float(cy*B - by*C)/(2*D),
                    float(bx*C - cx*B)/(2*D)]

        def circle_from_2_points(A, B):
            C = [(A[0]+B[0])/2.0, (A[1]+B[1])/2.0]
            return [C, dist(A, B)/2.0]

        def circle_from_3_points(A, B, C):
            I = circle_center(B[0]-A[0], B[1]-A[1],
                              C[0]-A[0], C[1]-A[1])
            I[0] += A[0]
            I[1] += A[1]
            return [I, dist(I, A)]

        def trivial(boundaries): 
            if not boundaries:
                return None
            if len(boundaries) == 1:
                return [boundaries[0], 0.0]
            if len(boundaries) == 2:
                return circle_from_2_points(boundaries[0], boundaries[1])
            return circle_from_3_points(boundaries[0], boundaries[1], boundaries[2])

        def Welzl(points, boundaries, curr):
            if curr == len(points) or len(boundaries) == 3:
                return trivial(boundaries)
            result = Welzl(points, boundaries, curr+1)
            if result is not None and inside(result, points[curr]):
                return result
            boundaries.append(points[curr])
            result = Welzl(points, boundaries, curr+1)
            boundaries.pop()
            return result

        EPS = 1e-5
        random.seed(0)
        random.shuffle(trees)
        result = Welzl(trees, [], 0)
        return result[0][0], result[0][1], result[1]",O(n)
"n=int(input())
if n==1 or n==2 :
    print(n)
elif n%2!=0 :
    m=n*(n-1)*(n-2)
    print(m)
elif n%3!=0 :
    m=n*(n-1)*(n-3)
    print(m)
else :
    m=(n-1)*(n-2)*(n-3)
    print(m)",O(1)
"class Solution(object):
    def numDecodings(self, s):
        if len(s) == 0 or s[0] == '0':
            return 0
        prev, prev_prev = 1, 0
        for i in range(len(s)):
            cur = 0
            if s[i] != '0':
                cur = prev
            if i > 0 and (s[i - 1] == '1' or (s[i - 1] == '2' and s[i] <= '6')):
                cur += prev_prev
            prev, prev_prev = cur, prev
        return prev",O(n)
"class Solution(object):
    def bagOfTokensScore(self, tokens, P):
        tokens.sort()
        result, points = 0, 0
        left, right = 0, len(tokens)-1
        while left <= right:
            if P >= tokens[left]:
                P -= tokens[left]
                left += 1
                points += 1
                result = max(result, points)
            elif points > 0:
                points -= 1
                P += tokens[right]
                right -= 1
            else:
                break
        return result",O(nlogn)
"class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):
        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
            if visited in lookup:
                return lookup[visited]

            mask = 1
            for i in range(maxChoosableInteger):
                if visited & mask == 0:
                    if i + 1 >= desiredTotal or \
                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):
                        lookup[visited] = True
                        return True
                mask <<= 1
            lookup[visited] = False
            return False

        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
            return False

        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})",O(n!)
"n, r = map(int, input().split())
y = []
x = list(map(int, input().split()))
for xi in x:
    yi = r
    for tx, ty in zip(x, y):
        if xi - 2 * r <= tx <= xi + 2 * r:
            dy = (4.0 * r ** 2 - (tx - xi) ** 2) ** 0.5
            yi = max(yi, ty + dy)
    y.append(yi)
print(*y)
",O(n ^ 2)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=999999999999999999999999
alphabets=""abcdefghijklmnopqrstuvwxyz""
class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

class SegTree:

    def __init__(self, n):
        self.N = 1 << n.bit_length()
        self.tree = [0] * (self.N<<1)

    def update(self, i, j, v):
        i += self.N
        j += self.N
        while i <= j:
            if i%2==1: self.tree[i] += v
            if j%2==0: self.tree[j] += v
            i, j = (i+1) >> 1, (j-1) >> 1

    def query(self, i):
        v = 0
        i += self.N
        while i > 0:
            v += self.tree[i]
            i >>= 1
        return v

def SieveOfEratosthenes(limit):

    isPrime = [True]*(limit+1)
    isPrime[0] = isPrime[1] = False
    primes = []
    for i in range(2, limit+1):
        if not isPrime[i]:continue
        primes += [i]
        for j in range(i*i, limit+1, i):
            isPrime[j] = False
    return primes

def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        a,b=ria()

        op=0
        while min(a,b):
            if a>b:
                op+=a//b
                a%=b
            else:
                op+=b//a
                b%=a

        wi(op)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(1)
"import math
n,m,k=map(int,input().split())
horz=[]
vert=[]
if k & 1:
    for i in range(n):
        temp=[-1 for j in range(m)]
        print(*temp)

else:
    for i in range(n):
        temp=list(map(int,input().split()))
        horz.append(temp)
    for i in range(n-1):
        temp=list(map(int,input().split()))
        vert.append(temp)
    dp=[[[0 for i in range(22)] for j in range(m)]for k in range(n)]
    for x in range(2,k+1,2):
        for i in range(n):
            for j in range(m):
                dp[i][j][x]=math.inf
                if i>0:
                     dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-2]+2*vert[i-1][j])
                if i<n-1:
                      dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-2]+2*vert[i][j])
                if j>0:
                     dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-2]+2*horz[i][j-1])
                if j<m-1:
                     dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-2]+2*horz[i][j])
    for i in range(n):
        temp=[]
        for j in range(m):
            temp.append(dp[i][j][k])
        print(*temp)",O(n ^ 3)
"import io
import os

import sys
from functools import lru_cache
from collections import defaultdict

sys.setrecursionlimit(10 ** 5)

def solve(N, A):

    valToLeftRight = defaultdict(lambda: defaultdict(set))

    valToRightLeft = defaultdict(lambda: defaultdict(set))

    for i, x in enumerate(A):
        valToLeftRight[x][i].add(i)
        valToRightLeft[x][i].add(i)

    maxVal = 1000 + 10
    for val in range(maxVal):
        for l, rights in valToLeftRight[val - 1].items():
            for r in rights:

                l2 = r + 1
                if l2 in valToLeftRight[val - 1]:
                    for r2 in valToLeftRight[val - 1][l2]:
                        assert l <= r
                        assert r + 1 == l2
                        assert l2 <= r2
                        valToLeftRight[val][l].add(r2)
                        valToRightLeft[val][r2].add(l)

                r2 = l - 1
                if r2 in valToRightLeft[val - 1]:
                    for l2 in valToRightLeft[val - 1][r2]:
                        assert l2 <= r2
                        assert r2 == l - 1
                        assert l <= r
                        valToLeftRight[val][l2].add(r)
                        valToRightLeft[val][r].add(l2)

    intervals = defaultdict(list)
    for val in range(maxVal):
        for l, rights in valToLeftRight[val].items():
            for r in rights:

                intervals[l].append(r)

    @lru_cache(maxsize=None)
    def getBest(left):

        if left == N:
            return 0
        best = float(""inf"")
        for right in intervals[left]:

            best = min(best, 1 + getBest(right + 1))
        return best

    return getBest(0)

def tup(l, r):

    return l * 16384 + r

def untup(t):

    return divmod(t, 16384)

def solve(N, A):

    cache = {}

    def f(lr):
        if lr not in cache:
            l, r = untup(lr)

            if r - l == 1:
                return tup(1, A[l])
            best = tup(float(""inf""), float(""inf""))
            for i in range(l + 1, r):

                lSplit = f(tup(l, i))
                rSplit = f(tup(i, r))
                lLen, lVal = untup(lSplit)
                rLen, rVal = untup(rSplit)
                if lLen != 1 or rLen != 1:

                    best = min(best, tup(lLen + rLen, 9999))
                else:
                    if lVal == rVal:

                        best = min(best, tup(1, lVal + 1))
                    else:

                        best = min(best, tup(2, 9999))
            cache[lr] = best

        return cache[lr]

    ans = untup(f(tup(0, N)))[0]

    return ans

if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    N, = list(map(int, input().split()))
    A = list(map(int, input().split()))
    ans = solve(N, A)
    print(ans)",O(n ^ 3)
"s, l= list(map(int,input().split()))
sig = []
utp = []
if s == 0 or l ==0:
    print('NO')
    quit()
for i in range(s):
    sig.append(list(map(int,input())))
for i in range(0,l):
    out = 0
    for x in range(0,s):
        out+=sig[x][i]
    utp.append(out)
sig = sorted(sig,key = sum)
for i in range(0,s):
    res1=0
    for x in range(0,l):
        if utp[x]-sig[i][x] <=0:
            break
        else:
            res1+=1
    if res1 == l:
        print('YES')
        quit()

print('NO')
",O(n ^ 2)
"l,r = map(int,input().split())

p = l
lp = -1
while p:
    p = p>>1
    lp+=1

q = r
rp = -1
while q:
    q = q>>1
    rp+=1

s = max(lp,rp)

n=0

while s>=0:
    if l>>s&1!=r>>s&1:
        n |= (r>>s&1)<<s
        break
    s-=1

s-=1

while s>=0:
    n |= 1<<s
    s-=1

print(n)
",O(logn)
"class Solution(object):
    def maximumScore(self, a, b, c):
        return min((a+b+c)//2, a+b+c - max(a, b, c))",O(1)
"a = list(input())
a = [int(x) for x in a]

b = list(input())
b = [int(x) for x in b]

n = len(a)
m = len(b)

ans = 0
for i in range(n):
    ans+=a[i]^b[i]
ones = [0 for i in range(m)]
zeros = [0 for i in range(m)]

for i in range(m):
    if b[i]:
        ones[i]=1
    else:
        zeros[i]=1

for i in range(1,m):
    ones[i]+=ones[i-1]
    zeros[i]+=zeros[i-1]

for i in range(n):
    if a[i]==1:
        ans+=zeros[m-n+i]-zeros[i]
    else:
        ans+=ones[m-n+i]-ones[i]
print(ans)
",O(n)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = 0
        posDiag = 0
        negDiag = 0
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            nonlocal col, posDiag, negDiag
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if ((col & (1 << c)) or (posDiag & (1 << (r + c)))
                    or (negDiag & (1 << (r - c + n)))):
                    continue
                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = ""Q""

                backtrack(r + 1)

                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        def dfs(i, flag):
            if i == len(nums):
                return 0 if flag else -1e6
            if flag:
                return max(0, nums[i] + dfs(i + 1, True))
            return max(dfs(i + 1, False), nums[i] + dfs(i + 1, True))
        return dfs(0, False)
",O(2 ^ n)
"import bisect
from itertools import accumulate
import os
import sys
import math
from decimal import *
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input():
    return sys.stdin.readline().rstrip(""\r\n"")

def isPrime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True

def SieveOfEratosthenes(n):
    prime = []
    primes = [True for i in range(n + 1)]
    p = 2
    while p * p <= n:

        if primes[p] == True:
            prime.append(p)
            for i in range(p * p, n + 1, p):
                primes[i] = False
        p += 1
    return prime

def primefactors(n):
    fac = []
    while n % 2 == 0:
        fac.append(2)
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 2):
        while n % i == 0:
            fac.append(i)
            n = n // i
    if n > 1:
        fac.append(n)
    return sorted(fac)

def factors(n):
    fac = set()
    fac.add(1)
    fac.add(n)
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            fac.add(i)
            fac.add(n // i)
    return list(fac)

def modInverse(a, m):
    m0 = m
    y = 0
    x = 1
    if m == 1:
        return 0
    while a > 1:
        q = a // m
        t = m
        m = a % m
        a = t
        t = y
        y = x - q * y
        x = t
    if x < 0:
        x = x + m0
    return x

n, k = map(int, input().split())
a = list(sorted(map(int, input().split()), reverse=True))
s = set()

for i in range(len(a)):
    if a[i] * k not in s:
        s.add(a[i])

print(len(s))",O(nlogn)
"input = raw_input

def f(n):
    t = (n + 1) // 2
    return t if n % 2 == 0 else -t

for i in range(int(input())):
    le, rg = map(int, input().split())

    print(f(rg) - f(le - 1))
",O(1)
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

def mapin():
    return map(int, input().split())

a, b, c, n = mapin()
d = a+b-c

if(d > n-1 or c > a or c > b):
    print(-1)
else:
    print(n-d)",O(1)
"class Solution(object):
    def rearrangeArray(self, nums):
        pos, neg = 0, 1
        result = [0]*len(nums)
        for x in nums:
            if x > 0:
                result[pos] = x
                pos += 2
            else:
                result[neg] = x
                neg += 2
        return result",O(n)
"class Solution2(object):
    def distMoney(self, money, children):
        if money < children*1:
            return -1
        money -= children*1
        q, r = divmod(money, 7)
        if q > children:
            return children-1
        if q == children:
            return q-int(r != 0)
        if q == children-1:
            return q-int(r == 3)
        return q",O(1)
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def solve(node, remain, adj, dp):
  if remain == 0:
    return 0
  key = (node, remain)
  mem = dp.get(key)
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))
  dp.set(key, ans)
  return ans

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = MDArray([total_nodes, k+2], -1)

  for i in range(n*m):
    dp.set((i, 0), 0)
  for t in range(1, k/2+1):
    for i in range(n*m):
      ans = min(map(lambda x: dp.get((x[0], t-1)) + x[1], adj[i]))
      dp.set((i, t), ans)

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(dp.get((node, k/2)) * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"n,m,k = list(map(int,input().split()))

l = list(map(int,input().split()))

out = 0
d = 0

while m > d:
    nex = l[d]
    page = (nex - d - 1)//k
    add = 1
    while d + add < m and (page * k) < l[d + add] - d  <= (page + 1) * k:
        add += 1
    d += add
    out += 1

print(out)
",O(n)
"class Solution2(object):
    def recoverFromPreorder(self, S):
        def recoverFromPreorderHelper(S, level, i):
            j = i[0]
            while j < len(S) and S[j] == '-':
                j += 1 
            if level != j - i[0]:
                return None
            i[0] = j
            while j < len(S) and S[j] != '-':
                j += 1
            node = TreeNode(int(S[i[0]:j]))
            i[0] = j
            node.left = recoverFromPreorderHelper(S, level+1, i)
            node.right = recoverFromPreorderHelper(S, level+1, i)
            return node

        return recoverFromPreorderHelper(S, 0, [0])",O(n)
"l,r=tuple(map(int,input().split("" "")))
x=l^r
pow=1
while(pow<=x) :
    pow*=2

print(pow-1)",O(logn)
"x, k = map(int, input().split())
mod = 1000000007
if x == 0:
    print(0)
else:
    print(int((pow(2, k+1, mod) * x - pow(2, k, mod) + 1) % mod))
",O(logn)
"class Solution(object):
    def findMin(self, nums):
        left, right = 0, len(nums)
        target = nums[-1]

        while left < right:
            mid = left + (right - left) / 2

            if nums[mid] <= target:
                right = mid
            else:
                left = mid + 1

        return nums[left]",O(logn)
"a0 = (1 << 30) - 1

a0 = 3
b0 = 1

def mock_query(c, d):
    res = (a0 ^ c) - (b0 ^ d)
    if res > 0:
        return 1
    elif res < 0:
        return -1
    else:
        return 0

def query2(c, d):
    ans = mock_query(c, d)
    print('? {:08b} {:08b} --> {}'.format(c, d, ans))
    return ans

def query(c, d):
    print('?', c, d)
    return int(input())

def solve():
    a = 0
    b = 0
    last_ans = query(0, 0)

    pos = 29
    while pos >= 0:
        bit = 1 << pos

        ans = query(a + bit, b + bit)
        if (last_ans, ans) == (1, -1):
            a += bit
            last_ans = query(a, b)
        elif (last_ans, ans) == (-1, 1):
            b += bit
            last_ans = query(a, b)

        else:
            last_ans = ans
            ans = query(a + bit, b)
            if ans == -1:
                a += bit
                b += bit

        pos -= 1

    print('!', a, b)

solve()
",O(logn)
"n = int(input())
arr = input().split()
b = []

for x in arr:
	b.append(int(x))

cnt = {}
ans = 0

for i in range(n):
	ans += b[i]*(i) + (-b[i])*(n - i - 1)

for i in range(n):
	if((b[i] - 1) in cnt.keys()):
		ans -= cnt[b[i] - 1]
	if((b[i] + 1) in cnt.keys()):
		ans += cnt[b[i] + 1]
	if((b[i]) in cnt.keys()):
		cnt[b[i]] += 1
	else:
		cnt[b[i]] = 1

print(ans)",O(nlogn)
"import sys
input = sys.stdin.readline
t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if len(set(a)) == 1:
        print(a[0],a[0],a[0],a[0])
    else:
        a.sort()
        g1 = False
        d = {}
        mx = 10001
        for i in a:
            if i not in d.keys():
                d[i] = 1
            else:
                d[i] += 1
            if d[i] == 4:
                g1 = True
                if i < mx:
                    mx = i
        if g1:
            print(mx, mx, mx, mx)
        else:
            res = []
            for k in d.keys():
                if d[k] >= 2:
                    res.append(k)
            m = len(res)
            minj = 0
            for j in range(m - 1):
                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):
                    minj = j
            print(res[minj],res[minj],res[minj+1],res[minj+1])",O(nlogn)
"from collections import defaultdict
n,k=map(int,input().split())
arr=list(map(int,input().split()))
xors=defaultdict(int)
xors[0]=1
comp=(1<<k)-1
xor=0
ans=n*(n+1)//2
for a in arr:
    xor^=a
    if(xors[xor]>xors[comp^xor]):
        xor^=comp
    ans-=xors[xor]
    xors[xor]+=1
print(ans)",O(n)
"n,m=map(int, input().split())
cols=[]
for i in range(n):
    cols.append(int(input()))
rows=[]
for i in range(m):
    k=list(map(int, input().split()))
    if k[0]==1:
        rows.append(k[1])
ans=n+m
cols.sort()
rows.sort()
cols.append(int(1e9))
j=0
rem=0

for i in cols:
    while j<len(rows) and rows[j]<i:
        j+=1
    ans=min(ans, len(rows)-j+rem)
    rem+=1
print(ans)
",O(nlogn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def __init__(self, root):
        def dfs(node, v, lookup):
            if not node:
                return
            node.val = v    
            lookup.add(v)
            dfs(node.left, 2*v+1, lookup)
            dfs(node.right, 2*v+2, lookup)

        self.__lookup = set()
        dfs(root, 0, self.__lookup)

    def find(self, target):
        return target in self.__lookup",O(n)
"n = int(input())
for i in range(n):
    p = int(input())
    a = list(map(int,input().split()))
    a = sorted(a)
    if p == 2:
        print(0)
        continue
    k = a[-2] - 1
    print(min(k, p - 2))",O(nlogn)
"class Solution(object):
    def maxEnergyBoost(self, energyDrinkA, energyDrinkB):
        dp = [0]*2
        for i in range(len(energyDrinkA)):
            dp = [max(dp[0]+energyDrinkA[i], dp[1]), max(dp[1]+energyDrinkB[i], dp[0])]
        return max(dp)",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import Counter, defaultdict
import bisect
import math

for _ in range(1):
    n = int(input())

    arr = list(map(int, input().split()))
    t=[0]*n
    cur=0
    for i in range(n-1,-1,-1):
        cur=max(cur-1,0,arr[i]+1)
        t[i]=cur
    ans=0
    for i in range(n):
        cur=max(cur,t[i])
        ans+=cur
    for i in range(n):
        ans-=(arr[i]+1)
    print(ans)
",O(n)
"n=int(input())
print(n//2+1)",O(1)
"class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        def dfs(i, flag):
            if i >= len(nums) or (flag and i == len(nums) - 1):
                return 0

            return max(dfs(i + 1, flag),
                       nums[i] + dfs(i + 2, flag or i == 0))
        return max(dfs(0, True), dfs(1, False))
",O(2 ^ n)
"h,b = map(int,input().split())
x,y,z = map(int,input().split())
print(max(0,2*x+y-h)+max(0,3*z+y-b))",O(1)
"class Solution(object):
    def maxWeight(self, pizzas):
        l = len(pizzas)//4
        pizzas.sort(reverse=True)
        return sum(pizzas[i] for i in range((l+1)//2))+sum(pizzas[i] for i in range((l+1)//2+1, ((l+1)//2+1)+(l//2)*2, 2))",O(nlogn)
"import collections


class Solution2(object):
    def countTriplets(self, A):
        count = collections.defaultdict(int)
        for i in range(len(A)):
            for j in range(len(A)):
                count[A[i]&A[j]] += 1
        result = 0
        for k in range(len(A)):
            for v in count:
                if A[k]&v == 0:
                    result += count[v]
        return result",O(n ^ 3)
"class Solution(object):
    def countDigits(self, num):
        result = 0
        curr = num
        while curr:
            result += int(num%(curr%10) == 0)
            curr //= 10
        return result",O(logn)
"class Solution(object):
    def findMinDifference(self, timePoints):
        minutes = [int(x[:2]) * 60 + int(x[3:]) for x in timePoints]
        minutes.sort()
        return min((y - x) % (24 * 60)  \
                   for x, y in zip(minutes, minutes[1:] + minutes[:1]))",O(nlogn)
"import sys

def chain_reaction(n, beacons):
    table = [0] * n

    for i in range(n):
        position = beacons[i][0]
        power = beacons[i][1]
        destroyed = 0
        r = position - power
        b = 0

        lo = 0
        hi = len(beacons) - 1
        while lo <= hi:
            mid = int(lo + (hi - lo) / 2)
            pos = beacons[mid][0]
            if beacons[mid][0] < r:
                lo = mid + 1
            else:
                hi = mid - 1

        destroyed += table[hi]

        destroyed += (i - (hi + 1))
        table[i] = destroyed

    max_val = max(table)
    ind = 0
    while ind < len(table):
        if table[ind] == max_val:
            break
        ind += 1
    cost = (len(table) - ind) + table[ind - 1]

    options = []
    for i in range(n):
        cost = (n - i) + table[i - 1]
        options.append(cost)
    min_cost = min(options)

    return min(table[n - 1], min_cost)

n = int(sys.stdin.readline().strip())
beacons = []
for i in range(n):
    a, b = [int(x) for x in sys.stdin.readline().strip().split("" "")]
    beacons.append((a, b))
beacons.sort()
print(chain_reaction(n, beacons))",O(n)
"class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None


class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

    def find(self, key):
        curr = self.head
        while curr:
            if curr.key == key:
                break
            curr = curr.__next__
        return curr


class Solution(object):

    def __init__(self):
        self.__data = [LinkedList() for _ in range(10000)]

    def add(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if not node:
            l.insert(ListNode(key, 0))

    def remove(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            l.delete(node)

    def contains(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        return node is not None",O(n)
"from sys import stdin, stdout
mod=(10**9)+7
mod1=mod-1
def modinv(n,p):
    return pow(n,p-2,p)
def ncr(n,r,p):
    t=((fact[n])*(modinv(fact[r],p)%p)*(modinv(fact[n-r],p)%p))%p
    return t
def GCD(x, y):
   while(y):
       x, y = y, x % y
   return x
def BS(arr, l, r, x):
    if r >= l:
        mid = l + (r - l)/2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return BS(arr, l, mid-1, x)
        else:
            return BS(arr, mid+1, r, x)
    else:n -1
from bisect import bisect_left as bl
from bisect import bisect_right as br
import itertools
import math
from Queue import Queue as Q
import heapq
from random import randint as rn
def comp(x,y):
    if(x[0]<y[0]):
        return -1
    elif(x[0]==y[0]):
        if(x[1]<y[1]):
            return -1
        else:
            return 1
    else:
        return 1

q=[]
for _ in range(input()):
    a=int(stdin.readline())
    b=map(int,stdin.readline().split())
    w={}
    for i in range(a):
        if(w.has_key(b[i])):
            w[b[i]]+=1
        else:
            w[b[i]]=1
    s=-1
    l=0
    mi=2325234324324234
    d=[]
    for i in w:
        if(w[i]>=4):
            t=[str(i),str(i),str(i),str(i)]
            q.append("" "".join(t))
            l=1
            break
        if(w[i]>=2):
            d.append(i)
    if(l==1):
        continue
    d.sort()
    for i in range(len(d)):
        if(s==-1):
            s=d[i]
        else:
            r=float(s)/float(d[i])
            r+=float(d[i])/float(s)
            if(r<mi):
                p=[str(d[i]),str(s)]
                mi=r
            s=d[i]
    p=p*2
    q.append("" "".join(p))
stdout.write(""\n"".join(q))
",O(nlogn)
"import bisect



class Solution4(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        def check(prefix, total, x):
            return (prefix[x]-prefix[x-1])*x-prefix[x] <= total

        def binary_search_right(prefix, total, left, right):
            while left <= right:
                mid = left+(right-left)//2
                if not check(prefix, total, mid):
                    right = mid-1
                else:
                    left = mid+1
            return right
    
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in range(n):
            prefix[i+1] = prefix[i]+flowers[i]
        result = suffix = 0
        left = n
        for right in reversed(range(n+1)):
            if right != n:
                suffix += flowers[right]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                break
            left = binary_search_right(prefix, total, 1, right)
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result",O(nlogn)
"import sys
input = sys.stdin.readline

def main():
    n = int(input())
    alst = [int(input()) for _ in range(n)]
    ans = []
    for a in alst:
        if a == 1:
            ans.append(""1"")
            print(""."".join(ans))
            continue
        while ans and int(ans[-1]) != a - 1:
            ans.pop()
        if not ans:
            ans.append(str(a))
        else:
            ans.pop()
            ans.append(str(a))

        print(""."".join(ans))

for _ in range(int(input())):
    main()",O(n ^ 2)
"import itertools


class Solution(object):
    def sortSentence(self, s):
        words = s.split()
        for i in range(len(words)):
            while int(words[i][-1])-1 != i:
                words[int(words[i][-1])-1], words[i] = words[i], words[int(words[i][-1])-1]
        return "" "".join(map(lambda x: x[:-1], words))",O(n)
"class Solution(object):
    def isUnivalTree(self, root):
        s = [root]
        while s:
            node = s.pop()
            if not node:
                continue
            if node.val != root.val:
                return False
            s.append(node.left)
            s.append(node.right)
        return True
    ",O(n)
"x, k = map(int, input().split())

md = 10 ** 9 + 7

res = x * pow(2, k + 1, md) - pow(2, k, md) + 1 if x > 0 else 0
print(res % md)
",O(logn)
"class Solution(object):
    def encode(self, num):
        result = []
        while num:
            result.append('0' if num%2 else '1')
            num = (num-1)//2
        return """".join(reversed(result))",O(logn)
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left,bisect
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
n=int(input())
l=list(map(int,input().split()))
x=dc(int)
y=dc(int)
z=dc(int)
p=dc(int)
q=dc(int)
r=dc(int)
x[l[-1]]+=1
y[l[-1]]+=1
z[l[-1]]+=1
for i in range(n-2,-1,-1):
    p[i]=x[l[i]]
    q[i]=y[l[i]+1]
    r[i]=z[l[i]-1]
    x[l[i]]+=1
    y[l[i]]+=1
    z[l[i]]+=1

x=[0]*n
for i in range(n-2,-1,-1):
    x[i]=l[i+1]+x[i+1]

s=0
for i in range(n-2,-1,-1):

    c=x[i]-(p[i]*l[i])-(q[i]*(l[i]+1))-(r[i]*(l[i]-1))
    d=n-i-1-p[i]-q[i]-r[i]
    e=c-l[i]*d

    s+=e
print(s)",O(nlogn)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if self.isSafe(r, c, board):
                    board[r][c] = ""Q""
                    backtrack(r + 1)
                    board[r][c] = "".""

        backtrack(0)
        return res

    def isSafe(self, r: int, c: int, board):
        row = r - 1
        while row >= 0:
            if board[row][c] == ""Q"":
                return False
            row -= 1

        row, col = r - 1, c - 1
        while row >= 0 and col >= 0:
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col -= 1

        row, col = r - 1, c + 1
        while row >= 0 and col < len(board):
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col += 1
        return True
",O(n!)
"class Solution(object):
    def maxNonDecreasingLength(self, nums1, nums2):
        result = 1
        dp = [1]*2
        for i in range(len(nums1)-1):
            dp = [max((dp[0]+1 if nums1[i] <= nums1[i+1] else 1), (dp[1]+1 if nums2[i] <= nums1[i+1] else 1)),
                  max((dp[0]+1 if nums1[i] <= nums2[i+1] else 1), (dp[1]+1 if nums2[i] <= nums2[i+1] else 1))]
            result = max(result, max(dp))
        return result",O(n)
"import collections


class Solution(object):
    def distinctNumbers(self, nums, k):
        result = []
        count = collections.Counter()
        for i, num in enumerate(nums):
            count[num] += 1
            if i >= k:
                count[nums[i-k]] -= 1
                if not count[nums[i-k]]:
                    del count[nums[i-k]]
            if i+1 >= k:
                result.append(len(count))
        return result",O(n)
"from sys import stdin, stdout
import math
import heapq
from itertools import accumulate

Q = int(input())

four = []

for i in range(62):
    four.append(4**i)

for i in range(Q):
    N,K = [int(x) for x in stdin.readline().split()]

    tmp_N = N
    if N>=60:
        N = 60

    dk = (4**(N)-1)//3
    if K>dk:
        print('NO')
        continue

    seq = []
    block = []
    s = 0
    for i in range(N):
        s += 2**(i+1) - 1
        block.append(2**(i+1)-1)
        seq.append(s)

    if K>=seq[-1]:
        print('YES',0)
        continue

    for i in range(N-1):
        if K>=seq[i] and K<seq[i+1]:
            d = K-seq[i]
            happy = tmp_N-i-1
            round = i+1
            break

    block = block[::-1]

    res = 0
    for i in range(round):
        A = (4**(i+1)-1)//3
        B = block[i] - 2
        res += A*B

    if d<=res:
        print('YES',happy)
    else:
        print('NO')
",O(logn)
"t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int,input().split()))
    a.sort()
    if a[-2]>n-2:
        print(n-2)
    else:
        print(a[-2]-1)",O(nlogn)
"n, t = [int(item) for item in input().split(' ')]
cont, ans = [], 2
for i in range(n):

    temp = list(map(int, input().split(' ')))
    house_center, house_len = temp[0], temp[1]
    cont.append([house_center - house_len / 2, house_center + house_len / 2])

cont.sort(key=lambda element: element[0])

for i in range(0,n - 1):
    gap = cont[i+1][0] - cont[i][1]
    if gap > t:
        ans += 2
    elif gap == t:
        ans += 1

print(ans)
",O(nlogn)
"from math import factorial
f=lambda:input()
a=f()
b=f()
s=0
s1=0
c=0
for i in a:
    if i=='+':
       s+=1
    else:
       s-=1
for i in b:
    if i=='+':
       s1+=1
    elif i=='-':
       s1-=1
    else:
       c+=1
if c==0:
    if s==s1:
        print(c+1)
    else:
        print(c)
else:
    l=[]
    k=c
    i=c
    j=0
    while i>=0:
        l.append(k)
        i-=1
        j+=1
        k=0
        k+=i
        k-=j
    if s1!=0:
        for i in range(len(l)):
            l[i]+=s1
    try:
        c1=l.index(s)
        k=factorial(c)/(factorial(c-c1)*factorial(c1))
        print(k/pow(2,c))
    except:
        print(0.0)",np
"T=int(input())
for _ in range(T):
    n,k=map(int,input().split())
    s=input()
    rq1=''
    rq2=''
    rq3=''

    for i in range(k):
        if(i%3==0):
            rq1=rq1+'R'
            rq2=rq2+'G'
            rq3=rq3+'B'
        elif(i%3==1):
            rq1=rq1+'G'
            rq2=rq2+'B'
            rq3=rq3+'R'
        elif(i%3==2):
            rq1=rq1+'B'
            rq2=rq2+'R'
            rq3=rq3+'G'

    ans=1000000000000000000

    for i in range(0,len(s)-k+1):

        a1=0
        a2=0
        a3=0

        for j in range(i,i+k):

            if(s[j]!=rq1[j-i]):
                a1+=1
            if(s[j]!=rq2[j-i]):
                a2+=1
            if(s[j]!=rq3[j-i]):
                a3+=1

        ans=min(ans,min(a1,a2,a3))

    print(ans)
",O(n ^ 2)
"n = int(input())
probs = list()
for i in range(n): probs.append(list(map(float, input().split())))
dp = [list([0 for i in range(1<<n)]) for i in range(n)]
dp[0][(1<<n)-1] = 1
ak = [list() for i in range(n+1)]
for i in range(1<<n):
    ak[bin(i).count(""1"")].append(i)
for k in range(1, n):
    for ele in ak[n-k+1]:
        for j in range(n):
            if (ele&(1<<j)):
                for w in range(n):
                    if (ele&(1<<w)) and j != w:
                        dp[k][ele-(1<<j)] += (dp[k-1][ele]*probs[w][j])/(((n-k+1)*(n-k))/2)
for i in range(n):
    print(dp[n-1][(1<<i)], end = "" "")
print()",np
"class Solution(object):
    def numDifferentIntegers(self, word):
        result, num = set(), None
        for i in range(len(word)+1):
            c = word[i] if i < len(word) else ' '
            if c.isdigit():
                num = 10*num+int(c) if num is not None else int(c)
            elif num is not None:
                result.add(num)
                num = None
        return len(result)",O(n)
"from math import sqrt as sqrt
n, k = map(int, input().split())
t = int(sqrt(8 * n + 8 * k + 9) + 0.0001)
m = (t - 3) // 2
print(n - m)",O(1)
"class Solution(object):
    def maxScore(self, cardPoints, k):
        result, total, curr, left = float(""inf""), 0, 0, 0
        for right, point in enumerate(cardPoints):
            total += point
            curr += point
            if right-left+1 > len(cardPoints)-k:
                curr -= cardPoints[left]
                left += 1
            if right-left+1 == len(cardPoints)-k:
                result = min(result, curr)
        return total-result",O(n)
"import sys
import math
import heapq
import bisect
from collections import Counter
from collections import defaultdict
from io import BytesIO, IOBase
import string

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
        self.BUFSIZE = 8192

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def get_int():
    return int(input())

def get_ints():
    return list(map(int, input().split(' ')))

def get_int_grid(n):
    return [get_ints() for _ in range(n)]

def get_str():
    return input().split(' ')

def yes_no(b):
    if b:
        return ""YES""
    else:
        return ""NO""

def prefix_sums(a):
    p = [0]
    for x in a:
        p.append(p[-1] + x)
    return p

def binary_search(good, left, right, delta=1, right_true=False):
    limits = [left, right]
    while limits[1] - limits[0] > delta:
        if delta == 1:
            mid = sum(limits) // 2
        else:
            mid = sum(limits) / 2
        if good(mid):
            limits[int(right_true)] = mid
        else:
            limits[int(~right_true)] = mid
    if good(limits[int(right_true)]):
        return limits[int(right_true)]
    else:
        return False

def solve_a():
    n = get_int()
    m = get_int()
    a = get_ints()
    b = get_ints()

    def good(k):
        for i in range(n):
            k -= (m + k) / a[i]
            k -= (m + k) / b[i]
        return k >= 0

    ans = binary_search(good, 0, 10 ** 9 + 1, delta=10 ** (-6), right_true=True)
    if not ans:
        return -1
    else:
        return ans

print(solve_a())
",O(n)
"class Solution(object):
    def removeDigit(self, number, digit):
        i = next((i for i in range(len(number)-1) if digit == number[i] < number[i+1]), len(number)-1)
        if i+1 == len(number):
            i = next((i for i in reversed(range(len(number))) if digit == number[i]))
        return number[:i]+number[i+1:]",O(n)
"import sys
input = sys.stdin.buffer.readline

from collections import deque

n,d,k=map(int,input().split())

if d>=n:
    print(""NO"")
    exit()

graph=[[] for i in range(n+1)]

for i in range(1,d+2):
    graph[i].append(min(i-1,d+1-i))

for i in range(1,d+1):
    graph[i].append(i+1)
    graph[i+1].append(i)

deg=[0]*(n+1)
deg[1]=1
deg[d+1]=1
for i in range(2,d+1):
    deg[i]=2

for i in deg:
    if i>k:
        print(""NO"")
        exit()

p=d+2
for i in range(1,d+2):
    q=deque()
    q.append(i)
    while len(q)!=0:
        x=q.popleft()
        while (graph[x][0]>0 and deg[x]<k and p<=n):
            graph[x].append(p)
            deg[x]=deg[x]+1
            graph[p].append(graph[x][0]-1)
            graph[p].append(x)
            deg[p]=deg[p]+1
            q.append(p)
            p=p+1

if p<=n:
    print(""NO"")
else:
    print(""YES"")
    vis=[-1]*(n+1)

    for i in range(1,d+2):
        if vis[i]==-1:
            q=deque()
            q.append(i)
            while len(q)!=0:
                x=q.popleft()
                vis[x]=1
                for j in range(1,len(graph[x])):
                    if vis[graph[x][j]]==-1:
                        print(x,graph[x][j])
                        q.append(graph[x][j])
",O(n ^ 2)
"N = 10**5+5
MOD = 10**9+7

freq = [0 for i in range(N)]

p2 = [0 for i in range(N)]
p2[0] = 1
for i in range(1,N):
    p2[i] = p2[i-1]*2
    p2[i]%=MOD

def Calculate_Mobius(N):
    arr = [1 for i in range(N+1)]
    prime_count = [0 for i in range(N+1)]

    mobius_value = [0 for i in range(N+1)]
    for i in range(2,N+1):
        if prime_count[i]==0:
            for j in range(i,N+1,i):
                prime_count[j]+=1
                arr[j] = arr[j] * i

    for i in range(1, N+1):
        if arr[i] == i:
            if (prime_count[i] & 1) == 0:
                mobius_value[i] = 1
            else:
                mobius_value[i] = -1
        else:
            mobius_value[i] = 0

    return mobius_value

mobius = Calculate_Mobius(N)
n = int(input())
b = [int(i) for i in input().split()]

for i in b:
    freq[i]+=1

ans = 0
for i in range(1,N):

    cnt = 0
    for j in range(i,N,i):
        cnt += freq[j]

    total_subsequences = p2[cnt] - 1
    ans = (ans + (mobius[i] * total_subsequences)%MOD)%MOD

ans += MOD
print(ans%MOD)
",np
"n, s = map(int, input().split())
if s % n == 0:
    print(s // n)
else:
    print(s // n + 1)
",O(1)
"n,s=map(int,input().split())
arr=[]
for i in range(n):
    arr.append([])
    arr[i]=[int(i) for i in input().split()]
arr=sorted(arr,reverse=True,key=lambda x:x[0])
ans,c=0,0
for i in range(n):
    if i!=0:
       c=arr[i-1][0]
    if i==0:
       ans=ans+s-arr[i][0]
    else:
       ans=ans+c-arr[i][0]
    if arr[i][1]>=ans:
        ans=ans+(arr[i][1]-ans)
ans=ans+arr[n-1][0]
print(ans)
",O(n)
"def main():
    n = int(input())
    arr = list(map(int, input().split()))
    ans = 10 ** 10
    for i in range(n):
        x = i if i > n - i - 1 else n - i - 1
        ans = min(ans, arr[i] // x)
    print(ans)
main()",O(n)
"n= int(input())
b = [int(_) for _ in input().split()]
d = [[b[i] if i == j else -1 for i in range(n)] for j in range(n)]

def f(i, j):
	if d[i][j] != -1:
		return d[i][j]
	d[i][j] = 0
	for m in range(i, j):
		l = f(i, m)
		if f(m+1, j) == l and l:
			d[i][j] = l+1
			break
	return d[i][j]

a = [_ for _ in range(1, n+1)]
for e in range(1, n):
	for s in range(e+1):
		if f(s, e):
			a[e] = min(a[e], ((a[s-1]+1) if s > 0 else a[s]))
print(a[-1])",O(n ^ 3)
"from math import fabs
n = int(input())
nots = [int(s) for s in input().split()]
map = [0]
ampl = 0
possible = True
zer = False
f_s = True

for i in range(len(nots) - 1):
    if nots[i] == nots[i + 1]:
        if ampl != 0:
            map.append(ampl)
            if ampl <= -5 or ampl >= 5: possible = False
        map.append(0)
        zer = True
        ampl = 0
    else:
        if nots[i] < nots[i + 1]:
            if ampl < 0 and f_s != True:
                map.append(ampl)
                if ampl == -5: possible = False
                ampl = 1
            else:
                ampl += 1
        else:
            if ampl > 0 and f_s != True:
                map.append(ampl)
                if ampl == 5: possible = False
                ampl = -1
            else:
                ampl += -1
    f_s = False
if ampl != 0:
    map.append(ampl)
    if ampl == -5 or ampl == 5: possible = False
if len(nots) == 1:
    map.append(0)
map.append(0)

if possible == True:
    if zer == True:
        l = len(map)
        for i in range(1, l - 1):
            if map[i] == 0:
                if map[i - 1] == 4: map[i] = -1
                if map[i - 1] == -4: map[i] = 1
                if map[i + 1] == 4: map[i] = -1
                if map[i + 1] == -4: map[i] = 1

        for i in range(1, l-1):
            if map[i] == 0:
                if map[i - 1] >= 0 and map[i + 1] >= 0: map[i] = -1
                if map[i - 1] > 0 and map[i + 1] < 0: map[i] = 1
                if map[i - 1] < 0 and map[i + 1] > 0: map[i] = -1
                if map[i - 1] <= 0 and map[i + 1] <= 0: map[i] = 1

        fin = []
        ampl = map[1]
        for i in range(1, l - 1):
            if map[i] * map[i + 1] > 0:
                ampl += map[i + 1]
            if map[i] * map[i + 1] < 0:
                fin.append(ampl)
                if ampl >= 5 or ampl <= -5: possible = False
                ampl = map[i + 1]
        fin.append(ampl)

        if possible == True:
            fin[-1] = int(fabs( fin[-1] ) / fin[-1] * (fabs( fin[-1] ) + 1))
            appl = []
            for i in range( len(fin) ):
                if fin[i] > 0:
                    for j in range(1, fin[i] + 1):
                        appl.append(j)
                if fin[i] < 0:
                    for j in range(5, 5 + fin[i], -1):
                        appl.append(j)

    else:
        appl = []
        try:
            map[-2] = int(fabs(map[-2]) / map[-2] * (fabs(map[-2]) + 1))
        except ZeroDivisionError:
            appl = [1]
        for i in range(len(map)):
            if map[i] > 0:
                for j in range(1, map[i] + 1):
                    appl.append(j)
            if map[i] < 0:
                for j in range(5, 5 + map[i], -1):
                    appl.append(j)

    for finger in appl:
        print(finger, end = ' ')
if possible == False:
    print(-1)
",O(n ^ 2)
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    l=sorted(zip(lst(),range(n)))
    p=0;ans=[0]*(2*n)
    st=[0]*n;ln=0
    s=input()
    for i in range(2*n):

        ch=s[i]
        if ch=='0':
            st[ln]=p
            ans[i]=l[p][1]+1
            ln+=1
            p+=1
        else:
            ans[i]=l[st[ln-1]][1]+1
            ln-=1
    print(*ans)",O(nlogn)
"import itertools
import heapq



class Solution(object):
    def maxScore(self, nums1, nums2, k):
        result = curr = 0
        min_heap = []
        for a, b in sorted(zip(nums1, nums2), key=lambda x: x[1],  reverse=True):
            curr += a
            heapq.heappush(min_heap, a)
            if len(min_heap) > k:
                curr -= heapq.heappop(min_heap)
            if len(min_heap) == k:
                result = max(result, curr*b)
        return result",O(nlogn)
"def solution(n, k):
    ret = [['.' for _ in range(n)] for _ in range(4)]
    if 1 == k & 1:
        ret[1][n >> 1] = '
        for i in range(1, n >> 1):
            if k < 2:
                break
            k -= 2
            ret[1][i] = '
            ret[1][n - 1 - i] = '
        for i in range(1, n >> 1):
            if k < 2:
                break
            k -= 2
            ret[2][i] = '
            ret[2][n - 1 - i] = '
    else:
        for i in range(1, n - 1):
            if k < 2:
                break
            k -= 2
            ret[1][i] = '
            ret[2][i] = '

    print('YES')
    for i in range(4):
        print(''.join(ret[i]))

solution(*map(int, input().split()))
",O(n)
"class Solution_Recu(object):
    def copyRandomBinaryTree(self, root):
        def dfs(node, callback):
            if not node:
                return None
            left_node, copy = callback(node)
            dfs(left_node, callback)
            dfs(node.right, callback) 
            return copy
    
        def merge(node):
            copy = NodeCopy(node.val)
            node.left, copy.left = copy, node.left
            return copy.left, copy
        
        def clone(node):
            copy = node.left
            node.left.random = node.random.left if node.random else None
            node.left.right = node.right.left if node.right else None
            return copy.left, copy
        
        def split(node):
            copy = node.left
            node.left, copy.left = copy.left, copy.left.left if copy.left else None
            return node.left, copy
    
        dfs(root, merge)
        dfs(root, clone)
        return dfs(root, split)


",O(n)
"class Solution2(object):
    def getLonelyNodes(self, root):
        def dfs(node, result):
            if not node:
                return
            if node.left and not node.right:
                result.append(node.left.val)
            elif node.right and not node.left:
                result.append(node.right.val)
            dfs(node.left, result)
            dfs(node.right, result)

        result = []
        dfs(root, result)
        return result",O(n)
"def pow1(n, k):
    if k == 0:
        return 1
    if k == 1:
        return n
    else:
        if k % 2 == 0:
            a = pow1(n, k // 2) % mod
            return a * a % mod
        else:
            return pow1(n, k - 1) % mod * n % mod

mod = 10 ** 9 + 7
n, k = map(int, input().split())
if n == 0:
    print(0)
else:
    x = pow1(2, k + 1) % mod
    print(((n * x - pow1(2, k) + 1)) % mod)",O(logn)
"a,b,c,d,e,f,g,h,i,j,k,l= [9*1, 90*2, 900*3, 9000*4, 90000*5, 900000*6, 9000000*7, 90000000*8, 900000000*9, 9000000000*10, 90000000000*11, 900000000000*12]
a=a; b= a+b; c= b+c; d=c+d; e=d+e; f= e+f; g= f+g; h=g+h; i=h+i; j= i+j
k= j+k; l= k+l
li1=[0,a,b,c,d,e,f,g,h,i,j,k,l]
n= int(input()); nn=0
for ii in range(1,12):
    if li1[ii-1]<n and li1[ii+1]>n:
        nn= ii

n= n-li1[nn-1]
r1= 10**(nn-1)
n1= n//nn
r1+= n1-1
n2= n-(n1*nn)
if n2==0:
    print(str(r1)[-1])
else:

    print(str(r1+1)[n2-1])",O(logn)
"n,m=[int(x) for x in input().split()]
a=sorted([int(x) for x in input().split()])
b=[int(x) for x in input().split()]
if max(a)<min(b):
    print(sum(a)*m+sum(b)-a[-1]*(m-1)-a[-2])
elif max(a)==min(b):
    print(sum(a)*m+sum(b)-a[-1]*m)
else:
    print(-1)
",O(nlogn)
"n, m = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))
mab = max(b)
mig = min(g)
if mab > mig:
    print(-1)
    exit()

b = sorted(b, reverse=True)
g = sorted(g)
num = 0
j = 0
for i in range(n):
    k = 0
    l = 1
    while j < m and k < m - l and b[i] <= g[j]:
        if b[i] == g[j]:
            l = 0
        num += g[j]
        j += 1
        k += 1
    num += b[i] * (m - k)

print(num)",O(nlogn)
"from sys import stdin, stdout

n = int(stdin.readline())
values = list(map(int, stdin.readline().split()))

cnt = 0
for i in range(n):
    for j in range(i + 1, n):
        if values[i] > values[j]:
            cnt += 1

m = int(stdin.readline())
for i in range(m):
    l, r = map(int, stdin.readline().split())
    n = r - l + 1

    cnt += n * (n - 1) // 2
    cnt &= 1

    if cnt == 1:
        stdout.write('odd\n')
    else:
        stdout.write('even\n')",O(n ^ 2)
"import collections


class Solution(object):

    def __init__(self, v1, v2):
        self.q = collections.deque([(len(v), iter(v)) for v in (v1, v2) if v])

    def __next__(self):
        len, iter = self.q.popleft()
        if len > 1:
            self.q.append((len-1, iter))
        return next(iter)

    def hasNext(self):
        return bool(self.q)",O(1)
"class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        n = len(gas)

        for i in range(n):
            tank = gas[i] - cost[i]
            if tank < 0:
                continue
            j = (i + 1) % n
            while j != i:
                tank += gas[j]
                tank -= cost[j]
                if tank < 0:
                    break
                j += 1
                j %= n
            if j == i:
                return i
        return -1
",O(n ^ 2)
"n = int(input())
ans = 0
mod = 998244353
a = list(map(int, input().split()))
p = 1 / 2

for i in range(n):
    ans = (ans + (i + 2) * (p * a[n - i - 1] % mod) % mod) % mod
    p = (2 * p) % mod

print(int(ans) % mod)",O(n)
"class Solution(object):

    def distributeCandies(self, candies):
        lookup = set(candies)
        return min(len(lookup), len(candies)/2)",O(n)
"n = int(input())
m = int(input())
r = 1
for power in range(n):
    r *= 2
    if r > m:
        print(m)
        break
else:
    if r == m:
        print(0)
    else:
        print(m % r)
",O(1)
"a, b= list(map(int, input().split()))
c = 1
result = a^b
while c <= result:
    c *= 2
c -= 1

print(c)
",O(logn)
"x, y, z, t1, t2, t3 = map(int, input().split())
ladder = abs(x - y) * t1
elevator = abs(x - z) * t2 + 3 * t3 + abs(x - y) * t2
if elevator > ladder:
	print(""NO"")
else:
	print(""YES"")",O(1)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key = lambda pair: pair[1])
        prevEnd = intervals[0][1]
        res = 0

        for i in range(1, len(intervals)):
            if prevEnd > intervals[i][0]:
                res += 1
            else:
                prevEnd = intervals[i][1]

        return res
",O(nlogn)
"class Solution(object):
    def maximumBeauty(self, nums, k):
        nums.sort()
        left = 0
        for right in range(len(nums)):
            if nums[right]-nums[left] > k*2:
                left += 1
        return right-left+1",O(nlogn)
"import heapq



class Solution(object):
    def minimumDifference(self, nums):
        max_heap = []
        for i in range(len(nums)//3):
            heapq.heappush(max_heap, -nums[i])
        prefix = [0]*(len(nums)//3+1)
        prefix[0] = -sum(max_heap)
        for i in range(len(nums)//3):
            x = -heapq.heappushpop(max_heap, -nums[i+len(nums)//3])
            prefix[i+1] = prefix[i]-x+nums[i+len(nums)//3]

        min_heap = []
        for i in reversed(range(len(nums)//3*2, len(nums))):
            heapq.heappush(min_heap, nums[i])
        suffix = sum(min_heap)
        result = prefix[len(nums)//3]-suffix
        for i in reversed(range(len(nums)//3)):
            x = heapq.heappushpop(min_heap, nums[i+len(nums)//3])
            suffix += -x+nums[i+len(nums)//3]
            result = min(result, prefix[i]-suffix)
        return result",O(nlogn)
"import sys
input = lambda: sys.stdin.readline().strip()
from math import ceil

def mismatch(s1, s2):
    cnt = 0
    for i in range(len(s1)):
        if s1[i]!=s2[i]: cnt+=1
    return cnt

T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    check = ''
    for i in range(ceil((k+2)/3)):
        check+='RGB'
    ls = []
    for i in range(3):
        ls.append(check[i:i+k])
    s = input()
    m = n
    for i in range(n-k+1):
        for j in ls:
            m = min(m, mismatch(s[i:i+k], j))
    print(m)
",O(n ^ 2)
"class Solution(object):
    def findPrefixScore(self, nums):
        curr = 0
        for i in range(len(nums)):
            curr = max(curr, nums[i])
            nums[i] += (nums[i-1] if i-1 >= 0 else 0)+curr
        return nums",O(n)
"import sys
def input(): return sys.stdin.readline().strip()

n, mod = map(int, input().split())

le = 405

def pow(x, y):
    ans = 1
    while y > 0:
        if y % 2 == 1:
            ans = (ans * x) % mod
        x = (x**2) % mod
        y //= 2
    return ans

def inv(x):
    return pow(x, mod-2)

M = [1]
mul = 1
for i in range(1, le):
    mul = (mul * i) % mod
    M.append(mul)

MI = [0] * (le-1) + [inv(M[le-1])]
for i in range(le-2, -1, -1):
    MI[i] = MI[i+1] * (i+1) % mod

def C(x, y):
    if y < 0 or y > x:
        return 0
    elif x > le:
        y = min(y, x-y)
        ans = 1
        for i in range(x, x-y, -1):
            ans = (ans * i) % mod
        return (ans * MI[y]) % mod
    else:
        ans = M[x]
        ans = (ans * MI[y]) % mod
        return (ans * MI[x-y]) % mod

M2 = [1]
for i in range(n+5):
    M2.append((M2[-1]*2) % mod)

CO = [[0] * (n+5) for i in range(n+5)]
for i in range(n+5):
    for j in range(n+5):
        CO[i][j] = C(i, j)

D = [[0] * (n+1) for i in range(n+2)]

D[0][0] = 1
for i in range(n+2):
    for j in range(i//2, min(n+1, i+1)):

        for k in range(1, min(n+1, n-i+1, n-j+1)):

            ind0 = i+k+1
            ind1 = j+k
            if ind0 <= n+1 and ind1 <= n:
                D[ind0][ind1] += D[i][j] * CO[j+k][k] * M2[k-1]
                D[ind0][ind1] %= mod

print(sum(D[-1]) % mod)
",O(n ^ 3)
"import sys
class Graph:
    verticies = {}
    nodesCount = 0

    class Vertex:
        def __init__(self, label, endPoint=None):
            self.label = label
            self.edges = []
            self.visitedToken = 0
            self.endPoint = endPoint

    class Edge:
        residual = None

        def __init__(self, from_, to_, isResidual, maxCapacity):
            self.from_ = from_
            self.to_ = to_
            self.isResidual = isResidual
            self.capacity = maxCapacity
            self.flow = 0

        def augment(self, bootleneck):
            self.flow += bootleneck
            self.residual.flow -= bootleneck

        def remainingCapacity(self):
            return self.capacity - self.flow

    def addEdge(self, from_, to_, capacity):
        from_ = self.verticies[from_]
        to_ = self.verticies[to_]
        if from_.endPoint and from_.endPoint != to_:
            from_ = from_.endPoint

        main = self.Edge(from_, to_, False, capacity)
        residual = self.Edge(to_, from_, True, 0)

        main.residual = residual
        residual.residual = main

        from_.edges.append(main)
        to_.edges.append(residual)

    def addVertex(self, label, *args):
        self.nodesCount += 1
        self.verticies[label] = self.Vertex(label)

    def maxFlow(self, f, t):
        f = self.verticies[f]
        t = self.verticies[t]
        visitedToken = 1
        flow = 0

        def dfs(node, bootleneck=sys.maxsize):
            node.visitedToken = visitedToken
            bootleneck_backup = bootleneck

            if node == t:
                return bootleneck

            for edge in node.edges:
                if edge.remainingCapacity() == 0 or edge.to_.visitedToken == visitedToken:
                    continue

                bootleneck = dfs(edge.to_, min(
                    bootleneck, edge.remainingCapacity()))
                if bootleneck:
                    edge.augment(bootleneck)
                    return bootleneck
                else:
                    bootleneck = bootleneck_backup

            return 0

        while True:
            bootleneck = dfs(f)

            if not bootleneck:
                break

            flow += bootleneck
            visitedToken += 1

        return flow

g = Graph()

n, m = map(int, input().split())
vv = list(map(int, input().split()))

for i in range(n+m+2):
    g.addVertex(i)

for i, v in enumerate(vv):
    g.addEdge(m+i+1, n+m+1, v)

s = 0

for i in range(1, m+1):
    a, b, c = map(int, input().split())
    s += c

    g.addEdge(0, i, c)
    g.addEdge(i, a+m, c)
    g.addEdge(i, b+m, c)

print(s-g.maxFlow(0, n+m+1))
",O(n ^ 3)
"class Solution(object):
    def splitBST(self, root, V):
        if not root:
            return None, None
        elif root.val <= V:
            result = self.splitBST(root.right, V)
            root.right = result[0]
            return root, result[1]
        else:
            result = self.splitBST(root.left, V)
            root.left = result[1]
            return result[0], root",O(n)
"class Solution(object):
    def kthCharacter(self, k):
        def popcount(x):
            return bin(x)[2:].count('1')

        return chr(ord('a')+popcount(k-1)%26)",O(1)
"class Solution(object):
    def missingInteger(self, nums):
        total = nums[0]
        for i in range(1, len(nums)):
            if nums[i] != nums[i-1]+1:
                break
            total += nums[i]
        lookup = set(nums)
        while total in lookup:
            total += 1
        return total",O(n)
"t = int(input())

def sol(n, k):
    p = 1
    acc = 0
    while n > 0 and k >= p:
        k -= p
        n -= 1
        if n >= 40:
            return n
        acc += (2*p-1)*(4**n-1)//3
        if k <= acc:
            return n
        p = 2*p+1
    return -1

for _ in range(t):
    n, k = (int(v) for v in input().split())
    ans = sol(n, k)
    if ans == -1:
        print(""NO"")
    else:
        print(""YES"", ans)",O(logn)
"def forninho(miolo, s):
    premiolo = miolo
    temp = 0
    while (miolo > 0):
        temp += miolo % 10;
        miolo = miolo // 10;
    if (premiolo - temp >= s):
        return 1
    else:
        return 0

entrada = input().split()
n = int(entrada[0])
s = int(entrada[1])

result = -1
l = 1
r = n
while (r-l >= 0):
    miolo = (l + r) // 2
    if(forninho(miolo,s) == 1):
        r = miolo - 1
        result = miolo
    else:
        l = miolo + 1

if (result == -1):
    print(""0"")
else:
    print(n - result + 1)
",O(logn)
"from sortedcontainers import SortedList



class Solution2(object):
    def maximumSegmentSum(self, nums, removeQueries):
        removed_idxs = SortedList([-1, len(nums)])
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        segments = SortedList([prefix[-1]])
        result = []
        for q in removeQueries: 
            removed_idxs.add(q)
            i = removed_idxs.bisect_left(q)
            left, right = removed_idxs[i-1], removed_idxs[i+1]
            segments.remove(prefix[right]-prefix[left+1])
            segments.add(prefix[q]-prefix[left+1])
            segments.add(prefix[right]-prefix[q+1])
            result.append(segments[-1])
        return result",O(nlogn)
"

class Solution(object):
    def restoreString(self, s, indices):
        result = list(s)
        for i, c in enumerate(result):
            if indices[i] == i:
                continue
            move, j = c, indices[i]
            while j != i:
                result[j], move = move, result[j]
                indices[j], j = j, indices[j]
            result[i] = move
        return """".join(result)


",O(n)
"
import pandas as pd



def Solution(weather: pd.DataFrame) -> pd.DataFrame:
    return weather.pivot(index=""month"", columns=""city"", values=""temperature"")
",O(n)
"import sys
from collections import deque, defaultdict
input = lambda: sys.stdin.readline().rstrip()
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = [s[j] if i>>j&1 else '_' for j in range(k)]
            Ans.add(''.join(ans))
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = True
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = False
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag and T:
        print('YES')
        print(*[t+1 for t in T])
    else:
        print('NO')

main()",np
"a = [int(i) for i in list(input())]
b = [int(i) for i in list(input())]

if (len(a)<len(b)):
	a.sort(reverse=True)
	ans = 0
	for i in range(len(a)):
		ans = ans*10+a[i]
	print(ans)
else:

	ans = 0
	n = len(a)
	count = [0]*10
	for i in range(n):
		count[a[i]] += 1
	i = 0
	while (i<n):
		x = b[i]
		if (count[x]>0):
			ans = ans*10+x
			count[x] -= 1
			i += 1
		else:
			break
	if (i==n):
		print(ans)
		exit(0)
	x = b[i]
	flag = False
	for j in range(x-1,-1,-1):
		if (count[j]>0):
			ans = ans*10+j
			count[j] -= 1
			flag = True
			break
	if (flag) :
		for j in range(9,-1,-1):
			while (count[j]>0):
				ans = ans*10+j
				count[j] -= 1
	else:
		while (not flag):
			t = ans%10
			ans = ans//10
			count[t] += 1
			for i in range(t-1,-1,-1):
				if (count[i]>0):
					count[i] -= 1
					flag = True
					ans = ans*10 + i
					break
		for j in range(9,-1,-1):
			while (count[j]>0):
				ans = ans*10+j
				count[j] -= 1
	print(ans)
",O(n ^ 3)
"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        cnt = k
        res = root.val

        def dfs(node):
            nonlocal cnt, res
            if not node:
                return

            dfs(node.left)
            cnt -= 1
            if cnt == 0:
                res = node.val
                return
            dfs(node.right)

        dfs(root)
        return res
",O(n)
"import collections



class Solution(object):
    def medianOfUniquenessArray(self, nums):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(k):
            result = 0
            cnt = collections.Counter()
            left = 0
            for right in range(len(nums)):
                cnt[nums[right]] += 1
                while len(cnt) == k+1:
                    cnt[nums[left]] -= 1
                    if cnt[nums[left]] == 0:
                        del cnt[nums[left]]
                    left += 1
                result += right-left+1
            return result >= total-result

        total = (len(nums)+1)*len(nums)//2
        return binary_search(1, len(set(nums)), check)",O(nlogn)
"n = int(input())
print(3*n//2)",O(1)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        memo = {}

        def dfs(i):
            if i in memo:
                return memo[i]
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return 1000000

            res = 1000000
            end = min(len(nums), i + nums[i] + 1)
            for j in range(i + 1, end):
                res = min(res, 1 + dfs(j))
            memo[i] = res
            return res

        return dfs(0)
",O(n ^ 2)
"n,m=map(int,input().split())
count=[0]*n
a=list(map(int,input().split()))
for i in range(m):
    count[a[i]-1]+=1
print(min(count))",O(n ^ 2)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i],inf)

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"n = int(input())
a = list(map(int, input().strip().split()))

amin = min(a)
for i in range(n):
    a[i] -= amin
ans = amin % n
cnt = 0
while True:
    if a[ans] <= cnt:
        break
    ans = (ans + 1) % n
    cnt += 1
print(ans + 1)
",O(n)
"n,d=[int(x) for x in input().split("" "")]
a=[int(x) for x in input().split("" "")]
pos=2
for i in range(n-1):
    l=a[i]+d
    r=a[i+1]-d
    if l==r:
        pos+=1
    elif l<r:
        pos+=2
print(pos)
",O(n)
"num = input()
num_list = []
for i in range(len(num)):
  num_list.append(int(num[i]))
myMod = (10 ** 9) + 7
length = len(num_list)
f = [0] * (length + 1)
t = [1] * (length + 1)
for i in range(length):
    f[i+1] = (f[i] * 10 + 1) % myMod
    t[i+1] = (t[i] * 10) % myMod
ans = 0
for i in range(1, 10):
    dp = [0] * (length + 1)
    for j in range(length):
        dp[j+1] = (dp[j] * i + (10 - i) * (dp[j] * 10 + t[j])) % myMod
    c = 0
    ctr = 0
    for k in num_list:
        z = min(i, k)
        o = k - z
        ans += o * (dp[length-1-ctr] * t[c+1] + f[c+1] * t[length-1-ctr]) % myMod
        ans += z * (dp[length-1-ctr] * t[c] + f[c] * t[length-1-ctr]) % myMod
        ans %= myMod
        c += k >= i
        ctr += 1
    ans += f[c]
    if ans >= myMod:
        ans -= myMod
print(ans)
",O(n ^ 2)
"import collections


class Solution(object):
    def leastBricks(self, wall):
        widths = collections.defaultdict(int)
        result = len(wall)
        for row in wall:
            width = 0
            for i in range(len(row)-1):
                width += row[i]
                widths[width] += 1
                result = min(result, len(wall) - widths[width])
        return result",O(n)
"def lr(a):
    l = [0] * len(a)
    r = [0] * len(a)
    for i in range(len(a)):
        for j in range(i+1, len(a)):
            if a[j] > a[i]:
                r[i] += 1
            if a[i] > a[j]:
                l[j] += 1
    return l, r

n = int(input())
l = [int(i) for i in input().split()]
r = [int(i) for i in input().split()]
a = [0] * n
for i in range(n):
    for j in range(n):
        if l[j] + r[j] == i:
            a[j] = n-i
l1, r1 = lr(a)
if l1 != l or r1 != r:
    print(""NO"")
else:
    print(""YES"")
    print(' '.join([str(i) for i in a]))
",O(n ^ 2)
"import bisect
n,q=map(int,input().split())
strength=list(map(int,input().split()))
arrows=list(map(int,input().split()))
for i in range(1,n):
    strength[i]+=strength[i-1]
No_arrows=0
n-=1
for i in range(q):
    No_arrows+=arrows[i]
    if(No_arrows>=strength[-1]):
        No_arrows=0
        print(n+1)
    else:
        it=bisect.bisect_left(strength,No_arrows)
        if(strength[it]==No_arrows):
            print(n-it)
        else:
            print(n-it+1)
",O(nlogn)
"from bisect import bisect_right
n, x, y = map(int, input().split(' '))
s=[0]*n
e=[0]*n
v=[0]*n
c=0
for i in range(n):
    s[i],e[i]=map(int, input().split(' '))
    c+=x+(e[i]-s[i])*y
s.sort()
e.sort()
for i in range(n-2,-1,-1):
    k=bisect_right(s,e[i])
    while (k < n)  and (v[k]==1) and (s[k]-e[i]) * y < x :
        k+=1
    if k==n:
        continue
    if (s[k]-e[i]) * y < x :
        v[k] = 1
        c+=(s[k]-e[i])*y-x

print(c%(10**9+7))",O(nlogn)
"class Solution(object):
    def lastRemaining(self, n):
        start, step, direction = 1, 2, 1
        while n > 1:
            start += direction * (step * (n//2) - step//2)
            n //= 2
            step *= 2
            direction *= -1
        return start",O(logn)
"class Solution(object):
    def minFlips(self, target):
        result, curr = 0, '0'
        for c in target:
            if c == curr:
                continue
            curr = c
            result += 1
        return result",O(n)
"class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]

        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])

        return dp[-1]
",O(n)
"class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def equationsPossible(self, equations):
        union_find = UnionFind(26)
        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '=':
                union_find.union_set(x, y)
        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '!':
                if union_find.find_set(x) == union_find.find_set(y):
                    return False
        return True",O(n)
"from sys import stdin
input=stdin.readline
rn=lambda:int(input())
rns=lambda:map(int,input().split())
rl=lambda:list(map(int,input().split()))
rs=lambda:input()
YN=lambda x:print('YES') if x else print('NO')
mod=10**9+7

n,m,k=rns()
rows=[rl() for i in range(n)]
cols=[rl() for i in range(n-1)]
def solve():
    if k%2==1:
        return [m*[-1] for i in range(n)]
    dp=[[[0 for i in range(k//2+1)] for j in range(m)] for l in range(n)]
    for i in range(1,k//2+1):
        for a in range(n):
            for b in range(m):
                mins=[]
                if b>0:
                    mins.append(dp[a][b-1][i-1] + 2*rows[a][b-1])
                if b<m-1:
                    mins.append(dp[a][b + 1][i - 1] + 2 * rows[a][b])
                if a>0:
                    mins.append(dp[a-1][b][i - 1] + 2 * cols[a-1][b])
                if a<n-1:
                    mins.append(dp[a+1][b][i - 1] + 2 * cols[a][b])
                dp[a][b][i]=min(mins)
    ans=[[dp[i][j][-1] for j in range(m)] for i in range(n)]
    return ans

ans = solve()
for i in ans:
    print(*i)",O(n ^ 3)
"class Solution(object):
    def numberOfGoodPartitions(self, nums):
        MOD = 10**9+7
        lookup = {x:i for i, x in enumerate(nums)}
        result = 1
        right = cnt = 0
        for left, x in enumerate(nums):
            if left == right+1:
                cnt += 1
            right = max(right, lookup[x])
        return pow(2, cnt, MOD)",O(n)
"class Solution(object):
    def countSpecialSubsequences(self, nums):
        MOD = 10**9+7
        dp = [0]*3
        for x in nums:
            dp[x] = ((dp[x]+dp[x])%MOD+(dp[x-1] if x-1 >= 0 else 1))%MOD
        return dp[-1]",O(n)
"class Solution_Wrong(object):
    def checkValid(self, matrix):
        return all(reduce(lambda x, y: x^y, (matrix[i][j]^(j+1) for j in range(len(matrix[0])))) == 0 for i in range(len(matrix))) and \
               all(reduce(lambda x, y: x^y, (matrix[i][j]^(i+1) for i in range(len(matrix)))) == 0 for j in range(len(matrix[0])))",O(n ^ 2)
"class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for c in tokens:
            if c == ""+"":
                stack.append(stack.pop() + stack.pop())
            elif c == ""-"":
                a, b = stack.pop(), stack.pop()
                stack.append(b - a)
            elif c == ""*"":
                stack.append(stack.pop() * stack.pop())
            elif c == ""/"":
                a, b = stack.pop(), stack.pop()
                stack.append(int(float(b) / a))
            else:
                stack.append(int(c))
        return stack[0]
",O(n)
"class Solution2(object):
    def maxLevelSum(self, root):
        result, level, max_total = 0, 1, float(""-inf"")
        q = collections.deque([root])
        while q:
            total = 0
            for _ in range(len(q)):
                node = q.popleft()
                total += node.val
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            if total > max_total:
                result, max_total = level, total
            level += 1
        return result",O(n)
"def main():
    def calc(x):
        if x & 1:
            return -x + calc(x - 1)
        return x // 2
    n = int(input())
    for i in range(n):
        a, b = map(int, input().split())
        print(calc(b) - calc(a - 1))

main()
",O(1)
"import heapq


class Solution(object):
    def findSecondMinimumValue(self, root):
        def findSecondMinimumValueHelper(root, max_heap, lookup):
            if not root:
                return
            if root.val not in lookup:
                heapq.heappush(max_heap, -root.val)
                lookup.add(root.val)
                if len(max_heap) > 2:
                    lookup.remove(-heapq.heappop(max_heap))
            findSecondMinimumValueHelper(root.left, max_heap, lookup)
            findSecondMinimumValueHelper(root.right, max_heap, lookup)

        max_heap, lookup = [], set()
        findSecondMinimumValueHelper(root, max_heap, lookup)
        if len(max_heap) < 2:
            return -1
        return -max_heap[0]",O(n)
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

def mapin():
    return map(int, input().split())

def solve(final, n):
    fifi = [[final[j][i] for j in range(n)] for i in range(n)]

    k = []
    for i in range(n):
        k.append(sum(final[i]))
    a = max(k)-min(k)

    a = a*a
    k = []
    for i in range(n):
        k.append(sum(fifi[i]))
    b = max(k)-min(k)

    b = b*b

    return a+b

def inte(a, b, c, d):
    a = max(a, c)
    b = min(b, d)

    return [a, b]

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n = int(input())
l = []
for i in range(n):
    a, b = mapin()
    l.append([a, b])

f= []
ff = []
a = 0
b = 10000000000000
f.append([a, b])
for i in range(n):
    x = inte(a, b, l[i][0], l[i][1])
    a = x[0]
    b = x[1]
    f.append([a, b])
a = 0
b = 10000000000000
ff = [[] for i in range(n)]
for i in reversed(range(n)):
    x = inte(a, b, l[i][0], l[i][1])
    a = x[0]
    b = x[1]
    ff[i] = [a, b]
ff.append([0, 100000000000000])
ans = 0
for i in range(n):
    a = f[i]
    b = ff[i+1]
    y = inte(a[0], a[1], b[0], b[1])
    if(y[1]>= y[0]):
        ans = max(ans, y[1]-y[0])

print(ans)
",O(n)
"class Solution(object):
    def stringCount(self, n):
        MOD = 10**9 + 7
        return (
            pow(26, n, MOD)
            - (25 + 25 + 25 + n) * pow(25, n - 1, MOD)
            + (24 + 24 + 24 + n + n + 0) * pow(24, n - 1, MOD)
            - (23 + n + 0 + 0) * pow(23, n - 1, MOD)
        ) % MOD",O(logn)
"class Solution(object):
    def calculateScore(self, instructions, values):
        result = 0
        lookup = [False]*len(instructions)
        i = 0
        while 0 <= i < len(instructions):
            if lookup[i]:
                break
            lookup[i] = True
            if instructions[i] == ""add"":
                result += values[i]
                i += 1
            else:
                i += values[i]
        return result",O(n)
"ii=lambda:int(input())
kk=lambda:map(int, input().split())
ll=lambda:list(kk())

n,k=kk()
pre,post = [],[]
k-=1
v = 1
for i in range(n-2,-1,-1):
	if k&(2**i):
		post.append(v)
	else:
		pre.append(v)
	v+=1
print(*pre,n,*reversed(post))",np
"from math import sqrt
n, k = map(int, input().split())
print(int(n - 0.5 * (sqrt(8 * (k + n) + 9) - 3)))
",O(1)
"a = sorted(input())
b = int(input())
a = a[::-1]
p = ''
cnt = [0]*10

while a :
    for i, d in enumerate(a):
        n = p + d + """".join(sorted(a[:i]+a[i+1:]))
        if int(n) <= b :
            p += d
            a.pop(i)
            break

print(p)",O(n ^ 3)
"import sys
input = sys.stdin.buffer.readline
from itertools import permutations

k = list(map(int,input().split()))

worked = 0
for k1,k2,k3 in permutations(k):
    worked2 = 1
    for t in range(10000):
        if not (t % k1 == 0 or t % k2 == 1 or t % k3 == 2):
            worked2 = 0

    if worked2:
        worked = 1
        break

if worked:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"x,y,z,t1,t2,t3 = map(int, input().split())
stairs = abs(x - y) * t1
lift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3
print('YES' if lift <= stairs else 'NO')",O(1)
"N, M = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))

if max(b) > min(g):
    ans = -1
elif max(b) == min(g):
    ans = M*sum(b)
    maxi = max(b)
    for i in range(M):
        if maxi == g[i]:
            continue
        else:
            ans += g[i] - maxi
else:
    ans = M * sum(b)
    b.sort(reverse = True)
    for i in range(M):
        if i == 0:
            ans += g[i] - b[1]
        else:
            ans += g[i] - b[0]
print(ans)
",O(nlogn)
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
from decimal import Decimal
from fractions import Fraction

INF = float('inf')
mod = int(1e9)+7

def recur(r,g,b):
    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:
        return 0
    if dp[r][g][b]:
        return dp[r][g][b]
    if r>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+recur(r-1,g-1,b))
    if r>0 and b>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+recur(r-1,g,b-1))
    if b>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+recur(r,g-1,b-1))
    return dp[r][g][b]

r,g,b=mdata()
R=sorted(mdata())
G=sorted(mdata())
B=sorted(mdata())
dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]
out(recur(r,g,b))
",O(n ^ 3)
"n = int(input())

print(n//2 + 1)
",O(1)
"class Solution(object):
    def compressedString(self, word):
        result = []
        cnt = 0
        for i in range(len(word)):
            cnt += 1
            if cnt == 9 or (i+1 == len(word) or word[i+1] != word[i]):
                result.append(""%s%s"" % (cnt, word[i]))
                cnt = 0
        return """".join(result)",O(n)
"import collections


class Solution(object):

    def __init__(self):
        self.__dq = collections.deque()
        self.__printed = set()

    def shouldPrintMessage(self, timestamp, message):
        while self.__dq and self.__dq[0][0] <= timestamp - 10:
            self.__printed.remove(self.__dq.popleft()[1])
        if message in self.__printed:
            return False
        self.__dq.append((timestamp, message))
        self.__printed.add(message)
        return True",O(1)
"import collections
from functools import reduce



class Solution(object):
    def sumOfGoodSubsequences(self, nums):
        MOD = 10**9+7
        dp = collections.defaultdict(int)
        cnt = collections.defaultdict(int)
        for x in nums:
            c = cnt[x-1]+cnt[x+1]+1
            cnt[x] = (cnt[x]+c)%MOD
            dp[x] = (dp[x]+(dp[x-1]+dp[x+1]+x*c))%MOD
        return reduce(lambda accu, x: (accu+x)%MOD, iter(dp.values()))",O(n)
"import sys
import os.path
from collections import *
import math
import bisect

if (os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")
else:
    input = sys.stdin.readline

n = int(input())

if(n == 2 or n == 3 or n == 4 or n == 5):
    print(-1)
else:
    print(1,2)
    print(2,3)
    print(2,4)
    for i in range(5,n + 1):
        print(4,i)

for i in range(2,n + 1):
    print(1,i)
",O(n)
"class Solution(object):
    def findLeaves(self, root):
        def findLeavesHelper(node, result):
            if not node:
                return -1
            level = 1 + max(findLeavesHelper(node.left, result), \
                            findLeavesHelper(node.right, result))
            if len(result) < level + 1:
                result.append([])
            result[level].append(node.val)
            return level

        result = []
        findLeavesHelper(root, result)
        return result",O(n)
"class Solution(object):
    def countArrangement(self, N):
        def countArrangementHelper(n, arr):
            if n <= 0:
                return 1
            count = 0
            for i in range(n):
                if arr[i] % n == 0 or n % arr[i] == 0:
                    arr[i], arr[n-1] = arr[n-1], arr[i]
                    count += countArrangementHelper(n - 1, arr)
                    arr[i], arr[n-1] = arr[n-1], arr[i]
            return count

        return countArrangementHelper(N, list(range(1, N+1)))",O(n!)
"import math
def mint(): return map(int, input().split())
n, m, k = mint()
horizontal = [list(mint()) for i in range(n)]
vertical = [list(mint()) for i in range(n-1)]
if k%2 or max(n, m)==1:
    for i in range(n):
        print(*[-1]*m)
    exit()
dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]
for length in range(1, k//2+1):
    for i in range(n):
        for j in range(m):
            left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]
            right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]
            top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]
            bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]
            dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])
for i in range(n):
    print(*[dp[i][j][k//2]*2 for j in range(m)])
",O(n ^ 3)
"import sys
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
ns = lambda: readline().rstrip()
ni = lambda: int(readline().rstrip())
nm = lambda: map(int, readline().split())
nl = lambda: list(map(int, readline().split()))

r, g, b = nm()
R = nl()
G = nl()
B = nl()
dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
R.insert(0, 0)
G.insert(0, 0)
B.insert(0, 0)
dp[0][0][0], ans = 0, 0
for i in range(0, r+1):
    for j in range(0, g+1):
        for k in range(0, b+1):
            if i==0 and j==0 and k==0:continue
            if i and j and dp[i - 1][j - 1][k] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])
            if k and j and dp[i][j - 1][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])
            if i and k and dp[i - 1][j][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])
            ans = max(ans, dp[i][j][k])
print(ans)",O(n ^ 3)
"class Solution(object):
    def makeGood(self, s):
        stk = []
        for ch in s:
            counter_ch = ch.upper() if ch.islower() else ch.lower()
            if stk and stk[-1] == counter_ch:
                stk.pop()
            else:
                stk.append(ch)
        return """".join(stk)",O(n)
"n, p = map(int, input().split())
list1 = list(map(int, input().split()))
mx = 0
curr = 0
nxt = sum(list1)
for i in range(n - 1):
    curr += list1[i]
    nxt -= list1[i]
    mx = max(mx, curr % p + nxt % p)
print(mx)",O(n)
"f = lambda m, k: (k*m - m*(m-1)//2 - m + 1)

def ok(m, k, n):
    return f(m, k) >= n

n, k = map(int, input().split())

if not ok(k, k, n): print(-1)
else:
    l, h = 0, k
    while (h > l):
        mid = l + (h - l) // 2
        if ok(mid, k, n): h = mid
        else: l = mid + 1
    print(h)",O(logn)
"n = int(input())
values = list(map(int, input().split()))
queries = int(input())

dp = [[0] * 5009 for i in range(5009)]

for i in range(n):
    dp[0][i] = values[i]

for i in range(1, n):
    for j in range(n-i+1):
        top = dp[i-1][j]
        right = dp[i-1][j+1]
        dp[i][j] = top ^ right

for i in range(1, n):
    for j in range(n-i+1):
        top = dp[i-1][j]
        right = dp[i-1][j+1]
        dp[i][j] = max(right, max(dp[i][j], top))

for i in range(queries):
    left, right = map(int, input().split())
    last_row = (right - 1) - (left - 1)
    last_column = (left - 1)
    print(dp[last_row][last_column])
",O(n ^ 2)
"class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:

        def dfs(i):
            if i >= len(cost):
                return 0
            return cost[i] + min(dfs(i + 1), dfs(i + 2))

        return min(dfs(0), dfs(1))
",O(2 ^ n)
"n = int(input())
s = ['']
for i in range(n):
	inp = input()
	s.append(inp)
	pos = len(s) - 1
	while len(s[pos]) < len(s[pos-1]):
		s[pos], s[pos-1] = s[pos-1], s[pos]
		pos -= 1
out = 'YES'
for i in range(n):
	if not s[i] in s[i+1]:
		out = 'NO'
		s = []
		break
print(out + '\n'.join(s))
",O(nlogn)
"from collections import defaultdict

mod_v = 1000000007

temp_arr = [[1]]
for i in range(1,1010):
    a = [1]
    for k in range(1,i):
        a.append((temp_arr[i-1][k-1]+temp_arr[i-1][k]) % mod_v)
    a.append(1)
    temp_arr.append(a)

ans_arr = [1]
for i in range(1,1010):
    res = 0
    for j in range(i):
        res += ans_arr[j] * temp_arr[i-1][j]
        res %= mod_v
    ans_arr.append(res)

n_list=list(map(int, input().split()))

n = n_list[0]
lines = n_list[1]

new_list = [0 for __ in range(n)]

for i in range(lines):
    input1 = list(map(int, input()))
    for k in range(n):
        new_list[k] |= input1[k] << i

default_d = defaultdict(int)
for k in new_list:
    default_d[k] += 1

answer = 1
for n in default_d.values():
    answer = answer * ans_arr[n] % mod_v

print(answer)
",O(n ^ 2)
"import collections



class Solution(object):
    def maxSubarraySum(self, nums):
        result = float(""-inf"")
        curr = mn = mn0 = 0
        mn1 = collections.defaultdict(int)
        for x in nums:
            curr += x
            result = max(result, curr-mn)
            mn1[x] = min(mn1[x], mn0)+x
            mn0 = min(mn0, curr)
            mn = min(mn, mn1[x], mn0)
        return result",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def rightSideView(self, root):
        result = []
        self.rightSideViewDFS(root, 1, result)
        return result

    def rightSideViewDFS(self, node, depth, result):
        if not node:
            return

        if depth > len(result):
            result.append(node.val)

        self.rightSideViewDFS(node.right, depth+1, result)
        self.rightSideViewDFS(node.left, depth+1, result)",O(n)
"n = int(input())
curpow, t, mx2pow = 1, 1, 0
while t < n:
    t <<= 1
    mx2pow += 1

if t > n:
    mx2pow -= 1

last = 1 << (mx2pow-1) if mx2pow else 1
add = last

while last < n:
    last += add

if last > n:
    last -= add

while n:
    if n == 1:
        print(last)
        break
    print((str(curpow)+' ') * ((n+1)//2), end='')
    curpow *= 2
    n //= 2
",O(nlogn)
"class Solution2(object):
    def invertTree(self, root):
        if root is not None:
            nodes = []
            nodes.append(root)
            while nodes:
                node = nodes.pop()
                node.left, node.right = node.right, node.left
                if node.left is not None:
                    nodes.append(node.left)
                if node.right is not None:
                    nodes.append(node.right)

        return root",O(n)
"def res(d,N):
    for i in range(1,N):
        if d[i][1] <= d[i-1][1]:
            return str(d[i][2]+1) + ' ' + str(d[i-1][2]+1)
    return '-1 -1'

N = int(input())
d = []
for i in range(N):
    a,b = map(int,input().split())
    d.append((a,b,i))
d = sorted(d, key = lambda x:(x[0],-x[1]))
print(res(d,N))
",O(nlogn)
"from itertools import combinations
n , l , r ,x = map(int,input().split())
a = list(map(int, input().split()))
c = 0
for i in range(1,n+1):
    for j in combinations(a,i):
        if (l<=sum(j)<=r and max(j)-min(j)>=x):
            c+=1
print(c)",np
"n=int(input())
s=0
i=1
c=1
while(s<n):
    s+=9*i*c
    c+=1
    i*=10
n=n-s+9*i*(c-1)//10
c=c-1
r=n%c
d=n//c
k=10**(c-1)+d
if(r==0):
    print(int(str(k-1)[-1]))
else:
    print(int(str(k)[r-1]))
",O(logn)
"n = int(input())
print(n**2+((n-1)**2))
",O(1)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,m,k=map(int,input().split())
y_axis=[list(map(int,input().split())) for i in range(n)]
x_axis=[list(map(int,input().split())) for i in range(n-1)]
if(k%2==1):
    for i in range(n):
        for j in range(m):
            print(-1,end="" "")
        print()
else:
    inf=10**9
    dp=[[[inf for z in range(k+1)]for y in range(m)]for x in range(n)]
    for i in range(n):
        for j in range(m):
            if(i>0):
                if(i<n-1):
                    dp[i][j][2]=min(dp[i][j][2],2*x_axis[i][j],2*x_axis[i-1][j])
                else:
                    dp[i][j][2]=min(dp[i][j][2],2*x_axis[i-1][j])
            else:
                dp[i][j][2]=min(dp[i][j][2],2*x_axis[i][j])
            if(j>0):
                if(j<m-1):
                    dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j],2*y_axis[i][j-1])
                else:
                    dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j-1])
            else:
                dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j])
    for z in range(4,k+1,2):
        for i in range(n):
            for j in range(m):
                if(i>0):
                    if(i<n-1):
                        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-2]+2*x_axis[i-1][j],dp[i+1][j][z-2]+2*x_axis[i][j])
                    else:
                        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-2]+2*x_axis[i-1][j])
                else:
                    dp[i][j][z]=min(dp[i][j][z],dp[i+1][j][z-2]+2*x_axis[i][j])
                if(j>0):
                    if(j<m-1):
                        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*y_axis[i][j-1],dp[i][j+1][z-2]+2*y_axis[i][j])
                    else:
                        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*y_axis[i][j-1])
                else:
                    dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-2]+2*y_axis[i][j])
    for i in range(n):
        for j in range(m):
            if(dp[i][j][k]==inf):
                print(-1,end="" "")
            else:
                print(dp[i][j][k],end="" "")
        print()
",O(n ^ 3)
"import sys
sys.setrecursionlimit(10**5+1)

inf     =  int(10 ** 20)
max_val =  inf
min_val = -inf

RW  = lambda : sys.stdin.readline().strip()
RI  = lambda : int(RW())
RMI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]
RWI = lambda : [x for x in sys.stdin.readline().strip().split()]

n, k = map(int, input().split())

print(int((2*n+3-(8*n+8*k+9)**(1/2))//2))",O(logn)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = set()
        posDiag = set()
        negDiag = set()

        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue

                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                board[r][c] = ""Q""

                backtrack(r + 1)

                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"class Solution2(object):
    def minimumFlips(self, root, result):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
            4: lambda x, y: x^y ,
            5: lambda x, y: not x if x is not None else not y
        }
        
        def dfs(node):
            if not node:
                return {None: 0} 
            if node.left == node.right:
                return {True: node.val^1, False: node.val^0}
            left = dfs(node.left)
            right = dfs(node.right)
            dp = collections.defaultdict(lambda: INF)
            for k1, v1 in left.items():
                for k2, v2 in right.items():
                    dp[OP[node.val](k1, k2)] = min(dp[OP[node.val](k1, k2)], v1+v2)
            return dp

        return dfs(root)[result]",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sumRootToLeaf(self, root):
        M = 10**9 + 7
        def sumRootToLeafHelper(root, val):
            if not root:
                return 0
            val = (val*2 + root.val) % M
            if not root.left and not root.right:
                return val
            return (sumRootToLeafHelper(root.left, val) +
                    sumRootToLeafHelper(root.right, val)) % M
        
        return sumRootToLeafHelper(root, 0)",O(n)
"k,n,s,p = map(int,input().split())
print(int((int((n+s-1)/s)*k+p-1)/p))",O(1)
"class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        prod, zero_cnt = 1, 0
        for num in nums:
            if num:
                prod *= num
            else:
                zero_cnt +=  1
        if zero_cnt > 1: return [0] * len(nums)

        res = [0] * len(nums)
        for i, c in enumerate(nums):
            if zero_cnt: res[i] = 0 if c else prod
            else: res[i] = prod // c
        return res
",O(n)
"from math import factorial
from decimal import *
A=input()
B=input()
a=0
cnt2=0
cnt1=0
b=0
for i in A:
    if i=='+':
        a+=1
        cnt1+=1
    else:
        a-=1
        cnt2+=1
cnt3=0
cnt=0
cnt4=0
for i in B:
    if i=='+':
        b+=1
        cnt3+=1
    elif i=='-':
        b-=1
        cnt4+=1
    else:
        cnt+=1
if cnt3>cnt1 or cnt4>cnt2:
    print(format(0,'.12f'))
else:
    No_of_plus=cnt1-cnt3
    No_of_minus=cnt2-cnt4
    Total_cases=2**cnt
    Total_No_of_favourable_cases=factorial(cnt)//(factorial(No_of_plus)*factorial(No_of_minus))

    print(format(Decimal(Total_No_of_favourable_cases)/Decimal(Total_cases), '.12f'))
",np
"from sys import stdin, stdout
def modinv(n,p):
    return pow(n,p-2,p)
def ncr(n,r,p,f):
    t=((f[n])*(modinv(f[r],p)%p)*(modinv(f[n-r],p)%p))%p
    return t
mod=(10**9)+7
def GCD(x, y):
   while(y):
       x, y = y, x % y
   return x
def BS(arr, l, r, x):
    if r >= l:
        mid = l + (r - l)/2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return BS(arr, l, mid-1, x)
        else:
            return BS(arr, mid+1, r, x)
    else:
        return -1
from bisect import bisect_left as bl
from bisect import bisect_right as br
import itertools
import math
from Queue import Queue as Q

def main():
    n=input()
    p=[]
    f=[0]*(n+1)
    for i in range(n):
        l,r=map(int,stdin.readline().split())
        p.append([l,""l""])
        p.append([r,""r""])
    p.sort(key=lambda x:x[0])
    o=1
    c=0
    w=[]
    for i in range(1,len(p)):
        if(p[i][0]==p[i-1][0]):
            if(p[i][1]==""l""):
                o+=1
            else:
                c+=1
        else:
            w.append([p[i-1][0],o,c])
            o,c=0,0
            if(p[i][1]==""l""):
                o=1
            else:
                c=1
    w.append([p[-1][0],o,c])
    s=0
    i=0
    r=-1
    while(i<len(w)):
        f[s]+=w[i][0]-r-1
        f[s+w[i][1]]+=1
        s+=w[i][1]-w[i][2]
        r=w[i][0]
        i+=1
    for i in range(1,n+1):
        stdout.write(str(f[i])+"" "")
if __name__ == '__main__':
    main()
",O(nlogn)
"import sys
import os
from io import IOBase, BytesIO

def main():
    n = int(input())
    x = 2 * n - 1
    ans = x
    x -= 2
    curr = 0
    while x > 0:
        curr += x
        x -= 2
    print(ans + 2 * curr)

BUFSIZE = 8192

class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        py2 = round(0.5)
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2 == 1:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode(""ascii""))
            self.read = lambda: self.buffer.read().decode(""ascii"")
            self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def get_array(): return list(map(int, sys.stdin.readline().split()))

def get_ints(): return map(int, sys.stdin.readline().split())

def input(): return sys.stdin.readline().strip()

if __name__ == ""__main__"":
    main()
",O(n)
"s = input()
n = len(s)
ans = 0
c = 0
l = []
for i in range(n):
    a = int(s[i])%3
    if a==0:
        ans+=1
        c = 0
        l = []
    else:
        if c==0:
            l.append(int(s[i]))
            c+=1
        elif c==1:
            if (a+l[0])%3==0:
                ans+=1
                c = 0
                l = []
            else:
                c+=1
        else:
            ans+=1
            c=0
            l = []
print(ans)",O(n)
"k1, k2, k3  = sorted(map(int, input().split()))

if 1 == k1 or (2 == k1 and 2 == k2) or (3 == k1 and 3 == k2 and 3 == k3) \
    or (k1 == 2 and k2 == 4 and k3 == 4):
    print(""YES"")
else:
    print(""NO"")",O(1)
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    a = list(map(int, input().split()))
    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[i] > a[j]:
                cnt += 1
    even = cnt % 2 == 0
    q = int(input())
    ans = []
    for _ in range(q):
        l, r = map(int, input().split())
        len = r - l + 1
        pairs = len * (len-1) // 2
        if pairs % 2 == 1:
            even = not even
        if even:
            ans.append('even')
        else:
            ans.append('odd')
    print('\n'.join(ans))

main()",O(n ^ 2)
"import os,sys
from io import BytesIO, IOBase

def bit_count(x):
    ans = 0
    while x:
        x &= x-1
        ans += 1
    return ans

def main():
    n = input().strip()
    x = len(n)
    k = int(input())
    if n == '1':
        print(int(k==0))
        exit()
    if not k:
        print(1)
        exit()
    mod = 10**9+7
    dp = [0]*(x+1)
    dp[1] = 1
    for i in range(2,x+1):
        dp[i] = dp[bit_count(i)]+1
    dp1 = [[0]*(x+1) for _ in range(x+1)]

    for i in range(x+1):
        dp1[i][0] = 1
    for i in range(1,x+1):
        for j in range(1,i+1):
            dp1[i][j] = (dp1[i-1][j-1]+dp1[i-1][j])%mod
    ans = 0
    cou = n.count('1')
    for i in range(1,x+1):
        if dp[i] != k:
            continue
        se = i
        for j in range(x):
            if n[j] == '0':
                continue
            ans = (ans+dp1[x-1-j][se]-(se==1 and k==1))%mod
            se -= 1
            if se < 0:
                break
        if cou == i:
            ans = (ans+1)%mod
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(n)
"import collections



class Solution(object):

    def __init__(self, capacity):
        self.__capa = capacity
        self.__size = 0
        self.__min_freq = float(""inf"")
        self.__freq_to_nodes = collections.defaultdict(collections.OrderedDict)
        self.__key_to_freq = {}

    def get(self, key):
        if key not in self.__key_to_freq:
            return -1
        value = self.__freq_to_nodes[self.__key_to_freq[key]][key]
        self.__update(key, value)
        return value

    def put(self, key, value):
        if self.__capa <= 0:
            return

        if key not in self.__key_to_freq and self.__size == self.__capa:
            del self.__key_to_freq[self.__freq_to_nodes[self.__min_freq].popitem(last=False)[0]]
            if not self.__freq_to_nodes[self.__min_freq]:
                del self.__freq_to_nodes[self.__min_freq]
            self.__size -= 1
        self.__update(key, value)
        
    def __update(self, key, value):
        freq = 0
        if key in self.__key_to_freq:
            freq = self.__key_to_freq[key]
            del self.__freq_to_nodes[freq][key]
            if not self.__freq_to_nodes[freq]:
                del self.__freq_to_nodes[freq]
                if self.__min_freq == freq:
                    self.__min_freq += 1
            self.__size -= 1

        freq += 1
        self.__min_freq = min(self.__min_freq, freq)
        self.__key_to_freq[key] = freq
        self.__freq_to_nodes[freq][key] = value
        self.__size += 1",O(1)
"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        res = nums[0]

        for i in range(len(nums)):
            cur = nums[i]
            res = max(res, cur)
            for j in range(i + 1, len(nums)):
                cur *= nums[j]
                res = max(res, cur)

        return res
",O(n ^ 2)
"class Solution(object):
    def tictactoe(self, moves):
        row, col = [[0]*3 for _ in range(2)], [[0]*3 for _ in range(2)]
        diag, anti_diag = [0]*2, [0]*2
        p = 0
        for r, c in moves:
            row[p][r] += 1
            col[p][c] += 1
            diag[p] += r == c
            anti_diag[p] += r+c == 2
            if 3 in (row[p][r], col[p][c], diag[p], anti_diag[p]):
                return ""AB""[p]
            p ^= 1
        return ""Draw"" if len(moves) == 9 else ""Pending""",O(1)
"n, k = [int(e) for e in input().split()]
a = sorted([int(e) for e in input().split()])
s = set()
for i in range(n):
    if a[i] % k != 0:
        s.add(a[i])
    elif a[i] / k not in s:
        s.add(a[i])
print(len(s))",O(nlogn)
"class Solution(object):
    def rotate(self, nums, k):
        def reverse(nums, start, end):
            while start < end:
                nums[start], nums[end - 1] = nums[end - 1], nums[start]
                start += 1
                end -= 1

        k %= len(nums)
        reverse(nums, 0, len(nums))
        reverse(nums, 0, k)
        reverse(nums, k, len(nums))",O(n)
"arr = [int(i) for i in filter(None, input().split("" ""))]
k_hodov = arr[0]
konf = arr[1]
left = 0
right = k_hodov+100
while(right-left)>1:
    mid = (right+left)//2
    k_give=k_hodov-mid
    if ((k_give+1)*(k_give/2))//1-mid<konf or k_give<0:
        right = mid
    else:
        left = mid

k_give=k_hodov-left
if ((k_give+1)*(k_give/2))//1-left==konf:
    print(left)
else:
    print(left-1)
",O(logn)
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        def backtrack(i, total):
            if i ==len(nums):
                return  total == target

            return (backtrack(i + 1, total + nums[i]) +
                    backtrack(i + 1, total - nums[i]))

        return backtrack(0, 0)
",O(2 ^ n)
"import itertools


class Solution(object):
    def climbStairs(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) \
                     for col in ZB] for row in A]

        T = [[1, 1],
             [1, 0]]
        return matrix_mult([[1,  0]], matrix_expo(T, n))[0][0]",O(logn)
"class Solution(object):
    def clearDigits(self, s):
        s = list(s)
        j = 0
        for i, x in enumerate(s):
            if x.isdigit():
                j -= 1
                continue
            s[j] = x
            j += 1
        while len(s) > j:
            s.pop()
        return """".join(s)",O(n)
"class Solution2(object):
    def evenProduct(self, nums):
        result = cnt = 0
        for i, x in enumerate(nums):
            if x%2 == 0:
                cnt = i+1
            result += cnt
        return result",O(n)
"import math

n=int(input())

s2=input()
s2=list(s2)
s=[]
for i in range(n):
    if s2[i]=='0':
        continue
    else:
        s.append(int(s2[i]))
s1=sum(s)
n=len(s)
l=[]
for i in range(2,n+1):
    if s1%i==0:
        l.append(s1//i)
f=0
if len(s)==0:
    f=1
for i in range(len(l)):
    c=0
    if f==1:
        break
    for j in range(n):
        c+=s[j]
        if c==l[i]:
            c=0
            if j==n-1:
                f=1
        elif c<l[i]:
            c=c
        else:
            break
if f==0:
    print('NO')
else:
    print('YES')",O(n ^ 2)
"import collections
import itertools



class Solution(object):
    def timeTaken(self, arrival, state):
        def go_until(t):
            while curr[0] <= t and any(q):
                if not q[direction[0]]:
                    direction[0] ^= 1
                result[q[direction[0]].popleft()] = curr[0]
                curr[0] += 1
    
        UNKNOWN, ENTERING, EXITING = list(range(-1, 1+1))
        result = [0]*len(arrival)
        curr, direction = [float(""-inf"")], [UNKNOWN]
        q = [collections.deque(), collections.deque()]
        for i, (a, s) in enumerate(zip(arrival, state)):
            go_until(a-1)
            q[s].append(i)
            if not (a <= curr[0]):
                curr, direction = [a], [EXITING]
        go_until(float(""inf""))
        return result",O(n)
"n=int(input())
a=str(n)
m=len(a)
b=int(a[0:m-1])
c=int(a[0:m-2]+a[-1])
d=max(n,b,c)
print(d)
",O(1)
"import sys

n = int(input())
prob = [list(map(float, input().split())) for _ in range(n)]
dp = [[0.0]*n for _ in range(1 << n)]
dp[1][0] = 1.0

for mask in range(3, 1 << n):
    for i in range(n):
        if not (mask & (1 << i)):
            continue
        for j in range(n):
            if i != j and mask & (1 << j):
                dp[mask][i] = max(
                    dp[mask][i],
                    dp[mask - (1 << j)][i] * prob[i][j]
                    + dp[mask - (1 << i)][j] * prob[j][i]
                )

print(max(dp[-1]))
",np
"n,k = map(int,input().split())
a = list(map(int,input().split()))

if k == 1:
    print(max(a) - min(a))
    exit()

dif = []
for i in range(n - 1):
    dif.append(a[i + 1] - a[i])
dif = sorted(dif)
print(sum(dif[:-k + 1]))",O(nlogn)
"class Solution3(object):
    def singleNumber(self, nums):
        return [x[0] for x in sorted(list(collections.Counter(nums).items()), key=lambda i: i[1], reverse=False)[:2]]",O(n)
"t = int(input())

while t>0:
    n, k = input().split()
    n, k = int(n), int(k)

    if n >= 32:
        print(""YES"", n-1)
        t -= 1
        continue

    possibleSize = -1
    sz = 1

    while sz <= n:

        req_cuts = 2**(sz+1) - 2 - sz

        tot_cuts = ((4**sz) - 1) // 3 + (((2**sz) -1)**2) * (((4**(n-sz)) - 1) // 3)

        if (req_cuts > k):
            break
        if (tot_cuts >= k):
            possibleSize = sz
            break

        sz+=1

    if (possibleSize != -1):
        print(""YES"", n - possibleSize)
    else:
        print(""NO"")

    t-=1",O(logn)
"class Solution2(object):
    def maxLength(self, arr):
        def bitset(s):
            result = 0
            for c in s:
                if result & power[ord(c)-ord('a')]:
                    return 0
                result |= power[ord(c)-ord('a')]
            return result
    
        bitsets = [bitset(x) for x in arr]
        result = 0
        for i in range(power[len(arr)]):
            curr_bitset, curr_len = 0, 0
            while i:
                j = i & -i 
                i ^= j
                j = log2[j] 
                if not bitsets[j] or (curr_bitset & bitsets[j]):
                    break
                curr_bitset |= bitsets[j]
                curr_len += len(arr[j])
            else:
                result = max(result, curr_len)
        return result",O(2 ^ n)
"class Solution(object):
    def smallestEqual(self, nums):
        return next((i for i, x in enumerate(nums) if i%10 == x), -1)",O(n)
"import sys
input = sys.stdin.buffer.readline

def process(A):
    d = {}
    final = set([])
    for x in A:
        if x not in d:
            d[x] = 0
        d[x]+=1
        if d[x] >= 4:
            return [x, x, x, x]
        if d[x] >= 2:
            final.add(x)
    L = sorted(final)
    answer = [float('inf'), None, None]
    for i in range(len(L)-1):
        a = L[i]
        b = L[i+1]
        a1 = a/b+b/a
        answer = min(answer, [a1, a, b])
    a1, a, b = answer
    return [a, a, b, b]

t = int(input())
for i in range(t):
    n = int(input())
    A = [int(x) for x in input().split()]
    a, b, c, d = process(A)
    print(f'{a} {b} {c} {d}')",O(nlogn)
"import heapq


class Solution(object):
    def getOrder(self, tasks):
        idx = list(range(len(tasks)))
        idx.sort(key=lambda x: tasks[x][0])
        result, min_heap = [], []
        i, time = 0, tasks[idx[0]][0]
        while i < len(idx) or min_heap:
            while i < len(idx) and tasks[idx[i]][0] <= time:
                heapq.heappush(min_heap, (tasks[idx[i]][1], idx[i]))
                i += 1
            if not min_heap:
                time = tasks[idx[i]][0]
                continue
            t, j = heapq.heappop(min_heap)
            time += t
            result.append(j)
        return result",O(nlogn)
"class Solution(object):
    def shortestDistanceColor(self, colors, queries):
        dp = [[-1 for _ in range(len(colors))] for _ in range(3)]
        dp[colors[0]-1][0] = 0
        for i in range(1, len(colors)):
            for color in range(3):
                dp[color][i] = dp[color][i-1]
            dp[colors[i]-1][i] = i

        dp[colors[len(colors)-1]-1][len(colors)-1] = len(colors)-1
        for i in reversed(range(len(colors)-1)):
            for color in range(3):
                if dp[color][i+1] == -1:
                    continue
                if dp[color][i] == -1 or \
                   abs(dp[color][i+1]-i) < abs(dp[color][i]-i):
                    dp[color][i] = dp[color][i+1]
            dp[colors[i]-1][i] = i
         
        return [abs(dp[color-1][i]-i) if dp[color-1][i] != -1 else -1 \
                    for i, color in queries]",O(n)
"n = input()
l = map(int, raw_input().split())
r = map(int, raw_input().split())

mp = {i:i for i in range(n)}
out = [-1]*n
v = 0

a = n
done = set()
while v < n:
    ids = set()
    for j in range(n):
        if l[j] == r[j] == 0 and j not in done:
            ids.add(j)
            done.add(j)
    if len(ids) == 0:
        print('NO')
        exit()
    v += len(ids)
    for i in ids:
        out[mp[i]] = a
        for j in range(len(l)):
            if j < i:
                r[j] -= 1
            else:
                l[j] -= 1
    a -= 1
print('YES')
print(' '.join(map(str, out)))
",O(n ^ 2)
"import sys

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()

def iinp(): return int(input())

def nninp(): return map(int, sys.stdin.readline().strip().split())

def llinp(): return list(map(int, sys.stdin.readline().strip().split()))

def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math

n,k=nninp()
if(k>=2*n):
    p(0)
elif(k<=n):
    if(k%2==1):
        p(k//2)
    else:
        p(k//2-1)
else:
    if(k%2==1):
       print(k//2-(k-n)+1)
    else:
        print(k//2 - (k - n))
",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def distributeCoins(self, root):
        def dfs(root, result):
            if not root:
                return 0
            left, right = dfs(root.left, result), dfs(root.right, result)
            result[0] += abs(left) + abs(right)
            return root.val + left + right - 1

        result = [0]
        dfs(root, result)
        return result[0]",O(n)
"class Solution(object):
    def maxValue(self, n, x):
        check = (lambda i: str(x) > n[i]) if n[0] != '-' else (lambda i: str(x) < n[i])
        for i in range(len(n)):
            if check(i):
                break
        else:
            i = len(n)
        return n[:i] + str(x) + n[i:]",O(n)
"class Solution(object):
    def isPossible(self, n, edges):
        adj = [set() for _ in range(n)]
        for u, v in edges:
            adj[u-1].add(v-1)
            adj[v-1].add(u-1)
        odds = [u for u in range(n) if len(adj[u])%2]
        if len(odds) == 0:
            return True
        if len(odds) == 2:
            return any(odds[0] not in adj[u] and odds[1] not in adj[u] for u in range(n))
        if len(odds) == 4:
            return ((odds[0] not in adj[odds[1]] and odds[2] not in adj[odds[3]]) or
                    (odds[0] not in adj[odds[2]] and odds[1] not in adj[odds[3]]) or
                    (odds[0] not in adj[odds[3]] and odds[1] not in adj[odds[2]]))
        return False",O(n)
"class Solution2(object):
    def isIsomorphic(self, s, t):
        if len(s) != len(t):
            return False

        return self.halfIsom(s, t) and self.halfIsom(t, s)

    def halfIsom(self, s, t):
        lookup = {}
        for i in range(len(s)):
            if s[i] not in lookup:
                lookup[s[i]] = t[i]
            elif lookup[s[i]] != t[i]:
                return False
        return True",O(n)
"from math import *
n,k=map(int,input().split())
val=int(sqrt(9+(8*(n+k))))
ans=(-3+val)//2
print(n-ans)
",O(1)
"from collections import defaultdict as dd
from collections import deque, Counter
import bisect
import heapq
from math import inf

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def ri():
    return int(input())

def rl():
    return list(map(int, input().split()))

n, m = rl()
aa = rl()

bb = [-1]*n
for i in range(n):
	if aa[i] == m:
	    bb[i] = 1
	elif aa[i] < m:
	    bb[i] = -1
	else:
	    bb[i] = 1

prefix_sum= [0]*(n+1)
for i in range(1, n+1):
    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]

def mergeSortGoodOrder(arr):

    if len(arr) == 1:
        return arr, 0
    else:
        a = arr[:len(arr)//2]
        b = arr[len(arr)//2:]

        a, ai = mergeSortGoodOrder(a)
        b, bi = mergeSortGoodOrder(b)
        c = []

        i = 0
        j = 0
        good = 0 + ai + bi

    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            c.append(a[i])
            i += 1
            good += (len(b)-j)
        else:
            c.append(b[j])
            j += 1

    c += a[i:]
    c += b[j:]

    return c, good

idx = 0
for i in range(n):
    if aa[i] == m:
        idx = i

_, good = mergeSortGoodOrder(prefix_sum)

_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])

_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])

first_count = good - bad_left - bad_right

bb = [-1]*n
for i in range(n):
	if aa[i] == m + 1:
	    bb[i] = 1
	elif aa[i] < m + 1:
	    bb[i] = -1
	else:
	    bb[i] = 1

prefix_sum= [0]*(n+1)
for i in range(1, n+1):
    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]

_, good = mergeSortGoodOrder(prefix_sum)

_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])

_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])

second_count = good - bad_left - bad_right

ans   = first_count - second_count

print(ans)
",O(nlogn)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
from collections import defaultdict
from itertools import permutations

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

a=sorted(input())
b=int(input())
a=a[::-1]
p=""""
while a:
	for i, z in enumerate(a):
		n=p+a[i]+"""".join(sorted(a[:i]+a[i+1:]))
		if int(n)<=b:
			p+=z
			a.pop(i)
			break
print(p)",O(n ^ 3)
"n,k =  map(int,input().split())

def tonny(i) :
	return (ord(i)-96)
a= sorted(input())
a=list(map(tonny,a))
a=sorted(list(set(a)))
ans=[a.pop(0)]
k-=1
for j in a :
	if j-ans[-1] >1 and k>0 :
		k-=1
		ans.append(j)
	if k==0 :
		break
if k!=0 :
	print(-1)
else:
	print(sum(ans))
",O(n)
"class Solution(object):
    def minCost(self, nums, costs):
        stk1, stk2 = [], []
        dp = [float(""inf"")]*len(nums)
        dp[0] = 0
        for i in range(len(nums)):
            while stk1 and nums[stk1[-1]] <= nums[i]:
                dp[i] = min(dp[i], dp[stk1.pop()]+costs[i])
            stk1.append(i)
            while stk2 and nums[stk2[-1]] > nums[i]:
                dp[i] = min(dp[i], dp[stk2.pop()]+costs[i])
            stk2.append(i)
        return dp[-1]",O(n)
"n = int(input())
ans = []
m = 1
while n > 3:
    ans += [m] * (n - n // 2)
    n //= 2
    m *= 2
if n == 3:
    ans += [m, m, m * 3]
elif n == 2:
    ans += [m, m * 2]
else:
    ans += [m]
print(*ans)
",O(nlogn)
"class Solution2(object):
    def firstPalindrome(self, words):
        return next((x for x in words if x == x[::-1]), """")",O(n)
"from sys import stdin, gettrace

if not gettrace():
    def input():
        return next(stdin)[:-1]

INF = 10000

def main():
    n = int(input())
    aa = [int(a) for a in input().split()]

    dp = [[0] * (n+1) for _ in range(n)]

    def calc_dp(i, j):
        if i + 1 == j:
            dp[i][j] = aa[i]
        if dp[i][j] != 0:
            return dp[i][j]
        dp[i][j] = -1
        for k in range(i+1, j):
            lf = calc_dp(i, k)
            rg = calc_dp(k, j)
            if lf > 0 and lf == rg:
                dp[i][j] = lf + 1
                break
        return dp[i][j]

    dp2 = list(range(0,n+1))
    for i in range(n):
        for j in range(i+1, n+1):
            if calc_dp(i, j) > 0:
                dp2[j] = min(dp2[j], dp2[i] + 1)
    print(dp2[n])

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"n, m, k = map(int, input().split())
*a, = map(int, input().split())
dp = [-1] * (n + 15)
for i in range(n):
    s, mx = a[i], max(0, a[i])
    for j in range(i - 1, max(-1, i - m), -1):
        s += a[j]
        mx = max(mx, s)
    dp[i] = max(0, dp[i - m] + s - k, mx - k)
print(max(dp))",O(n ^ 2)
"n,k=map(int,input().split())
n,k=n-1,k-1
l=0
r=k
g=k*(k+1)//2
ans=-1
while l<=r:
	m=(l+r)//2

	if (g-m*(m+1)//2)>=n:
		ans=k-m
		l=m+1
	else:
		r=m-1
print(ans)
",O(logn)
"n = int(input())

m = input()

s = list(m)

if n==1:
    ans = s[0]
else:
    count = 0
    for i in range(0,n):
        if s[i]=='0':
            count = count + 1
    ans = '1'
    for i in range(0,count):
        ans = ans + '0'

print(ans)",O(n)
"class Solution(object):
    def firstMissingPositive(self, A):
        i = 0
        while i < len(A):
            if A[i] > 0 and A[i] - 1 < len(A) and A[i] != A[A[i]-1]:
                A[A[i]-1], A[i] = A[i], A[A[i]-1]
            else:
                i += 1

        for i, integer in enumerate(A):
            if integer != i + 1:
                return i + 1
        return len(A) + 1",O(n)
"class Solution:
    def rob(self, nums: List[int]) -> int:
        rob1, rob2 = 0, 0

        for num in nums:
            temp = max(num + rob1, rob2)
            rob1 = rob2
            rob2 = temp
        return rob2
",O(n)
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=None):
        self.BIT=[0]*(n+1)
        self.num=n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        self.mod = mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res

    def bisect_l(self,l,r,x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l<r:
            if l & 1:
                if self.tree[l] <= x and Lmin==-1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r-1] <=x:
                    Rmin = r-1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        elif Rmin != -1:
            pos = Rmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        else:
            return -1

from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        forward = [to, cap, cost, None]
        backward = forward[3] = [fr, 0, -cost, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [None]*N

        d0 = [INF]*N
        dist = [INF]*N

        while f:
            dist[:] = d0
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                r0 = dist[v] + H[v]
                for e in G[v]:
                    w, cap, cost, _ = e
                    if cap > 0 and r0 + cost - H[w] < dist[w]:
                        dist[w] = r = r0 + cost - H[w]
                        prv_v[w] = v; prv_e[w] = e
                        heappush(que, (r, w))
            if dist[t] == INF:
                return None

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, prv_e[v][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = prv_e[v]
                e[1] -= d
                e[3][1] += d
                v = prv_v[v]
        return res

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.buffer.readline()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

k = li()
k.sort()
k = tuple(k)

ans = [(2,4,4),(3,3,3)]
if k.count(1)>=1:
    print(""YES"")
elif k.count(2)>=2:
    print(""YES"")
elif k.count(3)>=3:
    print(""YES"")
elif k in ans:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"n, k = map(int, input().split())
grid = [['.']*n for i in range(4)]
if k % 2 == 0:
    for i in range(k//2):
        grid[1][1+i], grid[2][1+i] = '
else:
    m = n//2
    if k > n - 2:
        for i in range(1, n-1):
            grid[1][i] = '
        for i in range(1, (k-n+2)//2 + 1):
            grid[2][m+i], grid[2][m-i] = '
    else:
        grid[1][m] = '
        if k > 1:
            for i in range(1, k//2 + 1):
                grid[1][m-i], grid[1][m+i] = '
print('YES')
for i in grid:
    print(''.join(i))",O(n)
"import sys
input = lambda: sys.stdin.readline().rstrip()

N, K = map(int, input().split())
S = [-1 if a == ""?"" else ord(a) - 97 for a in input()]
II = {1 << i: i for i in range(20)}
def calc(mmm):
    inf = 300000
    X = [[0] * N for _ in range(K)]
    for k in range(K):
        Xk = X[k]
        mi = inf
        r = 0
        for i in range(N)[::-1]:
            if S[i] < 0 or S[i] == k:
                r += 1
            else:
                r = 0
            if r >= mmm:
                mi = min(mi, i + mmm)
            Xk[i] = mi

    Y = [0] * (1 << K)
    for i in range(1, 1 << K):
        mi = inf
        for j in range(K):
            if i >> j & 1:
                ii = i ^ (1 << j)
                if Y[ii] < N:
                    mi = min(mi, X[j][Y[ii]])
        Y[i] = mi
    return 1 if Y[-1] < inf else 0

l, r = 0, N // K + 1
while r - l > 1:
    m = l + r >> 1
    if calc(m):
        l = m
    else:
        r = m
print(l)
",np
"q = int(input())
for i in range(q):
    n, m, k = map(int, input().split())
    m, n = abs(m), abs(n)
    mx = max(m, n)
    remaining = k - mx
    if remaining < 0:
        print(-1)
    elif m == n == 0:
        if k == 1:
            print(-1)
        elif k % 2:
            print(k - 1)
        else:
            print(k)
    elif abs(m - n) % 2 == 0:
        if remaining % 2 == 0:
            print(k)
        else:
            print(k - 2)
    else:
        if not remaining:
            print(k - 1)
        elif remaining % 2 == 0:
            print(k - 1)
        else:
            print(k - 1)
",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def flipMatchVoyage(self, root, voyage):
        def dfs(root, voyage, i, result):
            if not root:
                return True
            if root.val != voyage[i[0]]:
                return False
            i[0] += 1
            if root.left and root.left.val != voyage[i[0]]:
                result.append(root.val)
                return dfs(root.right, voyage, i, result) and \
                       dfs(root.left, voyage, i, result)
            return dfs(root.left, voyage, i, result) and \
                   dfs(root.right, voyage, i, result)
        
        result = []
        return result if dfs(root, voyage, [0], result) else [-1]",O(n)
"def f():
    b = [a[0]]
    for e in a[1:]:
        if b != []:
            if e == b[-1] or abs(e-b[-1])%2==0:
                b.pop()

            else:
                b.append(e)
        else:
            b.append(e)

    for i in range(1,len(b)):
        if abs(b[i]-b[i-1])%2:
            print('NO')
            return

    print('YES')

n=int(input())
a=[int(i) for i in input().split()]

f()",O(n)
"import sys

p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
def li(): return [int(i) for i in input().split()]
def lli(rows): return [li() for _ in range(rows)]
def si(): return input()
def ii(): return int(input())
def ins(): return input().split()

n,m=MI()
posf=(n*(n-1))//2
if(n%2!=0):
    negf=(n//2)*(n//2+1)
else:
    negf=(n//2)*(n//2-1)+n//2
ans=0
for i in range(m):
    x,d=MI()
    ans+=n*x
    if(d>=0):
        ans+=posf*d
    else:
        ans+=negf*d
print(ans/n)",O(n)
"class Solution(object):
    def findBottomLeftValue(self, root):
        def findBottomLeftValueHelper(root, curr_depth, max_depth, bottom_left_value):
            if not root:
                return max_depth, bottom_left_value
            if not root.left and not root.right and curr_depth+1 > max_depth:
                return curr_depth+1, root.val
            max_depth, bottom_left_value = findBottomLeftValueHelper(root.left, curr_depth+1, max_depth, bottom_left_value)
            max_depth, bottom_left_value = findBottomLeftValueHelper(root.right, curr_depth+1, max_depth, bottom_left_value)
            return max_depth, bottom_left_value

        result, max_depth = 0, 0
        return findBottomLeftValueHelper(root, 0, max_depth, result)[1]",O(n)
"pfs=[i*i for i in range(1,3163)]
p=[i for i in range(0,10000001)]
for i in range(1,10000001):
    if(p[i]==i):
        for j in pfs:
            if(i*j>10000000): break
            p[i*j]=i
t=int(input())
for lll in range(0,t):
    n,k=map(int,input().split())
    zc=list(map(int,input().split()))
    s=[p[zc[i]] for i in range(0,len(zc))]
    dp=[n]*(k+1)
    dp[0]=1
    ys=[{}]*(n+1)
    for i in range(0,len(s)):
        for j in range(k,-1,-1):
            if(dp[j]==n): continue
            if(ys[j].get(s[i],-1)!=-1):
                if(j<k and dp[j]<dp[j+1]):
                    dp[j+1]=dp[j]
                    ys[j+1]=ys[j]
                dp[j]+=1
                ys[j]={}
            ys[j][s[i]]=1
    print(min(dp))
",O(n ^ 3)
"n,k=map(int,input().split())
n,k=n-1,k-1
l=0
r=k
g=k*(k+1)//2
ans=-1
while l<=r:
	m=(l+r)//2
	if (g-m*(m+1)//2)>=n:
		ans=k-m
		l=m+1
	else:
		r=m-1
print(ans)",O(logn)
"import collections


class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def serialize(self, root):
        def serializeHelper(node, vals):
            if node:
                vals.append(node.val)
                serializeHelper(node.left, vals)
                serializeHelper(node.right, vals)

        vals = []
        serializeHelper(root, vals)

        return ' '.join(map(str, vals))


    def deserialize(self, data):
        def deserializeHelper(minVal, maxVal, vals):
            if not vals:
                return None

            if minVal < vals[0] < maxVal:
                val = vals.popleft()
                node = TreeNode(val)
                node.left = deserializeHelper(minVal, val, vals)
                node.right = deserializeHelper(val, maxVal, vals)
                return node
            else:
                return None

        vals = collections.deque([int(val) for val in data.split()])

        return deserializeHelper(float('-inf'), float('inf'), vals)",O(n)
"class Solution(object):
    def numberOfSubarrays(self, nums):
        result = 0
        stk = []
        for x in nums:
            while stk and stk[-1][0] < x:
                stk.pop()
            if not stk or stk[-1][0] != x:
                stk.append([x, 0])
            stk[-1][1] += 1
            result += stk[-1][1]
        return result",O(n)
"import sys
import math
from collections import defaultdict,deque
import heapq
n,k=map(int,sys.stdin.readline().split())

mod=998244353
dp=[[0,0,0,0] for x in range(k+3)]
dp[1][0]=1
dp[1][1]=1
dp[2][2]=1
dp[2][3]=1
newdp=[[0,0,0,0] for x in range(k+3)]
for i in range(n-1):

    for j in range(k+1):
        newdp[j+1][1]+=dp[j][0]
        newdp[j+1][3]+=dp[j][0]
        newdp[j+1][2]+=dp[j][0]
        newdp[j][0]+=dp[j][0]
        newdp[j][1]+=dp[j][1]
        newdp[j+1][3]+=dp[j][1]
        newdp[j+1][2]+=dp[j][1]
        newdp[j+1][0]+=dp[j][1]
        newdp[j][1]+=dp[j][2]
        newdp[j+2][3]+=dp[j][2]
        newdp[j][2]+=dp[j][2]
        newdp[j][0]+=dp[j][2]
        newdp[j][1]+=dp[j][3]
        newdp[j][3]+=dp[j][3]
        newdp[j+2][2]+=dp[j][3]
        newdp[j][0]+=dp[j][3]

        for a in range(3):
            for b in range(4):
                newdp[a+j][b]%=mod
    for a in range(k+3):
        for b in range(4):
            dp[a][b]=newdp[a][b]
            newdp[a][b]=0
ans=sum(dp[k])
ans%=mod
print(ans)
",np
"n=int(input())
p=[0,0]+list(map(int,input().split()))
d=[0]*(n+1)
for i in range(n,1,-1):
    if d[i]==0:
        d[i]=1
    d[p[i]]+=d[i]
if n==1:
    d[1]=1
d=d[1:]
d.sort()
print(*d)",O(n)
"n=int(input())
a=list(map(int,input().split()))
p=0
while p+1<len(a) and a[p]==a[p+1]:
    p+=2
c=0
while p<len(a):
    if p+1<len(a):
        i=a.index(a[p],p+1)
        c+=i-p-1
        tmp=a.pop(i)
        a.insert(p,tmp)
    while p+1<len(a) and a[p]==a[p+1]:
        p+=2
print(c)",O(n ^ 2)
"class Solution(object):
    def find132pattern(self, nums):
        ak = float(""-inf"")
        stk = []
        for i in reversed(range(len(nums))):
            if nums[i] < ak:
                return True
            while stk and stk[-1] < nums[i]:
                ak = stk.pop()
            stk.append(nums[i])
        return False",O(n)
"from sys import stdin
from math import hypot

def main():
    l = stdin.read().splitlines()[1:]
    for i, s in enumerate(l):
        l[i] = [*map(float, s.split()), i]
    l.sort(key=lambda xyi: abs(xyi[0]))
    res = ['1'] * len(l)
    x, y, _ = l.pop()
    while(l):
        dx, dy, i=l.pop()
        a, b, u, v = x + dx, y + dy, x - dx, y - dy
        if hypot(a, b) < hypot(u, v):
            x, y = a, b
        else:
            x, y, res[i] = u, v, '-1'
    print(' '.join(res))

if __name__ == '__main__':
    main()
",O(nlogn)
"class Solution2(object):
    def maxScore(self, edges):
        def dfs(u):
            if not adj[u]:
                return (0, 0)
            children = [dfs(v) for v, _ in adj[u]]
            without_u = sum(max(with_v, without_v) for with_v, without_v in children)
            with_u = max(without_u-max(with_v, without_v)+(without_v+adj[u][i][1]) for i, (with_v, without_v) in enumerate(children))
            return (with_u, without_u)
            
        adj = [[] for _ in range(len(edges))]
        for i, (p, w) in enumerate(edges):
            if i == 0:
                continue
            adj[p].append((i, w))
        return max(dfs(0))",O(n)
"n , k = map(int , input().split())
n , k = n-1 , k-1

l = 0
r = k
g = k*(k+1)//2
ans = -1

while l <= r:
 	m = (l+r)//2
 	if g-m*(m+1)//2>=n:
 		ans = k-m
 		l = m+1
 	else:
 		r = m-1

print(ans)",O(logn)
"class Solution(object):
    def maxNiceDivisors(self, primeFactors):
        MOD = 10**9 + 7
        if primeFactors <= 3:
            return primeFactors
        if primeFactors % 3 == 0: 
            return pow(3, primeFactors//3, MOD)
        if primeFactors % 3 == 1: 
            return (2*2*pow(3, (primeFactors-4)//3, MOD)) % MOD
        return (2*pow(3, (primeFactors-2)//3, MOD)) % MOD",O(logn)
"A=[9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889]
k=int(input())
if k<10:
    print(k)
else:
    for n in range (0,12):
        if k>A[n+1]:
            continue
        else:
            a=10**(n+1)+(k-A[n]-1)//(n+2)
            b=(k-A[n]-1)%(n+2)
            print(str(a)[b])
            break",O(logn)
"import math

inp = input().strip()
dec = input().strip()
inp_dict = {""+"":0,""-"":0}
dec_dict = {""+"":0,""-"":0,""?"":0}

for i in range(len(inp)):
	if inp[i]==""+"":
		inp_dict[""+""] += 1
	elif inp[i]==""-"":
		inp_dict[""-""] += 1

for i in range(len(dec)):
	if dec[i]==""+"":
		dec_dict[""+""] += 1
	elif dec[i]==""-"":
		dec_dict[""-""] += 1
	elif dec[i] == ""?"":
		dec_dict[""?""] += 1

if(dec_dict[""+""] == inp_dict[""+""] and dec_dict[""-""] == inp_dict[""-""]):
	print(1.0000000000)
else:
	temp = inp_dict[""+""] - dec_dict[""+""]
	temp1 = inp_dict[""-""] - dec_dict[""-""]

	if temp + temp1 == dec_dict[""?""] and temp>=0 and temp1 >= 0:
		temp2 = math.factorial(temp+temp1)/(math.factorial(temp)*math.factorial(temp1))
		for i in range(temp1+temp):
			temp2 = temp2 * 0.5
		print(temp2)
	else:
		print(0.000000000)
",np
"def nr(): return nrs()[0]
def nrs(): return [int(i) for i in input().split()]

def get_prime(n):
	res = []
	for i in range(2,n):
		is_prime = True
		for x in res:
			if i % x == 0:
				is_prime = False
				break
		if is_prime: res.append(i)
	return res

prime = get_prime(3162)

cache = {}
def get_mask (num):
	key = num
	if key in cache: return cache[key]
	dv = []
	for p in prime:
		c = 0
		while num % p == 0:
			c += 1
			num = num // p
		if c % 2 == 1:
			dv.append(p)
		if num < p * p:
			break

	for x in dv:
		num *= x

	cache[key] = num
	return num

for _ in range(nr()):
	N, K = nrs()
	A = nrs()
	dp = [N] * (K + 1)
	dp[0] = 1
	used = [{}] * (K + 1)
	for a in A:
		a = get_mask(a)
		for j in range(K, -1, -1):
			if dp[j] == N: continue
			if a in used[j]:
				if j < K and dp[j + 1] > dp[j]:
					dp[j + 1] = dp[j]
					used[j + 1] = used[j]
				dp[j] += 1
				used[j] = {}
			used[j][a] = 1
	print(min(dp))
",O(n ^ 3)
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        def backtrack(i, total):
            if i ==len(nums):
                return  total == target

            return (backtrack(i + 1, total + nums[i]) +
                    backtrack(i + 1, total - nums[i]))

        return backtrack(0, 0)
",O(2 ^ n)
"from operator import itemgetter

n, v = map(int, input().split())

if v >= n-1:
    ans = n-1
else:
    ans = v + ((2+(2+n-v-2))*(n-v-1))//2
print(ans)
",O(1)
"import collections


class Solution(object):
    def numTilePossibilities(self, tiles):
        fact = [0.0]*(len(tiles)+1)
        fact[0] = 1.0
        for i in range(1, len(tiles)+1):
            fact[i] = fact[i-1]*i
        count = collections.Counter(tiles)

        
        coeff = [0.0]*(len(tiles)+1)
        coeff[0] = 1.0
        for i in count.values():
            new_coeff = [0.0]*(len(tiles)+1)
            for j in range(len(coeff)):
                for k in range(i+1):
                    if k+j >= len(new_coeff):
                        break
                    new_coeff[j+k] += coeff[j]*1.0/fact[k]
            coeff = new_coeff

        result = 0
        for i in range(1, len(coeff)):
            result += int(round(coeff[i]*fact[i]))
        return result",O(n ^ 2)
"class Solution(object):
    def countHomogenous(self, s):
        MOD = 10**9+7
        result = cnt = 0
        for i in range(len(s)):
            if i and s[i-1] == s[i]:
                cnt += 1
            else:
                cnt = 1
            result = (result+cnt)%MOD
        return result",O(n)
"n=int(input())
a=list(map(int,input().split()))
b=[]
maxi=0
for i in range(n):
    maxi=max(maxi,a[i]+1)
    b.append(maxi)
c=[]
count=b[-1]
for i in range(n-1,-1,-1):
    if count-1>=b[i]:
        count-=1
        c.append(count)
    else:
        c.append(count)
c=c[::-1]
ans=0
for i in range(n):
    ans+=(c[i]-a[i]-1)
print(ans)",O(n)
"class Solution2(object):
    def triangularSum(self, nums):
        result = 0
        nCr = 1
        for i in range(len(nums)):
            result = (result+nCr*nums[i])%10
            nCr *= (len(nums)-1)-i
            nCr //= i+1
        return result",O(n)
"import sys,math
class Node:
    def __init__(self,u=math.inf,d=math.inf,l=math.inf,r=math.inf):
        self.up=u
        self.dn=d
        self.lt=l
        self.rt=r
    def __str__(self):
        return 'U:{},D:{},L:{},R:{}'.format(self.up,self.dn,self.lt,self.rt)

n,m,k=list(map(int,sys.stdin.readline().strip().split()))
graph=[[Node() for j in range(m)]for i in range(n)]
for i in range(n):
    wts=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(m-1):
        graph[i][j].rt=wts[j]
        graph[i][j+1].lt=wts[j]

for i in range(n-1):
    wts=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(m):
        graph[i][j].dn=wts[j]
        graph[i+1][j].up=wts[j]

ans=[[math.inf for j in range(m)]for i in range(n)]

if k%2:
    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]

else:
    def bfs(prsnt,stps):

        if stps==0:
            return 0
        else:
            if dp[prsnt[0]][prsnt[1]][stps]==math.inf:
                min_cost=math.inf
                for x,y,c in [(0,1,graph[prsnt[0]][prsnt[1]].dn),(1,0,graph[prsnt[0]][prsnt[1]].rt),(0,-1,graph[prsnt[0]][prsnt[1]].up),(-1,0,graph[prsnt[0]][prsnt[1]].lt)]:
                    if -1<prsnt[1]+x<m and -1<prsnt[0]+y<n:
                        min_cost=min(bfs((prsnt[0]+y,prsnt[1]+x),stps-1)+c,min_cost)
                dp[prsnt[0]][prsnt[1]][stps]=min_cost
                return min_cost
            else:
                return dp[prsnt[0]][prsnt[1]][stps]

    dp=[[[math.inf for k in range(k+1)] for j in range(m)]for i in range(n)]
    for i in range(n):
        for j in range(m):
            ans[i][j]=bfs((i,j),k//2)*2
    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]",O(n ^ 3)
"L = [(i+1)*9*10**i for i in range(12)]
number = int(input())

exponent=0
while number >= 0:
    number-=L[exponent]
    exponent+=1
exponent-=1
number%=L[exponent]
start = 10**exponent
numDigits = exponent+1
final = start+(number//numDigits-1)
remainder = number%numDigits
if remainder == 0:
    final = str(final)
    print(final[-1])
else:
    final = str(final+1)
    print(final[remainder-1])
",O(1)
"def solve(moves,candies_end):
    total_candies = 1
    low = 0
    high = moves
    while low <= high:
        mid = (low+high)//2
        if (((moves-mid)*(moves-mid+1))//2)-mid == candies_end:
            return mid
        elif (((moves-mid)*(moves-mid+1))//2)-mid < candies_end:
            high = mid-1
        else:
            low = mid+1

n,k = map(int,input().split())
print(solve(n,k))",O(logn)
"class Solution(object):
    def optimalDivision(self, nums):
        if len(nums) == 1:
            return str(nums[0])
        if len(nums) == 2:
            return str(nums[0]) + ""/"" + str(nums[1])
        result = [str(nums[0]) + ""/("" + str(nums[1])]
        for i in range(2, len(nums)):
            result += ""/"" + str(nums[i])
        result += "")""
        return """".join(result)",O(n)
"from sys import stdin, stdout

def main():
    p = 998244353
    n = int(stdin.readline())
    a = list(readline())
    answer = a[-1]
    pow_ = 1
    for i in range(n - 1, 0, -1):
        answer = (answer + a[i - 1] * (2 + n - i) * pow_ % p) % p
        pow_ = pow_ * 2 % p
    return answer

def readline():
    return map(int, stdin.readline().strip().split())

if __name__ == '__main__':
    stdout.write(str(main()) + '\n')
",O(n)
"n,m=map(int,input().split())
o=0
c=0
diff=[]
while n:
    n-=1
    a,b=map(int,input().split())
    diff.append(a-b)
    o+=a
    c+=b

if m >=o:
    print(0)
elif m <c:
    print(-1)
else:
    diff.sort(reverse=True)
    nd=o-m

    for i in range(len(diff)):

        nd-=diff[i]
        if nd<=0:
            print(i+1)
            break
",O(nlogn)
"import heapq
import collections



class Solution(object):
    def minimumAddedInteger(self, nums1, nums2):
        def check(cnt2, cnt1):
            return all(cnt1.get(k, 0)-v >= 0 for k, v in cnt2.items()) 
            
        mx = max(nums2)
        cnt2 = collections.Counter(nums2)
        return next(d for d in [mx-x for x in heapq.nlargest(3, nums1)] if check(cnt2, collections.Counter(x+d for x in nums1)))",O(n)
"class Solution(object):
    def getSmallestString(self, n, k):
        MAX_DIFF = ord('z')-ord('a')

        k -= n
        result = ['a']*n
        for i in reversed(range(n)):
            tmp = min(k, MAX_DIFF)
            result[i] = chr(ord('a')+tmp)
            k -= tmp
            if k == 0:
                break
        return """".join(result)",O(n)
"t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if n == 1:
        print(0)
    else:
        max1 = max2 = -1
        for q in a:
            if q > max1:
                max1, max2 = q, max1
            elif q > max2:
                max2 = q
        print(max(0, min(max2-1, len(a)-2)))
",O(n)
"import collections



class Solution2(object):
    def maxSubarraySum(self, nums):
        result = float(""-inf"")
        curr = mn = mn0 = 0
        mn1 = collections.defaultdict(int)
        for x in nums:
            curr += x
            result = max(result, curr-mn)
            if x < 0:
                mn1[x] = min(mn1[x], mn0)+x
                mn = min(mn, mn1[x])
            mn0 = min(mn0, curr)
            mn = min(mn, mn0)
        return result",O(n)
"import sys
import bisect
import heapq
import math

INF = 10**9+7
sys.setrecursionlimit(INF)

def fi():
    return int(sys.stdin.readline())

def fi2():
    return map(int, sys.stdin.readline().split())

def fi3():
    return sys.stdin.readline().rstrip()

def fo(*args):
    for s in args:
        sys.stdout.write(str(s)+' ')
    sys.stdout.write('\n')

def puts(*args):
    for s in args:
        sys.stdout.write(str(s))

def mask(n1):
    arr = []
    for i in range(64):
        arr.append(n1&1)
        n1 = n1 >> 1
    arr.reverse()
    return arr

def getn(mask):
    if sum(mask) == 0:
        return 0
    res = 0
    for i in range(63, -1, -1):
        res += (2*mask[i])**(63-i)
    return res

n1, n2 = fi2()
m1 = mask(n1)
m2 = mask(n2)

sol = [0 for i in range(64)]

for i in range(64):
    if m1[i] != m2[i]:
        sol[i] = 1
        break

i += 1
for j in range(i, 64):
    sol[j] = 1

res = getn(sol)
fo(res)
",O(logn)
"x, k = [int(a) for a in input().strip().split()]

def binpow(x, k, mod):
    res = 1
    while k > 0:
        if k & 1:
            res  = ( res * x ) % mod
        x = ( x * x) % mod
        k >>= 1
    return res
if x == 0:
    print(0)
    exit()

mod = int(1e9 + 7)
k2 = binpow(2, k, mod)
res = ( k2 * (2 * x - 1) + 1) % mod

res %= mod

print(int(res))",O(logn)
"def solve():
	c,d = 0,0
	print(""?"",c,d,flush=True)
	ans = int(input())
	if ans==0:

		num = 0
		for i in range(29,-1,-1):
			c = 1<<i
			d = 0
			print(""?"",c,d,flush=True)
			ans =int(input())
			if ans ==-2:
				return
			if ans == -1:
				num+=(1<<i)
		print(""!"",num,num)
	else:
		l = [0,0]
		if ans == 1:
			cur = 0
		else:
			cur = 1

		prev = ans

		for i in range(29,-1,-1):
			tc = c|(1<<i)
			td = d|(1<<i)
			print(""?"",tc,td,flush=True)
			ans = int(input())
			if ans ==-2:
				return
			if ans ==0:
				break
			if ans !=prev:
				l[cur] += (1<<i)
				if cur ==0:
					c = tc
				else:
					d = td
				print(""?"",c,d,flush=True)
				temp = int(input())
				prev = temp
				if temp == 1:
					cur = 0
				else:
					cur = 1
		c = l[0]
		d = l[1]

		for i in range(29,-1,-1):
			if c&(1<<i) != 0 or d&(1<<i) !=0 :
				continue
			tc = c|(1<<i)
			print(""?"",tc,d,flush=True)
			ans = int(input())
			if ans==-2:
				return
			if ans==-1:
				l[0]|=(1<<i)
				l[1]|=(1<<i)
		print(""!"",l[0],l[1])
	return

t = 1

while t>0:
	t-=1
	solve()",O(logn)
"class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        closeToOpen = { "")"" : ""("", ""]"" : ""["", ""}"" : ""{"" }

        for c in s:
            if c in closeToOpen:
                if stack and stack[-1] == closeToOpen[c]:
                    stack.pop()
                else:
                    return False
            else:
                stack.append(c)

        return True if not stack else False
",O(n)
"n,k=[int(x) for x in input().split("" "")]
a=[int(x) for x in input().split("" "")]
mark,b=[],[]
for x in a:
    b.append(x)
    mark.append(False)
b.sort(reverse=True)
idx,profit=0,0
while idx<k:
    profit+=b[idx]
    for i in range(n):
        if not mark[i] and a[i]==b[idx]:
            mark[i]=True
            break
    idx+=1
print(profit)
prev,counter=-1,0
for i in range(n):
    if counter==(k-1):
        break
    if mark[i]:
        print(i-prev,end=' ')
        prev=i
        counter+=1
print(n-prev-1)
",O(nlogn)
"class Solution2(object):
    def wordPattern(self, pattern, str):
        words = str.split() 
        if len(pattern) != len(words):
            return False

        w2p, p2w = {}, {}
        for p, w in zip(pattern, words):
            if w not in w2p and p not in p2w:
                w2p[w] = p
                p2w[p] = w
            elif w not in w2p or w2p[w] != p:
                return False
        return True",O(n)
"from __pypy__.intop import int_mulmod

n_, MOD = [int(t) for t in input().split()]

def mul(a, b):
    return int_mulmod(a, b, MOD)

N = 410
dp = [[0] * (N+1) for _ in range(N+1)]

fact = [1]
for x in range(1, N):
    fact.append(fact[-1] * x % MOD)

inv_fact = [0] * N
inv_fact[-1] = pow(fact[-1], MOD - 2, MOD)
for x in reversed(range(1, N)):
    inv_fact[x - 1] = inv_fact[x] * x % MOD

def nCr(n, r):
    return mul(fact[n], mul(inv_fact[n-r], inv_fact[r]))

for n in range(1, N+1):
    dp[n][n] = pow(2, n-1, MOD)
    for i in range(1, n-1):
        j = n-i-1
        for k in range(1, i+1):
            dp[n][k+j] = (dp[n][k+j]
                          + mul(nCr(k+j, k), mul(dp[i][k], dp[j][j]))) % MOD

print(sum(dp[n_]) % MOD)
",O(n ^ 3)
"class Solution2(object):
    def rearrangeArray(self, nums):
        def pos():
            for x in nums:
                if x > 0:
                    yield x
        
        def neg():
            for x in nums:
                if x < 0:
                    yield x
        
        gen_pos = pos()
        gen_neg = neg()
        return [next(gen_pos) if i%2 == 0 else next(gen_neg)  for i in range(len(nums))]",O(n)
"n,k = map(int, raw_input().split())

def area(height):
    return n * height

def bin_search(low, high):
    if (high == low):
        return high
    if high - low == 1:
        if area(low) >= k:
            return low
        return high
    midd = (high + low) // 2
    if area(midd) > k:
        return bin_search(low, midd)
    return bin_search(midd, high)

print(bin_search(0, 1000000000000000000))",O(logn)
"from heapq import heappush, heappop
n = int(input())
L = list(map(int, input().split()))
T = input()

ans = sum(L)

Q = []

for l, t in zip(L, T):
    if t == 'G':
        heappush(Q, (2, 2 * l))
        heappush(Q, (5, float('inf')))
    elif t == 'W':
        heappush(Q, (1, 2 * l))
        heappush(Q, (3, float('inf')))

    need_stamina = l
    while need_stamina > 0:
        cost, quantity = heappop(Q)
        if need_stamina > quantity:
            ans += quantity * cost
            need_stamina -= quantity
        else:
            ans += need_stamina * cost
            heappush(Q, (cost, quantity - need_stamina))
            need_stamina = 0

print(ans)
",O(nlogn)
"import sys
input=sys.stdin.readline
n=int(input())
a=list(map(int,input().split()))
INF=10**9
dp=[[INF]*(n+1) for i in range(n+1)]
val=[[-1]*(n+1) for i in range(n+1)]
for i in range(n):
  dp[i][i+1]=1
  val[i][i+1]=a[i]
for l in range(2,n+1):
  for i in range(n-l+1):
    j=i+l
    for k in range(i+1,j):
      if dp[i][k]==dp[k][j]==1 and val[i][k]==val[k][j]:
        dp[i][j]=1
        val[i][j]=val[i][k]+1
      else:
        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])
print(dp[0][n])",O(n ^ 3)
"from sys import stdin
input=stdin.readline
n,m,k=map(int,input().split())
lr=[list(map(int,input().split())) for i in range(n)]
ud=[list(map(int,input().split())) for i in range(n-1)]
if k%2:
  arr=[-1]*m
  for i in range(n):
    print(*arr)
  exit()
kk=k//2
dp=[[[10**10]*(kk+1) for i in range(m)] for j in range(n)]
for i in range(n):
  for j in range(m):
    dp[i][j][0]=0
for z in range(1,kk+1):
  for i in range(n):
    for j in range(m):
      if i>0:
        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-1]+ud[i-1][j])
      if i<n-1:
        dp[i][j][z]=min(dp[i][j][z],dp[i+1][j][z-1]+ud[i][j])
      if j>0:
        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-1]+lr[i][j-1])
      if j<m-1:
        dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-1]+lr[i][j])
ans=[[dp[i][j][kk]*2 for j in range(m)] for i in range(n)]
for i in range(n):
  print(*ans[i])",O(n ^ 3)
"class Solution(object):
    def diStringMatch(self, S):
        result = []
        left, right = 0, len(S)
        for c in S:
            if c == 'I':
                result.append(left)
                left += 1
            else:
                result.append(right)
                right -= 1
        result.append(left)
        return result",O(n)
"m = 1000000007
x, k = map(int, input().split())
up = (x * pow(2, k + 1, m)) % m
down = pow(2, k, m) - 1
if (x == 0):
    print(0)
else:
    print((up - down) % m)",O(logn)
"import sys
from collections import deque,defaultdict as dd
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input()
def mi():return map(int,input().split())
def li():return list(mi())
abc='abcdefghijklmnopqrstuvwxyz'
abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod=1000000007

inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]
def read():
    tc=0
    if tc:
        input=sys.stdin.readline
    else:
        sys.stdin=open('input1.txt', 'r')
        sys.stdout=open('output1.txt','w')

def permute(b,x,ind):
    if(ind==len(b)):
        return 1
    f=0
    for i in range(9,-1,-1):
        if(x[i]>0 and i<=int(b[ind])):
            x[i]-=1
            ans[ind]=str(i)
            if(i<int(b[ind])):
                f=1
            if(f):
                k=9
                for j in range(ind+1,len(b)):
                    while(x[k]==0):
                        k-=1
                    ans[j]=str(k)
                    x[k]-=1
                return 1
            if(permute(b,x,ind+1)):
                return 1
            x[i]+=1
    return 0

def solve():

    a=ii()
    b=ii()
    if(len(str(a))<len(str(b))):
        s=list(str(a))
        s.sort(reverse=True)
        print("""".join(s))
    else:
        x=[0]*10
        for i in str(a):
            x[int(i)]+=1
        b=str(b)
        i=0
        global ans
        ans=[0]*len(b)
        permute(b,x,0)
        print("""".join(ans))

if __name__ ==""__main__"":

    solve()
",O(n ^ 3)
"class Solution(object):
    def isBoomerang(self, points):
        return (points[0][0] - points[1][0]) * (points[0][1] - points[2][1]) - \
               (points[0][0] - points[2][0]) * (points[0][1] - points[1][1]) != 0",O(1)
"class BIT(object): 
    def __init__(self, n):
        self.__bit = [0] * n

    def add(self, i, val):
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def sum(self, i):
        result = 0
        while i > 0:
            result += self.__bit[i]
            i -= (i & -i)
        return result


class Solution(object):
    def processQueries(self, queries, m):
        bit = BIT(2*m+1)
        lookup = {}
        for i in range(1, m+1):
            bit.add(m+i, 1)
            lookup[i] = m+i
        result, curr = [], m
        for q in queries:
            i = lookup.pop(q)
            result.append(bit.sum(i-1))
            bit.add(i, -1)
            lookup[q] = curr
            bit.add(curr, 1)
            curr -= 1
        return result",O(nlogn)
"class Solution(object):
    def mergeTrees(self, t1, t2):
        if t1 is None:
            return t2
        if t2 is None:
            return t1
        t1.val += t2.val
        t1.left = self.mergeTrees(t1.left, t2.left)
        t1.right = self.mergeTrees(t1.right, t2.right)
        return t1",O(n)
"import math

def c(k, n):
    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))

def main():
    sent = input()
    received = input()
    difference = abs((sent.count('+') - sent.count('-')) - (received.count('+') - received.count('-')))
    unrecognized = received.count('?')
    if difference > unrecognized:
        print(0)
        return

    k = (unrecognized - difference) // 2
    answer = c(k, unrecognized) * 0.5**unrecognized
    print(answer)

if __name__ == '__main__':
    main()
",np
"class Solution2(object):
    def countCompleteDayPairs(self, hours):
        return sum((hours[i]+hours[j])%24 == 0 for i in range(len(hours)-1) for j in range(i+1, len(hours)))",O(n ^ 2)
"class Solution(object):
    def largestMultipleOfThree(self, digits):
        lookup = {0: [],
                  1: [(1,), (4,), (7,), (2, 2), (5, 2), (5, 5), (8, 2), (8, 5), (8, 8)],
                  2: [(2,), (5,), (8,), (1, 1), (4, 1), (4, 4), (7, 1), (7, 4), (7, 7)]}
        count = collections.Counter(digits)
        for deletes in lookup[sum(digits)%3]:
            delete_count = collections.Counter(deletes)
            if all(count[k] >= v for k, v in delete_count.items()):
                for k, v in delete_count.items():
                    count[k] -= v
                break
        result = """".join(str(d)*count[d] for d in reversed(range(10)))
        return ""0"" if result and result[0] == '0' else result",O(n)
"from collections import Counter

class Solution(object):
    def originalDigits(self, s):
        cnts = [Counter(_) for _ in [""zero"", ""one"", ""two"", ""three"", \
                                     ""four"", ""five"", ""six"", ""seven"", \
                                     ""eight"", ""nine""]]

        order = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]

        unique_chars = ['z', 'o', 'w', 't', 'u', \
                        'f', 'x', 's', 'g', 'n']

        cnt = Counter(list(s))
        res = []
        for i in order:
            while cnt[unique_chars[i]] > 0:
                cnt -= cnts[i]
                res.append(i)
        res.sort()

        return """".join(map(str, res))",O(n)
"import math
a,b=map(int,input().split())
c=[]
e=[]
f=0
for i in range(a):
    d=str(input())
    for j in range(b):
        if d[j]==""B"":
            c=c+[i]
            e=e+[j]
p=min(c)
p1=min(e)
p2=max(c)
plus=(max(c)-min(c))//2
p3=p+plus+1
p4=p1+plus+1
print(p3,p4)
",O(n ^ 2)
"class Solution(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def iter_dfs():
            lookup = [False]*len(circles)
            stk = []
            dst = [False]*len(circles)
            for u in range(len(circles)):
                x, y, r = circles[u]
                if x-r <= 0 or y+r >= Y:
                    lookup[u] = True
                    stk.append(u)
                if x+r >= X or y-r <= 0:
                    dst[u] = True
            while stk:
                u = stk.pop()
                if dst[u]:
                    return True
                x1, y1, r1 = circles[u]
                for v in range(len(circles)):
                    x2, y2, r2 = circles[v]
                    if lookup[v] or not check(x1, y1, r1, x2, y2, r2):
                        continue
                    lookup[v] = True
                    stk.append(v)
            return False

        return not iter_dfs()",O(n ^ 2)
"import math
from collections import defaultdict
ml=lambda:map(int,input().split())
ll=lambda:list(map(int,input().split()))
ii=lambda:int(input())
ip=lambda:list(input())

n,k=ml()
ans=0;
for i in range(1,1000001):
    val=(i*(i+1))//2
    if(val-(n-i)==k):
        ans=n-i
print(ans)",O(logn)
"import sys
from random import *
from bisect import *

pl=1
from math import gcd,sqrt
from copy import *
sys.setrecursionlimit(10**5)
if pl:
	input=sys.stdin.readline
else:
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('outpt.txt','w')

def li():
	return [int(xxx) for xxx in input().split()]
def fi():
	return int(input())
def si():
	return list(input().rstrip())
def mi():
	return 	map(int,input().split())

t=1

while t>0:
	t-=1
	n=fi()
	mod=10**9+7
	dp=[[0 for i in range(n+5)] for j in range(n+5)]
	prev=""-1""

	for i in range(n):
		p=input().rstrip()
		if i==0:
			dp[i][0]=1
		else:

			c=0
			if prev=='f':
				for j in range(n):
					dp[i][j+1]=dp[i-1][j]
			else:
				for j in range(n,-1,-1):
					c=(c+dp[i-1][j])%mod
					dp[i][j]=c

		prev=p

	print(sum(dp[n-1])%mod)
",O(n ^ 2)
"import sys
input=sys.stdin.readline
class Bit:
    def __init__(self, n):
        self.size = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= i & -i
        return s

    def add(self, i, x):
        while i <= self.size:
            self.tree[i] += x
            i += i & -i
n=int(input())
a=list(map(int,input().split()))
bi=Bit(n+1)
c=0
for i,x in enumerate(a):
    bi.add(x,1)
    c+=i+1-bi.sum(x)
if c%2==n%2:
    print(""Petr"")
else:
    print(""Um_nik"")",O(nlogn)
"import collections


class Solution(object):
    def smallestSubsequence(self, text):
        count = collections.Counter(text)

        lookup, stk = set(), []
        for c in text:
            if c not in lookup:
                while stk and stk[-1] > c and count[stk[-1]]:
                    lookup.remove(stk.pop())
                stk += c
                lookup.add(c)
            count[c] -= 1
        return """".join(stk)",O(n)
"def get_kth_digit(i):
    if i < 10:
        return i

    batch = 9
    count = 9
    width = 1

    while i >  10 * batch * (width + 1) + count:
        batch *= 10
        width += 1
        count += batch * width

    k = i - count - 1
    num = 10 ** width + k// (width + 1)
    return str(num)[k % (width + 1)]

def main():
    i = int(input())

    print(get_kth_digit(i))

if __name__ == '__main__':
    main()",O(logn)
"import math,io,os,sys

n,s=map(int,input().split())
c=0
i=n
for i in range(s,min(s+1000,n+1)):
    if i-sum(map(int,str(i)))>=s:
        c+=1
c+=max(0,n-i)
print(c)
",O(logn)
"import re

inputs = int(input())

for x in range(inputs):
    coordinates = input()
    match = re.match(""R(\d+)C(\d+)"", coordinates)
    if match:
        rows = int(match.group(1))
        columns = int(match.group(2))

        output = """"
        i = 0
        while columns > 0:
            alpha_index = (columns // (26 ** i) - 1) % 26
            output = chr(65 + alpha_index) + output

            columns -= (alpha_index + 1) * (26 ** i)
            i += 1
        output += str(rows)
        print(output)
    else:
        match = re.match(""(\D+)(\d+)"", coordinates)
        letters = match.group(1)
        rows = match.group(2)
        columns = 0
        for i in range(len(letters), 0, -1):
            columns += (ord(letters[i - 1]) - 64) * (26 ** (len(letters) - i))
        output = f""R{rows}C{columns}""
        print(output)
",O(n)
"import itertools
import operator


class Solution(object):
    def minProductSum(self, nums1, nums2):
        def inner_product(vec1, vec2):
            return sum(map(operator.mul, vec1, vec2))


        nums1.sort()
        nums2.sort(reverse=True)
        return inner_product(nums1, nums2)",O(nlogn)
"l, r = list(map(int, input().strip().split()))

if l == r:
    print(0)
    exit()

l, r = bin(l)[2:].zfill(64), bin(r)[2:].zfill(64)
i = 0
while i < len(r):
    if l[i] == r[i]:
        i += 1
    else:
        break
rslt = len(r[:i])*'0' + len(r[i:])*'1'
print(int(rslt, 2))
",O(logn)
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
MAP=[list(input().strip()) for i in range(n)]

T0=[[0]*(m+1) for i in range(n+1)]
T1=[[0]*(m+1) for i in range(n+1)]
Y0=[[0]*(m+1) for i in range(n+1)]
Y1=[[0]*(m+1) for i in range(n+1)]

for i in range(n):
    for j in range(m):
        if MAP[i][j]==""*"":
            T0[i][j]=T0[i-1][j]+1
            Y0[i][j]=Y0[i][j-1]+1

for i in range(n-1,-1,-1):
    for j in range(m-1,-1,-1):
        if MAP[i][j]==""*"":
            T1[i][j]=T1[i+1][j]+1
            Y1[i][j]=Y1[i][j+1]+1

ANS=[[0]*m for i in range(n)]

for i in range(n):
    for j in range(m):
        score=min(T0[i][j],T1[i][j],Y0[i][j],Y1[i][j])
        if score>=2:
            ANS[i][j]=score

T0=[[0]*(m+1) for i in range(n+1)]
T1=[[0]*(m+1) for i in range(n+1)]
Y0=[[0]*(m+1) for i in range(n+1)]
Y1=[[0]*(m+1) for i in range(n+1)]

for i in range(n):
    for j in range(m):
        T0[i][j]=max(ANS[i][j],T0[i-1][j]-1)
        Y0[i][j]=max(ANS[i][j],Y0[i][j-1]-1)

for i in range(n-1,-1,-1):
    for j in range(m-1,-1,-1):
        T1[i][j]=max(ANS[i][j],T1[i+1][j]-1)
        Y1[i][j]=max(ANS[i][j],Y1[i][j+1]-1)

SUF=[["".""]*m for i in range(n)]
for i in range(n):
    for j in range(m):
        if T0[i][j] or T1[i][j] or Y0[i][j] or Y1[i][j]:
            SUF[i][j]=""*""

if SUF!=MAP:
    print(-1)
else:
    ANSLIST=[]
    for i in range(n):
        for j in range(m):
            if ANS[i][j]!=0:
                ANSLIST.append((i+1,j+1,ANS[i][j]-1))

    print(len(ANSLIST))
    for ans in ANSLIST:
        print(*ans)
",O(n ^ 2)
"from math import floor
from sys import stdin

CONST = 9

def solve(k):
    i = 0
    while k > CONST * (10 ** i) * (i + 1):
        k -= floor(CONST * (10 ** i)) * (i + 1)
        i += 1
    num_digits = i + 1
    num = floor((k - 1) / num_digits)
    num += floor(10 ** (i))
    print(('{}'.format(num))[(k - 1) % num_digits])

if __name__ == '__main__':
    for line in stdin:
        solve(int(line.rstrip()))",O(logn)
"import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

dp = [[-1]*(N+1) for _ in range(N+1)]
for l in range(N):
    dp[l][l+1] = A[l]

for d in range(2, N+1):
    for l in range(N-d+1):
        for t in range(1, d):
            if dp[l][l+t] == dp[l+t][l+d] and dp[l][l+t] != -1:
                dp[l][l+d] = dp[l][l+t] + 1
                break

dp2 = [i for i in range(N+1)]
for r in range(1,N+1):
    if dp[0][r] != -1:
        dp2[r] = 1
for l in range(N):
    for r in range(l+2, N+1):
        if dp[l+1][r] != -1:
            dp2[r] = min(dp2[l+1]+1, dp2[r])
        else:
            dp2[r] = min(dp2[l+1]+(r-l-1), dp2[r])

print(dp2[N])",O(n ^ 3)
"import sys, os

if os.environ['USERNAME']=='kissz':
    inp=open('in.txt','r').readline
    def debug(*args):
        print(*args,file=sys.stderr)
else:
    inp=sys.stdin.readline
    def debug(*args):
        pass

n,m,k=map(int,inp().split())
A=[[*map(int,inp().split())] for _ in range(n)]
B=[[*map(int,inp().split())] for _ in range(n-1)]
if k%2==0:
    O=[[[1e12]*m for _ in range(n)] for _ in range(k//2)]
    for i in range(n):
        for j in range(m):
            if i>0:
                O[0][i][j]=min(O[0][i][j],B[i-1][j])
            if i<n-1:
                O[0][i][j]=min(O[0][i][j],B[i][j])
            if j>0:
                O[0][i][j]=min(O[0][i][j],A[i][j-1])
            if j<m-1:
                O[0][i][j]=min(O[0][i][j],A[i][j])

    for l in range(1,k//2):
        for i in range(n):
            for j in range(m):
                if i>0:
                    O[l][i][j]=min(O[l][i][j],B[i-1][j]+O[l-1][i-1][j])
                if i<n-1:
                    O[l][i][j]=min(O[l][i][j],B[i][j]+O[l-1][i+1][j])
                if j>0:
                    O[l][i][j]=min(O[l][i][j],A[i][j-1]+O[l-1][i][j-1])
                if j<m-1:
                    O[l][i][j]=min(O[l][i][j],A[i][j]+O[l-1][i][j+1])

    for i in range(n):
        print(*[O[-1][i][j]*2 for j in range(m)])
else:
    for i in range(n):
        print(*[-1]*m)
",O(n ^ 3)
"from sys import stdin, stdout, exit

n = int(input())
a = list(map(int, stdin.readline().split()))

def z(winner):
    return 'sjfnb' if winner == 0 else 'cslnb'

a.sort()
dups = set(a)
if len(dups) < len(a) - 1:
    print(z(1))
    exit()

winner = 0
for i in range(n-1):
    if a[i] == a[i+1]:
        if a[i] == 0 or a[i]-1 in a:
            print(z(1))
            exit()
        winner = 1
        a[i] = a[i] - 1

s = sum(a)
final = n*(n-1) // 2
winner += (s - final) + 1
winner %= 2
print(z(winner))
",O(nlogn)
"import math
import random
import heapq,bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict
threading.stack_size(10**8)
mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase
sys.setrecursionlimit(300000)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1

class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):

        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n

class SegmentTree1:
    def __init__(self, data, default=2**51, func=lambda a, b: a & b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a,b:max(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

for ik in range(1):
    n,k=map(int,input().split())
    cards=list(map(int,input().split()))
    l=list(map(int,input().split()))
    h=list(map(int,input().split()))
    h=[0]+h
    count=defaultdict(int)
    rt=defaultdict(int)
    def find(x,y):
        dp=[[0 for i in range(y+1)]for i in range(x+1)]
        for i in range(1,x+1):
            for j in range(y+1):
                for t in range(min(j+1,k+1)):
                    dp[i][j]=max(dp[i][j],dp[i-1][j-t]+h[t])
        return dp[x][y]
    for i in range(n*k):
        count[cards[i]]+=1
    for i in range(n):
        rt[l[i]]+=1
    ans=0
    for i in rt:
        if count[i]==0:
            continue
        ans+=find(rt[i],count[i])
    print(ans)",O(n ^ 3)
"import itertools



class Solution(object):
    def minCost(self, nums, cost):
        def f(x):
            return sum(abs(y-x)*c for y, c in zip(nums, cost))

        def check(x, t):
            return sum(c for y, c in zip(nums, cost) if y <= x) >= t
    
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        left, right = 0, len(idxs)-1
        total = sum(cost)
        median = (total+1)//2
        while left <= right:
            mid = left+(right-left)//2
            if check(nums[idxs[mid]], median):
                right = mid-1
            else:
                left = mid+1
        return f(nums[idxs[left]])",O(nlogn)
"input()
c = list(map(int, input().split()))
a = list(map(int, input().split()))

u = [0] * len(a)

ans = 0

for i in range(len(a)):
    if u[i] != 0:
        continue
    idx = i
    while u[idx] == 0:
        u[idx] = 1
        idx = a[idx] - 1

    if (u[idx] == 2):
        idx = i
        while u[idx] == 1:
            u[idx] = 2
            idx = a[idx] - 1
        continue

    start = idx
    mn = c[idx]
    u[idx] = 2
    while a[idx] - 1 != start:
        idx = a[idx] - 1
        mn = min(mn, c[idx])
        u[idx] = 2

    idx = i
    while u[idx] == 1:
        u[idx] = 2
        idx = a[idx] - 1
    ans += mn
print(ans)
",O(n)
"class Solution3(object):
    def lengthOfLIS(self, nums):
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [default]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret
    
        lookup = {x:i for i, x in enumerate(sorted(set(nums)))}
        bit = BIT(len(lookup), fn=max)
        for x in nums:
            bit.update(lookup[x], bit.query(lookup[x]-1)+1)
        return bit.query(len(lookup)-1)



class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y), 
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h) 
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"def size_of_group(i):
    return long(9 * 10**(i - 1)) * i

def find_group(k, i = 1):
    diff = long(k - (size_of_group(i)))
    if diff <= 0:
        return k, i
    return find_group(diff, i + 1)

def get_number(k, g):
    return str(long(10**(g - 1)) + k / g)[k % g]

def get_sequence_number(num):

    k_prim, g_prim = find_group(num)
    return get_number(k_prim - 1, g_prim)

if __name__ == ""__main__"":
    print(get_sequence_number(long(input())))",O(logn)
"import sys
input=sys.stdin.readline
n,k=map(int,input().split())
theorems=list(map(int,input().split()))
sleep=list(map(int,input().split()))
tsum=[]
ts=0
sleepsum=[]
slsum=0
for i in range(n):
    ts+=theorems[i]
    tsum.append(ts)
    if(sleep[i]==1):
        slsum+=theorems[i]
    sleepsum.append(slsum)

maxdiff=0

maxdiff=tsum[k-1]-sleepsum[k-1]
for i in range(1,n-k+1):
    diff=(tsum[i+k-1]-tsum[i-1])-(sleepsum[i+k-1]-sleepsum[i-1])

    maxdiff=max(maxdiff,diff)

print(slsum+maxdiff)",O(n)
"class Solution(object):
    def minOperations(self, nums):
        return sum(nums[i] != nums[i+1] for i in range(len(nums)-1))",O(n)
"MOD = 1000000007
def modpow(x, p):

    result = 1
    while p > 0:

        if p % 2 == 1:
            result = (result * x) % MOD

        p = p // 2

        x = (x * x) % MOD

    return result

n, k = map(int, input().split())
k+=1
if n == 0:
	print(0)
else:

	ans =  (((modpow(2, k))*(n%MOD))%MOD-(modpow(2, k-1)-1)%MOD)%MOD
	print(ans)",O(logn)
"import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

class Node:
    val = None

    def __init__(self, val):
        self.val = val
        self.left = Node
        self.right = None

def solve(W, H, N, A):
    xs = [0] + [v for t, v in A if t == 0] + [W]
    ys = [0] + [v for t, v in A if t == 1] + [H]
    xs.sort()
    ys.sort()

    xlist = Node(0)
    h = xlist
    xnodes = {0: h}
    maxw = max([xs[i+1] - xs[i] for i in range(len(xs)-1)] or [0])
    maxh = max([ys[i+1] - ys[i] for i in range(len(ys)-1)] or [0])
    for v in xs[1:]:
        n = Node(v)
        xnodes[v] = n
        h.right = n
        n.left = h
        h = n

    ylist =  Node(0)
    h = ylist
    ynodes = {0: h}
    for v in ys[1:]:
        n = Node(v)
        ynodes[v] = n
        h.right = n
        n.left = h
        h = n

    ans = []
    maxarea = maxh * maxw
    for t, v in reversed(A):
        ans.append(maxarea)
        if t == 0:
            node = xnodes[v]
            w = node.right.val - node.left.val
            maxw = max(maxw, w)
        else:
            node = ynodes[v]
            h = node.right.val - node.left.val
            maxh = max(maxh, h)
        node.left.right = node.right
        node.right.left = node.left
        maxarea = maxh * maxw

    return ans[::-1]

def solve2(W, H, N, A):
    ws = [(-W, 0, W)]
    hs = [(-H, 0, H)]
    iw, ih = set(), set()
    ans = []

    xs, ys = [0, W], [0, H]
    for t, v in A:
        if t == 0:
            bisect.insort_left(xs, v)
            i = bisect.bisect_left(xs, v)
            l, m, r = xs[i-1], xs[i], xs[i+1]
            iw.add((l-r, l, r))
            heapq.heappush(ws, (l - m, l, m))
            heapq.heappush(ws, (m - r, m, r))
            while ws[0] in iw:
                heapq.heappop(ws)
        else:
            bisect.insort(ys, v)
            i = bisect.bisect_left(ys, v)
            l, m, r = ys[i-1], ys[i], ys[i+1]
            ih.add((l-r, l, r))
            heapq.heappush(hs, (l - m, l, m))
            heapq.heappush(hs, (m - r, m, r))
            while hs[0] in ih:
                heapq.heappop(hs)
        w, h = ws[0], hs[0]
        ans.append(w[0] * h[0])

    return ans

W, H, N = map(int,input().split())
A = []
for i in range(N):
    a, b = input().split()
    c = 0 if a == 'V' else 1
    A.append((c, int(b)))

print('\n'.join(map(str, solve(W, H, N, A))))",O(nlogn)
"xs,ys = map(float,input().split())

n = int(input())

dist = [[0]*(n+1) for i in range(n+1)]
dist2 = [[0]*(n) for i in range(n)]

objects = [list(map(float,input().split())) for i in range(n)] + [[xs,ys]]

for i in range(n+1):
    for j in range(n+1):
        dist[i][j] = (objects[i][0] - objects[j][0])**2 + (objects[i][1] - objects[j][1])**2

for i in range(n):
    for j in range(n):
        dist2[i][j] = dist[n][i] + dist[i][j] + dist[j][n]

dp = [1e6]*(1<<n)
vis = set([0])
dp[0] = 0

for i in range((1<<n)-1):
    if i in vis:

        for j in range(n):
            if i&(1<<j) == 0:

                newi = i + (1 << j)
                dp[newi] = min(dp[newi], dp[i] + 2*dist[n][j])
                vis.add(newi)

                for k in range(j+1,n):

                    if i&(1<<k) == 0:
                        newi |= 1<<k
                        dp[newi] = min(dp[newi], dp[i] + dist2[j][k])
                        vis.add(newi)
                        newi ^= 1<<k

                break

curr = (1<<n) - 1
path = [0]
while curr:
    for i in range(n):
        if curr & (1<<i):

            if dp[curr] == dp[curr - (1<<i)] + 2*dist[n][i]:
                path.extend([i+1,0])
                curr ^= (1<<i)

            for j in range(i+1,n):
                if curr & (1<<j):
                    if dp[curr] == dp[curr - (1<<i) - (1<<j)] + dist2[i][j]:
                        path.extend([j+1,i+1,0])
                        curr ^= (1<<i) + (1<<j)

print(int(dp[(1<<n)-1]))
print(*path[::-1])",np
"class Solution(object):
    def grayCode(self, n):
        result = [0]
        for i in range(n):
            for n in reversed(result):
                result.append(1 << i | n)
        return result",O(2 ^ n)
"n,m=[int(x) for x in input().split()]
s=[]
for i in range(n):
    s.append(input())
mapp=[[False]*m for i in range(n)]

rnd=((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1))

def gene(x,y,p):
    cx=x-rnd[p][0]
    cy=y-rnd[p][1]
    ans=[]
    for i in range(8):
        ans.append((cx+rnd[i][0],cy+rnd[i][1]))
    return ans
def judge(ps):
    for x,y in ps:
        if x>=0 and x<n and y>=0 and y<m and s[x][y]=='
            continue
        else:
            return False
    return True
def dye(ps):
    global mapp
    for x,y in ps:
        mapp[x][y]=True
def check(x,y):
    for i in range(8):
        r=gene(x,y,i)
        if judge(r):
            dye(r)
            return True
    return False
for i in range(n):
    for j in range(m):
        if s[i][j]=='
            if check(i,j):
                continue
            else:
                print('NO')
                quit()
print('YES')",O(n ^ 2)
"s = input()
while s!="""":
	if s==s[::-1]:
		s=s[:(len(s)-1)]
	else:
		break
print(len(s))",O(n)
"class Solution(object):
    def countElements(self, arr):
        arr.sort()
        result, l = 0, 1
        for i in range(len(arr)-1):
            if arr[i] == arr[i+1]:
                l += 1
                continue
            if arr[i]+1 == arr[i+1]:
                result += l
            l = 1
        return result",O(nlogn)
"class Solution(object):
    def houseOfCards(self, n):
        dp = [0]*(n+1) 
        dp[0] = 1
        for t in range(1, (n+1)//3+1):
            for i in reversed(range(3*t-1, n+1)):
                dp[i] += dp[i-(3*t-1)]
        return dp[n]",O(n ^ 2)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, K = getIntList()

r=  K//N
if K%N!=0: r+=1

print(r)
",O(1)
"from sys import stdin, setrecursionlimit
from bisect import bisect_right

setrecursionlimit(15000)

def get_gdict(arr):
	gdict = dict()
	for i in range(len(arr)):
		if arr[i] in gdict:
			gdict[arr[i]] += 1
		else:
			gdict[arr[i]] = 1
	return gdict

def initial_check(barr, garr):
	for i in garr:
		if i < barr[-1]:
			return False
	return True

n, m = list(map(int, stdin.readline().split()))
barr = list(map(int, stdin.readline().split()))
garr = list(map(int, stdin.readline().split()))
barr.sort()
garr.sort()
ans = 0
gdict = get_gdict(garr)
if initial_check(barr, garr):
	count  = m
	b = n - 1
	g = m - 1
	while count  > 0:
		tempb = [barr[b]] * (m)

		for i in range(len(tempb)):
			if count <= 0:
				for j in range(i, m):
					ans += tempb[b]
				break

			if tempb[i] in gdict:
				gdict[tempb[i]] -= 1
				ans += (tempb[i])
				count -= 1
				if gdict[tempb[i]] == 0:
					del gdict[tempb[i]]
			else:
				if i == 0:
					ans += (tempb[i])
					continue
				for k in range(g, -1, -1):
					if garr[k] in gdict:
						ans += garr[g]
						g = k - 1
						count -= 1
						break

		b -= 1

	while b >= 0:
		ans += m * (barr[b])
		b -= 1
	print(ans)

else:
	print(-1)",O(n ^ 3)
"n, k = map(int,input().split())

start = 0
cnt = n
cur = 1

while start <= k:
    start += cur
    cnt -= 1
    cur += 1

ans = 0

if start != k:
    while cnt > 0:
        if start == k:
            start += cur
            cur += 1
            cnt -= 1
        ans += (start - k)
        cnt -= (start - k)
        start = k

print(ans)
",O(logn)
"import math

a=input()
b=input()
x1=a.count('+')
y1=a.count('-')
x2=b.count('+')
y2=b.count('-')
l=b.count('?')
if l==0 and(x1==x2 and y1==y2):
	print(float(1))
elif x1>(x2+l) or y1>(y2+l):
	print(float(0))
else:
	w=math.factorial(l)
	m=math.factorial(x1-x2)
	n=math.factorial(l-(x1-x2))
	print((w/(m*n)) /2**(x1+y1-x2-y2))
",np
"x,y=map(int,input().strip().split())
if(abs(x-y)<2):
    print(-1)
else:
    k=[]
    for i in range(x,y+1):
        if(i%2==0):
            k.append(i)
            if(i+1<y):
                k.append(i+1)
                k.append(i+2)
                break
    if(len(k)==3):
        print("" "".join(str(t) for t in k))
    else:
        print(-1)",O(1)
"import math

s1 = input()
s2 = input()

plus, minus = s1.count('+'), s1.count('-')

pre_plus = s2.count('+'); pre_minus = s2.count('-')

req_plus, req_minus = plus- pre_plus, minus - pre_minus

if req_minus < 0 or req_plus < 0:
	print('%.12f'%0)
else:
	unknowns = len(s1) - (pre_minus + pre_plus)

	if unknowns == 0:
		print('%.12f'%1)
	else:
		den = pow(2, unknowns)
		num = math.factorial(unknowns)/(math.factorial(req_plus)*math.factorial(req_minus))
		ans = num/den
		print('%.12f'%ans)",np
"class Solution(object):
    def minSwaps(self, data):
        total_count = sum(data)
        result, count, left = 0, 0, 0
        for i in range(len(data)):
            count += data[i]
            if i-left+1 > total_count: 
                count -= data[left]
                left += 1
            result = max(result, count)
        return total_count-result",O(n)
"q = int(input())
for t in range(q):
    n, k = map(int, input().split())
    rgb = input()
    dp = [0] * 3
    dp[0] = [0] * (n + 1)
    dp[1] = [0] * (n + 1)
    dp[2] = [0] * (n + 1)
    for i in range(0, n):
        if rgb[i] == 'R':
            dp[0][i + 1] = dp[2][i]
            dp[1][i + 1] = dp[0][i] + 1
            dp[2][i + 1] = dp[1][i] + 1
        if rgb[i] == 'G':
            dp[0][i + 1] = dp[2][i] + 1
            dp[1][i + 1] = dp[0][i]
            dp[2][i + 1] = dp[1][i] + 1
        if rgb[i] == 'B':
            dp[0][i + 1] = dp[2][i] + 1
            dp[1][i + 1] = dp[0][i] + 1
            dp[2][i + 1] = dp[1][i]
    repl = k
    dif = k % 3
    for j in range(3):
        for i in range(1, n - k + 2):
            repl = min(repl, -dp[j][i - 1] + dp[(j + dif) % 3][i + k - 1])
    print(repl)
",O(n)
"s=input()
for i in range(len(s),0,-1):
    if s[:i]!=s[i-1::-1]:
        print(i)
        break
else:
    print(0)
",O(n)
"import math
k = int(input())

def cnt_digit_order(X):
    res = 0
    if X == 0:
        return 0
    for i in range(1, X+1):
        res += i*(9*pow(10, i-1))
    return res

L = -1
leftcnt = 0
for length in range(1, 100):
    if cnt_digit_order(length - 1) < k <= cnt_digit_order(length):
        L = length
        leftcnt = k - cnt_digit_order(length - 1)
        break

M = str(math.ceil(leftcnt/L) + (10**(L-1) - 1))
leftcnt -= 1
leftcnt %= L
print(M[leftcnt])
",O(logn)
"k = int(input())
if (k < 10):
    print(k)
    quit()
c=0
n=k
a = k
while (n > 0):
    c+=1
    sub = 10 ** c - 10 ** (c-1)
    a-=sub*c
    n = a / (c+1) + (10 ** c - 1)
    if (n+1 <= 10 ** (c+1)):
        if (int(n) == n):
            print(int(n%(10)))
            exit()
        else:
            print(str(int(n)+1)[round((n-int(n))*(c+1))-1])
            exit()
",O(logn)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

for _ in range(N):
    l,r = getIntList()
    n = (r-l+1)
    z = n//2
    if l%2==0:
        z*=-1
    if n%2==1:
        if r%2==0:
            z += r
        else:
            z-=r
    print(z)
",O(1)
"q = int(input())
for _ in range(q):
	l, r = map(int, input().split())
	sign = -1 if l % 2 else 1
	if (r-l) % 2:
		print(-sign*(r-l+1)//2)
	else:
		print(sign*(l+(r-l)//2))
",O(1)
"n,a,b=map(int,input().split())
alist=list(map(int,input().split()))
alist.sort(reverse=True)
p=alist[a-1]
q=alist[a]
print(p-q)",O(nlogn)
"class Solution2(object):
    def isReflected(self, points):
        if not points:
            return True
        points.sort()
        points[len(points)/2:] = sorted(points[len(points)/2:], \
                                        lambda x, y: y[1] - x[1] if x[0] == y[0] else \
                                                     x[0] - y[0])
        mid = points[0][0] + points[-1][0]
        left, right = 0, len(points) - 1
        while left <= right:
            if (mid != points[left][0] + points[right][0]) or \
               (points[left][0] != points[right][0] and \
                points[left][1] != points[right][1]):
                return False
            left += 1
            right -= 1
        return True",O(nlogn)
"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        q = deque()
        if root:
            q.append(root)

        level = 0
        while q:
            for i in range(len(q)):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            level += 1
        return level
",O(n)
"n, m = map(int, input().split())
a = [list(map(int, input())) for i in range(n)]

ignorable = [True] * n

for i in range(m):
    cnt = 0
    for j in range(n):
        cnt += a[j][i]
    if cnt == 1:
        for j in range(n):
            if a[j][i]:
                ignorable[j] = False

if any(ignorable):
    print('YES')
else:
    print('NO')
",O(n ^ 2)
"a,b,c,d,e,f=list(map(int,input().split()))
n,n2=1,a*b+c*d+e*f
while n**2<n2:
    n+=1
if n**2>n2:
    print(-1)
    exit()
l=sorted([[max(a,b),min(a,b),'A'],[max(c,d),min(d,c),'B'],[max(e,f),min(e,f),'C']])
if l[2][0]!=n:
    print(-1)
    exit(0)
v=str(n)+'\n'+(l[2][2]*n+'\n')*l[2][1]
if l[0][0]==n and l[1][0]==n:
    for i in range(2):
        v+=(l[i][2]*n+'\n')*l[i][1]
else:
    s=n-l[2][1]
    if s not in l[0] or s not in l[1]:
        print(-1)
        exit()
    if s!=l[0][0]:
        l[0][0],l[0][1]=l[0][1],l[0][0]
    if s!=l[1][0]:
        l[1][0],l[1][1]=l[1][1],l[1][0]
    v+=(l[0][2]*l[0][1]+l[1][2]*l[1][1]+'\n')*s
print(v)
",np
"class node:
    def __init__(self,l,r,u,d):
        self.u = u
        self.d = d
        self.l = l
        self.r = r
        if l == 20000001 and r ==20000001 and u == 20000001 and d == 20000001:
            self.marr = [20000001 for i in range(11)]
        else:
            self.marr = [0 for i in range(11)]
            self.marr[1] = min(l,r,u,d)
    def mo(self,st):
        return self.marr[st-1]

n,m,s = (int(i) for i in input().split())
hor = [[20000001 for i in range(m+3)] for j in range(n+2)]
ver = [[20000001 for i in range(m+2)] for j in range(n+3)]
for i in range(1,n+1):
    hor[i][2:1+m] = [int(i) for i in input().split()]
for i in range(2,1+n):
    ver[i][1:m+1] = [int(i) for i in input().split()]
if s%2 == 0 :
    nds = [[node(hor[i][j],hor[i][j+1],ver[i][j],ver[i+1][j]) for j in range(m+2)] for i in range(n+2)]
    for st in range(2,s//2+1):
        for i in range(1,n+1):
            for j in range(1,m+1):
                x = nds[i][j].marr[1]
                l = nds[i][j].l
                r = nds[i][j].r
                u = nds[i][j].u
                d = nds[i][j].d
                nds[i][j].marr[st] = min(x*st,r+nds[i][j+1].mo(st),l+nds[i][j-1].mo(st),u+nds[i-1][j].mo(st),d+nds[i+1][j].mo(st))
    ans = [[nds[i][j].marr[s//2]*2 for j in range(1,m+1)] for i in range(1,n+1)]
    for i in range(n):
        print(*tuple(ans[i]))
else :
    a = [[-1 for i in range(m)] for j in range(n)]
    for i in range(n):
        print(*tuple(a[i]))
",O(n ^ 3)
"import collections


class Solution(object):
    def numEquivDominoPairs(self, dominoes):
        counter = collections.Counter((min(x), max(x)) for x in dominoes)
        return sum(v*(v-1)//2 for v in counter.values())",O(n)
"import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from collections import Counter
from collections import defaultdict as dd

flush = lambda: stdout.flush()
stdstr = lambda: stdin.readline()
stdint = lambda: int(stdin.readline())
stdpr = lambda x: stdout.write(str(x))
stdmap = lambda: map(int, stdstr().split())
stdarr = lambda: list(map(int, stdstr().split()))

mod = 1000000007

def sieve(n):

    prime = [True for _ in range(n+1)]
    p = 2

    while(p*p <= n):
        if(prime[p] == True):

            for i in range(p*p, n+1, p):
                prime[i] = False

        p += 1

    return prime

n,k = stdmap()

all = sieve(n)

primes = []

for i in range(1, len(all)):
    if(all[i] == True):
        primes.append(i)

s = Counter(primes)

res = 0

for i in range(len(primes)-1):
    toCheck = primes[i]+primes[i+1]+1

    if(toCheck in s):
        res += 1

if(res >= k):
    print(""YES"")
else:
    print(""NO"")
",O(n)
"n = int(input())
dp = [1]
for IND in range(n):
    c = input()
    if c == ""f"":
        dp.insert(0,0)
    else:
        for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007
print(dp[0])
",O(n ^ 2)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

def main():
    n, k = RLL()
    dp = [[0]*4 for _ in range(k+2)]
    dp[1][0] = 1
    dp[1][3] = 1
    dp[2][1] = 1
    dp[2][2] = 1

    for i in range(2, n+1):
        new = [[0]*4 for _ in range(k+2)]
        for j in range(1, k+2):
            for l in range(4):
                new[j][l] += dp[j][l]
                if l==0 or l==3:
                    new[j][l]+=dp[j-1][l^3]
                    new[j][l]+=(dp[j][1]+dp[j][2])
                elif l==1 or l==2:
                    new[j][l]+=(dp[j-1][0]+dp[j-1][3])
                    if j-2>=0: new[j][l]+=dp[j-2][l^3]
                new[j][l] = new[j][l]%mod
        dp = new
    print(sum(dp[k])%mod)

if __name__ == ""__main__"":
    main()
",np
"class Solution:
    def countBits(self, n: int) -> List[int]:
        res = [0] * (n + 1)
        for i in range(1, n + 1):
            num = i
            while num != 0:
                res[i] += 1
                num &= (num - 1)
        return res
",O(n)
"n=int(input())
for i in range(n):
	a,b = map( int, input().split() )
	if a>b:
	    a,b=b,a
	ans=0
	while a>0:
		ans+=b//a
		b%=a
		a,b=b,a
	print(ans)",O(1)
"N=int(input())
L=list(map(int,input().split()))

DP=[[-1]*N for i in range(N)]
for d in range(N):
    for s in range(N-d):
        e=s+d
        if s==e:
            DP[s][e]=L[s]
            continue
        for m in range(s,e):
            l=DP[s][m]
            r=DP[m+1][e]
            if l==r and l!=-1:
                DP[s][e]=max(DP[s][e],l+1)
DP2=[i+1 for i in range(N)]
for i in range(N):
    if DP[0][i]!=-1:
        DP2[i]=1
        continue
    for j in range(i):
        if DP[j+1][i]!=-1:
            DP2[i]=min(DP2[i],DP2[j]+1)
print(DP2[N-1])",O(n ^ 3)
"class Solution_Recu(object):
    def minTime(self, n, edges, hasApple):
        def dfs(graph, par, node, hasApple):
            result, extra = 0, int(hasApple[node])
            for nei in graph[node]:
                if nei == par:
                    continue
                count, found = dfs(graph, node, nei, hasApple)
                result += count+found
                extra |= bool(count+found)
            return result, extra
        
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        return 2*dfs(graph, -1, 0, hasApple)[0]",O(n)
"class Solution(object):
    def maximumSwap(self, num):
        digits = list(str(num))
        left, right = 0, 0
        max_idx = len(digits)-1
        for i in reversed(range(len(digits))):
            if digits[i] > digits[max_idx]:
                max_idx = i
            elif digits[max_idx] > digits[i]:
                left, right = i, max_idx
        digits[left], digits[right] = digits[right], digits[left]
        return int("""".join(digits))",O(logn)
"import itertools
class Solution2(object):
    def smallestStringWithSwaps(self, s, pairs):
        def dfs(i, adj, lookup, component):
            lookup.add(i)
            component.append(i)
            for j in adj[i]:
                if j in lookup:
                    continue
                dfs(j, adj, lookup, component)
            
        adj = collections.defaultdict(list)
        for i, j in pairs:
            adj[i].append(j)
            adj[j].append(i)
        lookup = set()
        result = list(s)
        for i in range(len(s)):
            if i in lookup:
                continue
            component = []
            dfs(i, adj, lookup, component)
            component.sort()
            chars = sorted(result[k] for k in component)
            for comp, char in zip(component, chars):
                result[comp] = char
        return """".join(result)",O(nlogn)
"class Solution3(object):
    def maxIncreasingGroups(self, usageLimits):
        def check(l):
            curr = 0
            for i in range(l):
                curr += usageLimits[~i]-(l-i)
                curr = min(curr, 0)
            for i in range(len(usageLimits)-l):
                curr += usageLimits[i]
            return curr >= 0

        usageLimits.sort()
        left, right = 1, len(usageLimits)
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right",O(nlogn)
"class Solution2(object):
    def findBuildings(self, heights):
        result = []
        for i in reversed(range(len(heights))):
            if not result or heights[result[-1]] < heights[i]:
                result.append(i)
        result.reverse()
        return result",O(n)
"class Solution2(object):
    def countNumbersWithUniqueDigits(self, n):
        fact = [1]*2
        def nPr(n, k):
            while len(fact) <= n: 
                fact.append(fact[-1]*len(fact))
            return fact[n]//fact[n-k]

        return 1+9*sum(nPr(9, i) for i in range(n))",O(n)
"n=int(input())
arr=list(map(int,input().split()))
gap=n//2
count =0
while gap >=1:
    for j in range(gap ,n):
        i= j-gap
        while i >=0:
            if arr[i +gap] >arr[i]:
                break
            else:
                arr[i +gap],arr[i] =arr[i] ,arr[i +gap]
                count +=1
            i-=gap
    gap//=2
if count % 2== 3*n %2:
    print(""Petr"")
else:
    print(""Um_nik"")",O(nlogn)
"def solve(a: int, b: int) -> int:
    if a > b:
        a, b = b, a
    ba = bin(a)[2:]
    bb = bin(b)[2:]
    r = ''
    if len(ba) != len(bb):
        int('1' * len(bb), 2)
    else:
        for ca, cb in zip(ba, bb):
            if ca == cb:
                r += '0'
            else:
                r += '1'
                break
    r += '1' * (len(bb) - len(r))
    return int(r, 2)

a, b = map(int, input().split())
print(solve(a, b))
",O(logn)
"class Solution2(object):
    def reverseList(self, head):
        [begin, end] = self.reverseListRecu(head)
        return begin

    def reverseListRecu(self, head):
        if not head:
            return [None, None]

        [begin, end] = self.reverseListRecu(head.__next__)

        if end:
            end.next = head
            head.next = None
            return [begin, head]
        else:
            return [head, head]",O(n)
"class Solution(object):
    def outerTrees(self, points):
        points = sorted(set(tuple(x) for x in points))

        if len(points) <= 1:
            return points

        def cross(o, a, b):
            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

        lower = []
        for p in points:
            while len(lower) >= 2 and cross(lower[-2], lower[-1], p) < 0: 
                lower.pop()
            lower.append(p)

        upper = []
        for p in reversed(points):
            while len(upper) >= 2 and cross(upper[-2], upper[-1], p) < 0: 
                upper.pop()
            upper.append(p)

        result = lower[:-1] + upper[:-1]
        return result if result[1] != result[-1] else result[:len(result)//2+1]",O(nlogn)
"class Solution(object):
    def concatenatedBinary(self, n):
        MOD = 10**9+7
        result = l = 0
        for i in range(1, n+1):
            if i&(i-1) == 0:
                l += 1
            result = ((result<<l)%MOD+i)%MOD
        return result",O(n)
"a = list(input())
b = list(input())
n = len(a)
a.sort()

def listtostring(string):
    return ''.join([str(ele) for ele in string])

for i in range(0,n):
    for j in range(0,n):
        t = a.copy()
        t[i],t[j] = t[j],t[i]
        if((int(listtostring(t)) >= int(listtostring(a))) and (int(listtostring(t))<= int(listtostring(b)))):

            a[i],a[j] = a[j],a[i]

print(listtostring(a))",O(n ^ 3)
"from sys import exit

def bad():
    print(""NO"")
    exit()

node = 1
def make_branch(u, d, deg, g, n, k):
    global node
    while deg[u] < k and d > 0 and node < n:
        node += 1
        deg[u] += 1
        deg[node] = 1
        g[u].append(node)
        make_branch(node, d - 1, deg, g, n, k)

def main():
    global node
    n, d, k = map(int, input().split())
    if d >= n or (k == 1 and n > 2):
        bad()

    g = [[] for _ in range(n + 5)]
    deg = [0 for _ in range(n + 5)]

    for i in range(1, d + 1):
        g[i].append(i + 1)
        deg[i] += 1
        deg[i + 1] += 1

    node = d + 1

    LD = 1
    RD = d - 1
    for u in range(2, d + 1):
        make_branch(u, min(LD, RD), deg, g, n, k)
        LD += 1
        RD -= 1

    used = [False for _ in range(n + 5)]
    q = [[1, 1]]
    used[1] = True
    while len(q) > 0:
        u, p = q.pop()
        for v in g[u]:
            if v != p:
                used[v] = True
                q.append([v, u])

    for i in range(1, n + 1):
        if used[i] == False:
            bad()

    print(""YES"")
    for u in range(1, n + 1):
        for v in g[u]:
            print(u, v)

main()
",O(n ^ 2)
"x,k=map(int,input().split())
m=10**9+7
print((x*pow(2,k+1,m) -pow(2,k,m) +1) %(m)) if x >0 else print(0)",O(logn)
"n,k=map(int,input().split())
p=list(map(int,input().split()))

arr=[[] for i in range(256)]
ans=[]
for i in p:
    j=i
    if len(arr[i])==0:
        c=0
        while c<k and j>=0:
            if len(arr[j])+c>k:
                break

            if len(arr[j])!=0:
                arr[i].extend(arr[j])
                break
            arr[j]=arr[i]
            arr[j].append(j)
            j-=1
            c+=1
        arr[i].sort()
    ans.append(arr[i][0])
print(*ans)
",O(n ^ 2)
"s = input()

def check_x(mid):
    ans = 'no'
    d = {}
    for i in range(len(s)-mid+1):

        if s[i:i+mid] in d.keys():
            ans = 'yes'
            break
        d[s[i:i+mid]] = 1

    return ans

l = 0
r = len(s) - 1
while r-l > 1:
    mid = (r+l) // 2

    ans = check_x(mid)
    if ans == 'yes':
        l = mid
    else:
        r = mid

if check_x(r) == 'yes':
    print(r)
else:
    print(l)
",O(n ^ 3)
"import sys
def contain(a, b):
    ax1, ay1, ax2, ay2 = a
    bx1, by1, bx2, by2 = b
    return bx1 <= ax1 and ax2 <= bx2 and by1 <= ay1 and ay2 <= by2
def ask(x1, y1, x2, y2, known=(), memo={}):
    if x2 < x1+1 or y2 < y1+1:
        return 0
    ofs = len(list(filter(lambda rect: contain(rect, (x1, y1, x2, y2)), known)))
    key = (x1+1, y1+1, x2, y2)
    if key in memo:
        return memo[key] - ofs
    print('?', *key)
    sys.stdout.flush()
    memo[key] = int(input())
    return memo[key] - ofs
def binsearch(l, r, p):
    assert l < r
    while l+1 != r:
        m = (l + r) // 2
        if p(m):
            r = m
        else:
            l = m
    return r
def shrink(x1, y1, x2, y2, cnt, known=()):
    assert ask(x1, y1, x2, y2, known=known) == cnt
    x1 = binsearch(x1, x2, lambda x: ask(x, y1, x2, y2, known=known) != cnt) - 1
    y1 = binsearch(y1, y2, lambda y: ask(x1, y, x2, y2, known=known) != cnt) - 1
    x2 = binsearch(x1, x2, lambda x: ask(x1, y1, x, y2, known=known) == cnt)
    y2 = binsearch(y1, y2, lambda y: ask(x1, y1, x2, y, known=known) == cnt)
    assert ask(x1, y1, x2, y2, known=known) == cnt
    assert ask(x1, y1, x2, y2, known=known) == cnt
    return x1, y1, x2, y2
def go(x1, y1, x2, y2):
    assert ask(x1, y1, x2, y2) == 2
    x1, y1, x2, y2 = shrink(x1, y1, x2, y2, 2)
    a = None
    if not a and x1 < x2:
        if ask(x1+1, y1, x2, y2) == 1:
            a = shrink(x1+1, y1, x2, y2, 1)
        elif ask(x1, y1, x2-1, y2) == 1:
            a = shrink(x1, y1, x2-1, y2, 1)
    if not a and y1 < y2:
        if ask(x1, y1+1, x2, y2) == 1:
            a = shrink(x1, y1+1, x2, y2, 1)
        elif ask(x1, y1, x2, y2-1) == 1:
            a = shrink(x1, y1, x2, y2-1, 1)
    if not a:
        a = x1, y1, x2, y2
        return a, a
    else:
        b = shrink(x1, y1, x2, y2, 1, known=[ a ])
        return a, b
n = int(input())
a, b = go(0, 0, n, n)
ax1, ay1, ax2, ay2 = a
bx1, by1, bx2, by2 = b
print('!', ax1+1, ay1+1, ax2, ay2, bx1+1, by1+1, bx2, by2)
",O(logn)
"from sys import stdin,stdout
from math import ceil,log
def main():
	d={}
	n=int(stdin.readline())
	a=list(map(int,stdin.readline().split( )))
	m=-1;mm=10**10
	for v in a:
		if v not in d:
			d[v]=1
		else:
			d[v]+=1
		m=max(m,v)
		mm=min(mm,v)
	ans=0

	for v in a:

		exponent=ceil(log(v,2))
		power=2**exponent
		find=0
		while power-v>=0:
			if power-v>mm and power-v>m:
				break

			element=power-v
			if element in d and element==v and d[element]>1:
				find=1
				break
			elif element in d and element!=v:
				find=1
				break
			power=power*2
		if find==0:
			ans+=1
	stdout.write(""%d\n""%(ans))

main()",O(nlogn)
"n = int(input())
a = [int(i) for i in input().split()]
a.sort()
flag = 0
for i in range(n-1):
	if(a[i] == a[i+1]):
		if(flag == 1):
			flag = 2
			break
		flag = 1
		index = i
		if(i+2<n and a[i+1] == a[i+2]):
			flag = 2
			break
		elif(i>0 and a[i-1] == a[i]-1):
			flag = 2
			break
if(flag == 2):
	print(""cslnb"")
elif(flag ==1 and a[index] ==0):
	print(""cslnb"")
else:
	moves=0
	for i in range(n):
		if(a[i] == i):
			continue
		elif(a[i]<i):
			continue
		else:
			moves += (a[i] - i)
	if(moves%2 == 0):
		print(""cslnb"")
	else:
		print(""sjfnb"")",O(nlogn)
"def naiveSolve():

    return

class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

class OrderedList(SortedList):
    def __init__(self, arg):
        super().__init__(arg)
    def rangeCountByValue(self, leftVal, rightVal):
        leftCummulative = self.bisect_left(leftVal)
        rightCummulative = self.bisect_left(rightVal + 1)
        return rightCummulative - leftCummulative

from collections import Counter

def main():

    n=int(input())
    a=readIntArr()

    cnts=Counter(a)
    ol=OrderedList([v for v in cnts.values()])
    ol.add(0)
    canMakeFirstMove=False
    for x in a:
        if x>0:
            c=cnts[x]
            ol.remove(c)
            ol.add(c-1)
            d=cnts[x-1]
            ol.remove(d)
            ol.add(d+1)

            if ol[-1]==1:
                canMakeFirstMove=True
                break
            ol.add(c)
            ol.remove(c-1)
            ol.add(d)
            ol.remove(d+1)
    if canMakeFirstMove==False:
        print('cslnb')
    else:

        target=(n*(n-1))//2
        if (sum(a)-target)%2==0:
            print('cslnb')
        else:
            print('sjfnb')

    return

import sys

input=lambda: sys.stdin.readline().rstrip(""\r\n"")

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))

def readIntArr():
    return [int(x) for x in input().split()]

def makeArr(defaultValFactory,dimensionArr):
    dv=defaultValFactory;da=dimensionArr
    if len(da)==1:return [dv() for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]

def queryInteractive(l,r):
    print('? {} {}'.format(l,r))
    sys.stdout.flush()
    return int(input())

def answerInteractive(x):
    print('! {}'.format(x))
    sys.stdout.flush()

inf=float('inf')
MOD=10**9+7

from math import gcd,floor,ceil

for _abc in range(1):
    main()
",O(nlogn)
"from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop
import math
from collections import *
from functools import reduce,cmp_to_key,lru_cache
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
import sys

M = mod = 10 ** 9 + 7
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)

def li():return [int(i) for i in input().rstrip().split()]
def st():return str(input().rstrip())[2:-1]
def val():return int(input().rstrip())
def li2():return [str(i)[2:-1] for i in input().rstrip().split()]
def li3():return [int(i) for i in st()]

n = val()
l = li()
c = li()

element = l[0]
for i in range(1, n):element = math.gcd(element, l[i])

if element != 1:
    print(-1)
    exit()

myset = {}

for ind, i in enumerate(l):
    for j in list(myset):
        temp = math.gcd(j, i)
        if(temp not in myset):myset[temp] = myset[j] + c[ind]
        else:myset[temp] = min(myset[temp], c[ind] + myset[j])

    if i not in myset:myset[i] = c[ind]
    else:myset[i] = min(myset[i], c[ind])

print(myset[1])",np
"q = int(input())
for i in range(q):
    x, y, k = map(int, input().split())
    if x > y: x, y = y, x
    m = y
    d = y
    if (y - x) % 2 == 1:
        d -= 1
    if k < m:
        print(-1)
        continue
    r = k - m
    if r % 2 != 0:
        r -= 1
        if d != m:
            d += 1
        else:
            d -= 1
    d += r
    print(d)
",O(1)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def zigzagLevelOrder(self, root):
        if root is None:
            return []
        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            result.append(vals[::-1] if len(result) % 2 else vals)
            current = next_level
        return result",O(n)
"class Solution(object):
    def countArrangement(self, N):
        def countArrangementHelper(n, arr):
            if n <= 0:
                return 1
            count = 0
            for i in range(n):
                if arr[i] % n == 0 or n % arr[i] == 0:
                    arr[i], arr[n-1] = arr[n-1], arr[i]
                    count += countArrangementHelper(n - 1, arr)
                    arr[i], arr[n-1] = arr[n-1], arr[i]
            return count

        return countArrangementHelper(N, list(range(1, N+1)))",O(n!)
"import math
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

n,m=map(int,input().split())
l=[]
tot=[]
done=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    l.append(input())
colsum=[[0 for i in range(m)]for j in range(n)]
rowsum=[[0 for i in range(m)]for j in range(n)]
col=[[0 for i in range(m)]for j in range(n)]
row=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            rowsum[i][j]=1
            colsum[i][j]=1
            row[i][j]=1
            col[i][j]=1
for i in range(n):
    for j in range(1,m):
        if l[i][j]=='.':
            continue
        rowsum[i][j]+=rowsum[i][j-1]
for i in range(n):
    for j in range(m-2,-1,-1):
        if l[i][j]=='.':
            continue
        row[i][j]+=row[i][j+1]
for i in range(m):
    for j in range(n-2,-1,-1):
        if l[j][i]=='.':
            continue
        col[j][i]+=col[j+1][i]
for i in range(m):
    for j in range(1,n):
        if l[j][i]=='.':
            continue
        colsum[j][i]+=colsum[j-1][i]
def check(x,y):
    i=x
    j=y
    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1
    if ans==0:
        return []
    return [ans]
h=[[0 for i in range(m+1)]for j in range(n)]
v=[[0 for i in range(m)]for j in range(n+1)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            ans=check(i,j)
            for j1 in ans:
                tot.append([i+1,j+1,j1])
                h[i][j-j1]+=1
                h[i][j+j1+1]-=1
                v[i-j1][j]+=1
                v[i+j1+1][j]-=1
for i in range(n):
    for j in range(1,m):
        h[i][j]+=h[i][j-1]
for i in range(m):
    for j in range(1,n):
        v[j][i]+=v[j-1][i]

for i in range(n):
    for j in range(m):
        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:
            print(-1)
            sys.exit(0)
print(len(tot))
for i in tot:
    print(*i)
",O(n ^ 2)
"n, k = map(int, input().split())
c = 1
while c * (c + 1) // 2 < k:
    c += 1
while c * (c + 1) // 2 - (n - c) != k:
    c += 1
print(n - c)
",O(n)
"import re


class Solution(object):

    def __init__(self, compressedString):
        self.__result = re.findall(r""([a-zA-Z])(\d+)"", compressedString)
        self.__index, self.__num, self.__ch = 0, 0, ' '

    def __next__(self):
        if not self.hasNext():
            return ' '
        if self.__num == 0:
            self.__ch = self.__result[self.__index][0]
            self.__num = int(self.__result[self.__index][1])
            self.__index += 1
        self.__num -= 1
        return self.__ch


    def hasNext(self):
        return self.__index != len(self.__result) or self.__num != 0",O(1)
"N, MOD = map(int,input().split())

dp = []
comps = [0]*(N+1)

ncr = [[1]]
for i in range(420):
    tmp = [1]
    for j in range(i):
        tmp.append((ncr[i][j] + ncr[i][j+1]) % MOD)
    tmp.append(1)
    ncr.append(tmp)

for i in range(N):
    curr = list(comps)
    curr[1] = pow(2,i,MOD)
    for j in range(i - 1):
        m = pow(2,i - j - 2)
        for k in range(N):
            num = j - k + 2
            if num < 0: continue
            mr = (m * ncr[i - j - 1 + num][num]) % MOD
            curr[k + 1] += mr * dp[j][k]
            curr[k + 1] %= MOD
    dp.append(curr)

print(sum(dp[-1]) % MOD)",O(n ^ 3)
"def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np
"import itertools



class Solution2(object):
    def minOperations(self, nums1, nums2):
        INF = float(""inf"")
        def count(mx1, mx2):
            return sum(1 if y <= mx1 and x <= mx2 else INF for x, y in zip(nums1, nums2) if not (x <= mx1 and y <= mx2))

        result = min(count(nums1[-1], nums2[-1]), count(nums2[-1], nums1[-1]))
        return result if result != INF else -1",O(n)
"class Solution(object):
    def findCelebrity(self, n):
        candidate = 0
        for i in range(1, n):
            if knows(candidate, i): 
                candidate = i       
        for i in range(n):
            candidate_knows_i = knows(candidate, i)
            i_knows_candidate = knows(i, candidate)
            if i != candidate and (candidate_knows_i or
                                   not i_knows_candidate):
                return -1
        return candidate",O(n)
"n, q = map(int, raw_input().split())
l = raw_input()
cnt1, cnt0 = [0]*(n+1), [0]*(n+1)
mod = 10**9 + 7
for i in range(len(l)):
	if l[i] == '1':
		cnt1[i+1] = cnt1[i] + 1
		cnt0[i+1] = cnt0[i]
	else:
		cnt0[i+1] = cnt0[i] + 1
		cnt1[i+1] = cnt1[i]
pow2 = [1]
for i in range(1, 10**5 + 10):
	pow2.append((2*pow2[-1])%mod)
for i in range(q):
	l, r = map(int, raw_input().split())
	ones = cnt1[r] - cnt1[l-1]
	zeroes = cnt0[r] - cnt0[l-1]
	t1 = (pow2[ones] - 1)%mod
	t2 = (((pow2[ones] - 1)%mod)*(pow2[zeroes] - 1))%mod
	print((t1+t2)%mod)",O(n)
"def func():
    count = 0
    for i in range(1 << n):
        temp = []
        for j in range(n):
            if 1 << j & i:
                temp.append(c[j])

        if l <= sum(temp) <= r and temp[-1] - temp[0] >= x:
            count += 1
    print(count)

n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))
c.sort()
func()
",np
"def i_ints():
    return list(map(int, input().split()))

n, a, b = i_ints()
def calc():
    if min(a, b) != 1:
        print(""NO"")
        return
    if a == b == 1 and n in (2, 3):
        print(""NO"")
        return

    print(""YES"")
    ONE, ZERO = ""10"" if a > 1 else ""01""

    edges = n - max(a, b)
    line = ""0"" + (ZERO, ONE)[edges>0]*(n>1) + ZERO * (n-2)
    print(line)

    for y in range(1, n):
        line = ZERO * (y-1) + (ZERO, ONE)[y<=edges] + ""0""
        if y < n-1:
            line += (ZERO, ONE)[y < edges] + ZERO * (n-y-2)
        print(line)

calc()
",O(n ^ 2)
"n = int(input())
data = [int(i) for i in input().split()]
data.sort()
ans = [0]*n
col = 0
for i in range(n):
    if ans[i] == 0:
        col += 1
        ans[i] = 1
        d = data[i]
        for j in range(i+1, n):
            if data[j] % d == 0:
                ans[j] = 1
print(col)
",O(n ^ 2)
"def possible(arr):

    a,b,c,d,e,f = arr
    if(a == c == e and b + d + f == a):
        one = ""A"" * b + ""B"" * d + ""C"" * f
        print(a)
        for i in range(a):
            print(one)
        return True
    if(b == d == f and a + c + e == d):
        print(b)
        for i in range(a):
            print(""A"" * b)
        for i in range(c):
            print(""B"" * b)
        for i in range(e):
            print(""C"" * b)
        return True
    ns = [(a,b,""A""),(c,d,""B""),(e,f,""C"")]
    fs = [(b, a,""A""),(d, c,""B""),(f, e,""C"")]
    ns.sort(reverse = True)
    x,y,z = ns
    a,b,t1 = x
    c,d,t2 = y
    e,f,t3 = z
    if(c + e == a and d == f and d + b == a):
        print(a)
        mat = [[""."" for i in range(a)] for j in range(a)]
        for i in range(a):
            for j in range(b):
                mat[i][j] = t1
        for i in range(c):
            for j in range(b, a):
                mat[i][j] = t2
        for  i in range(c, a):
            for j in range(b, a):
                mat[i][j] = t3
        for i in range(a):
            print("""".join(mat[i]))
        return True

    fs.sort(reverse = True)
    x,y,z = fs
    b,a,t1 = x
    d,c,t2 = y
    f,e,t3 = z
    if(d + f == b and c == e and c + a == b):
        print(b)
        mat = [[""."" for i in range(b)] for j in range(b)]
        for i in range(a):
            for j in range(b):
                mat[i][j] =t1
        for i in range(a, b):
            for j in range(d):
                mat[i][j] = t2
        for i in range(a, b):
            for j in range(d, b):
                mat[i][j] = t3
        for i in range(b):
            print("""".join(mat[i]))
        return True
    return False

arr = [int(x) for x in input().split()]
cnt = 0
ok = False
for i in range(8):
    send = [x for x in arr]
    if(i&1):
        send[0], send[1] = send[1], send[0]
    if(i&2):
        send[2], send[3] = send[3], send[2]
    if(i&4):
        send[4], send[5] = send[5], send[4]
    if(possible(send)):
        ok = True
        break
if(not ok):
    print(-1)
",np
"class Solution(object):
    def isLongPressedName(self, name, typed):
        i = 0
        for j in range(len(typed)):
            if i < len(name) and name[i] == typed[j]:
                i += 1
            elif j == 0 or typed[j] != typed[j-1]:
                return False
        return i == len(name)",O(n)
"class Solution(object):
    def removeDuplicates(self, A):
        if not A:
            return 0

        last, i, same = 0, 1, False
        while i < len(A):
            if A[last] != A[i] or not same:
                same = A[last] == A[i]
                last += 1
                A[last] = A[i]
            i += 1

        return last + 1",O(n)
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:

        def dfs(i, j):
            if i == len(nums):
                return 0

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            return LIS

        return dfs(0, -1)
",O(2 ^ n)
"def go():
    n = int(input())
    x, y = [int(i) for i in input().split(' ')]
    a = 1 + 1
    b = n + n
    c = x + y
    distance_w = c - a
    distance_b = b - c
    if distance_w == distance_b:
        return 'White'
    if distance_w < distance_b:
        return 'White'
    return 'Black'

print(go())
",O(1)
"mod = 10**9+7
x, k = map(int, input().split(' '))
if (x == 0):
    print(0)
else:
    val1 = pow(2,k+1,mod) * x
    val2 = pow(2, k, mod) - 1
    val1 -= val2
    val1 %= mod
    print(val1)
",O(logn)
"def cnt(s,t):
    i,c=0,0
    while(s.count(t)):
        s=s[s[i:].index(t)+1:]
        c+=1
    return c
s=(input())
n=len(s)
ln=0
for i in range(n):
    for j in range(i,n):
        if(j-i+1<=ln):
            continue
        if(cnt(s,s[i:j+1])>=2):
            ln=max(ln,j-i+1)
print(ln)
",O(n ^ 3)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def correctBinaryTree(self, root):
        q = {root:None}
        while q:
            new_q = {}
            for node, parent in q.items():
                if node.right in q:
                    if parent.left == node:
                        parent.left = None
                    else:
                        parent.right = None
                    return root
                if node.left:
                    new_q[node.left] = node
                if node.right:
                    new_q[node.right] = node
            q = new_q",O(n)
"class Solution2(object):
    def integerReplacement(self, n):
        if n < 4:
            return [0, 0, 1, 2][n]
        if n % 4 in (0, 2):
            return self.integerReplacement(n / 2) + 1
        elif n % 4 == 1:
            return self.integerReplacement((n - 1) / 4) + 3
        else:
            return self.integerReplacement((n + 1) / 4) + 3",O(logn)
"class Solution(object):
    def minSubarray(self, nums, p):
        residue = sum(nums) % p
        if not residue:
            return 0
        result = len(nums)
        curr, lookup = 0, {0: -1}
        for i, num in enumerate(nums):
            curr = (curr+num) % p
            lookup[curr] = i
            if (curr-residue) % p in lookup:
                result = min(result, i-lookup[(curr-residue)%p])
        return result if result < len(nums) else -1",O(n)
"n,m = map(int,input().split())
final = []
for i in range(n):
    a,b = map(int,input().split())
    final.append([a,b])
final.sort(key = lambda x: x[0]-x[1])
s1 = 0
s2 = 0
for i in final:
    s2+=i[1]
    s1+=i[0]
if s2>m:
    print(-1)
else:
    if s1<=m:
        print(0)
    else:
        i = n-1
        count = 0
        while s1>m:
            s1 = s1 - (final[i][0]-final[i][1])
            count+=1
            i-=1
        print(count)
",O(nlogn)
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    n = I()
    aa = [LI() for _ in range(n)]
    r = []
    for a,b in aa:
        al = a + (1-a%2)
        ar = b - (1-b%2)
        sa = (ar-al) // 2 + 1
        tr = -(al+ar) * sa // 2

        bl = a + (a%2)
        br = b - (b%2)
        sb = (br-bl) // 2 + 1
        tr += (bl+br) * sb // 2
        r.append(tr)

    return ""\n"".join(map(str,r))

print(main())
",O(1)
"import itertools

n, l, r, x = [int(x) for x in input().split()]
c = [int(x) for x in input().split()]

counter = 0
for i, val in enumerate(["""".join(seq) for seq in itertools.product(""01"", repeat=n)]):
    if val.count('1') < 2:
        continue
    dif = 0; mx = float(""-inf""); mn = float(""inf"")
    for i, bit in enumerate(val):
        if bit == '1':
            dif += c[i]
            mx = max(c[i], mx)
            mn = min(c[i], mn)
    if l <= dif <= r and  mx - mn >= x:
        counter += 1

print(counter)
",np
"n = int(input())
s = [input() for i in range(n)]
MOD = 10**9 + 7

dps = [[0]*(n + 3) for i in range(n + 1)]
dpf = [[0]*(n + 3) for i in range(n + 1)]

for k in range(n + 1):
    dps[0][k] = 1

for pos, char in enumerate(s):
    if char == ""s"":

        for depth in range(pos + 2):
            dps[pos + 1][depth] = dpf[pos][depth] - \
                dpf[pos][depth - 1] + dps[pos][pos] - dps[pos][depth - 1]

            dps[pos + 1][depth] += dps[pos + 1][depth - 1]
            dps[pos + 1][depth] %= MOD

        for p in range(pos + 2, n+1):
            dpf[pos + 1][p] += dpf[pos + 1][p - 1]
            dpf[pos + 1][p] %= MOD
        continue

    else:

        for depth in range(1, pos + 2):
            dpf[pos + 1][depth] = dpf[pos][depth - 1] - \
                dpf[pos][depth - 2] + dps[pos][pos] - dps[pos][depth - 2]

            dpf[pos + 1][depth] += dpf[pos + 1][depth - 1]
            dpf[pos + 1][depth] %= MOD
        for p in range(pos + 2, n+1):
            dpf[pos + 1][p] += dpf[pos + 1][p - 1]
            dpf[pos + 1][p] %= MOD

ans = dps[n][n] % MOD
print(ans)
",O(n ^ 2)
"from itertools import combinations

def findsum(comb):
    sum = 0
    for song in comb:
        sum += song[0]
    return sum

def finda(a,b,c):
    if a == 0:
        return 0
    if a == 1 and b == 0 and c == 0:
        return 1
    else:
        return (a * findb(a-1,b,c)+ a*findc(a-1,b,c))

def findb(a,b,c):
    if b == 0:
        return 0
    if b == 1 and a == 0 and c == 0:
        return 1
    else:
        return (b * finda(a,b-1,c)+ b*findc(a,b-1,c))

def findc(a,b,c):
    if c == 0:
        return 0
    if c == 1 and a == 0 and b == 0:
        return 1
    else:
        return (c * finda(a,b,c-1)+ c*findb(a,b,c-1))

n, T = map(int,input().split())
songs = []
total_combinations = 0
for i in range(n):
    t, g = map(int,input().split())
    songs.append([t,g])

for i in range(1, n+1):
    allcomb = list(combinations(songs,i))
    for comb in allcomb:
        sum = findsum(comb)

        if sum == T:
            a = 0
            b = 0
            c = 0
            for song in comb:
                if song[1] == 1:
                    a += 1
                elif song[1] == 2:
                    b += 1
                else:
                    c += 1
            total_combinations += finda(a,b,c)+findb(a,b,c)+findc(a,b,c)
total_combinations = total_combinations%1000000007
print(total_combinations)",np
"class Solution(object):
    def alienOrder(self, words):
        result, in_degree, out_degree = [], {}, {}
        zero_in_degree_queue = collections.deque()
        nodes = set()
        for word in words:
            for c in word:
                nodes.add(c)

        for i in range(1, len(words)):
            if (len(words[i-1]) > len(words[i]) and
                    words[i-1][:len(words[i])] == words[i]):
                return """"
            self.findEdges(words[i - 1], words[i], in_degree, out_degree)

        for node in nodes:
            if node not in in_degree:
                zero_in_degree_queue.append(node)

        while zero_in_degree_queue:
            precedence = zero_in_degree_queue.popleft()
            result.append(precedence)

            if precedence in out_degree:
                for c in out_degree[precedence]:
                    in_degree[c].discard(precedence)
                    if not in_degree[c]:
                        zero_in_degree_queue.append(c)

                del out_degree[precedence]

        if out_degree:
            return """"

        return """".join(result)

    def findEdges(self, word1, word2, in_degree, out_degree):
        str_len = min(len(word1), len(word2))
        for i in range(str_len):
            if word1[i] != word2[i]:
                if word2[i] not in in_degree:
                    in_degree[word2[i]] = set()
                if word1[i] not in out_degree:
                    out_degree[word1[i]] = set()
                in_degree[word2[i]].add(word1[i])
                out_degree[word1[i]].add(word2[i])
                break",O(n)
"import sys
readline = sys.stdin.readline

def popcount(i):
    assert 0 <= i < 0x100000000
    i = i - ((i >> 1) & 0x55555555)
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)
    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24

N, M = map(int, readline().split())

Ar = [tuple(map(int, readline().split())) for _ in range(N)]

pc = [popcount(i) for i in range(1<<(M+1))]

inf = 1<<31
maxi = [0]*(1<<M)

for i in range(N):
    a = Ar[i]
    dp = [0]*(1<<M)
    for S in range(1, 1<<M):
        p = pc[S]
        if p == 1:
            k = S.bit_length() - 1
            dp[S] = a[k]
        else:
            dp[S] = min(dp[-S&S], dp[S^(-S&S)])
        maxi[S] = max(maxi[S], dp[S])
for i in range(M):
    for j in range(1<<M):
        if not j & (1<<i):
            maxi[j] = max(maxi[j], maxi[j|(1<<i)])

D = (1<<M)-1
ans = maxi[D]
aS, bS = D, D
for S in range(1<<M):
    candi = min(maxi[S], maxi[D^S])
    if candi > ans:
        aS, bS = S, D^S
        ans = candi

Ans = [None]*2
pre = False
fro = False

for i in range(N):
    a = Ar[i]
    resa = inf
    resb = inf
    for j in range(M):
        if (1<<j)&aS:
            resa = min(resa, a[j])
        else:
            resb = min(resb, a[j])
    if resa >= ans:
        pre = True
        Ans[0] = i+1
    if resb >= ans:
        fro = True
        Ans[1] = i+1
    if pre and fro:
        break
print(*Ans)
",np
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def solve(node, remain, adj, dp):
  if remain == 0:
    return 0
  key = (node, remain)
  mem = dp.get(key)
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))
  dp.set(key, ans)
  return ans

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = [-1] * (n*m*(k/2+1))

  for i in range(n*m):
    dp[i] = 0

  for t in range(1, k/2+1):
    for i in range(n*m):
      ans = min(map(lambda x: dp[x[0]+((t-1)*n*m)] + x[1], adj[i]))
      dp[i+(t*n*m)] = ans

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(dp[node+(k/2*n*m)] * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 3)
"n, m, k = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
b = [list(map(int, input().split())) for _ in range(n-1)]

if k % 2 == 1:
    for i in range(n):
        print(*[-1]*m)
    exit()
k //= 2

INF = 10**18
dp = [[[INF]*(k+1) for _ in range(m)] for _ in range(n)]

for i in range(n):
    for j in range(m):
        dp[i][j][0] = 0

for v in range(1, k+1):
    for i in range(n):
        for j in range(m):
            now_h, now_w = i, j
            if i > 0:
                dp[i][j][v] = min(dp[i-1][j][v-1]+b[i-1][j], dp[i][j][v])
            if i < n-1:
                dp[i][j][v] = min(dp[i+1][j][v-1]+b[i][j], dp[i][j][v])
            if j > 0:
                dp[i][j][v] = min(dp[i][j-1][v-1]+a[i][j-1], dp[i][j][v])
            if j < m-1:
                dp[i][j][v] = min(dp[i][j+1][v-1]+a[i][j], dp[i][j][v])

for i in range(n):
    v = []
    for j in range(m):
        v.append(dp[i][j][k]*2)
    print(*v)
",O(n ^ 3)
"from sys import stdin, stdout
input = stdin.readline

n,m,K = map(int,input().split())
edges = []
for i in range(n):
    edges.append([[]])
    lis = list(map(int,input().split()))
    for j in range(m-1):
        edges[i][j].append((1,0,lis[j]))
        edges[i].append([])
        edges[i][j+1].append((-1,0,lis[j]))
for i in range(n-1):
    lis = list(map(int,input().split()))
    for j in range(m):
        edges[i][j].append((0,1,lis[j]))
        edges[i+1][j].append((0,-1,lis[j]))

if K%2==1:
    lis = []
    for i in range(n):
        lis.append([-1]*m)
else:
    lis = []
    for i in range(n):
        lis.append([0]*m)

    for k in range(1,(K//2)+1):
        new_lis = []
        for i in range(n):
            new_lis.append([0]*m)
        for i in range(n):
            for j in range(m):
                dist = []
                for e in edges[i][j]:

                    dist.append(e[2] + lis[i+e[1]][j+e[0]])
                new_lis[i][j] = min(dist)
        lis = new_lis
    for i in range(n):
        for j in range(m):
            lis[i][j] *= 2

for i in lis:
    print(*i)",O(n ^ 3)
"from sys import stdin
from operator import xor

rints = lambda: [int(x) for x in stdin.readline().split()]
n, a, m = int(input()), [rints()], int(input())
qur, out = [rints() for _ in range(m)], []

for i in range(1, n):
    a.append(map(xor, a[-1][:-1], a[-1][1:]))

for i in range(n - 1):
    a[i + 1] = map(max, a[i][:-1], a[i][1:], a[i + 1])

for l, r in qur:
    out.append(a[r - l][l - 1])

print('\n'.join(map(str, out)))
",O(n ^ 2)
"from collections import deque
n, d, k = map(int, input().split())
if n==1:
    print('NO')
    exit(0)
if n==2:
    if d>1:
        print('NO')
    else:
        print('YES')
        print(1, 2)
    exit(0)
if (not 2<=d<=n-1) or k==1:
    print('NO')
    exit(0)
ans = []
for i in range(d):
    ans.append((i+1, i+2))
now = d+2
for i in range(d-1):
    q = deque([(i+2, min(i, d-i-2))])
    first = True
    while q and len(ans)<n-1:
        node, depth = q.popleft()
        end = now+k-1
        if first:
            end -= 1
        for j in range(now, end):
            ans.append((node, j))
            if len(ans)==n-1:
                break
            if depth>0:
                q.append((j, depth-1))
        now = end
        first = False

if len(ans)==n-1:
    print('YES')
    for i, j in ans:
        print(i, j)
else:
    print('NO')",O(n ^ 2)
"num=int(input())
list_=sorted(set(map(int,input().split())))
if len(list_)==1:
    print(""NO"")
else:

    print(list_[1])
",O(nlogn)
"def fis(sq):
    if sq[2] < sq[0] or sq[3] < sq[1]:
        return [0, 0]
    sc = (sq[0] + sq[1]) % 2
    fc = (sq[2] + sq[3]) % 2
    sxl = sq[2] - sq[0] + 1
    syl = sq[3] - sq[1] + 1
    hf = (sxl * syl) // 2
    cp = -1
    if sc == fc and (sxl+syl) % 2 == 0 and sxl % 2 == 1:
        cp = sc
    return([hf + (1 if cp == 0 else 0), hf + (1 if cp == 1 else 0)])

t = int(input())
for i in range(t):
    n, m = [int(x) for x in input().split()]
    wco = [int(x) for x in input().split()]
    bco = [int(x) for x in input().split()]
    wf, bf = fis([1, 1, m, n])
    btw = fis(wco)[1]
    wtb = fis(bco)[0]
    bnac = [max(wco[0], bco[0]), max(wco[1], bco[1]), min(wco[2], bco[2]), min(wco[3], bco[3])]
    bna = fis(bnac)[1]
    print(wf+btw-wtb-bna, bf+wtb-btw+bna)
",O(1)
"class Solution(object):
    def maxDistance(self, s, k):
        result = x = y = 0
        for i, c in enumerate(s, 1):
            if c == 'E':
                x += 1
            elif c == 'W':
                x -= 1
            elif c == 'N':
                y += 1
            elif c == 'S':
                y -= 1
            result = max(result, min(abs(x)+abs(y)+2*k, i))
        return result",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def reverseEvenLengthGroups(self, head):
        prev, l = head, 2
        while prev.__next__:
            curr, cnt = prev, 0
            for _ in range(l):
                if not curr.__next__:
                    break
                cnt += 1
                curr = curr.__next__
            l += 1
            if cnt%2:
                prev = curr
                continue
            curr, last = prev.__next__, None
            for _ in range(cnt):
                curr.next, curr, last = last, curr.next, curr
            prev.next.next, prev.next, prev = curr, last, prev.next
        return head",O(n)
"class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None

class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

class Solution2(object):

    def __init__(self, capacity):
        self.list = LinkedList()
        self.dict = {}
        self.capacity = capacity

    def get(self, key):
        if key not in self.dict:
            return -1
        val = self.dict[key].val
        self.__update(key, val)
        return val

    def put(self, key, val):
        if key not in self.dict and len(self.dict) == self.capacity:
            del self.dict[self.list.head.key]
            self.list.delete(self.list.head)
        self.__update(key, val)

    def __update(self, key, val):
        if key in self.dict:
            self.list.delete(self.dict[key])
        node = ListNode(key, val)
        self.list.insert(node)
        self.dict[key] = node",O(1)
"def rec(r,g,b):
    if(dp[r][g][b]!=-1):
        return dp[r][g][b]
    ans=0
    if r<R and g<G:
        ans=max(ans, red[r]*green[g]+rec(r+1, g+1, b))
    if r<R and b<B:
        ans=max(ans, red[r]*blue[b]+rec(r+1, g, b+1))
    if b<B and g<G:
        ans=max(ans, blue[b]*green[g]+rec(r, g+1, b+1))
    dp[r][g][b]=ans
    return ans
R,G,B=map(int,input().split())
red=sorted(list(map(int, input().split())), reverse=True)
green=sorted(list(map(int, input().split())), reverse=True)
blue=sorted(list(map(int, input().split())), reverse=True)
dp=[[[-1]*(B+1) for _ in range(G+1)] for _ in range(R+1)]
print(rec(0,0,0))",O(n ^ 3)
"s = input()

count = 0

i = 0

while i < len(s):

    if int(s[i]) % 3 == 0:

        count += 1
        i += 1

    elif i < len(s)-1 and (int(s[i:i+2]) % 3 == 0 or int(s[i+1]) % 3 == 0 ):

        count += 1
        i +=2

    elif i < len(s)-2 and ( int(s[i+1:i+3]) % 3 == 0 or int(s[i:i+3]) % 3 == 0 or s[i+2] == '0') :

        count += 1
        i += 3

    else:

        i +=1

print(count)
",O(n)
"def pwr(a,n,m):
    if n==0:return 1
    ans=pwr(a,n//2,m)
    ans=ans*ans
    ans%=m
    if n%2==1:return (ans*a)%m
    else: return ans
M=1000000007
tx,tn=input().split()
x=int(tx)
n=int(tn)
ans=pwr(2,n+1,M)*x
ans%=M
ans=ans-pwr(2,n,M)+1
ans=(ans+M)%M
if x==0: ans=0
print(ans)
",O(logn)
"class Solution(object):
    def countArrangement(self, N):
        def countArrangementHelper(n, arr):
            if n <= 0:
                return 1
            count = 0
            for i in range(n):
                if arr[i] % n == 0 or n % arr[i] == 0:
                    arr[i], arr[n-1] = arr[n-1], arr[i]
                    count += countArrangementHelper(n - 1, arr)
                    arr[i], arr[n-1] = arr[n-1], arr[i]
            return count

        return countArrangementHelper(N, list(range(1, N+1)))",O(n!)
"a,b,c = map(int,input().split())
arr = list(map(int,input().split()))

arr.sort()
p = 0
a-=1
while(a>=0 and c<b):
    c-=1
    p+=1
    c+=arr[a]
    a-=1
if(c<b):
    print(-1)
else:
    print(p)",O(nlogn)
"l = []
n = []
sum = 0
multiply = 9
for i in range(1,12):
    s = '9' * i
    n.append(int(s))
    sum+=i*multiply
    multiply *= 10
    l.append(sum)
k = int(input())
if(k<9):
    print(k)
else:
    t = 0
    for i in range(len(l)):
        if(k < l[i]):
            t=i
            break
    temp = k-l[t-1]
    offset = temp%(t+1)
    value = temp//(t+1)
    number = n[t-1]+value
    if(offset == 0):
        print(number%10)
    else:
        number += 1
        offset -= 1
        print(str(number)[offset])",O(logn)
"class Solution(object):
    def maximumLengthOfRanges(self, nums):
        result = [0]*len(nums)
        stk = [-1]
        nums.append(float(""inf""))
        for i, x in enumerate(nums):
            while stk[-1] != -1 and nums[stk[-1]] < x:
                j = stk.pop()
                result[j] = (i-1)-stk[-1]
            stk.append(i)
        return result",O(n)
"k1,k2,k3=map(int,input().split())
a=[k1,k2,k3];a=sorted(a)

i=0
while i<=5000:
 if dp[i]==0 and i+a[0]<=5000:
   while i+a[0]<=5000:
     dp[i]=1
     i=i+a[0]
 else:i+=1

while i<=5000:
 if dp[i]==0 and i+a[1]<=5000:
   while i+a[1]<=5000:
     dp[i]=1
     i=i+a[1]
 else:i+=1

while i<=5000:
 if dp[i]==0 and i+a[2]<=5000:
   while i+a[2]<=5000:
     dp[i]=1
     i=i+a[2]
 else:i+=1

if dp.count(0)==0:print(""YES"")
else:print(""NO"")
",O(1)
"import collections


class Solution(object):
    def sumOfDistancesInTree(self, N, edges):
        def dfs(graph, node, parent, count, result):
            for nei in graph[node]:
                if nei != parent:
                    dfs(graph, nei, node, count, result)
                    count[node] += count[nei]
                    result[node] += result[nei]+count[nei]

        def dfs2(graph, node, parent, count, result):
            for nei in graph[node]:
                if nei != parent:
                    result[nei] = result[node]-count[nei] + \
                                  len(count)-count[nei]
                    dfs2(graph, nei, node, count, result)

        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        count = [1] * N
        result = [0] * N

        dfs(graph, 0, None, count, result)
        dfs2(graph, 0, None, count, result)
        return result",O(n)
"point = {}

n = int(input())

for i in range(n):
    l, r = map(int, input().split())
    r += 1
    if l not in point:
        point[l] = 0
    if r not in point:
        point[r] = 0
    point[l] += 1
    point[r] -= 1

line = []
for key in point:
    line.append((key,point[key]))
line.sort()
ans = [0] * (n+1)

last_index = 0
last_value = 0

for index, value in line:
    ans[last_value] += index - last_index
    last_index = index
    last_value += value

for cnt in ans[1:]:
    print(cnt,end=' ')",O(nlogn)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def reverseKGroup(self, head, k):
        dummy = ListNode(-1)
        dummy.next = head

        cur, cur_dummy = head, dummy
        length = 0

        while cur:
            next_cur = cur.__next__
            length = (length + 1) % k

            if length == 0:
                next_dummy = cur_dummy.__next__
                self.reverse(cur_dummy, cur.__next__)
                cur_dummy = next_dummy

            cur = next_cur

        return dummy.__next__

    def reverse(self, begin, end):
            first = begin.__next__
            cur = first.__next__

            while cur != end:
                first.next = cur.__next__
                cur.next = begin.__next__
                begin.next = cur
                cur = first.__next__",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def maxSumBST(self, root):
        result = 0
        stk = [[root, None, []]]
        while stk:
            node, tmp, ret = stk.pop()
            if tmp:
                lvalid, lsum, lmin, lmax = tmp[0]
                rvalid, rsum, rmin, rmax = tmp[1]
                if lvalid and rvalid and lmax < node.val < rmin:
                    total = lsum + node.val + rsum
                    result = max(result, total)
                    ret[:] = [True, total, min(lmin, node.val), max(node.val, rmax)]
                    continue
                ret[:] = [False, 0, 0, 0]
                continue
            if not node:
                ret[:] = [True, 0, float(""inf""), float(""-inf"")]
                continue
            new_tmp = [[], []]
            stk.append([node, new_tmp, ret])
            stk.append([node.right, None, new_tmp[1]])
            stk.append([node.left, None, new_tmp[0]])
        return result",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def amountOfTime(self, root, start):
        def iter_dfs(root, start):
            result = -1
            stk = [(1, (root, [-1]*2))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    curr, ret = args
                    if curr is None:
                        continue
                    left, right = [-1]*2, [-1]*2
                    stk.append((2, (curr, left, right, ret)))
                    stk.append((1, (curr.right, right)))
                    stk.append((1, (curr.left, left)))
                elif step == 2:
                    curr, left, right, ret = args
                    d = -1
                    if curr.val == start:
                        d = 0
                        result = max(left[0], right[0])+1
                    elif left[1] >= 0:
                        d = left[1]+1
                        result = max(result, right[0]+1+d)
                    elif right[1] >= 0:
                        d = right[1]+1
                        result = max(result, left[0]+1+d)
                    ret[:] = [max(left[0], right[0])+1, d] 
            return result

        return iter_dfs(root, start)",O(n)
"class Solution(object):
    def continuousSubarrays(self, nums):
        result = left = 0
        mn, mx = float(""inf""), float(""-inf"")
        for right in range(len(nums)):
            if mn <= nums[right] <= mx:
                mn, mx = max(mn, nums[right]-2), min(mx, nums[right]+2)
            else:
                mn, mx = nums[right]-2, nums[right]+2
                for left in reversed(range(right)):
                    if not mn <= nums[left] <= mx:
                        break
                    mn, mx = max(mn, nums[left]-2), min(mx, nums[left]+2)
                else:
                    left = -1
                left += 1
            result += right-left+1
        return result
import collections",O(n)
"def check_combination(v):
    sm = sum(v)
    if l <= sm <= r:
        if max(v) - min(v) >= x:
            global ans
            ans += 1

def go(offset, k):

    if k == 0:
        check_combination(combination)
        return
    for i in range(offset, len(problems) - k + 1):
        combination.append(problems[i])
        go(i+1, k-1)
        combination.pop()

n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))

problems = list()
combination = list()

ans = 0

for i in range(2, len(c) + 1):
    problems = c.copy()
    go(0, i)

print(ans)
",np
"import collections



class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def removeZeroSumSublists(self, head):
        curr = dummy = ListNode(0)
        dummy.next = head
        prefix = 0
        lookup = collections.OrderedDict()
        while curr:
            prefix += curr.val
            node = lookup.get(prefix, curr)
            while prefix in lookup:
                lookup.popitem()
            lookup[prefix] = node
            node.next = curr.__next__
            curr = curr.__next__
        return dummy.__next__",O(n)
"class Solution2(object):
    def maximumScore(self, grid):
        prefix = [0]*(len(grid)+1)
        for i in range(len(grid)):
            prefix[i+1] = prefix[i]+grid[i][0]
        dp = [[0]*(len(grid)+1) for _ in range(2)]
        for j in range(1, len(grid[0])):
            new_prefix = [0]*(len(grid)+1)
            for i in range(len(grid)):
               new_prefix[i+1] = new_prefix[i]+grid[i][j]
            new_dp = [[0]*(len(grid)+1) for _ in range(2)]
            for i in range(len(grid)+1):
                for k in range(len(grid)+1):
                    new_dp[0][i] = max(new_dp[0][i], max(prefix[i]-prefix[k], 0)+dp[0][k])
                    new_dp[1][i] = max(new_dp[1][i], dp[1][k]+max(new_prefix[k]-new_prefix[i], 0))
                new_dp[0][i] = max(new_dp[0][i], max(dp[1]))
                new_dp[1][i] = max(new_dp[1][i], new_dp[0][i])
            dp, prefix = new_dp, new_prefix
        return max(dp[1])",O(n ^ 3)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"class Solution(object):
    def maxOperations(self, nums):
        def memoization(left, right, target, lookup):
            if not right-left+1 >= 2:
                return 0
            if lookup[left][right] == -1:
                lookup[left][right] = max(1+memoization(left+2, right-0, target, lookup) if nums[left]+nums[left+1]   == target else 0,
                                          1+memoization(left+1, right-1, target, lookup) if nums[left]+nums[right]    == target else 0,
                                          1+memoization(left+0, right-2, target, lookup) if nums[right-1]+nums[right] == target else 0)
            return lookup[left][right] 

        return max(memoization(0, len(nums)-1, target, [[-1]*(len(nums)) for _ in range(len(nums))]) for target in {nums[0]+nums[1], nums[0]+nums[-1], nums[-2]+nums[-1]})",O(n ^ 2)
"class Solution(object):
    def findOcurrences(self, text, first, second):
        result = []
        first += ' '
        second += ' '
        third = []
        i, j, k = 0, 0, 0
        while k < len(text):
            c = text[k]
            k += 1
            if i != len(first):
                if c == first[i]:
                    i += 1
                else:
                    i = 0
                continue
            if j != len(second):
                if c == second[j]:
                    j += 1
                else:
                    k -= j+1
                    i, j = 0, 0
                continue
            if c != ' ':
                third.append(c)
                continue
            k -= len(second) + len(third) + 1
            i, j = 0, 0
            result.append("""".join(third))
            third = []
        if third:
            result.append("""".join(third))
        return result",O(n)
"from collections import defaultdict
import sys
import bisect
input=sys.stdin.readline

n,m=map(int,input().split())
a=[int(i) for i in input().split()if i!='\n']
rem=[[] for i in range(m)]
req=n//m
ans=0
for i in range(n):
    rem[a[i]%m].append([a[i],i])
ind=m-1
for i in range(m):
    size=len(rem[i])
    if size>req:
        ind=i
    if size<req:
        ok=False
        for j in range(ind,-1,-1):
            while len(rem[j])>req:
                pop,_=rem[j].pop()
                rem[i].append([pop+(i-j)%m,_])
                if len(rem[i])==req:
                    ok=True
                    break
            if ok:
                break
            ind-=1
        else:
            ind=m-1
            for j in range(ind,-1,-1):
                while len(rem[j])>req:
                    pop,_=rem[j].pop()
                    rem[i].append([pop+(i-j)%m,_])
                    if len(rem[i])==req:
                        ok=True
                        break
                if ok:
                    break
                ind-=1

out=[0]*(n)
for i in rem:
    for j in i:
        out[j[1]]=j[0]
print(sum(out)-sum(a))
out=' '.join(map(str,out))
print(out)
",O(n)
"n, m, k, l = [int(x) for x in input().split()]
if (l + k) % m == 0:
    c = (l + k)//m
else:
    c = (l + k)//m + 1
if m * c > n:
    print(-1)
else:
    print(c)",O(1)
"import math
import sys

DEBUG = False

def inp():
    return sys.stdin.readline().rstrip()

def dprint(*value, sep=' ', end='\n'):
    if DEBUG:
        print(*value, sep=sep, end=end)

def solve(H, W, A):
    visited = [bytearray(W) for _ in range(H)]

    for y in range(H):
        for x in range(W):
            if A[y][x] == '.' or visited[y][x]:
                continue

            dprint(x, y)
            for dx, dy in [(0, 0), (-1, 0), (-2, 0),
                           (0, -1), (-2, -1),
                           (0, -2), (-1, -2), (-2, -2)]:
                tx = x + dx
                ty = y + dy
                dprint('  ', tx, ty)
                if tx < 0 or ty < 0 or tx + 2 >= W or ty + 2 >= H:
                    continue
                bad = False
                for ex, ey in [(0, 0), (1, 0), (2, 0),
                               (0, 1), (2, 1),
                               (0, 2), (1, 2), (2, 2)]:
                    nx = tx + ex
                    ny = ty + ey
                    if A[ny][nx] == '.':
                        bad = True
                        break
                if bad:
                    continue

                for ex, ey in [(0, 0), (1, 0), (2, 0),
                               (0, 1), (2, 1),
                               (0, 2), (1, 2), (2, 2)]:
                    nx = tx + ex
                    ny = ty + ey
                    visited[ny][nx] = 1

                assert visited[ny][nx] == 1
                break

            if visited[y][x] == 0:
                return False

    return True

def main():
    H, W = [int(e) for e in inp().split()]
    A = [inp() for _ in range(H)]

    print('YES' if solve(H, W, A) else 'NO')

if __name__ == '__main__':
    main()
",O(n ^ 2)
"class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def dfs(root):
            if not root:
                return [True, 0]

            left, right = dfs(root.left), dfs(root.right)
            balanced = left[0] and right[0] and abs(left[1] - right[1]) <= 1
            return [balanced, 1 + max(left[1], right[1])]

        return dfs(root)[0]
",O(n)
"import math
s1=input()
s2=input()
s1p=s1.count(""+"")
s1m=s1.count(""-"")
s2p=s2.count(""+"")
s2m=s2.count(""-"")
s2q=0
if '?' in s2:
    s2q=s2.count(""?"")
if s2q==0:
    if s1p==s2p and s1m==s2m:
        print(""%.12f""%1)
    else:
        print(""%.12f""%0)
else:
    if s1p>=s2p and s1m>=s2m:
        s2q=math.factorial(s2q)/(math.factorial(s1p-s2p)*math.factorial(s1m-s2m))
        print(""%.12f""%(s2q/(2**s2.count(""?""))))
    else:
        print(""%.12f""%0)
",np
"class Solution2(object):
    def findSmallestInteger(self, nums, value):
        cnt = collections.Counter(x%value for x in nums)
        for i in range(len(nums)+1):
            if not cnt[i%value]:
                return i
            cnt[i%value] -= 1",O(n)
"n,m=map(int,input().strip().split())
v=[0]*51
left=1
right=n
for i in range(1,n+1):
	if(n-i-1<=0):
		pw=1
	else:
		pw=(1<<(n-i-1))

	if(m<=pw):
		v[left]=i
		left+=1
	else:
		v[right]=i
		right-=1
		m-=pw
for i in range(1,n):
	print(v[i], end=' ')
print(v[n])
",np
"from math import sqrt

n, k = map(int, input().split())

answer = int(-1.5 + sqrt(9/4 + 2*(n+k)))

print(n - answer)
",O(1)
"n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))

from itertools import combinations
ways_to_choose = 0
for length in range(2, n + 1):
    for p in combinations(c, length):
        problemset = sorted(p)
        if l <= sum(problemset) <= r and problemset[-1] - problemset[0] >= x:
            ways_to_choose += 1

print(ways_to_choose)
",np
"import collections



class Solution(object):
    def countGood(self, nums, k):
        result = curr = left = 0
        cnt = collections.Counter()
        for right in range(len(nums)):
            curr += cnt[nums[right]]
            cnt[nums[right]] += 1
            while curr >= k:
                cnt[nums[left]] -= 1
                curr -= cnt[nums[left]]
                left += 1
            result += left
        return result",O(n)
"class Solution(object):
    def findMinMoves(self, machines):
        total = sum(machines)
        if total % len(machines): return -1

        result, target, curr = 0, total / len(machines), 0
        for n in machines:
            curr += n - target
            result = max(result, max(n - target, abs(curr)))
        return result",O(n)
"n,x=list(map(int,input().split()))
b=list(map(int,input().split()))
d={}
flag=0
for i in b:
    if d.get(i):
        flag=1
        break
    else:
        d[i]=1
if flag:
    print(0)
else:
    flag=0
    c=set()
    for i in b:
        a=i&x
        c.add(a)
        if d.get(a) and a!=i:
            flag=1
            break
    if flag:
        print(1)
    elif len(c)<n and flag==0:
        print(2)
    else:
        print(-1)
",O(n)
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []

    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)

    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)

    return powerset_orderred
def fastPlrintNextLines(a):

    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
t = 1

for _ in range(t):
    n,k = li()
    if k<=n:
        print((k-1)//2)
    else:
        print(max((2*n-k+1)//2,0))
",O(1)
"s = input()
for i in range(len(s), 0, -1):
	for j in range(len(s) - i + 1):
		if s[j: j + i] in s[j + 1:]:
			print(i)
			exit()
print(0)",O(n ^ 3)
"import math
def C(a, b):
	return math.factorial(a)//(math.factorial(b)*math.factorial(a-b))

a = list(input())
b = list(input())
x, y, d, ans, power = 0, 0, 0, 0, 0
for i in range(len(a)):
	if a[i] == '+':
		x += 1
	if a[i] == '-':
		x -= 1
	if b[i] == '?':
		d += 1
	if b[i] == '+':
		y += 1
	if b[i] == '-':
		y -= 1
plus, minus = d, 0
for i in range(0, d+1):
	k = C(d, plus)
	if y+(plus-minus) == x:
		ans += k
	power += k
	plus -= 1
	minus += 1
print(""{0:.12f}"".format(ans/power))",np
"n = int(input())
a = {}
ans = 0
sum = 0
i = 0
for t in map(int, input().split()):
    sum += t
    a[t] = a.get(t, 0) + 1

    ans += (i - a.get(t, 0) - a.get(t - 1, 0) - a.get(t + 1, 0) + 1) * t - (sum - a.get(t, 0) * t - a.get(t - 1, 0) * (t - 1) - a.get(t + 1, 0) * (t + 1))
    i += 1

print(ans)
",O(nlogn)
"def givestringsk(k):
    t=[""R"",""G"",""B""]
    ans=[]
    for i in range(3):
        temp=""""
        for j in range(i,i+k):
            temp+=t[j%3]
        ans.append(temp)
    return ans
def countdifferences(a,b):
    cnt=0
    for i in range(len(a)):
        if a[i]!=b[i]:cnt+=1
    return cnt
for _ in range(int(input())):
    n,k=list(map(int,input().split()))
    s=input()
    temp=givestringsk(k)
    ans=10000000000000
    for i in range(k,n+1):
        for j in range(3):
            ans=min(ans,countdifferences(s[i-k:i],temp[j]))
    print(ans)
",O(n ^ 2)
"n, t = map(int, input().split())
l = []
for _ in range(n):
  x, a = map(int, input().split())
  l.append((x-a/2, x+a/2))
l.sort()
res = 2

for i in range(n-1):
  if l[i+1][0] - l[i][1] == t:
    res += 1
  elif l[i+1][0] - l[i][1] > t:
    res += 2

print(res)
",O(nlogn)
"class Solution(object):
    def beautifulSplits(self, nums):
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        result = 0
        z0 = z_function(nums)
        for i in range(1, len(nums)-1):
            zi = z_function(nums[i:])
            for j in range(i+1, len(nums)):
                if (z0[i] >= i and j-i >= i) or zi[j-i] >= j-i:
                    result += 1
        return result",O(n ^ 2)
"def solve(n, k):

	if n >= 60:
		return ""YES "" + str(n - 1)

	mxxx = (4 ** n - 1) // 3

	if k > mxxx:
		return 'NO'

	mn, mx = 0, 0

	for i in range(n):
		mn += 2 ** (i + 1) - 1
		mx += 4 ** i
		if mn <= k and mx >= k:
			return ""YES "" + str(n - i - 1)

	if k >= 22 and k <= 25:
		return 'YES ' + str(n - 3)

	if k == 2:
		if n >= 2:
			return 'YES ' + str(n - 1)
		return 'NO'

	if k == 3:
		if n <= 2:
			return 'NO'
		return 'YES ' + str(n - 1)

	if k >= 6 and k <= 10:
		return 'YES ' + str(n - 2)

t = int(input())

for i in range(t):
	n, k = map(int, input().split())
	print(solve(n, k))
",O(logn)
"n = int(input())

a = sorted(map(int, input().split()))

if not any(a):
    print('cslnb')
elif n > 2 and a[0] == a[1] == 0:
    print('cslnb')
else:
    seq_cnt = 0
    seq_sz = 1
    max_seq_sz = 1
    for i in range(n-1):
        if a[i] == a[i+1]:
            seq_sz += 1
        elif a[i] + 1 == a[i+1] and i + 2 < n and a[i+1] == a[i+2]:
            max_seq_sz = 3
            break
        else:
            max_seq_sz = max(seq_sz, max_seq_sz)
            seq_cnt += seq_sz > 1
            seq_sz = 1

    max_seq_sz = max(seq_sz, max_seq_sz)
    seq_cnt += seq_sz > 1

    if max_seq_sz > 2 or seq_cnt > 1:
        print('cslnb')
    else:
        last = to_play = 0
        for i in range(n):
            to_play += a[i] - last
            last += 1

        if to_play % 2 == 0:
            print('cslnb')
        else:
            print('sjfnb')
",O(nlogn)
"n, s = map(int, input().split())
print((s + n - 1) // n)
",O(1)
"n, m = map(int, input().split())
a = []
b = []
check = True
while n >= 0:
    if check == True:
        a.append(5)
        n -= 5
        b.append(4)
        check = False
    else:
         check = True
         a.append(4)
         n -= 4
         b.append(5)

if m != 1:
    a.append(5)
    b.append(6)
else:
    a.append(5)
    b.append(5)

print(*a, sep = """")
print(*b, sep = """")
",O(1)
"n=int(input())
s=0; pred=0
for i in range(1,20):
    m=9*pow(10,i-1)*i
    s+=m
    if n<=s:
        nd=pow(10,i-1)
        sme=n-pred
        num=sme//i
        ost=sme%i
        if ost==0:
            dig=nd+num-1
        else:
            dig=nd+num
        d=i
        rez=[]
        ddig=dig
        while d>0:
            o=ddig%10
            a=ddig//10
            rez.append(o)
            d-=1
            ddig=a
        break
    pred=s
print(str(rez[-ost]))
",O(logn)
"def solve():
    from sys import stdin
    f_i = stdin

    n = int(f_i.readline())

    segments = []
    for i in range(n):
        x, w = map(int, f_i.readline().split())
        segments.append((x + w, x - w))
    segments.sort()

    ans = 0
    t = segments[0][1]
    for end, start in segments:
        if t <= start:
            ans += 1
            t = end

    print(ans)

solve()",O(nlogn)
"n, k = map(int, input().split())
P = map(int, input().split())

parent = list(range(256))
sz = [1] * 256
def rt(x):
    if x != parent[x]:
        parent[x] = rt(parent[x])
    return parent[x]

def u(rx, ry):
    parent[ry] = rx
    sz[rx] += sz[ry]

ans = [0] * n
for i, p in enumerate(P):
    rx = rt(p)
    while rx > 0 and sz[rx] + sz[rt(rx - 1)] <= k:
        u(rt(rx - 1), rx)
        rx = rt(p)
    ans[i] = rt(p)
print(' '.join(map(str, ans)))
",O(n ^ 2)
"class Solution(object):
    def orderOfLargestPlusSign(self, N, mines):
        lookup = {tuple(mine) for mine in mines}
        dp = [[0] * N for _ in range(N)]
        result = 0
        for i in range(N):
            l = 0
            for j in range(N):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = l
            l = 0
            for j in reversed(range(N)):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)

        for j in range(N):
            l = 0
            for i in range(N):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)
            l = 0
            for i in reversed(range(N)):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)
                result = max(result, dp[i][j])
        return result",O(n ^ 2)
"N, M, K = map(int, raw_input().split())
A = [int(a) for a in raw_input().split()]
S = [0]
for a in A:
    S.append(S[-1]+M*a-K)
MI = [(10**50)] * M
ans = 0
for i in range(N+1):
    MI[i%M] = min(MI[i%M], S[i])
    for j in range(M):
        ans = max(ans, (S[i]-MI[(i-j)%M] - K*((-j)%M))//M)
print(ans)
",O(n ^ 2)
"a = int(input())
lister = input().split()
lister = [int(i) for i in lister]

ans = dict()

def findans(n):
	if n in ans:
		return ans[n]
	mod = n%lister[n]
	ok = True
	if n + lister[n] >= a and n - lister[n] < 0:
		ok = False
	else:
		for i in range(mod, a, lister[n]):
			if i != n and lister[i] > lister[n]:
				ok = ok and findans(i)

		ok = not(ok)

	ans[n] = ok
	return ok

for i in range(len(lister)):
	findans(i)

level = []
for i in range(a):
	if ans[i] == True:
		level.append('A')
	else:
		level.append('B')

print(''.join(level))",O(n ^ 2)
"n=int(input())
for i in range(n//3):
    print(2*i,0)
    print(2*i+1,0)
    print(2*i+1,3)
for i in range(n%3):
    print(2*(n//3)+i,0)",O(n)
"def check(e,value,pre):
    global maxi,count
    e[str(value)]-=1
    pre+=str(value)
    arr=[]
    for i in e:
        for j in range(e[i]):
            arr.append(i)
    arr.sort(reverse=True)
    st=''
    for i in arr:
        st+=str(i)
    alpha=int(pre+st)
    if alpha<=int(b):
        maxi=max(maxi,int(pre+st))

a=input()
b=input()
maxi=0
d={}
for i in a:
    if i not in d:
        d[i]=1
    else:
        d[i]+=1
maxi=0
num=""""
count=0
if len(a)<len(b):
    check(d.copy(),max(d),'')
else:
    for i in b:
        if i in d and d[i]>0:
            for j in range(int(i)-1,-1,-1):
                if str(j) in d and d[str(j)]>0:
                    check(d.copy(),j,num)
                    break
            check(d.copy(),i,num)
            num+=i
            d[i]-=1

        else:
            j=0
            for j in range(int(i)-1,-1,-1):
                if str(j) in d and d[str(j)]>0:
                    check(d.copy(),j,num)
                    break
            break
print(maxi)",O(n ^ 3)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def diameterOfBinaryTree(self, root):
        def iter_dfs(node):
            result = 0
            stk = [(1, [node, [0]])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    result = max(result, ret1[0]+ret2[0])
                    ret[0] = 1+max(ret1[0], ret2[0])
            return result
        
        return iter_dfs(root)",O(n)
"a = input()
b = input()
list_a = list(a)
list_a.sort()
max_a = int(''.join(list_a))
for i in range(len(a)):
    for j in range(i+1, len(a)):
        list_a[i], list_a[j] = list_a[j], list_a[i]
        temp_a = int(''.join(list_a))
        if int(b) < temp_a or temp_a <= max_a:
            list_a[i], list_a[j] = list_a[j], list_a[i]
        else:
            max_a = temp_a
print(max_a)",O(n ^ 3)
"n = int(input())
p = [(-(10**6), 0)] + sorted([tuple(map(int, input().split())) for i in range(n)])
dp = [0] * (n + 1)
for i in range(1, n + 1):
    l, r = 0, i
    while r - l > 1:
        mid = (l + r) >> 1
        if p[i][0] - p[i][1] <= p[mid][0]: r = mid
        else: l = mid
    dp[i] = i - r + dp[r - 1]
ans = min(dp[i] + (n - i) for i in range(1, n + 1))
print(ans)",O(n)
"class Solution2(object):
    def largestMultipleOfThree(self, digits):
        def candidates_gen(r):
            if r == 0:
                return
            for i in range(10):
                yield [i]
            for i in range(10):
                for j in range(i+1):
                    yield [i, j]

        count, r = collections.Counter(digits), sum(digits)%3
        for deletes in candidates_gen(r):
            delete_count = collections.Counter(deletes)
            if sum(deletes)%3 == r and \
               all(count[k] >= v for k, v in delete_count.items()):
                for k, v in delete_count.items():
                    count[k] -= v
                break
        result = """".join(str(d)*count[d] for d in reversed(range(10)))
        return ""0"" if result and result[0] == '0' else result",O(n)
"def get_ans(x, a, n, m):

    lim = 1<<m
    match = lim-1
    track = [-1 for i in range(lim)]

    for i in range(n):
        mask = 0
        for j in range(m):
            if(a[i][j] >= x):
                mask |= 1 << j
        track[mask] = i

    for i in range(lim):
        for j in range(lim):
            if(i|j == match and track[i] != -1 and track[j] != -1):
                return track[i], track[j]

    return -1, -1

n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]

lo = 0
hi = 1000000000
while(lo < hi-1):
    mid = (lo+hi)/2
    i, j = get_ans(mid,a,n,m)
    if(i == -1):
        hi = mid-1
    else:
        lo = mid

i,j = get_ans(hi,a,n,m)
if(i != -1):
    print(""{} {}"".format(i+1,j+1))
else:
    i,j = get_ans(lo,a,n,m)
    print(""{} {}"".format(i+1,j+1))
",np
"n, M = map(int, input().strip().split())
a = list(map(int, input().strip().split()))

a.insert(0, 0)
n += 1

lit = [0] * (n + 1)
for i in range(1, n):
    if i % 2 == 0:
        lit[i] = lit[i - 1]
    else:
        lit[i] = lit[i - 1] + a[i] - a[i - 1]
if n % 2 == 0:
    lit[n] = lit[n - 1]
else:
    lit[n] = lit[n - 1] + M - a[n - 1]

ans = lit[n]
for i in range(n):
    pre_lit = lit[i]
    post_lit = M - a[i] - (lit[n] - lit[i])

    if i > 0 and a[i - 1] + 1 < a[i]:
        if i % 2 == 0:
            ans = max(ans, pre_lit + 1 + post_lit)
        else:
            ans = max(ans, pre_lit - 1 + post_lit)
    if (i + 1 < n and a[i] + 1 < a[i + 1]) or (i + 1 == n and a[n - 1] + 1 < M):
        if i % 2 == 0:
            ans = max(ans, pre_lit + post_lit + 1)
        else:
            ans = max(ans, pre_lit + post_lit - 1)
print(ans)",O(n)
"def balance(x1, y1, x2, y2):
    return min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)

def get_lr():
    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 2:
            l = m
        else:
            r = m
    r2 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = n, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res == 2:
            l = m
        else:
            r = m
    l2 = l

    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 1:
            l = m
        else:
            r = m
    r1 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = n, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res >= 1:
            l = m
        else:
            r = m
    l1 = l
    return r1, r2, l2, l1

def get_ud():
    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 2:
            l = m
        else:
            r = m
    r2 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, n, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res == 2:
            l = m
        else:
            r = m
    l2 = l

    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 1:
            l = m
        else:
            r = m
    r1 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, n, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res >= 1:
            l = m
        else:
            r = m
    l1 = l
    return r1, r2, l2, l1

n = int(input())
lr = get_lr()
ud = get_ud()
rr = [lr[0], lr[1]]
ll = [lr[2], lr[3]]
uu = [ud[0], ud[1]]
dd = [ud[2], ud[3]]
for r1 in rr:
    r2 = rr[0] if rr[0] != r1 else rr[1]
    for l1 in ll:
        l2 = ll[0] if ll[0] != l1 else ll[1]
        for u1 in uu:
            u2 = uu[0] if uu[0] != u1 else uu[1]
            for d1 in dd:
                d2 = dd[0] if dd[0] != d1 else dd[1]
                if r1 < l1 or r2 < l2 or u1 < d1 or u2 < d2:
                    continue
                print('?', l1, d1, r1, u1)
                res1 = int(input())
                print('?', l2, d2, r2, u2)
                res2 = int(input())
                if res1 == res2 == 1:
                    print('!', l1, d1, r1, u1, l2, d2, r2, u2)
                    __import__('sys').exit(0)
",O(logn)
"def numtostr(a):
    var=[]
    while a>0:

       if a%26==0:
          var.append(""Z"")
          a=a//26-1
       else:
          var.append(chr(a%26-1+ord(""A"")))
          a=a//26
    var.reverse()
    return """".join(var)

def strtonum(b):
    par=len(b)
    result=0
    for i in range(1,par):
        result+=(26**i)
    par=len(b)-1
    for elem in b:
        if par!=0:
             result+=((ord(elem)-ord(""A""))*((26)**par))
        else:
            result += ((ord(elem) - ord(""A""))+1)

        if par==0:
            break
        par -= 1
    return result

def method1(par1):
    C=par1.index(""C"")
    result=numtostr(int(par1[C+1:]))+str(par1[1:C])
    return result

def method2(par2):
    c=0
    for elem in par2:
        try:
            if int(elem):
                break
        except:
            c+=1
    return ""R""+par2[c:]+""C""+str(strtonum(par2[:c]))

i=input()
inp=[]
for j in range(int(i)):
     x=input()
     inp.append(x)
for key in range(len(inp)):
    if ""R"" in inp[key] and ""C"" in inp[key]:
        try:
            if int(inp[key][1:inp[key].index(""C"")]) and int(inp[key][inp[key].index(""C"")+1:]):
                print(method1(inp[key]))
        except:
            print(method2(inp[key]))
    else:
        print(method2(inp[key]))",O(n)
"class Solution(object):
    def peakIndexInMountainArray(self, arr):
        left, right = 0, len(arr)-1
        while left <= right:
            mid = left + (right-left)//2
            if arr[mid] > arr[mid+1]:
                right = mid-1
            else:
                left = mid+1
        return left",O(logn)
"import sys
n = int(input())
l = list(map(int, input().split()))
r = list(map(int, input().split()))
res = [0] * n
for i in range(n):
    res[i] = n - l[i] - r[i]
for i in range(n):
    ok = 0
    for j in range(i):
        if res[j] > res[i]:
            ok += 1
    if ok != l[i]:
        print(""NO"")
        sys.exit(0)
    ok = 0
    for j in range(i + 1, n):
        if res[j] > res[i]:
            ok += 1
    if ok != r[i]:
        print(""NO"")
        sys.exit(0)
print(""YES"")
print(' '.join(map(str, res)))
",O(n ^ 2)
"class Solution(object):
    def lastVisitedIntegers(self, words):
        PREV = ""prev""
        result, stk = [], []
        i = -1
        for x in words:
            if x == PREV:
                result.append(stk[i] if i >= 0 else -1)
                i -= 1
                continue
            stk.append(int(x))
            i = len(stk)-1
        return result",O(n)
"n = int(input())
arr = list(map(int, input().split()))
res = float('inf')
for i in range(1, n):
    res = min(res, min(arr[i], arr[0]) // i)
for i in range(n - 1):
    res = min(res, min(arr[i], arr[n - 1]) // (n - 1 - i))
print(res)
",O(n)
"n,q = map(int, raw_input().split())
nums = list(map(int, raw_input().split()))

m = max(nums)

ab = []
while nums[0] < m:
    ab.append([nums[0], nums[1]])
    nums.append(nums.pop(1)) if nums[0]>nums[1] else nums.append(nums.pop(0))

for i in range(q):
    mj = int(input())
    a, b = map(str, ab[mj-1] if mj <= len(ab) else (m, nums[(mj-len(ab)-1)%(len(nums)-1) +1]))
    print(a + "" "" + b)
",O(n)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        def dfs(i):
            if i == len(nums) - 1:
                return True
            end = min(len(nums) - 1, i + nums[i])
            for j in range(i + 1, end + 1):
                if dfs(j):
                    return True
            return False

        return dfs(0)
",O(n!)
"def popcount(i):
    assert 0 <= i < 0x100000000
    i = i - ((i >> 1) & 0x55555555)
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)
    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24

N, T = map(int, input().split())
TG = [list(map(int, input().split())) for _ in range(N)]
mod = 10**9+7

dp = [[0]*(2**N) for _ in range(4)]
for i in range(1, 4):
    dp[i][0] = 1

for S in range(2**N):
    if popcount(S) == 1:
        dp[TG[(S&(-S)).bit_length() - 1][1]][S] = 1
    for i in range(1, 4):
        for j in range(N):
            if S & (2**j) or i == TG[j][1]:
                continue
            dp[TG[j][1]][S|(2**j)] = (dp[TG[j][1]][S|(2**j)] + dp[i][S]) % mod

table = [0]*(2**N)
for S in range(2**N):
    table[S] = sum(TG[j][0] for j in range(N) if 2**j & S)

ans = 0
for S in range(2**N):
    if table[S] == T:
        for i in range(1, 4):
            ans = (ans + dp[i][S]) % mod

print(ans)",np
"class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):
        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
            if visited in lookup:
                return lookup[visited]

            mask = 1
            for i in range(maxChoosableInteger):
                if visited & mask == 0:
                    if i + 1 >= desiredTotal or \
                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):
                        lookup[visited] = True
                        return True
                mask <<= 1
            lookup[visited] = False
            return False

        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
            return False

        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})",O(n!)
"class Solution2(object):
    def minTime(self, n, edges, hasApple):
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        result = [0]
        s = [(1, (-1, 0, result))]
        while s:
            step, params = s.pop()
            if step == 1:
                par, node, ret = params
                tmp = [int(hasApple[node])]
                s.append((3, (tmp, ret)))
                for nei in reversed(graph[node]):
                    if nei == par:
                        continue
                    new_ret = [0]
                    s.append((2, (new_ret, tmp, ret)))
                    s.append((1, (node, nei, new_ret)))
            elif step == 2:
                new_ret, tmp, ret = params
                ret[0] += new_ret[0]
                tmp[0] |= bool(new_ret[0])
            else:
                tmp, ret = params
                ret[0] += tmp[0]
        return 2*max(result[0]-1, 0)",O(n)
"class Solution(object):
    def secondsToRemoveOccurrences(self, s):
        result = cnt = 0
        for c in s: 
            if c == '0':
                cnt += 1
                continue
            if cnt:
                result = max(result+1, cnt)
        return result",O(n)
"n = int(input())

nums = list(map(int, input().split()))
costs = list(map(int, input().split()))

k = -1

for i in range(n):

    kc = -1
    for c in range(i + 1, n):
        if nums[i] < nums[c] and (kc == -1 or kc > costs[c]):
            if kc == -1:
                kc = costs[c]
            kc = costs[c]

    if kc > -1:
        nat = kc
        kc = -1
        for c in range(i):
            if nums[i] > nums[c] and (kc == -1 or kc > costs[c]):
                if kc == -1:
                    kc = costs[c]

                kc = costs[c]

        if kc > -1:
            if k == -1:
                k = nat + kc + costs[i]
            k = min(nat + kc + costs[i], k)

print(k)
",O(n ^ 2)
"import math,sys,bisect,heapq,os
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
from functools import lru_cache

pr = lambda x:    x
def input(): return sys.stdin.readline().rstrip('\r\n')

aj = lambda: list(map(int, input().split()))
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

def solve():
    n, = aj()
    A = aj()
    if A.count(0) >= 2:
        print('cslnb')
    elif n == 1:
        if A[0]%2:
            print('sjfnb')
        else:
            print('cslnb')
    else:
        g2 = 0;flag = 1
        C = Counter(A)
        for i in C.keys():
            if C[i] >= 3:
                flag = 0
            if C[i] == 2 and C[i-1] >= 1:
                flag = 0
            if C[i] == 2:
                g2 += 1
        if g2 >= 2:
            flag = 0
        if not flag:
            print('cslnb')
        else:
            movescount = 0
            A.sort()
            for ii,i in enumerate(A):
                movescount += i - ii
            if movescount % 2 == 0:
                print('cslnb')
            else:
                print('sjfnb')

try:

    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
    from aj import *
except:
    pass

solve()",O(nlogn)
"q = int(input())

for _ in range(q):
    n, m, k = map(int, input().split())
    if max([n, m]) > k:
        print(-1)
    else:
        if (n + m) % 2 == 0:
            if max([n, m]) % 2 != k % 2:
                print(k - 2)
            else:
                print(k)
        else:
            print(k - 1);
",O(1)
"class Solution(object):
    def maxSubArrayLen(self, nums, k):
        sums = {}
        cur_sum, max_len = 0, 0
        for i in range(len(nums)):
            cur_sum += nums[i]
            if cur_sum == k:
                max_len = i + 1
            elif cur_sum - k in sums:
                max_len = max(max_len, i - sums[cur_sum - k])
            if cur_sum not in sums:
                sums[cur_sum] = i 
        return max_len",O(n)
"import sys, math, queue, bisect

MOD = 998244353
sys.setrecursionlimit(1000000)

n = int(input())
if n < 10:
    print(n)
    exit()
d = 1
while n > 9*d*pow(10, d-1):
    n -= 9*d*pow(10, d-1)
    d += 1
x = pow(10, d-1) + (n-1)//d
p = n % d
x = str(x).zfill(d)
print(x[p-1])",O(logn)
"import collections


class Solution(object):
    def getFolderNames(self, names):
        count = collections.Counter()
        result, lookup = [], set()
        for name in names:
            while True:
                name_with_suffix = ""{}({})"".format(name, count[name]) if count[name] else name
                count[name] += 1
                if name_with_suffix not in lookup:
                    break
            result.append(name_with_suffix)
            lookup.add(name_with_suffix)
        return result",O(n)
"class Solution2(object):
    def grayCode(self, n):
        return [i >> 1 ^ i for i in range(1 << n)]",O(2 ^ n)
"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        res = nums[0]
        curMin, curMax = 1, 1

        for num in nums:
            tmp = curMax * num
            curMax = max(num * curMax, num * curMin, num)
            curMin = min(tmp, num * curMin, num)
            res = max(res, curMax)
        return res
",O(n)
"import sys
input=sys.stdin.buffer.readline

nr,ng,nb=[int(x) for x in input().split()]
r=[int(x) for x in input().split()]
g=[int(x) for x in input().split()]
b=[int(x) for x in input().split()]

r.sort()
g.sort()
b.sort()

memo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]
memo[0][0][0]=0
for i in range(nr):
    memo[i+1][0][0]=0
for j in range(ng):
    memo[0][j+1][0]=0
for k in range(nb):
    memo[0][0][k+1]=0
def dp(i,j,k):
    if i<-1 or j<-1 or k<-1:
        return -float('inf')
    if memo[i+1][j+1][k+1]==-1:
        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],
                   dp(i-1,j-1,k)+r[i]*g[j],
                   dp(i-1,j,k-1)+r[i]*b[k]
                )
    return memo[i+1][j+1][k+1]

for i in range(max(nr,ng,nb)):
    dp(min(i,nr-1),min(i,ng-1),min(i,nb-1))

print(dp(nr-1,ng-1,nb-1))",O(n ^ 3)
"class Solution(object):
    def reverseParentheses(self, s):
        stk, lookup = [], {}
        for i, c in enumerate(s):
            if c == '(':
                stk.append(i)
            elif c == ')':
                j = stk.pop()
                lookup[i], lookup[j] = j, i
        result = []
        i, d = 0, 1
        while i < len(s):
            if i in lookup:
                i = lookup[i]
                d *= -1
            else:
                result.append(s[i])
            i += d
        return """".join(result)",O(n)
"n = int(input())
a = sorted(list(map(int, input().split())))

win = None
first = True

if n == 1:
    win = a[0] % 2 == 1
elif a[1] == 0:
    win = False

if n > 2:
    for i in range(n-1):
        if a[i] == a[i+1]:
            if i > 0:
                if a[i-1] == a[i]-1:
                    win = False
                    break
            if not first:
                win = False
                break
            first = False

if win is None:
    win = (sum(a) - (n*(n-1)//2)) % 2 == 1

if win:
    print('sjfnb')
else:
    print('cslnb')
",O(nlogn)
"n = int(input())

if n == 3:
    print('1 1 3')
    exit()
if n == 1:
    print('1')
    exit()
if n == 2:
    print('1 2')
    exit()
d = 2
ans = []
lfn = n
while d <= n:
    k = n // d
    for j in range(lfn - k):
        ans.append(d//2)
    lfn = n - len(ans)
    d *=2
d //= 2
k = n/d
if k < 1.5:
    ans.append(d)
else:
    ans.append(d + d//2)
print(' '.join([str(i) for i in ans]))",O(nlogn)
"import sys

sys.setrecursionlimit(10**5)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
inf = 10**16
md = 10**9+7

a,b=MI()
x,y,z=MI()
yel=x*2+y
bul=y+z*3
print(max(0,yel-a)+max(0,bul-b))
",O(1)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

T, = getIntList()

MAXN = 10**18 + 10
def getUpper(N):
    z = 1
    r = 0
    for i in range(N):
        r+=z
        z*=4
        if r>MAXN:
            break
    return r
for _ in range(T):
    N,K = getIntList()
    tk = K
    z = 1
    for i in range(N):
        tk -= z
        z*= 4
        if tk<0: break
    if tk>0:
        print('NO')
        continue
    nowcut =  0
    nt = 1
    nowupper = 0
    ok = False
    for i in range(N):
        nt *=2
        nowcut += nt-1

        if nowcut >K: break
        t = (nt *2 - 3)
        tu  = t * getUpper(N-1-i)
        nowupper += tu
        dprint('bound', nowcut, nowcut+nowupper)
        if nowcut<=K<= nowcut+nowupper:
            ok = True
            break
    if ok:
        print('YES', N-1-i)
    else:
        print(""NO"")
",O(n ^ 2)
"from math import pi, sin

n, r = map(float, input().split())
ang = pi / n
k = sin(ang)
print(k * r /  (1 - k))
",O(1)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

za = getIntList()
if N==1:
    print(za[0])
    sys.exit()
t1 = max(za)
t2 = min(za)
if t2>=0:
    print(sum(za) - 2*t2)
    sys.exit()
if t1<=0:
    print(2*t1 - sum(za))
    sys.exit()

res = 0
for x in za:
    res+= abs(x)

print(res)
",O(n)
"import math
def C1():
    n, r = map(int, input().split())
    x_cord = [int(x) for x in input().split()]

    y_cord = []

    contactedDisk = 0
    for i, x in enumerate(x_cord):
        if len(y_cord) == 0:
            y_cord.append(r)
        else:
            y_cord.append(r)
            for j in range(i):
                diff = abs(x_cord[i] - x_cord[j])
                if diff <= 2 * r:
                    y_cord[i] = max(y_cord[i], math.sqrt(4*r*r - diff ** 2) + y_cord[j])

    for i in y_cord:
        print(i, end= "" "")

if __name__=='__main__':
    C1()
",O(n ^ 2)
"from bisect import insort,bisect_right,bisect_left
from sys import stdout, stdin, setrecursionlimit
from heapq import heappush, heappop, heapify
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from string import *
from queue import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
graph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())
def getStr(): return input()
def getInt(): return int(input())
def listStr(): return list(input())
def getStrs(): return input().split()
def isInt(s): return '0' <= s[0] <= '9'
def input(): return stdin.readline().strip()
def zzz(): return [int(i) for i in input().split()]
def output(answer, end='\n'): stdout.write(str(answer) + end)
def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))

def getPrimes(N = 10**5):
    SN = int(sqrt(N))
    sieve = [i for i in range(N+1)]
    sieve[1] = 0
    for i in sieve:
        if i > SN:
            break
        if i == 0:
            continue
        for j in range(2*i, N+1, i):
            sieve[j] = 0
    prime = [i for i in range(N+1) if sieve[i] != 0]
    return prime
def primeFactor(n,prime=getPrimes()):
    lst = []
    mx=int(sqrt(n))+1
    for i in prime:
        if i>mx:break
        while n%i==0:
            lst.append(i)
            n//=i
    if n>1:
        lst.append(n)
    return lst

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]
daysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

a = int(stdin.readline())
b = getInt()

ans = ''

c = sorted(list(str(a)))

while c:
    for i in range(len(c) - 1, -1, -1):
        if int(''.join(list(ans) + [c[i]] + c[:i] + c[i + 1:])) <= b:
            ans += c[i]
            c.pop(i)
            break

stdout.write(ans)
",O(n ^ 3)
"def mul(a, b, md) :
    if(b == 1) :
        return a
    if(b % 2 == 0) :
        t = mul(a, b // 2, md)
        return (2 * t) % md
    return (mul(a, b - 1, md) + a) % md;

def pows(a, b, md) :
    if(b == 0) :
        return 1
    if(b % 2 == 0) :
        t = pows(a, b // 2, md)
        return mul(t, t, md) % md
    return (mul(pows(a, b - 1, md) , a, md)) % md;

x, k = map(int, input().split())
ch = pows(2, k, 1000000007)
ans = pows(2, k + 1, 1000000007) * x - ch + 1
ans = ans % (1000000007)
if(x == 0) :
    ans = 0
print(ans)",O(logn)
"class Solution5(object):
    def lengthOfLIS(self, nums):
        dp = [] 
        for i in range(len(nums)):
            dp.append(1)
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp) if dp else 0",O(n ^ 2)
"n, m = map(int, input().split())
tc = [0]*m
ps = []
for _ in range(n):
    temp = input()
    psa = [0]*m
    for i in range(m):
        if temp[i] == '1':
            psa[i] += 1
            tc[i] += 1
    ps.append(psa)
ans = 'NO'

for i in ps:
    c = 0
    for j in range(m):
        if tc[j]-i[j] > 0:
            c += 1
    if c == m:
        ans = 'YES'
        break

print(ans)
",O(n ^ 2)
"class Solution(object):
    def reversePrefix(self, word, ch):
        i = word.find(ch)
        return word[:i+1][::-1]+word[i+1:]",O(n)
