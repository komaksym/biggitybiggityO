[
{"code": "class Solution:\n    def hasDuplicate(self, nums: List[int]) -> bool:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    return True\n        return False\n", "time_complexity": "O(n^2)"},
{"code": "class Solution:\n    def hasDuplicate(self, nums: List[int]) -> bool:\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:\n                return True\n        return False\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def hasDuplicate(self, nums: List[int]) -> bool:\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def hasDuplicate(self, nums: List[int]) -> bool:\n        return len(set(nums)) < len(nums)\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        return a + b\n", "time_complexity": "O(1)"},
{"code": "class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        carry = 0\n        res = 0\n        mask = 0xFFFFFFFF\n\n        for i in range(32):\n            a_bit = (a >> i) & 1\n            b_bit = (b >> i) & 1\n            cur_bit = a_bit ^ b_bit ^ carry\n            carry = (a_bit + b_bit + carry) >= 2\n            if cur_bit:\n                res |= (1 << i)\n\n        if res > 0x7FFFFFFF:\n            res = ~(res ^ mask)\n            \n        return res\n", "time_complexity": "O(1)"},
{"code": "class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        mask = 0xFFFFFFFF\n        max_int = 0x7FFFFFFF\n\n        while b != 0:\n            carry = (a & b) << 1\n            a = (a ^ b) & mask\n            b = carry & mask\n\n        return a if a <= max_int else ~(a ^ mask)\n", "time_complexity": "O(1)"},
{"code": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        nums.sort()\n        for i in range(n):\n            if nums[i] != i:\n                return i\n        return n\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        num_set = set(nums)\n        n = len(nums)\n        for i in range(n + 1):\n            if i not in num_set:\n                return i\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        xorr = n  \n        for i in range(n):\n            xorr ^= i ^ nums[i]\n        return xorr\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        res = len(nums)\n\n        for i in range(len(nums)):\n            res += i - nums[i]\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def reverse(self, x: int) -> int:\n        org = x\n        x = abs(x)\n        res = int(str(x)[::-1])\n        if org < 0:\n            res *= -1\n        if res < -(1 << 31) or res > (1 << 31) - 1:\n            return 0\n        return res\n", "time_complexity": "O(1)"},
{"code": "class Solution:\n    def reverse(self, x: int) -> int:\n        def rec(n: int, rev: int) -> int:\n            if n == 0:\n                return rev\n            \n            rev = rev * 10 + n % 10\n            return rec(n // 10, rev)\n        \n        sign = -1 if x < 0 else 1\n        x = abs(x)        \n        reversed_num = rec(x, 0)\n        reversed_num *= sign        \n        if reversed_num < -(1 << 31) or reversed_num > (1 << 31) - 1:\n            return 0\n            \n        return reversed_num\n", "time_complexity": "O(1)"},
{"code": "class Solution:\n    def reverse(self, x: int) -> int:\n        MIN = -2147483648  # -2^31,\n        MAX = 2147483647  #  2^31 - 1\n\n        res = 0\n        while x:\n            digit = int(math.fmod(x, 10))\n            x = int(x / 10)\n\n            if res > MAX // 10 or (res == MAX // 10 and digit > MAX % 10):\n                return 0\n            if res < MIN // 10 or (res == MIN // 10 and digit < MIN % 10):\n                return 0\n            res = (res * 10) + digit\n\n        return res\n", "time_complexity": "O(1)"},
{"code": "class CountSquares:\n    def __init__(self):\n        self.ptsCount = defaultdict(int)\n        self.pts = []\n\n    def add(self, point: List[int]) -> None:\n        self.ptsCount[tuple(point)] += 1\n        self.pts.append(point)\n\n    def count(self, point: List[int]) -> int:\n        res = 0\n        px, py = point\n        for x, y in self.pts:\n            if (abs(py - y) != abs(px - x)) or x == px or y == py:\n                continue\n            res += self.ptsCount[(x, py)] * self.ptsCount[(px, y)]\n        return res\n", "time_complexity": "O(1)$ for $add()$, $O(n)$ for $count()"},
{"code": "class CountSquares:\n\n    def __init__(self):\n        self.ptsCount = defaultdict(lambda: defaultdict(int))\n\n    def add(self, point: List[int]) -> None:\n        self.ptsCount[point[0]][point[1]] += 1\n\n    def count(self, point: List[int]) -> int:\n        res = 0\n        x1, y1 = point\n        for y2 in self.ptsCount[x1]:\n            side = y2 - y1\n            if side == 0:\n                continue\n\n            x3, x4 = x1 + side, x1 - side\n            res += (self.ptsCount[x1][y2] * self.ptsCount[x3][y1] *\n                    self.ptsCount[x3][y2])\n\n            res += (self.ptsCount[x1][y2] * self.ptsCount[x4][y1] *\n                    self.ptsCount[x4][y2])\n        return res\n", "time_complexity": "O(1)$ for $add()$, $O(n)$ for $count()"},
{"code": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        for i in range(32):\n            if (1 << i) & n:\n                res += 1\n        return res\n", "time_complexity": "O(1)"},
{"code": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        while n:\n            res += 1 if n & 1 else 0\n            n >>= 1\n        return res\n", "time_complexity": "O(1)"},
{"code": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        while n:\n            n &= n - 1\n            res += 1\n        return res\n", "time_complexity": "O(1)"},
{"code": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        return bin(n).count('1')\n", "time_complexity": "O(1)"},
{"code": "class Solution:\n    def reverseBits(self, n: int) -> int:\n        binary = \"\"\n        for i in range(32):\n            if n & (1 << i):\n                binary += \"1\"\n            else:\n                binary += \"0\"\n                \n        res = 0\n        for i, bit in enumerate(binary[::-1]):\n            if bit == \"1\":\n                res |= (1 << i)\n                \n        return res\n", "time_complexity": "O(1)"},
{"code": "class Solution:\n    def reverseBits(self, n: int) -> int:\n        res = 0\n        for i in range(32):\n            bit = (n >> i) & 1\n            res += (bit << (31 - i))\n        return res\n", "time_complexity": "O(1)"},
{"code": "class Solution:\n    def reverseBits(self, n: int) -> int:\n        res = n\n        res = (res >> 16) | (res << 16) & 0xFFFFFFFF\n        res = ((res & 0xff00ff00) >> 8) | ((res & 0x00ff00ff) << 8)\n        res = ((res & 0xf0f0f0f0) >> 4) | ((res & 0x0f0f0f0f) << 4)\n        res = ((res & 0xcccccccc) >> 2) | ((res & 0x33333333) << 2)\n        res = ((res & 0xaaaaaaaa) >> 1) | ((res & 0x55555555) << 1)\n        return res & 0xFFFFFFFF\n", "time_complexity": "O(1)"},
{"code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            flag = True\n            for j in range(len(nums)):\n                if i != j and nums[i] == nums[j]:\n                    flag = False\n                    break\n            if flag:\n                return nums[i]\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        seen = set()\n        for num in nums:\n            if num in seen:\n                seen.remove(num)\n            else:\n                seen.add(num)\n        return list(seen)[0]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        nums.sort()\n        i = 0\n        while i < len(nums) - 1:\n            if nums[i] == nums[i + 1]:\n                i += 2\n            else:\n                return nums[i]\n        return nums[i]\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        res = 0\n        for num in nums:\n            res = num ^ res\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        res = []\n        for num in range(n + 1):\n            one = 0\n            for i in range(32):\n                if num & (1 << i):\n                    one += 1\n            res.append(one)\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        res = [0] * (n + 1)\n        for i in range(1, n + 1):\n            num = i\n            while num != 0:\n                res[i] += 1\n                num &= (num - 1)\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        return [bin(i).count('1') for i in range(n + 1)]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        dp = [0] * (n + 1)\n        offset = 1\n\n        for i in range(1, n + 1):\n            if offset * 2 == i:\n                offset = i\n            dp[i] = 1 + dp[i - offset]\n        return dp\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        dp = [0] * (n + 1)\n        for i in range(n + 1):\n            dp[i] = dp[i >> 1] + (i & 1)\n        return dp\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        visit = set()\n\n        while n not in visit:\n            visit.add(n)\n            n = self.sumOfSquares(n)\n            if n == 1:\n                return True\n        return False\n\n    def sumOfSquares(self, n: int) -> int:\n        output = 0\n\n        while n:\n            digit = n % 10\n            digit = digit ** 2\n            output += digit\n            n = n // 10\n        return output\n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        slow, fast = n, self.sumOfSquares(n)\n\n        while slow != fast:\n            fast = self.sumOfSquares(fast)\n            fast = self.sumOfSquares(fast)\n            slow = self.sumOfSquares(slow)\n        return True if fast == 1 else False\n    \n    def sumOfSquares(self, n: int) -> int:\n        output = 0\n\n        while n:\n            digit = n % 10\n            digit = digit ** 2\n            output += digit\n            n = n // 10\n        return output\n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        slow, fast = n, self.sumOfSquares(n)\n        power = lam = 1\n        \n        while slow != fast:\n            if power == lam:\n                slow = fast\n                power *= 2\n                lam = 0\n            fast = self.sumOfSquares(fast)\n            lam += 1\n        return True if fast == 1 else False\n    \n    def sumOfSquares(self, n: int) -> int:\n        output = 0\n\n        while n:\n            digit = n % 10\n            digit = digit ** 2\n            output += digit\n            n = n // 10\n        return output\n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        if not digits:\n            return [1]\n\n        if digits[-1] < 9:\n            digits[-1] += 1\n            return digits\n        else:\n            return self.plusOne(digits[:-1]) + [0]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        one = 1\n        i = 0\n        digits = digits[::-1]\n\n        while one:\n            if i < len(digits):\n                if digits[i] == 9:\n                    digits[i] = 0\n                else:\n                    digits[i] += 1\n                    one = 0\n            else:\n                digits.append(one)\n                one = 0\n            i += 1\n        return digits[::-1]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        \n        return [1] + digits\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        mark = [[matrix[r][c] for c in range(COLS)] for r in range(ROWS)]\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if matrix[r][c] == 0:\n                    for col in range(COLS):\n                        mark[r][col] = 0\n                    for row in range(ROWS):\n                        mark[row][c] = 0\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                matrix[r][c] = mark[r][c]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        rows, cols = [False] * ROWS, [False] * COLS\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if matrix[r][c] == 0:\n                    rows[r] = True\n                    cols[c] = True\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if rows[r] or cols[c]:\n                    matrix[r][c] = 0\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        rowZero = False\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if matrix[r][c] == 0:\n                    matrix[0][c] = 0\n                    if r > 0:\n                        matrix[r][0] = 0\n                    else:\n                        rowZero = True\n\n        for r in range(1, ROWS):\n            for c in range(1, COLS):\n                if matrix[0][c] == 0 or matrix[r][0] == 0:\n                    matrix[r][c] = 0\n\n        if matrix[0][0] == 0:\n            for r in range(ROWS):\n                matrix[r][0] = 0\n\n        if rowZero:\n            for c in range(COLS):\n                matrix[0][c] = 0\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if x == 0:\n            return 0\n        if n == 0:\n            return 1\n\n        res = 1\n        for i in range(abs(n)):\n            res *= x\n        return res if n >= 0 else 1 / res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        def helper(x, n):\n            if x == 0:\n                return 0\n            if n == 0:\n                return 1\n\n            res = helper(x * x, n // 2)\n            return x * res if n % 2 else res\n\n        res = helper(x, abs(n))\n        return res if n >= 0 else 1 / res\n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if x == 0:\n            return 0\n        if n == 0:\n            return 1\n        \n        res = 1\n        power = abs(n)\n        \n        while power:\n            if power & 1:\n                res *= x\n            x *= x\n            power >>= 1\n        \n        return res if n >= 0 else 1 / res\n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        m, n = len(matrix), len(matrix[0])\n        res = []\n\n        # append all the elements in the given direction\n        def dfs(row, col, r, c, dr, dc):\n            if row == 0 or col == 0:\n                return\n            \n            for i in range(col):\n                r += dr\n                c += dc\n                res.append(matrix[r][c])\n\n            # sub-problem\n            dfs(col, row - 1, r, c, dc, -dr)\n        \n        # start by going to the right\n        dfs(m, n, 0, -1, 0, 1)\n        return res\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        res = []\n        left, right = 0, len(matrix[0])\n        top, bottom = 0, len(matrix)\n\n        while left < right and top < bottom:\n            for i in range(left, right):\n                res.append(matrix[top][i])\n            top += 1\n            for i in range(top, bottom):\n                res.append(matrix[i][right - 1])\n            right -= 1\n            if not (left < right and top < bottom):\n                break\n            for i in range(right - 1, left - 1, -1):\n                res.append(matrix[bottom - 1][i])\n            bottom -= 1\n            for i in range(bottom - 1, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n        return res\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        res = []\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        steps = [len(matrix[0]), len(matrix) - 1]\n\n        r, c, d = 0, -1, 0\n        while steps[d & 1]:\n            for i in range(steps[d & 1]):\n                r += directions[d][0]\n                c += directions[d][1]\n                res.append(matrix[r][c])\n            steps[d & 1] -= 1\n            d += 1\n            d %= 4\n        return res\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        n = len(matrix)\n        rotated = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(n):\n                rotated[j][n - 1 - i] = matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n):\n                matrix[i][j] = rotated[i][j]\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        l, r = 0, len(matrix) - 1\n        while l < r:\n            for i in range(r - l):\n                top, bottom = l, r\n\n                # save the topleft\n                topLeft = matrix[top][l + i]\n\n                # move bottom left into top left\n                matrix[top][l + i] = matrix[bottom - i][l]\n\n                # move bottom right into bottom left\n                matrix[bottom - i][l] = matrix[bottom][r - i]\n\n                # move top right into bottom right\n                matrix[bottom][r - i] = matrix[top + i][r]\n\n                # move top left into top right\n                matrix[top + i][r] = topLeft\n            r -= 1\n            l += 1\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        # Reverse the matrix vertically\n        matrix.reverse()\n\n        # Transpose the matrix\n        for i in range(len(matrix)):\n            for j in range(i + 1, len(matrix)):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        n = len(intervals)\n        res = []\n        for q in queries:\n            cur = -1\n            for l, r in intervals:\n                if l <= q <= r:\n                    if cur == -1 or (r - l + 1) < cur:\n                        cur = r - l + 1\n            res.append(cur)\n        return res\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        events = []\n        # Create events for intervals\n        for idx, (start, end) in enumerate(intervals):\n            events.append((start, 0, end - start + 1, idx))    \n            events.append((end, 2, end - start + 1, idx))      \n        \n        # Create events for queries\n        for i, q in enumerate(queries):\n            events.append((q, 1, i))\n        \n        # Sort by time and type (end before query)\n        events.sort(key=lambda x: (x[0], x[1]))\n        \n        # Min heap storing [size, index]\n        sizes = []  \n        ans = [-1] * len(queries)\n        inactive = [False] * len(intervals)\n        \n        for time, type, *rest in events:\n            if type == 0:  # Interval start\n                interval_size, idx = rest\n                heapq.heappush(sizes, (interval_size, idx))\n            elif type == 2: #Interval end\n                idx = rest[1]\n                inactive[idx] = True\n            else: # Query\n                query_idx = rest[0]\n                while sizes and inactive[sizes[0][1]]:\n                    heapq.heappop(sizes)\n                if sizes:\n                    ans[query_idx] = sizes[0][0]\n        \n        return ans\n", "time_complexity": "O((n + m) \\log (n + m))"},
{"code": "class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        intervals.sort()\n        minHeap = []\n        res = {}\n        i = 0\n        for q in sorted(queries):\n            while i < len(intervals) and intervals[i][0] <= q:\n                l, r = intervals[i]\n                heapq.heappush(minHeap, (r - l + 1, r))\n                i += 1\n\n            while minHeap and minHeap[0][1] < q:\n                heapq.heappop(minHeap)\n            res[q] = minHeap[0][0] if minHeap else -1\n        return [res[q] for q in queries]\n", "time_complexity": "O(n \\log n + m \\log m)"},
{"code": "class SegmentTree:\n    def __init__(self, N):\n        self.n = N\n        self.tree = [float('inf')] * (4 * N)\n        self.lazy = [float('inf')] * (4 * N)\n\n    def propagate(self, treeidx, lo, hi):\n        if self.lazy[treeidx] != float('inf'):\n            self.tree[treeidx] = min(self.tree[treeidx], self.lazy[treeidx])\n            if lo != hi:\n                self.lazy[2 * treeidx + 1] = min(self.lazy[2 * treeidx + 1], self.lazy[treeidx])\n                self.lazy[2 * treeidx + 2] = min(self.lazy[2 * treeidx + 2], self.lazy[treeidx])\n            self.lazy[treeidx] = float('inf')\n\n    def update(self, treeidx, lo, hi, left, right, val):\n        self.propagate(treeidx, lo, hi)\n        if lo > right or hi < left:\n            return\n        if lo >= left and hi <= right:\n            self.lazy[treeidx] = min(self.lazy[treeidx], val)\n            self.propagate(treeidx, lo, hi)\n            return\n        mid = (lo + hi) // 2\n        self.update(2 * treeidx + 1, lo, mid, left, right, val)\n        self.update(2 * treeidx + 2, mid + 1, hi, left, right, val)\n        self.tree[treeidx] = min(self.tree[2 * treeidx + 1], self.tree[2 * treeidx + 2])\n\n    def query(self, treeidx, lo, hi, idx):\n        self.propagate(treeidx, lo, hi)\n        if lo == hi:\n            return self.tree[treeidx]\n        mid = (lo + hi) // 2\n        if idx <= mid:\n            return self.query(2 * treeidx + 1, lo, mid, idx)\n        else:\n            return self.query(2 * treeidx + 2, mid + 1, hi, idx)\n\n    def update_range(self, left, right, val):\n        self.update(0, 0, self.n - 1, left, right, val)\n\n    def query_point(self, idx):\n        return self.query(0, 0, self.n - 1, idx)\n\nclass Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        points = []\n        for interval in intervals:\n            points.append(interval[0])\n            points.append(interval[1])\n        for q in queries:\n            points.append(q)\n\n        # Compress the coordinates\n        points = sorted(set(points))\n        compress = {points[i]: i for i in range(len(points))}\n\n        # Lazy Segment Tree\n        segTree = SegmentTree(len(points))\n\n        for interval in intervals:\n            start = compress[interval[0]]\n            end = compress[interval[1]]\n            length = interval[1] - interval[0] + 1\n            segTree.update_range(start, end, length)\n\n        ans = []\n        for q in queries:\n            idx = compress[q]\n            \n            # query for minSize\n            res = segTree.query_point(idx)\n            ans.append(res if res != float('inf') else -1)\n        return ans\n", "time_complexity": "O((n + m)\\log k)"},
{"code": "\"\"\"\nDefinition of Interval:\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\n\nclass Solution:\n    def minMeetingRooms(self, intervals: List[Interval]) -> int:\n        intervals.sort(key=lambda x: x.start)\n        min_heap = []\n\n        for interval in intervals:\n            if min_heap and min_heap[0] <= interval.start:\n                heapq.heappop(min_heap)\n            heapq.heappush(min_heap, interval.end)\n\n        return len(min_heap)\n", "time_complexity": "O(n \\log n)"},
{"code": "\"\"\"\nDefinition of Interval:\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\n\nclass Solution:\n    def minMeetingRooms(self, intervals: List[Interval]) -> int:\n        mp = defaultdict(int)\n        for i in intervals:\n            mp[i.start] += 1\n            mp[i.end] -= 1\n        prev = 0\n        res = 0\n        for i in sorted(mp.keys()):\n            prev += mp[i]\n            res = max(res, prev)\n        return res\n", "time_complexity": "O(n \\log n)"},
{"code": "\"\"\"\nDefinition of Interval:\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\n\nclass Solution:\n    def minMeetingRooms(self, intervals: List[Interval]) -> int:\n        start = sorted([i.start for i in intervals])\n        end = sorted([i.end for i in intervals])\n        \n        res = count = 0\n        s = e = 0\n        while s < len(intervals):\n            if start[s] < end[e]:\n                s += 1\n                count += 1\n            else:\n                e += 1\n                count -= 1\n            res = max(res, count)\n        return res\n", "time_complexity": "O(n \\log n)"},
{"code": "\"\"\"\nDefinition of Interval:\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\n\nclass Solution:\n    def minMeetingRooms(self, intervals: List[Interval]) -> int:\n        time = []\n        for i in intervals:\n            time.append((i.start, 1))\n            time.append((i.end, -1))\n        \n        time.sort(key=lambda x: (x[0], x[1]))\n        \n        res = count = 0\n        for t in time:\n            count += t[1]\n            res = max(res, count)\n        return res\n", "time_complexity": "O(n \\log n)"},
{"code": "\"\"\"\nDefinition of Interval:\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\n\nclass Solution:\n    def canAttendMeetings(self, intervals: List[Interval]) -> bool:\n        n = len(intervals)\n        for i in range(n):\n            A = intervals[i]\n            for j in range(i + 1, n):\n                B = intervals[j]\n                if min(A.end, B.end) > max(A.start, B.start):\n                    return False\n        return True\n", "time_complexity": "O(n ^ 2)"},
{"code": "\"\"\"\nDefinition of Interval:\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\n\nclass Solution:\n    def canAttendMeetings(self, intervals: List[Interval]) -> bool:\n        intervals.sort(key=lambda i: i.start)\n\n        for i in range(1, len(intervals)):\n            i1 = intervals[i - 1]\n            i2 = intervals[i]\n\n            if i1.end > i2.start:\n                return False\n        return True\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        \n        def dfs(i, prev):\n            if i == len(intervals):\n                return 0\n            res = dfs(i + 1, prev)\n            if prev == -1 or intervals[prev][1] <= intervals[i][0]:\n                res = max(res, 1 + dfs(i + 1, i))\n            return res\n        \n        return len(intervals) - dfs(0, -1)\n", "time_complexity": "O(2 ^ n)"},
{"code": "class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key = lambda x: x[1])\n        n = len(intervals)\n        memo = {}\n\n        def dfs(i):\n            if i in memo:\n                return memo[i]\n\n            res = 1\n            for j in range(i + 1, n):\n                if intervals[i][1] <= intervals[j][0]:\n                    res = max(res, 1 + dfs(j))\n            memo[i] = res\n            return res\n\n        return n - dfs(0)\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: x[1])\n        n = len(intervals)\n        dp = [0] * n  \n\n        for i in range(n):\n            dp[i] = 1 \n            for j in range(i):\n                if intervals[j][1] <= intervals[i][0]:  \n                    dp[i] = max(dp[i], 1 + dp[j])\n\n        max_non_overlapping = max(dp)  \n        return n - max_non_overlapping\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: x[1])\n        n = len(intervals)\n        dp = [0] * n\n        dp[0] = 1\n\n        def bs(r, target):\n            l = 0\n            while l < r:\n                m = (l + r) >> 1\n                if intervals[m][1] <= target:\n                    l = m + 1\n                else:\n                    r = m\n            return l\n\n        for i in range(1, n):\n            idx = bs(i, intervals[i][0])\n            if idx == 0:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[i - 1], 1 + dp[idx - 1])\n        return n - dp[n - 1]\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        res = 0\n        prevEnd = intervals[0][1]\n        \n        for start, end in intervals[1:]:\n            if start >= prevEnd:\n                prevEnd = end\n            else:\n                res += 1\n                prevEnd = min(end, prevEnd)\n        return res\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key = lambda pair: pair[1])\n        prevEnd = intervals[0][1]\n        res = 0\n\n        for i in range(1, len(intervals)):\n            if prevEnd > intervals[i][0]:\n                res += 1\n            else:\n                prevEnd = intervals[i][1]\n\n        \n        return res\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key=lambda pair: pair[0])\n        output = [intervals[0]]\n\n        for start, end in intervals:\n            lastEnd = output[-1][1]\n\n            if start <= lastEnd:\n                output[-1][1] = max(lastEnd, end)\n            else:\n                output.append([start, end])\n        return output\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        mp = defaultdict(int)\n        for start, end in intervals:\n            mp[start] += 1\n            mp[end] -= 1\n\n        res = []\n        interval = []\n        have = 0\n        for i in sorted(mp):\n            if not interval:\n                interval.append(i)\n            have += mp[i]\n            if have == 0:\n                interval.append(i)\n                res.append(interval)\n                interval = []\n        return res\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        max_val = max(interval[0] for interval in intervals)\n        \n        mp = [0] * (max_val + 1)\n        for start, end in intervals:\n            mp[start] = max(end + 1, mp[start])\n\n        res = []\n        have = -1\n        interval_start = -1\n        for i in range(len(mp)):\n            if mp[i] != 0:\n                if interval_start == -1:\n                    interval_start = i\n                have = max(mp[i] - 1, have)\n            if have == i:\n                res.append([interval_start, have])\n                have = -1\n                interval_start = -1\n\n        if interval_start != -1:\n            res.append([interval_start, have])\n\n        return res\n", "time_complexity": "O(n + m)"},
{"code": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        n = len(intervals)\n        i = 0\n        res = []\n\n        while i < n and intervals[i][1] < newInterval[0]:\n            res.append(intervals[i])\n            i += 1\n\n        while i < n and newInterval[1] >= intervals[i][0]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        res.append(newInterval)\n\n        while i < n:\n            res.append(intervals[i])\n            i += 1\n\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        if not intervals:\n            return [newInterval]\n\n        n = len(intervals)\n        target = newInterval[0]\n        left, right = 0, n - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if intervals[mid][0] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        intervals.insert(left, newInterval)\n\n        res = []\n        for interval in intervals:\n            if not res or res[-1][1] < interval[0]:\n                res.append(interval)\n            else:\n                res[-1][1] = max(res[-1][1], interval[1])\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        res = []\n\n        for i in range(len(intervals)):\n            if newInterval[1] < intervals[i][0]:\n                res.append(newInterval)\n                return res + intervals[i:]\n            elif newInterval[0] > intervals[i][1]:\n                res.append(intervals[i])\n            else:\n                newInterval = [\n                    min(newInterval[0], intervals[i][0]),\n                    max(newInterval[1], intervals[i][1]),\n                ]\n        res.append(newInterval)\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def checkValidString(self, s: str) -> bool:\n        \n        def dfs(i, open):\n            if open < 0:\n                return False\n            if i == len(s):\n                return open == 0\n            \n            if s[i] == '(':\n                return dfs(i + 1, open + 1)\n            elif s[i] == ')':\n                return dfs(i + 1, open - 1)\n            else:\n                return (dfs(i + 1, open) or\n                        dfs(i + 1, open + 1) or\n                        dfs(i + 1, open - 1))\n        return dfs(0, 0)\n", "time_complexity": "O(3 ^ n)"},
{"code": "class Solution:\n    def checkValidString(self, s: str) -> bool:\n        n = len(s)\n        memo = [[None] * (n + 1) for _ in range(n + 1)]\n\n        def dfs(i, open):\n            if open < 0:\n                return False\n            if i == n:\n                return open == 0\n            if memo[i][open] is not None:\n                return memo[i][open]\n            \n            if s[i] == '(':\n                result = dfs(i + 1, open + 1)\n            elif s[i] == ')':\n                result = dfs(i + 1, open - 1)\n            else:\n                result = (dfs(i + 1, open) or \n                          dfs(i + 1, open + 1) or \n                          dfs(i + 1, open - 1))\n            \n            memo[i][open] = result\n            return result\n\n        return dfs(0, 0)\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def checkValidString(self, s: str) -> bool:\n        n = len(s)\n        dp = [[False] * (n + 1) for _ in range(n + 1)]\n        dp[n][0] = True\n\n        for i in range(n - 1, -1, -1):\n            for open in range(n):\n                res = False\n                if s[i] == '*':\n                    res |= dp[i + 1][open + 1]\n                    if open > 0:\n                        res |= dp[i + 1][open - 1]\n                    res |= dp[i + 1][open]\n                else:\n                    if s[i] == '(':\n                        res |= dp[i + 1][open + 1]\n                    elif open > 0:\n                        res |= dp[i + 1][open - 1]\n                dp[i][open] = res\n\n        return dp[0][0]\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def checkValidString(self, s: str) -> bool:\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n\n        for i in range(n - 1, -1, -1):\n            new_dp = [False] * (n + 1)\n            for open in range(n):\n                if s[i] == '*':\n                    new_dp[open] = (dp[open + 1] or \n                                    (open > 0 and dp[open - 1]) or \n                                    dp[open])\n                elif s[i] == '(':\n                    new_dp[open] = dp[open + 1]\n                elif open > 0:\n                    new_dp[open] = dp[open - 1]\n            dp = new_dp\n\n        return dp[0]\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def checkValidString(self, s: str) -> bool:\n        left = []\n        star = []\n        for i, ch in enumerate(s):\n            if ch == '(':\n                left.append(i)\n            elif ch == '*':\n                star.append(i)\n            else:\n                if not left and not star:\n                    return False\n                if left:\n                    left.pop()\n                else:\n                    star.pop()\n        \n        while left and star:\n            if left.pop() > star.pop():\n                return False\n        return not left\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def checkValidString(self, s: str) -> bool:\n        leftMin, leftMax = 0, 0\n\n        for c in s:\n            if c == \"(\":\n                leftMin, leftMax = leftMin + 1, leftMax + 1\n            elif c == \")\":\n                leftMin, leftMax = leftMin - 1, leftMax - 1\n            else:\n                leftMin, leftMax = leftMin - 1, leftMax + 1\n            if leftMax < 0:\n                return False\n            if leftMin < 0:\n                leftMin = 0\n        return leftMin == 0\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def isNStraightHand(self, hand, groupSize):\n        if len(hand) % groupSize:\n            return False\n        count = Counter(hand)\n        hand.sort()\n        for num in hand:\n            if count[num]:\n                for i in range(num, num + groupSize):\n                    if not count[i]:\n                        return False\n                    count[i] -= 1\n        return True\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        if len(hand) % groupSize:\n            return False\n\n        count = {}\n        for n in hand:\n            count[n] = 1 + count.get(n, 0)\n\n        minH = list(count.keys())\n        heapq.heapify(minH)\n        while minH:\n            first = minH[0]\n            for i in range(first, first + groupSize):\n                if i not in count:\n                    return False\n                count[i] -= 1\n                if count[i] == 0:\n                    if i != minH[0]:\n                        return False\n                    heapq.heappop(minH)\n        return True\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def isNStraightHand(self, hand, groupSize):\n        if len(hand) % groupSize != 0:\n            return False\n\n        count = Counter(hand)\n        q = deque()\n        last_num, open_groups = -1, 0\n\n        for num in sorted(count):\n            if ((open_groups > 0 and num > last_num + 1) or \n                open_groups > count[num]\n            ):\n                return False\n\n            q.append(count[num] - open_groups)\n            last_num = num\n            open_groups = count[num]\n\n            if len(q) == groupSize:\n                open_groups -= q.popleft()\n\n        return open_groups == 0\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        if len(hand) % groupSize != 0:\n            return False\n        count = Counter(hand)\n        for num in hand:\n            start = num\n            while count[start - 1]:\n                start -= 1\n            while start <= num:\n                while count[start]:\n                    for i in range(start, start + groupSize):\n                        if not count[i]:\n                            return False\n                        count[i] -= 1\n                start += 1\n        return True\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def partitionLabels(self, s: str) -> List[int]:\n        lastIndex = {}\n        for i, c in enumerate(s):\n            lastIndex[c] = i\n        \n        res = []\n        size = end = 0\n        for i, c in enumerate(s):\n            size += 1\n            end = max(end, lastIndex[c])\n\n            if i == end:\n                res.append(size)\n                size = 0\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n        good = set()\n\n        for t in triplets:\n            if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:\n                continue\n            for i, v in enumerate(t):\n                if v == target[i]:\n                    good.add(i)\n        return len(good) == 3\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n        x = y = z = False\n        for t in triplets:\n            x |= (t[0] == target[0] and t[1] <= target[1] and t[2] <= target[2])\n            y |= (t[0] <= target[0] and t[1] == target[1] and t[2] <= target[2])\n            z |= (t[0] <= target[0] and t[1] <= target[1] and t[2] == target[2])\n            if x and y and z:\n                return True\n        return False\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        if len(num1) < len(num2):\n            return self.multiply(num2, num1)\n        \n        res, zero = \"\", 0\n        for i in range(len(num2) - 1, -1, -1):\n            cur = self.mul(num1, num2[i], zero)\n            res = self.add(res, cur)\n            zero += 1\n        \n        return res\n    \n    def mul(self, s: str, d: str, zero: int) -> str:\n        i, carry = len(s) - 1, 0\n        d = int(d)\n        cur = []\n\n        while i >= 0 or carry:\n            n = int(s[i]) if i >= 0 else 0\n            prod = n * d + carry\n            cur.append(str(prod % 10))\n            carry = prod // 10\n            i -= 1\n        \n        return ''.join(cur[::-1]) + '0' * zero\n\n    def add(self, num1: str, num2: str) -> str:\n        i, j, carry = len(num1) - 1, len(num2) - 1, 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            n1 = int(num1[i]) if i >= 0 else 0\n            n2 = int(num2[j]) if j >= 0 else 0\n            total = n1 + n2 + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n        \n        return ''.join(res[::-1])\n", "time_complexity": "O(min(m, n) * (m + n))"},
{"code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if \"0\" in [num1, num2]:\n            return \"0\"\n\n        res = [0] * (len(num1) + len(num2))\n        num1, num2 = num1[::-1], num2[::-1]\n        for i1 in range(len(num1)):\n            for i2 in range(len(num2)):\n                digit = int(num1[i1]) * int(num2[i2])\n                res[i1 + i2] += digit\n                res[i1 + i2 + 1] += res[i1 + i2] // 10\n                res[i1 + i2] = res[i1 + i2] % 10\n\n        res, beg = res[::-1], 0\n        while beg < len(res) and res[beg] == 0:\n            beg += 1\n        res = map(str, res[beg:])\n        return \"\".join(res)\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n\n        for i in range(n):\n            tank = gas[i] - cost[i]\n            if tank < 0:\n                continue\n            j = (i + 1) % n\n            while j != i:\n                tank += gas[j]\n                tank -= cost[j]\n                if tank < 0:\n                    break\n                j += 1\n                j %= n\n            if j == i:\n                return i\n        return -1\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        start, end = n - 1, 0\n        tank = gas[start] - cost[start]\n        while start > end:\n            if tank < 0:\n                start -= 1\n                tank += gas[start] - cost[start]\n            else:\n                tank += gas[end] - cost[end]\n                end += 1\n        return start if tank >= 0 else -1\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        if sum(gas) < sum(cost):\n            return -1\n\n        total = 0\n        res = 0\n        for i in range(len(gas)):\n            total += (gas[i] - cost[i])\n\n            if total < 0:\n                total = 0\n                res = i + 1\n        \n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        def dfs(i):\n            if i == len(nums) - 1:\n                return 0\n            if nums[i] == 0:\n                return float('inf')\n\n            end = min(len(nums) - 1, i + nums[i])\n            res = float('inf')\n            for j in range(i + 1, end + 1):\n                res = min(res, 1 + dfs(j))\n            return res\n\n        return dfs(0)\n", "time_complexity": "O(n!)"},
{"code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        memo = {}\n\n        def dfs(i):\n            if i in memo:\n                return memo[i]\n            if i == len(nums) - 1:\n                return 0\n            if nums[i] == 0:\n                return 1000000\n            \n            res = 1000000\n            end = min(len(nums), i + nums[i] + 1)\n            for j in range(i + 1, end):\n                res = min(res, 1 + dfs(j))\n            memo[i] = res\n            return res\n\n        return dfs(0)\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [1000000] * n\n        dp[-1] = 0\n\n        for i in range(n - 2, -1, -1):\n            end = min(n, i + nums[i] + 1)\n            for j in range(i + 1, end):\n                dp[i] = min(dp[i], 1 + dp[j])\n        return dp[0]\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        res = 0\n        l = r = 0\n\n        while r < len(nums) - 1:\n            farthest = 0\n            for i in range(l, r + 1):\n                farthest = max(farthest, i + nums[i])\n            l = r + 1\n            r = farthest\n            res += 1\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        n, res = len(nums), nums[0]\n        for i in range(n):\n            cur = 0\n            for j in range(i, n):\n                cur += nums[j]\n                res = max(res, cur)\n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        def dfs(i, flag):\n            if i == len(nums):\n                return 0 if flag else -1e6\n            if flag:\n                return max(0, nums[i] + dfs(i + 1, True))\n            return max(dfs(i + 1, False), nums[i] + dfs(i + 1, True))\n        return dfs(0, False)\n", "time_complexity": "O(2 ^ n)"},
{"code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        memo = [[None] * 2 for _ in range(len(nums) + 1)]\n\n        def dfs(i, flag):\n            if i == len(nums):\n                return 0 if flag else -1e6\n            if memo[i][flag] is not None:\n                return memo[i][flag]\n            if flag:\n                memo[i][flag] = max(0, nums[i] + dfs(i + 1, True))\n            else:\n                memo[i][flag] = max(dfs(i + 1, False), \n                                    nums[i] + dfs(i + 1, True))\n            return memo[i][flag]\n\n        return dfs(0, False)\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0] * 2 for _ in range(n)]\n        dp[n - 1][1] = dp[n - 1][0] = nums[n - 1]\n        for i in range(n - 2, -1, -1):\n            dp[i][1] = max(nums[i], nums[i] + dp[i + 1][1])\n            dp[i][0] = max(dp[i + 1][0], dp[i][1])\n        \n        return dp[0][0]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxSubArray(self, nums):\n        dp = [*nums]\n        for i in range(1, len(nums)):\n            dp[i] = max(nums[i], nums[i] + dp[i - 1])\n        return max(dp)\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        maxSub, curSum = nums[0], 0\n        for num in nums:\n            if curSum < 0:\n                curSum = 0\n            curSum += num\n            maxSub = max(maxSub, curSum)\n        return maxSub\n\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        def dfs(l, r):\n            if l > r:\n                return float(\"-inf\")\n\n            m = (l + r) >> 1\n            leftSum = rightSum = curSum = 0\n            for i in range(m - 1, l - 1, -1):\n                curSum += nums[i]\n                leftSum = max(leftSum, curSum)\n\n            curSum = 0\n            for i in range(m + 1, r + 1):\n                curSum += nums[i]\n                rightSum = max(rightSum, curSum)\n\n            return (max(dfs(l, m - 1), \n                        dfs(m + 1, r), \n                        leftSum + nums[m] + rightSum))\n                        \n        return dfs(0, len(nums) - 1)\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n\n        def dfs(i, j):\n            if i == m:\n                return n - j\n            if j == n:\n                return m - i\n            if word1[i] == word2[j]:\n                return dfs(i + 1, j + 1)\n            res = min(dfs(i + 1, j), dfs(i, j + 1))\n            res = min(res, dfs(i + 1, j + 1))\n            return res + 1\n        \n        return dfs(0, 0)\n", "time_complexity": "O(3 ^ {m + n})"},
{"code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n\n        dp = {}\n        def dfs(i, j):\n            if i == m:\n                return n - j\n            if j == n:\n                return m - i\n            if (i, j) in dp:\n                return dp[(i, j)]\n                \n            if word1[i] == word2[j]:\n                dp[(i, j)] = dfs(i + 1, j + 1)\n            else:\n                res = min(dfs(i + 1, j), dfs(i, j + 1))\n                res = min(res, dfs(i + 1, j + 1))\n                dp[(i, j)] = res + 1\n            return dp[(i, j)]\n        \n        return dfs(0, 0)\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        dp = [[float(\"inf\")] * (len(word2) + 1) for i in range(len(word1) + 1)]\n\n        for j in range(len(word2) + 1):\n            dp[len(word1)][j] = len(word2) - j\n        for i in range(len(word1) + 1):\n            dp[i][len(word2)] = len(word1) - i\n\n        for i in range(len(word1) - 1, -1, -1):\n            for j in range(len(word2) - 1, -1, -1):\n                if word1[i] == word2[j]:\n                    dp[i][j] = dp[i + 1][j + 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1])\n        return dp[0][0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        if m < n:\n            m, n = n, m\n            word1, word2 = word2, word1\n\n        dp = [0] * (n + 1)\n        nextDp = [0] * (n + 1)\n\n        for j in range(n + 1):\n            dp[j] = n - j\n\n        for i in range(m - 1, -1, -1):\n            nextDp[n] = m - i\n            for j in range(n - 1, -1, -1):\n                if word1[i] == word2[j]:\n                    nextDp[j] = dp[j + 1]\n                else:\n                    nextDp[j] = 1 + min(dp[j], nextDp[j + 1], dp[j + 1])\n            dp = nextDp[:]\n        \n        return dp[0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        if m < n:\n            m, n = n, m\n            word1, word2 = word2, word1\n        \n        dp = [n - i for i in range(n + 1)]\n\n        for i in range(m - 1, -1, -1):\n            nextDp = dp[n]\n            dp[n] = m - i\n            for j in range(n - 1, -1, -1):\n                temp = dp[j]\n                if word1[i] == word2[j]:\n                    dp[j] = nextDp\n                else:\n                    dp[j] = 1 + min(dp[j], dp[j + 1], nextDp)\n                nextDp = temp\n        return dp[0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n\n        def dfs(i, j):\n            if j == n:\n                return i == m\n            \n            match = i < m and (s[i] == p[j] or p[j] == \".\")\n            if (j + 1) < n and p[j + 1] == \"*\":\n                return (dfs(i, j + 2) or          # don't use * \n                       (match and dfs(i + 1, j))) # use *\n            if match:\n                return dfs(i + 1, j + 1)\n            return False\n        \n        return dfs(0, 0)\n", "time_complexity": "O(2 ^ {m + n})"},
{"code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        cache = {}\n\n        def dfs(i, j):\n            if j == n:\n                return i == m\n            if (i, j) in cache:\n                return cache[(i, j)]\n\n            match = i < m and (s[i] == p[j] or p[j] == \".\")\n            if (j + 1) < n and p[j + 1] == \"*\":\n                cache[(i, j)] = (dfs(i, j + 2) or \n                                (match and dfs(i + 1, j)))\n                return cache[(i, j)]\n\n            if match:\n                cache[(i, j)] = dfs(i + 1, j + 1)\n                return cache[(i, j)]\n                \n            cache[(i, j)] = False\n            return False\n        \n        return dfs(0, 0)\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        dp = [[False] * (len(p) + 1) for i in range(len(s) + 1)]\n        dp[len(s)][len(p)] = True\n\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                match = i < len(s) and (s[i] == p[j] or p[j] == \".\")\n\n                if (j + 1) < len(p) and p[j + 1] == \"*\":\n                    dp[i][j] = dp[i][j + 2]\n                    if match:\n                        dp[i][j] = dp[i + 1][j] or dp[i][j]\n                elif match:\n                    dp[i][j] = dp[i + 1][j + 1]\n\n        return dp[0][0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        dp = [False] * (len(p) + 1)\n        dp[len(p)] = True\n        \n        for i in range(len(s), -1, -1):\n            nextDp = [False] * (len(p) + 1)\n            nextDp[len(p)] = (i == len(s))\n\n            for j in range(len(p) - 1, -1, -1):\n                match = i < len(s) and (s[i] == p[j] or p[j] == \".\")\n                \n                if (j + 1) < len(p) and p[j + 1] == \"*\":\n                    nextDp[j] = nextDp[j + 2]\n                    if match:\n                        nextDp[j] |= dp[j]\n                elif match:\n                    nextDp[j] = dp[j + 1]\n            \n            dp = nextDp\n        \n        return dp[0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        dp = [False] * (len(p) + 1)\n        dp[len(p)] = True\n        \n        for i in range(len(s), -1, -1):\n            dp1 = dp[len(p)]\n            dp[len(p)] = (i == len(s))\n            \n            for j in range(len(p) - 1, -1, -1):\n                match = i < len(s) and (s[i] == p[j] or p[j] == \".\")\n                res = False\n                if (j + 1) < len(p) and p[j + 1] == \"*\":\n                    res = dp[j + 2]\n                    if match:\n                        res |= dp[j]\n                elif match:\n                    res = dp1\n                dp[j], dp1 = res, dp[j]\n\n        return dp[0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        nums = [1] + nums + [1]\n\n        def dfs(nums):\n            if len(nums) == 2:\n                return 0\n\n            maxCoins = 0\n            for i in range(1, len(nums) - 1):\n                coins = nums[i - 1] * nums[i] * nums[i + 1]\n                coins += dfs(nums[:i] + nums[i + 1:])\n                maxCoins = max(maxCoins, coins)\n            return maxCoins\n\n        return dfs(nums)\n", "time_complexity": "O(n*2^n)"},
{"code": "class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        nums = [1] + nums + [1]\n        dp = {}\n        def dfs(l, r):\n            if l > r:\n                return 0\n            if (l, r) in dp:\n                return dp[(l, r)]\n\n            dp[(l, r)] = 0\n            for i in range(l, r + 1):\n                coins = nums[l - 1] * nums[i] * nums[r + 1]\n                coins += dfs(l, i - 1) + dfs(i + 1, r)\n                dp[(l, r)] = max(dp[(l, r)], coins)\n            return dp[(l, r)]\n\n        return dfs(1, len(nums) - 2)\n", "time_complexity": "O(n ^ 3)"},
{"code": "class Solution:\n    def maxCoins(self, nums):\n        n = len(nums)\n        new_nums = [1] + nums + [1]\n\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\n        for l in range(n, 0, -1):\n            for r in range(l, n + 1):\n                for i in range(l, r + 1):\n                    coins = new_nums[l - 1] * new_nums[i] * new_nums[r + 1]\n                    coins += dp[l][i - 1] + dp[i + 1][r]\n                    dp[l][r] = max(dp[l][r], coins)\n\n        return dp[1][n]\n", "time_complexity": "O(n^3)"},
{"code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        def dfs(i):\n            if i == len(nums) - 1:\n                return True\n            end = min(len(nums) - 1, i + nums[i])\n            for j in range(i + 1, end + 1):\n                if dfs(j):\n                    return True\n            return False\n\n        return dfs(0)\n", "time_complexity": "O(n!)"},
{"code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        memo = {}\n\n        def dfs(i):\n            if i in memo:\n                return memo[i]\n            if i == len(nums) - 1:\n                return True\n            if nums[i] == 0:\n                return False\n            \n            end = min(len(nums), i + nums[i] + 1)\n            for j in range(i + 1, end):\n                if dfs(j):\n                    memo[i] = True\n                    return True\n            memo[i] = False\n            return False\n\n        return dfs(0)\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        n = len(nums)\n        dp = [False] * n\n        dp[-1] = True\n\n        for i in range(n - 2, -1, -1):\n            end = min(n, i + nums[i] + 1)\n            for j in range(i + 1, end):\n                if dp[j]:\n                    dp[i] = True\n                    break\n        return dp[0]\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        goal = len(nums) - 1\n\n        for i in range(len(nums) - 2, -1, -1):\n            if i + nums[i] >= goal:\n                goal = i\n        return goal == 0\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        \n        def dfs(i, j, k):\n            if k == len(s3):\n                return (i == len(s1)) and (j == len(s2))\n            \n            if i < len(s1) and s1[i] == s3[k]:\n                if dfs(i + 1, j, k + 1):\n                    return True\n            \n            if j < len(s2) and s2[j] == s3[k]:\n                if dfs(i, j + 1, k + 1):\n                    return True\n            \n            return False\n        \n        return dfs(0, 0, 0)\n", "time_complexity": "O(2 ^ {m + n})"},
{"code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = {}\n        def dfs(i, j, k):\n            if k == len(s3):\n                return (i == len(s1)) and (j == len(s2))\n            if (i, j) in dp:\n                return dp[(i, j)]\n            \n            res = False\n            if i < len(s1) and s1[i] == s3[k]:\n                res = dfs(i + 1, j, k + 1)\n            if not res and j < len(s2) and s2[j] == s3[k]:\n                res = dfs(i, j + 1, k + 1)\n            \n            dp[(i, j)] = res\n            return res\n        \n        return dfs(0, 0, 0)\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for i in range(len(s1) + 1)]\n        dp[len(s1)][len(s2)] = True\n\n        for i in range(len(s1), -1, -1):\n            for j in range(len(s2), -1, -1):\n                if i < len(s1) and s1[i] == s3[i + j] and dp[i + 1][j]:\n                    dp[i][j] = True\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\n                    dp[i][j] = True\n        return dp[0][0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        m, n = len(s1), len(s2)\n        if m + n != len(s3):\n            return False\n        if n < m:\n            s1, s2 = s2, s1\n            m, n = n, m\n        \n        dp = [False for _ in range(n + 1)]\n        dp[n] = True\n        for i in range(m, -1, -1):\n            nextDp = [False for _ in range(n + 1)]\n            nextDp[n] = True\n            for j in range(n, -1, -1):\n                if i < m and s1[i] == s3[i + j] and dp[j]:\n                    nextDp[j] = True\n                if j < n and s2[j] == s3[i + j] and nextDp[j + 1]:\n                    nextDp[j] = True\n            dp = nextDp\n        return dp[0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        m, n = len(s1), len(s2)\n        if m + n != len(s3):\n            return False\n        if n < m:\n            s1, s2 = s2, s1\n            m, n = n, m\n        \n        dp = [False for _ in range(n + 1)]\n        dp[n] = True\n        for i in range(m, -1, -1):\n            nextDp = True\n            for j in range(n - 1, -1, -1):\n                res = False\n                if i < m and s1[i] == s3[i + j] and dp[j]:\n                    res = True\n                if j < n and s2[j] == s3[i + j] and nextDp:\n                    res = True\n                dp[j] = res\n                nextDp = dp[j]\n        return dp[0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        coins.sort()\n\n        def dfs(i, a):\n            if a == 0:\n                return 1\n            if i >= len(coins):\n                return 0\n\n            res = 0\n            if a >= coins[i]:\n                res = dfs(i + 1, a)\n                res += dfs(i, a - coins[i])\n            return res\n\n        return dfs(0, amount)\n", "time_complexity": "O(2 ^ {max(n, \\frac{a}{m})})"},
{"code": "class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        coins.sort()\n        memo = [[-1] * (amount + 1) for _ in range(len(coins) + 1)]\n\n        def dfs(i, a):\n            if a == 0:\n                return 1\n            if i >= len(coins):\n                return 0\n            if memo[i][a] != -1:\n                return memo[i][a]\n            \n            res = 0\n            if a >= coins[i]:\n                res = dfs(i + 1, a)\n                res += dfs(i, a - coins[i])\n\n            memo[i][a] = res\n            return res\n\n        return dfs(0, amount)\n", "time_complexity": "O(n * a)"},
{"code": "class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        n = len(coins)\n        coins.sort()\n        dp = [[0] * (amount + 1) for _ in range(n + 1)]\n        \n        for i in range(n + 1):\n            dp[i][0] = 1\n        \n        for i in range(n - 1, -1, -1):\n            for a in range(amount + 1):\n                if a >= coins[i]:\n                    dp[i][a] = dp[i + 1][a]  \n                    dp[i][a] += dp[i][a - coins[i]]  \n\n        return dp[0][amount]\n", "time_complexity": "O(n * a)"},
{"code": "class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for i in range(len(coins) - 1, -1, -1):\n            nextDP = [0] * (amount + 1)\n            nextDP[0] = 1\n\n            for a in range(1, amount + 1):\n                nextDP[a] = dp[a]\n                if a - coins[i] >= 0:\n                    nextDP[a] += nextDP[a - coins[i]]\n            dp = nextDP\n        return dp[amount]\n", "time_complexity": "O(n * a)"},
{"code": "class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for i in range(len(coins) - 1, -1, -1):\n            for a in range(1, amount + 1):\n                dp[a] += dp[a - coins[i]] if coins[i] <= a else 0\n        return dp[amount]\n", "time_complexity": "O(n * a)"},
{"code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        \n        def backtrack(i, total):\n            if i ==len(nums):\n                return  total == target\n            \n            return (backtrack(i + 1, total + nums[i]) + \n                    backtrack(i + 1, total - nums[i]))\n                \n        return backtrack(0, 0)\n", "time_complexity": "O(2 ^ n)"},
{"code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        dp = {}  # (index, total) -> # of ways\n\n        def backtrack(i, total):\n            if i == len(nums):\n                return 1 if total == target else 0\n            if (i, total) in dp:\n                return dp[(i, total)]\n\n            dp[(i, total)] = (backtrack(i + 1, total + nums[i]) + \n                              backtrack(i + 1, total - nums[i]))\n            return dp[(i, total)]\n\n        return backtrack(0, 0)\n", "time_complexity": "O(n * m)"},
{"code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [defaultdict(int) for _ in range(n + 1)]\n        dp[0][0] = 1\n\n        for i in range(n):\n            for total, count in dp[i].items():\n                dp[i + 1][total + nums[i]] += count\n                dp[i + 1][total - nums[i]] += count\n\n        return dp[n][target]\n", "time_complexity": "O(n * m)"},
{"code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        dp = defaultdict(int)\n        dp[0] = 1\n\n        for num in nums:\n            next_dp = defaultdict(int)\n            for total, count in dp.items():\n                next_dp[total + num] += count\n                next_dp[total - num] += count\n            dp = next_dp\n            \n        return dp[target]\n", "time_complexity": "O(n * m)"},
{"code": "class Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\n        def dfs(r, c, prevVal):\n            if (min(r, c) < 0 or r >= ROWS or \n                c >= COLS or matrix[r][c] <= prevVal\n            ):\n                return 0\n            \n            res = 1\n            for d in directions:\n                res = max(res, 1 + dfs(r + d[0], c + d[1], matrix[r][c]))\n            return res\n\n        LIP = 0\n        for r in range(ROWS):\n            for c in range(COLS):\n                LIP = max(LIP, dfs(r, c, float('-inf')))\n        return LIP\n", "time_complexity": "O(m * n * 4 ^ {m * n})"},
{"code": "class Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        dp = {}  # (r, c) -> LIP\n\n        def dfs(r, c, prevVal):\n            if (r < 0 or r == ROWS or c < 0 or \n                c == COLS or matrix[r][c] <= prevVal\n            ):\n                return 0\n            if (r, c) in dp:\n                return dp[(r, c)]\n\n            res = 1\n            res = max(res, 1 + dfs(r + 1, c, matrix[r][c]))\n            res = max(res, 1 + dfs(r - 1, c, matrix[r][c]))\n            res = max(res, 1 + dfs(r, c + 1, matrix[r][c]))\n            res = max(res, 1 + dfs(r, c - 1, matrix[r][c]))\n            dp[(r, c)] = res\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, -1)\n        return max(dp.values())\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n        indegree = [[0] * COLS for _ in range(ROWS)]\n        \n        for r in range(ROWS):\n            for c in range(COLS):\n                for d in directions:\n                    nr, nc = d[0] + r, d[1] + c\n                    if (0 <= nr < ROWS and 0 <= nc < COLS and \n                        matrix[nr][nc] < matrix[r][c]\n                    ):\n                        indegree[r][c] += 1\n\n        q = deque()\n        for r in range(ROWS):\n            for c in range(COLS):\n                if indegree[r][c] == 0:\n                    q.append([r, c])\n\n        LIS = 0\n        while q:\n            for _ in range(len(q)):\n                r, c = q.popleft()\n                for d in directions:\n                    nr, nc = r + d[0], c + d[1]\n                    if (0 <= nr < ROWS and 0 <= nc < COLS and \n                        matrix[nr][nc] > matrix[r][c]\n                    ):\n                        indegree[nr][nc] -= 1\n                        if indegree[nr][nc] == 0:\n                            q.append([nr, nc])\n            LIS += 1\n        return LIS\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        \n        def dfs(i, j):\n            if i == len(text1) or j == len(text2):\n                return 0\n            if text1[i] == text2[j]:\n                return 1 + dfs(i + 1, j + 1)\n            return max(dfs(i + 1, j), dfs(i, j + 1))\n        \n        return dfs(0, 0)\n", "time_complexity": "O(2 ^ {m + n})"},
{"code": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        memo = {}\n\n        def dfs(i, j):\n            if i == len(text1) or j == len(text2):\n                return 0\n            if (i, j) in memo:\n                return memo[(i, j)]\n            \n            if text1[i] == text2[j]:\n                memo[(i, j)] = 1 + dfs(i + 1, j + 1)\n            else:\n                memo[(i, j)] = max(dfs(i + 1, j), dfs(i, j + 1))\n                \n            return memo[(i, j)]\n        \n        return dfs(0, 0)\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        dp = [[0 for j in range(len(text2) + 1)] \n                 for i in range(len(text1) + 1)]\n\n        for i in range(len(text1) - 1, -1, -1):\n            for j in range(len(text2) - 1, -1, -1):\n                if text1[i] == text2[j]:\n                    dp[i][j] = 1 + dp[i + 1][j + 1]\n                else:\n                    dp[i][j] = max(dp[i][j + 1], dp[i + 1][j])\n\n        return dp[0][0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        if len(text1) < len(text2):\n            text1, text2 = text2, text1\n            \n        prev = [0] * (len(text2) + 1)\n        curr = [0] * (len(text2) + 1)\n\n        for i in range(len(text1) - 1, -1, -1):\n            for j in range(len(text2) - 1, -1, -1):\n                if text1[i] == text2[j]:\n                    curr[j] = 1 + prev[j + 1]\n                else:\n                    curr[j] = max(curr[j + 1], prev[j])\n            prev, curr = curr, prev\n\n        return prev[0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        if len(text1) < len(text2):\n            text1, text2 = text2, text1\n\n        dp = [0] * (len(text2) + 1)\n\n        for i in range(len(text1) - 1, -1, -1):\n            prev = 0\n            for j in range(len(text2) - 1, -1, -1):\n                temp = dp[j]\n                if text1[i] == text2[j]:\n                    dp[j] = 1 + prev\n                else:\n                    dp[j] = max(dp[j], dp[j + 1])\n                prev = temp\n\n        return dp[0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        \n        def dfs(i, j):\n            if i == (m - 1) and j == (n - 1):\n                return 1\n            if i >= m or j >= n:\n                return 0\n            return dfs(i, j + 1) + dfs(i + 1, j)\n        \n        return dfs(0, 0)\n", "time_complexity": "O(2 ^ {m + n})"},
{"code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        memo = [[-1] * n for _ in range(m)]\n        def dfs(i, j):\n            if i == (m - 1) and j == (n - 1):\n                return 1\n            if i >= m or j >= n:\n                return 0\n            if memo[i][j] != -1:\n                return memo[i][j]\n            \n            memo[i][j] =  dfs(i, j + 1) + dfs(i + 1, j)\n            return memo[i][j]\n        \n        return dfs(0, 0)\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        dp[m - 1][n - 1] = 1\n\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                dp[i][j] += dp[i + 1][j] + dp[i][j + 1]\n\n        return dp[0][0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        row = [1] * n\n\n        for i in range(m - 1):\n            newRow = [1] * n\n            for j in range(n - 2, -1, -1):\n                newRow[j] = newRow[j + 1] + row[j]\n            row = newRow\n        return row[0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [1] * n\n        for i in range(m - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                dp[j] += dp[j + 1]\n                \n        return dp[0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        if m == 1 or n == 1:\n            return 1\n        if m < n:\n            m, n = n, m\n\n        res = j = 1\n        for i in range(m, m + n - 1):\n            res *= i\n            res //= j\n            j += 1\n\n        return res\n", "time_complexity": "O(min(m, n))"},
{"code": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        if sum(nums) % 2:\n            return False\n        \n        def dfs(i, target):\n            if i >= len(nums):\n                return target == 0\n            if target < 0:\n                return False\n            \n            return dfs(i + 1, target) or dfs(i + 1, target - nums[i])\n        \n        return dfs(0, sum(nums) // 2)\n", "time_complexity": "O(2 ^ n)"},
{"code": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n        \n        target = total // 2\n        n = len(nums)\n        memo = [[-1] * (target + 1) for _ in range(n + 1)]\n\n        def dfs(i, target):\n            if target == 0:\n                return True\n            if i >= n or target < 0:\n                return False\n            if memo[i][target] != -1:\n                return memo[i][target]\n            \n            memo[i][target] = (dfs(i + 1, target) or \n                               dfs(i + 1, target - nums[i]))\n            return memo[i][target]\n\n        return dfs(0, target)\n", "time_complexity": "O(n * target)"},
{"code": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n\n        target = total // 2\n        n = len(nums)\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n        for i in range(n + 1):\n            dp[i][0] = True\n\n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if nums[i - 1] <= j:\n                    dp[i][j] = (dp[i - 1][j] or \n                                dp[i - 1][j - nums[i - 1]])\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n        return dp[n][target]\n", "time_complexity": "O(n * target)"},
{"code": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        if sum(nums) % 2:\n            return False\n\n        target = sum(nums) // 2\n        dp = [False] * (target + 1)\n        nextDp = [False] * (target + 1)\n\n        dp[0] = True \n        for i in range(len(nums)):\n            for j in range(1, target + 1):\n                if j >= nums[i]:\n                    nextDp[j] = dp[j] or dp[j - nums[i]]\n                else:\n                    nextDp[j] = dp[j]\n            dp, nextDp = nextDp, dp\n            \n        return dp[target]\n", "time_complexity": "O(n * target)"},
{"code": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        if sum(nums) % 2:\n            return False\n\n        dp = set()\n        dp.add(0)\n        target = sum(nums) // 2\n\n        for i in range(len(nums) - 1, -1, -1):\n            nextDP = set()\n            for t in dp:\n                if (t + nums[i]) == target:\n                    return True\n                nextDP.add(t + nums[i])\n                nextDP.add(t)\n            dp = nextDP\n        return False\n", "time_complexity": "O(n * target)"},
{"code": "class Solution:\n    def canPartition(self, nums: list[int]) -> bool:\n        if sum(nums) % 2:\n            return False\n\n        target = sum(nums) // 2\n        dp = [False] * (target + 1)\n\n        dp[0] = True\n        for num in nums:\n            for j in range(target, num - 1, -1):\n                dp[j] = dp[j] or dp[j - num]\n                \n        return dp[target]\n", "time_complexity": "O(n * target)"},
{"code": "class Solution:\n    def canPartition(self, nums: list[int]) -> bool:\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n\n        target = total // 2\n        dp = 1 << 0\n        \n        for num in nums:\n            dp |= dp << num\n            \n        return (dp & (1 << target)) != 0\n", "time_complexity": "O(n * target)"},
{"code": "class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        \n        def dfs(i, j):\n            if i == len(nums):\n                return 0\n            \n            LIS = dfs(i + 1, j) # not include\n\n            if j == -1 or nums[j] < nums[i]:\n                LIS = max(LIS, 1 + dfs(i + 1, i)) # include\n            \n            return LIS\n\n        return dfs(0, -1)\n", "time_complexity": "O(2 ^ n)"},
{"code": "class Solution:\n    def lengthOfLIS(self, nums):\n        n = len(nums)\n        memo = [[-1] * (n + 1) for _ in range(n)]  \n\n        def dfs(i, j):\n            if i == n:\n                return 0\n            if memo[i][j + 1] != -1:\n                return memo[i][j + 1]\n\n            LIS = dfs(i + 1, j)\n\n            if j == -1 or nums[j] < nums[i]:\n                LIS = max(LIS, 1 + dfs(i + 1, i))\n\n            memo[i][j + 1] = LIS\n            return LIS\n\n        return dfs(0, -1)\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        LIS = [1] * len(nums)\n\n        for i in range(len(nums) - 1, -1, -1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] < nums[j]:\n                    LIS[i] = max(LIS[i], 1 + LIS[j])\n        return max(LIS)\n", "time_complexity": "O(n ^ 2)"},
{"code": "from bisect import bisect_left\nclass SegmentTree:\n    def __init__(self, N):\n        self.n = N\n        while (self.n & (self.n - 1)) != 0:\n            self.n += 1\n        self.tree = [0] * (2 * self.n)\n\n    def update(self, i, val):\n        self.tree[self.n + i] = val\n        j = (self.n + i) >> 1\n        while j >= 1:\n            self.tree[j] = max(self.tree[j << 1], self.tree[j << 1 | 1])\n            j >>= 1\n\n    def query(self, l, r):\n        if l > r:\n            return 0\n        res = float('-inf')\n        l += self.n\n        r += self.n + 1\n        while l < r:\n            if l & 1:\n                res = max(res, self.tree[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                res = max(res, self.tree[r])\n            l >>= 1\n            r >>= 1\n        return res\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        def compress(arr):\n            sortedArr = sorted(set(arr))\n            order = []\n            for num in arr:\n                order.append(bisect_left(sortedArr, num))\n            return order\n        \n        nums = compress(nums)\n        n = len(nums)\n        segTree = SegmentTree(n)\n\n        LIS = 0\n        for num in nums:\n            curLIS = segTree.query(0, num - 1) + 1\n            segTree.update(num, curLIS)\n            LIS = max(LIS, curLIS)\n        return LIS\n", "time_complexity": "O(n \\log n)"},
{"code": "from bisect import bisect_left\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        dp = []\n        dp.append(nums[0])\n\n        LIS = 1\n        for i in range(1, len(nums)):\n            if dp[-1] < nums[i]: \n                dp.append(nums[i])\n                LIS += 1\n                continue\n\n            idx = bisect_left(dp, nums[i])\n            dp[idx] = nums[i] \n\n        return LIS\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n\n        def dfs(i):\n            if i == len(s):\n                return True\n            \n            for w in wordDict:\n                if ((i + len(w)) <= len(s) and \n                     s[i : i + len(w)] == w\n                ):\n                    if dfs(i + len(w)):\n                        return True\n            return False\n        \n        return dfs(0)\n", "time_complexity": "O(t * m ^ n)"},
{"code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        wordSet = set(wordDict)\n\n        def dfs(i):\n            if i == len(s):\n                return True\n            \n            for j in range(i, len(s)):\n                if s[i : j + 1] in wordSet:\n                    if dfs(j + 1):\n                        return True\n            return False\n        \n        return dfs(0)\n", "time_complexity": "O( (n * 2 ^ n) + m)"},
{"code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        memo = {len(s) : True}\n        def dfs(i):\n            if i in memo:\n                return memo[i]\n            \n            for w in wordDict:\n                if ((i + len(w)) <= len(s) and \n                     s[i : i + len(w)] == w\n                ):\n                    if dfs(i + len(w)):\n                        memo[i] = True\n                        return True\n            memo[i] = False\n            return False\n        \n        return dfs(0)\n", "time_complexity": "O(n * m * t)"},
{"code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        wordSet = set(wordDict)\n        t = 0\n        for w in wordDict:\n            t = max(t, len(w))\n\n        memo = {}\n        def dfs(i):\n            if i in memo:\n                return memo[i]\n            if i == len(s):\n                return True\n            for j in range(i, min(len(s), i + t)):\n                if s[i : j + 1] in wordSet:\n                    if dfs(j + 1):\n                        memo[i] = True\n                        return True\n            memo[i] = False\n            return False\n        \n        return dfs(0)\n", "time_complexity": "O((t ^ 2 * n) + m)"},
{"code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        dp = [False] * (len(s) + 1)\n        dp[len(s)] = True\n\n        for i in range(len(s) - 1, -1, -1):\n            for w in wordDict:\n                if (i + len(w)) <= len(s) and s[i : i + len(w)] == w:\n                    dp[i] = dp[i + len(w)]\n                if dp[i]:\n                    break\n\n        return dp[0]\n", "time_complexity": "O(n * m * t)"},
{"code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_word = True\n\n    def search(self, s, i, j):\n        node = self.root\n        for idx in range(i, j + 1):\n            if s[idx] not in node.children:\n                return False\n            node = node.children[s[idx]]\n        return node.is_word\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        trie = Trie()\n        for word in wordDict:\n            trie.insert(word)\n\n        dp = [False] * (len(s) + 1)\n        dp[len(s)] = True\n\n        t = 0\n        for w in wordDict:\n            t = max(t, len(w))\n        \n        for i in range(len(s), -1, -1):\n            for j in range(i, min(len(s), i + t)):\n                if trie.search(s, i, j):\n                    dp[i] = dp[j + 1]\n                    if dp[i]:\n                        break\n\n        return dp[0]\n", "time_complexity": "O((n * t ^ 2) + m)"},
{"code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        if len(t) > len(s):\n            return 0\n            \n        def dfs(i, j):\n            if j == len(t):\n                return 1\n            if i == len(s):\n                return 0\n            \n            res = dfs(i + 1, j)\n            if s[i] == t[j]:\n                res += dfs(i + 1, j + 1)\n            return res\n        \n        return dfs(0, 0)\n", "time_complexity": "O(2 ^ m)"},
{"code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        if len(t) > len(s):\n            return 0\n        \n        dp = {}\n        def dfs(i, j):\n            if j == len(t):\n                return 1\n            if i == len(s):\n                return 0\n            if (i, j) in dp:\n                return dp[(i, j)]\n            \n            res = dfs(i + 1, j)\n            if s[i] == t[j]:\n                res += dfs(i + 1, j + 1)\n            dp[(i, j)] = res\n            return res\n\n        return dfs(0, 0)\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(m + 1):\n            dp[i][n] = 1\n        \n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                dp[i][j] = dp[i + 1][j]\n                if s[i] == t[j]:\n                    dp[i][j] += dp[i + 1][j + 1]\n                    \n        return dp[0][0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n        dp = [0] * (n + 1)\n        nextDp = [0] * (n + 1)\n\n        dp[n] = nextDp[n] = 1\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                nextDp[j] = dp[j]\n                if s[i] == t[j]:\n                    nextDp[j] += dp[j + 1]\n            dp = nextDp[:]\n\n        return dp[0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n        dp = [0] * (n + 1)\n\n        dp[n] = 1\n        for i in range(m - 1, -1, -1):\n            prev = 1\n            for j in range(n - 1, -1, -1):\n                res = dp[j]\n                if s[i] == t[j]:\n                    res += prev\n\n                prev = dp[j]\n                dp[j] = res \n                \n        return dp[0]\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        \n        def dfs(i, buying):\n            if i >= len(prices):\n                return 0\n            \n            cooldown = dfs(i + 1, buying)\n            if buying:\n                buy = dfs(i + 1, not buying) - prices[i]\n                return max(buy, cooldown)\n            else:\n                sell = dfs(i + 2, not buying) + prices[i]\n                return max(sell, cooldown)\n        \n        return dfs(0, True)\n", "time_complexity": "O(2 ^ n)"},
{"code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        dp = {}  # key=(i, buying) val=max_profit\n\n        def dfs(i, buying):\n            if i >= len(prices):\n                return 0\n            if (i, buying) in dp:\n                return dp[(i, buying)]\n\n            cooldown = dfs(i + 1, buying)\n            if buying:\n                buy = dfs(i + 1, not buying) - prices[i]\n                dp[(i, buying)] = max(buy, cooldown)\n            else:\n                sell = dfs(i + 2, not buying) + prices[i]\n                dp[(i, buying)] = max(sell, cooldown)\n            return dp[(i, buying)]\n\n        return dfs(0, True)\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [[0] * 2 for _ in range(n + 1)]  \n\n        for i in range(n - 1, -1, -1):\n            for buying in [True, False]:\n                if buying:\n                    buy = dp[i + 1][False] - prices[i] if i + 1 < n else -prices[i]\n                    cooldown = dp[i + 1][True] if i + 1 < n else 0\n                    dp[i][1] = max(buy, cooldown)\n                else:\n                    sell = dp[i + 2][True] + prices[i] if i + 2 < n else prices[i]\n                    cooldown = dp[i + 1][False] if i + 1 < n else 0\n                    dp[i][0] = max(sell, cooldown)\n\n        return dp[0][1]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp1_buy, dp1_sell = 0, 0  \n        dp2_buy = 0\n\n        for i in range(n - 1, -1, -1):\n            dp_buy = max(dp1_sell - prices[i], dp1_buy)\n            dp_sell = max(dp2_buy + prices[i], dp1_sell)\n            dp2_buy = dp1_buy\n            dp1_buy, dp1_sell = dp_buy, dp_sell\n\n        return dp1_buy\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        \n        def dfs(i):\n            if i == len(s):\n                return 1\n            if s[i] == '0':\n                return 0\n\n            res = dfs(i + 1)\n            if i < len(s) - 1:\n                if (s[i] == '1' or \n                   (s[i] == '2' and s[i + 1] < '7')):\n                    res += dfs(i + 2)\n\n            return res\n\n        return dfs(0)\n", "time_complexity": "O(2 ^ n)"},
{"code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        dp = {len(s) : 1}\n\n        def dfs(i):\n            if i in dp:\n                return dp[i]\n            if s[i] == \"0\":\n                return 0\n\n            res = dfs(i + 1)\n            if i + 1 < len(s) and (\n                s[i] == \"1\" or s[i] == \"2\" and\n                s[i + 1] in \"0123456\"\n            ):\n                res += dfs(i + 2)\n            dp[i] = res\n            return res\n\n        return dfs(0)\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        dp = {len(s): 1}\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == \"0\":\n                dp[i] = 0\n            else:\n                dp[i] = dp[i + 1]\n\n            if i + 1 < len(s) and (s[i] == \"1\" or\n               s[i] == \"2\" and s[i + 1] in \"0123456\"\n            ):\n                dp[i] += dp[i + 2]\n        return dp[0]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        dp = dp2 = 0\n        dp1 = 1\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == \"0\":\n                dp = 0\n            else:\n                dp = dp1\n\n            if i + 1 < len(s) and (s[i] == \"1\" or\n               s[i] == \"2\" and s[i + 1] in \"0123456\"\n            ):\n                dp += dp2\n            dp, dp1, dp2 = 0, dp, dp1\n        return dp1\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        def dfs(amount):\n            if amount == 0:\n                return 0\n            \n            res = 1e9\n            for coin in coins:\n                if amount - coin >= 0:\n                    res = min(res, 1 + dfs(amount - coin))\n            return res\n\n        minCoins = dfs(amount)\n        return -1 if minCoins >= 1e9 else minCoins\n", "time_complexity": "O(n ^ t)"},
{"code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = {}\n\n        def dfs(amount):\n            if amount == 0:\n                return 0\n            if amount in memo:\n                return memo[amount]\n            \n            res = 1e9\n            for coin in coins:\n                if amount - coin >= 0:\n                    res = min(res, 1 + dfs(amount - coin))\n            \n            memo[amount] = res\n            return res\n        \n        minCoins = dfs(amount)\n        return -1 if minCoins >= 1e9 else minCoins\n", "time_complexity": "O(n * t)"},
{"code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n\n        for a in range(1, amount + 1):\n            for c in coins:\n                if a - c >= 0:\n                    dp[a] = min(dp[a], 1 + dp[a - c])\n        return dp[amount] if dp[amount] != amount + 1 else -1\n", "time_complexity": "O(n * t)"},
{"code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n\n        q = deque([0])\n        seen = [False] * (amount + 1)\n        seen[0] = True\n        res = 0  \n\n        while q:\n            res += 1\n            for _ in range(len(q)):\n                cur = q.popleft()\n                for coin in coins:\n                    nxt = cur + coin\n                    if nxt == amount:\n                        return res\n                    if nxt > amount or seen[nxt]:\n                        continue\n                    seen[nxt] = True\n                    q.append(nxt)\n\n        return -1\n", "time_complexity": "O(n * t)"},
{"code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        res, resLen = \"\", 0\n\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                l, r = i, j\n                while l < r and s[l] == s[r]:\n                    l += 1\n                    r -= 1\n                \n                if l >= r and resLen < (j - i + 1):\n                    res = s[i : j + 1]\n                    resLen = j - i + 1\n        return res\n", "time_complexity": "O(n ^ 3)"},
{"code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        resIdx, resLen = 0, 0\n        n = len(s)\n\n        dp = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):\n                    dp[i][j] = True\n                    if resLen < (j - i + 1):\n                        resIdx = i\n                        resLen = j - i + 1\n\n        return s[resIdx : resIdx + resLen]\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        resIdx = 0\n        resLen = 0\n\n        for i in range(len(s)):\n            # odd length\n            l, r = i, i\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > resLen:\n                    resIdx = l\n                    resLen = r - l + 1\n                l -= 1\n                r += 1\n\n            # even length\n            l, r = i, i + 1\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > resLen:\n                    resIdx = l\n                    resLen = r - l + 1\n                l -= 1\n                r += 1\n\n        return s[resIdx : resIdx + resLen]\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        def manacher(s):\n            t = '#' + '#'.join(s) + '#'\n            n = len(t)\n            p = [0] * n\n            l, r = 0, 0\n            for i in range(n):\n                p[i] = min(r - i, p[l + (r - i)]) if i < r else 0\n                while (i + p[i] + 1 < n and i - p[i] - 1 >= 0 \n                       and t[i + p[i] + 1] == t[i - p[i] - 1]):\n                    p[i] += 1\n                if i + p[i] > r:\n                    l, r = i - p[i], i + p[i]\n            return p\n        \n        p = manacher(s)\n        resLen, center_idx = max((v, i) for i, v in enumerate(p))\n        resIdx = (center_idx - resLen) // 2\n        return s[resIdx : resIdx + resLen]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        res = nums[0]\n\n        for i in range(len(nums)):\n            cur = nums[i]\n            res = max(res, cur)\n            for j in range(i + 1, len(nums)):\n                cur *= nums[j]\n                res = max(res, cur)\n                \n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        A = []\n        cur = []\n        res = float('-inf')\n\n        for num in nums:\n            res = max(res, num)\n            if num == 0:\n                if cur:\n                    A.append(cur)\n                cur = []\n            else:\n                cur.append(num)\n\n        if cur:\n            A.append(cur)\n\n        for sub in A:\n            negs = sum(1 for i in sub if i < 0)\n            prod = 1\n            need = negs if negs % 2 == 0 else negs - 1\n            negs = 0\n            j = 0\n\n            for i in range(len(sub)):\n                prod *= sub[i]\n                if sub[i] < 0:\n                    negs += 1\n                    while negs > need:\n                        prod //= sub[j]\n                        if sub[j] < 0:\n                            negs -= 1\n                        j += 1\n                if j <= i:\n                    res = max(res, prod)\n\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        res = nums[0]\n        curMin, curMax = 1, 1\n\n        for num in nums:\n            tmp = curMax * num\n            curMax = max(num * curMax, num * curMin, num)\n            curMin = min(tmp, num * curMin, num)\n            res = max(res, curMax)\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        n, res = len(nums), nums[0]\n        prefix = suffix = 0\n\n        for i in range(n):\n            prefix = nums[i] * (prefix or 1)\n            suffix = nums[n - 1 - i] * (suffix or 1)\n            res = max(res, max(prefix, suffix))\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        \n        def dfs(i):\n            if i >= len(nums):\n                return 0\n            return max(dfs(i + 1),\n                       nums[i] + dfs(i + 2))\n        \n        return dfs(0)\n", "time_complexity": "O(2 ^ n)"},
{"code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        memo = [-1] * len(nums)\n\n        def dfs(i):\n            if i >= len(nums):\n                return 0\n            if memo[i] != -1:\n                return memo[i]\n            memo[i] = max(dfs(i + 1), nums[i] + dfs(i + 2))\n            return memo[i]\n        \n        return dfs(0)\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        \n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        \n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])\n        \n        return dp[-1]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        rob1, rob2 = 0, 0\n\n        for num in nums:\n            temp = max(num + rob1, rob2)\n            rob1 = rob2\n            rob2 = temp\n        return rob2\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        \n        def dfs(i):\n            if i >= len(cost):\n                return 0\n            return cost[i] + min(dfs(i + 1), dfs(i + 2))\n        \n        return min(dfs(0), dfs(1))\n", "time_complexity": "O(2 ^ n)"},
{"code": "class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        memo = [-1] * len(cost)\n        \n        def dfs(i):\n            if i >= len(cost):\n                return 0\n            if memo[i] != -1:\n                return memo[i]\n            memo[i] = cost[i] + min(dfs(i + 1), dfs(i + 2))\n            return memo[i]\n        \n        return min(dfs(0), dfs(1))\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        n = len(cost)\n        dp = [0] * (n + 1)\n        \n        for i in range(2, n + 1):\n            dp[i] = min(dp[i - 1] + cost[i - 1],\n                        dp[i - 2] + cost[i - 2])\n        \n        return dp[n]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        for i in range(len(cost) - 3, -1, -1):\n            cost[i] += min(cost[i + 1], cost[i + 2])\n\n        return min(cost[0], cost[1])\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n        def dfs(i, flag):\n            if i >= len(nums) or (flag and i == len(nums) - 1):\n                return 0\n            \n            return max(dfs(i + 1, flag), \n                       nums[i] + dfs(i + 2, flag or i == 0))\n        return max(dfs(0, True), dfs(1, False))\n", "time_complexity": "O(2 ^ n)"},
{"code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n\n        memo = [[-1] * 2 for _ in range(len(nums))]\n\n        def dfs(i, flag):\n            if i >= len(nums) or (flag and i == len(nums) - 1):\n                return 0\n            if memo[i][flag] != -1:\n                return memo[i][flag]\n            memo[i][flag] = max(dfs(i + 1, flag), \n                            nums[i] + dfs(i + 2, flag or (i == 0)))\n            return memo[i][flag]\n\n        return max(dfs(0, True), dfs(1, False))\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n        return max(self.helper(nums[1:]), \n                   self.helper(nums[:-1]))\n    \n    def helper(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        \n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        \n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])\n        \n        return dp[-1]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    \n    def rob(self, nums: List[int]) -> int:\n        return max(nums[0], self.helper(nums[1:]), \n                            self.helper(nums[:-1]))\n\n    def helper(self, nums):\n        rob1, rob2 = 0, 0\n\n        for num in nums:\n            newRob = max(rob1 + num, rob2)\n            rob1 = rob2\n            rob2 = newRob\n        return rob2\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        \n        def dfs(i):\n            if i >= n:\n                return i == n\n            return dfs(i + 1) + dfs(i + 2)\n            \n        return dfs(0)\n", "time_complexity": "O(2 ^ n)"},
{"code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        cache = [-1] * n\n        def dfs(i):\n            if i >= n:\n                return i == n\n            if cache[i] != -1:\n                return cache[i]\n            cache[i] = dfs(i + 1) + dfs(i + 2)\n            return cache[i]\n            \n        return dfs(0)\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 2:\n            return n\n        dp = [0] * (n + 1)\n        dp[1], dp[2] = 1, 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        one, two = 1, 1\n\n        for i in range(n - 1):\n            temp = one\n            one = one + two\n            two = temp\n        \n        return one\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n == 1:\n            return 1\n\n        def matrix_mult(A, B):\n            return [[A[0][0] * B[0][0] + A[0][1] * B[1][0], \n                     A[0][0] * B[0][1] + A[0][1] * B[1][1]],\n                    [A[1][0] * B[0][0] + A[1][1] * B[1][0], \n                     A[1][0] * B[0][1] + A[1][1] * B[1][1]]]\n\n        def matrix_pow(M, p):\n            result = [[1, 0], [0, 1]]  \n            base = M\n\n            while p:\n                if p % 2 == 1:\n                    result = matrix_mult(result, base)\n                base = matrix_mult(base, base)\n                p //= 2\n\n            return result\n\n        M = [[1, 1], [1, 0]]\n        result = matrix_pow(M, n)\n        return result[0][0]\n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        sqrt5 = math.sqrt(5)\n        phi = (1 + sqrt5) / 2\n        psi = (1 - sqrt5) / 2\n        n += 1\n        return round((phi**n - psi**n) / sqrt5)\n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def foreignDictionary(self, words: List[str]) -> str:\n        adj = {c: set() for w in words for c in w}\n\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            minLen = min(len(w1), len(w2))\n            if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:\n                return \"\"\n            for j in range(minLen):\n                if w1[j] != w2[j]:\n                    adj[w1[j]].add(w2[j])\n                    break\n\n        visited = {}\n        res = []\n\n        def dfs(char):\n            if char in visited:\n                return visited[char]\n\n            visited[char] = True\n\n            for neighChar in adj[char]:\n                if dfs(neighChar):\n                    return True\n\n            visited[char] = False\n            res.append(char)\n\n        for char in adj:\n            if dfs(char):\n                return \"\"\n\n        res.reverse()\n        return \"\".join(res)\n", "time_complexity": "O(N + V + E)"},
{"code": "class Solution:\n    def foreignDictionary(self, words):\n        adj = {c: set() for w in words for c in w}\n        indegree = {c: 0 for c in adj}\n        \n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            minLen = min(len(w1), len(w2))\n            if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:\n                return \"\"\n            for j in range(minLen):\n                if w1[j] != w2[j]:\n                    if w2[j] not in adj[w1[j]]:\n                        adj[w1[j]].add(w2[j])\n                        indegree[w2[j]] += 1\n                    break\n        \n        q = deque([c for c in indegree if indegree[c] == 0])\n        res = []\n        \n        while q:\n            char = q.popleft()\n            res.append(char)\n            for neighbor in adj[char]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n        \n        if len(res) != len(indegree):\n            return \"\"\n        \n        return \"\".join(res)\n", "time_complexity": "O(N + V + E)"},
{"code": "class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        visit = [[False] * n for _ in range(n)]\n\n        def dfs(node, t):\n            r, c = node\n            if min(r, c) < 0 or max(r, c) >= n or visit[r][c]:\n                return 1000000\n            if r == (n - 1) and c == (n - 1):\n                return max(t, grid[r][c])\n            visit[r][c] = True\n            t = max(t, grid[r][c])\n            res = min(dfs((r + 1, c), t),\n                       dfs((r - 1, c), t),\n                       dfs((r, c + 1), t),\n                       dfs((r, c - 1), t))\n            visit[r][c] = False\n            return res\n        \n        return dfs((0, 0), 0)\n", "time_complexity": "O(4 ^ {n ^ 2})"},
{"code": "class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        visit = [[False] * n for _ in range(n)]\n        minH = maxH = grid[0][0]\n        for row in range(n):\n            maxH = max(maxH, max(grid[row]))\n            minH = min(minH, min(grid[row]))\n\n        def dfs(node, t):\n            r, c = node\n            if (min(r, c) < 0 or max(r, c) >= n or \n                visit[r][c] or grid[r][c] > t):\n                return False\n            if r == (n - 1) and c == (n - 1):\n                return True\n            visit[r][c] = True\n            return (dfs((r + 1, c), t) or\n                    dfs((r - 1, c), t) or\n                    dfs((r, c + 1), t) or\n                    dfs((r, c - 1), t))\n            \n        for t in range(minH, maxH):\n            if dfs((0, 0), t):\n                return t\n            for r in range(n):\n                for c in range(n):\n                    visit[r][c] = False\n        \n        return maxH\n", "time_complexity": "O(n ^ 4)"},
{"code": "class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        visit = [[False] * n for _ in range(n)]\n        minH = maxH = grid[0][0]\n        for row in range(n):\n            maxH = max(maxH, max(grid[row]))\n            minH = min(minH, min(grid[row]))\n\n        def dfs(node, t):\n            r, c = node\n            if (min(r, c) < 0 or max(r, c) >= n or \n                visit[r][c] or grid[r][c] > t):\n                return False\n            if r == (n - 1) and c == (n - 1):\n                return True\n            visit[r][c] = True\n            return (dfs((r + 1, c), t) or\n                    dfs((r - 1, c), t) or\n                    dfs((r, c + 1), t) or\n                    dfs((r, c - 1), t))\n        \n        l, r = minH, maxH\n        while l < r:\n            m = (l + r) >> 1\n            if dfs((0, 0), m):\n                r = m\n            else:\n                l = m + 1\n            for row in range(n):\n                for col in range(n):\n                    visit[row][col] = False\n        \n        return r\n", "time_complexity": "O(n ^ 2 \\log n)"},
{"code": "class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        visit = set()\n        minH = [[grid[0][0], 0, 0]]  # (time/max-height, r, c)\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n        visit.add((0, 0))\n        while minH:\n            t, r, c = heapq.heappop(minH)\n            if r == N - 1 and c == N - 1:\n                return t\n            for dr, dc in directions:\n                neiR, neiC = r + dr, c + dc\n                if (neiR < 0 or neiC < 0 or \n                    neiR == N or neiC == N or\n                    (neiR, neiC) in visit\n                ):\n                    continue\n                visit.add((neiR, neiC))\n                heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])\n", "time_complexity": "O(n ^ 2 \\log n)"},
{"code": "class DSU:\n    def __init__(self, n):\n        self.Parent = list(range(n + 1))\n        self.Size = [1] * (n + 1)\n\n    def find(self, node):\n        if self.Parent[node] != node:\n            self.Parent[node] = self.find(self.Parent[node])\n        return self.Parent[node]\n\n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv:\n            return False\n        if self.Size[pu] < self.Size[pv]:\n            pu, pv = pv, pu\n        self.Size[pu] += self.Size[pv]\n        self.Parent[pv] = pu\n        return True\n    \n    def connected(self, u, v):\n        return self.find(u) == self.find(v)\n\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        dsu = DSU(N * N)\n        positions = sorted((grid[r][c], r, c) for r in range(N) for c in range(N))\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        for t, r, c in positions:\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < N and 0 <= nc < N and grid[nr][nc] <= t:\n                    dsu.union(r * N + c, nr * N + nc)\n            if dsu.connected(0, N * N - 1):\n                return t\n", "time_complexity": "O(n ^ 2 \\log n)"},
{"code": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n        res = 0\n        \n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                l, r = i, j\n                while l < r and s[l] == s[r]:\n                    l += 1\n                    r -= 1\n                res += (l >= r)\n                \n        return res\n", "time_complexity": "O(n ^ 3)"},
{"code": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n        n, res = len(s), 0\n        dp = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):\n                    dp[i][j] = True\n                    res += 1\n\n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n        res = 0\n        \n        for i in range(len(s)):\n            # odd length\n            l, r = i, i\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                res += 1\n                l -= 1\n                r += 1\n\n            # even length\n            l, r = i, i + 1\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                res += 1\n                l -= 1\n                r += 1\n        \n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    \n    def countSubstrings(self, s: str) -> int:\n        res = 0\n\n        for i in range(len(s)):\n            res += self.countPali(s, i, i)\n            res += self.countPali(s, i, i + 1)\n        return res\n\n    def countPali(self, s, l, r):\n        res = 0\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            res += 1\n            l -= 1\n            r += 1\n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n\n        def manacher(s):\n            t = '#' + '#'.join(s) + '#'\n            n = len(t)\n            p = [0] * n\n            l, r = 0, 0\n            for i in range(n):\n                p[i] = min(r - i, p[l + (r - i)]) if i < r else 0\n                while (i + p[i] + 1 < n and i - p[i] - 1 >= 0 \n                       and t[i + p[i] + 1] == t[i - p[i] - 1]):\n                    p[i] += 1\n                if i + p[i] > r:\n                    l, r = i - p[i], i + p[i]\n            return p\n        \n        p = manacher(s)\n        res = 0\n        for i in p:\n            res += (i + 1) // 2\n        return res\n", "time_complexity": "O(n)"},
{"code": "class DSU:\n    def __init__(self, n):\n        self.Parent = list(range(n + 1))\n        self.Size = [1] * (n + 1)\n\n    def find(self, node):\n        if self.Parent[node] != node:\n            self.Parent[node] = self.find(self.Parent[node])\n        return self.Parent[node]\n\n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv:\n            return False\n        if self.Size[pu] < self.Size[pv]:\n            pu, pv = pv, pu\n        self.Size[pu] += self.Size[pv]\n        self.Parent[pv] = pu\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        dsu = DSU(n)\n        edges = []\n        for i in range(n):\n            x1, y1 = points[i]\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                edges.append((dist, i, j))\n        \n        edges.sort()\n        res = 0\n        for dist, u, v in edges:\n            if dsu.union(u, v):\n                res += dist\n        return res\n", "time_complexity": "O(n ^ 2 \\log n)"},
{"code": "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        adj = {i: [] for i in range(N)}\n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i + 1, N):\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                adj[i].append([dist, j])\n                adj[j].append([dist, i])\n\n        res = 0\n        visit = set()\n        minH = [[0, 0]]\n        while len(visit) < N:\n            cost, i = heapq.heappop(minH)\n            if i in visit:\n                continue\n            res += cost\n            visit.add(i)\n            for neiCost, nei in adj[i]:\n                if nei not in visit:\n                    heapq.heappush(minH, [neiCost, nei])\n        return res\n", "time_complexity": "O(n ^ 2 \\log n)"},
{"code": "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n, node = len(points), 0\n        dist = [100000000] * n\n        visit = [False] * n\n        edges, res = 0, 0\n\n        while edges < n - 1:\n            visit[node] = True\n            nextNode = -1\n            for i in range(n):\n                if visit[i]:\n                    continue\n                curDist = (abs(points[i][0] - points[node][0]) + \n                           abs(points[i][1] - points[node][1]))\n                dist[i] = min(dist[i], curDist)\n                if nextNode == -1 or dist[i] < dist[nextNode]:\n                    nextNode = i\n                    \n            res += dist[nextNode]\n            node = nextNode\n            edges += 1\n\n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        adj = {src: [] for src, dst in tickets}\n        tickets.sort()\n        for src, dst in tickets:\n            adj[src].append(dst)\n\n        res = [\"JFK\"]\n        def dfs(src):\n            if len(res) == len(tickets) + 1:\n                return True\n            if src not in adj:\n                return False\n\n            temp = list(adj[src])\n            for i, v in enumerate(temp):\n                adj[src].pop(i)\n                res.append(v)\n                if dfs(v): return True\n                adj[src].insert(i, v)\n                res.pop()\n            return False\n            \n        dfs(\"JFK\")\n        return res\n", "time_complexity": "O(E * V)"},
{"code": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        adj = defaultdict(list)\n        for src, dst in sorted(tickets)[::-1]:\n            adj[src].append(dst)\n\n        res = []\n        def dfs(src):\n            while adj[src]:\n                dst = adj[src].pop()\n                dfs(dst)\n            res.append(src)\n            \n        dfs('JFK')\n        return res[::-1]\n", "time_complexity": "O(E\\log E)"},
{"code": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        adj = defaultdict(list)\n        for src, dst in sorted(tickets)[::-1]:\n            adj[src].append(dst)\n            \n        stack = [\"JFK\"]\n        res = []\n        \n        while stack:\n            curr = stack[-1]\n            if not adj[curr]:\n                res.append(stack.pop())\n            else:\n                stack.append(adj[curr].pop())\n                \n        return res[::-1]\n", "time_complexity": "O(E\\log E)"},
{"code": "class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        INF = float(\"inf\")\n        adj = [[] for _ in range(n)]\n        dist = [[INF] * (k + 5) for _ in range(n)]\n        for u, v, cst in flights:\n            adj[u].append([v, cst])\n        \n        dist[src][0] = 0\n        minHeap = [(0, src, -1)] # cost, node, stops\n        while len(minHeap):\n            cst, node, stops = heapq.heappop(minHeap)\n            if dst == node: return cst\n            if stops == k or dist[node][stops + 1] < cst:\n                continue\n            for nei, w in adj[node]:\n                nextCst = cst + w\n                nextStops = 1 + stops\n                if dist[nei][nextStops + 1] > nextCst:\n                    dist[nei][nextStops + 1] = nextCst\n                    heapq.heappush(minHeap, (nextCst, nei, nextStops))\n\n        return -1\n", "time_complexity": "O((n + m) * k)"},
{"code": "class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        prices = [float(\"inf\")] * n\n        prices[src] = 0\n\n        for i in range(k + 1):\n            tmpPrices = prices.copy()\n\n            for s, d, p in flights:  # s=source, d=dest, p=price\n                if prices[s] == float(\"inf\"):\n                    continue\n                if prices[s] + p < tmpPrices[d]:\n                    tmpPrices[d] = prices[s] + p\n            prices = tmpPrices\n        return -1 if prices[dst] == float(\"inf\") else prices[dst]\n", "time_complexity": "O(n + (m * k))"},
{"code": "class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        prices = [float(\"inf\")] * n\n        prices[src] = 0\n        adj = [[] for _ in range(n)]\n        for u, v, cst in flights:\n            adj[u].append([v, cst])\n\n        q = deque([(0, src, 0)])\n        while q:\n            cst, node, stops = q.popleft()\n            if stops > k:\n                continue\n            \n            for nei, w in adj[node]:\n                nextCost = cst + w\n                if nextCost < prices[nei]:\n                    prices[nei] = nextCost\n                    q.append((nextCost, nei, stops + 1))\n\n        return prices[dst] if prices[dst] != float(\"inf\") else -1\n", "time_complexity": "O(n * k)"},
{"code": "class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges)\n        adj = [[] for _ in range(n + 1)]\n\n        def dfs(node, par):\n            if visit[node]:\n                return True\n            \n            visit[node] = True\n            for nei in adj[node]:\n                if nei == par:\n                    continue\n                if dfs(nei, node):\n                    return True\n            return False\n        \n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n            visit = [False] * (n + 1)\n            \n            if dfs(u, -1):\n                return [u, v]\n        return []\n", "time_complexity": "O(E * (V + E))"},
{"code": "class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges)\n        adj = [[] for _ in range(n + 1)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        visit = [False] * (n + 1)\n        cycle = set()\n        cycleStart = -1\n        \n        def dfs(node, par):\n            nonlocal cycleStart\n            if visit[node]:\n                cycleStart = node\n                return True  \n            \n            visit[node] = True\n            for nei in adj[node]:\n                if nei == par:\n                    continue\n                if dfs(nei, node):\n                    if cycleStart != -1:\n                        cycle.add(node)\n                    if node == cycleStart:\n                        cycleStart = -1\n                    return True\n            return False\n        \n        dfs(1, -1)\n        \n        for u, v in reversed(edges):\n            if u in cycle and v in cycle:\n                return [u, v]\n\n        return []\n", "time_complexity": "O(V + E)"},
{"code": "class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges)\n        indegree = [0] * (n + 1)\n        adj = [[] for _ in range(n + 1)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n            indegree[u] += 1\n            indegree[v] += 1\n        \n        q = deque()\n        for i in range(1, n + 1):\n            if indegree[i] == 1:\n                q.append(i)\n\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            for nei in adj[node]:\n                indegree[nei] -= 1\n                if indegree[nei] == 1:\n                    q.append(nei)\n\n        for u, v in edges[::-1]:\n            if indegree[u] == 2 and indegree[v]:\n                return [u, v]\n        return []\n", "time_complexity": "O(V + E)"},
{"code": "class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        par = [i for i in range(len(edges) + 1)]\n        rank = [1] * (len(edges) + 1)\n\n        def find(n):\n            p = par[n]\n            while p != par[p]:\n                par[p] = par[par[p]]\n                p = par[p]\n            return p\n\n        def union(n1, n2):\n            p1, p2 = find(n1), find(n2)\n\n            if p1 == p2:\n                return False\n            if rank[p1] > rank[p2]:\n                par[p2] = p1\n                rank[p1] += rank[p2]\n            else:\n                par[p1] = p2\n                rank[p2] += rank[p1]\n            return True\n\n        for n1, n2 in edges:\n            if not union(n1, n2):\n                return [n1, n2]\n", "time_complexity": "O(V + (E * (V)))"},
{"code": "class Solution:\n    def validTree(self, n: int, edges: List[List[int]]) -> bool:\n        if len(edges) > (n - 1):\n            return False\n        \n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        \n        visit = set()\n        def dfs(node, par):\n            if node in visit:\n                return False\n            \n            visit.add(node)\n            for nei in adj[node]:\n                if nei == par:\n                    continue\n                if not dfs(nei, node):\n                    return False\n            return True\n        \n        return dfs(0, -1) and len(visit) == n\n", "time_complexity": "O(V + E)"},
{"code": "class Solution:\n    def validTree(self, n: int, edges: List[List[int]]) -> bool:\n        if len(edges) > n - 1:\n            return False\n        \n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        \n        visit = set()\n        q = deque([(0, -1)])  # (current node, parent node)\n        visit.add(0)\n        \n        while q:\n            node, parent = q.popleft()\n            for nei in adj[node]:\n                if nei == parent:\n                    continue\n                if nei in visit:\n                    return False\n                visit.add(nei)\n                q.append((nei, node))\n        \n        return len(visit) == n\n", "time_complexity": "O(V + E)"},
{"code": "class DSU:\n    def __init__(self, n):\n        self.comps = n\n        self.Parent = list(range(n + 1))\n        self.Size = [1] * (n + 1)\n\n    def find(self, node):\n        if self.Parent[node] != node:\n            self.Parent[node] = self.find(self.Parent[node])\n        return self.Parent[node]\n\n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv:\n            return False\n\n        self.comps -= 1\n        if self.Size[pu] < self.Size[pv]:\n            pu, pv = pv, pu\n        self.Size[pu] += self.Size[pv]\n        self.Parent[pv] = pu\n        return True\n    \n    def components(self):\n        return self.comps\n\nclass Solution:\n    def validTree(self, n: int, edges: List[List[int]]) -> bool:\n        if len(edges) > n - 1:\n            return False\n        \n        dsu = DSU(n)\n        for u, v in edges:\n            if not dsu.union(u, v):\n                return False\n        return dsu.components() == 1\n", "time_complexity": "O(V + (E * (V)))"},
{"code": "class Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        adj = [[] for _ in range(n)]\n        visit = [False] * n\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        def dfs(node):\n            for nei in adj[node]:\n                if not visit[nei]:\n                    visit[nei] = True\n                    dfs(nei)\n        \n        res = 0\n        for node in range(n):\n            if not visit[node]:\n                visit[node] = True\n                dfs(node)\n                res += 1\n        return res\n", "time_complexity": "O(V + E)"},
{"code": "class Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        adj = [[] for _ in range(n)]\n        visit = [False] * n\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        def bfs(node):\n            q = deque([node])\n            visit[node] = True\n            while q:\n                cur = q.popleft()\n                for nei in adj[cur]:\n                    if not visit[nei]:\n                        visit[nei] = True\n                        q.append(nei)\n        \n        res = 0\n        for node in range(n):\n            if not visit[node]:\n                bfs(node)\n                res += 1\n        return res\n", "time_complexity": "O(V + E)"},
{"code": "class DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [1] * n\n\n    def find(self, node):\n        cur = node\n        while cur != self.parent[cur]:\n            self.parent[cur] = self.parent[self.parent[cur]]\n            cur = self.parent[cur]\n        return cur\n\n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv:\n            return False\n        if self.rank[pv] > self.rank[pu]:\n            pu, pv = pv, pu\n        self.parent[pv] = pu\n        self.rank[pu] += self.rank[pv]\n        return True\n\nclass Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        dsu = DSU(n)\n        res = n\n        for u, v in edges:\n            if dsu.union(u, v):\n                res -= 1\n        return res\n", "time_complexity": "O(V + (E * (V)))"},
{"code": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if (endWord not in wordList) or (beginWord == endWord):\n            return 0\n        \n        n, m = len(wordList), len(wordList[0])\n        adj = [[] for _ in range(n)]\n        mp = {}\n        for i in range(n):\n            mp[wordList[i]] = i\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                cnt = 0\n                for k in range(m):\n                    if wordList[i][k] != wordList[j][k]:\n                        cnt += 1\n                if cnt == 1:\n                    adj[i].append(j)\n                    adj[j].append(i)\n        \n        q, res = deque(), 1\n        visit = set()\n        for i in range(m):\n            for c in range(97, 123):\n                if chr(c) == beginWord[i]:\n                    continue\n                word = beginWord[:i] + chr(c) + beginWord[i + 1:]\n                if word in mp and mp[word] not in visit:\n                    q.append(mp[word])\n                    visit.add(mp[word])\n        \n        while q:\n            res += 1\n            for i in range(len(q)):\n                node = q.popleft()\n                if wordList[node] == endWord:\n                    return res\n                for nei in adj[node]:\n                    if nei not in visit:\n                        visit.add(nei)\n                        q.append(nei)\n            \n        return 0\n", "time_complexity": "O(n ^ 2 * m)"},
{"code": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if (endWord not in wordList) or (beginWord == endWord):\n            return 0\n        words, res = set(wordList), 0\n        q = deque([beginWord])\n        while q:\n            res += 1\n            for _ in range(len(q)):\n                node = q.popleft()\n                if node == endWord:\n                    return res\n                for i in range(len(node)):\n                    for c in range(97, 123):\n                        if chr(c) == node[i]:\n                            continue\n                        nei = node[:i] + chr(c) + node[i + 1:]\n                        if nei in words:\n                            q.append(nei)\n                            words.remove(nei)\n        return 0\n", "time_complexity": "O(m ^ 2 * n)"},
{"code": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n\n        nei = collections.defaultdict(list)\n        wordList.append(beginWord)\n        for word in wordList:\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                nei[pattern].append(word)\n\n        visit = set([beginWord])\n        q = deque([beginWord])\n        res = 1\n        while q:\n            for i in range(len(q)):\n                word = q.popleft()\n                if word == endWord:\n                    return res\n                for j in range(len(word)):\n                    pattern = word[:j] + \"*\" + word[j + 1 :]\n                    for neiWord in nei[pattern]:\n                        if neiWord not in visit:\n                            visit.add(neiWord)\n                            q.append(neiWord)\n            res += 1\n        return 0\n", "time_complexity": "O(m ^ 2 * n)"},
{"code": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList or beginWord == endWord:\n            return 0\n        m = len(wordList[0])\n        wordSet = set(wordList)\n        qb, qe = deque([beginWord]), deque([endWord])\n        fromBegin, fromEnd = {beginWord: 1}, {endWord: 1}\n        \n        while qb and qe:\n            if len(qb) > len(qe):\n                qb, qe = qe, qb\n                fromBegin, fromEnd = fromEnd, fromBegin\n            for _ in range(len(qb)):\n                word = qb.popleft()\n                steps = fromBegin[word]\n                for i in range(m):\n                    for c in range(97, 123):\n                        if chr(c) == word[i]:\n                            continue\n                        nei = word[:i] + chr(c) + word[i + 1:]\n                        if nei not in wordSet:\n                            continue\n                        if nei in fromEnd:\n                            return steps + fromEnd[nei]\n                        if nei not in fromBegin:\n                            fromBegin[nei] = steps + 1\n                            qb.append(nei)\n        return 0\n", "time_complexity": "O(m ^ 2 * n)"},
{"code": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        # Map each course to its prerequisites\n        preMap = {i: [] for i in range(numCourses)}\n        for crs, pre in prerequisites:\n            preMap[crs].append(pre)\n\n        # Store all courses along the current DFS path\n        visiting = set()\n\n        def dfs(crs):\n            if crs in visiting:\n                # Cycle detected\n                return False\n            if preMap[crs] == []:\n                return True\n\n            visiting.add(crs)\n            for pre in preMap[crs]:\n                if not dfs(pre):\n                    return False\n            visiting.remove(crs)\n            preMap[crs] = []\n            return True\n\n        for c in range(numCourses):\n            if not dfs(c):\n                return False\n        return True\n", "time_complexity": "O(V + E)"},
{"code": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        indegree = [0] * numCourses\n        adj = [[] for i in range(numCourses)]\n        for src, dst in prerequisites:\n            indegree[dst] += 1\n            adj[src].append(dst)\n\n        q = deque()\n        for n in range(numCourses):\n            if indegree[n] == 0:\n                q.append(n)\n        \n        finish = 0\n        while q:\n            node = q.popleft()\n            finish += 1\n            for nei in adj[node]:\n                indegree[nei] -= 1\n                if indegree[nei] == 0:\n                    q.append(nei)\n                \n        return finish == numCourses\n", "time_complexity": "O(V + E)"},
{"code": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        prereq = {c: [] for c in range(numCourses)}\n        for crs, pre in prerequisites:\n            prereq[crs].append(pre)\n\n        output = []\n        visit, cycle = set(), set()\n\n        def dfs(crs):\n            if crs in cycle:\n                return False\n            if crs in visit:\n                return True\n\n            cycle.add(crs)\n            for pre in prereq[crs]:\n                if dfs(pre) == False:\n                    return False\n            cycle.remove(crs)\n            visit.add(crs)\n            output.append(crs)\n            return True\n\n        for c in range(numCourses):\n            if dfs(c) == False:\n                return []\n        return output\n", "time_complexity": "O(V + E)"},
{"code": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        indegree = [0] * numCourses\n        adj = [[] for i in range(numCourses)]\n        for src, dst in prerequisites:\n            indegree[dst] += 1\n            adj[src].append(dst)\n\n        q = deque()\n        for n in range(numCourses):\n            if indegree[n] == 0:\n                q.append(n)\n        \n        finish, output = 0, []\n        while q:\n            node = q.popleft()\n            output.append(node)\n            finish += 1\n            for nei in adj[node]:\n                indegree[nei] -= 1\n                if indegree[nei] == 0:\n                    q.append(nei)\n        \n        if finish != numCourses:\n            return []\n        return output[::-1]\n", "time_complexity": "O(V + E)"},
{"code": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        adj = [[] for i in range(numCourses)]\n        indegree = [0] * numCourses\n        for nxt, pre in prerequisites:\n            indegree[nxt] += 1\n            adj[pre].append(nxt)\n        \n        output = []\n\n        def dfs(node):\n            output.append(node)\n            indegree[node] -= 1\n            for nei in adj[node]:\n                indegree[nei] -= 1\n                if indegree[nei] == 0:\n                    dfs(nei)\n        \n        for i in range(numCourses):\n            if indegree[i] == 0:\n                dfs(i)\n        \n        return output if len(output) == numCourses else []\n", "time_complexity": "O(V + E)"},
{"code": "class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        ROWS, COLS = len(board), len(board[0])\n\n        def capture(r, c):\n            if (r < 0 or c < 0 or r == ROWS or \n                c == COLS or board[r][c] != \"O\"\n            ):\n                return\n            board[r][c] = \"T\"\n            capture(r + 1, c)\n            capture(r - 1, c)\n            capture(r, c + 1)\n            capture(r, c - 1)\n\n        for r in range(ROWS):\n            if board[r][0] == \"O\":\n                capture(r, 0)\n            if board[r][COLS - 1] == \"O\":\n                capture(r, COLS - 1)\n        \n        for c in range(COLS):\n            if board[0][c] == \"O\":\n                capture(0, c)\n            if board[ROWS - 1][c] == \"O\":\n                capture(ROWS - 1, c)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \"O\":\n                    board[r][c] = \"X\"\n                elif board[r][c] == \"T\":\n                    board[r][c] = \"O\"\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        ROWS, COLS = len(board), len(board[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        def capture():\n            q = deque()\n            for r in range(ROWS):\n                for c in range(COLS):\n                    if (r == 0 or r == ROWS - 1 or \n                        c == 0 or c == COLS - 1 and \n                        board[r][c] == \"O\"\n                    ):\n                        q.append((r, c))\n            while q:\n                r, c = q.popleft()\n                if board[r][c] == \"O\":\n                    board[r][c] = \"T\"\n                    for dr, dc in directions:\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < ROWS and 0 <= nc < COLS:\n                            q.append((nr, nc))\n        \n        capture()\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \"O\":\n                    board[r][c] = \"X\"\n                elif board[r][c] == \"T\":\n                    board[r][c] = \"O\"\n", "time_complexity": "O(m * n)"},
{"code": "class DSU:\n    def __init__(self, n):\n        self.Parent = list(range(n + 1))\n        self.Size = [1] * (n + 1)\n\n    def find(self, node):\n        if self.Parent[node] != node:\n            self.Parent[node] = self.find(self.Parent[node])\n        return self.Parent[node]\n\n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv:\n            return False\n        if self.Size[pu] >= self.Size[pv]:\n            self.Size[pu] += self.Size[pv]\n            self.Parent[pv] = pu\n        else:\n            self.Size[pv] += self.Size[pu]\n            self.Parent[pu] = pv\n        return True\n    \n    def connected(self, u, v):\n        return self.find(u) == self.find(v)\n\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        ROWS, COLS = len(board), len(board[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        dsu = DSU(ROWS * COLS + 1)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] != \"O\":\n                    continue\n                if (r == 0 or c == 0 or \n                    r == (ROWS - 1) or c == (COLS - 1)\n                ):\n                    dsu.union(ROWS * COLS, r * COLS + c)\n                else:\n                    for dx, dy in directions:\n                        nr, nc = r + dx, c + dy\n                        if board[nr][nc] == \"O\":\n                            dsu.union(r * COLS + c, nr * COLS + nc)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if not dsu.connected(ROWS * COLS, r * COLS + c):\n                    board[r][c] = \"X\"\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        adj = defaultdict(list)\n        for u, v, w in times:\n            adj[u].append((v, w))\n        \n        dist = {node: float(\"inf\") for node in range(1, n + 1)}\n\n        def dfs(node, time):\n            if time >= dist[node]:\n                return\n            \n            dist[node] = time\n            for nei, w in adj[node]:\n                dfs(nei, time + w)\n        \n        dfs(k, 0)\n        res = max(dist.values())\n        return res if res < float('inf') else -1\n", "time_complexity": "O(V * E)"},
{"code": "class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        inf = float('inf')\n        dist = [[inf] * n for _ in range(n)]\n        \n        for u, v, w in times:\n            dist[u-1][v-1] = w\n        for i in range(n):\n            dist[i][i] = 0\n        \n        for mid in range(n):\n            for i in range(n):\n                for j in range(n):\n                    dist[i][j] = min(dist[i][j], dist[i][mid] + dist[mid][j])\n        \n        res = max(dist[k-1])\n        return res if res < inf else -1\n", "time_complexity": "O(V ^ 3)"},
{"code": "class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        dist = [float('inf')] * n\n        dist[k - 1] = 0\n        for _ in range(n - 1):\n            for u, v, w in times:\n                if dist[u - 1] + w < dist[v - 1]:\n                    dist[v - 1] = dist[u - 1] + w\n        max_dist = max(dist)\n        return max_dist if max_dist < float('inf') else -1\n", "time_complexity": "O(V * E)"},
{"code": "class Solution:\n    def networkDelayTime(self, times, n, k):\n        adj = defaultdict(list)\n        for u, v, w in times:\n            adj[u].append((v, w))\n        \n        dist = {node: float(\"inf\") for node in range(1, n + 1)}\n        q = deque([(k, 0)])\n        dist[k] = 0\n\n        while q:\n            node, time = q.popleft()\n            if dist[node] < time:\n                continue\n            for nei, w in adj[node]:\n                if time + w < dist[nei]:\n                    dist[nei] = time + w\n                    q.append((nei, time + w))\n\n        res = max(dist.values())\n        return res if res < float('inf') else -1\n", "time_complexity": "O(V + E)$ in average case, $O(V * E)"},
{"code": "class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        edges = collections.defaultdict(list)\n        for u, v, w in times:\n            edges[u].append((v, w))\n\n        minHeap = [(0, k)]\n        visit = set()\n        t = 0\n        while minHeap:\n            w1, n1 = heapq.heappop(minHeap)\n            if n1 in visit:\n                continue\n            visit.add(n1)\n            t = w1\n\n            for n2, w2 in edges[n1]:\n                if n2 not in visit:\n                    heapq.heappush(minHeap, (w1 + w2, n2))\n        return t if len(visit) == n else -1\n", "time_complexity": "O(E \\log V)"},
{"code": "class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        ROWS, COLS = len(heights), len(heights[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        pacific = atlantic = False\n\n        def dfs(r, c, prevVal):\n            nonlocal pacific, atlantic\n            if r < 0 or c < 0:\n                pacific = True\n                return\n            if r >= ROWS or c >= COLS:\n                atlantic = True\n                return\n            if heights[r][c] > prevVal:\n                return\n\n            tmp = heights[r][c]\n            heights[r][c] = float('inf')\n            for dx, dy in directions:\n                dfs(r + dx, c + dy, tmp)\n                if pacific and atlantic:\n                    break\n            heights[r][c] = tmp\n\n        res = []\n        for r in range(ROWS):\n            for c in range(COLS):\n                pacific = False\n                atlantic = False\n                dfs(r, c, float('inf'))\n                if pacific and atlantic:\n                    res.append([r, c])\n        return res\n", "time_complexity": "O(m * n * 4 ^ {m * n})"},
{"code": "class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        ROWS, COLS = len(heights), len(heights[0])\n        pac, atl = set(), set()\n\n        def dfs(r, c, visit, prevHeight):\n            if ((r, c) in visit or \n                r < 0 or c < 0 or \n                r == ROWS or c == COLS or \n                heights[r][c] < prevHeight\n            ):\n                return\n            visit.add((r, c))\n            dfs(r + 1, c, visit, heights[r][c])\n            dfs(r - 1, c, visit, heights[r][c])\n            dfs(r, c + 1, visit, heights[r][c])\n            dfs(r, c - 1, visit, heights[r][c])\n\n        for c in range(COLS):\n            dfs(0, c, pac, heights[0][c])\n            dfs(ROWS - 1, c, atl, heights[ROWS - 1][c])\n\n        for r in range(ROWS):\n            dfs(r, 0, pac, heights[r][0])\n            dfs(r, COLS - 1, atl, heights[r][COLS - 1])\n\n        res = []\n        for r in range(ROWS):\n            for c in range(COLS):\n                if (r, c) in pac and (r, c) in atl:\n                    res.append([r, c])\n        return res\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        ROWS, COLS = len(heights), len(heights[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        pac = [[False] * COLS for _ in range(ROWS)]\n        atl = [[False] * COLS for _ in range(ROWS)]\n\n        def bfs(source, ocean):\n            q = deque(source)\n            while q:\n                r, c = q.popleft()\n                ocean[r][c] = True\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if (0 <= nr < ROWS and 0 <= nc < COLS and \n                        not ocean[nr][nc] and \n                        heights[nr][nc] >= heights[r][c]\n                    ):\n                        q.append((nr, nc))\n\n        pacific = []\n        atlantic = []\n        for c in range(COLS):\n            pacific.append((0, c))\n            atlantic.append((ROWS - 1, c))\n\n        for r in range(ROWS):\n            pacific.append((r, 0))\n            atlantic.append((r, COLS - 1))\n            \n        bfs(pacific, pac)\n        bfs(atlantic, atl)\n\n        res = []\n        for r in range(ROWS):\n            for c in range(COLS):\n                if pac[r][c] and atl[r][c]:\n                    res.append([r, c])\n        return res\n", "time_complexity": "O(m * n)"},
{"code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\n\nclass Solution:\n    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\n        oldToNew = {}\n\n        def dfs(node):\n            if node in oldToNew:\n                return oldToNew[node]\n\n            copy = Node(node.val)\n            oldToNew[node] = copy\n            for nei in node.neighbors:\n                copy.neighbors.append(dfs(nei))\n            return copy\n\n        return dfs(node) if node else None\n", "time_complexity": "O(V + E)"},
{"code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\n\nclass Solution:\n    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\n        if not node:\n            return None\n\n        oldToNew = {}\n        oldToNew[node] = Node(node.val)\n        q = deque([node])\n\n        while q:\n            cur = q.popleft()\n            for nei in cur.neighbors:\n                if nei not in oldToNew:\n                    oldToNew[nei] = Node(nei.val)\n                    q.append(nei)\n                oldToNew[cur].neighbors.append(oldToNew[nei])\n\n        return oldToNew[node]\n", "time_complexity": "O(V + E)"},
{"code": "class WordDictionary:\n\n    def __init__(self):\n        self.store = []\n\n    def addWord(self, word: str) -> None:\n        self.store.append(word)\n\n    def search(self, word: str) -> bool:\n        for w in self.store:\n            if len(w) != len(word):\n                continue\n            i = 0\n            while i < len(w):\n                if w[i] == word[i] or word[i] == '.':\n                    i += 1\n                else:\n                    break\n            if i == len(w):\n                return True\n        return False\n", "time_complexity": "O(1)$ for $addWord()$, $O(m * n)$ for $search()"},
{"code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        cur = self.root\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n        cur.word = True\n\n    def search(self, word: str) -> bool:\n        def dfs(j, root):\n            cur = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n                if c == \".\":\n                    for child in cur.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in cur.children:\n                        return False\n                    cur = cur.children[c]\n            return cur.word\n\n        return dfs(0, self.root)\n", "time_complexity": "O(n)$ for $addWord()$, $O(n)$ for $search()"},
{"code": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n        ROWS, COLS = len(grid), len(grid[0])\n        islands = 0\n\n        def dfs(r, c):\n            if (r < 0 or c < 0 or r >= ROWS or \n                c >= COLS or grid[r][c] == \"0\"\n            ):\n                return\n                \n            grid[r][c] = \"0\"\n            for dr, dc in directions:\n                dfs(r + dr, c + dc)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == \"1\":\n                    dfs(r, c)\n                    islands += 1\n\n        return islands\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n        ROWS, COLS = len(grid), len(grid[0])\n        islands = 0\n\n        def bfs(r, c):\n            q = deque()\n            grid[r][c] = \"0\"\n            q.append((r, c))\n\n            while q:\n                row, col = q.popleft()  \n                for dr, dc in directions:\n                    nr, nc = dr + row, dc + col\n                    if (nr < 0 or nc < 0 or nr >= ROWS or\n                        nc >= COLS or grid[nr][nc] == \"0\"\n                    ):\n                        continue\n                    q.append((nr, nc))\n                    grid[nr][nc] = \"0\"\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == \"1\":\n                    bfs(r, c)\n                    islands += 1\n\n        return islands\n", "time_complexity": "O(m * n)"},
{"code": "class DSU:\n    def __init__(self, n):\n        self.Parent = list(range(n + 1))\n        self.Size = [1] * (n + 1)\n\n    def find(self, node):\n        if self.Parent[node] != node:\n            self.Parent[node] = self.find(self.Parent[node])\n        return self.Parent[node]\n\n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv:\n            return False\n        if self.Size[pu] >= self.Size[pv]:\n            self.Size[pu] += self.Size[pv]\n            self.Parent[pv] = pu\n        else:\n            self.Size[pv] += self.Size[pu]\n            self.Parent[pu] = pv\n        return True\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        dsu = DSU(ROWS * COLS)\n\n        def index(r, c):\n            return r * COLS + c\n\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        islands = 0\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == '1':\n                    islands += 1\n                    for dr, dc in directions:\n                        nr, nc = r + dr, c + dc\n                        if (nr < 0 or nc < 0 or nr >= ROWS or\n                            nc >= COLS or grid[nr][nc] == \"0\"\n                        ):\n                            continue\n                            \n                        if dsu.union(index(r, c), index(nr, nc)):\n                            islands -= 1\n\n        return islands\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        res = []\n        board = [[\".\"] * n for i in range(n)]\n\n        def backtrack(r):\n            if r == n:\n                copy = [\"\".join(row) for row in board]\n                res.append(copy)\n                return\n            for c in range(n):\n                if self.isSafe(r, c, board):\n                    board[r][c] = \"Q\"\n                    backtrack(r + 1)\n                    board[r][c] = \".\"\n\n        backtrack(0)\n        return res\n\n    def isSafe(self, r: int, c: int, board):\n        row = r - 1\n        while row >= 0:\n            if board[row][c] == \"Q\":\n                return False\n            row -= 1\n            \n        row, col = r - 1, c - 1\n        while row >= 0 and col >= 0:\n            if board[row][col] == \"Q\":\n                return False\n            row -= 1\n            col -= 1\n\n        row, col = r - 1, c + 1\n        while row >= 0 and col < len(board):\n            if board[row][col] == \"Q\":\n                return False\n            row -= 1\n            col += 1\n        return True\n", "time_complexity": "O(n!)"},
{"code": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        col = set()\n        posDiag = set()\n        negDiag = set()\n\n        res = []\n        board = [[\".\"] * n for i in range(n)]\n\n        def backtrack(r):\n            if r == n:\n                copy = [\"\".join(row) for row in board]\n                res.append(copy)\n                return\n\n            for c in range(n):\n                if c in col or (r + c) in posDiag or (r - c) in negDiag:\n                    continue\n\n                col.add(c)\n                posDiag.add(r + c)\n                negDiag.add(r - c)\n                board[r][c] = \"Q\"\n\n                backtrack(r + 1)\n\n                col.remove(c)\n                posDiag.remove(r + c)\n                negDiag.remove(r - c)\n                board[r][c] = \".\"\n\n        backtrack(0)\n        return res\n", "time_complexity": "O(n!)"},
{"code": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        col = [False] * n\n        posDiag = [False] * (n * 2)\n        negDiag = [False] * (n * 2)\n        res = []\n        board = [[\".\"] * n for i in range(n)]\n\n        def backtrack(r):\n            if r == n:\n                copy = [\"\".join(row) for row in board]\n                res.append(copy)\n                return\n            for c in range(n):\n                if col[c] or posDiag[r + c] or negDiag[r - c + n]:\n                    continue\n                col[c] = True\n                posDiag[r + c] = True\n                negDiag[r - c + n] = True\n                board[r][c] = \"Q\"\n\n                backtrack(r + 1)\n\n                col[c] = False\n                posDiag[r + c] = False\n                negDiag[r - c + n] = False\n                board[r][c] = \".\"\n\n        backtrack(0)\n        return res\n", "time_complexity": "O(n!)"},
{"code": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        col = 0\n        posDiag = 0\n        negDiag = 0\n        res = []\n        board = [[\".\"] * n for i in range(n)]\n\n        def backtrack(r):\n            nonlocal col, posDiag, negDiag \n            if r == n:\n                copy = [\"\".join(row) for row in board]\n                res.append(copy)\n                return\n            for c in range(n):\n                if ((col & (1 << c)) or (posDiag & (1 << (r + c))) \n                    or (negDiag & (1 << (r - c + n)))):\n                    continue\n                col ^= (1 << c)\n                posDiag ^= (1 << (r + c))\n                negDiag ^= (1 << (r - c + n))\n                board[r][c] = \"Q\"\n\n                backtrack(r + 1)\n\n                col ^= (1 << c)\n                posDiag ^= (1 << (r + c))\n                negDiag ^= (1 << (r - c + n))\n                board[r][c] = \".\"\n\n        backtrack(0)\n        return res\n", "time_complexity": "O(n!)"},
{"code": "class Solution:\n    def islandsAndTreasure(self, grid: List[List[int]]) -> None:\n        ROWS, COLS = len(grid), len(grid[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        INF = 2147483647\n        visit = [[False for _ in range(COLS)] for _ in range(ROWS)]\n\n        def dfs(r, c):\n            if (r < 0 or c < 0 or r >= ROWS or\n                c >= COLS or grid[r][c] == -1 or\n                visit[r][c]):\n                return INF\n            if grid[r][c] == 0:\n                return 0\n\n            visit[r][c] = True\n            res = INF\n            for dx, dy in directions:\n                res = min(res, 1 + dfs(r + dx, c + dy))\n            visit[r][c] = False\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == INF:\n                    grid[r][c] = dfs(r, c)\n", "time_complexity": "O(m * n * 4 ^ {m * n})"},
{"code": "class Solution:\n    def islandsAndTreasure(self, grid: List[List[int]]) -> None:\n        ROWS, COLS = len(grid), len(grid[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        INF = 2147483647\n\n        def bfs(r, c):\n            q = deque([(r, c)])\n            visit = [[False] * COLS for _ in range(ROWS)]\n            visit[r][c] = True\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    row, col = q.popleft()\n                    if grid[row][col] == 0:\n                        return steps\n                    for dr, dc in directions:\n                        nr, nc = row + dr, col + dc\n                        if (0 <= nr < ROWS and 0 <= nc < COLS and \n                            not visit[nr][nc] and grid[nr][nc] != -1\n                        ):\n                            visit[nr][nc] = True\n                            q.append((nr, nc))\n                steps += 1\n            return INF\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == INF:\n                    grid[r][c] = bfs(r, c)\n", "time_complexity": "O((m * n) ^ 2)"},
{"code": "class Solution:\n    def islandsAndTreasure(self, grid: List[List[int]]) -> None:\n        ROWS, COLS = len(grid), len(grid[0])\n        visit = set()\n        q = deque()\n\n        def addCell(r, c):\n            if (min(r, c) < 0 or r == ROWS or c == COLS or\n                (r, c) in visit or grid[r][c] == -1\n            ):\n                return\n            visit.add((r, c))\n            q.append([r, c])\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 0:\n                    q.append([r, c])\n                    visit.add((r, c))\n\n        dist = 0\n        while q:\n            for i in range(len(q)):\n                r, c = q.popleft()\n                grid[r][c] = dist\n                addCell(r + 1, c)\n                addCell(r - 1, c)\n                addCell(r, c + 1)\n                addCell(r, c - 1)\n            dist += 1\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        ROWS, COLS = len(board), len(board[0])\n        res = []\n\n        def backtrack(r, c, i):\n            if i == len(word):\n                return True\n            if (r < 0 or c < 0 or r >= ROWS or \n                c >= COLS or board[r][c] != word[i]\n            ):\n                return False\n\n            board[r][c] = '*'\n            ret = (backtrack(r + 1, c, i + 1) or\n                   backtrack(r - 1, c, i + 1) or\n                   backtrack(r, c + 1, i + 1) or\n                   backtrack(r, c - 1, i + 1))\n            board[r][c] = word[i]\n            return ret\n\n        for word in words:\n            flag = False\n            for r in range(ROWS):\n                if flag:\n                    break\n                for c in range(COLS):\n                    if board[r][c] != word[0]:\n                        continue\n                    if backtrack(r, c, 0):\n                        res.append(word)\n                        flag = True\n                        break\n        return res\n", "time_complexity": "O(m * n * 4 ^ t + s)"},
{"code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n\n    def addWord(self, word):\n        cur = self\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n        cur.isWord = True\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        root = TrieNode()\n        for w in words:\n            root.addWord(w)\n\n        ROWS, COLS = len(board), len(board[0])\n        res, visit = set(), set()\n\n        def dfs(r, c, node, word):\n            if (r < 0 or c < 0 or r >= ROWS or \n                c >= COLS or (r, c) in visit or \n                board[r][c] not in node.children\n            ):\n                return\n\n            visit.add((r, c))\n            node = node.children[board[r][c]]\n            word += board[r][c]\n            if node.isWord:\n                res.add(word)\n\n            dfs(r + 1, c, node, word)\n            dfs(r - 1, c, node, word)\n            dfs(r, c + 1, node, word)\n            dfs(r, c - 1, node, word)\n            visit.remove((r, c))\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, root, \"\")\n\n        return list(res)\n", "time_complexity": "O(m * n * 4 * 3 ^ {t - 1} + s)"},
{"code": "class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.idx = -1\n        self.refs = 0\n\n    def addWord(self, word, i):\n        cur = self\n        cur.refs += 1\n        for c in word:\n            index = ord(c) - ord('a')\n            if not cur.children[index]:\n                cur.children[index] = TrieNode()\n            cur = cur.children[index]\n            cur.refs += 1\n        cur.idx = i\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        root = TrieNode()\n        for i in range(len(words)):\n            root.addWord(words[i], i)\n\n        ROWS, COLS = len(board), len(board[0])\n        res = []\n\n        def getIndex(c):\n            index = ord(c) - ord('a')\n            return index\n\n        def dfs(r, c, node):\n            if (r < 0 or c < 0 or r >= ROWS or \n                c >= COLS or board[r][c] == '*' or \n                not node.children[getIndex(board[r][c])]):\n                return\n            \n            tmp = board[r][c]\n            board[r][c] = '*'\n            prev = node\n            node = node.children[getIndex(tmp)]\n            if node.idx != -1:\n                res.append(words[node.idx])\n                node.idx = -1\n                node.refs -= 1\n                if not node.refs:\n                    prev.children[getIndex(tmp)] = None\n                    node = None\n                    board[r][c] = tmp\n                    return\n\n            dfs(r + 1, c, node)\n            dfs(r - 1, c, node)\n            dfs(r, c + 1, node)\n            dfs(r, c - 1, node)\n\n            board[r][c] = tmp\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, root)\n\n        return res\n", "time_complexity": "O(m * n * 4 * 3 ^ {t - 1} + s)"},
{"code": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        res = []\n        digitToChar = {\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",\n            \"7\": \"qprs\",\n            \"8\": \"tuv\",\n            \"9\": \"wxyz\",\n        }\n\n        def backtrack(i, curStr):\n            if len(curStr) == len(digits):\n                res.append(curStr)\n                return\n            for c in digitToChar[digits[i]]:\n                backtrack(i + 1, curStr + c)\n\n        if digits:\n            backtrack(0, \"\")\n\n        return res\n", "time_complexity": "O(n * 4 ^ n)"},
{"code": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n\n        res = [\"\"]\n        digitToChar = {\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",\n            \"7\": \"qprs\",\n            \"8\": \"tuv\",\n            \"9\": \"wxyz\",\n        }\n\n        for digit in digits:\n            tmp = []\n            for curStr in res:\n                for c in digitToChar[digit]:\n                    tmp.append(curStr + c)\n            res = tmp\n        return res\n", "time_complexity": "O(n * 4 ^ n)"},
{"code": "class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        q = collections.deque()\n        fresh = 0\n        time = 0\n\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 1:\n                    fresh += 1\n                if grid[r][c] == 2:\n                    q.append((r, c))\n\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n        while fresh > 0 and q:\n            length = len(q)\n            for i in range(length):\n                r, c = q.popleft()\n\n                for dr, dc in directions:\n                    row, col = r + dr, c + dc\n                    if (row in range(len(grid))\n                        and col in range(len(grid[0]))\n                        and grid[row][col] == 1\n                    ):\n                        grid[row][col] = 2\n                        q.append((row, col))\n                        fresh -= 1\n            time += 1\n        return time if fresh == 0 else -1\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        fresh = 0\n        time = 0\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 1:\n                    fresh += 1\n\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n        while fresh > 0:\n            flag = False\n            for r in range(ROWS):\n                for c in range(COLS):\n                    if grid[r][c] == 2:\n                        for dr, dc in directions:\n                            row, col = r + dr, c + dc\n                            if (row in range(ROWS) and \n                                col in range(COLS) and \n                                grid[row][col] == 1):\n                                grid[row][col] = 3  \n                                fresh -= 1\n                                flag = True\n\n            if not flag:\n                return -1\n\n            for r in range(ROWS):\n                for c in range(COLS):\n                    if grid[r][c] == 3:\n                        grid[r][c] = 2  \n\n            time += 1\n\n        return time\n", "time_complexity": "O((m * n) ^ 2)"},
{"code": "class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        visit = set()\n\n        def dfs(r, c):\n            if (r < 0 or r == ROWS or c < 0 or\n                c == COLS or grid[r][c] == 0 or\n                (r, c) in visit\n            ):\n                return 0\n            visit.add((r, c))\n            return (1 + dfs(r + 1, c) + \n                        dfs(r - 1, c) + \n                        dfs(r, c + 1) + \n                        dfs(r, c - 1))\n\n        area = 0\n        for r in range(ROWS):\n            for c in range(COLS):\n                area = max(area, dfs(r, c))\n        return area\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n        ROWS, COLS = len(grid), len(grid[0])\n        area = 0\n\n        def bfs(r, c):\n            q = deque()\n            grid[r][c] = 0\n            q.append((r, c))\n            res = 1\n\n            while q:\n                row, col = q.popleft()  \n                for dr, dc in directions:\n                    nr, nc = dr + row, dc + col\n                    if (nr < 0 or nc < 0 or nr >= ROWS or\n                        nc >= COLS or grid[nr][nc] == 0\n                    ):\n                        continue\n                    q.append((nr, nc))\n                    grid[nr][nc] = 0\n                    res += 1\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 1:\n                    area = max(area, bfs(r, c))\n\n        return area\n", "time_complexity": "O(m * n)"},
{"code": "class DSU:\n    def __init__(self, n):\n        self.Parent = list(range(n + 1))\n        self.Size = [1] * (n + 1)\n\n    def find(self, node):\n        if self.Parent[node] != node:\n            self.Parent[node] = self.find(self.Parent[node])\n        return self.Parent[node]\n\n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv:\n            return False\n        if self.Size[pu] >= self.Size[pv]:\n            self.Size[pu] += self.Size[pv]\n            self.Parent[pv] = pu\n        else:\n            self.Size[pv] += self.Size[pu]\n            self.Parent[pu] = pv\n        return True\n    \n    def getSize(self, node):\n        par = self.find(node)\n        return self.Size[par]\n\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        dsu = DSU(ROWS * COLS)\n\n        def index(r, c):\n            return r * COLS + c\n\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        area = 0\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 1:\n                    for dr, dc in directions:\n                        nr, nc = r + dr, c + dc\n                        if (nr < 0 or nc < 0 or nr >= ROWS or\n                            nc >= COLS or grid[nr][nc] == 0\n                        ):\n                            continue\n                            \n                        dsu.union(index(r, c), index(nr, nc))\n\n                    area = max(area, dsu.getSize(index(r, c)))\n\n        return area\n", "time_complexity": "O(m * n)"},
{"code": "class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.endOfWord = False\n\nclass PrefixTree:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        cur = self.root\n        for c in word:\n            i = ord(c) - ord(\"a\")\n            if cur.children[i] == None:\n                cur.children[i] = TrieNode()\n            cur = cur.children[i]\n        cur.endOfWord = True\n\n    def search(self, word: str) -> bool:\n        cur = self.root\n        for c in word:\n            i = ord(c) - ord(\"a\")\n            if cur.children[i] == None:\n                return False\n            cur = cur.children[i]\n        return cur.endOfWord\n\n    def startsWith(self, prefix: str) -> bool:\n        cur = self.root\n        for c in prefix:\n            i = ord(c) - ord(\"a\")\n            if cur.children[i] == None:\n                return False\n            cur = cur.children[i]\n        return True\n", "time_complexity": "O(n)"},
{"code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = False\n\nclass PrefixTree:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        cur = self.root\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n        cur.endOfWord = True\n\n    def search(self, word: str) -> bool:\n        cur = self.root\n        for c in word:\n            if c not in cur.children:\n                return False\n            cur = cur.children[c]\n        return cur.endOfWord\n\n    def startsWith(self, prefix: str) -> bool:\n        cur = self.root\n        for c in prefix:\n            if c not in cur.children:\n                return False\n            cur = cur.children[c]\n        return True\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        res = set()\n\n        def backtrack(i, subset):\n            if i == len(nums):\n                res.add(tuple(subset))\n                return\n\n            subset.append(nums[i])\n            backtrack(i + 1, subset)\n            subset.pop()\n            backtrack(i + 1, subset)\n\n        nums.sort()\n        backtrack(0, [])\n        return [list(s) for s in res]\n", "time_complexity": "O(n * 2 ^n)"},
{"code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        def backtrack(i, subset):\n            if i == len(nums):\n                res.append(subset[::])\n                return\n\n            subset.append(nums[i])\n            backtrack(i + 1, subset)\n            subset.pop()\n\n            while i + 1 < len(nums) and nums[i] == nums[i + 1]:\n                i += 1\n            backtrack(i + 1, subset)\n\n        backtrack(0, [])\n        return res\n", "time_complexity": "O(n * 2 ^ n)"},
{"code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        res = []\n        def backtrack(i, subset):\n            res.append(subset[::])\n\n            for j in range(i, len(nums)):\n                if j > i and nums[j] == nums[j - 1]:\n                    continue\n                subset.append(nums[j])\n                backtrack(j + 1, subset)\n                subset.pop()\n\n        backtrack(0, [])\n        return res\n", "time_complexity": "O(n * 2 ^ n)"},
{"code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        res = [[]]\n        prev_Idx = idx = 0\n        for i in range(len(nums)):\n            idx = prev_idx if i >= 1 and nums[i] == nums[i - 1] else 0\n            prev_idx = len(res)\n            for j in range(idx, prev_idx):\n                tmp = res[j].copy()\n                tmp.append(nums[i])\n                res.append(tmp)\n        return res\n", "time_complexity": "O(n * 2 ^ n)"},
{"code": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        ROWS, COLS = len(board), len(board[0])\n        path = set()\n\n        def dfs(r, c, i):\n            if i == len(word):\n                return True\n            \n            if (min(r, c) < 0 or\n                r >= ROWS or c >= COLS or\n                word[i] != board[r][c] or\n                (r, c) in path):\n                return False\n            \n            path.add((r, c))\n            res = (dfs(r + 1, c, i + 1) or\n                   dfs(r - 1, c, i + 1) or\n                   dfs(r, c + 1, i + 1) or\n                   dfs(r, c - 1, i + 1))\n            path.remove((r, c))\n            return res\n        \n        for r in range(ROWS):\n            for c in range(COLS):\n                if dfs(r, c, 0):\n                    return True\n        return False\n", "time_complexity": "O(m * 4 ^ n)"},
{"code": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        ROWS, COLS = len(board), len(board[0])\n        visited = [[False for _ in range(COLS)] for _ in range(ROWS)]\n\n        def dfs(r, c, i):\n            if i == len(word):\n                return True\n            if (r < 0 or c < 0 or r >= ROWS or c >= COLS or\n                word[i] != board[r][c] or visited[r][c]):\n                return False\n\n            visited[r][c] = True\n            res = (dfs(r + 1, c, i + 1) or\n                   dfs(r - 1, c, i + 1) or\n                   dfs(r, c + 1, i + 1) or\n                   dfs(r, c - 1, i + 1))\n            visited[r][c] = False\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if dfs(r, c, 0):\n                    return True\n        return False\n", "time_complexity": "O(m * 4 ^ n)"},
{"code": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        ROWS, COLS = len(board), len(board[0])\n\n        def dfs(r, c, i):\n            if i == len(word):\n                return True\n            if (r < 0 or c < 0 or r >= ROWS or c >= COLS or\n                word[i] != board[r][c] or board[r][c] == '#'):\n                return False\n\n            board[r][c] = '#'\n            res = (dfs(r + 1, c, i + 1) or\n                   dfs(r - 1, c, i + 1) or\n                   dfs(r, c + 1, i + 1) or\n                   dfs(r, c - 1, i + 1))\n            board[r][c] = word[i]\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if dfs(r, c, 0):\n                    return True\n        return False\n", "time_complexity": "O(m * 4 ^ n)"},
{"code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res, part = [], []\n\n        def dfs(j, i):\n            if i >= len(s):\n                if i == j:\n                    res.append(part.copy())\n                return\n            \n            if self.isPali(s, j, i):\n                part.append(s[j : i + 1])\n                dfs(i + 1, i + 1)\n                part.pop()\n            \n            dfs(j, i + 1)\n        \n        dfs(0, 0)\n        return res\n\n    def isPali(self, s, l, r):\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l, r = l + 1, r - 1\n        return True\n", "time_complexity": "O(n * 2 ^ n)"},
{"code": "class Solution:\n    \n    def partition(self, s: str) -> List[List[str]]:\n        res, part = [], []\n\n        def dfs(i):\n            if i >= len(s):\n                res.append(part.copy())\n                return\n            for j in range(i, len(s)):\n                if self.isPali(s, i, j):\n                    part.append(s[i : j + 1])\n                    dfs(j + 1)\n                    part.pop()\n\n        dfs(0)\n        return res\n\n    def isPali(self, s, l, r):\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l, r = l + 1, r - 1\n        return True\n", "time_complexity": "O(n * 2 ^ n)"},
{"code": "class Solution:\n    \n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for l in range(1, n + 1):\n            for i in range(n - l + 1):\n                dp[i][i + l - 1] = (s[i] == s[i + l - 1] and\n                                    (i + 1 > (i + l - 2) or\n                                    dp[i + 1][i + l - 2]))\n\n        res, part = [], []\n        def dfs(i):\n            if i >= len(s):\n                res.append(part.copy())\n                return\n            for j in range(i, len(s)):\n                if dp[i][j]:\n                    part.append(s[i : j + 1])\n                    dfs(j + 1)\n                    part.pop()\n\n        dfs(0)\n        return res\n", "time_complexity": "O(n * 2 ^ n)"},
{"code": "class Solution:\n    \n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for l in range(1, n + 1):\n            for i in range(n - l + 1):\n                dp[i][i + l - 1] = (s[i] == s[i + l - 1] and\n                                    (i + 1 > (i + l - 2) or\n                                    dp[i + 1][i + l - 2]))\n        \n        def dfs(i):\n            if i >= n:\n                return [[]]  \n            \n            ret = []\n            for j in range(i, n):\n                if dp[i][j]:\n                    nxt = dfs(j + 1)\n                    for part in nxt:\n                        cur = [s[i : j + 1]] + part  \n                        ret.append(cur)\n            return ret\n        \n        return dfs(0)\n", "time_complexity": "O(n * 2 ^ n)"},
{"code": "class Solution:\n    def combinationSum(self, nums: List[int], target: int) -> List[List[int]]:\n        res = []\n\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n            if i >= len(nums) or total > target:\n                return\n\n            cur.append(nums[i])\n            dfs(i, cur, total + nums[i])\n            cur.pop()\n            dfs(i + 1, cur, total)\n\n        dfs(0, [], 0)\n        return res\n", "time_complexity": "O(2 ^ \\frac{t}{m})"},
{"code": "class Solution:\n    def combinationSum(self, nums: List[int], target: int) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n            \n            for j in range(i, len(nums)):\n                if total + nums[j] > target:\n                    return\n                cur.append(nums[j])\n                dfs(j, cur, total + nums[j])\n                cur.pop()\n        \n        dfs(0, [], 0)\n        return res\n", "time_complexity": "O(2 ^ \\frac{t}{m})"},
{"code": "class Solution:\n    def combinationSum2(self, candidates, target):\n        res = set()\n        candidates.sort()\n\n        def generate_subsets(i, cur, total):\n            if total == target:\n                res.add(tuple(cur))  \n                return\n            if total > target or i == len(candidates):\n                return\n\n            cur.append(candidates[i])\n            generate_subsets(i + 1, cur, total + candidates[i])\n            cur.pop()\n\n            generate_subsets(i + 1, cur, total)\n\n        generate_subsets(0, [], 0)\n        return [list(combination) for combination in res] \n", "time_complexity": "O(n * 2 ^ n)"},
{"code": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        res = []\n        candidates.sort()\n\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n            if total > target or i == len(candidates):\n                return\n            \n            cur.append(candidates[i])\n            dfs(i + 1, cur, total + candidates[i])\n            cur.pop()\n\n            \n            while i + 1 < len(candidates) and candidates[i] == candidates[i+1]:\n                i += 1\n            dfs(i + 1, cur, total)\n            \n        dfs(0, [], 0)\n        return res\n", "time_complexity": "O(n * 2 ^n)"},
{"code": "class Solution:\n    def combinationSum2(self, nums, target):\n        self.res = []\n        self.count = defaultdict(int)\n        cur = []\n        A = []\n        \n        for num in nums:\n            if self.count[num] == 0:\n                A.append(num)\n            self.count[num] += 1\n        self.backtrack(A, target, cur, 0)\n        return self.res\n\n    def backtrack(self, nums, target, cur, i):\n        if target == 0:\n            self.res.append(cur.copy())\n            return\n        if target < 0 or i >= len(nums):\n            return\n        \n        if self.count[nums[i]] > 0:\n            cur.append(nums[i])\n            self.count[nums[i]] -= 1\n            self.backtrack(nums, target - nums[i], cur, i)\n            self.count[nums[i]] += 1\n            cur.pop()\n\n        self.backtrack(nums, target, cur, i + 1)\n", "time_complexity": "O(n * 2 ^ n)"},
{"code": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        res = []\n        candidates.sort()\n\n        def dfs(idx, path, cur):\n            if cur == target:\n                res.append(path.copy())\n                return\n            for i in range(idx, len(candidates)):\n                if i > idx and candidates[i] == candidates[i - 1]:\n                    continue\n                if cur + candidates[i] > target:\n                    break\n\n                path.append(candidates[i])\n                dfs(i + 1, path, cur + candidates[i])\n                path.pop()\n\n        dfs(0, [], 0)\n        return res\n", "time_complexity": "O(n * 2 ^ n)"},
{"code": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        if len(nums) == 0:\n            return [[]]\n        \n        perms = self.permute(nums[1:])\n        res = []\n        for p in perms:\n            for i in range(len(p) + 1):\n                p_copy = p.copy()\n                p_copy.insert(i, nums[0])\n                res.append(p_copy)\n        return res\n", "time_complexity": "O(n! * n ^ 2)"},
{"code": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        perms = [[]]\n        for num in nums:\n            new_perms = []\n            for p in perms:\n                for i in range(len(p) + 1):\n                    p_copy = p.copy()\n                    p_copy.insert(i, num)\n                    new_perms.append(p_copy)\n            perms = new_perms\n        return perms\n", "time_complexity": "O(n! * n ^ 2)"},
{"code": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        self.res = []\n        self.backtrack([], nums, [False] * len(nums))\n        return self.res\n\n    def backtrack(self, perm: List[int], nums: List[int], pick: List[bool]):\n        if len(perm) == len(nums):\n            self.res.append(perm[:])\n            return\n        for i in range(len(nums)):\n            if not pick[i]:\n                perm.append(nums[i])\n                pick[i] = True\n                self.backtrack(perm, nums, pick)\n                perm.pop()\n                pick[i] = False\n", "time_complexity": "O(n! * n)"},
{"code": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        self.res = []\n        self.backtrack([], nums, 0)\n        return self.res\n\n    def backtrack(self, perm: List[int], nums: List[int], mask: int):\n        if len(perm) == len(nums):\n            self.res.append(perm[:])\n            return\n        for i in range(len(nums)):\n            if not (mask & (1 << i)):\n                perm.append(nums[i])\n                self.backtrack(perm, nums, mask | (1 << i))\n                perm.pop()\n", "time_complexity": "O(n! * n)"},
{"code": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        self.res = []\n        self.backtrack(nums, 0)\n        return self.res\n\n    def backtrack(self, nums: List[int], idx: int):\n        if idx == len(nums):\n            self.res.append(nums[:])\n            return\n        for i in range(idx, len(nums)):\n            nums[idx], nums[i] = nums[i], nums[idx]\n            self.backtrack(nums, idx + 1)\n            nums[idx], nums[i] = nums[i], nums[idx]\n", "time_complexity": "O(n! * n)"},
{"code": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = []\n\n        subset = []\n\n        def dfs(i):\n            if i >= len(nums):\n                res.append(subset.copy())\n                return\n            subset.append(nums[i])\n            dfs(i + 1)\n            subset.pop()\n            dfs(i + 1)\n\n        dfs(0)\n        return res\n", "time_complexity": "O(n * 2 ^ n)"},
{"code": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = [[]]\n        \n        for num in nums:\n            res += [subset + [num] for subset in res]\n        \n        return res\n", "time_complexity": "O(n * 2 ^ n)"},
{"code": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        n = len(nums)\n        res = []\n        for i in range(1 << n):\n            subset = [nums[j] for j in range(n) if (i & (1 << j))]\n            res.append(subset)\n        return res\n", "time_complexity": "O(n * 2 ^ n)"},
{"code": "class MedianFinder:\n\n    def __init__(self):\n        self.data = []\n\n    def addNum(self, num: int) -> None:\n        self.data.append(num)\n\n    def findMedian(self) -> float:\n        self.data.sort()\n        n = len(self.data)\n        return (self.data[n // 2] if (n & 1) else \n                (self.data[n // 2] + self.data[n // 2 - 1]) / 2)\n", "time_complexity": "O(m)$ for $addNum()$, $O(m * n \\log n)$ for $findMedian()"},
{"code": "class MedianFinder:\n    def __init__(self):\n        # two heaps, large, small, minheap, maxheap\n        # heaps should be equal size\n        self.small, self.large = [], []  \n\n    def addNum(self, num: int) -> None:\n        if self.large and num > self.large[0]:\n            heapq.heappush(self.large, num)\n        else:\n            heapq.heappush(self.small, -1 * num)\n\n        if len(self.small) > len(self.large) + 1:\n            val = -1 * heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.large) > len(self.small) + 1:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -1 * val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -1 * self.small[0]\n        elif len(self.large) > len(self.small):\n            return self.large[0]\n        return (-1 * self.small[0] + self.large[0]) / 2.0\n", "time_complexity": "O(m * \\log n)$ for $addNum()$, $O(m)$ for $findMedian()"},
{"code": "class Twitter:\n\n    def __init__(self):\n        self.time = 0\n        self.followMap = defaultdict(set)\n        self.tweetMap = defaultdict(list)\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweetMap[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        feed = self.tweetMap[userId][:]\n        for followeeId in self.followMap[userId]:\n            feed.extend(self.tweetMap[followeeId])\n\n        feed.sort(key=lambda x: -x[0])  \n        return [tweetId for _, tweetId in feed[:10]]\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        if followerId != followeeId:\n            self.followMap[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        self.followMap[followerId].discard(followeeId)\n", "time_complexity": "O(n * m + t\\log t)$ for each $getNewsFeed()$ call and $O(1)"},
{"code": "class Twitter:\n    def __init__(self):\n        self.count = 0\n        self.tweetMap = defaultdict(list)  # userId -> list of [count, tweetIds]\n        self.followMap = defaultdict(set)  # userId -> set of followeeId\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweetMap[userId].append([self.count, tweetId])\n        self.count -= 1\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        res = []\n        minHeap = []\n\n        self.followMap[userId].add(userId)\n        for followeeId in self.followMap[userId]:\n            if followeeId in self.tweetMap:\n                index = len(self.tweetMap[followeeId]) - 1\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n\n        while minHeap and len(res) < 10:\n            count, tweetId, followeeId, index = heapq.heappop(minHeap)\n            res.append(tweetId)\n            if index >= 0:\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.followMap[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followeeId in self.followMap[followerId]:\n            self.followMap[followerId].remove(followeeId)\n", "time_complexity": "O(n \\log n)$ for each $getNewsFeed()$ call and $O(1)"},
{"code": "class Twitter:\n\n    def __init__(self):\n        self.count = 0\n        self.tweetMap = defaultdict(list)  # userId -> list of [count, tweetIds]\n        self.followMap = defaultdict(set)  # userId -> set of followeeId\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweetMap[userId].append([self.count, tweetId])\n        if len(self.tweetMap[userId]) > 10:\n            self.tweetMap[userId].pop(0)\n        self.count -= 1\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        res = []\n        minHeap = []\n        self.followMap[userId].add(userId)\n        if len(self.followMap[userId]) >= 10:\n            maxHeap = []\n            for followeeId in self.followMap[userId]:\n                if followeeId in self.tweetMap:\n                    index = len(self.tweetMap[followeeId]) - 1\n                    count, tweetId = self.tweetMap[followeeId][index]\n                    heapq.heappush(maxHeap, [-count, tweetId, followeeId, index - 1])\n                    if len(maxHeap) > 10:\n                        heapq.heappop(maxHeap)\n            while maxHeap:\n                count, tweetId, followeeId, index = heapq.heappop(maxHeap)\n                heapq.heappush(minHeap, [-count, tweetId, followeeId, index])\n        else:\n            for followeeId in self.followMap[userId]:\n                if followeeId in self.tweetMap:\n                    index = len(self.tweetMap[followeeId]) - 1\n                    count, tweetId = self.tweetMap[followeeId][index]\n                    heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n\n        while minHeap and len(res) < 10:\n            count, tweetId, followeeId, index = heapq.heappop(minHeap)\n            res.append(tweetId)\n            if index >= 0:\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n        \n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.followMap[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followeeId in self.followMap[followerId]:\n            self.followMap[followerId].remove(followeeId)\n", "time_complexity": "O(n)$ for each $getNewsFeed()$ call and $O(1)"},
{"code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        return nums[len(nums) - k]\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def findKthLargest(self, nums, k):\n        return heapq.nlargest(k, nums)[-1]\n", "time_complexity": "O(n \\log k)"},
{"code": "class Solution:\n\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        k = len(nums) - k\n        \n        def quickSelect(l, r):\n            pivot, p = nums[r], l\n            for i in range(l, r):\n                if nums[i] <= pivot:\n                    nums[p], nums[i] = nums[i], nums[p]\n                    p += 1\n            nums[p], nums[r] = nums[r], nums[p]\n\n            if p > k: \n                return quickSelect(l, p - 1)\n            elif p < k:\n                return quickSelect(p + 1, r)\n            else:\n                return nums[p]\n\n        return quickSelect(0, len(nums) - 1)\n", "time_complexity": "O(n)$ in average case, $O(n ^ 2)"},
{"code": "class Solution:\n    def partition(self, nums: List[int], left: int, right: int) -> int:\n        mid = (left + right) >> 1\n        nums[mid], nums[left + 1] = nums[left + 1], nums[mid]\n        \n        if nums[left] < nums[right]:\n            nums[left], nums[right] = nums[right], nums[left]\n        if nums[left + 1] < nums[right]:\n            nums[left + 1], nums[right] = nums[right], nums[left + 1]\n        if nums[left] < nums[left + 1]:\n            nums[left], nums[left + 1] = nums[left + 1], nums[left]\n        \n        pivot = nums[left + 1]\n        i = left + 1\n        j = right\n        \n        while True:\n            while True:\n                i += 1\n                if not nums[i] > pivot:\n                    break\n            while True:\n                j -= 1\n                if not nums[j] < pivot:\n                    break\n            if i > j:\n                break\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        nums[left + 1], nums[j] = nums[j], nums[left + 1]\n        return j\n    \n    def quickSelect(self, nums: List[int], k: int) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while True:\n            if right <= left + 1:\n                if right == left + 1 and nums[right] > nums[left]:\n                    nums[left], nums[right] = nums[right], nums[left]\n                return nums[k]\n            \n            j = self.partition(nums, left, right)\n            \n            if j >= k:\n                right = j - 1\n            if j <= k:\n                left = j + 1\n    \n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return self.quickSelect(nums, k - 1)\n", "time_complexity": "O(n)$ in average case, $O(n ^ 2)"},
{"code": "class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        count = [0] * 26\n        for task in tasks:\n            count[ord(task) - ord('A')] += 1\n        \n        arr = []\n        for i in range(26):\n            if count[i] > 0:\n                arr.append([count[i], i])\n\n        time = 0\n        processed = []\n        while arr:\n            maxi = -1\n            for i in range(len(arr)):\n                if all(processed[j] != arr[i][1] for j in range(max(0, time - n), time)):\n                    if maxi == -1 or arr[maxi][0] < arr[i][0]:\n                        maxi = i\n            \n            time += 1\n            cur = -1\n            if maxi != -1:\n                cur = arr[maxi][1]\n                arr[maxi][0] -= 1\n                if arr[maxi][0] == 0:\n                    arr.pop(maxi)\n            processed.append(cur)\n        return time\n", "time_complexity": "O(t * n)"},
{"code": "class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        count = Counter(tasks)\n        maxHeap = [-cnt for cnt in count.values()]\n        heapq.heapify(maxHeap)\n\n        time = 0\n        q = deque()  # pairs of [-cnt, idleTime]\n        while maxHeap or q:\n            time += 1\n\n            if not maxHeap:\n                time = q[0][1]\n            else:\n                cnt = 1 + heapq.heappop(maxHeap)\n                if cnt:\n                    q.append([cnt, time + n])\n            if q and q[0][1] == time:\n                heapq.heappush(maxHeap, q.popleft()[0])\n        return time\n", "time_complexity": "O(m)"},
{"code": "class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        count = [0] * 26\n        for task in tasks:\n            count[ord(task) - ord('A')] += 1\n        \n        count.sort()\n        maxf = count[25]\n        idle = (maxf - 1) * n\n\n        for i in range(24, -1, -1):\n            idle -= min(maxf - 1, count[i])\n        return max(0, idle) + len(tasks)\n", "time_complexity": "O(m)"},
{"code": "class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        count = [0] * 26\n        for task in tasks:\n            count[ord(task) - ord('A')] += 1\n        \n        maxf = max(count)\n        maxCount = 0\n        for i in count:\n            maxCount += 1 if i == maxf else 0\n\n        time = (maxf - 1) * (n + 1) + maxCount\n        return max(len(tasks), time)\n", "time_complexity": "O(m)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Codec:\n    \n    # Encodes a tree to a single string.\n    def serialize(self, root: Optional[TreeNode]) -> str:\n        res = []\n\n        def dfs(node):\n            if not node:\n                res.append(\"N\")\n                return\n            res.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n        return \",\".join(res)\n        \n    # Decodes your encoded data to tree.\n    def deserialize(self, data: str) -> Optional[TreeNode]:\n        vals = data.split(\",\")\n        self.i = 0\n\n        def dfs():\n            if vals[self.i] == \"N\":\n                self.i += 1\n                return None\n            node = TreeNode(int(vals[self.i]))\n            self.i += 1\n            node.left = dfs()\n            node.right = dfs()\n            return node\n\n        return dfs()\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Codec:\n    \n    # Encodes a tree to a single string.\n    def serialize(self, root: Optional[TreeNode]) -> str:\n        if not root:\n            return \"N\"\n        res = []\n        queue = deque([root])\n        while queue:\n            node = queue.popleft()\n            if not node:\n                res.append(\"N\")\n            else:\n                res.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n        return \",\".join(res)\n        \n    # Decodes your encoded data to tree.\n    def deserialize(self, data: str) -> Optional[TreeNode]:\n        vals = data.split(\",\")\n        if vals[0] == \"N\":\n            return None\n        root = TreeNode(int(vals[0]))\n        queue = deque([root])\n        index = 1\n        while queue:\n            node = queue.popleft()\n            if vals[index] != \"N\":\n                node.left = TreeNode(int(vals[index]))\n                queue.append(node.left)\n            index += 1\n            if vals[index] != \"N\":\n                node.right = TreeNode(int(vals[index]))\n                queue.append(node.right)\n            index += 1\n        return root\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n\n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1 : mid + 1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid + 1 :], inorder[mid + 1 :])\n        return root\n", "time_complexity": "O(n ^ 2)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        indices = {val: idx for idx, val in enumerate(inorder)}\n        \n        self.pre_idx = 0\n        def dfs(l, r):\n            if l > r:\n                return None\n\n            root_val = preorder[self.pre_idx]\n            self.pre_idx += 1\n            root = TreeNode(root_val)\n            mid = indices[root_val]\n            root.left = dfs(l, mid - 1)\n            root.right = dfs(mid + 1, r)\n            return root\n\n        return dfs(0, len(inorder) - 1)\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        preIdx = inIdx = 0\n        def dfs(limit):\n            nonlocal preIdx, inIdx\n            if preIdx >= len(preorder):\n                return None\n            if inorder[inIdx] == limit:\n                inIdx += 1\n                return None\n            \n            root = TreeNode(preorder[preIdx])\n            preIdx += 1\n            root.left = dfs(root.val)\n            root.right = dfs(limit)\n            return root\n        return dfs(float('inf'))\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        res = -float('inf')\n        def dfs(root):\n            nonlocal res\n            if not root:\n                return \n            left = self.getMax(root.left)\n            right = self.getMax(root.right)\n            res =max(res, root.val + left + right)\n            dfs(root.left)\n            dfs(root.right)\n        dfs(root)\n        return res\n            \n    def getMax(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        left = self.getMax(root.left)\n        right = self.getMax(root.right)\n        path = root.val + max(left, right)\n        return max(0, path)\n", "time_complexity": "O(n ^ 2)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        res = [root.val]\n\n        def dfs(root):\n            if not root:\n                return 0\n\n            leftMax = dfs(root.left)\n            rightMax = dfs(root.right)\n            leftMax = max(leftMax, 0)\n            rightMax = max(rightMax, 0)\n\n            res[0] = max(res[0], root.val + leftMax + rightMax)\n            return root.val + max(leftMax, rightMax)\n\n        dfs(root)\n        return res[0]\n", "time_complexity": "O(n)"},
{"code": "class KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.arr = nums\n\n    def add(self, val: int) -> int:\n        self.arr.append(val)\n        self.arr.sort()\n        return self.arr[len(self.arr) - self.k]\n", "time_complexity": "O(m * n\\log n)"},
{"code": "class KthLargest:\n    \n    def __init__(self, k: int, nums: List[int]):\n        self.minHeap, self.k = nums, k\n        heapq.heapify(self.minHeap)\n        while len(self.minHeap) > k:\n            heapq.heappop(self.minHeap)\n\n    def add(self, val: int) -> int:\n        heapq.heappush(self.minHeap, val)\n        if len(self.minHeap) > self.k:\n            heapq.heappop(self.minHeap)\n        return self.minHeap[0]\n", "time_complexity": "O(m * \\log k)"},
{"code": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        \n        while len(stones) > 1:\n            stones.sort()\n            cur = stones.pop() - stones.pop()\n            if cur:\n                stones.append(cur)\n                \n        return stones[0] if stones else 0\n", "time_complexity": "O(n ^ 2 \\log n)"},
{"code": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        stones.sort()\n        n = len(stones)\n\n        while n > 1:\n            cur = stones.pop() - stones.pop()\n            n -= 2\n            if cur > 0:\n                l, r = 0, n\n                while l < r:\n                    mid = (l + r) // 2\n                    if stones[mid] < cur:\n                        l = mid + 1\n                    else:\n                        r = mid\n                pos = l\n                n += 1\n                stones.append(0)\n                for i in range(n - 1, pos, -1):\n                    stones[i] = stones[i - 1]\n                stones[pos] = cur\n\n        return stones[0] if n > 0 else 0\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        stones = [-s for s in stones]\n        heapq.heapify(stones)\n\n        while len(stones) > 1:\n            first = heapq.heappop(stones)\n            second = heapq.heappop(stones)\n            if second > first:\n                heapq.heappush(stones, first - second)\n\n        stones.append(0)\n        return abs(stones[0])\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n\n        maxStone = max(stones)\n        bucket = [0] * (maxStone + 1)\n        for stone in stones:\n            bucket[stone] += 1\n        \n        first = second = maxStone\n        while first > 0:\n            if bucket[first] % 2 == 0:\n                first -= 1\n                continue\n            \n            j = min(first - 1, second)\n            while j > 0 and bucket[j] == 0:\n                j -= 1\n            \n            if j == 0:\n                return first\n            second = j\n            bucket[first] -= 1\n            bucket[second] -= 1\n            bucket[first - second] += 1\n            first = max(first - second, second)\n        return first\n", "time_complexity": "O(n + w)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        arr = []\n\n        def dfs(node):\n            if not node:\n                return\n            \n            arr.append(node.val)\n            dfs(node.left)\n            dfs(node.right)\n        \n        dfs(root)\n        arr.sort()\n        return arr[k - 1]\n", "time_complexity": "O(n \\log n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        arr = []\n\n        def dfs(node):\n            if not node:\n                return\n            \n            dfs(node.left)\n            arr.append(node.val)\n            dfs(node.right)\n        \n        dfs(root)\n        return arr[k - 1]\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        cnt = k\n        res = root.val\n\n        def dfs(node):\n            nonlocal cnt, res\n            if not node:\n                return\n            \n            dfs(node.left)\n            cnt -= 1\n            if cnt == 0:\n                res = node.val\n                return\n            dfs(node.right)\n        \n        dfs(root)\n        return res\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stack = []\n        curr = root\n\n        while stack or curr:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            k -= 1\n            if k == 0:\n                return curr.val\n            curr = curr.right\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        curr = root\n        \n        while curr:\n            if not curr.left:\n                k -= 1\n                if k == 0:\n                    return curr.val\n                curr = curr.right\n            else:\n                pred = curr.left\n                while pred.right and pred.right != curr:\n                    pred = pred.right\n                \n                if not pred.right:\n                    pred.right = curr\n                    curr = curr.left\n                else:\n                    pred.right = None\n                    k -= 1\n                    if k == 0:\n                        return curr.val\n                    curr = curr.right\n\n        return -1  \n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    left_check = staticmethod(lambda val, limit: val < limit) \n    right_check = staticmethod(lambda val, limit: val > limit) \n\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n        \n        if (not self.isValid(root.left, root.val, self.left_check) or\n            not self.isValid(root.right, root.val, self.right_check)):\n            return False\n        \n        return self.isValidBST(root.left) and self.isValidBST(root.right)\n\n    def isValid(self, root: Optional[TreeNode], limit: int, check) -> bool:\n        if not root:\n            return True\n        if not check(root.val, limit):\n            return False\n        return (self.isValid(root.left, limit, check) and\n                self.isValid(root.right, limit, check))\n", "time_complexity": "O(n ^ 2)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        def valid(node, left, right):\n            if not node:\n                return True\n            if not (left < node.val < right):\n                return False\n\n            return valid(node.left, left, node.val) and valid(\n                node.right, node.val, right\n            )\n\n        return valid(root, float(\"-inf\"), float(\"inf\"))\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n\n        q = deque([(root, float(\"-inf\"), float(\"inf\"))])\n\n        while q:\n            node, left, right = q.popleft()\n            if not (left < node.val < right):\n                return False\n            if node.left:\n                q.append((node.left, left, node.val))\n            if node.right:\n                q.append((node.right, node.val, right))\n\n        return True\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n\n        def dfs(node, maxVal):\n            if not node:\n                return 0\n\n            res = 1 if node.val >= maxVal else 0\n            maxVal = max(maxVal, node.val)\n            res += dfs(node.left, maxVal)\n            res += dfs(node.right, maxVal)\n            return res\n\n        return dfs(root, root.val)\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        res = 0\n        q = deque()\n\t\t\n        q.append((root,-float('inf')))\n\n        while q:\n            node,maxval = q.popleft()\n            if node.val >= maxval:  \n                res += 1\n\t\t\t\t\n            if node.left:    \n                q.append((node.left,max(maxval,node.val)))\n            \n            if node.right:\n                q.append((node.right,max(maxval,node.val)))\n                \n        return res\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n\n        def dfs(node, depth):\n            if not node:\n                return None\n            if depth == len(res):\n                res.append(node.val)\n            \n            dfs(node.right, depth + 1)\n            dfs(node.left, depth + 1)\n        \n        dfs(root, 0)\n        return res\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        q = deque([root])\n\n        while q:\n            rightSide = None\n            qLen = len(q)\n\n            for i in range(qLen):\n                node = q.popleft()\n                if node:\n                    rightSide = node\n                    q.append(node.left)\n                    q.append(node.right)\n            if rightSide:\n                res.append(rightSide.val)\n        return res\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        res = []\n\n        def dfs(node, depth):\n            if not node:\n                return None\n            if len(res) == depth:\n                res.append([])\n            \n            res[depth].append(node.val)\n            dfs(node.left, depth + 1)\n            dfs(node.right, depth + 1)\n        \n        dfs(root, 0)\n        return res\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        res = []\n\n        q = collections.deque()\n        q.append(root)\n\n        while q:\n            qLen = len(q)\n            level = []\n            for i in range(qLen):\n                node = q.popleft()\n                if node:\n                    level.append(node.val)\n                    q.append(node.left)\n                    q.append(node.right)\n            if level:\n                res.append(level)\n                \n        return res\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        if not root or not p or not q:\n            return None\n        if (max(p.val, q.val) < root.val):\n            return self.lowestCommonAncestor(root.left, p, q)\n        elif (min(p.val, q.val) > root.val):\n            return self.lowestCommonAncestor(root.right, p, q)\n        else:\n            return root\n", "time_complexity": "O(h)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        cur = root\n\n        while cur:\n            if p.val > cur.val and q.val > cur.val:\n                cur = cur.right\n            elif p.val < cur.val and q.val < cur.val:\n                cur = cur.left\n            else:\n                return cur\n", "time_complexity": "O(h)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n        \n        left = self.height(root.left)\n        right = self.height(root.right)\n        if abs(left - right) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n\n    def height(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        return 1 + max(self.height(root.left), self.height(root.right))\n", "time_complexity": "O(n ^ 2)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if not root:\n                return [True, 0]\n\n            left, right = dfs(root.left), dfs(root.right)\n            balanced = left[0] and right[0] and abs(left[1] - right[1]) <= 1\n            return [balanced, 1 + max(left[1], right[1])]\n\n        return dfs(root)[0]\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isBalanced(self, root):\n        stack = []\n        node = root\n        last = None\n        depths = {}\n\n        while stack or node:\n            if node:\n                stack.append(node)\n                node = node.left\n            else:\n                node = stack[-1]\n                if not node.right or last == node.right:\n                    stack.pop()\n                    left = depths.get(node.left, 0)\n                    right = depths.get(node.right, 0)\n\n                    if abs(left - right) > 1:\n                        return False\n\n                    depths[node] = 1 + max(left, right)\n                    last = node\n                    node = None\n                else:\n                    node = node.right\n\n        return True\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    \n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not subRoot:\n            return True\n        if not root:\n            return False\n\n        if self.sameTree(root, subRoot):\n            return True\n        return (self.isSubtree(root.left, subRoot) or \n               self.isSubtree(root.right, subRoot))\n\n    def sameTree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not root and not subRoot:\n            return True\n        if root and subRoot and root.val == subRoot.val:\n            return (self.sameTree(root.left, subRoot.left) and \n                   self.sameTree(root.right, subRoot.right))\n        return False\n", "time_complexity": "O(m * n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution: \n    def serialize(self, root: Optional[TreeNode]) -> str:\n            if root == None:\n                return \"$#\"\n            \n            return (\"$\" + str(root.val) + \n                    self.serialize(root.left) + self.serialize(root.right))  \n\n    def z_function(self, s: str) -> list:\n        z = [0] * len(s)\n        l, r, n = 0, 0, len(s)\n        for i in range(1, n):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n            while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n            if i + z[i] - 1 > r:\n                l, r = i, i + z[i] - 1\n        return z\n\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        serialized_root = self.serialize(root)\n        serialized_subRoot = self.serialize(subRoot)\n        combined = serialized_subRoot + \"|\" + serialized_root\n        \n        z_values = self.z_function(combined)\n        sub_len = len(serialized_subRoot)\n        \n        for i in range(sub_len + 1, len(combined)):\n            if z_values[i] == sub_len:\n                return True\n        return False\n", "time_complexity": "O(m + n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if p and q and p.val == q.val:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        else:\n            return False\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        stack = [(p, q)]\n        \n        while stack:\n            node1, node2 = stack.pop()\n            \n            if not node1 and not node2:\n                continue\n            if not node1 or not node2 or node1.val != node2.val:\n                return False\n                \n            stack.append((node1.right, node2.right))\n            stack.append((node1.left, node2.left))\n        \n        return True\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        q1 = deque([p])\n        q2 = deque([q])\n\n        while q1 and q2:\n            for _ in range(len(q1)):\n                nodeP = q1.popleft()\n                nodeQ = q2.popleft()\n\n                if nodeP is None and nodeQ is None:\n                    continue\n                if nodeP is None or nodeQ is None or nodeP.val != nodeQ.val:\n                    return False\n\n                q1.append(nodeP.left)\n                q1.append(nodeP.right)\n                q2.append(nodeQ.left)\n                q2.append(nodeQ.right)\n\n        return True \n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        stack = [[root, 1]]\n        res = 0\n\n        while stack:\n            node, depth = stack.pop()\n\n            if node:\n                res = max(res, depth)\n                stack.append([node.left, depth + 1])\n                stack.append([node.right, depth + 1])\n        return res\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        q = deque()\n        if root:\n            q.append(root)\n\n        level = 0\n        while q:\n            for i in range(len(q)):\n                node = q.popleft()\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            level += 1\n        return level\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        queue = deque([root])\n        while queue:\n            node = queue.popleft()\n            node.left, node.right = node.right, node.left\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        return root\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root: return None\n\n        root.left, root.right = root.right, root.left\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            node.left, node.right = node.right, node.left\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return root\n", "time_complexity": "O(n)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        cur = head\n        group = 0\n        while cur and group < k:\n            cur = cur.next\n            group += 1\n\n        if group == k:\n            cur = self.reverseKGroup(cur, k)\n            while group > 0:\n                tmp = head.next\n                head.next = cur\n                cur = head\n                head = tmp\n                group -= 1\n            head = cur\n        return head\n", "time_complexity": "O(n)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        groupPrev = dummy\n\n        while True:\n            kth = self.getKth(groupPrev, k)\n            if not kth:\n                break\n            groupNext = kth.next\n\n            prev, curr = kth.next, groupPrev.next\n            while curr != groupNext:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n\n            tmp = groupPrev.next\n            groupPrev.next = kth\n            groupPrev = tmp\n        return dummy.next\n\n    def getKth(self, curr, k):\n        while curr and k > 0:\n            curr = curr.next\n            k -= 1\n        return curr\n", "time_complexity": "O(n)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:    \n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        nodes = []\n        for lst in lists:\n            while lst:\n                nodes.append(lst.val)\n                lst = lst.next\n        nodes.sort()\n\n        res = ListNode(0)\n        cur = res\n        for node in nodes:\n            cur.next = ListNode(node)\n            cur = cur.next\n        return res.next\n", "time_complexity": "O(n \\log n)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:    \n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        res = ListNode(0)\n        cur = res\n        \n        while True:\n            minNode = -1\n            for i in range(len(lists)):\n                if not lists[i]:\n                    continue\n                if minNode == -1 or lists[minNode].val > lists[i].val:\n                    minNode = i\n            \n            if minNode == -1:\n                break\n            cur.next = lists[minNode]\n            lists[minNode] = lists[minNode].next\n            cur = cur.next\n\n        return res.next\n", "time_complexity": "O(n * k)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:    \n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if len(lists) == 0:\n            return None\n\n        for i in range(1, len(lists)):\n            lists[i] = self.mergeList(lists[i - 1], lists[i])\n        \n        return lists[-1]\n\n    def mergeList(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next\n", "time_complexity": "O(n * k)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass NodeWrapper:\n    def __init__(self, node):\n        self.node = node\n\n    def __lt__(self, other):\n        return self.node.val < other.node.val\n\nclass Solution:    \n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if len(lists) == 0:\n            return None\n\n        res = ListNode(0)\n        cur = res\n        minHeap = []\n\n        for lst in lists:\n            if lst is not None:\n                heapq.heappush(minHeap, NodeWrapper(lst))\n\n        while minHeap:\n            node_wrapper = heapq.heappop(minHeap)\n            cur.next = node_wrapper.node\n            cur = cur.next\n            \n            if node_wrapper.node.next:\n                heapq.heappush(minHeap, NodeWrapper(node_wrapper.node.next))\n        \n        return res.next\n", "time_complexity": "O(n \\log k)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists):\n        if not lists or len(lists) == 0:\n            return None\n        return self.divide(lists, 0, len(lists) - 1)\n\n    def divide(self, lists, l, r):\n        if l > r:\n            return None\n        if l == r:\n            return lists[l]\n        mid = l + (r - l) // 2\n        left = self.divide(lists, l, mid)\n        right = self.divide(lists, mid + 1, r)\n        return self.conquer(left, right)\n\n    def conquer(self, l1, l2):\n        dummy = ListNode(0)\n        curr = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        if l1:\n            curr.next = l1\n        else:\n            curr.next = l2\n        return dummy.next\n", "time_complexity": "O(n \\log k)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    \n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists or len(lists) == 0:\n            return None\n\n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if (i + 1) < len(lists) else None\n                mergedLists.append(self.mergeList(l1, l2))\n            lists = mergedLists\n        return lists[0]\n\n    def mergeList(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next\n", "time_complexity": "O(n \\log k)"},
{"code": "class LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = []\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        for i in range(len(self.cache)):\n            if self.cache[i][0] == key:\n                tmp = self.cache.pop(i)\n                self.cache.append(tmp)\n                return tmp[1]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        for i in range(len(self.cache)):\n            if self.cache[i][0] == key:\n                tmp = self.cache.pop(i)\n                tmp[1] = value\n                self.cache.append(tmp)\n                return\n\n        if self.capacity == len(self.cache):\n            self.cache.pop(0)\n            \n        self.cache.append([key, value])\n", "time_complexity": "O(n)$ for each $put()$ and $get()"},
{"code": "class Node:\n    def __init__(self, key, val):\n        self.key, self.val = key, val\n        self.prev = self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}  # map key to node\n\n        self.left, self.right = Node(0, 0), Node(0, 0)\n        self.left.next, self.right.prev = self.right, self.left\n\n    def remove(self, node):\n        prev, nxt = node.prev, node.next\n        prev.next, nxt.prev = nxt, prev\n\n    def insert(self, node):\n        prev, nxt = self.right.prev, self.right\n        prev.next = nxt.prev = node\n        node.next, node.prev = nxt, prev\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n            return self.cache[key].val\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.remove(self.cache[key])\n        self.cache[key] = Node(key, value)\n        self.insert(self.cache[key])\n\n        if len(self.cache) > self.cap:\n            lru = self.left.next\n            self.remove(lru)\n            del self.cache[lru.key]\n", "time_complexity": "O(1)$ for each $put()$ and $get()"},
{"code": "class LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n\n        if len(self.cache) > self.cap:\n            self.cache.popitem(last=False)\n", "time_complexity": "O(1)$ for each $put()$ and $get()"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def add(self, l1: Optional[ListNode], l2: Optional[ListNode], carry: int) -> Optional[ListNode]:\n        if not l1 and not l2 and carry == 0:\n            return None\n        \n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n        \n        carry, val = divmod(v1 + v2 + carry, 10)\n        \n        next_node = self.add(\n            l1.next if l1 else None, \n            l2.next if l2 else None, \n            carry\n        )\n        return ListNode(val, next_node)\n\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        return self.add(l1, l2, 0)\n", "time_complexity": "O(m + n)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        cur = dummy\n\n        carry = 0\n        while l1 or l2 or carry:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n\n            # new digit\n            val = v1 + v2 + carry\n            carry = val // 10\n            val = val % 10\n            cur.next = ListNode(val)\n\n            # update ptrs\n            cur = cur.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy.next\n", "time_complexity": "O(m + n)"},
{"code": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        nums.sort()\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                return nums[i]\n        return -1\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return num\n            seen.add(num)\n        return -1\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        seen = [0] * len(nums)\n        for num in nums:\n            if seen[num - 1]:\n                return num\n            seen[num - 1] = 1\n        return -1\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        for num in nums :\n            idx = abs(num) - 1 \n            if nums[idx] < 0 :\n                return abs(num)\n            nums[idx] *= -1\n        return -1\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        n = len(nums)\n        low, high = 1, n - 1\n        while low < high:\n            mid = low + (high - low) // 2\n            lessOrEqual = sum(1 for num in nums if num <= mid)\n\n            if lessOrEqual <= mid:\n                low = mid + 1\n            else:\n                high = mid\n\n        return low\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        n = len(nums)\n        res = 0\n        for b in range(32):\n            x = y = 0\n            mask = 1 << b\n            for num in nums:\n                if num & mask:\n                    x += 1\n            \n            for num in range(1, n):\n                if num & mask:\n                    y += 1\n            \n            if x > y:\n                res |= mask\n        return res\n", "time_complexity": "O(32 * n)"},
{"code": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        slow, fast = 0, 0\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        slow2 = 0\n        while True:\n            slow = nums[slow]\n            slow2 = nums[slow2]\n            if slow == slow2:\n                return slow\n", "time_complexity": "O(n)"},
{"code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def __init__(self):\n        self.map = {}\n\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if head is None:\n            return None\n        if head in self.map:\n            return self.map[head]\n        \n        copy = Node(head.val)\n        self.map[head] = copy\n        copy.next = self.copyRandomList(head.next)\n        copy.random = self.map.get(head.random)\n        return copy\n", "time_complexity": "O(n)"},
{"code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        oldToCopy = {None: None}\n\n        cur = head\n        while cur:\n            copy = Node(cur.val)\n            oldToCopy[cur] = copy\n            cur = cur.next\n        cur = head\n        while cur:\n            copy = oldToCopy[cur]\n            copy.next = oldToCopy[cur.next]\n            copy.random = oldToCopy[cur.random]\n            cur = cur.next\n        return oldToCopy[head]\n", "time_complexity": "O(n)"},
{"code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        oldToCopy = collections.defaultdict(lambda: Node(0))\n        oldToCopy[None] = None\n        \n        cur = head\n        while cur:\n            oldToCopy[cur].val = cur.val\n            oldToCopy[cur].next = oldToCopy[cur.next]\n            oldToCopy[cur].random = oldToCopy[cur.random]\n            cur = cur.next\n        return oldToCopy[head]\n", "time_complexity": "O(n)"},
{"code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if head is None:\n            return None\n        \n        l1 = head\n        while l1 is not None:\n            l2 = Node(l1.val)\n            l2.next = l1.next\n            l1.next = l2\n            l1 = l2.next\n            \n        newHead = head.next\n        \n        l1 = head\n        while l1 is not None:\n            if l1.random is not None:\n                l1.next.random = l1.random.next\n            l1 = l1.next.next\n            \n        l1 = head\n        while l1 is not None:\n            l2 = l1.next\n            l1.next = l2.next\n            if l2.next is not None:\n                l2.next = l2.next.next\n            l1 = l1.next\n            \n        return newHead\n", "time_complexity": "O(n)"},
{"code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if head is None:\n            return None\n\n        l1 = head\n        while l1:\n            l2 = Node(l1.val)\n            l2.next = l1.random\n            l1.random = l2\n            l1 = l1.next\n        \n        newHead = head.random\n        \n        l1 = head\n        while l1:\n            l2 = l1.random\n            l2.random = l2.next.random if l2.next else None\n            l1 = l1.next\n            \n        l1 = head\n        while l1 is not None:\n            l2 = l1.random\n            l1.random = l2.next\n            l2.next = l1.next.random if l1.next else None\n            l1 = l1.next\n\n        return newHead\n", "time_complexity": "O(n)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        if not head:\n            return\n        \n        nodes = []\n        cur = head\n        while cur:\n            nodes.append(cur)\n            cur = cur.next\n        \n        i, j = 0, len(nodes) - 1\n        while i < j:\n            nodes[i].next = nodes[j]\n            i += 1\n            if i >= j:\n                break\n            nodes[j].next = nodes[i]\n            j -= 1\n        \n        nodes[i].next = None\n", "time_complexity": "O(n)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n\n        def rec(root: ListNode, cur: ListNode) -> ListNode:\n            if not cur:\n                return root\n            root = rec(root, cur.next)\n\n            if not root:\n                return None\n            tmp = None\n            if root == cur or root.next == cur:\n                cur.next = None\n            else:\n                tmp = root.next\n                root.next = cur\n                cur.next = tmp\n            return tmp\n            \n        head = rec(head, head.next)\n", "time_complexity": "O(n)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        second = slow.next\n        prev = slow.next = None\n        while second:\n            tmp = second.next\n            second.next = prev\n            prev = second\n            second = tmp\n\n        first, second = head, prev\n        while second:\n            tmp1, tmp2 = first.next, second.next\n            first.next = second\n            second.next = tmp1\n            first, second = tmp1, tmp2\n", "time_complexity": "O(n)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        nodes = []\n        cur = head\n        while cur:\n            nodes.append(cur)\n            cur = cur.next\n        \n        removeIndex = len(nodes) - n\n        if removeIndex == 0:\n            return head.next\n        \n        nodes[removeIndex - 1].next = nodes[removeIndex].next\n        return head\n", "time_complexity": "O(N)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        N = 0\n        cur = head\n        while cur:\n            N += 1\n            cur = cur.next\n        \n        removeIndex = N - n\n        if removeIndex == 0:\n            return head.next\n        \n        cur = head\n        for i in range(N - 1):\n            if (i + 1) == removeIndex:\n                cur.next = cur.next.next\n                break\n            cur = cur.next\n        return head\n", "time_complexity": "O(N)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def rec(self, head, n):\n        if not head:\n            return None\n\n        head.next = self.rec(head.next, n)\n        n[0] -= 1\n        if n[0] == 0:\n            return head.next\n        return head\n\n    def removeNthFromEnd(self, head, n):\n        return self.rec(head, [n])\n", "time_complexity": "O(N)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n\n        while n > 0:\n            right = right.next\n            n -= 1\n\n        while right:\n            left = left.next\n            right = right.next\n\n        left.next = left.next.next\n        return dummy.next\n", "time_complexity": "O(N)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        seen = set()\n        cur = head\n        while cur:\n            if cur in seen:\n                return True\n            seen.add(cur)\n            cur = cur.next\n        return False\n", "time_complexity": "O(n)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow, fast = head, head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False\n", "time_complexity": "O(n)"},
{"code": "class TimeMap:\n\n    def __init__(self):\n        self.keyStore = {}\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.keyStore:\n            self.keyStore[key] = {}\n        if timestamp not in self.keyStore[key]:\n            self.keyStore[key][timestamp] = []\n        self.keyStore[key][timestamp].append(value)\n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.keyStore:\n            return \"\"\n        seen = 0\n\n        for time in self.keyStore[key]:\n            if time <= timestamp:\n                seen = max(seen, time)\n        return \"\" if seen == 0 else self.keyStore[key][seen][-1]\n", "time_complexity": "O(1)$ for $set()$ and $O(n)$ for $get()"},
{"code": "from sortedcontainers import SortedDict\n\nclass TimeMap:\n    def __init__(self):\n        self.m = defaultdict(SortedDict)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        self.m[key][timestamp] = value\n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.m:\n            return \"\"\n        \n        timestamps = self.m[key]\n        idx = timestamps.bisect_right(timestamp) - 1\n        \n        if idx >= 0:\n            closest_time = timestamps.iloc[idx]\n            return timestamps[closest_time]\n        return \"\"\n", "time_complexity": "O(1)$ for $set()$ and $O(\\log n)$ for $get()"},
{"code": "class TimeMap:\n\n    def __init__(self):\n        self.keyStore = {}  # key : list of [val, timestamp]\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.keyStore:\n            self.keyStore[key] = []\n        self.keyStore[key].append([value, timestamp])\n\n    def get(self, key: str, timestamp: int) -> str:\n        res, values = \"\", self.keyStore.get(key, [])\n        l, r = 0, len(values) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if values[m][1] <= timestamp:\n                res = values[m][0]\n                l = m + 1\n            else:\n                r = m - 1\n        return res\n", "time_complexity": "O(1)$ for $set()$ and $O(\\log n)$ for $get()"},
{"code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        len1 = len(nums1)\n        len2 = len(nums2)\n        merged = nums1 + nums2\n        merged.sort()\n        \n        totalLen = len(merged)\n        if totalLen % 2 == 0:\n            return (merged[totalLen // 2 - 1] + merged[totalLen // 2]) / 2.0\n        else:\n            return merged[totalLen // 2]\n", "time_complexity": "O((n + m)\\log (n + m))"},
{"code": "class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        len1, len2 = len(nums1), len(nums2)\n        i = j = 0\n        median1 = median2 = 0\n\n        for count in range((len1 + len2) // 2 + 1):\n            median2 = median1\n            if i < len1 and j < len2:\n                if nums1[i] > nums2[j]:\n                    median1 = nums2[j]\n                    j += 1\n                else:\n                    median1 = nums1[i]\n                    i += 1\n            elif i < len1:\n                median1 = nums1[i]\n                i += 1\n            else:\n                median1 = nums2[j]\n                j += 1\n\n        if (len1 + len2) % 2 == 1:\n            return float(median1)\n        else:\n            return (median1 + median2) / 2.0\n", "time_complexity": "O(n + m)"},
{"code": "class Solution:\n    def get_kth(self, a: List[int], m: int, b: List[int], n: int, k: int, a_start: int = 0, b_start: int = 0) -> int:\n        if m > n:\n            return self.get_kth(b, n, a, m, k, b_start, a_start)\n        if m == 0:\n            return b[b_start + k - 1]\n        if k == 1:\n            return min(a[a_start], b[b_start])\n        \n        i = min(m, k // 2)\n        j = min(n, k // 2)\n        \n        if a[a_start + i - 1] > b[b_start + j - 1]:\n            return self.get_kth(a, m, b, n - j, k - j, a_start, b_start + j)\n        else:\n            return self.get_kth(a, m - i, b, n, k - i, a_start + i, b_start)\n    \n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        left = (len(nums1) + len(nums2) + 1) // 2\n        right = (len(nums1) + len(nums2) + 2) // 2\n        return (self.get_kth(nums1, len(nums1), nums2, len(nums2), left) +\n                self.get_kth(nums1, len(nums1), nums2, len(nums2), right)) / 2.0\n", "time_complexity": "O(\\log (m + n))"},
{"code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        A, B = nums1, nums2\n        total = len(nums1) + len(nums2)\n        half = total // 2\n\n        if len(B) < len(A):\n            A, B = B, A\n\n        l, r = 0, len(A) - 1\n        while True:\n            i = (l + r) // 2\n            j = half - i - 2\n\n            Aleft = A[i] if i >= 0 else float(\"-infinity\")\n            Aright = A[i + 1] if (i + 1) < len(A) else float(\"infinity\")\n            Bleft = B[j] if j >= 0 else float(\"-infinity\")\n            Bright = B[j + 1] if (j + 1) < len(B) else float(\"infinity\")\n\n            if Aleft <= Bright and Bleft <= Aright:\n                if total % 2:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\n            elif Aleft > Bright:\n                r = i - 1\n            else:\n                l = i + 1\n", "time_complexity": "O(\\log (min(n, m)))"},
{"code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        for i in range(len(nums)):\n            if nums[i] == target:\n                return i\n        return -1\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n\n        pivot = l\n        \n        def binary_search(left: int, right: int) -> int:\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n\n        result = binary_search(0, pivot - 1)\n        if result != -1:\n            return result\n        \n        return binary_search(pivot, len(nums) - 1)\n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n\n        pivot = l\n        l, r = 0, len(nums) - 1\n\n        if target >= nums[pivot] and target <= nums[r]:\n            l = pivot\n        else:\n            r = pivot - 1\n\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] == target:\n                return m\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                r = m - 1\n\n        return -1\n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            mid = (l + r) // 2\n            if target == nums[mid]:\n                return mid\n\n            if nums[l] <= nums[mid]:\n                if target > nums[mid] or target < nums[l]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n                    \n            else:\n                if target < nums[mid] or target > nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1\n", "time_complexity": "O(\\log n)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n\n        newHead = head\n        if head.next:\n            newHead = self.reverseList(head.next)\n            head.next.next = head\n        head.next = None\n        \n        return newHead\n", "time_complexity": "O(n)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        prev, curr = None, head\n\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        return prev\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        return min(nums)\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        res = nums[0]\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            if nums[l] < nums[r]:\n                res = min(res, nums[l])\n                break\n            \n            m = (l + r) // 2\n            res = min(res, nums[m])\n            if nums[m] >= nums[l]:\n                l = m + 1\n            else:\n                r = m - 1\n        return res\n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = l + (r - l) // 2\n            if nums[m] < nums[r]:\n                r = m\n            else:\n                l = m + 1\n        return nums[l]\n", "time_complexity": "O(\\log n)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        if list1.val <= list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2\n", "time_complexity": "O(n + m)"},
{"code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:\n        dummy = node = ListNode()\n\n        while list1 and list2:\n            if list1.val < list2.val:\n                node.next = list1\n                list1 = list1.next\n            else:\n                node.next = list2\n                list2 = list2.next\n            node = node.next\n\n        node.next = list1 or list2\n\n        return dummy.next\n", "time_complexity": "O(n + m)"},
{"code": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        speed = 1\n        while True:\n            totalTime = 0\n            for pile in piles:\n                totalTime += math.ceil(pile / speed)\n            \n            if totalTime <= h:\n                return speed\n            speed += 1\n        return speed\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        l, r = 1, max(piles)\n        res = r\n\n        while l <= r:\n            k = (l + r) // 2\n\n            totalTime = 0\n            for p in piles:\n                totalTime += math.ceil(float(p) / k)\n            if totalTime <= h:\n                res = k\n                r = k - 1\n            else:\n                l = k + 1\n        return res\n", "time_complexity": "O(n * \\log m)"},
{"code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for r in range(len(matrix)):\n            for c in range(len(matrix[0])):\n                if matrix[r][c] == target:\n                    return True\n        return False\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        m, n = len(matrix), len(matrix[0])\n        r, c = 0, n - 1\n\n        while r < m and c >= 0:\n            if matrix[r][c] > target:\n                c -= 1\n            elif matrix[r][c] < target:\n                r += 1\n            else:\n                return True\n        return False\n", "time_complexity": "O(m + n)"},
{"code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        ROWS, COLS = len(matrix), len(matrix[0])\n\n        top, bot = 0, ROWS - 1\n        while top <= bot:\n            row = (top + bot) // 2\n            if target > matrix[row][-1]:\n                top = row + 1\n            elif target < matrix[row][0]:\n                bot = row - 1\n            else:\n                break\n\n        if not (top <= bot):\n            return False\n        row = (top + bot) // 2\n        l, r = 0, COLS - 1\n        while l <= r:\n            m = (l + r) // 2\n            if target > matrix[row][m]:\n                l = m + 1\n            elif target < matrix[row][m]:\n                r = m - 1\n            else:\n                return True\n        return False\n", "time_complexity": "O(\\log m + \\log n)$ (which reduces to $O(\\log(m * n))"},
{"code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        ROWS, COLS = len(matrix), len(matrix[0])\n\n        l, r = 0, ROWS * COLS - 1\n        while l <= r:\n            m = l + (r - l) // 2\n            row, col = m // COLS, m % COLS\n            if target > matrix[row][col]:\n                l = m + 1\n            elif target < matrix[row][col]:\n                r = m - 1\n            else:\n                return True\n        return False\n", "time_complexity": "O(\\log(m * n))"},
{"code": "class Solution:\n    def binary_search(self, l: int, r: int, nums: List[int], target: int) -> int:\n        if l > r:\n            return -1\n        m = l + (r - l) // 2\n        \n        if nums[m] == target:\n            return m\n        if nums[m] < target:\n            return self.binary_search(m + 1, r, nums, target)\n        return self.binary_search(l, m - 1, nums, target)\n\n    def search(self, nums: List[int], target: int) -> int:\n        return self.binary_search(0, len(nums) - 1, nums, target)\n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            # (l + r) // 2 can lead to overflow\n            m = l + ((r - l) // 2)  \n\n            if nums[m] > target:\n                r = m - 1\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                return m\n        return -1\n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums)\n\n        while l < r:\n            m = l + ((r - l) // 2)  \n            if nums[m] > target:\n                r = m\n            elif nums[m] <= target:\n                l = m + 1\n        return l - 1 if (l and nums[l - 1] == target) else -1 \n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums)\n\n        while l < r:\n            m = l + ((r - l) // 2)  \n            if nums[m] >= target:\n                r = m\n            elif nums[m] < target:\n                l = m + 1\n        return l if (l < len(nums) and nums[l] == target) else -1 \n", "time_complexity": "O(\\log n)"},
{"code": "import bisect\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        index = bisect.bisect_left(nums, target)\n        return index if index < len(nums) and nums[index] == target else -1\n", "time_complexity": "O(\\log n)"},
{"code": "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        pair = [(p, s) for p, s in zip(position, speed)]\n        pair.sort(reverse=True)\n        stack = []\n        for p, s in pair:  # Reverse Sorted Order\n            stack.append((target - p) / s)\n            if len(stack) >= 2 and stack[-1] <= stack[-2]:\n                stack.pop()\n        return len(stack)\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        pair = [(p, s) for p, s in zip(position, speed)]\n        pair.sort(reverse=True)\n        \n        fleets = 1\n        prevTime = (target - pair[0][0]) / pair[0][1]\n        for i in range(1, len(pair)):\n            currCar = pair[i]\n            currTime = (target - currCar[0]) / currCar[1]\n            if currTime > prevTime:\n                fleets += 1\n                prevTime = currTime\n        return fleets\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        n = len(heights)\n        maxArea = 0\n\n        for i in range(n):\n            height = heights[i]\n\n            rightMost = i + 1\n            while rightMost < n and heights[rightMost] >= height:\n                rightMost += 1\n            \n            leftMost = i\n            while leftMost >= 0 and heights[leftMost] >= height:\n                leftMost -= 1\n            \n            rightMost -= 1\n            leftMost += 1\n            maxArea = max(maxArea, height * (rightMost - leftMost + 1))\n        return maxArea\n", "time_complexity": "O(n ^ 2)"},
{"code": "class MinIdx_Segtree:\n    def __init__(self, N, A):\n        self.n = N\n        self.INF = int(1e9)\n        self.A = A\n        while (self.n & (self.n - 1)) != 0:\n            self.A.append(self.INF)\n            self.n += 1\n        self.tree = [0] * (2 * self.n)\n        self.build()\n\n    def build(self):\n        for i in range(self.n):\n            self.tree[self.n + i] = i\n        for j in range(self.n - 1, 0, -1):\n            a = self.tree[j << 1]\n            b = self.tree[(j << 1) + 1]\n            if self.A[a] <= self.A[b]:\n                self.tree[j] = a\n            else:\n                self.tree[j] = b\n\n    def update(self, i, val):\n        self.A[i] = val\n        j = (self.n + i) >> 1\n        while j >= 1:\n            a = self.tree[j << 1]\n            b = self.tree[(j << 1) + 1]\n            if self.A[a] <= self.A[b]:\n                self.tree[j] = a\n            else:\n                self.tree[j] = b\n            j >>= 1\n\n    def query(self, ql, qh):\n        return self._query(1, 0, self.n - 1, ql, qh)\n\n    def _query(self, node, l, h, ql, qh):\n        if ql > h or qh < l:\n            return self.INF\n        if l >= ql and h <= qh:\n            return self.tree[node]\n        a = self._query(node << 1, l, (l + h) >> 1, ql, qh)\n        b = self._query((node << 1) + 1, ((l + h) >> 1) + 1, h, ql, qh)\n        if a == self.INF:\n            return b\n        if b == self.INF:\n            return a\n        return a if self.A[a] <= self.A[b] else b\n\nclass Solution:\n    def getMaxArea(self, heights, l, r, st):\n        if l > r:\n            return 0\n        if l == r:\n            return heights[l]\n        minIdx = st.query(l, r)\n        return max(max(self.getMaxArea(heights, l, minIdx - 1, st),\n                       self.getMaxArea(heights, minIdx + 1, r, st)),\n                   (r - l + 1) * heights[minIdx])\n\n    def largestRectangleArea(self, heights):\n        n = len(heights)\n        st = MinIdx_Segtree(n, heights)\n        return self.getMaxArea(heights, 0, n - 1, st)\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        n = len(heights)\n        stack = []\n\n        leftMost = [-1] * n\n        for i in range(n):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n            if stack:\n                leftMost[i] = stack[-1]\n            stack.append(i)\n        \n        stack = []\n        rightMost = [n] * n\n        for i in range(n - 1, -1, -1):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n            if stack:\n                rightMost[i] = stack[-1]\n            stack.append(i)\n        \n        maxArea = 0\n        for i in range(n):\n            leftMost[i] += 1\n            rightMost[i] -= 1\n            maxArea = max(maxArea, heights[i] * (rightMost[i] - leftMost[i] + 1))\n        return maxArea\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        maxArea = 0\n        stack = []  # pair: (index, height)\n\n        for i, h in enumerate(heights):\n            start = i\n            while stack and stack[-1][1] > h:\n                index, height = stack.pop()\n                maxArea = max(maxArea, height * (i - index))\n                start = index\n            stack.append((start, h))\n\n        for i, h in stack:\n            maxArea = max(maxArea, h * (len(heights) - i))\n        return maxArea\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        n = len(heights)\n        maxArea = 0\n        stack = []\n\n        for i in range(n + 1):\n            while stack and (i == n  or heights[stack[-1]] >= heights[i]):\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                maxArea = max(maxArea, height * width)\n            stack.append(i)\n        return maxArea\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        while '()' in s or '{}' in s or '[]' in s:\n            s = s.replace('()', '')\n            s = s.replace('{}', '')\n            s = s.replace('[]', '')\n        return s == ''\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        closeToOpen = { \")\" : \"(\", \"]\" : \"[\", \"}\" : \"{\" }\n\n        for c in s:\n            if c in closeToOpen:\n                if stack and stack[-1] == closeToOpen[c]:\n                    stack.pop()\n                else:\n                    return False\n            else:\n                stack.append(c)\n        \n        return True if not stack else False\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        n = len(temperatures)\n        res = []\n\n        for i in range(n):\n            count = 1\n            j = i + 1\n            while j < n:\n                if temperatures[j] > temperatures[i]:\n                    break\n                j += 1\n                count += 1\n            count = 0 if j == n else count\n            res.append(count)\n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        res = [0] * len(temperatures)\n        stack = []  # pair: [temp, index]\n\n        for i, t in enumerate(temperatures):\n            while stack and t > stack[-1][0]:\n                stackT, stackInd = stack.pop()\n                res[stackInd] = i - stackInd\n            stack.append((t, i))\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        n = len(temperatures)\n        res = [0] * n\n\n        for i in range(n - 2, -1, -1):\n            j = i + 1\n            while j < n and temperatures[j] <= temperatures[i]:\n                if res[j] == 0:\n                    j = n\n                    break\n                j += res[j]\n            \n            if j < n:\n                res[i] = j - i\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        while len(tokens) > 1:\n            for i in range(len(tokens)):\n                if tokens[i] in \"+-*/\":\n                    a = int(tokens[i-2])\n                    b = int(tokens[i-1])\n                    if tokens[i] == '+':\n                        result = a + b\n                    elif tokens[i] == '-':\n                        result = a - b\n                    elif tokens[i] == '*':\n                        result = a * b\n                    elif tokens[i] == '/':\n                        result = int(a / b)\n                    tokens = tokens[:i-2] + [str(result)] + tokens[i+1:]\n                    break\n        return int(tokens[0])\n", "time_complexity": "O(n ^ 2)"},
{"code": "class DoublyLinkedList:\n    def __init__(self, val, next=None, prev=None):\n        self.val = val\n        self.next = next\n        self.prev = prev\n\nclass Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        head = DoublyLinkedList(tokens[0])\n        curr = head\n\n        for i in range(1, len(tokens)):\n            curr.next = DoublyLinkedList(tokens[i], prev=curr)\n            curr = curr.next\n\n        while head is not None:\n            if head.val in \"+-*/\":\n                l = int(head.prev.prev.val)\n                r = int(head.prev.val)\n                if head.val == '+':\n                    res = l + r\n                elif head.val == '-':\n                    res = l - r\n                elif head.val == '*':\n                    res = l * r\n                else:\n                    res = int(l / r)\n\n                head.val = str(res)\n                head.prev = head.prev.prev.prev\n                if head.prev is not None:\n                    head.prev.next = head\n\n            ans = int(head.val)\n            head = head.next\n\n        return ans\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        def dfs():\n            token = tokens.pop()\n            if token not in \"+-*/\":\n                return int(token)\n            \n            right = dfs()\n            left = dfs()\n            \n            if token == '+':\n                return left + right\n            elif token == '-':\n                return left - right\n            elif token == '*':\n                return left * right\n            elif token == '/':\n                return int(left / right)\n        \n        return dfs()\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        stack = []\n        for c in tokens:\n            if c == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif c == \"-\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(b - a)\n            elif c == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif c == \"/\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(int(float(b) / a))\n            else:\n                stack.append(int(c))\n        return stack[0]\n", "time_complexity": "O(n)"},
{"code": "class MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n\n    def pop(self) -> None:\n        self.stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        tmp = []\n        mini = self.stack[-1]\n\n        while len(self.stack):\n            mini = min(mini, self.stack[-1])\n            tmp.append(self.stack.pop())\n        \n        while len(tmp):\n            self.stack.append(tmp.pop())\n        \n        return mini\n", "time_complexity": "O(n)$ for $getMin()$ and $O(1)"},
{"code": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -> None:\n        self.stack.pop()\n        self.minStack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.minStack[-1]\n", "time_complexity": "O(1)"},
{"code": "class MinStack:\n    def __init__(self):\n        self.min = float('inf')\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if not self.stack:\n            self.stack.append(0)\n            self.min = x\n        else:\n            self.stack.append(x - self.min)\n            if x < self.min:\n                self.min = x\n\n    def pop(self) -> None:\n        if not self.stack:\n            return\n        \n        pop = self.stack.pop()\n        \n        if pop < 0:\n            self.min = self.min - pop\n\n    def top(self) -> int:\n        top = self.stack[-1]\n        if top > 0:\n            return top + self.min\n        else:\n            return self.min\n\n    def getMin(self) -> int:\n        return self.min\n", "time_complexity": "O(1)"},
{"code": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        res = []\n\n        def valid(s: str):\n            open = 0\n            for c in s:\n                open += 1 if c == '(' else -1\n                if open < 0:\n                    return False\n            return not open\n\n        def dfs(s: str):\n            if n * 2 == len(s):\n                if valid(s):\n                    res.append(s)\n                return\n            \n            dfs(s + '(')\n            dfs(s + ')')\n        \n        dfs(\"\")\n        return res\n", "time_complexity": "O(2 ^ {2n} * n)"},
{"code": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        stack = []\n        res = []\n\n        def backtrack(openN, closedN):\n            if openN == closedN == n:\n                res.append(\"\".join(stack))\n                return\n\n            if openN < n:\n                stack.append(\"(\")\n                backtrack(openN + 1, closedN)\n                stack.pop()\n            if closedN < openN:\n                stack.append(\")\")\n                backtrack(openN, closedN + 1)\n                stack.pop()\n\n        backtrack(0, 0)\n        return res\n", "time_complexity": "O(\\frac{4^n}{\\sqrt{n}})"},
{"code": "class Solution:\n    def generateParenthesis(self, n):\n        res = [[] for _ in range(n+1)]\n        res[0] = [\"\"]\n        \n        for k in range(n + 1):\n            for i in range(k):\n                for left in res[i]:\n                    for right in res[k-i-1]:\n                        res[k].append(\"(\" + left + \")\" + right)\n        \n        return res[-1]\n", "time_complexity": "O(\\frac{4^n}{\\sqrt{n}})"},
{"code": "class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        points.sort(key=lambda p: p[0]**2 + p[1]**2)\n        return points[:k]\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        minHeap = []\n        for x, y in points:\n            dist = (x ** 2) + (y ** 2)\n            minHeap.append([dist, x, y])\n        \n        heapq.heapify(minHeap)\n        res = []\n        while k > 0:\n            dist, x, y = heapq.heappop(minHeap)\n            res.append([x, y])\n            k -= 1\n            \n        return res\n", "time_complexity": "O(k * \\log n)"},
{"code": "class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        maxHeap = []\n        for x, y in points:\n            dist = -(x ** 2 + y ** 2)\n            heapq.heappush(maxHeap, [dist, x, y])\n            if len(maxHeap) > k:\n                heapq.heappop(maxHeap)\n        \n        res = []\n        while maxHeap:\n            dist, x, y = heapq.heappop(maxHeap)\n            res.append([x, y])\n        return res\n", "time_complexity": "O(n * \\log k)"},
{"code": "class Solution:\n    def kClosest(self, points, k):\n        euclidean = lambda x: x[0] ** 2 + x[1] ** 2\n        def partition(l, r):\n            pivotIdx = r\n            pivotDist = euclidean(points[pivotIdx])\n            i = l\n            for j in range(l, r):\n                if euclidean(points[j]) <= pivotDist:\n                    points[i], points[j] = points[j], points[i]\n                    i += 1\n            points[i], points[r] = points[r], points[i]\n            return i\n\n        L, R = 0, len(points) - 1\n        pivot = len(points)\n\n        while pivot != k:\n            pivot = partition(L, R)\n            if pivot < k:\n                L = pivot + 1\n            else:\n                R = pivot - 1\n        return points[:k]\n", "time_complexity": "O(n)$ in average case, $O(n ^ 2)"},
{"code": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if t == \"\":\n            return \"\"\n\n        countT = {}\n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n\n        res, resLen = [-1, -1], float(\"infinity\")\n        for i in range(len(s)):\n            countS = {}\n            for j in range(i, len(s)):\n                countS[s[j]] = 1 + countS.get(s[j], 0)\n\n                flag = True\n                for c in countT:\n                    if countT[c] > countS.get(c, 0):\n                        flag = False\n                        break\n                \n                if flag and (j - i + 1) < resLen:\n                    resLen = j - i + 1\n                    res = [i, j]\n\n        l, r = res\n        return s[l : r + 1] if resLen != float(\"infinity\") else \"\"\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if t == \"\":\n            return \"\"\n\n        countT, window = {}, {}\n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n\n        have, need = 0, len(countT)\n        res, resLen = [-1, -1], float(\"infinity\")\n        l = 0\n        for r in range(len(s)):\n            c = s[r]\n            window[c] = 1 + window.get(c, 0)\n\n            if c in countT and window[c] == countT[c]:\n                have += 1\n\n            while have == need:\n                if (r - l + 1) < resLen:\n                    res = [l, r]\n                    resLen = r - l + 1\n                    \n                window[s[l]] -= 1\n                if s[l] in countT and window[s[l]] < countT[s[l]]:\n                    have -= 1\n                l += 1\n        l, r = res\n        return s[l : r + 1] if resLen != float(\"infinity\") else \"\"\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        s1 = sorted(s1)\n\n        for i in range(len(s2)):\n            for j in range(i, len(s2)):\n                subStr = s2[i : j + 1]\n                subStr = sorted(subStr)\n                if subStr == s1:\n                    return True\n        return False\n", "time_complexity": "O(n ^ 3 \\log n)"},
{"code": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        count1 = {}\n        for c in s1:\n            count1[c] = 1 + count1.get(c, 0)\n        \n        need = len(count1)\n        for i in range(len(s2)):\n            count2, cur = {}, 0\n            for j in range(i, len(s2)):\n                count2[s2[j]] = 1 + count2.get(s2[j], 0)\n                if count1.get(s2[j], 0) < count2[s2[j]]:\n                    break\n                if count1.get(s2[j], 0) == count2[s2[j]]:\n                    cur += 1\n                if cur == need:\n                    return True\n        return False\n", "time_complexity": "O(n * m)"},
{"code": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        if len(s1) > len(s2):\n            return False\n        \n        s1Count, s2Count = [0] * 26, [0] * 26\n        for i in range(len(s1)):\n            s1Count[ord(s1[i]) - ord('a')] += 1\n            s2Count[ord(s2[i]) - ord('a')] += 1\n        \n        matches = 0\n        for i in range(26):\n            matches += (1 if s1Count[i] == s2Count[i] else 0)\n        \n        l = 0\n        for r in range(len(s1), len(s2)):\n            if matches == 26:\n                return True\n            \n            index = ord(s2[r]) - ord('a')\n            s2Count[index] += 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] + 1 == s2Count[index]:\n                matches -= 1\n\n            index = ord(s2[l]) - ord('a')\n            s2Count[index] -= 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] - 1 == s2Count[index]:\n                matches -= 1\n            l += 1\n        return matches == 26\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        res = 0\n        for i in range(len(s)):\n            count, maxf = {}, 0\n            for j in range(i, len(s)):\n                count[s[j]] = 1 + count.get(s[j], 0)\n                maxf = max(maxf, count[s[j]])\n                if (j - i + 1) - maxf <= k:\n                    res = max(res, j - i + 1)\n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        res = 0\n        charSet = set(s)\n\n        for c in charSet:\n            count = l = 0\n            for r in range(len(s)):\n                if s[r] == c:\n                    count += 1\n\n                while (r - l + 1) - count > k:\n                    if s[l] == c:\n                        count -= 1\n                    l += 1\n                    \n                res = max(res, r - l + 1)\n        return res\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        count = {}\n        res = 0\n        \n        l = 0\n        maxf = 0\n        for r in range(len(s)):\n            count[s[r]] = 1 + count.get(s[r], 0)\n            maxf = max(maxf, count[s[r]])\n\n            while (r - l + 1) - maxf > k:\n                count[s[l]] -= 1\n                l += 1\n            res = max(res, r - l + 1)\n\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        res = 0\n        for i in range(len(s)):\n            charSet = set()\n            for j in range(i, len(s)):\n                if s[j] in charSet:\n                    break\n                charSet.add(s[j])\n            res = max(res, len(charSet))\n        return res\n", "time_complexity": "O(n * m)"},
{"code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        charSet = set()\n        l = 0\n        res = 0\n\n        for r in range(len(s)):\n            while s[r] in charSet:\n                charSet.remove(s[l])\n                l += 1\n            charSet.add(s[r])\n            res = max(res, r - l + 1)\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        mp = {}\n        l = 0\n        res = 0\n        \n        for r in range(len(s)):\n            if s[r] in mp:\n                l = max(mp[s[r]] + 1, l)\n            mp[s[r]] = r\n            res = max(res, r - l + 1)\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        res = 0\n        for i in range(len(prices)):\n            buy = prices[i]\n            for j in range(i + 1, len(prices)):\n                sell  = prices[j]\n                res = max(res, sell - buy)\n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        l, r = 0, 1\n        maxP = 0\n\n        while r < len(prices):\n            if prices[l] < prices[r]:\n                profit = prices[r] - prices[l]\n                maxP = max(maxP, profit)\n            else:\n                l = r\n            r += 1\n        return maxP\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        maxP = 0\n        minBuy = prices[0]\n\n        for sell in prices:\n            maxP = max(maxP, sell - minBuy)\n            minBuy = min(minBuy, sell)\n        return maxP\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        if not height:\n            return 0\n        n = len(height)\n        res = 0\n\n        for i in range(n):\n            leftMax = rightMax = height[i]\n\n            for j in range(i):\n                leftMax = max(leftMax, height[j])\n            for j in range(i + 1, n):\n                rightMax = max(rightMax, height[j])\n                \n            res += min(leftMax, rightMax) - height[i]\n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        n = len(height)\n        if n == 0:\n            return 0\n        \n        leftMax = [0] * n\n        rightMax = [0] * n\n        \n        leftMax[0] = height[0]\n        for i in range(1, n):\n            leftMax[i] = max(leftMax[i - 1], height[i])\n        \n        rightMax[n - 1] = height[n - 1]\n        for i in range(n - 2, -1, -1):\n            rightMax[i] = max(rightMax[i + 1], height[i])\n        \n        res = 0\n        for i in range(n):\n            res += min(leftMax[i], rightMax[i]) - height[i]\n        return res         \n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        if not height:\n            return 0\n        stack = []\n        res = 0\n\n        for i in range(len(height)):\n            while stack and height[i] >= height[stack[-1]]:\n                mid = height[stack.pop()]\n                if stack:\n                    right = height[i]\n                    left = height[stack[-1]]\n                    h = min(right, left) - mid\n                    w = i - stack[-1] - 1\n                    res += h * w\n            stack.append(i)\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        if not height:\n            return 0\n\n        l, r = 0, len(height) - 1\n        leftMax, rightMax = height[l], height[r]\n        res = 0\n        while l < r:\n            if leftMax < rightMax:\n                l += 1\n                leftMax = max(leftMax, height[l])\n                res += leftMax - height[l]\n            else:\n                r -= 1\n                rightMax = max(rightMax, height[r])\n                res += rightMax - height[r]\n        return res   \n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxArea(self, heights: List[int]) -> int:\n        res = 0\n        for i in range(len(heights)):\n            for j in range(i + 1, len(heights)):\n                res = max(res, min(heights[i], heights[j]) * (j - i))\n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def maxArea(self, heights: List[int]) -> int:\n        l, r = 0, len(heights) - 1\n        res = 0\n\n        while l < r:\n            area = min(heights[l], heights[r]) * (r - l)\n            res = max(res, area)\n            if heights[l] <= heights[r]:\n                l += 1\n            else:\n                r -= 1\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = set()\n        nums.sort()\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    if nums[i] + nums[j] + nums[k] == 0:\n                        tmp = [nums[i], nums[j], nums[k]]\n                        res.add(tuple(tmp))\n        return [list(i) for i in res]\n", "time_complexity": "O(n ^ 3)"},
{"code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        count = defaultdict(int)\n        for num in nums:\n            count[num] += 1\n\n        res = []\n        for i in range(len(nums)):\n            count[nums[i]] -= 1\n            if i and nums[i] == nums[i - 1]:\n                continue\n                \n            for j in range(i + 1, len(nums)):\n                count[nums[j]] -= 1\n                if j - 1 > i and nums[j] == nums[j - 1]:\n                    continue\n                target = -(nums[i] + nums[j])\n                if count[target] > 0:\n                    res.append([nums[i], nums[j], target])\n\n            for j in range(i + 1, len(nums)):\n                count[nums[j]] += 1\n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        for i, a in enumerate(nums):\n            if a > 0:\n                break\n\n            if i > 0 and a == nums[i - 1]:\n                continue\n\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                threeSum = a + nums[l] + nums[r]\n                if threeSum > 0:\n                    r -= 1\n                elif threeSum < 0:\n                    l += 1\n                else:\n                    res.append([a, nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while nums[l] == nums[l - 1] and l < r:\n                        l += 1\n                        \n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        leftHeight = self.maxHeight(root.left)\n        rightHeight = self.maxHeight(root.right)\n        diameter = leftHeight + rightHeight \n        sub = max(self.diameterOfBinaryTree(root.left),\n                  self.diameterOfBinaryTree(root.right))\n        return max(diameter, sub)\n\n\n    def maxHeight(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        return 1 + max(self.maxHeight(root.left), self.maxHeight(root.right))\n", "time_complexity": "O(n ^ 2)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        res = 0\n\n        def dfs(root):\n            nonlocal res\n\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            res = max(res, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n        return res\n", "time_complexity": "O(n)"},
{"code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        stack = [root]\n        mp = {None: (0, 0)}\n\n        while stack:\n            node = stack[-1]\n\n            if node.left and node.left not in mp:\n                stack.append(node.left)\n            elif node.right and node.right not in mp:\n                stack.append(node.right)\n            else:\n                node = stack.pop()\n\n                leftHeight, leftDiameter = mp[node.left]\n                rightHeight, rightDiameter = mp[node.right]\n\n                mp[node] = (1 + max(leftHeight, rightHeight),\n                           max(leftHeight + rightHeight, leftDiameter, rightDiameter))\n\n        return mp[root][1]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        newStr = ''\n        for c in s:\n            if c.isalnum():\n                newStr += c.lower()\n        return newStr == newStr[::-1]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n\n        while l < r:\n            while l < r and not self.alphaNum(s[l]):\n                l += 1\n            while r > l and not self.alphaNum(s[r]):\n                r -= 1\n            if s[l].lower() != s[r].lower():\n                return False\n            l, r = l + 1, r - 1\n        return True\n    \n    def alphaNum(self, c):\n        return (ord('A') <= ord(c) <= ord('Z') or \n                ord('a') <= ord(c) <= ord('z') or \n                ord('0') <= ord(c) <= ord('9'))\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        res = 0\n        store = set(nums)\n\n        for num in nums:\n            streak, curr = 0, num\n            while curr in store:\n                streak += 1\n                curr += 1\n            res = max(res, streak)\n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        res = 0\n        nums.sort()\n        \n        curr, streak = nums[0], 0\n        i = 0\n        while i < len(nums):\n            if curr != nums[i]:\n                curr = nums[i]\n                streak = 0\n            while i < len(nums) and nums[i] == curr:\n                i += 1\n            streak += 1\n            curr += 1\n            res = max(res, streak)\n        return res\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numSet = set(nums)\n        longest = 0\n\n        for num in numSet:\n            if (num - 1) not in numSet:\n                length = 1\n                while (num + length) in numSet:\n                    length += 1\n                longest = max(length, longest)\n        return longest\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        mp = defaultdict(int)\n        res = 0\n\n        for num in nums:\n            if not mp[num]:\n                mp[num] = mp[num - 1] + mp[num + 1] + 1\n                mp[num - mp[num - 1]] = mp[num]\n                mp[num + mp[num + 1]] = mp[num]\n                res = max(res, mp[num])\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        res = [0] * n\n\n        for i in range(n):\n            prod = 1\n            for j in range(n):\n                if i == j:\n                    continue    \n                prod *= nums[j]\n            \n            res[i] = prod\n        return res\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        prod, zero_cnt = 1, 0\n        for num in nums:\n            if num:\n                prod *= num\n            else:\n                zero_cnt +=  1\n        if zero_cnt > 1: return [0] * len(nums)\n\n        res = [0] * len(nums)\n        for i, c in enumerate(nums):\n            if zero_cnt: res[i] = 0 if c else prod\n            else: res[i] = prod // c\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        res = [0] * n\n        pref = [0] * n\n        suff = [0] * n\n\n        pref[0] = suff[n - 1] = 1\n        for i in range(1, n):\n            pref[i] = nums[i - 1] * pref[i - 1]\n        for i in range(n - 2, -1, -1):\n            suff[i] = nums[i + 1] * suff[i + 1]\n        for i in range(n):\n            res[i] = pref[i] * suff[i] \n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res = [1] * (len(nums))\n\n        prefix = 1\n        for i in range(len(nums)):\n            res[i] = prefix\n            prefix *= nums[i]\n        postfix = 1\n        for i in range(len(nums) - 1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = {}\n        for num in nums:\n            count[num] = 1 + count.get(num, 0)\n\n        arr = []\n        for num, cnt in count.items():\n            arr.append([cnt, num])\n        arr.sort()\n\n        res = []\n        while len(res) < k:\n            res.append(arr.pop()[1])\n        return res\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = {}\n        for num in nums:\n            count[num] = 1 + count.get(num, 0)\n\n        heap = []\n        for num in count.keys():\n            heapq.heappush(heap, (count[num], num))\n            if len(heap) > k:\n                heapq.heappop(heap)\n\n        res = []\n        for i in range(k):\n            res.append(heapq.heappop(heap)[1])\n        return res\n", "time_complexity": "O(n \\log k)"},
{"code": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = {}\n        freq = [[] for i in range(len(nums) + 1)]\n\n        for num in nums:\n            count[num] = 1 + count.get(num, 0)\n        for num, cnt in count.items():\n            freq[cnt].append(num)\n        \n        res = []\n        for i in range(len(freq) - 1, 0, -1):\n            for num in freq[i]:\n                res.append(num)\n                if len(res) == k:\n                    return res\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def encode(self, strs: List[str]) -> str:\n        if not strs:\n            return \"\"\n        sizes, res = [], \"\"\n        for s in strs:\n            sizes.append(len(s))\n        for sz in sizes:\n            res += str(sz)\n            res += ','\n        res += '#'\n        for s in strs:\n            res += s\n        return res\n\n    def decode(self, s: str) -> List[str]:\n        if not s:\n            return []\n        sizes, res, i = [], [], 0\n        while s[i] != '#':\n            cur = \"\"\n            while s[i] != ',':\n                cur += s[i]\n                i += 1\n            sizes.append(int(cur))\n            i += 1\n        i += 1\n        for sz in sizes:\n            res.append(s[i:i + sz])\n            i += sz\n        return res\n", "time_complexity": "O(m)$ for $encode()$ and $decode()"},
{"code": "class Solution:\n    \n    def encode(self, strs: List[str]) -> str:\n        res = \"\"\n        for s in strs:\n            res += str(len(s)) + \"#\" + s\n        return res\n\n    def decode(self, s: str) -> List[str]:\n        res = []\n        i = 0\n        \n        while i < len(s):\n            j = i\n            while s[j] != '#':\n                j += 1\n            length = int(s[i:j])\n            i = j + 1\n            j = i + length\n            res.append(s[i:j])\n            i = j\n            \n        return res\n", "time_complexity": "O(m)$ for $encode()$ and $decode()"},
{"code": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        res = defaultdict(list)\n        for s in strs:\n            sortedS = ''.join(sorted(s))\n            res[sortedS].append(s)\n        return list(res.values())\n", "time_complexity": "O(m * n \\log n)"},
{"code": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        res = defaultdict(list)\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n            res[tuple(count)].append(s)\n        return list(res.values())\n", "time_complexity": "O(m * n)"},
{"code": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        for i in range(len(numbers)):\n            for j in range(i + 1, len(numbers)):\n                if numbers[i] + numbers[j] == target:\n                    return [i + 1, j + 1]\n        return []\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        for i in range(len(numbers)):\n            l, r = i + 1, len(numbers) - 1\n            tmp = target - numbers[i]\n            while l <= r:\n                mid = l + (r - l)//2\n                if numbers[mid] == tmp:\n                    return [i + 1, mid + 1]\n                elif numbers[mid] < tmp:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return []\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        mp = defaultdict(int)\n        for i in range(len(numbers)):\n            tmp = target - numbers[i]\n            if mp[tmp]:\n                return [mp[tmp], i + 1]\n            mp[numbers[i]] = i + 1\n        return []\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        l, r = 0, len(numbers) - 1\n\n        while l < r:\n            curSum = numbers[l] + numbers[r]\n\n            if curSum > target:\n                r -= 1\n            elif curSum < target:\n                l += 1\n            else:\n                return [l + 1, r + 1]\n        return []\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        for row in range(9):\n            seen = set()\n            for i in range(9):\n                if board[row][i] == \".\": \n                    continue\n                if board[row][i] in seen:\n                    return False\n                seen.add(board[row][i])\n        \n        for col in range(9):\n            seen = set()\n            for i in range(9):\n                if board[i][col] == \".\":\n                    continue\n                if board[i][col] in seen:\n                    return False\n                seen.add(board[i][col])\n            \n        for square in range(9):\n            seen = set()\n            for i in range(3):\n                for j in range(3):\n                    row = (square//3) * 3 + i\n                    col = (square % 3) * 3 + j\n                    if board[row][col] == \".\":\n                        continue\n                    if board[row][col] in seen:\n                        return False\n                    seen.add(board[row][col])\n        return True\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        cols = defaultdict(set)\n        rows = defaultdict(set)\n        squares = defaultdict(set)  \n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                    continue\n                if ( board[r][c] in rows[r]\n                    or board[r][c] in cols[c]\n                    or board[r][c] in squares[(r // 3, c // 3)]):\n                    return False\n\n                cols[c].add(board[r][c])\n                rows[r].add(board[r][c])\n                squares[(r // 3, c // 3)].add(board[r][c])\n\n        return True\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = [0] * 9\n        cols = [0] * 9\n        squares = [0] * 9\n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                    continue\n                \n                val = int(board[r][c]) - 1\n                if (1 << val) & rows[r]:\n                    return False\n                if (1 << val) & cols[c]:\n                    return False\n                if (1 << val) & squares[(r // 3) * 3 + (c // 3)]:\n                    return False\n                    \n                rows[r] |= (1 << val)\n                cols[c] |= (1 << val)\n                squares[(r // 3) * 3 + (c // 3)] |= (1 << val)\n\n        return True\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n        return []\n", "time_complexity": "O(n ^ 2)"},
{"code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        A = []\n        for i, num in enumerate(nums):\n            A.append([num, i])\n        \n        A.sort()\n        i, j = 0, len(nums) - 1\n        while i < j:\n            cur = A[i][0] + A[j][0]\n            if cur == target:\n                return [min(A[i][1], A[j][1]), \n                        max(A[i][1], A[j][1])]\n            elif cur < target:\n                i += 1\n            else:\n                j -= 1\n        return []\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        indices = {}  # val -> index\n\n        for i, n in enumerate(nums):\n            indices[n] = i\n\n        for i, n in enumerate(nums):\n            diff = target - n\n            if diff in indices and indices[diff] != i:\n                return [i, indices[diff]]\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        prevMap = {}  # val -> index\n\n        for i, n in enumerate(nums):\n            diff = target - n\n            if diff in prevMap:\n                return [prevMap[diff], i]\n            prevMap[n] = i\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n            \n        return sorted(s) == sorted(t)\n", "time_complexity": "O(n \\log n + m \\log m)"},
{"code": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        countS, countT = {}, {}\n\n        for i in range(len(s)):\n            countS[s[i]] = 1 + countS.get(s[i], 0)\n            countT[t[i]] = 1 + countT.get(t[i], 0)\n        return countS == countT\n", "time_complexity": "O(n + m)"},
{"code": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        count = [0] * 26\n        for i in range(len(s)):\n            count[ord(s[i]) - ord('a')] += 1\n            count[ord(t[i]) - ord('a')] -= 1\n\n        for val in count:\n            if val != 0:\n                return False\n        return True\n", "time_complexity": "O(n + m)"},
{"code": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        output = []\n\n        for i in range(len(nums) - k + 1):\n            maxi = nums[i]\n            for j in range(i, i + k):\n                maxi = max(maxi, nums[j])\n            output.append(maxi)\n\n        return output\n", "time_complexity": "O(n * k)"},
{"code": "class SegmentTree:\n    def __init__(self, N, A):\n        self.n = N\n        while (self.n & (self.n - 1)) != 0:\n            self.n += 1\n        self.build(N, A)\n\n    def build(self, N, A):\n        self.tree = [float('-inf')] * (2 * self.n)\n        for i in range(N):\n            self.tree[self.n + i] = A[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = max(self.tree[i << 1], self.tree[i << 1 | 1])\n\n    def query(self, l, r):\n        res = float('-inf')\n        l += self.n\n        r += self.n + 1\n        while l < r:\n            if l & 1:\n                res = max(res, self.tree[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                res = max(res, self.tree[r])\n            l >>= 1\n            r >>= 1\n        return res\n\n\nclass Solution:\n    def maxSlidingWindow(self, nums, k):\n        n = len(nums)\n        segTree = SegmentTree(n, nums)\n        output = []\n        for i in range(n - k + 1):\n            output.append(segTree.query(i, i + k - 1))\n        return output\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        output = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (-nums[i], i))\n            if i >= k - 1:\n                while heap[0][1] <= i - k:\n                    heapq.heappop(heap)\n                output.append(-heap[0][0])\n        return output\n", "time_complexity": "O(n \\log n)"},
{"code": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        leftMax = [0] * n\n        rightMax = [0] * n\n\n        leftMax[0] = nums[0]\n        rightMax[n - 1] = nums[n - 1]\n\n        for i in range(1, n):\n            if i % k == 0:\n                leftMax[i] = nums[i]\n            else:\n                leftMax[i] = max(leftMax[i - 1], nums[i])\n\n            if (n - 1 - i) % k == 0:\n                rightMax[n - 1 - i] = nums[n - 1 - i]\n            else:\n                rightMax[n - 1 - i] = max(rightMax[n - i], nums[n - 1 - i])\n\n        output = [0] * (n - k + 1)\n\n        for i in range(n - k + 1):\n            output[i] = max(leftMax[i + k - 1], rightMax[i])\n\n        return output\n", "time_complexity": "O(n)"},
{"code": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        output = []\n        q = deque()  # index\n        l = r = 0\n\n        while r < len(nums):\n            while q and nums[q[-1]] < nums[r]:\n                q.pop()\n            q.append(r)\n\n            if l > q[0]:\n                q.popleft()\n\n            if (r + 1) >= k:\n                output.append(nums[q[0]])\n                l += 1\n            r += 1\n\n        return output\n", "time_complexity": "O(n)"}
]