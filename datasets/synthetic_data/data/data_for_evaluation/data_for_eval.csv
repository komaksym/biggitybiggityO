code,label
"def powerset(items):
    if not items:
        return [[]]
    first = items[0]
    rest = powerset(items[1:])
    return rest + [[first] + subset for subset in rest]
",O(2 ^ n)
"def generate_binary_strings(n):
    if n == 0:
        return ['']
    prev = generate_binary_strings(n - 1)
    return [s + '0' for s in prev] + [s + '1' for s in prev]
",O(2 ^ n)
"def tower_of_hanoi(n, source, target, auxiliary):
    if n > 0:
        tower_of_hanoi(n - 1, source, auxiliary, target)
        target.append(source.pop())
        tower_of_hanoi(n - 1, auxiliary, target, source)
",O(2 ^ n)
"def all_subsets(nums):
    result = []
    def backtrack(start, path):
        result.append(path[:])
        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()
    backtrack(0, [])
    return result
",O(2 ^ n)
"def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)
",O(2 ^ n)
"def generate_parentheses(n):
    result = []
    def dfs(s, left, right):
        if len(s) == 2 * n:
            result.append(s)
            return
        if left < n:
            dfs(s + '(', left + 1, right)
        if right < left:
            dfs(s + ')', left, right + 1)
    dfs('', 0, 0)
    return result
",O(2 ^ n)
"def count_subsets_sum(arr, target):
    def dfs(i, current_sum):
        if i == len(arr):
            return 1 if current_sum == target else 0
        return dfs(i + 1, current_sum) + dfs(i + 1, current_sum + arr[i])
    return dfs(0, 0)
",O(2 ^ n)
"def all_permutations(arr):
    if len(arr) <= 1:
        return [arr]
    result = []
    for i in range(len(arr)):
        rest = arr[:i] + arr[i+1:]
        for p in all_permutations(rest):
            result.append([arr[i]] + p)
    return result
",O(2 ^ n)
"def word_break(s, word_dict):
    def dfs(start):
        if start == len(s):
            return True
        for end in range(start + 1, len(s) + 1):
            if s[start:end] in word_dict and dfs(end):
                return True
        return False
    return dfs(0)
",O(2 ^ n)
"def knapsack_recursive(weights, values, capacity, n):
    if n == 0 or capacity == 0:
        return 0
    if weights[n-1] > capacity:
        return knapsack_recursive(weights, values, capacity, n-1)
    return max(values[n-1] + knapsack_recursive(weights, values, capacity - weights[n-1], n-1),
               knapsack_recursive(weights, values, capacity, n-1))
",O(2 ^ n)
