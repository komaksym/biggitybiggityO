code,complexity
"def generate_permutations(arr):
    if len(arr) == 0:
        return [[]]
    result = []
    for i in range(len(arr)):
        rest = arr[:i] + arr[i+1:]
        for p in generate_permutations(rest):
            result.append([arr[i]] + p)
    return result",O(n!)
"def heap_permutation(data, n):
    if n == 1:
        print(data)
        return
    for i in range(n):
        heap_permutation(data, n-1)
        if n % 2 == 0:
            data[i], data[n-1] = data[n-1], data[i]
        else:
            data[0], data[n-1] = data[n-1], data[0]",O(n!)
"def all_permutations(seq):
    from itertools import permutations
    return list(permutations(seq))",O(n!)
"def permute(nums):
    res = []
    def backtrack(start):
        if start == len(nums):
            res.append(nums[:])
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]
    backtrack(0)
    return res",O(n!)
"def generate_anagrams(s):
    if len(s) <= 1:
        return [s]
    anagrams = []
    for i, char in enumerate(s):
        remaining = s[:i] + s[i+1:]
        for perm in generate_anagrams(remaining):
            anagrams.append(char + perm)
    return anagrams",O(n!)
"def traveling_salesman(graph, n):
    from itertools import permutations
    min_path = float('inf')
    for perm in permutations(range(n)):
        current_cost = 0
        for i in range(n):
            current_cost += graph[perm[i]][perm[(i+1)%n]]
        min_path = min(min_path, current_cost)
    return min_path",O(n!)
"def derangements(n):
    if n == 0:
        return 1
    if n == 1:
        return 0
    return (n-1) * (derangements(n-1) + derangements(n-2))",O(n!)
"def generate_sequences(n, k):
    if k == 0:
        return [[]]
    sequences = []
    for seq in generate_sequences(n, k-1):
        for i in range(n):
            if i not in seq:
                sequences.append(seq + [i])
    return sequences",O(n!)
"def generate_permutations(arr):
    if len(arr) <= 1:
        return [arr]
    result = []
    for i in range(len(arr)):
        first = arr[i]
        rest = arr[:i] + arr[i+1:]
        for p in generate_permutations(rest):
            result.append([first] + p)
    return result",O(n!)
"def all_permutations(data):
    if len(data) == 0:
        return [[]]
    permutations = []
    for i in range(len(data)):
        current = data[i]
        remaining = data[:i] + data[i+1:]
        for perm in all_permutations(remaining):
            permutations.append([current] + perm)
    return permutations",O(n!)
"def permute(nums):
    result = []
    def backtrack(start):
        if start == len(nums):
            result.append(nums[:])
            return
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]
    backtrack(0)
    return result",O(n!)
"def factorial_permutation(items):
    if not items:
        yield []
    else:
        for i in range(len(items)):
            for perm in factorial_permutation(items[:i] + items[i+1:]):
                yield [items[i]] + perm",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.results = []
    
    def generate(self, elements):
        self._helper(elements, [])
        return self.results
    
    def _helper(self, remaining, current):
        if len(remaining) == 0:
            self.results.append(current)
            return
        for i in range(len(remaining)):
            self._helper(remaining[:i] + remaining[i+1:], current + [remaining[i]])",O(n!)
"def get_permutations(sequence):
    if len(sequence) == 1:
        return [sequence]
    perms = []
    for i, char in enumerate(sequence):
        for p in get_permutations(sequence[:i] + sequence[i+1:]):
            perms.append([char] + p)
    return perms",O(n!)
"def permutation_sequence(elems):
    from itertools import permutations
    return list(permutations(elems))",O(n!)
"def recursive_permute(lst):
    if len(lst) == 0:
        return [[]]
    output = []
    for i in range(len(lst)):
        head = lst[i]
        tail = lst[:i] + lst[i+1:]
        for p in recursive_permute(tail):
            output.append([head] + p)
    return output",O(n!)
"def heap_permutation(n, A):
    if n == 1:
        yield A[:]
    else:
        for i in range(n):
            yield from heap_permutation(n - 1, A)
            if n % 2 == 0:
                A[i], A[n-1] = A[n-1], A[i]
            else:
                A[0], A[n-1] = A[n-1], A[0]",O(n!)
"def all_permutations(seq):
    if len(seq) <= 1:
        return [seq]
    else:
        perms = []
        for i in range(len(seq)):
            first = seq[i]
            remaining = seq[:i] + seq[i+1:]
            for p in all_permutations(remaining):
                perms.append([first] + p)
        return perms",O(n!)
"def factorial_complexity(n, current=[]):
    if len(current) == n:
        return [current[:]]
    results = []
    for i in range(1, n+1):
        if i not in current:
            current.append(i)
            results.extend(factorial_complexity(n, current))
            current.pop()
    return results",O(n!)
"def permute(nums):
    res = []
    def backtrack(start):
        if start == len(nums):
            res.append(nums[:])
            return
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]
    backtrack(0)
    return res",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, items, path=[]):
        if not items:
            self.result.append(path)
            return
        for i in range(len(items)):
            self.generate(items[:i] + items[i+1:], path + [items[i]])",O(n!)
"def heap_permutation(n, arr):
    if n == 1:
        yield arr[:]
    else:
        for i in range(n):
            yield from heap_permutation(n - 1, arr)
            if n % 2 == 0:
                arr[i], arr[n-1] = arr[n-1], arr[i]
            else:
                arr[0], arr[n-1] = arr[n-1], arr[0]",O(n!)
"def get_permutations(elements):
    if len(elements) <= 1:
        return [elements]
    permutations = []
    for perm in get_permutations(elements[1:]):
        for i in range(len(elements)):
            new_perm = perm[:i] + [elements[0]] + perm[i:]
            permutations.append(new_perm)
    return permutations",O(n!)
"def ordered_combinations(n):
    from itertools import permutations
    return list(permutations(range(1, n+1)))",O(n!)
"def permutation_sequence(n):
    def dfs(used, path):
        if len(path) == n:
            yield path[:]
        for i in range(1, n+1):
            if not used[i]:
                used[i] = True
                path.append(i)
                yield from dfs(used, path)
                path.pop()
                used[i] = False
    return list(dfs([False]*(n+1), []))",O(n!)
"def all_arrangements(data):
    if len(data) == 0:
        return []
    if len(data) == 1:
        return [data]
    arrangements = []
    for i in range(len(data)):
        m = data[i]
        rem = data[:i] + data[i+1:]
        for p in all_arrangements(rem):
            arrangements.append([m] + p)
    return arrangements",O(n!)
"import itertools
def all_permutations(n):
    items = list(range(n))
    return list(itertools.permutations(items))",O(n!)
"def heap_permutation(n):
    def generate(k, arr):
        if k == 1:
            yield arr[:]
        else:
            for i in range(k):
                yield from generate(k - 1, arr)
                if k % 2 == 0:
                    arr[i], arr[k-1] = arr[k-1], arr[i]
                else:
                    arr[0], arr[k-1] = arr[k-1], arr[0]
    arr = list(range(n))
    return list(generate(n, arr))",O(n!)
"def solve_tsp(graph):
    n = len(graph)
    min_path = float('inf')
    def dfs(path, visited, cost):
        nonlocal min_path
        if len(path) == n:
            min_path = min(min_path, cost + graph[path[-1]][path[0]])
            return
        for next_city in range(n):
            if not visited[next_city]:
                visited[next_city] = True
                dfs(path + [next_city], visited, cost + graph[path[-1]][next_city])
                visited[next_city] = False
    visited = [False] * n
    visited[0] = True
    dfs([0], visited, 0)
    return min_path",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    def permute(self, nums):
        self.backtrack(nums, [])
        return self.result
    def backtrack(self, nums, path):
        if not nums:
            self.result.append(path)
            return
        for i in range(len(nums)):
            self.backtrack(nums[:i] + nums[i+1:], path + [nums[i]])",O(n!)
"def derangements(n):
    if n == 0:
        return 1
    if n == 1:
        return 0
    return (n - 1) * (derangements(n - 1) + derangements(n - 2))",O(n!)
"def assignment_problem(cost_matrix):
    n = len(cost_matrix)
    min_cost = float('inf')
    def assign(worker, assigned, total):
        nonlocal min_cost
        if worker == n:
            min_cost = min(min_cost, total)
            return
        for job in range(n):
            if not assigned[job]:
                assigned[job] = True
                assign(worker + 1, assigned, total + cost_matrix[worker][job])
                assigned[job] = False
    assign(0, [False] * n, 0)
    return min_cost",O(n!)
"def generate_permutations(arr):
    if len(arr) <= 1:
        return [arr]
    result = []
    for i in range(len(arr)):
        rest = arr[:i] + arr[i+1:]
        for p in generate_permutations(rest):
            result.append([arr[i]] + p)
    return result",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, nums, path=[]):
        if not nums:
            self.result.append(path)
            return
        for i in range(len(nums)):
            self.generate(nums[:i] + nums[i+1:], path + [nums[i]])

generator = PermutationGenerator()
generator.generate([1, 2, 3, 4])",O(n!)
"def heap_permutation(n, arr):
    if n == 1:
        print(arr)
        return
    for i in range(n):
        heap_permutation(n-1, arr)
        if n % 2 == 1:
            arr[0], arr[n-1] = arr[n-1], arr[0]
        else:
            arr[i], arr[n-1] = arr[n-1], arr[i]

heap_permutation(4, ['a', 'b', 'c', 'd'])",O(n!)
"def traveling_salesman(n, graph):
    from itertools import permutations
    min_cost = float('inf')
    for perm in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += graph[perm[i]][perm[(i+1)%n]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def generate_anagrams(s):
    if len(s) == 1:
        return [s]
    anagrams = []
    for i, char in enumerate(s):
        remaining = s[:i] + s[i+1:]
        for ana in generate_anagrams(remaining):
            anagrams.append(char + ana)
    return anagrams",O(n!)
"def solve_tsp(n, distances):
    visited = [False] * n
    def dfs(city, count, cost):
        if count == n:
            return cost + distances[city][0]
        min_cost = float('inf')
        for next_city in range(n):
            if not visited[next_city]:
                visited[next_city] = True
                min_cost = min(min_cost, dfs(next_city, count+1, cost + distances[city][next_city]))
                visited[next_city] = False
        return min_cost
    visited[0] = True
    return dfs(0, 1, 0)",O(n!)
"def factorial_permute(elements):
    from itertools import permutations
    return list(permutations(elements))",O(n!)
"def permute_unique(nums):
    result = []
    def backtrack(start):
        if start == len(nums):
            result.append(nums[:])
            return
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]
    backtrack(0)
    return result",O(n!)
"def generate_anagrams(s):
    if len(s) == 0:
        return [""""]
    anagrams = []
    for i in range(len(s)):
        for ana in generate_anagrams(s[:i] + s[i+1:]):
            anagrams.append(s[i] + ana)
    return anagrams",O(n!)
"def traveling_salesman(graph, start):
    from itertools import permutations
    n = len(graph)
    vertices = [i for i in range(n) if i != start]
    min_path = float('inf')
    for perm in permutations(vertices):
        current_cost = 0
        k = start
        for j in perm:
            current_cost += graph[k][j]
            k = j
        current_cost += graph[k][start]
        min_path = min(min_path, current_cost)
    return min_path",O(n!)
"def derangements(n):
    if n == 0:
        return [[]]
    result = []
    for i in range(n):
        for d in derangements(n - 1):
            if i != len(d):
                result.append(d[:i] + [n-1] + d[i:])
    return result",O(n!)
"def generate_sequences(n):
    if n == 0:
        return [[]]
    smaller = generate_sequences(n-1)
    result = []
    for seq in smaller:
        for i in range(len(seq)+1):
            result.append(seq[:i] + [n-1] + seq[i:])
    return result",O(n!)
"def all_arrangements(items):
    if not items:
        return [[]]
    arrangements = []
    for i in range(len(items)):
        first_item = items[i]
        remaining_items = items[:i] + items[i+1:]
        for arr in all_arrangements(remaining_items):
            arrangements.append([first_item] + arr)
    return arrangements",O(n!)
"def all_paths(nodes):
    if not nodes:
        return [[]]
    paths = []
    for i in range(len(nodes)):
        remaining = nodes[:i] + nodes[i+1:]
        for path in all_paths(remaining):
            paths.append([nodes[i]] + path)
    return paths",O(n!)
"def factorial_complexity(data):
    if len(data) <= 1:
        return [data]
    permutations = []
    for i, elem in enumerate(data):
        remaining = data[:i] + data[i+1:]
        for perm in factorial_complexity(remaining):
            permutations.append([elem] + perm)
    return permutations",O(n!)
"def permute_unique(items):
    if len(items) == 0:
        yield []
    else:
        for idx in range(len(items)):
            rest = items[:idx] + items[idx+1:]
            for perm in permute_unique(rest):
                yield [items[idx]] + perm",O(n!)
"class PermutationGenerator:
    def generate(self, elements):
        if len(elements) == 0:
            return [[]]
        results = []
        for i in range(len(elements)):
            current = elements[i]
            remaining = elements[:i] + elements[i+1:]
            subperms = self.generate(remaining)
            for sub in subperms:
                results.append([current] + sub)
        return results",O(n!)
"def heap_permutation(n, arr):
    if n == 1:
        print(arr)
        return
    for i in range(n):
        heap_permutation(n-1, arr)
        if n % 2 == 0:
            arr[i], arr[n-1] = arr[n-1], arr[i]
        else:
            arr[0], arr[n-1] = arr[n-1], arr[0]",O(n!)
"def ordered_combinations(sequence):
    if len(sequence) == 0:
        return [[]]
    output = []
    for index in range(len(sequence)):
        first = sequence[index]
        rest = sequence[:index] + sequence[index+1:]
        for combo in ordered_combinations(rest):
            output.append([first] + combo)
    return output",O(n!)
"def exhaustive_permutations(items):
    n = len(items)
    if n == 0:
        return [[]]
    result = []
    for i in range(n):
        remaining = items[:i] + items[i+1:]
        perms = exhaustive_permutations(remaining)
        for p in perms:
            result.append([items[i]] + p)
    return result",O(n!)
"def factorial_complexity(n):
    if n == 0:
        return 1
    count = 0
    for i in range(n):
        count += factorial_complexity(n - 1)
    return count",O(n!)
"def all_permutations(elements):
    from itertools import permutations
    return list(permutations(elements))",O(n!)
"def generate_sequences(n, current=[]):
    if len(current) == n:
        return [current[:]]
    sequences = []
    for i in range(n):
        if i not in current:
            current.append(i)
            sequences.extend(generate_sequences(n, current))
            current.pop()
    return sequences",O(n!)
"def heap_permutation(data, n):
    if n == 1:
        yield data[:]
    else:
        for i in range(n):
            yield from heap_permutation(data, n - 1)
            if n % 2 == 0:
                data[i], data[n-1] = data[n-1], data[i]
            else:
                data[0], data[n-1] = data[n-1], data[0]",O(n!)
"def traveling_salesman_naive(graph, start):
    from itertools import permutations
    nodes = list(graph.keys())
    nodes.remove(start)
    min_path_cost = float('inf')
    for perm in permutations(nodes):
        current_path = [start] + list(perm) + [start]
        cost = 0
        for i in range(len(current_path)-1):
            cost += graph[current_path[i]][current_path[i+1]]
        if cost < min_path_cost:
            min_path_cost = cost
    return min_path_cost",O(n!)
"def generate_arrangements(items):
    if not items:
        return [[]]
    arrangements = []
    for i, item in enumerate(items):
        remaining = items[:i] + items[i+1:]
        for arr in generate_arrangements(remaining):
            arrangements.append([item] + arr)
    return arrangements",O(n!)
"def n_queens_count(n):
    def backtrack(row, cols, diag1, diag2):
        if row == n:
            return 1
        count = 0
        for col in range(n):
            d1 = row - col
            d2 = row + col
            if cols[col] or diag1[d1] or diag2[d2]:
                continue
            cols[col] = diag1[d1] = diag2[d2] = True
            count += backtrack(row + 1, cols, diag1, diag2)
            cols[col] = diag1[d1] = diag2[d2] = False
        return count
    return backtrack(0, [False]*n, [False]*(2*n), [False]*(2*n))",O(n!)
"def all_permutations(items):
    n = len(items)
    if n == 0:
        yield []
    else:
        for i in range(n):
            for perm in all_permutations(items[:i] + items[i+1:]):
                yield [items[i]] + perm",O(n!)
"def factorial_complexity(n):
    if n == 0:
        return 1
    total = 0
    for i in range(n):
        total += factorial_complexity(n - 1)
    return total",O(n!)
"def permute(data):
    if len(data) <= 1:
        return [data]
    permutations = []
    for i in range(len(data)):
        current = data[i]
        remaining = data[:i] + data[i+1:]
        for p in permute(remaining):
            permutations.append([current] + p)
    return permutations",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, arr, start=0):
        if start == len(arr):
            self.result.append(arr[:])
            return
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self.generate(arr, start + 1)
            arr[start], arr[i] = arr[i], arr[start]

def get_permutations(n):
    pg = PermutationGenerator()
    pg.generate(list(range(n)))
    return pg.result",O(n!)
"def heap_permutation(n, arr, result):
    if n == 1:
        result.append(arr[:])
        return
    for i in range(n):
        heap_permutation(n - 1, arr, result)
        if n % 2 == 0:
            arr[i], arr[n-1] = arr[n-1], arr[i]
        else:
            arr[0], arr[n-1] = arr[n-1], arr[0]

def generate_all_permutations(size):
    array = list(range(size))
    res = []
    heap_permutation(size, array, res)
    return res",O(n!)
"def traveling_salesman(n, graph):
    from itertools import permutations
    min_cost = float('inf')
    for path in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += graph[path[i]][path[(i+1)%n]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def generate_sequences(n):
    if n == 0:
        return [[]]
    smaller = generate_sequences(n-1)
    result = []
    for seq in smaller:
        for i in range(len(seq)+1):
            new_seq = seq[:i] + [n] + seq[i:]
            result.append(new_seq)
    return result",O(n!)
"def all_permutations(data):
    if len(data) <= 1:
        return [data]
    permutations = []
    for i in range(len(data)):
        current = data[i]
        remaining = data[:i] + data[i+1:]
        for perm in all_permutations(remaining):
            permutations.append([current] + perm)
    return permutations",O(n!)
"def traveling_salesman(graph, start=0):
    from itertools import permutations
    n = len(graph)
    vertices = [i for i in range(n) if i != start]
    min_path = float('inf')
    for perm in permutations(vertices):
        current_path = 0
        k = start
        for j in perm:
            current_path += graph[k][j]
            k = j
        current_path += graph[k][start]
        min_path = min(min_path, current_path)
    return min_path",O(n!)
"def all_derangements(n):
    if n == 0:
        return [[]]
    if n == 1:
        return []
    result = []
    for i in range(1, n):
        for der in all_derangements(n - 2):
            result.append([i, 0] + [x + 2 if x >= i - 1 else x + 1 for x in der])
    return result",O(n!)
"def generate_sequence_permutations(seq):
    if not seq:
        yield []
    else:
        for i in range(len(seq)):
            for perm in generate_sequence_permutations(seq[:i] + seq[i+1:]):
                yield [seq[i]] + perm",O(n!)
"def heap_permutation(data, n):
    if n == 1:
        print(data)
        return
    for i in range(n):
        heap_permutation(data, n - 1)
        if n % 2 == 0:
            data[i], data[n-1] = data[n-1], data[i]
        else:
            data[0], data[n-1] = data[n-1], data[0]",O(n!)
"def solve_tsp(graph):
    n = len(graph)
    min_path = float('inf')
    
    def dfs(path, visited, cost):
        nonlocal min_path
        if len(path) == n:
            min_path = min(min_path, cost + graph[path[-1]][path[0]])
            return
        for next_city in range(n):
            if not visited[next_city]:
                visited[next_city] = True
                dfs(path + [next_city], visited, cost + graph[path[-1]][next_city])
                visited[next_city] = False
    
    for start in range(n):
        visited = [False] * n
        visited[start] = True
        dfs([start], visited, 0)
    return min_path",O(n!)
"def generate_anagrams(s):
    if len(s) <= 1:
        return [s]
    result = []
    for i, char in enumerate(s):
        remaining = s[:i] + s[i+1:]
        for perm in generate_anagrams(remaining):
            result.append(char + perm)
    return result",O(n!)
"def assignment_cost(cost_matrix):
    n = len(cost_matrix)
    min_cost = float('inf')
    
    def backtrack(worker, assigned, total):
        nonlocal min_cost
        if worker == n:
            min_cost = min(min_cost, total)
            return
        for job in range(n):
            if not assigned[job]:
                assigned[job] = True
                backtrack(worker + 1, assigned, total + cost_matrix[worker][job])
                assigned[job] = False
    
    backtrack(0, [False] * n, 0)
    return min_cost",O(n!)
"def factorial_complexity(n):
    if n == 0:
        return [[]]
    prev = factorial_complexity(n - 1)
    result = []
    for perm in prev:
        for i in range(len(perm) + 1):
            new_perm = perm[:i] + [n] + perm[i:]
            result.append(new_perm)
    return result",O(n!)
"def heap_permutation(n, arr):
    if n == 1:
        print(arr)
        return
    for i in range(n):
        heap_permutation(n - 1, arr)
        if n % 2 == 0:
            arr[i], arr[n-1] = arr[n-1], arr[i]
        else:
            arr[0], arr[n-1] = arr[n-1], arr[0]",O(n!)
"def permute_string(s):
    if len(s) == 1:
        return [s]
    perms = []
    for i, char in enumerate(s):
        remaining = s[:i] + s[i+1:]
        for perm in permute_string(remaining):
            perms.append(char + perm)
    return perms",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, arr, start=0):
        if start == len(arr):
            self.result.append(arr[:])
            return
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self.generate(arr, start + 1)
            arr[start], arr[i] = arr[i], arr[start]
    
    def get_permutations(self, arr):
        self.result = []
        self.generate(arr)
        return self.result",O(n!)
"def generate_sequences(n):
    if n == 0:
        return [[]]
    smaller = generate_sequences(n - 1)
    sequences = []
    for seq in smaller:
        for pos in range(len(seq) + 1):
            new_seq = seq[:pos] + [n] + seq[pos:]
            sequences.append(new_seq)
    return sequences",O(n!)
"def count_permutations(n):
    if n == 0:
        return 1
    count = 0
    for i in range(n):
        count += count_permutations(n - 1)
    return count",O(n!)
"def hamiltonian_paths(graph, n):
    def backtrack(path):
        if len(path) == n:
            results.append(path[:])
            return
        current = path[-1] if path else 0
        for neighbor in range(n):
            if graph[current][neighbor] and neighbor not in path:
                path.append(neighbor)
                backtrack(path)
                path.pop()
    results = []
    backtrack([])
    return results",O(n!)
"def all_permutations(items):
    from itertools import permutations
    return list(permutations(items))",O(n!)
"def solve_tsp(distances):
    n = len(distances)
    min_cost = float('inf')
    best_path = []
    
    def dfs(path, visited, cost):
        nonlocal min_cost, best_path
        if len(path) == n:
            total = cost + distances[path[-1]][path[0]]
            if total < min_cost:
                min_cost = total
                best_path = path[:]
            return
        last = path[-1]
        for next_city in range(n):
            if not visited[next_city]:
                visited[next_city] = True
                path.append(next_city)
                dfs(path, visited, cost + distances[last][next_city])
                path.pop()
                visited[next_city] = False
    
    visited = [False] * n
    visited[0] = True
    dfs([0], visited, 0)
    return best_path, min_cost",O(n!)
"def arrangement_count(n, k):
    def backtrack(current):
        if len(current) == k:
            count[0] += 1
            return
        for i in range(n):
            if i not in current:
                current.append(i)
                backtrack(current)
                current.pop()
    count = [0]
    backtrack([])
    return count[0]",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.results = []
    
    def generate(self, elements):
        self._backtrack(elements, [])
        return self.results
    
    def _backtrack(self, elements, current):
        if not elements:
            self.results.append(current[:])
            return
        for i in range(len(elements)):
            current.append(elements[i])
            self._backtrack(elements[:i] + elements[i+1:], current)
            current.pop()",O(n!)
"def factorial_permute(lst):
    if not lst:
        return [[]]
    return [[lst[i]] + p for i in range(len(lst)) for p in factorial_permute(lst[:i] + lst[i+1:])]",O(n!)
"def permute_string(s):
    if len(s) == 1:
        return [s]
    perms = []
    for i, char in enumerate(s):
        for perm in permute_string(s[:i] + s[i+1:]):
            perms.append(char + perm)
    return perms",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, arr, start=0):
        if start == len(arr):
            self.result.append(arr[:])
            return
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self.generate(arr, start + 1)
            arr[start], arr[i] = arr[i], arr[start]

def get_permutations(arr):
    pg = PermutationGenerator()
    pg.generate(arr)
    return pg.result",O(n!)
"def heap_permute(n, arr):
    if n == 1:
        yield arr[:]
    else:
        for i in range(n):
            yield from heap_permute(n - 1, arr)
            if n % 2 == 0:
                arr[i], arr[n-1] = arr[n-1], arr[i]
            else:
                arr[0], arr[n-1] = arr[n-1], arr[0]",O(n!)
"def ordered_combinations(items):
    if len(items) == 0:
        return [[]]
    first = items[0]
    rest = items[1:]
    combs_without = ordered_combinations(rest)
    combs_with = []
    for comb in combs_without:
        for i in range(len(comb) + 1):
            new_comb = comb[:i] + [first] + comb[i:]
            combs_with.append(new_comb)
    return combs_without + combs_with",O(n!)
"def generate_anagrams(word):
    if len(word) <= 1:
        return [word]
    anagrams = []
    for i in range(len(word)):
        substr = word[:i] + word[i+1:]
        for ana in generate_anagrams(substr):
            anagrams.append(word[i] + ana)
    return anagrams",O(n!)
"def factorial_permute(n):
    from itertools import permutations
    return list(permutations(range(n)))",O(n!)
"def all_permutations(elements):
    if len(elements) == 0:
        return [[]]
    perms = []
    for i in range(len(elements)):
        current = elements[i]
        remaining = elements[:i] + elements[i+1:]
        for p in all_permutations(remaining):
            perms.append([current] + p)
    return perms",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, arr, start=0):
        if start == len(arr):
            self.result.append(arr[:])
            return
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self.generate(arr, start + 1)
            arr[start], arr[i] = arr[i], arr[start]
    
    def get_permutations(self, n):
        self.result = []
        self.generate(list(range(n)))
        return self.result",O(n!)
"def heap_permute(n):
    def generate(k, arr):
        if k == 1:
            yield arr[:]
        else:
            for i in range(k):
                yield from generate(k - 1, arr)
                if k % 2 == 0:
                    arr[i], arr[k-1] = arr[k-1], arr[i]
                else:
                    arr[0], arr[k-1] = arr[k-1], arr[0]
    return list(generate(n, list(range(n))))",O(n!)
"def permute_string(s):
    if len(s) == 1:
        return [s]
    res = []
    for i, char in enumerate(s):
        for perm in permute_string(s[:i] + s[i+1:]):
            res.append(char + perm)
    return res",O(n!)
"def traveling_salesman(n):
    from itertools import permutations
    distances = [[0 if i == j else 1 for j in range(n)] for i in range(n)]
    min_cost = float('inf')
    for path in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += distances[path[i]][path[(i+1)%n]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def generate_anagrams(word):
    if len(word) <= 1:
        return [word]
    anagrams = []
    for i in range(len(word)):
        for ana in generate_anagrams(word[:i] + word[i+1:]):
            anagrams.append(word[i] + ana)
    return anagrams",O(n!)
"def all_permutations(elements):
    if len(elements) <= 1:
        yield elements
    else:
        for perm in all_permutations(elements[1:]):
            for i in range(len(elements)):
                yield perm[:i] + elements[0:1] + perm[i:]",O(n!)
"def solve_tsp(graph):
    n = len(graph)
    min_path = float('inf')
    def dfs(path, visited, cost):
        nonlocal min_path
        if len(path) == n:
            min_path = min(min_path, cost + graph[path[-1]][path[0]])
            return
        for next_city in range(n):
            if not visited[next_city]:
                visited[next_city] = True
                dfs(path + [next_city], visited, cost + graph[path[-1]][next_city])
                visited[next_city] = False
    for start in range(n):
        visited = [False] * n
        visited[start] = True
        dfs([start], visited, 0)
    return min_path",O(n!)
"def generate_anagrams(s):
    if len(s) == 0:
        return {''}
    result = set()
    for i in range(len(s)):
        for ana in generate_anagrams(s[:i] + s[i+1:]):
            result.add(s[i] + ana)
    return result",O(n!)
"def permute_unique(nums):
    result = []
    def backtrack(start):
        if start == len(nums):
            result.append(nums[:])
            return
        seen = set()
        for i in range(start, len(nums)):
            if nums[i] in seen:
                continue
            seen.add(nums[i])
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]
    backtrack(0)
    return result",O(n!)
"def all_paths(graph):
    n = len(graph)
    paths = []
    def dfs(path):
        if len(path) == n:
            paths.append(path[:])
            return
        for neighbor in graph[path[-1]]:
            if neighbor not in path:
                path.append(neighbor)
                dfs(path)
                path.pop()
    for i in range(n):
        dfs([i])
    return paths",O(n!)
"def permute(nums):
    def backtrack(start):
        if start == len(nums):
            output.append(nums[:])
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]
    output = []
    backtrack(0)
    return output",O(n!)
"def factorial_permute(lst):
    if len(lst) <= 1:
        return [lst]
    perms = []
    for i in range(len(lst)):
        m = lst[i]
        rem = lst[:i] + lst[i+1:]
        for p in factorial_permute(rem):
            perms.append([m] + p)
    return perms",O(n!)
"def get_permutations(arr):
    if len(arr) == 1:
        return [arr]
    perms = []
    for i, el in enumerate(arr):
        remaining = arr[:i] + arr[i+1:]
        for p in get_permutations(remaining):
            perms.append([el] + p)
    return perms",O(n!)
"def permute_unique(nums):
    def backtrack(path, counter):
        if len(path) == len(nums):
            res.append(path[:])
            return
        for num in counter:
            if counter[num] > 0:
                path.append(num)
                counter[num] -= 1
                backtrack(path, counter)
                path.pop()
                counter[num] += 1
    res = []
    backtrack([], collections.Counter(nums))
    return res",O(n!)
"def all_orders(items):
    if not items:
        return [[]]
    orders = []
    for idx, item in enumerate(items):
        for order in all_orders(items[:idx] + items[idx+1:]):
            orders.append([item] + order)
    return orders",O(n!)
"def ordered_combinations(elems):
    if len(elems) == 0:
        return [[]]
    result = []
    for i in range(len(elems)):
        first = elems[i]
        rest = elems[:i] + elems[i+1:]
        for combo in ordered_combinations(rest):
            result.append([first] + combo)
    return result",O(n!)
"def generate_all_orders(arr):
    if len(arr) == 0:
        return [[]]
    output = []
    for i in range(len(arr)):
        current = arr[i]
        remaining = arr[:i] + arr[i+1:]
        for perm in generate_all_orders(remaining):
            output.append([current] + perm)
    return output",O(n!)
"def all_permutations(seq):
    if len(seq) <= 1:
        yield seq
    else:
        for perm in all_permutations(seq[1:]):
            for i in range(len(perm) + 1):
                yield perm[:i] + seq[0:1] + perm[i:]",O(n!)
"def generate_anagrams(s):
    if len(s) == 1:
        return [s]
    result = []
    for i, char in enumerate(s):
        remaining = s[:i] + s[i+1:]
        for perm in generate_anagrams(remaining):
            result.append(char + perm)
    return result",O(n!)
"def traveling_salesman(graph, path, visited, cost, n):
    if len(path) == n:
        return cost + graph[path[-1]][path[0]]
    min_cost = float('inf')
    for next_city in range(n):
        if not visited[next_city]:
            visited[next_city] = True
            path.append(next_city)
            new_cost = cost + graph[path[-2]][path[-1]] if len(path) > 1 else 0
            min_cost = min(min_cost, traveling_salesman(graph, path, visited, new_cost, n))
            path.pop()
            visited[next_city] = False
    return min_cost",O(n!)
"def permutation_sort(arr):
    def is_sorted(lst):
        return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))
    def generate_permutations(items):
        if len(items) == 0:
            yield []
        for i in range(len(items)):
            for perm in generate_permutations(items[:i] + items[i+1:]):
                yield [items[i]] + perm
    for perm in generate_permutations(arr):
        if is_sorted(perm):
            return perm",O(n!)
"def factorial_complexity(n, current=[]):
    if len(current) == n:
        return 1
    total = 0
    for i in range(n):
        if i not in current:
            total += factorial_complexity(n, current + [i])
    return total",O(n!)
"def all_permutations(items):
    if len(items) <= 1:
        yield items
    else:
        for perm in all_permutations(items[1:]):
            for i in range(len(items)):
                yield perm[:i] + items[0:1] + perm[i:]",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, nums, path=[]):
        if not nums:
            self.result.append(path)
            return
        for i in range(len(nums)):
            self.generate(nums[:i] + nums[i+1:], path + [nums[i]])",O(n!)
"def heap_permutation(n, arr):
    if n == 1:
        return [arr[:]]
    result = []
    for i in range(n):
        result.extend(heap_permutation(n - 1, arr))
        if n % 2 == 0:
            arr[i], arr[n-1] = arr[n-1], arr[i]
        else:
            arr[0], arr[n-1] = arr[n-1], arr[0]
    return result",O(n!)
"def count_arrangements(n, used=None):
    if used is None:
        used = [False] * n
    if all(used):
        return 1
    count = 0
    for i in range(n):
        if not used[i]:
            used[i] = True
            count += count_arrangements(n, used)
            used[i] = False
    return count",O(n!)
"def generate_sequence(n, seq=[]):
    if len(seq) == n:
        return [seq]
    sequences = []
    for i in range(n):
        if i not in seq:
            sequences.extend(generate_sequence(n, seq + [i]))
    return sequences",O(n!)
"def permute_unique(nums):
    if len(nums) == 0:
        return [[]]
    res = []
    for i in range(len(nums)):
        for j in permute_unique(nums[:i] + nums[i+1:]):
            res.append([nums[i]] + j)
    return res",O(n!)
"def all_permutations(n):
    from itertools import permutations
    return list(permutations(range(n)))",O(n!)
"def generate_sequences(n):
    if n == 0:
        return [[]]
    prev = generate_sequences(n - 1)
    result = []
    for seq in prev:
        for i in range(len(seq) + 1):
            new_seq = seq[:i] + [n] + seq[i:]
            result.append(new_seq)
    return result",O(n!)
"def heap_permutation(n):
    def generate(k, arr):
        if k == 1:
            yield arr[:]
        else:
            for i in range(k):
                yield from generate(k - 1, arr)
                if k % 2 == 0:
                    arr[i], arr[k-1] = arr[k-1], arr[i]
                else:
                    arr[0], arr[k-1] = arr[k-1], arr[0]
    return list(generate(n, list(range(n))))",O(n!)
"def traveling_salesman(n):
    from itertools import permutations
    distances = [[0 if i == j else 1 for j in range(n)] for i in range(n)]
    min_distance = float('inf')
    for path in permutations(range(n)):
        current_distance = 0
        for i in range(n):
            current_distance += distances[path[i]][path[(i+1)%n]]
        min_distance = min(min_distance, current_distance)
    return min_distance",O(n!)
"def generate_derangements(n):
    if n == 0:
        return [[]]
    if n == 1:
        return []
    result = []
    for i in range(1, n):
        for der in generate_derangements(n - 2):
            result.append([i, 0] + [x + 1 if x >= i else x for x in der])
    return result",O(n!)
"def all_permutations(seq):
    if len(seq) <= 1:
        yield seq
    else:
        for perm in all_permutations(seq[1:]):
            for i in range(len(perm)+1):
                yield perm[:i] + seq[0:1] + perm[i:]",O(n!)
"def permute_unique(nums):
    def backtrack(path, used):
        if len(path) == len(nums):
            output.append(path[:])
            return
        for i in range(len(nums)):
            if used[i]:
                continue
            used[i] = True
            path.append(nums[i])
            backtrack(path, used)
            path.pop()
            used[i] = False
    output = []
    backtrack([], [False]*len(nums))
    return output",O(n!)
"def ordered_permutations(items):
    if len(items) == 0:
        yield []
    for i in range(len(items)):
        for perm in ordered_permutations(items[:i] + items[i+1:]):
            yield [items[i]] + perm",O(n!)
"def generate_arrangements(elements):
    if not elements:
        return [[]]
    arrangements = []
    for i, el in enumerate(elements):
        remaining = elements[:i] + elements[i+1:]
        for arr in generate_arrangements(remaining):
            arrangements.append([el] + arr)
    return arrangements",O(n!)
"def all_orders(n):
    def dfs(path):
        if len(path) == n:
            res.append(path)
            return
        for i in range(1, n+1):
            if i not in path:
                dfs(path + [i])
    res = []
    dfs([])
    return res",O(n!)
"def permutation_sequence(data):
    if len(data) == 1:
        return [data]
    perms = []
    for i in range(len(data)):
        first = data[i]
        remaining = data[:i] + data[i+1:]
        for p in permutation_sequence(remaining):
            perms.append([first] + p)
    return perms",O(n!)
"def permute(data, i, length):
    if i == length:
        print(''.join(data))
    else:
        for j in range(i, length):
            data[i], data[j] = data[j], data[i]
            permute(data, i+1, length)
            data[i], data[j] = data[j], data[i]",O(n!)
"import itertools
def generate_all_orders(n):
    items = list(range(n))
    return list(itertools.permutations(items))",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.results = []
    def generate(self, current, remaining):
        if not remaining:
            self.results.append(current[:])
            return
        for i in range(len(remaining)):
            self.generate(current + [remaining[i]], remaining[:i] + remaining[i+1:])",O(n!)
"def heap_permute(n, arr):
    if n == 1:
        print(arr)
        return
    for i in range(n):
        heap_permute(n-1, arr)
        if n % 2 == 1:
            arr[0], arr[n-1] = arr[n-1], arr[0]
        else:
            arr[i], arr[n-1] = arr[n-1], arr[i]",O(n!)
"def dfs_permute(path, unused):
    if not unused:
        yield path
    for item in list(unused):
        unused.remove(item)
        yield from dfs_permute(path + [item], unused)
        unused.add(item)",O(n!)
"def ordered_combinations(elements):
    if len(elements) == 0:
        return [[]]
    perms = []
    first = elements[0]
    for shorter in ordered_combinations(elements[1:]):
        for i in range(len(shorter)+1):
            perms.append(shorter[:i] + [first] + shorter[i:])
    return perms",O(n!)
"def factorial_complexity(n):
    def helper(current, remaining):
        if len(remaining) == 0:
            return [current]
        results = []
        for i in range(len(remaining)):
            results.extend(helper(current + [remaining[i]], remaining[:i] + remaining[i+1:]))
        return results
    return helper([], list(range(n)))",O(n!)
"def permute_string(s):
    if len(s) == 1:
        return [s]
    permutations = []
    for i, char in enumerate(s):
        for perm in permute_string(s[:i] + s[i+1:]):
            permutations.append(char + perm)
    return permutations",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, arr, start=0):
        if start == len(arr):
            self.result.append(arr[:])
            return
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self.generate(arr, start + 1)
            arr[start], arr[i] = arr[i], arr[start]

generator = PermutationGenerator()
generator.generate([1, 2, 3, 4])",O(n!)
"def heap_permutation(n):
    def generate(k, A):
        if k == 1:
            yield A[:]
        else:
            for i in range(k):
                yield from generate(k - 1, A)
                if k % 2 == 0:
                    A[i], A[k-1] = A[k-1], A[i]
                else:
                    A[0], A[k-1] = A[k-1], A[0]
    return list(generate(n, list(range(n))))",O(n!)
"def traveling_salesman(n):
    from itertools import permutations
    cities = list(range(n))
    min_distance = float('inf')
    for path in permutations(cities):
        distance = 0
        for i in range(len(path)):
            distance += abs(path[i] - path[(i+1) % len(path)])
        min_distance = min(min_distance, distance)
    return min_distance",O(n!)
"def generate_anagrams(word):
    if len(word) == 0:
        return {''}
    anagrams = set()
    for i in range(len(word)):
        for ana in generate_anagrams(word[:i] + word[i+1:]):
            anagrams.add(word[i] + ana)
    return anagrams",O(n!)
"def permute(data):
    if len(data) == 0:
        return []
    if len(data) == 1:
        return [data]
    l = []
    for i in range(len(data)):
        m = data[i]
        remLst = data[:i] + data[i+1:]
        for p in permute(remLst):
            l.append([m] + p)
    return l",O(n!)
"def heap_permutation(n, arr):
    if n == 1:
        return [arr[:]]
    result = []
    for i in range(n):
        result.extend(heap_permutation(n - 1, arr))
        if n % 2 == 1:
            arr[0], arr[n-1] = arr[n-1], arr[0]
        else:
            arr[i], arr[n-1] = arr[n-1], arr[i]
    return result",O(n!)
"def traveling_salesman(n, graph):
    from itertools import permutations
    min_path = float('inf')
    for perm in permutations(range(n)):
        current_path = 0
        for i in range(n):
            current_path += graph[perm[i]][perm[(i + 1) % n]]
        min_path = min(min_path, current_path)
    return min_path",O(n!)
"def generate_sequences(n):
    if n == 0:
        return [[]]
    smaller = generate_sequences(n - 1)
    result = []
    for seq in smaller:
        for i in range(len(seq) + 1):
            result.append(seq[:i] + [n] + seq[i:])
    return result",O(n!)
"def count_arrangements(n):
    if n == 0:
        return 1
    count = 0
    for i in range(n):
        count += count_arrangements(n - 1)
    return count",O(n!)
"def all_derangements(n):
    if n == 0:
        return [[]]
    if n == 1:
        return []
    result = []
    for i in range(1, n):
        for der in all_derangements(n - 2):
            new_der = [i, 0] + [x + 1 if x >= i else x for x in der]
            result.append(new_der)
        for der in all_derangements(n - 1):
            new_der = [i] + [x if x < i else x + 1 for x in der]
            result.append(new_der)
    return result",O(n!)
"def permute_string(s):
    if len(s) <= 1:
        return [s]
    perms = []
    for i, char in enumerate(s):
        remaining = s[:i] + s[i+1:]
        for perm in permute_string(remaining):
            perms.append(char + perm)
    return perms",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, nums, path=[]):
        if not nums:
            self.result.append(path[:])
            return
        for i in range(len(nums)):
            self.generate(nums[:i] + nums[i+1:], path + [nums[i]])
    
    def get_permutations(self, nums):
        self.result = []
        self.generate(nums)
        return self.result",O(n!)
"def traveling_salesman(n):
    import itertools
    min_cost = float('inf')
    for path in itertools.permutations(range(n)):
        cost = 0
        for i in range(n-1):
            cost += abs(path[i] - path[i+1])
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def count_permutations(n):
    if n == 0:
        return 1
    total = 0
    for i in range(n):
        total += count_permutations(n - 1)
    return total",O(n!)
"def generate_anagrams(word):
    if len(word) == 1:
        return [word]
    anagrams = []
    for i in range(len(word)):
        first_char = word[i]
        rest = word[:i] + word[i+1:]
        for anagram in generate_anagrams(rest):
            anagrams.append(first_char + anagram)
    return anagrams",O(n!)
"def all_derangements(n):
    from itertools import permutations
    count = 0
    for perm in permutations(range(n)):
        if all(perm[i] != i for i in range(n)):
            count += 1
    return count",O(n!)
"def all_permutations(items):
    if len(items) <= 1:
        yield items
    else:
        for perm in all_permutations(items[1:]):
            for i in range(len(perm) + 1):
                yield perm[:i] + [items[0]] + perm[i:]",O(n!)
"def heap_permutation(data, n):
    if n == 1:
        print(data)
        return
    for i in range(n):
        heap_permutation(data, n - 1)
        if n % 2 == 0:
            data[i], data[n - 1] = data[n - 1], data[i]
        else:
            data[0], data[n - 1] = data[n - 1], data[0]",O(n!)
"def traveling_salesman(graph, n, path=[], cost=0):
    if len(path) == n:
        return cost + graph[path[-1]][path[0]]
    min_cost = float('inf')
    for next_city in range(n):
        if next_city not in path:
            new_cost = cost + (graph[path[-1]][next_city] if path else 0)
            candidate = traveling_salesman(graph, n, path + [next_city], new_cost)
            if candidate < min_cost:
                min_cost = candidate
    return min_cost",O(n!)
"def generate_derangements(n, current=[]):
    if len(current) == n:
        return [current[:]] if all(i != current[i] for i in range(n)) else []
    result = []
    for i in range(n):
        if i not in current and i != len(current):
            current.append(i)
            result.extend(generate_derangements(n, current))
            current.pop()
    return result",O(n!)
"def permute_unique(nums):
    if len(nums) == 0:
        return [[]]
    result = []
    used = [False] * len(nums)
    def backtrack(path):
        if len(path) == len(nums):
            result.append(path[:])
            return
        for i in range(len(nums)):
            if used[i]:
                continue
            used[i] = True
            path.append(nums[i])
            backtrack(path)
            path.pop()
            used[i] = False
    backtrack([])
    return result",O(n!)
"def all_permutations(data):
    from itertools import permutations
    return list(permutations(data))",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.results = []
    
    def generate(self, current, remaining):
        if len(remaining) == 0:
            self.results.append(current[:])
            return
        for i in range(len(remaining)):
            self.generate(current + [remaining[i]], remaining[:i] + remaining[i+1:])
    
    def get_permutations(self, items):
        self.generate([], items)
        return self.results",O(n!)
"def factorial_sequence(n):
    if n == 0:
        return [[]]
    smaller = factorial_sequence(n - 1)
    result = []
    for seq in smaller:
        for i in range(len(seq) + 1):
            new_seq = seq[:i] + [n] + seq[i:]
            result.append(new_seq)
    return result",O(n!)
"def traveling_salesman(graph, start):
    from itertools import permutations
    nodes = list(graph.keys())
    nodes.remove(start)
    min_path = None
    min_cost = float('inf')
    for perm in permutations(nodes):
        current_cost = 0
        current_node = start
        for next_node in perm:
            current_cost += graph[current_node][next_node]
            current_node = next_node
        current_cost += graph[current_node][start]
        if current_cost < min_cost:
            min_cost = current_cost
            min_path = [start] + list(perm) + [start]
    return min_path, min_cost",O(n!)
"def generate_derangements(n):
    if n == 0:
        return [[]]
    if n == 1:
        return []
    result = []
    for i in range(1, n):
        for der in generate_derangements(n - 2):
            result.append([i, 0] + [x + 2 if x >= i else x + 1 for x in der])
    return result",O(n!)
"def generate_permutations(arr):
    if len(arr) <= 1:
        return [arr]
    perms = []
    for i in range(len(arr)):
        rest = arr[:i] + arr[i+1:]
        for p in generate_permutations(rest):
            perms.append([arr[i]] + p)
    return perms",O(n!)
"def all_permutations(elements):
    if not elements:
        return [[]]
    result = []
    for idx, val in enumerate(elements):
        remaining = elements[:idx] + elements[idx+1:]
        for perm in all_permutations(remaining):
            result.append([val] + perm)
    return result",O(n!)
"def permute(data):
    if len(data) == 0:
        return []
    if len(data) == 1:
        return [data]
    l = []
    for i in range(len(data)):
        m = data[i]
        rem = data[:i] + data[i+1:]
        for p in permute(rem):
            l.append([m] + p)
    return l",O(n!)
"def factorial_permutation(items):
    n = len(items)
    if n == 0:
        return [[]]
    permutations = []
    for i in range(n):
        first = items[i]
        rest = items[:i] + items[i+1:]
        sub_perms = factorial_permutation(rest)
        for perm in sub_perms:
            permutations.append([first] + perm)
    return permutations",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    def generate(self, arr, start=0):
        if start == len(arr):
            self.result.append(arr[:])
            return
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self.generate(arr, start + 1)
            arr[start], arr[i] = arr[i], arr[start]
    def get_permutations(self, arr):
        self.result = []
        self.generate(arr)
        return self.result",O(n!)
"def heap_permutation(a, size):
    if size == 1:
        print(a)
        return
    for i in range(size):
        heap_permutation(a, size-1)
        if size % 2 == 1:
            a[0], a[size-1] = a[size-1], a[0]
        else:
            a[i], a[size-1] = a[size-1], a[i]",O(n!)
"def get_all_permutations(sequence):
    if len(sequence) == 0:
        return []
    if len(sequence) == 1:
        return [sequence]
    perms = []
    for i in range(len(sequence)):
        current = sequence[i]
        remaining = sequence[:i] + sequence[i+1:]
        for p in get_all_permutations(remaining):
            perms.append([current] + p)
    return perms",O(n!)
"def permute_list(lst):
    if len(lst) == 0:
        return [[]]
    return [[lst[i]] + p for i in range(len(lst)) for p in permute_list(lst[:i] + lst[i+1:])]",O(n!)
"def heap_permutation(n, A):
    if n == 1:
        print(A)
    else:
        for i in range(n):
            heap_permutation(n - 1, A)
            if n % 2 == 0:
                A[i], A[n-1] = A[n-1], A[i]
            else:
                A[0], A[n-1] = A[n-1], A[0]",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, arr, start=0):
        if start == len(arr):
            self.result.append(arr[:])
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self.generate(arr, start+1)
            arr[start], arr[i] = arr[i], arr[start]
        return self.result",O(n!)
"def get_all_orders(items):
    if not items:
        return [[]]
    orders = []
    for idx, item in enumerate(items):
        others = items[:idx] + items[idx+1:]
        for order in get_all_orders(others):
            orders.append([item] + order)
    return orders",O(n!)
"def factorial_permute(lst):
    if len(lst) == 0:
        yield []
    for i in range(len(lst)):
        rest = lst[:i] + lst[i+1:]
        for p in factorial_permute(rest):
            yield [lst[i]] + p",O(n!)
"def arrangement_sequence(elements):
    n = len(elements)
    if n == 0:
        return [[]]
    sequences = []
    for i in range(n):
        first = elements[i]
        remainder = elements[:i] + elements[i+1:]
        for seq in arrangement_sequence(remainder):
            sequences.append([first] + seq)
    return sequences",O(n!)
"def ordered_combinations(arr):
    if len(arr) == 1:
        return [arr]
    perms = []
    for i in range(len(arr)):
        current = arr[i]
        remaining = arr[:i] + arr[i+1:]
        for p in ordered_combinations(remaining):
            perms.append([current] + p)
    return perms",O(n!)
"def all_permutations(items):
    if len(items) <= 1:
        yield items
    else:
        for perm in all_permutations(items[1:]):
            for i in range(len(perm) + 1):
                yield perm[:i] + items[0:1] + perm[i:]",O(n!)
"def generate_permutations(arr):
    if len(arr) == 0:
        return [[]]
    result = []
    for i in range(len(arr)):
        rest = arr[:i] + arr[i+1:]
        for p in generate_permutations(rest):
            result.append([arr[i]] + p)
    return result
",O(n!)
"import itertools

def all_permutations(n):
    items = list(range(n))
    return list(itertools.permutations(items))
",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, nums, path):
        if not nums:
            self.result.append(path[:])
            return
        for i in range(len(nums)):
            self.generate(nums[:i] + nums[i+1:], path + [nums[i]])
    
    def get_permutations(self, n):
        self.result = []
        self.generate(list(range(n)), [])
        return self.result
",O(n!)
"def heap_permutation(n):
    def generate(k, arr):
        if k == 1:
            yield arr[:]
        else:
            for i in range(k):
                yield from generate(k - 1, arr)
                if k % 2 == 0:
                    arr[i], arr[k-1] = arr[k-1], arr[i]
                else:
                    arr[0], arr[k-1] = arr[k-1], arr[0]
    return list(generate(n, list(range(n))))
",O(n!)
"def permute_string(s):
    if len(s) == 1:
        return [s]
    permutations = []
    for i, char in enumerate(s):
        remaining = s[:i] + s[i+1:]
        for perm in permute_string(remaining):
            permutations.append(char + perm)
    return permutations
",O(n!)
"def traveling_salesman(n):
    from itertools import permutations
    graph = [[0 if i == j else 1 for j in range(n)] for i in range(n)]
    min_cost = float('inf')
    for path in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += graph[path[i]][path[(i+1)%n]]
        min_cost = min(min_cost, cost)
    return min_cost
",O(n!)
"def generate_anagrams(word):
    if len(word) <= 1:
        return [word]
    anagrams = []
    for i in range(len(word)):
        for ana in generate_anagrams(word[:i] + word[i+1:]):
            anagrams.append(word[i] + ana)
    return anagrams
",O(n!)
"def all_arrangements(items):
    if len(items) == 0:
        yield []
    for i in range(len(items)):
        for arr in all_arrangements(items[:i] + items[i+1:]):
            yield [items[i]] + arr
",O(n!)
"def generate_permutations(arr):
    if len(arr) <= 1:
        return [arr]
    result = []
    for i in range(len(arr)):
        remaining = arr[:i] + arr[i+1:]
        for p in generate_permutations(remaining):
            result.append([arr[i]] + p)
    return result",O(n!)
"def all_permutations(seq):
    if len(seq) == 0:
        return [[]]
    perms = []
    for i in range(len(seq)):
        rest = seq[:i] + seq[i+1:]
        for p in all_permutations(rest):
            perms.append([seq[i]] + p)
    return perms",O(n!)
"def get_permutations(elements):
    from itertools import permutations
    return list(permutations(elements))",O(n!)
"def heap_permutation(n, arr):
    if n == 1:
        return [arr[:]]
    res = []
    for i in range(n):
        res.extend(heap_permutation(n-1, arr))
        if n % 2 == 1:
            arr[0], arr[n-1] = arr[n-1], arr[0]
        else:
            arr[i], arr[n-1] = arr[n-1], arr[i]
    return res",O(n!)
"def permute_string(s):
    if len(s) == 1:
        return [s]
    permutations = []
    for i, char in enumerate(s):
        remaining = s[:i] + s[i+1:]
        for perm in permute_string(remaining):
            permutations.append(char + perm)
    return permutations",O(n!)
"def ordered_combinations(n):
    if n == 0:
        return [[]]
    smaller = ordered_combinations(n-1)
    result = []
    for seq in smaller:
        for i in range(len(seq)+1):
            new_seq = seq[:i] + [n] + seq[i:]
            result.append(new_seq)
    return result",O(n!)
"def factorial_traversal(n, path=None):
    if path is None:
        path = []
    if len(path) == n:
        return 1
    total = 0
    for i in range(n):
        if i not in path:
            path.append(i)
            total += factorial_traversal(n, path)
            path.pop()
    return total",O(n!)
"def generate_ordered_sets(n):
    if n == 0:
        return [[]]
    smaller = generate_ordered_sets(n - 1)
    result = []
    for s in smaller:
        for i in range(len(s) + 1):
            result.append(s[:i] + [n-1] + s[i:])
    return result",O(n!)
"def factorial_complexity(n, current=[]):
    if len(current) == n:
        return 1
    count = 0
    for i in range(n):
        if i not in current:
            count += factorial_complexity(n, current + [i])
    return count",O(n!)
"def permute_unique(nums):
    def backtrack(path, used):
        if len(path) == len(nums):
            results.append(path[:])
            return
        for i in range(len(nums)):
            if used[i]:
                continue
            used[i] = True
            path.append(nums[i])
            backtrack(path, used)
            path.pop()
            used[i] = False
    results = []
    used = [False] * len(nums)
    backtrack([], used)
    return results",O(n!)
"def generate_sequences(n, seq=[]):
    if len(seq) == n:
        return [seq]
    sequences = []
    for i in range(n):
        if i not in seq:
            sequences.extend(generate_sequences(n, seq + [i]))
    return sequences",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    def generate(self, items, start=0):
        if start == len(items):
            self.result.append(items[:])
        for i in range(start, len(items)):
            items[start], items[i] = items[i], items[start]
            self.generate(items, start + 1)
            items[start], items[i] = items[i], items[start]",O(n!)
"def heap_permutation(data, n):
    if n == 1:
        yield data
    else:
        for i in range(n):
            yield from heap_permutation(data, n - 1)
            if n % 2 == 0:
                data[i], data[n-1] = data[n-1], data[i]
            else:
                data[0], data[n-1] = data[n-1], data[0]",O(n!)
"def count_arrangements(n, arranged=[]):
    if len(arranged) == n:
        return 1
    total = 0
    for candidate in range(n):
        if candidate not in arranged:
            total += count_arrangements(n, arranged + [candidate])
    return total",O(n!)
"def traveling_salesman(graph, path, visited, cost):
    if len(path) == len(graph):
        return cost + graph[path[-1]][path[0]]
    min_cost = float('inf')
    for next_city in range(len(graph)):
        if not visited[next_city]:
            visited[next_city] = True
            path.append(next_city)
            new_cost = traveling_salesman(graph, path, visited, cost + graph[path[-2]][next_city])
            min_cost = min(min_cost, new_cost)
            path.pop()
            visited[next_city] = False
    return min_cost",O(n!)
"def count_derangements(n):
    if n == 0:
        return 1
    if n == 1:
        return 0
    return (n - 1) * (count_derangements(n - 1) + count_derangements(n - 2))",O(n!)
"def generate_arrangements(items, arrangement=[]):
    if not items:
        yield arrangement
    for i in range(len(items)):
        yield from generate_arrangements(items[:i] + items[i+1:], arrangement + [items[i]])",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, nums, start=0):
        if start == len(nums):
            self.result.append(nums[:])
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            self.generate(nums, start + 1)
            nums[start], nums[i] = nums[i], nums[start]",O(n!)
"def brute_force_tsp(distances):
    from itertools import permutations
    n = len(distances)
    min_path = float('inf')
    for perm in permutations(range(n)):
        current_path = 0
        for i in range(n):
            current_path += distances[perm[i]][perm[(i + 1) % n]]
        min_path = min(min_path, current_path)
    return min_path",O(n!)
"def all_permutations(seq):
    if len(seq) <= 1:
        return [seq]
    perms = []
    for i in range(len(seq)):
        remaining = seq[:i] + seq[i+1:]
        for p in all_permutations(remaining):
            perms.append([seq[i]] + p)
    return perms",O(n!)
"def permutation_generator(items):
    if len(items) == 0:
        yield []
    else:
        for i in range(len(items)):
            for perm in permutation_generator(items[:i] + items[i+1:]):
                yield [items[i]] + perm",O(n!)
"def factorial_complexity(n, prefix=[]):
    if n == 0:
        print(prefix)
    else:
        for i in range(n):
            factorial_complexity(n - 1, prefix + [i])",O(n!)
"class PermutationBuilder:
    def __init__(self):
        self.result = []
    
    def build(self, arr, current=[]):
        if not arr:
            self.result.append(current)
            return
        for i in range(len(arr)):
            self.build(arr[:i] + arr[i+1:], current + [arr[i]])",O(n!)
"def permute_unique(elements):
    if len(elements) == 0:
        return [[]]
    permutations = []
    seen = set()
    for i in range(len(elements)):
        if elements[i] not in seen:
            seen.add(elements[i])
            remaining = elements[:i] + elements[i+1:]
            for p in permute_unique(remaining):
                permutations.append([elements[i]] + p)
    return permutations",O(n!)
"def generate_sequences(n, current=[]):
    if len(current) == n:
        return [current]
    sequences = []
    for i in range(n):
        if i not in current:
            sequences.extend(generate_sequences(n, current + [i]))
    return sequences",O(n!)
"def factorial_complexity(n, prefix=[]):
    if n == 0:
        print(prefix)
        return
    for i in range(n):
        factorial_complexity(n - 1, prefix + [i])",O(n!)
"def all_permutations(data):
    if len(data) <= 1:
        return [data]
    perms = []
    for i, elem in enumerate(data):
        remaining = data[:i] + data[i+1:]
        for perm in all_permutations(remaining):
            perms.append([elem] + perm)
    return perms",O(n!)
"def heap_permutation(n, A):
    if n == 1:
        yield A.copy()
    else:
        for i in range(n):
            yield from heap_permutation(n - 1, A)
            if n % 2 == 0:
                A[i], A[n-1] = A[n-1], A[i]
            else:
                A[0], A[n-1] = A[n-1], A[0]",O(n!)
"class PermutationGenerator:
    def __init__(self, n):
        self.n = n
    def generate(self):
        def backtrack(path):
            if len(path) == self.n:
                yield path[:]
                return
            for i in range(self.n):
                if i not in path:
                    path.append(i)
                    yield from backtrack(path)
                    path.pop()
        return list(backtrack([]))",O(n!)
"def permute_unique(elements):
    if len(elements) == 0:
        return [[]]
    perms = set()
    for i in range(len(elements)):
        for p in permute_unique(elements[:i] + elements[i+1:]):
            perms.add(tuple([elements[i]] + p))
    return [list(p) for p in perms]",O(n!)
"def ordered_combinations(n):
    if n == 0:
        return [[]]
    smaller = ordered_combinations(n - 1)
    result = []
    for seq in smaller:
        for pos in range(len(seq) + 1):
            new_seq = seq[:pos] + [n-1] + seq[pos:]
            result.append(new_seq)
    return result",O(n!)
"def all_permutations(sequence):
    if len(sequence) <= 1:
        yield sequence
    else:
        for perm in all_permutations(sequence[1:]):
            for i in range(len(perm) + 1):
                yield perm[:i] + sequence[0:1] + perm[i:]",O(n!)
"class PermutationGenerator:
    def __init__(self, items):
        self.items = items
        self.n = len(items)
    def generate(self):
        if self.n == 0:
            return [[]]
        perms = []
        for i in range(self.n):
            remaining = self.items[:i] + self.items[i+1:]
            for p in PermutationGenerator(remaining).generate():
                perms.append([self.items[i]] + p)
        return perms",O(n!)
"def heap_permutation(n, A):
    if n == 1:
        print(A)
        return
    for i in range(n):
        heap_permutation(n - 1, A)
        if n % 2 == 0:
            A[i], A[n-1] = A[n-1], A[i]
        else:
            A[0], A[n-1] = A[n-1], A[0]",O(n!)
"def permute(data, i, length):
    if i == length:
        print(''.join(data))
    else:
        for j in range(i, length):
            data[i], data[j] = data[j], data[i]
            permute(data, i + 1, length)
            data[i], data[j] = data[j], data[i]",O(n!)
"def traveling_salesman(graph, n):
    from itertools import permutations
    vertices = list(range(n))
    min_path = float('inf')
    for perm in permutations(vertices):
        current_path = 0
        for i in range(n):
            current_path += graph[perm[i]][perm[(i + 1) % n]]
        min_path = min(min_path, current_path)
    return min_path",O(n!)
"def factorial_complexity(n):
    def dfs(path, used):
        if len(path) == n:
            return 1
        count = 0
        for i in range(n):
            if not used[i]:
                used[i] = True
                count += dfs(path + [i], used)
                used[i] = False
        return count
    return dfs([], [False] * n)",O(n!)
"def permute_unique(nums):
    res = []
    def backtrack(start):
        if start == len(nums):
            res.append(nums[:])
            return
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]
    backtrack(0)
    return res",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, items):
        self._permute(items, 0)
        return self.result
    
    def _permute(self, arr, idx):
        if idx == len(arr):
            self.result.append(arr[:])
            return
        for j in range(idx, len(arr)):
            arr[idx], arr[j] = arr[j], arr[idx]
            self._permute(arr, idx + 1)
            arr[idx], arr[j] = arr[j], arr[idx]",O(n!)
"def get_all_orders(elems):
    if not elems:
        return [[]]
    permutations = []
    for i, val in enumerate(elems):
        remaining = elems[:i] + elems[i+1:]
        for p in get_all_orders(remaining):
            permutations.append([val] + p)
    return permutations",O(n!)
"def count_arrangements(n):
    if n == 0:
        return 1
    total = 0
    for i in range(n):
        total += count_arrangements(n - 1)
    return total",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.results = []
    
    def generate(self, items, path=[]):
        if not items:
            self.results.append(path)
            return
        for i in range(len(items)):
            self.generate(items[:i] + items[i+1:], path + [items[i]])",O(n!)
"def heap_permutation(n, A):
    if n == 1:
        print(A)
        return
    for i in range(n):
        heap_permutation(n-1, A)
        if n % 2 == 0:
            A[i], A[n-1] = A[n-1], A[i]
        else:
            A[0], A[n-1] = A[n-1], A[0]",O(n!)
"def count_arrangements(n, used=None):
    if used is None:
        used = [False] * n
    if all(used):
        return 1
    total = 0
    for i in range(n):
        if not used[i]:
            used[i] = True
            total += count_arrangements(n, used)
            used[i] = False
    return total",O(n!)
"def factorial_complexity(n):
    def backtrack(path, choices):
        if len(path) == n:
            return [path[:]]
        res = []
        for i in range(len(choices)):
            path.append(choices[i])
            new_choices = choices[:i] + choices[i+1:]
            res.extend(backtrack(path, new_choices))
            path.pop()
        return res
    return backtrack([], list(range(n)))",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, nums):
        self.backtrack(nums, [])
        return self.result
    
    def backtrack(self, nums, path):
        if not nums:
            self.result.append(path)
            return
        for i in range(len(nums)):
            self.backtrack(nums[:i] + nums[i+1:], path + [nums[i]])",O(n!)
"def heap_permutation(n):
    arr = list(range(n))
    result = []
    def generate(k):
        if k == 1:
            result.append(arr[:])
            return
        for i in range(k):
            generate(k-1)
            if k % 2 == 0:
                arr[i], arr[k-1] = arr[k-1], arr[i]
            else:
                arr[0], arr[k-1] = arr[k-1], arr[0]
    generate(n)
    return result",O(n!)
"def permutation_sequence(n):
    if n == 0:
        return [[]]
    smaller = permutation_sequence(n-1)
    result = []
    for perm in smaller:
        for i in range(len(perm)+1):
            result.append(perm[:i] + [n-1] + perm[i:])
    return result",O(n!)
"class Permuter:
    def __init__(self):
        self.result = []
    def generate(self, items, k=None):
        if k is None:
            k = len(items)
        if k == 0:
            self.result.append([])
            return
        self.generate(items, k-1)
        new_result = []
        for perm in self.result:
            for i in range(len(perm)+1):
                new_perm = perm[:i] + [items[k-1]] + perm[i:]
                new_result.append(new_perm)
        self.result = new_result
    def get_all(self):
        return self.result",O(n!)
"def ordered_combinations(elements):
    if not elements:
        return [[]]
    first = elements[0]
    rest = elements[1:]
    combs_without = ordered_combinations(rest)
    combs_with = []
    for comb in combs_without:
        for i in range(len(comb)+1):
            new_comb = comb[:i] + [first] + comb[i:]
            combs_with.append(new_comb)
    return combs_without + combs_with",O(n!)
"def brute_force_tsp(distances):
    from itertools import permutations
    n = len(distances)
    min_cost = float('inf')
    for perm in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += distances[perm[i-1]][perm[i]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def factorial_permute(elements):
    if len(elements) <= 1:
        yield elements
    else:
        for perm in factorial_permute(elements[1:]):
            for i in range(len(elements)):
                yield perm[:i] + [elements[0]] + perm[i:]",O(n!)
"def all_permutations(lst):
    from itertools import permutations
    return list(permutations(lst))",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.results = []
    def generate(self, current, remaining):
        if len(remaining) == 0:
            self.results.append(current[:])
            return
        for i in range(len(remaining)):
            current.append(remaining[i])
            self.generate(current, remaining[:i] + remaining[i+1:])
            current.pop()
    def get_permutations(self, items):
        self.results = []
        self.generate([], items)
        return self.results",O(n!)
"def permute_unique(nums):
    def backtrack(path, counter):
        if len(path) == len(nums):
            output.append(path[:])
            return
        for num in counter:
            if counter[num] > 0:
                path.append(num)
                counter[num] -= 1
                backtrack(path, counter)
                path.pop()
                counter[num] += 1
    output = []
    from collections import Counter
    backtrack([], Counter(nums))
    return output",O(n!)
"def generate_anagrams(s):
    if len(s) == 1:
        return [s]
    perms = []
    for i, char in enumerate(s):
        for perm in generate_anagrams(s[:i] + s[i+1:]):
            perms.append(char + perm)
    return perms",O(n!)
"def iterative_permutations(arr):
    stack = [([], arr)]
    result = []
    while stack:
        current, remaining = stack.pop()
        if not remaining:
            result.append(current)
        else:
            for i in range(len(remaining)):
                stack.append((current + [remaining[i]], remaining[:i] + remaining[i+1:]))
    return result",O(n!)
"def permute_unique(elements):
    if not elements:
        return [[]]
    perms = []
    for i, elem in enumerate(elements):
        remaining = elements[:i] + elements[i+1:]
        for perm in permute_unique(remaining):
            perms.append([elem] + perm)
    return perms",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, arr, start=0):
        if start == len(arr):
            self.result.append(arr[:])
            return
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self.generate(arr, start+1)
            arr[start], arr[i] = arr[i], arr[start]
    
    def get_permutations(self, arr):
        self.result = []
        self.generate(arr)
        return self.result",O(n!)
"def heap_permutation(n, arr):
    if n == 1:
        yield arr[:]
    else:
        for i in range(n):
            yield from heap_permutation(n-1, arr)
            if n % 2 == 0:
                arr[i], arr[n-1] = arr[n-1], arr[i]
            else:
                arr[0], arr[n-1] = arr[n-1], arr[0]",O(n!)
"def permute_unique(nums):
    res = []
    def backtrack(path, counter):
        if len(path) == len(nums):
            res.append(path[:])
            return
        for num in counter:
            if counter[num] > 0:
                path.append(num)
                counter[num] -= 1
                backtrack(path, counter)
                path.pop()
                counter[num] += 1
    from collections import Counter
    backtrack([], Counter(nums))
    return res",O(n!)
"def derangement(n):
    if n == 0:
        return 1
    if n == 1:
        return 0
    return (n - 1) * (derangement(n - 1) + derangement(n - 2))",O(n!)
"def permute_unique(elements):
    if len(elements) == 0:
        yield []
    for idx, el in enumerate(elements):
        remaining = elements[:idx] + elements[idx+1:]
        for perm in permute_unique(remaining):
            yield [el] + perm",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, items, current=[]):
        if not items:
            self.result.append(current[:])
            return
        for i in range(len(items)):
            self.generate(items[:i] + items[i+1:], current + [items[i]])",O(n!)
"def traveling_salesman(graph, n, path=[], visited=None):
    if visited is None:
        visited = [False] * n
    if len(path) == n:
        return [path[:]]
    results = []
    for city in range(n):
        if not visited[city]:
            visited[city] = True
            path.append(city)
            results.extend(traveling_salesman(graph, n, path, visited))
            path.pop()
            visited[city] = False
    return results",O(n!)
"def generate_sequences(n, current=[]):
    if len(current) == n:
        return [current[:]]
    sequences = []
    for i in range(n):
        if i not in current:
            sequences.extend(generate_sequences(n, current + [i]))
    return sequences",O(n!)
"def all_arrangements(items):
    if len(items) == 0:
        return [[]]
    return [[items[i]] + p for i in range(len(items)) for p in all_arrangements(items[:i] + items[i+1:])]",O(n!)
"def permutation_swap(arr, l, r):
    if l == r:
        print(arr)
    else:
        for i in range(l, r + 1):
            arr[l], arr[i] = arr[i], arr[l]
            permutation_swap(arr, l + 1, r)
            arr[l], arr[i] = arr[i], arr[l]",O(n!)
"def traveling_salesman(graph, path, visited, cost, n):
    if len(path) == n:
        return cost + graph[path[-1]][path[0]]
    min_cost = float('inf')
    for next_city in range(n):
        if not visited[next_city]:
            visited[next_city] = True
            path.append(next_city)
            new_cost = cost + graph[path[-2]][next_city]
            min_cost = min(min_cost, traveling_salesman(graph, path, visited, new_cost, n))
            path.pop()
            visited[next_city] = False
    return min_cost",O(n!)
"def generate_sequences(n, current=[]):
    if len(current) == n:
        print(current)
        return
    for i in range(n):
        if i not in current:
            generate_sequences(n, current + [i])",O(n!)
"def all_arrangements(items):
    if not items:
        return [[]]
    arrangements = []
    for i in range(len(items)):
        first = items[i]
        remaining = items[:i] + items[i+1:]
        for arr in all_arrangements(remaining):
            arrangements.append([first] + arr)
    return arrangements",O(n!)
"def permute(nums):
    from itertools import permutations
    return list(permutations(nums))",O(n!)
"def all_permutations(seq):
    if len(seq) <= 1:
        yield seq
    else:
        for perm in all_permutations(seq[1:]):
            for i in range(len(seq)):
                yield perm[:i] + [seq[0]] + perm[i:]",O(n!)
"def factorial_complexity(n):
    results = []
    def backtrack(path, choices):
        if len(choices) == 0:
            results.append(path[:])
            return
        for i in range(len(choices)):
            path.append(choices[i])
            backtrack(path, choices[:i] + choices[i+1:])
            path.pop()
    backtrack([], list(range(n)))
    return results",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    def generate(self, items):
        self._permute(items, 0)
        return self.result
    def _permute(self, arr, start):
        if start >= len(arr):
            self.result.append(arr[:])
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self._permute(arr, start + 1)
            arr[start], arr[i] = arr[i], arr[start]",O(n!)
"def heap_permute(n):
    A = list(range(n))
    def generate(k):
        if k == 1:
            yield A[:]
        else:
            for i in range(k):
                yield from generate(k - 1)
                if k % 2 == 0:
                    A[i], A[k-1] = A[k-1], A[i]
                else:
                    A[0], A[k-1] = A[k-1], A[0]
    return list(generate(n))",O(n!)
"def all_permutations(lst):
    if len(lst) <= 1:
        return [lst]
    perms = []
    for i in range(len(lst)):
        m = lst[i]
        rem = lst[:i] + lst[i+1:]
        for p in all_permutations(rem):
            perms.append([m] + p)
    return perms",O(n!)
"def factorial_complexity(n):
    def backtrack(path, choices):
        if len(path) == n:
            return 1
        total = 0
        for i in range(len(choices)):
            total += backtrack(path + [choices[i]], choices[:i] + choices[i+1:])
        return total
    return backtrack([], list(range(n)))",O(n!)
"def permute_string(s):
    if len(s) == 1:
        return [s]
    result = []
    for i, char in enumerate(s):
        remaining = s[:i] + s[i+1:]
        for perm in permute_string(remaining):
            result.append(char + perm)
    return result",O(n!)
"def heap_permutation(data, n):
    if n == 1:
        return [data[:]]
    result = []
    for i in range(n):
        result.extend(heap_permutation(data, n-1))
        if n % 2 == 0:
            data[i], data[n-1] = data[n-1], data[i]
        else:
            data[0], data[n-1] = data[n-1], data[0]
    return result",O(n!)
"def count_permutations(n):
    if n == 0:
        return 1
    count = 0
    for i in range(n):
        count += count_permutations(n-1)
    return count",O(n!)
"def generate_sequences(elements):
    if not elements:
        return [[]]
    sequences = []
    for i in range(len(elements)):
        current = elements[i]
        remaining = elements[:i] + elements[i+1:]
        for seq in generate_sequences(remaining):
            sequences.append([current] + seq)
    return sequences",O(n!)
"def all_permutations(elements):
    if len(elements) == 0:
        return [[]]
    perms = []
    for i in range(len(elements)):
        current = elements[i]
        remaining = elements[:i] + elements[i+1:]
        for perm in all_permutations(remaining):
            perms.append([current] + perm)
    return perms",O(n!)
"def factorial_complexity(n):
    def backtrack(path, choices):
        if len(choices) == 0:
            yield path
            return
        for i in range(len(choices)):
            yield from backtrack(path + [choices[i]], choices[:i] + choices[i+1:])
    return list(backtrack([], list(range(n))))",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    def generate(self, nums):
        self.backtrack(nums, [])
        return self.result
    def backtrack(self, nums, path):
        if not nums:
            self.result.append(path)
            return
        for i in range(len(nums)):
            self.backtrack(nums[:i] + nums[i+1:], path + [nums[i]])",O(n!)
"def get_permutations(sequence):
    if len(sequence) == 0:
        return [sequence]
    first_char = sequence[0]
    rest = sequence[1:]
    perms = get_permutations(rest)
    all_perms = []
    for perm in perms:
        for i in range(len(perm) + 1):
            new_perm = perm[:i] + first_char + perm[i:]
            all_perms.append(new_perm)
    return all_perms",O(n!)
"def permute_unique(elements):
    if not elements:
        return [[]]
    permutations = []
    for idx in range(len(elements)):
        first = elements[idx]
        rest = elements[:idx] + elements[idx+1:]
        for perm in permute_unique(rest):
            permutations.append([first] + perm)
    return permutations",O(n!)
"def ordered_permutations(sequence):
    if len(sequence) == 1:
        return [sequence]
    all_perms = []
    for i in range(len(sequence)):
        element = sequence[i]
        sub_sequence = sequence[:i] + sequence[i+1:]
        sub_perms = ordered_permutations(sub_sequence)
        for perm in sub_perms:
            all_perms.append([element] + perm)
    return all_perms",O(n!)
"def exhaustive_permute(items):
    n = len(items)
    if n == 0:
        return [[]]
    output = []
    for i in range(n):
        head = items[i]
        tail = items[:i] + items[i+1:]
        for p in exhaustive_permute(tail):
            output.append([head] + p)
    return output",O(n!)
"def recursive_permutations(arr):
    if len(arr) == 0:
        return [[]]
    perms = []
    for i in range(len(arr)):
        remaining = arr[0:i] + arr[i+1:]
        subperms = recursive_permutations(remaining)
        for sub in subperms:
            perms.append([arr[i]] + sub)
    return perms",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, nums, path=[]):
        if not nums:
            self.result.append(path[:])
            return
        for i in range(len(nums)):
            self.generate(nums[:i] + nums[i+1:], path + [nums[i]])",O(n!)
"def brute_force_tsp(distances):
    import itertools
    n = len(distances)
    min_cost = float('inf')
    for perm in itertools.permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += distances[perm[i]][perm[(i+1) % n]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def all_paths(nodes):
    if not nodes:
        return [[]]
    paths = []
    for i, node in enumerate(nodes):
        remaining = nodes[:i] + nodes[i+1:]
        for path in all_paths(remaining):
            paths.append([node] + path)
    return paths",O(n!)
"def factorial_complexity(data):
    if len(data) == 0:
        return []
    if len(data) == 1:
        return [data]
    output = []
    for idx in range(len(data)):
        elem = data[idx]
        rest = data[:idx] + data[idx+1:]
        for perm in factorial_complexity(rest):
            output.append([elem] + perm)
    return output",O(n!)
"def permute_items(items):
    n = len(items)
    if n <= 1:
        return [items]
    perms = []
    for i in range(n):
        first = items[i]
        remainder = items[:i] + items[i+1:]
        for p in permute_items(remainder):
            perms.append([first] + p)
    return perms",O(n!)
"def compute_permutations(elements):
    if len(elements) == 0:
        return [[]]
    permutations = []
    for i in range(len(elements)):
        current = elements[i]
        remaining = elements[:i] + elements[i+1:]
        sub_perms = compute_permutations(remaining)
        for perm in sub_perms:
            permutations.append([current] + perm)
    return permutations",O(n!)
"def generate_sequences(lst):
    if len(lst) == 0:
        return [[]]
    sequences = []
    for index in range(len(lst)):
        head = lst[index]
        tail = lst[:index] + lst[index+1:]
        for seq in generate_sequences(tail):
            sequences.append([head] + seq)
    return sequences",O(n!)
"def get_all_orders(arr):
    if not arr:
        return [[]]
    results = []
    for pos in range(len(arr)):
        pick = arr[pos]
        others = arr[:pos] + arr[pos+1:]
        for ordering in get_all_orders(others):
            results.append([pick] + ordering)
    return results",O(n!)
"def enumerate_permutations(input_list):
    n = len(input_list)
    if n == 0:
        return [[]]
    output = []
    for i in range(n):
        element = input_list[i]
        rest = input_list[:i] + input_list[i+1:]
        for perm in enumerate_permutations(rest):
            output.append([element] + perm)
    return output",O(n!)
"def get_permutations(lst):
    if len(lst) == 0:
        return []
    if len(lst) == 1:
        return [lst]
    l = []
    for i in range(len(lst)):
        m = lst[i]
        rem_lst = lst[:i] + lst[i+1:]
        for p in get_permutations(rem_lst):
            l.append([m] + p)
    return l",O(n!)
"import itertools
def all_permutations(n):
    items = list(range(1, n+1))
    return list(itertools.permutations(items))",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    def permute(self, nums, start=0):
        if start == len(nums):
            self.result.append(nums[:])
            return
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            self.permute(nums, start+1)
            nums[start], nums[i] = nums[i], nums[start]
    def get_permutations(self, n):
        nums = list(range(n))
        self.permute(nums)
        return self.result",O(n!)
"def heap_permutation(n):
    def generate(k, arr):
        if k == 1:
            yield arr[:]
        else:
            for i in range(k):
                yield from generate(k-1, arr)
                if k % 2 == 0:
                    arr[i], arr[k-1] = arr[k-1], arr[i]
                else:
                    arr[0], arr[k-1] = arr[k-1], arr[0]
    arr = list(range(n))
    return list(generate(n, arr))",O(n!)
"def traveling_salesman(n):
    from itertools import permutations
    graph = [[0] * n for _ in range(n)]
    min_cost = float('inf')
    for perm in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += graph[perm[i]][perm[(i+1)%n]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def generate_permutations(arr):
    if len(arr) == 1:
        return [arr]
    result = []
    for i in range(len(arr)):
        rest = arr[:i] + arr[i+1:]
        for p in generate_permutations(rest):
            result.append([arr[i]] + p)
    return result",O(n!)
"def generate_sequences(n, current=[]):
    if len(current) == n:
        return [current[:]]
    result = []
    for i in range(n):
        if i not in current:
            current.append(i)
            result.extend(generate_sequences(n, current))
            current.pop()
    return result",O(n!)
"def traveling_salesman(n, dist):
    from itertools import permutations
    min_cost = float('inf')
    for perm in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += dist[perm[i]][perm[(i+1)%n]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def generate_anagrams(s):
    if len(s) <= 1:
        return [s]
    result = []
    for i, char in enumerate(s):
        for perm in generate_anagrams(s[:i] + s[i+1:]):
            result.append(char + perm)
    return result",O(n!)
"def n_queens_permutations(n):
    def is_valid(board):
        for i in range(len(board)):
            for j in range(i+1, len(board)):
                if abs(board[i] - board[j]) == abs(i - j):
                    return False
        return True
    from itertools import permutations
    solutions = []
    for perm in permutations(range(n)):
        if is_valid(perm):
            solutions.append(perm)
    return solutions",O(n!)
"def recursive_permutation(arr, start=0):
    if start == len(arr):
        return [arr[:]]
    result = []
    for i in range(start, len(arr)):
        arr[start], arr[i] = arr[i], arr[start]
        result.extend(recursive_permutation(arr, start+1))
        arr[start], arr[i] = arr[i], arr[start]
    return result",O(n!)
"def generate_all_orders(tasks):
    if not tasks:
        return [[]]
    result = []
    for i in range(len(tasks)):
        rest = tasks[:i] + tasks[i+1:]
        for order in generate_all_orders(rest):
            result.append([tasks[i]] + order)
    return result",O(n!)
"def traveling_salesman(n, distances):
    from itertools import permutations
    min_cost = float('inf')
    for path in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += distances[path[i]][path[(i+1) % n]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def generate_anagrams(s):
    if len(s) == 0:
        return ['']
    result = []
    for i in range(len(s)):
        for ana in generate_anagrams(s[:i] + s[i+1:]):
            result.append(s[i] + ana)
    return result",O(n!)
"def job_assignment(n, cost_matrix):
    from itertools import permutations
    min_cost = float('inf')
    for assignment in permutations(range(n)):
        total = 0
        for i in range(n):
            total += cost_matrix[i][assignment[i]]
        min_cost = min(min_cost, total)
    return min_cost",O(n!)
"def permute_unique(nums):
    if len(nums) == 0:
        return [[]]
    used = [False] * len(nums)
    res = []
    def backtrack(path):
        if len(path) == len(nums):
            res.append(path[:])
            return
        for i in range(len(nums)):
            if used[i]:
                continue
            used[i] = True
            path.append(nums[i])
            backtrack(path)
            path.pop()
            used[i] = False
    backtrack([])
    return res",O(n!)
"def generate_anagrams(s):
    if len(s) == 1:
        return [s]
    result = []
    for i, char in enumerate(s):
        for ana in generate_anagrams(s[:i] + s[i+1:]):
            result.append(char + ana)
    return result",O(n!)
"def traveling_salesman(graph, start):
    from itertools import permutations
    nodes = list(graph.keys())
    nodes.remove(start)
    min_path = float('inf')
    for perm in permutations(nodes):
        current_path = 0
        k = start
        for node in perm:
            current_path += graph[k][node]
            k = node
        current_path += graph[k][start]
        min_path = min(min_path, current_path)
    return min_path",O(n!)
"def generate_sequences(n):
    if n == 0:
        return [[]]
    smaller = generate_sequences(n - 1)
    result = []
    for seq in smaller:
        for i in range(len(seq) + 1):
            new_seq = seq[:i] + [n] + seq[i:]
            result.append(new_seq)
    return result",O(n!)
"def derangements(n):
    if n == 0:
        return [[]]
    result = []
    for perm in derangements(n - 1):
        for i in range(len(perm)):
            new_perm = perm[:i] + [n] + perm[i:]
            if all(new_perm[j] != j+1 for j in range(len(new_perm))):
                result.append(new_perm)
    return result",O(n!)
"def hamiltonian_paths(graph, n):
    def backtrack(path):
        if len(path) == n:
            results.append(path[:])
            return
        for neighbor in graph[path[-1]]:
            if neighbor not in path:
                path.append(neighbor)
                backtrack(path)
                path.pop()
    results = []
    for start in range(n):
        backtrack([start])
    return results",O(n!)
"def all_permutations(items):
    if not items:
        yield []
    else:
        for i in range(len(items)):
            for perm in all_permutations(items[:i] + items[i+1:]):
                yield [items[i]] + perm",O(n!)
"def solve_tsp(distances):
    n = len(distances)
    min_cost = float('inf')
    def visit(path, visited, cost):
        nonlocal min_cost
        if len(path) == n:
            min_cost = min(min_cost, cost)
            return
        for next_city in range(n):
            if not visited[next_city]:
                visited[next_city] = True
                visit(path + [next_city], visited, cost + distances[path[-1]][next_city])
                visited[next_city] = False
    for start in range(n):
        visited = [False] * n
        visited[start] = True
        visit([start], visited, 0)
    return min_cost",O(n!)
"def generate_sequences(n):
    results = []
    def backtrack(seq):
        if len(seq) == n:
            results.append(seq[:])
            return
        for i in range(n):
            if i not in seq:
                seq.append(i)
                backtrack(seq)
                seq.pop()
    backtrack([])
    return results",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.results = []
    def generate(self, elements):
        if len(elements) == 0:
            self.results.append([])
        for i in range(len(elements)):
            remaining = elements[:i] + elements[i+1:]
            self.generate(remaining)
            for perm in self.results:
                if len(perm) == len(remaining):
                    perm.insert(0, elements[i])
        return self.results",O(n!)
"def all_permutations(elements):
    if len(elements) == 0:
        return [[]]
    permutations = []
    for i, el in enumerate(elements):
        remaining = elements[:i] + elements[i+1:]
        for perm in all_permutations(remaining):
            permutations.append([el] + perm)
    return permutations",O(n!)
"def permute(data):
    if len(data) == 0:
        yield []
    for idx, item in enumerate(data):
        for perm in permute(data[:idx] + data[idx+1:]):
            yield [item] + perm",O(n!)
"def get_all_orders(items):
    if len(items) == 0:
        return [[]]
    output = []
    for first_index in range(len(items)):
        first_item = items[first_index]
        rest_items = items[:first_index] + items[first_index+1:]
        for ordering in get_all_orders(rest_items):
            output.append([first_item] + ordering)
    return output",O(n!)
"def factorial_time_sequence(n):
    def backtrack(start, path):
        if len(path) == n:
            yield path[:]
        for num in range(1, n+1):
            if num not in path:
                path.append(num)
                yield from backtrack(start, path)
                path.pop()
    return list(backtrack(1, []))",O(n!)
"def permute_unique(nums):
    def backtrack(path, used):
        if len(path) == len(nums):
            output.append(path[:])
            return
        for i in range(len(nums)):
            if not used[i]:
                used[i] = True
                path.append(nums[i])
                backtrack(path, used)
                path.pop()
                used[i] = False
    output = []
    used = [False] * len(nums)
    backtrack([], used)
    return output",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    def generate(self, items, path=[]):
        if not items:
            self.result.append(path)
            return
        for i in range(len(items)):
            self.generate(items[:i] + items[i+1:], path + [items[i]])",O(n!)
"def heap_permutation(data, n):
    if n == 1:
        yield data[:]
    else:
        for i in range(n):
            yield from heap_permutation(data, n-1)
            if n % 2 == 0:
                data[i], data[n-1] = data[n-1], data[i]
            else:
                data[0], data[n-1] = data[n-1], data[0]",O(n!)
"def ordered_combinations(elements):
    if len(elements) == 0:
        return [[]]
    first = elements[0]
    rest = elements[1:]
    combs_without = ordered_combinations(rest)
    combs_with = []
    for comb in combs_without:
        for i in range(len(comb)+1):
            combs_with.append(comb[:i] + [first] + comb[i:])
    return combs_with",O(n!)
"def generate_sequences(n):
    if n == 0:
        return [[]]
    smaller = generate_sequences(n - 1)
    result = []
    for seq in smaller:
        for pos in range(len(seq) + 1):
            new_seq = seq[:pos] + [n] + seq[pos:]
            result.append(new_seq)
    return result",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.results = []
    def generate(self, arr, start=0):
        if start == len(arr):
            self.results.append(arr[:])
            return
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self.generate(arr, start + 1)
            arr[start], arr[i] = arr[i], arr[start]
    def get_permutations(self, arr):
        self.generate(arr)
        return self.results",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, current, remaining):
        if len(remaining) == 0:
            self.result.append(current[:])
            return
        for i in range(len(remaining)):
            current.append(remaining[i])
            self.generate(current, remaining[:i] + remaining[i+1:])
            current.pop()
    
    def get_permutations(self, arr):
        self.result = []
        self.generate([], arr)
        return self.result",O(n!)
"def factorial_permutations(n):
    if n == 0:
        return [[]]
    smaller = factorial_permutations(n - 1)
    result = []
    for perm in smaller:
        for i in range(len(perm) + 1):
            new_perm = perm[:i] + [n] + perm[i:]
            result.append(new_perm)
    return result",O(n!)
"def traveling_salesman(n, dist):
    from itertools import permutations
    min_cost = float('inf')
    for perm in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += dist[perm[i]][perm[(i + 1) % n]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def heap_permutation(n, arr=None):
    if arr is None:
        arr = list(range(n))
    if n == 1:
        return [arr[:]]
    result = []
    for i in range(n):
        result.extend(heap_permutation(n - 1, arr))
        if n % 2 == 0:
            arr[i], arr[n - 1] = arr[n - 1], arr[i]
        else:
            arr[0], arr[n - 1] = arr[n - 1], arr[0]
    return result",O(n!)
"def n_queens_count(n, board=[]):
    if len(board) == n:
        return 1
    count = 0
    for col in range(n):
        if all(abs(col - c) != len(board) - r for r, c in enumerate(board)):
            count += n_queens_count(n, board + [col])
    return count",O(n!)
"def traveling_salesman(n, dist):
    from itertools import permutations
    min_cost = float('inf')
    for path in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += dist[path[i-1]][path[i]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def generate_derangements(n, current=[]):
    if len(current) == n:
        return 1
    count = 0
    for i in range(n):
        if i != len(current) and i not in current:
            count += generate_derangements(n, current + [i])
    return count",O(n!)
"def permutation_sequence(n, k, current=[]):
    if len(current) == n:
        return current
    for i in range(n):
        if i not in current:
            result = permutation_sequence(n, k, current + [i])
            if result is not None:
                return result
    return None",O(n!)
"def factorial_complexity(n):
    def dfs(path, choices):
        if not choices:
            return [path]
        result = []
        for i in range(len(choices)):
            new_choices = choices[:i] + choices[i+1:]
            result.extend(dfs(path + [choices[i]], new_choices))
        return result
    return dfs([], list(range(n)))",O(n!)
"def all_permutations(items):
    if len(items) <= 1:
        yield items
    else:
        for perm in all_permutations(items[1:]):
            for i in range(len(items)):
                yield perm[:i] + [items[0]] + perm[i:]",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, current, remaining):
        if len(remaining) == 0:
            self.result.append(current[:])
            return
        for i in range(len(remaining)):
            current.append(remaining[i])
            self.generate(current, remaining[:i] + remaining[i+1:])
            current.pop()
    
    def get_permutations(self, n):
        self.result = []
        self.generate([], list(range(n)))
        return self.result",O(n!)
"def permutation_sequence(n):
    if n == 0:
        return [[]]
    smaller = permutation_sequence(n - 1)
    result = []
    for perm in smaller:
        for i in range(len(perm) + 1):
            result.append(perm[:i] + [n-1] + perm[i:])
    return result",O(n!)
"def iterative_permutations(n):
    elements = list(range(n))
    result = [elements[:]]
    c = [0] * n
    i = 0
    while i < n:
        if c[i] < i:
            if i % 2 == 0:
                elements[0], elements[i] = elements[i], elements[0]
            else:
                elements[c[i]], elements[i] = elements[i], elements[c[i]]
            result.append(elements[:])
            c[i] += 1
            i = 0
        else:
            c[i] = 0
            i += 1
    return result",O(n!)
"def heap_permutation(n, A):
    if n == 1:
        yield A[:]
    else:
        for i in range(n):
            yield from heap_permutation(n-1, A)
            if n % 2 == 0:
                A[i], A[n-1] = A[n-1], A[i]
            else:
                A[0], A[n-1] = A[n-1], A[0]",O(n!)
"def generate_anagrams(s):
    if len(s) == 1:
        return [s]
    anagrams = []
    for i, char in enumerate(s):
        remaining = s[:i] + s[i+1:]
        for perm in generate_anagrams(remaining):
            anagrams.append(char + perm)
    return anagrams",O(n!)
"def traveling_salesman(graph, path=[], cost=0):
    n = len(graph)
    if len(path) == n:
        return [(path[:], cost)]
    results = []
    for next_city in range(n):
        if next_city not in path:
            new_cost = cost + (graph[path[-1]][next_city] if path else 0)
            path.append(next_city)
            results.extend(traveling_salesman(graph, path, new_cost))
            path.pop()
    return results",O(n!)
"def generate_sequences(n, seq=[]):
    if len(seq) == n:
        return [seq[:]]
    sequences = []
    for i in range(1, n+1):
        if i not in seq:
            seq.append(i)
            sequences.extend(generate_sequences(n, seq))
            seq.pop()
    return sequences",O(n!)
"def factorial_complexity(n):
    if n <= 1:
        return 1
    total = 0
    for i in range(n):
        total += factorial_complexity(n - 1)
    return total",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, arr, start=0):
        if start == len(arr):
            self.result.append(arr[:])
            return
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self.generate(arr, start + 1)
            arr[start], arr[i] = arr[i], arr[start]
    
    def get_permutations(self, arr):
        self.generate(arr)
        return self.result",O(n!)
"def generate_derangements(n, current=None, used=None):
    if current is None:
        current = []
        used = [False] * n
    if len(current) == n:
        return [current[:]]
    result = []
    for i in range(n):
        if not used[i] and i != len(current):
            used[i] = True
            current.append(i)
            result.extend(generate_derangements(n, current, used))
            current.pop()
            used[i] = False
    return result",O(n!)
"def all_permutations(elements):
    if len(elements) <= 1:
        yield elements
    else:
        for perm in all_permutations(elements[1:]):
            for i in range(len(elements)):
                yield perm[:i] + [elements[0]] + perm[i:]",O(n!)
"def solve_tsp(graph):
    n = len(graph)
    min_cost = float('inf')
    def dfs(path, visited, cost):
        nonlocal min_cost
        if len(path) == n:
            min_cost = min(min_cost, cost + graph[path[-1]][path[0]])
            return
        for next_city in range(n):
            if next_city not in visited:
                dfs(path + [next_city], visited | {next_city}, cost + graph[path[-1]][next_city])
    for start in range(n):
        dfs([start], {start}, 0)
    return min_cost",O(n!)
"def generate_anagrams(s):
    if len(s) == 0:
        return [s]
    anagrams = []
    for i in range(len(s)):
        for ana in generate_anagrams(s[:i] + s[i+1:]):
            anagrams.append(s[i] + ana)
    return anagrams",O(n!)
"def brute_force_assignment(cost_matrix):
    n = len(cost_matrix)
    min_cost = float('inf')
    from itertools import permutations
    for assignment in permutations(range(n)):
        total = 0
        for i in range(n):
            total += cost_matrix[i][assignment[i]]
        min_cost = min(min_cost, total)
    return min_cost",O(n!)
"def string_permutations(s, current=''):
    if len(s) == 0:
        return [current]
    perms = []
    for i in range(len(s)):
        perms.extend(string_permutations(s[:i] + s[i+1:], current + s[i]))
    return perms",O(n!)
"def factorial_permute(nums):
    from itertools import permutations
    return list(permutations(nums))",O(n!)
"def derangements(arr, idx=0):
    if idx == len(arr):
        return [[]]
    result = []
    for i in range(idx, len(arr)):
        if arr[i] != idx:
            arr[i], arr[idx] = arr[idx], arr[i]
            for d in derangements(arr, idx+1):
                result.append([arr[idx]] + d)
            arr[i], arr[idx] = arr[idx], arr[i]
    return result",O(n!)
"def generate_permutations(arr):
    if len(arr) == 0:
        return [[]]
    perms = []
    for i in range(len(arr)):
        rest = arr[:i] + arr[i+1:]
        for p in generate_permutations(rest):
            perms.append([arr[i]] + p)
    return perms",O(n!)
"def factorial_permute(n):
    def backtrack(path, used):
        if len(path) == n:
            result.append(path[:])
            return
        for i in range(n):
            if not used[i]:
                used[i] = True
                path.append(i)
                backtrack(path, used)
                path.pop()
                used[i] = False
    result = []
    backtrack([], [False] * n)
    return result",O(n!)
"def all_permutations(seq):
    if len(seq) <= 1:
        yield seq
    else:
        for perm in all_permutations(seq[1:]):
            for i in range(len(seq)):
                yield perm[:i] + seq[0:1] + perm[i:]",O(n!)
"def permute_list(items):
    if len(items) == 0:
        return []
    if len(items) == 1:
        return [items]
    l = []
    for i in range(len(items)):
        m = items[i]
        rem = items[:i] + items[i+1:]
        for p in permute_list(rem):
            l.append([m] + p)
    return l",O(n!)
"class PermutationGenerator:
    def __init__(self, n):
        self.n = n
        self.result = []
    def generate(self, current=[]):
        if len(current) == self.n:
            self.result.append(current.copy())
            return
        for num in range(self.n):
            if num not in current:
                current.append(num)
                self.generate(current)
                current.pop()
    def get_permutations(self):
        self.generate()
        return self.result",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.results = []
    def generate(self, items, current=[]):
        if not items:
            self.results.append(current[:])
            return
        for i in range(len(items)):
            self.generate(items[:i] + items[i+1:], current + [items[i]])",O(n!)
"def heap_permutation(arr, size):
    if size == 1:
        print(arr)
        return
    for i in range(size):
        heap_permutation(arr, size-1)
        if size % 2 == 1:
            arr[0], arr[size-1] = arr[size-1], arr[0]
        else:
            arr[i], arr[size-1] = arr[size-1], arr[i]",O(n!)
"def permute_string(s, prefix=""""):
    n = len(s)
    if n == 0:
        print(prefix)
    else:
        for i in range(n):
            permute_string(s[:i] + s[i+1:], prefix + s[i])",O(n!)
"def traveling_salesman_brute(graph):
    from itertools import permutations
    n = len(graph)
    min_cost = float('inf')
    for perm in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += graph[perm[i]][perm[(i+1)%n]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def generate_sequences(n):
    if n == 0:
        return [[]]
    smaller = generate_sequences(n-1)
    result = []
    for seq in smaller:
        for i in range(len(seq)+1):
            new_seq = seq[:i] + [n-1] + seq[i:]
            result.append(new_seq)
    return result",O(n!)
"def all_arrangements(elements):
    if len(elements) <= 1:
        return [elements]
    perms = []
    for i in range(len(elements)):
        first = elements[i]
        remaining = elements[:i] + elements[i+1:]
        for p in all_arrangements(remaining):
            perms.append([first] + p)
    return perms",O(n!)
"def n_queens_permutation(n):
    def is_valid(board):
        for i in range(len(board)):
            for j in range(i+1, len(board)):
                if abs(board[i] - board[j]) == abs(i - j):
                    return False
        return True
    from itertools import permutations
    count = 0
    for perm in permutations(range(n)):
        if is_valid(perm):
            count += 1
    return count",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, arr, start=0):
        if start == len(arr):
            self.result.append(arr[:])
            return
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self.generate(arr, start + 1)
            arr[start], arr[i] = arr[i], arr[start]",O(n!)
"def traveling_salesman_naive(graph, start=0):
    import itertools
    n = len(graph)
    min_cost = float('inf')
    for perm in itertools.permutations(range(n)):
        if perm[0] != start:
            continue
        cost = 0
        for i in range(n):
            cost += graph[perm[i]][perm[(i + 1) % n]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def generate_derangements(n):
    if n == 0:
        return [[]]
    result = []
    for i in range(n):
        for der in generate_derangements(n - 1):
            new_der = [i] + [x if x < i else x + 1 for x in der]
            if new_der[0] != 0:
                result.append(new_der)
    return result",O(n!)
"def count_permutations(n):
    if n <= 1:
        return 1
    count = 0
    for i in range(n):
        count += count_permutations(n - 1)
    return count",O(n!)
"def all_arrangements(items):
    if not items:
        yield []
        return
    for i in range(len(items)):
        for rest in all_arrangements(items[:i] + items[i+1:]):
            yield [items[i]] + rest",O(n!)
"def factorial_complexity(n, prefix=[]):
    if n == 0:
        print(prefix)
        return
    for i in range(n):
        factorial_complexity(n-1, prefix + [i])",O(n!)
"def traveling_salesman(graph, path, visited, cost, n):
    if len(path) == n:
        return cost + graph[path[-1]][path[0]]
    min_cost = float('inf')
    for next_city in range(n):
        if next_city not in visited:
            visited.add(next_city)
            path.append(next_city)
            new_cost = cost + graph[path[-2]][next_city] if len(path) > 1 else 0
            min_cost = min(min_cost, traveling_salesman(graph, path, visited, new_cost, n))
            path.pop()
            visited.remove(next_city)
    return min_cost",O(n!)
"def generate_derangements(arr, idx=0):
    if idx == len(arr):
        return [arr[:]]
    result = []
    for i in range(idx, len(arr)):
        if arr[i] != idx:
            arr[idx], arr[i] = arr[i], arr[idx]
            result.extend(generate_derangements(arr, idx+1))
            arr[idx], arr[i] = arr[i], arr[idx]
    return result",O(n!)
"def all_topological_sorts(graph, visited, path, result, n):
    if len(path) == n:
        result.append(path[:])
        return
    for v in range(n):
        if not visited[v] and all(visited[u] for u in graph[v]):
            visited[v] = True
            path.append(v)
            all_topological_sorts(graph, visited, path, result, n)
            path.pop()
            visited[v] = False",O(n!)
"def factorial_complexity(n):
    result = []
    def backtrack(current, remaining):
        if len(remaining) == 0:
            result.append(current[:])
            return
        for i in range(len(remaining)):
            current.append(remaining[i])
            backtrack(current, remaining[:i] + remaining[i+1:])
            current.pop()
    backtrack([], list(range(n)))
    return result",O(n!)
"def permute_unique(nums):
    res = []
    def dfs(path, counter):
        if len(path) == len(nums):
            res.append(path[:])
            return
        for num in counter:
            if counter[num] > 0:
                path.append(num)
                counter[num] -= 1
                dfs(path, counter)
                path.pop()
                counter[num] += 1
    from collections import Counter
    dfs([], Counter(nums))
    return res",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.result = []
    
    def generate(self, arr):
        self._helper(arr, 0)
        return self.result
    
    def _helper(self, arr, start):
        if start >= len(arr):
            self.result.append(arr[:])
            return
        for i in range(start, len(arr)):
            arr[start], arr[i] = arr[i], arr[start]
            self._helper(arr, start + 1)
            arr[start], arr[i] = arr[i], arr[start]",O(n!)
"def generate_anagrams(s):
    if len(s) == 1:
        return [s]
    permutations = []
    for i, char in enumerate(s):
        for perm in generate_anagrams(s[:i] + s[i+1:]):
            permutations.append(char + perm)
    return permutations",O(n!)
"def traveling_salesman(graph, start):
    from itertools import permutations
    n = len(graph)
    min_cost = float('inf')
    for perm in permutations(range(n)):
        if perm[0] != start:
            continue
        cost = 0
        for i in range(n):
            cost += graph[perm[i]][perm[(i+1)%n]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"class PermutationGenerator:
    def __init__(self):
        self.results = []
    def generate(self, elements, current=[]):
        if not elements:
            self.results.append(current[:])
            return
        for i in range(len(elements)):
            self.generate(elements[:i] + elements[i+1:], current + [elements[i]])
    def get_all(self, n):
        self.generate(list(range(n)))
        return self.results",O(n!)
"def brute_force_hamiltonian(graph):
    import itertools
    n = len(graph)
    vertices = list(range(n))
    min_cost = float('inf')
    for perm in itertools.permutations(vertices):
        cost = 0
        valid = True
        for i in range(n):
            if graph[perm[i]][perm[(i+1)%n]] == 0:
                valid = False
                break
            cost += graph[perm[i]][perm[(i+1)%n]]
        if valid:
            min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def string_permutations(s):
    if len(s) == 1:
        return [s]
    perms = []
    for i in range(len(s)):
        first_char = s[i]
        remaining = s[:i] + s[i+1:]
        for p in string_permutations(remaining):
            perms.append(first_char + p)
    return perms",O(n!)
"def job_assignment(cost_matrix):
    n = len(cost_matrix)
    min_cost = float('inf')
    def assign(worker, assigned, total):
        nonlocal min_cost
        if worker == n:
            min_cost = min(min_cost, total)
            return
        for job in range(n):
            if not assigned[job]:
                assigned[job] = True
                assign(worker + 1, assigned, total + cost_matrix[worker][job])
                assigned[job] = False
    assign(0, [False]*n, 0)
    return min_cost",O(n!)
"def factorial_permute(items):
    from itertools import permutations
    return list(permutations(items))",O(n!)
"def heap_permute(n, arr, result):
    if n == 1:
        result.append(arr[:])
        return
    for i in range(n):
        heap_permute(n - 1, arr, result)
        if n % 2 == 1:
            arr[0], arr[n-1] = arr[n-1], arr[0]
        else:
            arr[i], arr[n-1] = arr[n-1], arr[i]",O(n!)
"def traveling_salesman_brute(graph):
    from itertools import permutations
    n = len(graph)
    min_cost = float('inf')
    for perm in permutations(range(n)):
        cost = 0
        for i in range(n):
            cost += graph[perm[i]][perm[(i+1) % n]]
        min_cost = min(min_cost, cost)
    return min_cost",O(n!)
"def heap_permutation(n, arr):
    if n == 1:
        print(arr)
        return
    for i in range(n):
        heap_permutation(n - 1, arr)
        if n % 2 == 0:
            arr[i], arr[n-1] = arr[n-1], arr[i]
        else:
            arr[0], arr[n-1] = arr[n-1], arr[0]
    return",O(n!)
"def arrangement_count(n, k):
    def factorial(x):
        if x == 0:
            return 1
        return x * factorial(x-1)
    return factorial(n) // factorial(n - k)",O(n!)
"def string_permutations(s):
    if len(s) == 1:
        return [s]
    perms = []
    for i, char in enumerate(s):
        for perm in string_permutations(s[:i] + s[i+1:]):
            perms.append(char + perm)
    return perms",O(n!)
"def generate_sequences(n):
    if n == 0:
        return [[]]
    smaller = generate_sequences(n-1)
    result = []
    for seq in smaller:
        for i in range(len(seq)+1):
            result.append(seq[:i] + [n] + seq[i:])
    return result",O(n!)
"def heap_permutation(n, A):
    if n == 1:
        print(A)
    else:
        for i in range(n):
            heap_permutation(n-1, A)
            if n % 2 == 0:
                A[i], A[n-1] = A[n-1], A[i]
            else:
                A[0], A[n-1] = A[n-1], A[0]",O(n!)
"def permute(nums):
    res = []
    def backtrack(start):
        if start == len(nums):
            res.append(nums[:])
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start+1)
            nums[start], nums[i] = nums[i], nums[start]
    backtrack(0)
    return res",O(n!)
"def factorial_permutations(items):
    from itertools import permutations
    return list(permutations(items))",O(n!)
"def generate_anagrams(s):
    if len(s) == 0:
        return ['']
    anagrams = []
    for i, char in enumerate(s):
        for ana in generate_anagrams(s[:i] + s[i+1:]):
            anagrams.append(char + ana)
    return anagrams",O(n!)
"def generate_derangements(n):
    if n == 0:
        return [[]]
    result = []
    for i in range(n):
        for der in generate_derangements(n-1):
            if i != len(der):
                new_der = der[:]
                new_der.insert(i, n-1)
                result.append(new_der)
    return result",O(n!)
"def all_assignments(tasks, workers):
    if not tasks:
        return [[]]
    result = []
    for i in range(len(workers)):
        for assignment in all_assignments(tasks[1:], workers[:i] + workers[i+1:]):
            result.append([(tasks[0], workers[i])] + assignment)
    return result",O(n!)
"def generate_sequence_permutations(seq):
    if len(seq) == 1:
        return [seq]
    perms = []
    for i in range(len(seq)):
        first = seq[i]
        remaining = seq[:i] + seq[i+1:]
        for p in generate_sequence_permutations(remaining):
            perms.append([first] + p)
    return perms",O(n!)
"def generate_derangements(n, current=None):
    if current is None:
        current = []
    if len(current) == n:
        return [current[:]] if all(i != current[i] for i in range(n)) else []
    result = []
    for i in range(n):
        if i not in current and i != len(current):
            current.append(i)
            result.extend(generate_derangements(n, current))
            current.pop()
    return result",O(n!)
"def permute_unique(elements):
    if len(elements) == 0:
        yield []
    for idx, val in enumerate(elements):
        remainder = elements[:idx] + elements[idx+1:]
        for perm in permute_unique(remainder):
            yield [val] + perm",O(n!)
"def get_all_orders(sequence):
    if len(sequence) == 1:
        return [sequence]
    permutations = []
    for i in range(len(sequence)):
        first = sequence[i]
        rest = sequence[:i] + sequence[i+1:]
        for p in get_all_orders(rest):
            permutations.append([first] + p)
    return permutations",O(n!)
"def exhaustive_permutation(lst):
    if len(lst) == 0:
        return [[]]
    output = []
    for index in range(len(lst)):
        element = lst[index]
        remaining = lst[:index] + lst[index+1:]
        for perm in exhaustive_permutation(remaining):
            output.append([element] + perm)
    return output",O(n!)
