code,complexity
"n, m = map(int, input().split())
A = list(map(int, input().split()))
L = [0]*n
for i in range(m):
    L[A[i]-1] += 1
print(min(L))",O(n ^ 2)
"import sys

def set(mask, pos):
    return mask | (1 << pos)

def isOn(mask, pos):
    return mask & ( 1 << pos) > 0

n, l, r, x = map(int, input().split(' '))
dif = list(map(int, input().split(' ')))

count, mask = 0, 0

while mask <= 2**n:
    summ, bit = [], 0

    while bit < n:

        if isOn(mask, bit):
            summ.append(dif[bit])

        bit += 1

    if sum(summ) <= r and sum(summ) >= l and max(summ) - min(summ) >= x:
        count += 1

    mask += 1

print(count)
",np
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,m=map(int,input().split())
c=list(map(int,input().split()))
kk=get_frequency(c)
if len(set(c))==n:
    print(min(kk.values()))
else:
    print(0)
",O(n ^ 2)
"from sys import stdin, stdout
from collections import defaultdict, Counter, deque
for _ in range(1):
    n,k=map(int, stdin.readline().split())
    li = list(map(int, stdin.readline().split()))
    dic=Counter(li)
    li=list(set(li))
    li.sort()
    n=len(li)
    for i in range(1,n):
        for j in range(i-1,-1,-1):
            if li[j]+k>=li[i] and dic[li[j]]!=0:
                dic[li[j]]=0
            else:
                break
    stdout.write(str(sum(dic.values()))+""\n"")",O(nlogn)
"n, k = map(int, input().split())
d = int((9 + 8 * (n + k)) ** 0.5)
x = (d - 3) // 2
print(n - x)",O(1)
"class Solution2(object):
    def treeQueries(self, n, edges, queries):
        def dfs(u, p, d):
            L[u] = cnt[0]
            cnt[0] += 1
            dist[u] = d
            for v, w in adj[u]:
                if v == p:
                    continue
                lookup[v] = w
                dfs(v, u, d+w)
            R[u] = cnt[0]

        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            u -= 1
            v -= 1
            adj[u].append((v, w))
            adj[v].append((u, w))
        L, R, dist, lookup = [0]*n, [0]*n, [0]*n, [0]*n
        cnt = [0]
        dfs(0, -1, 0)
        bit = BIT(n)
        result = []
        for q in queries:
            if q[0] == 1:
                _, u, v, w = q
                u -= 1
                v -= 1
                if L[u] > L[v]:
                    u, v = v, u 
                diff = w-lookup[v]
                bit.add(L[v], diff)
                bit.add(R[v], -diff)
                lookup[v] = w
            else:
                _, x = q
                x -= 1
                result.append(dist[x]+bit.query(L[x]))
        return result",O(nlogn)
"def solve(n,k):
    print(1*k,end = ' ')
    if n==2:
        print(2*k,end = ' ')
    if n == 3:
        print(k,3*k,end = ' ')
    else:
        temp = n//2
        if(n%2 == 0): temp -= 1
        print((str(k)+' ')*temp,end='')
        if(n>3):
            solve(n//2,k*2)

n = int(input())
solve(n,1)",O(n)
"class Codec:

    def serialize(self, root: Optional[TreeNode]) -> str:
        if not root:
            return ""N""
        res = []
        queue = deque([root])
        while queue:
            node = queue.popleft()
            if not node:
                res.append(""N"")
            else:
                res.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
        return "","".join(res)

    def deserialize(self, data: str) -> Optional[TreeNode]:
        vals = data.split("","")
        if vals[0] == ""N"":
            return None
        root = TreeNode(int(vals[0]))
        queue = deque([root])
        index = 1
        while queue:
            node = queue.popleft()
            if vals[index] != ""N"":
                node.left = TreeNode(int(vals[index]))
                queue.append(node.left)
            index += 1
            if vals[index] != ""N"":
                node.right = TreeNode(int(vals[index]))
                queue.append(node.right)
            index += 1
        return root
",O(n)
"import math,io,os,sys

n,s=map(int,input().split())
c=0
i=n
for i in range(s,min(s+1000,n+1)):
    if i-sum(map(int,str(i)))>=s:
        c+=1
c+=max(0,n-i)
print(c)
",O(logn)
"n, k = map(int, input().split())
c = 1
while c * (c + 1) // 2 < k:
    c += 1
while c * (c + 1) // 2 - (n - c) != k:
    c += 1
print(n - c)
",O(n)
"import sys
import bisect
import heapq
import math

INF = 10**9+7
sys.setrecursionlimit(INF)

def fi():
    return int(sys.stdin.readline())

def fi2():
    return map(int, sys.stdin.readline().split())

def fi3():
    return sys.stdin.readline().rstrip()

def fo(*args):
    for s in args:
        sys.stdout.write(str(s)+' ')
    sys.stdout.write('\n')

def puts(*args):
    for s in args:
        sys.stdout.write(str(s))

def mask(n1):
    arr = []
    for i in range(64):
        arr.append(n1&1)
        n1 = n1 >> 1
    arr.reverse()
    return arr

def getn(mask):
    if sum(mask) == 0:
        return 0
    res = 0
    for i in range(63, -1, -1):
        res += (2*mask[i])**(63-i)
    return res

n1, n2 = fi2()
m1 = mask(n1)
m2 = mask(n2)

sol = [0 for i in range(64)]

for i in range(64):
    if m1[i] != m2[i]:
        sol[i] = 1
        break

i += 1
for j in range(i, 64):
    sol[j] = 1

res = getn(sol)
fo(res)
",O(logn)
"print(""? 0 0"", flush=True)
res = input()
i = 1
a = 0
b = 0
for i in range(29,-1,-1):
	print(""?"",(a^(1<<i)), b, flush=True)
	res1 = input()
	print(""?"",a, (b^(1<<i)), flush=True)
	res2 = input()
	if res1 == res2:
		if res == '1':
			a ^= (1<<i)
		else:
			b ^= (1<<i)
		res = res1
	elif res1 == '-1':
		a ^= (1<<i)
		b ^= (1<<i)
print(""!"", a, b, flush=True)",O(logn)
"import itertools

element_to_value = {
  'H':1, 'He':2, 'Li':3, 'Be':4, 'B':5, 'C':6, 'N':7, 'O':8, 'F':9, 'Ne':10,
  'Na':11, 'Mg':12, 'Al':13, 'Si':14, 'P':15, 'S':16, 'Cl':17, 'Ar':18, 'K':19, 'Ca':20,
  'Sc':21, 'Ti':22, 'V':23, 'Cr':24, 'Mn':25, 'Fe':26, 'Co':27, 'Ni':28, 'Cu':29, 'Zn':30,
  'Ga':31, 'Ge':32, 'As':33, 'Se':34, 'Br':35, 'Kr':36, 'Rb':37, 'Sr':38, 'Y':39, 'Zr':40,
  'Nb':41, 'Mo':42, 'Tc':43, 'Ru':44, 'Rh':45, 'Pd':46, 'Ag':47, 'Cd':48, 'In':49, 'Sn':50,
  'Sb':51, 'Te':52, 'I':53, 'Xe':54, 'Cs':55, 'Ba':56, 'La':57, 'Ce':58, 'Pr':59, 'Nd':60,
  'Pm':61, 'Sm':62, 'Eu':63, 'Gd':64, 'Tb':65, 'Dy':66, 'Ho':67, 'Er':68, 'Tm':69, 'Yb':70,
  'Lu':71, 'Hf':72, 'Ta':73, 'W':74, 'Re':75, 'Os':76, 'Ir':77, 'Pt':78, 'Au':79, 'Hg':80,
  'Tl':81, 'Pb':82, 'Bi':83, 'Po':84, 'At':85, 'Rn':86, 'Fr':87, 'Ra':88, 'Ac':89, 'Th':90,
  'Pa':91, 'U':92, 'Np':93, 'Pu':94, 'Am':95, 'Cm':96, 'Bk':97, 'Cf':98, 'Es':99, 'Fm':100
}
value_to_element = dict()
for (element, value) in element_to_value.items():
  value_to_element[value] = element

(n,k) = map(int,input().split())
products_start_str = input().split()
products_end_str = input().split()

products_start = [element_to_value[elem] for elem in products_start_str]
products_end = [element_to_value[elem] for elem in products_end_str]

products_start.sort()
ingredient_value = []
ingredient_count = []
for (key, lst) in itertools.groupby(products_start):
  ingredient_value.append(key)
  ingredient_count.append(len(list(lst)))
nr_ingredients = len(ingredient_value)

construction_options = [[] for i in range(k)]
for combination in itertools.product(*[range(l+1) for l in ingredient_count]):
  value = sum(combination[i]*ingredient_value[i] for i in range(nr_ingredients))
  if (value in products_end):
    for i in range(k):
      if products_end[i] == value:
        construction_options[i].append(combination)

solution =  [None for i in range(k)]
def find_solution(used = [0 for i in range(nr_ingredients)], next = 0):
  if (next == k):
    return all(used[i] == ingredient_count[i] for i in range(nr_ingredients))
  else:
    for option in construction_options[next]:
      usage = [used[i]+option[i] for i in range(nr_ingredients)]
      if all(used[i] <= ingredient_count[i] for i in range(nr_ingredients)):
        possible = find_solution(usage, next+1)
        if (possible):
          solution[next] = option
          return True
  return False

possible = find_solution()

if not possible:
  print(""NO"")
  exit()

def combination_to_recipe(combination):
  recipe = []
  for i in range(nr_ingredients):
    for j in range(combination[i]):
      recipe.append(value_to_element[ingredient_value[i]])
  return recipe

print(""YES"")
for i in range(k):
  recipe = combination_to_recipe(solution[i])
  print(""%s->%s"" % (""+"".join(recipe),products_end_str[i]))
",np
"from sys import exit
t = input().split()[:3:]
s = set(t)
res = 3
if len(s)==1:
	res = min(res,0)
elif len(s)==2:
	res = min(res,1)
elif len(s)==3:
	res = min(res,2)
if res==0:
	print(res)
	exit(0)
t.sort()
m = [int(a[0]) for a in t if a[1]=='m']
p = [int(a[0]) for a in t if a[1]=='p']
s = [int(a[0]) for a in t if a[1]=='s']
def f(a):
	res = 2
	for i in a:
		if (i-1 in a and i+1 in a)or(i-2 in a and i-1 in a)or(i+1 in a and i+2 in a):
			return 0
		elif i-1 in a or i+1 in a or i-2 in a or i+2 in a:
			res = min(res,1)
	return res
res = min([res,f(m),f(p),f(s)])
print(res)",O(nlogn)
"n = int(input())
A = list(map(int, input().split()))
if n == 1:
    if A[0] >= 0:
        print(A[0])
    else:
        print(-A[0]-1)
    exit(0)
for i in range(n):
    if A[i] < 0:
        pass
    else:
        A[i] = -A[i]-1
if n % 2 == 0:
    print(*A)
    exit(0)
mim = 0
indmim = 0
for i in range(n):
    if A[i] < mim:
        mim = A[i]
        indmim = i
A[indmim] = -A[indmim]-1
print(*A)
",O(n)
"import collections



class Solution(object):
    def maxFrequencyScore(self, nums, k):
        MOD = 10**9+7
        lookup = {}
        def powmod(n, p):
            if (n, p) not in lookup:
                lookup[n, p] = (lookup[n, p-1]*n)%MOD if p >= 2 else n%MOD 
            return lookup[n, p]

        result = curr = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            if i >= k:
                curr = (curr-powmod(nums[i-k], cnt[nums[i-k]]))%MOD
                cnt[nums[i-k]] -= 1
                if cnt[nums[i-k]]:
                    curr = (curr+powmod(nums[i-k], cnt[nums[i-k]]))%MOD
            if cnt[nums[i]]:
               curr = (curr-powmod(nums[i], cnt[nums[i]]))%MOD
            cnt[nums[i]] += 1
            curr = (curr+powmod(nums[i], cnt[nums[i]]))%MOD
            if i >= k-1:
                result = max(result, curr)
        return result",O(n)
"import collections



class Solution(object):
    def countPalindromePaths(self, parent, s):
        def iter_dfs():
            result = 0
            cnt = collections.defaultdict(int)
            cnt[0] = 1
            stk = [(0, 0)]
            while stk:
                u, mask = stk.pop()
                if u:
                    mask ^= 1<<(ord(s[u])-ord('a'))
                    result += cnt[mask]+sum(cnt[mask^(1<<i)] if mask^(1<<i) in cnt else 0 for i in range(26))
                    cnt[mask] += 1
                for v in reversed(adj[u]):
                    stk.append((v, mask))
            return result

        adj = [[] for _ in range(len(parent))]
        for u, p in enumerate(parent):
            if p != -1:
                adj[p].append(u)
        return iter_dfs()",O(n)
"R = lambda: map(int, input().split())
a = sorted(map(int, input()))
b = list(map(int, input()))
bn = int(''.join(map(str, b)))
res = int(''.join(map(str, sorted(a))))
if len(b) != len(a):
    print(''.join(map(str, sorted(a, reverse=True))))
else:
    for i in range(len(a)):
        for j in range(i + 1, len(a)):
            if a[i] < a[j] < b[i]:
                a[i], a[j] = a[j], a[i]
        tmp = int(''.join(map(str, a[:i + 1] + sorted(a[i + 1:], reverse=True))))
        res = max(res, tmp) if tmp <= bn else res
        for j in range(i + 1, len(a)):
            if a[j] == b[i]:
                a[i], a[j] = a[j], a[i]
    print(res)",O(n ^ 3)
"import string


class Solution(object):
    def uniqueLetterString(self, S):
        M = 10**9 + 7
        index = {c: [-1, -1] for c in string.ascii_uppercase}
        result = 0
        for i, c in enumerate(S):
            k, j = index[c]
            result = (result + (i-j) * (j-k)) % M
            index[c] = [j, i]
        for c in index:
            k, j = index[c]
            result = (result + (len(S)-j) * (j-k)) % M
        return result",O(n)
"class Solution(object):
    def isValid(self, s):
        stack, lookup = [], {""("": "")"", ""{"": ""}"", ""["": ""]""}
        for parenthese in s:
            if parenthese in lookup:
                stack.append(parenthese)
            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:
                return False
        return len(stack) == 0",O(n)
"import collections



class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def countPairs(self, root, distance):
        def iter_dfs(distance, root):
            result = 0
            stk = [(1, (root, [collections.Counter()]))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    if not node.left and not node.right:
                        ret[0][0] = 1
                        continue
                    left, right = [collections.Counter()], [collections.Counter()]
                    stk.append((2, (left, right, ret)))
                    stk.append((1, (node.right, right)))
                    stk.append((1, (node.left, left)))
                else:
                    left, right, ret = params
                    for left_d, left_c in left[0].items():
                        for right_d,right_c in right[0].items():
                            if left_d+right_d+2 <= distance:
                                result += left_c*right_c
                    ret[0] = collections.Counter({k+1:v for k,v in (left[0]+right[0]).items()})
            return result
        
        return iter_dfs(distance, root)",O(n)
"class Solution2(object):
    def makePalindrome(self, s):
        cnt = 0
        left, right = 0, len(s)-1
        while left < right:
            if s[left] != s[right]:
                cnt += 1
                if cnt > 2:
                    return False
            left += 1
            right -= 1
        return True",O(n)
"class Solution2(object):
    def isPrefixString(self, s, words):
        i = 0
        for word in words:
            for c in word:
                if i == len(s) or s[i] != c:
                    return False
                i += 1
            if i == len(s):
                return True
        return False",O(n)
"n, m, k = map(int, input().split())

a = list(map(int, input().split()))

best = 0
dp = [0] * (n + 1)
for i in range(n):
    b2 = 0
    for j in range(max(-1, i - m), i + 1):
        b2 = max(b2, dp[j] - k + sum(a[j + 1:i + 1]))
    dp[i] = max(b2, a[i] - k)
    best = max(best, dp[i])

print(best)
",O(n ^ 2)
"n,m=map(int,input().split())
o=0
c=0
diff=[]
while n:
    n-=1
    a,b=map(int,input().split())
    diff.append(a-b)
    o+=a
    c+=b

if m >=o:
    print(0)
elif m <c:
    print(-1)
else:
    diff.sort(reverse=True)
    nd=o-m

    for i in range(len(diff)):

        nd-=diff[i]
        if nd<=0:
            print(i+1)
            break
",O(nlogn)
"n, s = map(int, input().split())
l = [0 for i in range(n)]
for i in range(n-1):
	a, b = map(int, input().split())
	l[a-1]+=1
	l[b-1]+=1
count = 0
for i in range(n):
	if(l[i]==1):
		count+=1
print((s/count)*2)",O(n)
"from math import ceil
N = int(input())
S = (N * (N + 1)) / 2
F = int(ceil(N /2.0))
ans = int((S + F) / 2)
print(ans)",O(n)
"import operator
from functools import reduce


class Solution(object):
    def getXORSum(self, arr1, arr2):
        return reduce(operator.xor, arr1) & reduce(operator.xor, arr2)",O(n)
"class Solution3(object):
    def getConcatenation(self, nums):
        return nums*2",O(n)
"
class Solution(object):
    def removeInterval(self, intervals, toBeRemoved):
        A, B = toBeRemoved
        return [[x, y] for a, b in intervals
                for x, y in ((a, min(A, b)), (max(a, B), b))
                if x < y]
",O(n)
"class Solution(object):
    def winnerOfGame(self, colors):
        cnt1 = cnt2 = 0
        for i in range(1, len(colors)-1):
            if not (colors[i-1] == colors[i] == colors[i+1]):
                continue
            if colors[i] == 'A':
                cnt1 += 1
            else:
                cnt2 += 1
        return cnt1 > cnt2",O(n)
"import sys

from collections import deque

from queue import PriorityQueue
from math import gcd
from math import log
from math import ceil
from math import pi
input_ = lambda: sys.stdin.readline().strip(""\r\n"")
ii = lambda : int(input_())
il = lambda : list(map(int, input_().split()))
ilf = lambda : list(map(float, input_().split()))
ip = lambda : input_()
fi = lambda : float(input_())
ap = lambda ab,bc,cd : ab[bc].append(cd)
li = lambda : list(input_())
pr = lambda x : print(x)
prinT = lambda x : print(x)
f = lambda : sys.stdout.flush()
mod = 10**9 + 7

n,mod = il()
N = 406

fact = [1 for i in range (N)]
inver = [1 for i in range (N)]
power2 = [1 for i in range (N)]
ncr = [[1 for i in range (N)] for j in range (N)]
dp = [[0 for i in range (N)] for j in range (N)]

def precom() :

    fact[0] = 1
    inver[0] = 1

    for i in range (1,N) :
        fact[i] = (fact[i-1]*i)%mod
        inver[i] = pow(fact[i],mod-2,mod)

    for i in range (N) :
        for j in range (i+1) :
            ncr[i][j] = (((fact[i]*inver[j])%mod)*inver[i-j])%mod

    for i in range(1,N) :
        power2[i] = (power2[i-1]*2)%mod

precom()

dp[0][0] = 1

for i in range (n) :
    for j in range (i+1) :
        k = 1
        while (k+i <= n) :

            dp[i+k+1][j+k] = (dp[i+k+1][j+k] + ((dp[i][j]*power2[k-1])%mod*ncr[j+k][k])%mod)%mod

            k += 1

ans = 0

for i in range (n+1) :
    ans = (ans + dp[n+1][i])%mod

print(ans)
",O(n ^ 3)
"import sys
m,n = [int(i) for i in input().split(' ')]
l = [[] for _ in range(m)]
for i in range(m):
	l[i] = input()
inks = []
for i in range(1, m-1):
	for j in range(1, n-1):
		if l[i-1][j-1] == '
			   inks += [(i-1,j-1),(i,j-1),(i+1,j-1),
					    (i-1,j  )        ,(i+1,j  ),
						(i-1,j+1),(i,j+1),(i+1,j+1),]
for i in range(m):
	for j in range(n):
		if l[i][j] == '
			print(""NO"")
			sys.exit()
else:
	print(""YES"")
",O(n ^ 2)
"string = input()
l, r = string.split()
l = int(l)
r = int(r)
p = l ^ r
x = 1
while x <= p:
    x = x << 1
print(x-1)
",O(logn)
"class Solution(object):
    def strangePrinter(self, s):
        def dp(s, i, j, lookup):
            if i > j:
                return 0
            if (i, j) not in lookup:
                lookup[(i, j)]  = dp(s, i, j-1, lookup) + 1
                for k in range(i, j):
                    if s[k] == s[j]:
                        lookup[(i, j)] = min(lookup[(i, j)], \
                                             dp(s, i, k, lookup) + dp(s, k+1, j-1, lookup))
            return lookup[(i, j)]

        lookup = {}
        return dp(s, 0, len(s)-1, lookup)",O(n ^ 3)
"import io
import os

from collections import Counter, defaultdict, deque

DEBUG = False

def bisect_f(f, lo, hi):
    if DEBUG:
        assert f(lo) and not f(hi)
    while hi - lo > 1:
        mid = (lo + hi) // 2
        if f(mid):
            lo = mid
        else:
            hi = mid
        if DEBUG:
            assert f(lo) and not f(hi)
    if DEBUG:
        assert hi - lo == 1
        assert f(lo) and not f(hi)
    return lo

def solve(N, M, arrs):
    def isPossible(target):
        possible = set()
        for arr in arrs:
            mask = 0
            for pos, x in enumerate(arr):
                if x >= target:
                    mask += 1 << pos
            possible.add(mask)
        allMask = (1 << M) - 1
        for mask1 in possible:
            for mask2 in possible:
                if mask1 | mask2 == allMask:
                    return (mask1 << 8) + mask2
        return 0

    lo = min(arrs[0])
    hi = 10 ** 9 + 1
    index = bisect_f(isPossible, lo, hi)

    mask1, mask2 = divmod(isPossible(index), 1 << 8)
    ans = [-1, -1]
    for i, arr in enumerate(arrs):
        mask = 0
        for pos, x in enumerate(arr):
            if x >= index:
                mask += 1 << pos
        if mask == mask1:
            ans[0] = str(i + 1)
        if mask == mask2:
            ans[1] = str(i + 1)
    return "" "".join(ans)

if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    N, M = [int(x) for x in input().split()]
    arrs = [[int(x) for x in input().split()] for i in range(N)]
    ans = solve(N, M, arrs)
    print(ans)
",np
"n , s = map(int , input().split())
lst = []
for i in range(n):
    lst.append(list(map(int , input().split())))
lst = sorted(lst , key =lambda x : x[0] , reverse = True)
prev , ans = s , 0
for i in range(n):
    ans += prev -lst[i][0]
    if ans < lst[i][1]:
        ans += (lst[i][1]- ans)

    prev = lst[i][0]
print(ans+prev)",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def replaceValueInTree(self, root):
        q = [(root, root.val)]
        while q:
            new_q = []
            total = sum(node.val for node, _ in q)
            for node, x in q:
                node.val = total-x
                x = (node.left.val if node.left else 0) + (node.right.val if node.right else 0)
                if node.left:
                    new_q.append((node.left, x))
                if node.right:
                    new_q.append((node.right, x))
            q = new_q
        return root",O(n)
"class Solution(object):
    def decrypt(self, code, k):
        result = [0]*len(code)
        if k == 0:
            return result
        left, right = 1, k
        if k < 0:
            k = -k
            left, right = len(code)-k, len(code)-1
        total = sum(code[i] for i in range(left, right+1))
        for i in range(len(code)):
            result[i] = total
            total -= code[left%len(code)]
            total += code[(right+1)%len(code)]
            left += 1
            right += 1
        return result",O(n)
"from math import *
import sys
input = lambda: sys.stdin.readline().strip()

d = {'m': [], 's': [], 'p': []}

ls = list(input().split())
for i in ls:
    d[i[1]].append(int(i[0]))
for k, v in d.items():
    v.sort()
    if len(v)==3 and len(set(v))==1: print(0); break
    if len(v)==3 and v[0]+1==v[1] and v[1]+1==v[2]: print(0); break
else:
    for k, v in d.items():
        if len(v)==2 and len(set(v))==1: print(1); break
        if len(v)==2 and v[1]-v[0]<=2: print(1); break
        if len(v)==3 and (v[0]==v[1] or v[1]==v[2]): print(1); break
        if len(v)==3 and (v[1]-v[0]<=2 or v[2]-v[1]<=2): print(1); break
    else:
        print(2)
",O(nlogn)
"print(""? 0 0"")
t = int(input())
A=[]
B=[]
a=0
b=0
for i in range(30):
    A.append(-1)
    B.append(-1)
i = 29
d = 2**i
while i>=0:
    a+=d
    b+=d
    print(""?"", end=' ')
    print(a, end=' ')
    print(b)
    s=int(input())
    if s == -t:
        if s==1:
            A[i]=0
            B[i]=1
            b-=d
            print(""?"", end=' ')
            print(a, end=' ')
            print(b)
            t=int(input())
        elif s==-1:
            A[i]=1
            a-=d
            B[i]=0
            print(""?"", end=' ')
            print(a, end=' ')
            print(b)
            t=int(input())
    i-=1
    d//=2
d=1
for j in range(30):
    if A[j]==-1:
        a = a^d
        print(""?"", end=' ')
        print(a, end=' ')
        print(b)
        s = int(input())
        if s==1:
            A[j]=1
            B[j]=1
        else:
            A[j]=0
            B[j]=0
        a = a^d
    d*=2
d=1
a=0
b=0
for i in range(30):
    a+=d*A[i]
    b+=d*B[i]
    d*=2
print(""!"", end=' ')
print(a, end=' ')
print(b)
",O(logn)
"def binar(a,st,d):
    if st==0:
        return 1

    elif st==1:
        return a%d

    return (   binar(a**2%d,st//2,d) *  binar(a, st%2,d)   )%d

x,k=map(int,input().split())

if x==0:
	print(0)
	exit()

res= ((x*binar(2,k+1,1000000007)) - (binar(2,k,1000000007))+1)% 1000000007
print(res)",O(logn)
"class MinStack:
    def __init__(self):
        self.stack = []
        self.minStack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        val = min(val, self.minStack[-1] if self.minStack else val)
        self.minStack.append(val)

    def pop(self) -> None:
        self.stack.pop()
        self.minStack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minStack[-1]
",O(1)
"class Solution(object):
    def maximumSwap(self, num):
        digits = list(str(num))
        left, right = 0, 0
        max_idx = len(digits)-1
        for i in reversed(range(len(digits))):
            if digits[i] > digits[max_idx]:
                max_idx = i
            elif digits[max_idx] > digits[i]:
                left, right = i, max_idx
        digits[left], digits[right] = digits[right], digits[left]
        return int("""".join(digits))",O(logn)
"def is_good(x, n, k):
    y = k - x + 1
    return (y + k * (k - 1) // 2 - y * (y - 1) // 2) >= n

if __name__ == '__main__':
    n, k = [int(x) for x in input().split()]
    if n == 1:
        print(0)
    elif (k + (k - 2) * (k - 1) // 2) < n:
        print(-1)
    elif k >= n:
        print(1)
    else:
        l = 0
        r = k
        while r > l + 1:
            m = (l + r) // 2

            if is_good(m, n, k):
                r = m
            else:
                l = m
        print(r)
",O(logn)
"class Solution(object):
    def areaOfMaxDiagonal(self, dimensions):
        return max((l**2+w**2, l*w) for l, w in dimensions)[1]",O(n)
"a, b, c, d, e, f, g, h = map(int, input().split(' '))
i, j, k, l, m, n, o, p = map(int, input().split(' '))

s1 = [[a, b], [c, d], [e, f], [g, h]]
s1.sort()
bleft = s1[0]
tr = s1[3]
u, v, w, x = bleft[0], bleft[1], tr[0], tr[1]

def check(xd, dx, u, v, w, x):
	return (u <= xd and xd <= w and v <= dx and dx <= x)

god = [(i+k+m+o)/4, (j+l+n+p)/4]
nani = 0
for moo in [[i, j], [k, l], [m, n], [o, p]]:
	if check(moo[0], moo[1], u, v, w, x):
		print(""Yes"")
		quit()

if check(god[0], god[1], u, v, w, x):
	nani += 1

i, j = i+j, i-j
k, l = k+l, k-l
m, n = m+n, m-n
o, p = o+p, o-p

a, b = a+b, a-b
c, d = c+d, c-d
e, f = e+f, e-f
g, h = g+h, g-h

a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p = i, j, k, l, m, n, o, p, a, b, c, d, e, f, g, h

s1 = [[a, b], [c, d], [e, f], [g, h]]
s1.sort()
bleft = s1[0]
tr = s1[3]
u, v, w, x = bleft[0], bleft[1], tr[0], tr[1]

def check(xd, dx, u, v, w, x):
	return (u <= xd and xd <= w and v <= dx and dx <= x)

god = [(i+k+m+o)/4, (j+l+n+p)/4]

for moo in [[i, j], [k, l], [m, n], [o, p]]:
	if check(moo[0], moo[1], u, v, w, x):
		print(""Yes"")
		quit()

if check(god[0], god[1], u, v, w, x):
	nani += 1
if nani == 2:
	print(""Yes"")
	quit()

print(""No"")",O(1)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import gcd, ceil

def pre(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi

def prod(a):
    ans = 1
    for each in a:
        ans = (ans * each)
    return ans

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

for _ in range(int(input()) if not True else 1):
    r, g, b = map(int, input().split())

    rr = list(map(int, input().split()))
    gg = list(map(int, input().split()))
    bb = list(map(int, input().split()))

    dp = [[[0]*(b+1) for __ in range(g+1)] for ___ in range(r+1)]
    def f(a):return sorted(a,reverse=True)
    rr,gg,bb=f(rr),f(gg),f(bb)
    ans=0
    r+=1
    g+=1
    b+=1
    for i in range(r):
        for j in range(g):
            for k in range(b):
                try:dp[i+1][j+1][k] = max(dp[i+1][j+1][k],dp[i][j][k] + rr[i]*gg[j])
                except:pass
                try:dp[i][j+1][k+1] = max(dp[i][j+1][k+1],dp[i][j][k] + gg[j]*bb[k])
                except:pass
                try:dp[i+1][j][k+1] = max(dp[i+1][j][k+1],dp[i][j][k] + rr[i]*bb[k])
                except:pass
                ans=max(ans,dp[i][j][k])
    print(ans)",O(n ^ 3)
"n,m=map(int,input().split())
MAP=[list(input()) for i in range(n)]

ANSMAP=[[""."" for i in range(m)] for j in range(n)]

for i in range(1,n-1):
    for j in range(1,m-1):
        if MAP[i-1][j-1]==""
            ANSMAP[i-1][j-1] =""
            ANSMAP[i-1][j]=""
            ANSMAP[i-1][j+1]=""
            ANSMAP[i][j-1]=""
            ANSMAP[i][j+1]=""
            ANSMAP[i+1][j-1]=""
            ANSMAP[i+1][j]=""
            ANSMAP[i+1][j+1]=""

if MAP==ANSMAP:
    print(""YES"")

else:
    print(""NO"")
",O(n ^ 2)
"a, b = map(int, input().split())
print(""1""*a)
print(int(""1"" + (""0"" * a)) - int(""1"" * a))",O(1)
"x = list(map(int, input().split()))

start = 0
end = x[0] -1

target = x[1]

ans = 0

while start<= end:

    mid = (start+end)//2
    sum = mid*(mid+1) //2

    ans1 = x[0] - mid

    if sum - ans1 == target:
        ans = ans1
        break
    elif sum - ans1 > target:
        end = mid - 1
    else:
        start = mid+1

print(ans)
",O(logn)
"class Solution3(object):
    def countPairs(self, nums, k):
        idxs = collections.defaultdict(list)
        for i, x in enumerate(nums):
            idxs[x].append(i)
        return sum(idx[i]*idx[j]%k == 0 for idx in idxs.values() for i in range(len(idx)) for j in range(i+1, len(idx)))",O(n ^ 2)
"class Solution(object):
    def findKthBit(self, n, k):
        flip, l = 0, 2**n-1
        while k > 1:
            if k == l//2+1:
                flip ^= 1
                break
            if k > l//2:
                k = l+1-k
                flip ^= 1
            l //= 2
        return str(flip)",O(n)
"n,k= map(int,input().split(' '))
l= list(map(int,input().split(' ')))
f =list(map(int,input().split(' ')))
h=list(map(int,input().split(' ')))
d1=dict({(a,0) for a in f})
d2=dict({(a,0) for a in f})
for a in l:
	if(a in d1):d1[a]+=1
for a in f:
	d2[a]+=1

dp = [[0 for i in range(520*12)] for j in range(520)]

for x in range(n+1):
	for y in range(n*k+1):
		for i in range(k+1):
				dp[x+1][y+i] = max(dp[x+1][y+i],+dp[x][y]+(0 if i==0 else h[i-1]) )
ss=0
for i in d1:

	ss+=dp[d2[i]][d1[i]]
print(ss)",O(n ^ 3)
"n = int(input())
a = [int(i) for i in input().split()]
a.sort()
flag = 0
for i in range(n-1):
	if(a[i] == a[i+1]):
		if(flag == 1):
			flag = 2
			break
		flag = 1
		index = i
		if(i+2<n and a[i+1] == a[i+2]):
			flag = 2
			break
		elif(i>0 and a[i-1] == a[i]-1):
			flag = 2
			break
if(flag == 2):
	print(""cslnb"")
elif(flag ==1 and a[index] ==0):
	print(""cslnb"")
else:
	moves=0
	for i in range(n):
		if(a[i] == i):
			continue
		elif(a[i]<i):
			continue
		else:
			moves += (a[i] - i)
	if(moves%2 == 0):
		print(""cslnb"")
	else:
		print(""sjfnb"")",O(nlogn)
"n, k = [int(i) for i in input().split()]
d = dict()
d[0] = 1
x = 0
for i in [int(i) for i in input().split()]:
    x ^= i
    v = min(x, (1 << k) - x - 1)
    if v not in d.keys():
        d[v] = 0
    d[v] += 1
ans = 0
for k, v in d.items():
    c1 = v // 2
    c2 = v - c1
    ans += c1 * (c1 - 1) // 2 + c2 * (c2 - 1) // 2
print(n * (n - 1) // 2 + n - ans)
",O(n)
"n,a,b,c,t=map(int,input().split())
l=list(map(int,input().split()))
if c>b:
    r=0
    for i in l:
        k=t-i
        k*=(c-b)
        r+=k
    print(a*n+r)
else:
    print(a*n)
",O(n)
"import sys
input=lambda: sys.stdin.readline().rstrip()
import copy
n=int(input())
A=[int(i) for i in input().split()]
inf=float(""inf"")
DP=[[inf]*(n+1) for _ in range(n+1)]

for j in range(1,n+1):
  for i in range(n):
    if i+j>n:
      continue
    else:
      if j==1:
        DP[i][i+1]=A[i]
      else:
        for k in range(i+1,i+j):
          if DP[i][k]<10000 and DP[k][i+j]<10000:
            if DP[i][k]==DP[k][i+j]:
              DP[i][i+j]=DP[i][k]+1
            else:
              DP[i][i+j]=20000
          else:
            if DP[i][k]<10000:
              DP[i][i+j]=min(DP[i][i+j],10000+DP[k][i+j])
            elif DP[k][i+j]<10000:
              DP[i][i+j]=min(DP[i][i+j],DP[i][k]+10000)
            else:
              DP[i][i+j]=min(DP[i][i+j],DP[i][k]+DP[k][i+j])
print(DP[0][n]//10000 if DP[0][n]>=10000 else 1)",O(n ^ 3)
"n = int(input())
f0= 0
f1 = 1
li = [0,1]
for i in range(45):
	t = f1
	f1 += f0
	f0 = t
	li.append(f1)
x = []
for i in range(3):
	for i in range(len(li)-1, -1, -1):
		if li[i] <= n:
			n -= li[i]
			x.append(li[i])
			break
if n == 0:
	print(*x, sep = "" "")
else:
	print(""I'm too stupid to solve this problem"")
",O(1)
"import sys
from collections import defaultdict

reader = (map(int, line.split()) for line in sys.stdin)
input = reader.__next__

n, m = input()

vals = set()
locs = defaultdict(list)
for i in range(n):
    for pos, v in enumerate(input()):
        vals.add(v)
        locs[v].append((pos, i))

masks = [0] * n
full = (1<<m) - 1
met = {0:0}
for v in sorted(vals, reverse=True):
    for pos, i in locs[v]:
        curr_mask = masks[i] = masks[i] | (1<<pos)
        met[curr_mask] = i
        complement = full ^ curr_mask
        if complement in met:
            print(i+1, met[complement]+1)
            sys.exit()",np
"class Solution(object):
    def findMinDifference(self, timePoints):
        minutes = [int(x[:2]) * 60 + int(x[3:]) for x in timePoints]
        minutes.sort()
        return min((y - x) % (24 * 60)  \
                   for x, y in zip(minutes, minutes[1:] + minutes[:1]))",O(nlogn)
"import sys
from array import array

def readline() -> str: return sys.stdin.buffer.readline().decode('utf-8')

n, k = map(int, readline().split())
mod = 998244353
dp = [[array('i', [0])*(2*n+3) for _ in range(n)] for _ in range(4)]
dp[0][0][1] = dp[3][0][1] = 1
dp[1][0][2] = dp[2][0][2] = 1

for i in range(n-1):
    for j in range(k+1):
        for sbit in range(4):
            for tbit in range(4):
                add = (
                    1 if sbit == 3 and tbit == 0 or sbit == 0 and tbit == 3 else
                    (1 if (sbit & 2) != (tbit & 2) and (tbit == 1 or tbit == 2) else 0)
                    + (1 if (sbit & 1) != (tbit & 1) and (tbit == 1 or tbit == 2) else 0)
                )
                dp[tbit][i+1][j+add] += dp[sbit][i][j]
                if dp[tbit][i+1][j+add] >= mod:
                    dp[tbit][i+1][j+add] -= mod

ans = sum(dp[bit][-1][k] for bit in range(4)) % mod
print(ans)
",np
"n,k=[int(x) for x in input().split()]
lst1=[int(x) for x in input().split()]
lst2=[int(x) for x in input().split()]
lst3={}
ans=[]
for i in lst2:
    if(i in lst1):

        lst3[i]=lst1.index(i)
for i in sorted(lst3,key=lst3.get):
    ans.append(i)

print(*ans,sep="" "")
",O(n ^ 2)
"class Solution2(object):
    def invertTree(self, root):
        if root is not None:
            nodes = []
            nodes.append(root)
            while nodes:
                node = nodes.pop()
                node.left, node.right = node.right, node.left
                if node.left is not None:
                    nodes.append(node.left)
                if node.right is not None:
                    nodes.append(node.right)

        return root",O(n)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maxProduct(self, root):
        MOD = 10**9 + 7
        def dfs(root, total, result):
            if not root:
                return 0
            subtotal = dfs(root.left, total, result)+dfs(root.right, total, result)+root.val
            result[0] = max(result[0], subtotal*(total-subtotal) )
            return subtotal

        result = [0]
        dfs(root, dfs(root, 0, result), result)
        return result[0] % MOD",O(n)
"class Solution2(object):
    def countPairsOfConnectableServers(self, edges, signalSpeed):
        def dfs(u, p, dist):
            cnt = 1 if dist%signalSpeed == 0 else 0
            for v, w in adj[u]:
                if v == p:
                    continue
                cnt += dfs(v, u, dist+w)
            return cnt
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        result = [0]*(len(edges)+1)
        for u in range(len(result)):
            curr = 0
            for v, w in adj[u]:
                cnt = dfs(v, u, w)
                result[u] += curr*cnt
                curr += cnt
        return result",O(n ^ 2)
"import collections


class Solution(object):
    def areOccurrencesEqual(self, s):
        return len(set(collections.Counter(s).values())) == 1",O(n)
"class Solution(object):
    def minCost(self, nums, x):
        def accumulate(a):
            for i in range(len(a)-1):
                a[i+1] += a[i]
            return a

        i = min(range(len(nums)), key=lambda x: nums[x])
        nums = nums[i:]+nums[:i]
        left, right = [-1]*len(nums), [len(nums)]*len(nums)
        stk = []
        for i in range(len(nums)):
            while stk and nums[stk[-1]] > nums[i]:
                right[stk.pop()] = i
            if stk:
                left[i] = stk[-1]
            stk.append(i)
        diff2 = [0]*(len(nums)+1)
        diff2[0] = (+1)*sum(nums)            
        diff2[1] = x                         
        diff2[-1] += (-1)*nums[0]            
        for i in range(1, len(nums)):
            l, r = i-left[i], right[i]-i
            diff2[min(l, r)] += (-1)*nums[i] 
            diff2[max(l, r)] += (-1)*nums[i] 
            diff2[l+r] += (+1)*nums[i]       
        return min(accumulate(accumulate(diff2)))",O(n)
"buck = [[0, 0] for i in range(2201)]
m = int(input())
for i in range(m):
    a = int(input())
    ok = True
    br = 0
    for j in range(2200, -1, -1):
        if a & (1 << j):
            if(buck[j][0]):
                a  ^= buck[j][0]
                br ^= buck[j][1]
            else:
                ok = False
                buck[j][0] = a
                buck[j][1] = br | (1 << i)
                break
    if not ok:
        print(""0"")
    else:
        lst = []
        for j in range(2201):
            if br & (1 << j):
                lst.append(j)
        print(len(lst), end = ' ')
        for j in lst:
            print(j, end = ' ')
        print('\n', end='')
",np
"import collections



class Solution(object):
    def findWinners(self, matches):
        lose = collections.defaultdict(int)
        players_set = set()
        for x, y in matches:
            lose[y] += 1
            players_set.add(x)
            players_set.add(y)
        return [[x for x in sorted(players_set) if lose[x] == i] for i in range(2)]",O(nlogn)
"
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        s, b = sorted([p.val, q.val])
        while not s <= root.val <= b:
            root = root.left if s <= root.val else root.right
        return root

",O(n)
"
import collections


class Solution(object):
    def subdomainVisits(self, cpdomains):
        result = collections.defaultdict(int)
        for domain in cpdomains:
            count, domain = domain.split()
            count = int(count)
            frags = domain.split('.')
            curr = []
            for i in reversed(range(len(frags))):
                curr.append(frags[i])
                result[""."".join(reversed(curr))] += count

        return [""{} {}"".format(count, domain) \
                for domain, count in result.items()]

",O(n)
"def some_random_function():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function5():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

import os,sys
from io import BytesIO,IOBase

def main():
    n,m,k = map(int,input().split())
    hor = [list(map(int,input().split()))+[10**20+1] for _ in range(n)]
    ver = [list(map(int,input().split())) for _ in range(n-1)]+[[10**20+1]*m]
    if k&1:
        for _ in range(n):
            print(*[-1]*m)
        exit()
    dp = [[0]*m for _ in range(n)]
    dx,dy = [0,0,1,-1],[1,-1,0,0]
    for _ in range(k//2):
        dp1 = [[10**20]*m for _ in range(n)]
        for i in range(n):
            for j in range(m):
                for kk in range(4):
                    x1,y1 = i+dx[kk],j+dy[kk]
                    if kk < 2:
                        ed = hor[i][j-(kk==1)]
                    else:
                        ed = ver[i-(kk==3)][j]
                    if ed != 10**20+1:
                        dp1[i][j] = min(dp1[i][j],2*ed+dp[x1][y1])
        dp = dp1
    for i in dp:
        print(*i)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def some_random_function1():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function2():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function3():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function4():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function6():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function7():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function8():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

if __name__ == '__main__':
    main()",O(n ^ 3)
"n, m = map(int, input().split())
c = list(map(int, input().split()))
a = list(map(int, input().split()))

ans = 0
i = 0
for bill in a:
    try:
        i += next(ind for ind, el in enumerate(c[i:]) if el <= bill) + 1
        ans += 1
    except StopIteration:
        break

print(ans)
",O(n)
"class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root: return None

        root.left, root.right = root.right, root.left

        self.invertTree(root.left)
        self.invertTree(root.right)

        return root
",O(n)
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    n=int(input())
    s=list(input().strip())
    t=list(input().strip())
    res=True
    ans=[]
    for i in range(n):
        if s[i]==t[i]:
            continue
        else:
            ind=-1
            for j in range(i+1,n):
                if t[i]==s[j]:
                    ind=j
                    break
            if ind==-1:
                res=False
                break
            for j in range(ind-1,i-1,-1):
                ans.append(j+1)
                s[j],s[j+1]=s[j+1],s[j]
    if res:
        print(len(ans))
        print(*ans)
    else:
        print(-1)

if __name__ == '__main__':
    main()
",O(n ^ 2)
"class Solution(object):
    def minimumRightShifts(self, nums):
        i = next((i for i in range(len(nums)) if not nums[i] < nums[(i+1)%len(nums)]), len(nums))
        j = next((j for j in range(i+1, len(nums)) if not nums[j%len(nums)] < nums[(j+1)%len(nums)]), len(nums))
        return len(nums)-(i+1) if j == len(nums) else -1",O(n)
"n=int(input())+1
if n<2:
    print(0)
elif n%2==0:
    print(n//2)
else:
    print(n)",O(1)
"from sys import stdin
input=stdin.readline
from collections import defaultdict
def f(q):
    q.sort()
    d=defaultdict(int)
    for l,r in q:
        d[l]+=1
        d[r+1]-=1
    res=0
    prev=None
    ans=[0]*(len(q)+1)
    for i in sorted(d.keys()):

        if prev==None:

            prev=i
        else:
            ans[res]+=i-prev
            prev=i
        res+=d[i]

    return ans[1:]

n=int(input())
q=[]
for i in range(n):
    x,y=map(int,input().strip().split())
    q.append((x,y))
print(*f(q))",O(nlogn)
"class Solution3(object):
    def hasSameDigits(self, s):
        s = list(map(int, s))
        for l in reversed(range(3, len(s)+1)):
            for i in range(l-1):
                s[i] = (s[i]+s[i+1])%10
        return s[0] == s[1]",O(n ^ 2)
"class Solution2(object):
    def numberOfSubstrings(self, s):
        result, left, count = 0, 0, [0]*3
        for right, c in enumerate(s):
            count[ord(s[right])-ord('a')] += 1
            while all(count):
                count[ord(s[left])-ord('a')] -= 1
                left += 1
            result += left
        return result",O(n)
"n, a, b = map(int, input().split())
arr = list(map(int, input().split()))
arr.sort()
end_b = arr[b-1]
start_a = arr[b]
if end_b < start_a:
    print(start_a - end_b)
else:
    print(0)
",O(nlogn)
"n = int(input())

arr = list(map(int, input().split(' ')))
arr.sort()

stop = 0
equal = -1
tempcounter = 0

for i in range(1, n):
    if arr[i] == arr[i-1]:
        equal = arr[i]
        tempcounter += 1
        if tempcounter == 2:
            break

if tempcounter == 1 and equal != 0:
    for j in range(n):
        if arr[j] == equal-1:
            print(""cslnb"")
            stop = 1

if tempcounter == 1 and equal == 0:
    print(""cslnb"")

elif tempcounter < 2 and stop == 0:
    moves = arr[0]
    counter = 0

    for i in range(1, n):
        moves += arr[i] - i

    if counter == 0:
        if moves%2 == 0:
            print(""cslnb"")

        else:
            print(""sjfnb"")

elif stop == 0:
    print(""cslnb"")
",O(nlogn)
"class Solution(object):
    def minNumberOfFrogs(self, croakOfFrogs):
        S = ""croak""
        lookup = [0]*len(S)
        result = 0
        for c in croakOfFrogs:
            i = S.find(c)
            lookup[i] += 1
            if lookup[i-1]:
                lookup[i-1] -= 1
            elif i == 0:
                result += 1
            else:
                return -1
        return result if result == lookup[-1] else -1",O(n)
"class Solution(object):
    def checkIfCanBreak(self, s1, s2):
        def is_break(count1, count2):
            curr1, curr2 = 0, 0
            for c in string.ascii_lowercase:
                curr1 += count1[c]
                curr2 += count2[c]
                if curr1 < curr2:
                    return False
            return True

        count1, count2 = collections.Counter(s1), collections.Counter(s2)
        return is_break(count1, count2) or is_break(count2, count1)
import itertools",O(n)
"MAX=10**9
def main():

    n,m=readIntArr()
    arrs=[]
    for _ in range(n):
        arrs.append(readIntArr())

    def checkPossible(minB):
        binRepresentations=set()
        for arr in arrs:
            binRepresentations.add(convertToBinary(arr,minB))
        binList=list(binRepresentations)
        ii=jj=-1
        n=len(binList)
        for i in range(n):
            for j in range(i,n):
                if binList[i]|binList[j]==(1<<m)-1:
                    ii=binList[i]
                    jj=binList[j]
        if ii!=-1:
            ansi=ansj=-1
            for i in range(len(arrs)):
                b=convertToBinary(arrs[i],minB)
                if b==ii:
                    ansi=i
                if b==jj:
                    ansj=i

            return (ansi,ansj)
        else:
            return None

    def convertToBinary(arr,minB):
        b=0
        for i in range(m):
            if arr[i]>=minB:
                b|=(1<<i)
        return b

    minB=-1
    i=j=-1
    b=MAX
    while b>0:
        temp=checkPossible(minB+b)
        if temp==None:
            b//=2
        else:
            minB+=b
            i,j=temp
    i+=1;j+=1
    print('{} {}'.format(i,j))

    return

import sys
input=sys.stdin.buffer.readline

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))

def readIntArr():
    return [int(x) for x in input().split()]

def makeArr(*args):

    assert len(args) >= 2, ""makeArr args should be (default value, dimension 1, dimension 2,...""
    if len(args) == 2:
        return [args[0] for _ in range(args[1])]
    else:
        return [makeArr(args[0],*args[2:]) for _ in range(args[1])]

def queryInteractive(x,y):
    print('? {} {}'.format(x,y))
    sys.stdout.flush()
    return int(input())

def answerInteractive(ans):
    print('! {}'.format(ans))
    sys.stdout.flush()

inf=float('inf')
MOD=10**9+7

for _abc in range(1):
    main()",np
"R=lambda:map(int,input().split())
a,b=R()
x,y,z=R()
print(max(0,2*x+y-a)+max(0,y+3*z-b))",O(1)
"class Solution(object):
    def parseBoolExpr(self, expression):
        def parse(expression, i):
            if expression[i[0]] not in ""&|!"":
                result = expression[i[0]] == 't'
                i[0] += 1
                return result
            op = expression[i[0]]
            i[0] += 2
            stk = []
            while expression[i[0]] != ')':
                if expression[i[0]] == ',': 
                    i[0] += 1
                    continue
                stk.append(parse(expression, i))
            i[0] += 1
            if op == '&':
                return all(stk)
            if op == '|':
                return any(stk)
            return not stk[0]

        return parse(expression, [0])",O(n)
"class Solution(object):
    def numberOfWays(self, n, m, k, source, dest):
        MOD = 10**9+7
        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        T = [[0, m-1, n-1,           0],
             [1, m-2,   0,         n-1],
             [1,   0, n-2,         m-1],
             [0,   1,   1, (n-2)+(m-2)]]
        dp = [0]*4 
        if source == dest:
            dp[0] = 1
        elif source[0] == dest[0]:
            dp[1] = 1
        elif source[1] == dest[1]:
            dp[2] = 1
        else:
            dp[3] = 1
        dp = matrix_mult([dp], matrix_expo(T, k))[0] 
        return dp[0]",O(logn)
"from operator import itemgetter

def main():
    n,m=map(int,input().split( ))
    a=[]
    for _ in range(m):
        x,y=map(int,input().split( ))
        x-=1;y-=1
        a.append((x,y))
    a=sorted(a,key=itemgetter(0,1))

    ans=[-1]*n
    for l,r in a:

        if ans[l]==-1:

            flag=1

            for i in range(l,r+1):
                if flag:
                    ans[i]=1
                else:
                    ans[i]=0
                flag^=1
        else:

            flag=1
            x=ans[l]
            for i in range(l,r+1):

                if flag:
                    ans[i]=x
                else:
                    ans[i]=x^1
                flag^=1
    for i in range(n):
        if ans[i]==-1:
            ans[i]=0

    ans=map(str,ans)
    print(''.join(ans))
main()",O(n)
"def main():
    n, q = map(int, input().split())
    for _ in range(q):
        node = int(input())
        s = input()

        for i in s:
            if i == 'L':
                if node % 2:
                    continue
                k = node & (-node)
                node -= k
                k //= 2
                node += k

            if i == 'R':
                if node % 2:
                    continue
                k = node & (-node)
                k //= 2
                node += k

            if i == 'U':
                if node == (n + 1) // 2:
                    continue
                k = node & (-node)
                node -= k
                k *= 2
                node |= k
        print(node)
    return

if __name__ == ""__main__"":
    main()",np
"import collections



class Solution(object):
    def minimumPushes(self, word):
        return sum(x*(i//(9-2+1)+1) for i, x in enumerate(sorted(iter(collections.Counter(word).values()), reverse=True)))",O(n)
"test=int(input())
while test:
	test=test-1
	n,k = input().split()
	n=int(n)
	k=int(k)
	s=0
	curr=1
	ct=0
	while s<k:
		s=s+curr
		curr=4*curr
		ct=ct+1
	if n>=35:
		print(""YES"",n-1)
		continue
	val=[]
	val.append(0)
	for i in range(1,n):
		val.append(1+4*val[i-1])
	s=0
	t=2
	rem=0
	while n>0:
		s=s+t-1
		t*=2
		p=3
		rem=rem+(t-3)*(val[n-1])
		rem=int(rem)
		if rem+s>=k and s<=k:
			print(""YES"",n-1)
			n=-2
			break
		n=n-1
	if n != -2:
		print(""NO"")",O(logn)
"import sys

def ask(c, d):
    print(""? {} {}"".format(c, d))
    return int(input())

c = d = 0

def solve(mi, base):
    def solve_same():
        global c, d
        print(""
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d)
            res2 = ask(c, d ^ bit)
            if res1 == -1 and res2 == 1:
                c |= bit
                d |= bit

    def solve1():
        global c, d
        print(""
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d ^ bit)
            if res1 == -1:

                c |= bit
                return solve(i - 1, ask(c, d))
            else:

                res2 = ask(c ^ bit, d)
                if res2 == -1:

                    c |= bit
                    d |= bit

    def solve2():
        global c, d
        print(""
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d ^ bit)
            if res1 == 1:

                d |= bit
                return solve(i - 1, ask(c, d))
            else:

                res2 = ask(c, d ^ bit)
                if res2 == 1:

                    c |= bit
                    d |= bit

    if base == 0:
        solve_same()
    elif base == 1:
        solve1()
    else:
        solve2()

solve(29, ask(0, 0))
print(""! {} {}"".format(c, d))
",O(logn)
"l, r = [int(x) for x in input().split()]

r = bin(r)[2:]
l = bin(l)[2:]

r = r[::-1]
l = l[::-1]

if l == r:
    print(0)
else:

    l += '0' * (len(r) - len(l))
    p = -1
    for i in range(len(r)):
        if r[i] != l[i]:
            p = i

    a = '1' * p + '0'
    b = '0' * p + '1'

    print(int(a, 2) ^ int(b, 2))
",O(logn)
"class Solution(object):

    def __init__(self, n):
        self.__size = n
        self.__rows = [[0, 0] for _ in range(n)]
        self.__cols = [[0, 0] for _ in range(n)]
        self.__diagonal = [0, 0]
        self.__anti_diagonal = [0, 0]

    def move(self, row, col, player):
        i = player - 1
        self.__rows[row][i] += 1
        self.__cols[col][i] += 1
        if row == col:
            self.__diagonal[i] += 1
        if col == len(self.__rows) - row - 1:
            self.__anti_diagonal[i] += 1
        if any(self.__rows[row][i] == self.__size,
               self.__cols[col][i] == self.__size,
               self.__diagonal[i] == self.__size,
               self.__anti_diagonal[i] == self.__size):
            return player

        return 0",O(1)
"n,m = map(int,input().split())
mat = []

for i in range(n):
    mat.append(list(map(int,input().replace(""*"",""1"").replace(""."",""0""))))

ver,hor = [[0 for i in range(m)] for j in range(n)],[[0 for i in range(m)] for j in range(n)]

dp = [[[0 for i in range(4)]for j in range(m) ] for k in range(n)]
for i in range(1,n):
    for j in range(1,m):
        x,y = n-i-1,m-j-1
        if mat[i][j]==1:
            dp[i][j][0] = max(dp[i][j-1][0],mat[i][j-1]) + 1
            dp[i][j][1] = max(dp[i-1][j][1],mat[i-1][j]) + 1
        if mat[x][y]==1:
            dp[x][y][2] = max(dp[x][y+1][2],mat[x][y+1]) + 1
            dp[x][y][3] = max(dp[x+1][y][3],mat[x+1][y]) + 1

stars = []
for i in range(1,n-1):
    for j in range(1,m-1):
        if mat[i][j]==1:
            s = min(dp[i][j])-1
            if s>0:
                stars.append((i+1,j+1,s))
                ver[i-s][j]+=1
                if i+s+1<n:
                    ver[i+s+1][j] -= 1
                hor[i][j-s]+=1
                if j+s+1<m:
                    hor[i][j+s+1] -= 1

for i in range(1,n):
    for j in range(1,m):
        ver[i][j] += ver[i-1][j]
        hor[i][j] += hor[i][j-1]

chk = True
for i in range(n):
    for j in range(m):
        if mat[i][j] and max(ver[i][j],hor[i][j])<=0:
            chk=False
            break

if chk:
    print(len(stars))
    for i in stars:
        print(*i)
else:
    print(-1)",O(n ^ 2)
"n = int(input())
d = []
for i in range(n):
    xx, ww = [int(i) for i in input().split()]
    d.append([xx-ww, xx+ww])
d.sort(key=lambda x:x[0])
last = -100000000000
ans = 0
for i in range(n):
    if last <= d[i][0]:
        last = d[i][1]
        ans += 1
    elif last > d[i][1]:
        last = d[i][1]
print(ans)
",O(nlogn)
"import os
import sys
from math import *
from collections import *

from bisect import *
from io import BytesIO, IOBase

def vsInput():
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA = ""abcdefghijklmnopqrstuvwxyz/""
M = 1000000007
EPS = 1e-6

def Ceil(a, b):
    return a // b + int(a % b > 0)

def value():
    return tuple(map(int, input().split()))

def array():
    return [int(i) for i in input().split()]

def Int():
    return int(input())

def Str():
    return input()

def arrayS():
    return [i for i in input().split()]

n=int(input())
a=list(map(int,input().split("" "")))
dic=defaultdict(lambda:0)
cursum=0
ans=0
for i in range(n):
    ele=a[i]
    if ele-1 in dic.keys() and ele+1 in dic.keys():
        ans+=ele*(i-dic[ele-1]-dic[ele+1])-(cursum-(dic[ele-1]*(ele-1)+dic[ele+1]*(ele+1)))
    elif ele-1 in dic.keys():
        ans+=ele*(i-dic[ele-1])-(cursum-(dic[ele-1]*(ele-1)))
    elif ele+1 in dic.keys():
        ans+=ele*(i-dic[ele+1])-(cursum-(dic[ele+1]*(ele+1)))
    else:
        ans+=(ele*i-cursum)
    dic[ele]+=1
    cursum+=ele
print(ans)
",O(nlogn)
"class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [[0] * 2 for _ in range(n)]
        dp[n - 1][1] = dp[n - 1][0] = nums[n - 1]
        for i in range(n - 2, -1, -1):
            dp[i][1] = max(nums[i], nums[i] + dp[i + 1][1])
            dp[i][0] = max(dp[i + 1][0], dp[i][1])

        return dp[0][0]
",O(n)
"a = input()
b = input()
la = [int(x) for x in a]
res = []
la.sort()
la = la[::-1]
lb = [int(x) for x in b]
cnt = [0] * 20

def check():
    tres = 0
    for x in range(len(res)):
        tres *= 10
        tres += int(res[x])
    return tres <= int(b)
if len(a) < len(b):
    for i in range(len(la)):
        print(la[i], end = '')
    print()
else:
    for i in range(len(la)):
        cnt[la[i]] += 1
    flag = 0
    for i in range(len(lb)):
        if flag == 0 and cnt[lb[i]]:
            res.append(lb[i])
            cnt[lb[i]] -= 1
        else:
            flag = i - 1
            for j in range(lb[i] - 1, -1, -1):
                if cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
                    break
            for j in range(9, -1, -1):
                while cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
            break
    while not check():
        temp = []
        cnt = [0] * 20
        for x in range(flag):
            temp.append(res[x])
            cnt[res[x]] -= 1
        for i in la:
            cnt[i] += 1

        res = temp

        for v in range(lb[flag] - 1, -1, -1):
            if cnt[v]:
                res.append(v)
                cnt[v] -= 1
                break
        for v in range(9, -1, -1):
            while cnt[v]:
                res.append(v)
                cnt[v] -= 1

        flag -= 1
    for i in range(len(res)):
        print(res[i], end = '')
    print()
",O(n ^ 3)
"import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
def power(a,b,z):
    if b==0:
        return 1
    temp=power(a,b//2,z)
    if b%2==0:
        return (temp*temp)%z
    return (a*temp*temp)%z
x,k=list(map(int,input().split()))
if x==0:
    print(0)
else:
    z=(10**9)+7
    n=(power(2,k+1,z)*x)%z
    m=power(2,k,z)
    print((n-m+1)%z)",O(logn)
"import io,os

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
n,m=map(lambda x:int(x), input().split())
A = []
for _ in range(n):
    scores = list(map(lambda x:int(x), input().split()))
    A.append(scores)

def solve(n,m,A):

    ans = ()
    nstats = 2**m
    def judge(finalScore):
        nonlocal ans
        seen = {}
        for i,scores in enumerate(A):
            sta = 0
            for e in scores:
                sta=sta*2+(e>=finalScore)

            seen[sta]=i

        for i in range(nstats):
            for j in range(nstats):
                if ((i|j) == nstats-1) and i in seen and j in seen:
                    ans = (seen[i], seen[j])
                    return True

        return False

    l=0
    r=2**31-1
    while l<r:
        m=l+(r-l)//2
        if not judge(m):
            r=m
        else:
            l=m+1

    print(ans[0]+1,ans[1]+1)

solve(n,m,A)
",np
"a, b = list(map(int,input().split()))
l = 0
r = a + 1
while r - l > 1:
    m = (r + l) // 2

    if m * (m + 1) // 2 - (a - m) > b:
        r = m
    else:
        l = m
print(a - l)",O(logn)
"x,y,z=map(int,input().split())
l=list(map(int,input().split()))
l.sort()
c=0
s=z
t=False
while s<y and c<x:
    c+=1
    s=s+l[x-c]-1
if s<y:
    print(-1)
else:
    print(c)
",O(nlogn)
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []

    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)

    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)

    return powerset_orderred
def fastPlrintNextLines(a):

    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")

t = 1

for _ in range(t):
    n,k = li()
    s = list(si())
    cnt = 0
    ans = []
    covered = 0
    for i in range(n):
        if (s[i]=='('):
            cnt+=1
            ans.append('(')
        else:
            ans.append(')')
            covered+=1
        if cnt==k//2:
            break
    ans+=[')']*(k//2-covered)
    print(''.join(ans))",O(n)
"import sys

n, q = map(int, input().split())
top = len(bin(n >> 1)) - 2
ans = [1] * q

for i in range(q):
    v = int(input())
    s = input()
    if n == 1:
        continue
    for h in range(top+1):
        if v & (1 << h):
            break

    for c in s:
        if h == top and c == 'U' or h == 0 and c != 'U':
            continue
        if c == 'U':
            v -= 1 << h
            h += 1
            v |= 1 << h
        elif c == 'L':
            v -= 1 << h
            h -= 1
            v |= 1 << h
        else:
            h -= 1
            v |= 1 << h
    ans[i] = v

print(*ans, sep='\n')
",np
"n, s = int(input()), input() * 2
h = s.count('H') // 2
print(h - max(s[i:i + h].count('H') for i in range(n)))",O(n)
"n,least,most,x = map(int,input().split())
c = list(map(int,input().split()))

ans= 0
_max = lambda x,y: x if x>y else y
_min = lambda x,y: x if x<y else y

for mask in range(1<<n):
    mx = float('-inf')
    mn = float('inf')
    count = 0
    Sum = 0
    for i in range(n):
        if mask&(1<<i):
            count+=1
            Sum+=c[i]
            mx = _max(mx,c[i])
            mn = _min(mn,c[i])
    if mx-mn>=x and Sum>=least and Sum<=most and count >=2:
        ans+=1
print(ans)
",np
"class Solution(object):
    def minimumSum(self, nums):
        INF = float(""inf"")

        right = [INF]*len(nums)
        curr = INF
        for i in reversed(range(len(nums))):
            right[i] = curr
            curr = min(curr, nums[i])
        result = curr = INF
        for i in range(len(nums)):
            if curr < nums[i] > right[i]:
                result = min(result, curr+nums[i]+right[i])
            curr = min(curr, nums[i])
        return result if result != INF else -1",O(n)
"__author__ = 'ruckus'

n = int(input())
s = input()
t = input()
dif = {}
hem = 0
for i in range(n):
    if s[i] != t[i]:
        dif[i] = [s[i], t[i]]
        hem += 1

change = []
probed = []
k = 0
for i in dif.keys():
    if dif[i] in probed:
        continue
    probed.append(dif[i])
    k += 1
    for j in list(dif.keys())[k:]:
        if dif[i] == dif[j][::-1]:
            print(hem - 2)
            print(i + 1, j + 1)
            quit()
        if not change and (dif[i][0] == dif[j][1] or dif[j][0] == dif[i][1]):
            change = [i, j]

if change:
    print(hem - 1)
    print(change[0] + 1, change[1] + 1)
else:
    print(hem)
    print('-1 -1')",O(n)
"class Solution(object):
    def numWays(self, n, k):
        if n == 0:
            return 0
        elif n == 1:
            return k
        ways = [0] * 3
        ways[0] = k
        ways[1] = (k - 1) * ways[0] + k
        for i in range(2, n):
            ways[i % 3] = (k - 1) * (ways[(i - 1) % 3] + ways[(i - 2) % 3])
        return ways[(n - 1) % 3]",O(n)
"import os
import sys
from io import BytesIO, IOBase

def main():
    n,m,k=map(int,input().split())
    left=[list(map(int,input().split())) for _ in range(n)]
    down=[list(map(int,input().split())) for _ in range(n-1)]
    dp=[[(-1 if k&1 else 0) for _ in range(m)] for _ in range(n)]
    if k&1==0:
        for l in range(k//2):
            dp1=[[10**8 for _ in range(m)] for _ in range(n)]
            for i in range(n):
                for j in range(m):
                    if j>0:
                        dp1[i][j]=min(dp1[i][j],dp[i][j-1]+2*left[i][j-1])
                    if j<m-1:
                        dp1[i][j]=min(dp1[i][j],dp[i][j+1]+2*left[i][j])
                    if i>0:
                        dp1[i][j]=min(dp1[i][j],dp[i-1][j]+2*down[i-1][j])
                    if i<n-1:
                        dp1[i][j]=min(dp1[i][j],dp[i+1][j]+2*down[i][j])
            dp=dp1
    for i in dp:
        print(*i)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"import math
def sportMafia(n,k):
    r=round(n+1.5-math.sqrt(2*(n+k)+2.75))
    return r

n,k = map(int,input().split())
print(sportMafia(n,k))
",O(logn)
"import sys,os,io
from math import log, gcd
from collections import defaultdict, deque
from heapq import heappush, heappop

def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res

def si():
    return input()

def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r

def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1

def ii():
    return int(input())

def li():
    return list(map(int,input().split()))

t = 1
for _ in range(t):
    n = ii()
    l = li()
    l1 = l[:]
    l1.sort()
    pos = []
    for i in range(n):
        if (l1[i]!=l[i]):
            pos.append(i)
    if (len(pos)==0) or (len(pos)==2 and l[pos[0]]==l1[pos[1]] and l[pos[1]]==l1[pos[0]]):
        print(""YES"")
    else:
        print(""NO"")
",O(nlogn)
"n = int(input())

if n<6:
	print(-1)
else:
	print(""1 2\n1 3\n1 4"")
	for i in range(5,n+1):
		print('2 '+str(i))
for i in range(2, n+1):
	print('1 '+str(i))",O(n)
"class Solution(object):
    def newInteger(self, n):
        result, base = 0, 1
        while n > 0:
            result += (n%9) * base
            n /= 9
            base *= 10
        return result",O(logn)
"class Solution(object):
    def separateSquares(self, squares):
        class SegmentTreeRecu(object):
            def __init__(self, sorted_x):
                self.sorted_x = sorted_x
                n = len(sorted_x)-1
                l = 1<<((n-1).bit_length()+1)
                self.tree = [0]*l
                self.cnt = [0]*l
        
            def update(self, ql, qr, v, l, r, i): 
                if ql >= r or qr <= l:
                    return
                if ql <= l and r <= qr:
                    self.cnt[i] += v
                else:
                    m = l+(r-l)//2
                    self.update(ql, qr, v, l, m, 2*i)
                    self.update(ql, qr, v, m, r, 2*i+1)
                if self.cnt[i] > 0:
                    self.tree[i] = self.sorted_x[r]-self.sorted_x[l]
                else:
                    if r-l == 1:
                        self.tree[i] = 0
                    else:
                        self.tree[i] = self.tree[2*i]+self.tree[2*i+1]
    
        events = []
        x_set = set()
        for x, y, l in squares:
            events.append((y, 1, x, x+l))
            events.append((y+l, -1, x, x+l))
            x_set.add(x)
            x_set.add(x+l)
        events.sort(key=lambda e: e[0])
        sorted_x = sorted(x_set) 
        x_to_idx = {x:i for i, x in enumerate(sorted_x)}
        st = SegmentTreeRecu(sorted_x)
        prev = events[0][0]
        intervals = []
        for y, v, x1, x2 in events:
            if y != prev:
                intervals.append([prev, y, st.tree[1]])
                prev = y
            st.update(x_to_idx[x1], x_to_idx[x2], v, 0, len(sorted_x)-1, 1)
        expect = sum((y2-y1)*curr for y1, y2, curr in intervals)/2.0
        total = 0.0
        for y1, y2, curr in intervals:
            if total+(y2-y1)*curr >= expect:
                break
            total += (y2-y1)*curr
        return y1+(expect-total)/curr",O(nlogn)
"input_1 = input()
input_2 = input()

line_1 = [i for i in str(input_1)]
line_2 = [i for i in str(input_2)]

no = 0
for i in range(len(line_1) - 1):
    if line_1[i] != 'X' and line_2[i] != 'X':
        if line_1[i + 1] != 'X':
            no += 1
            line_1[i] = 'X'
            line_2[i] = 'X'
            line_1[i + 1] = 'X'

        elif line_2[i + 1] != 'X':
            no += 1
            line_1[i] = 'X'
            line_2[i] = 'X'
            line_2[i + 1] = 'X'

    elif line_1[i] != 'X' and line_1[i + 1] != 'X' and line_2[i + 1] != 'X':
        no += 1
        line_1[i] = 'X'
        line_1[i + 1] = 'X'
        line_2[i + 1] = 'X'

    elif line_2[i] != 'X' and line_1[i + 1] != 'X' and line_2[i + 1] != 'X':
        no += 1
        line_2[i] = 'X'
        line_1[i + 1] = 'X'
        line_2[i + 1] = 'X'

print(no)
",O(1)
"from heapq import *

MSIZE = 1 << 8
def GetVal(s):
    ans = 0
    for i in range(8):
        if s[i] == '1':
            ans = ans + (1 << i)
    return ans

def GetNot(s):
    return MSIZE - 1 - s;

xVal = GetVal('00001111')
yVal = GetVal('00110011')
zVal = GetVal('01010101')

def Dijkstra():
    depth = [['Z' * 585 for i in range(4)] for i in range(MSIZE)]
    depth[xVal][3] = 'x'
    depth[yVal][3] = 'y'
    depth[zVal][3] = 'z'

    pq = []
    def push(kek):
        heappush(pq, kek)
    def pop():
        return heappop(pq)
    push([1, xVal, 3])
    push([1, yVal, 3])
    push([1, zVal, 3])
    while len(pq) > 0:
        l, i, j = pop();
        if len(depth[i][j]) < l: continue
        for x in range(MSIZE):
            for y in range(4):
                nxt1 = depth[i][j] + '|' + depth[x][y]
                nxt2 = depth[x][y] + '|' + depth[i][j]
                nxt = min(nxt1, nxt2)
                val = (i | x)
                if len(depth[val][0]) == len(nxt) and depth[val][0] > nxt:
                    depth[val][0] = nxt
                    push([len(nxt), val, 0])
                elif len(depth[val][0]) > len(nxt):
                    depth[val][0] = nxt
                    push([len(nxt), val, 0])
        if j > 0:
            for x in range(MSIZE):
                for y in range(1, 4):
                    nxt1 = depth[i][j] + '&' + depth[x][y]
                    nxt2 = depth[x][y] + '&' + depth[i][j]
                    nxt = min(nxt1, nxt2)
                    val = (i & x)
                    if len(depth[val][1]) == len(nxt) and depth[val][1] > nxt:
                        depth[val][1] = nxt
                        push([len(nxt), val, 1])
                    elif len(depth[val][1]) > len(nxt):
                        depth[val][1] = nxt
                        push([len(nxt), val, 1])
        if j > 2:
            val = GetNot(i)
            nxt = '!' + depth[i][j]
            if len(depth[val][2]) == len(nxt) and depth[val][2] > nxt:
                depth[val][2] = nxt
                push([len(nxt), val, 2])
            elif len(depth[val][2]) > len(nxt):
                depth[val][2] = nxt
                push([len(nxt), val, 2])
        nxt = '(' + depth[i][j] + ')'
        val = i
        if len(depth[val][3]) == len(nxt) and depth[val][3] > nxt:
            depth[val][3] = nxt
            push([len(nxt), val, 3])
        elif len(depth[val][3]) > len(nxt):
            depth[val][3] = nxt
            push([len(nxt), val, 3])
    answer = []
    for i in range(MSIZE):
        ans = 'Z' * 585
        for j in range(4):
            if len(ans) > len(depth[i][j]):
                ans = depth[i][j]
            elif len(ans) == len(depth[i][j]) and ans > depth[i][j]:
                ans = depth[i][j]
        answer.append(ans)
    return answer
kek = Dijkstra()

q = int(input())
for i in range(q):
    print(kek[GetVal(input())])",O(n ^ 2)
"X, K = map(int, input().split())
mod = 1000000007
res = X*pow(2, K+1, mod)-pow(2, K, mod)+1;
while(res < 0):
   res += mod
if(X == 0):
   print(0)
else:
   print(res%mod)",O(logn)
"import collections



class Solution(object):
    def countInterestingSubarrays(self, nums, modulo, k):
        cnt = collections.Counter([0])
        result = prefix = 0
        for x in nums:
            if x%modulo == k:
                prefix = (prefix+1)%modulo
            result += cnt[(prefix-k)%modulo]
            cnt[prefix] += 1
        return result",O(n)
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

def solve(x , arr ):

    n = len(arr)
    flag = True
    k = []
    i = 0
    while flag:
        sm = 0
        while n > 0 and sm < x :
            sm += int(arr[i])
            i +=1
            n -=1
            if n <= 0 :
                flag = False
                break
        if sm>0:
            k.append(sm)

    return k

n = INT()
s = STR()

if len(set(s)) == 1 :
    print('YES');exit(0)

l = []
t = 0
for i in range(n-1):
    t += int(s[i])
    l.append(t)

v = []
for i in l :
    if i > 0 :
        r = solve(i , s)
        if len(r) > 1 and len(set(r)) == 1 :
            print('YES')
            break
else:
    print('NO')
",O(n ^ 2)
"class Solution(object):
    def minFlipsMonoIncr(self, S):
        flip0, flip1 = 0, 0
        for c in S:
            flip0 += int(c == '1')
            flip1 = min(flip0, flip1 + int(c == '0'))
        return flip1",O(n)
"class Solution(object):
    def stoneGameIII(self, stoneValue):
        dp = [float(""-inf"")]*3
        dp[len(stoneValue)%3] = 0
        for i in reversed(range(len(stoneValue))):
            max_dp, curr = float(""-inf""), 0
            for j in range(min(3, len(stoneValue)-i)):
                curr += stoneValue[i+j]
                max_dp = max(max_dp, curr-dp[(i+j+1)%3])
            dp[i%3] = max_dp
        return [""Tie"", ""Alice"", ""Bob""][cmp(dp[0], 0)]",O(n)
"n, k = map(int, input().split())
v = list(map(int, input().split()))

d = {}
ans = 0

for x in v:
  num_d, mod_k = len(str(x)), x % k
  d.setdefault(num_d, {}).setdefault(mod_k, []).append(x)

for x in v:
  num_d, mod_k = len(str(x)), x % k
  for add, mods in d.items():
    val_mod = (mod_k * 10 ** add) % k
    need_mod = (k - val_mod) % k
    ans += len(mods.get(need_mod, []))
    if need_mod == mod_k and add == num_d:
      ans -= 1

print(ans)
",O(nlogn)
"n, k = [int(x) for x in input().split()]

ps = [int(x) for x in input().split()]

mapping = [-1 for _ in range(256)]

res = []
for p in ps:
    if mapping[p] == -1:
        j = p - k + 1
        while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p):
            j += 1
        for i in range(j, p+1):
            mapping[i] = j

    res.append(mapping[p])
print("" "".join(map(str, res)))
",O(n ^ 2)
"n, v = map(int, input().split())

result = v-1 + (n-v)*(n-v+1)//2 if n-1 > v else n-1
print(result)",O(1)
"n=int(input())
l=[input() for i in range(n)]

s=sorted(l,key=len)
for i in range(1,n):
    if s[i-1] not in s[i]:
        print(""NO"")
        exit()

print(""YES"")
for i in s:
    print(i)
",O(nlogn)
"t = int(input())

def sol(n, k):
    p = 1
    acc = 0
    while n > 0 and k >= p:
        k -= p
        n -= 1
        if n >= 40:
            return n
        acc += (2*p-1)*(4**n-1)//3
        if k <= acc:
            return n
        p = 2*p+1
    return -1

for _ in range(t):
    n, k = (int(v) for v in input().split())
    ans = sol(n, k)
    if ans == -1:
        print(""NO"")
    else:
        print(""YES"", ans)",O(logn)
"class Solution(object):
    def longestAlternatingSubarray(self, nums, threshold):
        result = l = 0
        for x in nums:
            if x > threshold:
                l = 0
                continue
            if l%2 == x%2:
                l += 1
            else:
                l = int(x%2 == 0)
            result = max(result, l)
        return result",O(n)
"vals=list(map(int,input().split()))
l=vals[0]
r=vals[1]

if l==r:
    print(""0"")
else:
    i=0
    j=0
    while l>0 or r>0:
        i+=1
        if (l&1)^(r&1)==1:
            j=i
        l=l>>1
        r=r>>1
    ans=1
    for i in range(0,j):
        ans=ans*2
    ans-=1
    print(ans)",O(logn)
"import bisect


class Solution(object):
    def findRightInterval(self, intervals):
        sorted_intervals = sorted((interval.start, i) for i, interval in enumerate(intervals))
        result = []
        for interval in intervals:
            idx = bisect.bisect_left(sorted_intervals, (interval.end,))
            result.append(sorted_intervals[idx][1] if idx < len(sorted_intervals) else -1)
        return result",O(nlogn)
"class Solution(object):
    def getRow(self, rowIndex):
        result = [0] * (rowIndex + 1)
        for i in range(rowIndex + 1):
            old = result[0] = 1
            for j in range(1, i + 1):
                old, result[j] = result[j], old + result[j]
        return result

    def getRow2(self, rowIndex):
        row = [1]
        for _ in range(rowIndex):
            row = [x + y for x, y in zip([0] + row, row + [0])]
        return row

    def getRow3(self, rowIndex):
        if rowIndex == 0: return [1]
        res = [1, 1]

        def add(nums):
            res = nums[:1]
            for i, j in enumerate(nums):
                if i < len(nums) - 1:
                    res += [nums[i] + nums[i + 1]]
            res += nums[:1]
            return res

        while res[1] < rowIndex:
            res = add(res)
        return res",O(n ^ 2)
"import math

v = [int(x) for x in input().split()]
n = len(v)
val = 0
for i in range(n):
    a = v[i] // n
    arr = v.copy()
    arr[i] = 0
    for j in range(n):
        arr[j] += a
    b = v[i] % n
    k = i + 1
    l = 0
    while l < b:
        if k > n - 1:
            k = 0
        arr[k] += 1
        k += 1
        l += 1

    count = 0
    for j in range(n):
        if arr[j] % 2 == 0:
            count += arr[j]
    val = max(val, count)
print(val)
",O(1)
"import sys,os,io
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from sys import stdin

import math

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2

    for i in range(3,int(math.sqrt(n))+1,2):

        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res

def si():
    return input()

def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r

def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1

def ii():
    return int(input())

def li():
    return list(map(int,input().split()))

def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")

t = 1
for _ in range(t):
    s = si()
    s = s*3
    m = 0
    c = 1
    for i in range(1,len(s)):
        if (s[i]!=s[i-1]):
            c+=1
        else:
            m = max(m,c)
            c = 1
    m = max(m,c)

    m = min(m,len(s)//3)
    print(m)",O(n)
"from sys import stdin,stdout
from collections import Counter
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
def pos(n):
    t=0
    for k,v in d.items():
        if v>=n:t+=v//n
    return t>=p
for _ in range(1):
    p,n=lst()
    d=Counter(lst())
    ans=0
    for sel in range(1,n+1):
         if pos(sel):ans=max(ans,sel)
    print(ans)",O(nlogn)
"a=input()
b=input()
na=len(a)
nb=len(b)
def fs(a,b):
	try:
		for i in range(a+1,len(b)):
			if b[a]>b[i]:
				ans=b[i]
				k=b.copy()
				k.pop(i)
				ans+="""".join(k)
				return ans
		return False
	except:
		return False
if(na<nb):
	print("""".join(sorted(list(a),reverse=True)))
else:
	if(a==b):
		print(a)

	else:
		l=sorted(list(a),reverse=True)
		l2=l.copy()
		ans1=""""
		flag=0
		ans=[]
		for i in b:
			for j in range(len(l)):
				if i==l[j]:
					k=fs(j,l)
					if(k!=False):
						ans.append(ans1+fs(j,l))
					ans1+=l[j]
					l.pop(j)
					break
				if i>l[j]:
					ans1+=l[j]
					l.pop(j)
					flag=1
					break
			if(flag==1):
				break
		ans1+="""".join(l)
		if(int(ans1)<=int(b)):
			print(ans1)
		else:
			for i in sorted([int(i) for i in ans],reverse=True):
				if(i<=int(b)):
					print(i)
					break
",O(n ^ 3)
"import sys
input=sys.stdin.readline
n,m,k=map(int,input().strip().split("" ""))

lr=[]
for i in range(n):
	lr.append([100000001]+list(map(int,input().strip().split("" "")))+[100000001])
ud=[[100000001]*m]
for i in range(n-1):
	ud.append(list(map(int,input().strip().split("" ""))))
ud.append([100000001]*m)
o=[[1000000001]*(m+2)]
from copy import deepcopy
if k%2:
	for i in range(n):
		sys.stdout.write("" "".join([""-1""]*m)+""\n"")
	sys.exit()
for _ in range(n):
	oo=[100000001]
	for _ in range(m):
		oo.append(0)
	oo.append(100000001)
	o.append(oo)
o.append([100000001]*(m+2))
for _ in range(k//2):
	oo=deepcopy(o)
	for i in range(1,n+1):
		for j in range(1,m+1):
			oo[i][j]=min(lr[i-1][j-1]+o[i][j-1],lr[i-1][j]+o[i][j+1],ud[i-1][j-1]+o[i-1][j],ud[i][j-1]+o[i+1][j])
	o=deepcopy(oo)
for i in o[1:n+1]:
	sys.stdout.write("" "".join(map(str,[j*2 for j in i[1:m+1]]))+""\n"")
",O(n ^ 3)
"from sys import stdin

def quadratic(a, b, c):
    num = (b * b) - (4 * a * c)
    if num >= 0:
        return [(-b + (num ** .5)) / (2.0 * a), (-b - (num ** .5)) / (2.0 * a)]
    else:
        return [.5, .5]

n, k = map(int, stdin.readline().split())
for root in quadratic(1, 3, -2 * n - 2 * k):
    ans = n - root
    if ans > -1:
        print(int(ans))
        exit()
",O(logn)
"n,l,r,x = map(int,input().split())
c = [int(i) for i in input().split()]
ans = 0
for bit in range(2,1<<n):
    probs = []
    t = 0
    for i in range(n):
        if bit&(1<<i):
            probs.append(c[i])
            t += c[i]

    a = min(probs)
    b = max(probs)

    if t >= l and t <= r and abs(a-b) >= x:
        ans += 1
print(ans)",np
"import collections



class Solution(object):
    def distinctSubarraysWithAtMostKOddIntegers(self, A, K):
        def countDistinct(A, left, right, trie): 
            result = 0
            for i in reversed(range(left, right+1)):
                if A[i] not in trie:
                    result += 1
                trie = trie[A[i]]
            return result

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result, left, count = 0, 0, 0
        for right in range(len(A)):
            count += A[right]%2
            while count > K:
                count -= A[left]%2
                left += 1
            result += countDistinct(A, left, right, trie)
        return result",O(n ^ 2)
"def f(ch):
    if ch=='0':
        return 0
    else:
        return 1

U=[ [f(i) for i in list(input())],
    [f(i) for i in list(input())]]
i=0
size=len(U[0])
ans=0
while i+1<size:
    if U[0][i]+U[0][i+1]+U[1][i]+U[1][i+1]>1:
        i+=1
        continue
    elif U[0][i]+U[0][i+1]+U[1][i]+U[1][i+1]==1:
        U[0][i]=1
        U[0][i+1]=1
        U[1][i]=1
        U[1][i+1]=1
        ans+=1
    else:
        U[0][i]=1
        U[0][i+1]=1
        U[1][i]=1
        ans+=1

    i+=1

print(ans)
",O(1)
"l,r=map(int,input().split())
r1=len(bin(r))-3
l1=len(bin(l))-3
ans=0
while(l>0):
    if l1==r1:
        r-=(1<<l1)
        l-=(1<<l1)
    else:
        ans=(1<<(r1+1))-1
        break

    z1=min(l,r)
    z2=max(l,r)
    l,r=z1,z2
    r1 = len(bin(r)) - 3
    l1 = len(bin(l)) - 3

if ans==0:
    if l1==r1:
        if r==1:
            print(1)
        else:
            print(0)
    else:
        print((1<<(r1+1))-1)

else:
    print(ans)
",O(logn)
"class Node(object):
    def __init__(self, val=0, left=None, right=None, next=None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next


class Solution(object):
    def connect(self, root):
        head = root
        pre = Node(0)
        cur = pre
        while root:
            while root:
                if root.left:
                    cur.next = root.left
                    cur = cur.__next__
                if root.right:
                    cur.next = root.right
                    cur = cur.__next__
                root = root.__next__
            root, cur = pre.__next__, pre
            cur.next = None
        return head",O(n)
"casas, tubos = map(int, input().strip().split())

def bs(c, t):
    l, r = 0, t-1
    while l <= r:
        mid = l+r >> 1
        if ((2*t - mid - 1)*mid)//2+1 < c:
            l = mid+1
        else:
            r = mid-1
    return r+1

res = bs(casas, tubos)
print(-1 if res == tubos else res)
",O(logn)
"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        if not digits:
            return [1]

        if digits[-1] < 9:
            digits[-1] += 1
            return digits
        else:
            return self.plusOne(digits[:-1]) + [0]
",O(n)
"t = int(input())

for i in range(0, t) :
    n, k = [int(x) for x in input().split()]
    if (n >= 32) :
        print(""YES %d"" % (n-1))
    else :
        low=0
        co=-1
        md = [0]
        for j in range(1, n):
            md.append(md[-1]*4 + 1)
        kk = 0
        found=0
        for cut in range(1,n+1) :
            low += (1<<cut)-1
            co = 2*co + 3
            kk += co*md[n-cut]
            if (k>=low and k<=low+kk) :
                print(""YES %d"" % (n-cut))
                found=1
                break
        if (found == 0) : print(""NO"")
",O(logn)
"M=10**9+7
def pw(x,y):
	r=1
	x=x%M
	while y:
		if y&1:
			r=(r*x)%M
		y=y>>1
		x=(x*x)%M
	return r
x,k=map(int,input().split())
ans=pw(2,k+1)*x-pw(2,k)+1+M
if x==0:
	ans=0
print(ans%M)
",O(logn)
"class Solution(object):
    def parseTernary(self, expression):
        if not expression:
            return """"

        stack = []
        for c in expression[::-1]:
            if stack and stack[-1] == '?':
                stack.pop() 
                first = stack.pop()
                stack.pop() 
                second = stack.pop()

                if c == 'T':
                    stack.append(first)
                else:
                    stack.append(second)
            else:
                stack.append(c)


        return str(stack[-1])",O(n)
"yellow, blue = map(int, input().split())
x, y, z = map(int, input().split())
answer1 = x*2+y-yellow
answer2 = z*3+y - blue
if answer1 > 0:
    if answer2 > 0:
        print(answer1+answer2)
    else:
        print(answer1)
else:
    if answer2 > 0:
        print(answer2)
    else:
        print(0)
",O(1)
"chores = [int(x) for x in input().split()]
complexity = [int(x) for x in input().split()]
complexity.sort()
print(complexity[chores[2]]-complexity[chores[2]-1])
",O(nlogn)
"def main():
    pieces_Dimension = int(input())
    piece1 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece2 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece3 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece4 = ''.join(input() for _ in range(pieces_Dimension))

    brokenPieces = (piece1, piece2, piece3, piece4)
    nSquares = pieces_Dimension*pieces_Dimension
    squares = '01'*-(-nSquares//2)

    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)

def nSquaresToRecolorIn(brokenPieces, nSquares, squares):
    possible_nSquares = [(sum(piece[i] != squares[:-1][i] for i in range(nSquares)),
                          sum(piece[i] != squares[1:][i] for i in range(nSquares)))
                         for piece in brokenPieces]
    possible_nSquares.sort(key=lambda x: x[0])

    return possible_nSquares[0][0] + possible_nSquares[1][0] + possible_nSquares[2][1] + possible_nSquares[3][1]

if __name__ == '__main__':
    print(main())
",O(n ^ 2)
"class Solution(object):
    def smallestSubarrays(self, nums):
        result = [0]*len(nums)
        lookup = [-1]*max(max(nums).bit_length(), 1)
        for i in reversed(range(len(nums))):
            for bit in range(len(lookup)):
                if nums[i]&(1<<bit):
                    lookup[bit] = i
            result[i] = max(max(lookup)-i+1, 1)
        return result",O(n)
"l ,r = map(int,input().split())
for i in range(63,-1,-1):
    mx, mn= r,l
    if (1<<i)&l and (1<<i)&r :
        mx= (1<<i)-1
        mx= r^(1<<i)|mx
    elif ((1<<i)&l)==0 and ((1<<i)&r)==0 :
        mn = (1<<i)-1
        mn=(l&mn)^(l|(1<<i))
    if mx>=l and mx <=r and mn>=l and mn<=r:
        r,l=mx,mn
print(l^r)
",O(logn)
"import heapq
n,k = map(int,input().split())
P = list(map(int,input().split()))
C = list(map(int,input().split()))
X = []
for i in range(n):
    X.append([P[i],C[i],i])
X.sort(key = lambda x : x[0])
coins = []
heapq.heapify(coins)
curr = 0
res = [0 for i in range(n)]
for i in range(k):
    heapq.heappush(coins,X[i][1])
    curr += X[i][1]
    res[X[i][2]] = curr
for j in range(k,n):

    res[X[j][2]] = X[j][1] + sum(coins)
    if len(coins)>0:
        x = heapq.heappop(coins)
        if x < X[j][1]:
            heapq.heappush(coins,X[j][1])
        else:
            heapq.heappush(coins,x)

print(*res)",O(nlogn)
"n, k = map(int, input().split())

a, b, c = 0, k, 0

while a < b:
    c = (a + b) // 2
    if c * n < k:
        a = c + 1
    else:
        b = c

print(a)
",O(logn)
"def main():
    input()
    acc = {0: 0}
    for p, c in zip(list(map(int, input().split())),
                    list(map(int, input().split()))):
        adds = []
        for b, u in acc.items():
            a = p
            while b:
                a, b = b, a % b
            adds.append((a, u + c))
        for a, u in adds:
            acc[a] = min(u, acc.get(a, 1000000000))
    print(acc.get(1, -1))

if __name__ == '__main__':
    main()
",np
"from os import path
import sys
from heapq import heappush,heappop
from functools import cmp_to_key as ctk
from collections import deque,defaultdict as dd
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input().rstrip()
def mi():return map(int,input().split())
def li():return list(mi())
abc='abcdefghijklmnopqrstuvwxyz'

mod=998244353
inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]

def bo(i):
    return ord(i)-ord('a')

def sod(n):
    s = 0
    while n:
        s += (n%10)
        n //= 10
    return s

def solve():

    n,s = mi()

    def fun(mid):
        return mid - sod(mid) >= s

    l = 0
    r = n
    ans = -1
    while l <= r:
        m = l+(r-l)//2
        if fun(m):
            ans = m
            r = m-1
        else:
            l = m+1
    if ans == -1:
        ans = n+1
    print(n-ans+1)

if __name__ ==""__main__"":

    if path.exists('input.txt'):
        sys.stdin=open('input.txt', 'r')
        sys.stdout=open('output.txt','w')
    else:
        input=sys.stdin.readline
    solve()",O(logn)
"a,b = (map(int,input().split()))
print((b+a-1)//a)
",O(1)
"class Solution(object):
    def stringCount(self, n):
        MOD = 10**9 + 7
        return (
            pow(26, n, MOD)
            - (25 + 25 + 25 + n) * pow(25, n - 1, MOD)
            + (24 + 24 + 24 + n + n + 0) * pow(24, n - 1, MOD)
            - (23 + n + 0 + 0) * pow(23, n - 1, MOD)
        ) % MOD",O(logn)
"def func(n,i):
        if n==3:
                return (str(1*i)+' ')+(str(1*i)+' ')+(str(3*i))
        if n%2==0:
                odd=n//2
        else:
                odd=n//2+1
        q=1*i
        s= (str(q)+' ')*odd
        return s

from math import log
n=int(input())
if n==3:
        s='1 1 3'
else:
        s=''
        z=1
        while(n>0):
                s=s+func(n,z)
                z=z*2
                if n==3:
                        break
                if n%2==0:
                        odd=n//2
                else:
                        odd=n//2+1
                n=n-odd
print(s)
",O(logn)
"n, K = map(int, input().split())
mod = 998244353
if K == 1:
    print(2)
    exit()
dp = [[0]*(2**2) for i in range(K+1)]
dp[1][0] = 1
dp[2][1] = 1
dp[2][2] = 1
dp[1][3] = 1
for i in range(1, n):
    nx = [[0]*(2**2) for i in range(K+1)]
    for k in range(K+1):
        for j in range(4):
            if j == 0:
                nx[k][0] += dp[k][j]%mod
                if k+1 <= K:
                    nx[k+1][1] += dp[k][j]%mod
                    nx[k+1][2] += dp[k][j]%mod
                    nx[k+1][3] += dp[k][j]%mod
            elif j == 1:
                nx[k][0] += dp[k][j]%mod
                nx[k][1] += dp[k][j]%mod
                if k+2 <= K:
                    nx[k+2][2] += dp[k][j]%mod
                nx[k][3] += dp[k][j]%mod
            elif j == 2:
                nx[k][0] += dp[k][j]%mod
                if k+2 <= K:
                    nx[k+2][1] += dp[k][j]%mod
                nx[k][2] += dp[k][j]%mod
                nx[k][3] += dp[k][j]%mod
            else:
                if k+1 <= K:
                    nx[k+1][0] += dp[k][j]%mod
                    nx[k+1][1] += dp[k][j]%mod
                    nx[k+1][2] += dp[k][j]%mod
                nx[k][3] += dp[k][j]%mod
    dp = nx

print(sum(dp[K])%mod)
",np
"import os
import sys
from io import BytesIO, IOBase
import math

def main():
    l, r = map(int, input().split())
    for i in range(62, -1, -1):
        if ((1 << i) & l) ^ ((1 << i) & r):
            print((1 << (i+1)) - 1)
            break
    else:
        print(0)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",O(logn)
"n,m = map(int,input().split())
arr1 = list(map(int,input().split()))
arr2 = list(map(int,input().split()))

j = 0
for i in range(n):
    if j<m and arr2[j]>=arr1[i]:
        j+=1
print(j)
",O(n)
"class Solution2(object):
    def numberOfSpecialSubstrings(self, s):
        result = left = 0
        lookup = [False]*26
        for right in range(len(s)):
            while lookup[ord(s[right])-ord('a')]:
                lookup[ord(s[left])-ord('a')] = False
                left += 1
            lookup[ord(s[right])-ord('a')] = True
            result += (right-left+1)
        return result",O(n)
"import itertools


class Solution(object):
    def magicalString(self, n):
        def gen(): 
            for c in 1, 2, 2:
                yield c
            for i, c in enumerate(gen()):
                if i > 1:
                    for _ in range(c):
                        yield i % 2 + 1

        return sum(c & 1 for c in itertools.islice(gen(), n))",O(n)
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
ans = 0
for i in range(2, n):
    for j in range(2 * i, n + 1, i):
        ans += j // i
print(ans * 4)",O(nlogn)
"import sys
k=int(input())
if type(k)!=int or k<=0 or k>pow(10,12) :
        print(""wrong input. try again"")
        sys.exit()
lim_init=lim=decimal=9
c=0
while True:
        c+=1
        if k<=lim:
                diff=lim-k
                pos=diff%c
                diff=int(diff/c)
                diff=decimal-diff
                print(''.join(list(reversed(str(diff))))[pos])
                break
        else:
                decimal = int(str(lim_init)*(c+1))
                lim+=int(str(lim_init)+'0'*c)*(c+1)
",O(logn)
"T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889)
k = int(input())
a = 0
for i in T:
    if i - k > 0:
        a = T.index(i)
        break
temp = T[a] - k
x = temp % a
res = (10 ** a) - 1 - int(temp / a)
ans = int((res % (10 ** (x+1))) / (10 ** x))
print(ans)
",O(logn)
"class Solution(object):
    def getSmallestString(self, s, k):
        result = [ord(x)-ord('a') for x in s]
        for i in range(len(result)):
            d = min(result[i]-0, 26-result[i])
            result[i] = 0 if d <= k else result[i]-k
            k -= min(d, k)
            if k == 0:
                break
        return """".join([chr(x+ord('a')) for x in result])",O(n)
"import heapq
class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):
        min_heap = list(zip(startTime, endTime, profit))
        heapq.heapify(min_heap)
        result = 0
        while min_heap:
            s, e, p = heapq.heappop(min_heap)
            if s < e:
                heapq.heappush(min_heap, (e, s, result+p))
            else:
                result = max(result, p)
        return result",O(nlogn)
"n = int(input())
print(n**2 + (n-1)**2)
",O(1)
"class Solution3(object):
    def countDistinct(self, nums, k, p):
        MOD, P = 10**9+7, 200
        result = 0
        cnt, h = [0]*len(nums), [0]*len(nums)
        for l in range(1, len(nums)+1):
            lookup = set()
            for i in range(len(nums)-l+1):
                cnt[i] += (nums[i+l-1]%p == 0)
                if cnt[i] > k:
                    continue
                h[i] = (h[i]*P+nums[i+l-1])%MOD
                lookup.add(h[i])
            result += len(lookup)
        return result",O(n ^ 2)
"import collections
import heapq


class Solution(object):
    def highFive(self, items):
        min_heaps = collections.defaultdict(list)
        for i, val in items:
            heapq.heappush(min_heaps[i], val)
            if len(min_heaps[i]) > 5:
                heapq.heappop(min_heaps[i])
        return [[i, sum(min_heaps[i]) // len(min_heaps[i])] for i in sorted(min_heaps)]",O(nlogn)
"import sys

n, q = list(map(int,sys.stdin.readline().strip().split()))
a = list(map(int,sys.stdin.readline().strip().split()))
m = [0] * q

M = max(a)
i = 0
x = a[0]
L = []
L1 = []
L2 = []
while x != M:
    L1.append(x)
    L2.append(a[i+1])
    i = i + 1
    if x < a[i]:
        L.append(x)
        x = a[i]
    else:
        L.append(a[i])

b = a[i+1:] + L

for j in range (0, q):
    m = int(sys.stdin.readline().strip())
    if m <= i:
        print(str(L1[m-1]) + "" "" + str(L2[m-1]))
    else:
        print(str(x) + "" "" + str(b[(m - i - 1) % (n-1)]))
",O(n)
"class Solution(object):
    def longestConsecutive(self, root):
        self.max_len = 0

        def longestConsecutiveHelper(root):
            if not root:
                return 0

            left_len = longestConsecutiveHelper(root.left)
            right_len = longestConsecutiveHelper(root.right)

            cur_len = 1
            if root.left and root.left.val == root.val + 1:
                cur_len = max(cur_len, left_len + 1)
            if root.right and root.right.val == root.val + 1:
                cur_len = max(cur_len, right_len + 1)

            self.max_len = max(self.max_len, cur_len)

            return cur_len

        longestConsecutiveHelper(root)
        return self.max_len",O(n)
"import re

inputs = int(input())

for x in range(inputs):
    coordinates = input()
    match = re.match(""R(\d+)C(\d+)"", coordinates)
    if match:
        rows = int(match.group(1))
        columns = int(match.group(2))

        output = """"
        i = 0
        while columns > 0:
            alpha_index = (columns // (26 ** i) - 1) % 26
            output = chr(65 + alpha_index) + output

            columns -= (alpha_index + 1) * (26 ** i)
            i += 1
        output += str(rows)
        print(output)
    else:
        match = re.match(""(\D+)(\d+)"", coordinates)
        letters = match.group(1)
        rows = match.group(2)
        columns = 0
        for i in range(len(letters), 0, -1):
            columns += (ord(letters[i - 1]) - 64) * (26 ** (len(letters) - i))
        output = f""R{rows}C{columns}""
        print(output)
",O(n)
"n, k = [int(num) for num in input().split(' ')]
string = input()

def fn(string, k):
    maximum_match = 0
    for i in range(1, len(string)):
        if string[:i] == string[-i:]:
            maximum_match = i

    answer = list(string)
    extra = list(string[maximum_match:])
    for i in range(k-1):
        answer.extend(extra)

    return ''.join(answer)

print(fn(string, k))
",O(n ^ 2)
"x, y, z, t1, t2, t3 = map( int, input().split() )
elevator = t2 * ( abs( x - y ) + abs( z - x ) ) + 3 * t3
stairs = t1 * abs( x - y )
if elevator > stairs:
    print( 'NO' )
else:
    print( 'YES' )
",O(1)
"import sys
a = list(map(int, sys.stdin.readlines()[1][:-1].split()))
mx = 0
for i in range(len(a)):
	if a[i] > mx:
		print(i+1)
		sys.exit(0)
	mx = max(mx,a[i] + 1)
print(-1)",O(n)
"class Solution(object):
    def searchInsert(self, nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) / 2
            if nums[mid] >= target:
                right = mid - 1
            else:
                left = mid + 1

        return left",O(logn)
"import sys

input = sys.stdin.readline
def ii(): return int(input())
def mi(): return map(int, input().rstrip().split())
def lmi(): return list(map(int, input().rstrip().split()))
def li(): return list(input().rstrip())

if __name__ == '__main__':

    n,q = mi()
    a = lmi()
    i = 0
    max_a = max(a)
    t = a.index(max_a)
    last = a[0]
    Lis = []
    tmp = []
    for i in range(1, t + 1):
        Lis.append((last,a[i]))
        if last < a[i]:
            tmp.append(last)
            last = a[i]
        else:
            tmp.append(a[i])

    anslist = a[t+1:] + tmp

    for i in range(q):
        tm = ii()
        if 1 <= tm <= t:
            print(Lis[tm - 1][0],Lis[tm - 1][1])
        else:
            print(max_a,anslist[(tm-t-1)%len(anslist)])",O(n)
"class Solution(object):
    def getCommon(self, nums1, nums2):
        i = j = 0
        while i < len(nums1) and j < len(nums2):
            if nums1[i] < nums2[j]:
                i += 1
            elif nums1[i] > nums2[j]:
                j += 1
            else:
                return nums1[i]
        return -1",O(n)
"def suma(n):
    return n*(n+1)//2

def sumaij(i, j):
    if i <= 1:
        return suma(j)
    return suma(j) - suma(i-1)

def bin_search_solution(n, k):
    st, end = 1, k
    while st < end:
        mid = (st+end)//2
        s = sumaij(mid, k)
        if s == n:
            return k - mid + 1
        if s > n:
            st = mid + 1
        else:
            end = mid
    return k - st + 2

def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    elif k >= n:
        print(1)
    else:
        n -= 1
        k -= 1

        if suma(k) < n:
            print(-1)
        else:
            res = bin_search_solution(n, k)
            print(res)

if __name__ == '__main__':
    solve()
",O(logn)
"import sys
def main():
    pass
def binary(n):

    return (bin(n).replace(""0b"", """"))
def decimal(s):

    return (int(s, 2))
def pow2(n):

    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
def isPrime(n):

    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
def lts(l):

    s = ''.join(map(str, l))
    return s
def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()

def iinp(): return int(input())

def nninp(): return map(int, sys.stdin.readline().strip().split())

def llinp(): return list(map(int, sys.stdin.readline().strip().split()))

def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math
from collections import OrderedDict

n=iinp()
l=[]
s={""purple"",""green"",""blue"",""orange"",""red"",""yellow""}
for i in range(n):
    inp=ssinp()
    s.remove(inp)
print(6-n)
for i in s:
    if(i==""purple""):
        print(""Power"")
    elif(i==""green""):
        print(""Time"")
    elif(i==""blue""):
        print(""Space"")
    elif (i == ""orange""):
        print(""Soul"")
    elif (i == ""red""):
        print(""Reality"")
    else:
        print(""Mind"")
",O(1)
"l,r=map(int,input().split())
a=bin(l)
b=bin(r)
a=""0""*(len(b)-len(a))+a[2:len(a)]
b=b[2:len(b)]
c=[0 for i in range(len(a))]
flag=False
for i in range(len(a)):
    if(a[i]!=b[i]):
        flag=True
    if(flag):c[i]=1
ans=0
for j in range(len(a)):
    ans+=c[len(a)-1-j]*(2**(j))
print(ans)",O(logn)
"import functools
import time
from collections import Counter

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        pass

    def __call__(self):
        n, m = map(int, input().strip().split())
        a = list(map(int, input().strip().split()))
        h = Counter()
        for ai in a:
            h[ai] = h[ai] + 1 if ai in h else 1
        days = 0
        while True:
            tot = 0
            for key, cnt in h.items():
                tot += cnt // (days + 1)
            if tot < n:
                print(days)
                return
            days += 1

solver()()",O(nlogn)
"n = int(input())
a = [0] * (n+1) ; b = [0] * (n+1) ; c = [0] * (n+1)
for i in range(2, n+1):
    a[i] = int(input())
    b[a[i]] += 1
for i in range(1, n+1):
    if b[i] == 0:
        c[a[i]] += 1
for i in range(1, n+1):
    if b[i] != 0 and c[i] < 3:
        print(""NO"")
        exit()
print(""YES"")",O(n)
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n,m = inpl()
s = [inpsl(m) for _ in range(n)]
lampcnt = [0]*m
for i in range(n):
    for j in range(m):
        if s[i][j] == '1':
            lampcnt[j] += 1
res = False
for i in range(n):
    only = False
    for j in range(m):
        if s[i][j] == '1' and lampcnt[j] == 1:
            only = True
    if not only: res = True
print('YES' if res else 'NO')",O(n ^ 2)
"parent = [i for i in range(int(1e5 + 2))]
def findSet(u):
    if parent[u] != u:
        parent[u] = findSet(parent[u])
    return parent[u]

def unionSet(u, v):
    up = findSet(u)
    vp = findSet(v)
    parent[up] = vp

if __name__ == '__main__':
    n, a, b = map(int, input().split())
    lst = list(map(int, input().split()))
    temp = {lst[i]: i for i in range(n)}
    for i in range(n):
        if a - lst[i] in temp:
            unionSet(i, temp[a - lst[i]])
        else:
            unionSet(i, n)
        if b - lst[i] in temp:
            unionSet(i, temp[b - lst[i]])
        else:
            unionSet(i, n + 1)

    pa = findSet(n)
    pb = findSet(n + 1)
    if pa == pb:
        print('NO')
    else:
        print('YES')
        lst = [0 if findSet(i) == pb else 1 for i in range(n)]
        print(*lst)",O(n)
"n,m=[int(x) for x in input().split()]
a=[int(x) for x in input().split()]
s=sum(a)
need=0
a.sort()
j=1
flag=0
k=max(a)
if n==1:
    print(0)
else:
    for i in range(n):
        if a[i]<j:
            flag=1
        else:
            flag=0
        if a[i]==1:
            need+=1
        elif a[i]>=j and i!=n-1:
            need+=1
        elif a[i]>=j and i==n-1 and j<=k:
            need+=k-j+1
        else:
            need+=1
        if flag!=1:
            j+=1
    print(s-need)
",O(nlogn)
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort

from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal

INF = 10001
mod = int(1e9) + 7

def cal(l,r):
    if l==r:
        dp1[l][r]=a[l]
        dp3[l][r] = 1
        return dp1[l][r]
    if dp1[l][r]!=-1:
        return dp1[l][r]
    for i in range(l,r):
        if cal(l,i) == cal(i+1,r) != 0:
            dp1[l][r]=dp1[l][i]+1
            dp3[l][r]=1
        dp3[l][r]=min(dp3[l][r],dp3[l][i]+dp3[i+1][r])
    if dp1[l][r] == -1:
        dp1[l][r] = 0
    return dp1[l][r]

n=int(data())
a=mdata()
ans=[n]
dp1=[[-1]*n for i in range(n)]
dp3=[[10001]*n for i in range(n)]
cal(0,n-1)
out(dp3[0][n-1])",O(n ^ 3)
"x, k = (int(x) for x in input().split())
mod = 10**9 + 7
if x == 0:
    print(0)
    quit()
if k == 0:
    print(x * 2 % mod)
    quit()
ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod) - 1
ans %= mod
ans += mod
ans %= mod
print(ans)
",O(logn)
"n,k = map(int,input().split("" ""))
degrees = [0] * n
neighbors = [list() for x in range(n)]
for i in range(n-1):
	first,second = map(int,input().split("" ""))
	degrees[first-1] += 1
	degrees[second-1] += 1
	neighbors[first-1] += [second]
	neighbors[second-1] += [first]

curr = 0
for i in range(n):
	if degrees[i] == 1:
		curr = i+1
		break
if curr == 0 or len(neighbors[curr-1]) == 0:
	print(""No"")
	exit()
curr = neighbors[curr-1][0]

def check(prev,parent,curr,level,degrees,neighbors,k):

	if level == 0:
		return len(parent) == 1 and degrees[curr-1] == 1,[]
	checked = []
	for neighbor in neighbors[curr-1]:

		if len(prev) != 0 and prev[0] == neighbor:
			checked += [neighbor]
			continue
		if len(parent) != 0 and parent[0] == neighbor:
			continue
		result,garbage = check([],[curr],neighbor,level-1,degrees,neighbors,k)
		if result:
			checked += [neighbor]
		else:

			if len(parent) == 0:
				parent += [neighbor]
			else:
				return False,[]
	if len(checked) > 2 and len(parent) == 0 and level == k:

		return True,[]
	elif len(checked) > 2 and len(parent) == 1 and level != k:

		return True,parent
	else:

		return False,[]

prev = []
parent = []
counter = 1
while(counter <= k):
	result,parent = check(prev,[],curr,counter,degrees,neighbors,k)
	if not(result):
		print(""No"")
		exit()
	if counter == k:
		print(""Yes"")
		exit()
	prev = [curr]
	curr = parent[0]
	counter += 1
",O(nlogn)
"def examA():
    T = I()
    ans = []
    for _ in range(T):
        N, M = LI()
        if N%M!=0:
            ans.append(""NO"")
        else:
            ans.append(""YES"")
    for v in ans:
        print(v)
    return

def examB():
    T = I()
    ans = []
    for _ in range(T):
        N = I()
        A = LI()
        A.sort()
        ans.append(A[::-1])
    for v in ans:
        print("" "".join(map(str,v)))
    return

def examC():
    T = I()
    ans = []
    for _ in range(T):
        N, K = LI()
        A = LI()
        sumA = sum(A)
        if sumA==0:
            ans.append(""YES"")
            continue
        cur = 0
        L = []
        for i in range(100):
            now = K**i
            L.append(now)
            cur += now
            if cur>=sumA:
                break
        for i in range(N):
            A[i] *= (-1)
        heapify(A)

        for l in L[::-1]:
            if not A:
                break
            a = -heappop(A)
            if a<l:
                heappush(A, -a)
            elif a>l:
                heappush(A,-(a-l))
        if not A or heappop(A)==0:
            ans.append(""YES"")
        else:
            ans.append(""NO"")
    for v in ans:
        print(v)
    return

def examD():
    class combination():

        def __init__(self, n, mod):
            self.n = n
            self.fac = [1] * (n + 1)
            self.inv = [1] * (n + 1)
            for j in range(1, n + 1):
                self.fac[j] = self.fac[j - 1] * j % mod

            self.inv[n] = pow(self.fac[n], mod - 2, mod)
            for j in range(n - 1, -1, -1):
                self.inv[j] = self.inv[j + 1] * (j + 1) % mod

        def comb(self, n, r, mod):
            if r > n or n < 0 or r < 0:
                return 0
            return self.fac[n] * self.inv[n - r] * self.inv[r] % mod
    N, M = LI()
    ans = 0
    if N==2:
        print(ans)
        return
    C = combination(M,mod2)
    for i in range(N-1,M+1):
        cur = pow(2,N-3,mod2) * (i-1) * C.comb(i-2,N-3,mod2)

        ans += cur
        ans %= mod2
    print(ans)
    return

def examE():
    N = I()
    A = LI()
    dp = [[-1]*(N+1) for _ in range(N+1)]
    for i in range(N):
        dp[i][i+1] = A[i]
    for l in range(2, N + 1):
        for i in range(N - l + 1):
            for k in range(i + 1, i + l):
                if dp[i][k] >= 1 and dp[i][k] == dp[k][i+l]:
                    dp[i][i + l] = dp[i][k] + 1

    L = [inf]*(N+1)
    for i in range(1,N+1):
        if dp[0][i]>=1:
            L[i] = 1
    for i in range(N):
        for k in range(1, N - i + 1):
            if dp[i][i + k] >= 1:
                L[i + k] = min(L[i + k], L[i] + 1)

    ans = L[N]
    print(ans)
    return

def examF():
    ans = 0
    print(ans)
    return

import sys,copy,bisect,itertools,heapq,math,random
from heapq import heappop,heappush,heapify
from collections import Counter,defaultdict,deque
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int,sys.stdin.readline().split()))
def LSI(): return list(map(str,sys.stdin.readline().split()))
def LS(): return sys.stdin.readline().split()
def SI(): return sys.stdin.readline().strip()
global mod,mod2,inf,alphabet,_ep
mod = 10**9 + 7
mod2 = 998244353
inf = 10**18
_ep = 10**(-12)
alphabet = [chr(ord('a') + i) for i in range(26)]

if __name__ == '__main__':
    examE()
",O(n ^ 3)
"size = int(input())
s = input()

ct = 0
F = 0
for i in range(size-2):
    if s[i]==s[i+1] and s[i+1]==s[i+2] and s[i] == 'x':
        ct += 1
        F = 1

if F == 0:
    print(0)
else:
    print(ct)",O(n)
"rnd_mod = 1234567890133
rnd_x = 987654321098
def rnd():
    global rnd_x
    rnd_x = rnd_x**2 % rnd_mod
    return (rnd_x>>5) % (1<<20)
def randrange(a):
    return rnd() % a

T = int(input())
for _ in range(T):
    N, M = map(int, input().split())
    X = []
    for __ in range(N):
        X.append([int(a) for a in input().split()])
    Y = [[X[i][j] for i in range(N)] for j in range(M)]
    ma = 0
    for t in range(577):
        for i in range(M):
            a = randrange(N)
            Y[i] = [Y[i][j-a] for j in range(N)]
        ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)]))
    print(ma)
",np
"n = int(input())
x, y = list(map(int, input().strip().split()))

if n-x + n-y >= x-1 + y-1:
	print(""White"")
else:
	print(""Black"")",O(1)
"import itertools



class Solution(object):
    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):
        result = 0
        for hp, ex in zip(energy, experience):
            inc1 = max((hp+1)-initialEnergy, 0)
            inc2 = max((ex+1)-initialExperience, 0)
            result += inc1+inc2
            initialEnergy += inc1-hp
            initialExperience += inc2+ex
        return result",O(n)
"n, s = map(int, input().split())
print((s + n - 1) // n)",O(1)
"n = int(input())
l = list(map(int, input().split("" "")))
r = list(map(int, input().split("" "")))

slr = [l[i]+r[i] for i in range(n)]
ans = [n-slr[i] for i in range(n)]

flag = True
if l[0]!=0 or r[n-1]!=0:
	flag= False

for i in range(n):
	great = 0
	for j in range(i+1, n):
		if ans[i]<ans[j]:
			great = great + 1
	if r[i]!=great:
		flag = False
		break
for i in range(n-1, -1, -1):
	great = 0
	for j in range(i-1, -1, -1):
		if ans[i]<ans[j]:
			great = great + 1
	if l[i]!=great:
		flag = False
		break

if flag:
	print(""YES"")
	for i in range(0, n-1):
		print(ans[i], end="" "")
	print(ans[n-1])
else:
	print(""NO"")
",O(n ^ 2)
"class Solution(object):
    def hasSpecialSubstring(self, s, k):
        l = 0
        for i in range(len(s)):
            l += 1
            if i+1 == len(s) or s[i] != s[i+1]:
                if l == k:
                    return True
                l = 0
        return False",O(n)
"import bisect
import sys
input=sys.stdin.readline

import collections
import heapq
t=1
p=10**9+7
def ncr_util():

    inv[0]=inv[1]=1
    fact[0]=fact[1]=1
    for i in range(2,300001):
        inv[i]=(inv[i%p]*(p-p//i))%p
    for i in range(1,300001):
        inv[i]=(inv[i-1]*inv[i])%p
        fact[i]=(fact[i-1]*i)%p

def solve():
    ans,a,b=0,0,0
    mul=2**60
    for i in range(60,-1,-1):

        ch1,ch2=0,0
        if a+mul<=l:

            a+=mul
            ch1=1
        if  b+mul<=l:

            b+=mul
            ch2=1
        if ch1^ch2==1:
            ans+=mul
        elif ch1==0 and ch2==0:
            if a+mul<=r:
                a+=mul
                ans+=mul
            elif b+mul<=r:
                b+=mul
                ans+=mul

        mul//=2

    return ans

for _ in range(t):

    l,r=map(int,input().split())

    print(solve())
",O(logn)
"def solution():

    n = int(input())
    segments = []
    for i,_ in enumerate(range(n)):
        x,y = input().split("" "")
        segments.append((int(x), int(y), i+1))

    segments = sorted(segments, key=lambda x: (x[0], -x[1]))

    for i,seg in enumerate(segments):
        j = i+1
        if j >= n:
            print(""-1 -1"")
            return

        while segments[j][1] <= seg[1]:
            print(""{} {}"".format(segments[j][2], seg[2]))
            return

    print(""-1 -1"")
    return

solution()
",O(nlogn)
"from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        forward = [to, cap, cost, None]
        backward = forward[3] = [fr, 0, -cost, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [None]*N

        d0 = [INF]*N
        dist = [INF]*N

        while f:
            dist[:] = d0
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                r0 = dist[v] + H[v]
                for e in G[v]:
                    w, cap, cost, _ = e
                    if cap > 0 and r0 + cost - H[w] < dist[w]:
                        dist[w] = r = r0 + cost - H[w]
                        prv_v[w] = v; prv_e[w] = e
                        heappush(que, (r, w))
            if dist[t] == INF:
                return None

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, prv_e[v][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = prv_e[v]
                e[1] -= d
                e[3][1] += d
                v = prv_v[v]
        return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

n,m = map(int,input().split())

G = MinCostFlow(n+2)
coef = [0 for i in range(n)]
edge = []
for _ in range(m):
    x,y,b = map(int,input().split())
    G.add_edge(y,x,10**18,-1)
    coef[x-1] += b
    coef[y-1] -= b
    edge.append((x,y))

s = 0
for i in range(n):
    if coef[i]<0:
        G.add_edge(0,i+1,-coef[i],0)
        s -= coef[i]
    elif coef[i]>0:
        G.add_edge(i+1,n+1,coef[i],0)

f = G.flow(0,n+1,s)

Edge = [[] for i in range(n)]
use = [False]*m
uf = UnionFindVerSize(n)
for i in range(m):
    u,v = edge[i]
    for e in G.G[u]:
        to = e[0]
        if to==v and e[1]:
            Edge[v-1].append((u-1,1))
            Edge[u-1].append((v-1,-1))
            use[i] = True
            uf.unite(u-1,v-1)

edge = [(edge[i][0],edge[i][1]) for i in range(m) if not use[i]]
for u,v in edge:
    if not uf.is_same_group(u-1,v-1):
        Edge[v-1].append((u-1,1))
        Edge[u-1].append((v-1,-1))
        uf.unite(u-1,v-1)

used_1 = [False]*n
used_2 = [False]*n
lazy = [0 for i in range(n)]
a = [0 for i in range(n)]
def dfs(v,pv):
    lazy[v] = min(lazy[v],a[v])
    for nv,c in Edge[v]:
        if not used_1[nv]:
            used_1[nv] = True
            a[nv] = a[v] + c
            dfs(nv,v)
            lazy[v] = min(lazy[v],lazy[nv])

def add(v,pv,ff):
    a[v] += ff
    for nv,c in Edge[v]:
        if not used_2[nv]:
            used_2[nv] = True
            add(nv,v,ff)

for i in range(n):
    if not used_1[i]:
        used_1[i] = True
        dfs(i,-1)
        used_2[i] = True
        add(i,-1,-lazy[i]+1)

print(*a)
",np
"class Solution(object):
    def minimumDeletions(self, nums):
        i, j = nums.index(min(nums)), nums.index(max(nums))
        if i > j:
            i, j = j, i
        return min((i+1)+(len(nums)-j), j+1, len(nums)-i)",O(n)
"import sys
def ints():
    return list(map(int, sys.stdin.readline().strip().split()))
tc = 1
while tc:
    tc-=1
    n, k = map(int, input().split())
    l = -1
    r = n+1
    while r-l > 1:
        m = (r+l)//2
        if (n-m)*(n-m+1)//2 - m > k:
            l = m
        else:
            r = m
    print(r)",O(logn)
"def main():
    l,r = map(int,input().split())

    if l == r:
        print(0)
        return

    l = bin(l)[2:]
    r = bin(r)[2:]

    if len(l) == len(r):
        i = 1
        while l[i] == r[i]:
            i += 1
        tam = len(l)-i
    else:
        tam = len(r)

    num = """"
    for i in range(tam):
        num += '1'

    print(int(num,2))

main()",O(logn)
"class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None

class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

class Solution2(object):

    def __init__(self, capacity):
        self.list = LinkedList()
        self.dict = {}
        self.capacity = capacity

    def get(self, key):
        if key not in self.dict:
            return -1
        val = self.dict[key].val
        self.__update(key, val)
        return val

    def put(self, key, val):
        if key not in self.dict and len(self.dict) == self.capacity:
            del self.dict[self.list.head.key]
            self.list.delete(self.list.head)
        self.__update(key, val)

    def __update(self, key, val):
        if key in self.dict:
            self.list.delete(self.dict[key])
        node = ListNode(key, val)
        self.list.insert(node)
        self.dict[key] = node",O(1)
"class Solution(object):
    def minSubsequence(self, nums):
        result, total, curr = [], sum(nums), 0
        nums.sort(reverse=True)
        for i, x in enumerate(nums):
            curr += x
            if curr > total-curr:
                break
        return nums[:i+1]",O(nlogn)
"class Solution(object):
    def minOperations(self, nums):
        result = 0
        for x in nums:
            if x^(result&1):
                continue
            result += 1
        return result",O(n)
"def balance(x1, y1, x2, y2):
    return min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)

def get_lr():
    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 2:
            l = m
        else:
            r = m
    r2 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = n, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res == 2:
            l = m
        else:
            r = m
    l2 = l

    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 1:
            l = m
        else:
            r = m
    r1 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = n, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res >= 1:
            l = m
        else:
            r = m
    l1 = l
    return r1, r2, l2, l1

def get_ud():
    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 2:
            l = m
        else:
            r = m
    r2 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, n, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res == 2:
            l = m
        else:
            r = m
    l2 = l

    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 1:
            l = m
        else:
            r = m
    r1 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, n, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res >= 1:
            l = m
        else:
            r = m
    l1 = l
    return r1, r2, l2, l1

n = int(input())
lr = get_lr()
ud = get_ud()
rr = [lr[0], lr[1]]
ll = [lr[2], lr[3]]
uu = [ud[0], ud[1]]
dd = [ud[2], ud[3]]
for r1 in rr:
    r2 = rr[0] if rr[0] != r1 else rr[1]
    for l1 in ll:
        l2 = ll[0] if ll[0] != l1 else ll[1]
        for u1 in uu:
            u2 = uu[0] if uu[0] != u1 else uu[1]
            for d1 in dd:
                d2 = dd[0] if dd[0] != d1 else dd[1]
                if r1 < l1 or r2 < l2 or u1 < d1 or u2 < d2:
                    continue
                print('?', l1, d1, r1, u1)
                res1 = int(input())
                print('?', l2, d2, r2, u2)
                res2 = int(input())
                if res1 == res2 == 1:
                    print('!', l1, d1, r1, u1, l2, d2, r2, u2)
                    __import__('sys').exit(0)
",O(logn)
"import os
import sys
from math import *
from collections import *

from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=10**9+7
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

l,r=value()
ans=0

R=len(bin(r))-2

for i in range(61):
    if(l&(1<<i) ^ r&(1<<i)):
        ans=2**(i+1)-1

print(ans)
",O(logn)
"n = int(input())
b = []
bb =[]
for i in range(n):
    x=int(input())
    idx = 0
    for j in range(len(b)):
        nxt = b[j] ^ x
        if nxt < x :
            x = nxt
            idx ^= bb[j]
    if x == 0:
        cnt = 0
        v = []
        for k in range(2000):
            if idx & (1 << k) :
                v.append(k)
        print(len(v),end=' ')
        for e in v:
            print(e,end=' ')
        print()
    else :
        print(0)
        idx ^= 1 << i
        b.append(x)
        bb.append(idx)
",np
"import os
import sys
from io import BytesIO, IOBase

def main():
    n, MOD = map(int, input().split())
    factorial = [1]
    for i in range(2, n + 1):
        factorial.append(factorial[-1] * i % MOD)
    for i in range(len(factorial)):
        factorial[i] = pow(factorial[i], MOD - 2, MOD)
    DP = []
    for i in range(n):
        DP.append([0] * n)
    for i in range(n):
        DP[i][0] = pow(2, i, MOD) * factorial[i]
        for j in range(1, i // 2 + 1):
            for k in range(0, i - 1):
                DP[i][j] += DP[k][j - 1] * pow(2, i - k - 2, MOD) * factorial[i - k - 2]
            DP[i][j] %= MOD
    ans = 0
    for i in range(len(factorial)):
        factorial[i] = pow(factorial[i], MOD - 2, MOD)
    for i in range(n):
        ans += DP[n - 1][i] * factorial[n - i - 1]
    print(ans % MOD)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"import sys
LI=lambda:list(map(int, sys.stdin.readline().split()))
MI=lambda:map(int, sys.stdin.readline().split())
SI=lambda:sys.stdin.readline().strip('\n')
II=lambda:int(sys.stdin.readline())

n=II()
s=SI()
c=set(s)
ln=[0]*n
for d in c:
	last=-1

	for i, v in enumerate(s):
		if v==d:
			last=i
		if last==-1:
			ln[i]=int(1e9)
		else:
			ln[i]=max(ln[i], i-last+1)

print(min(ln))",O(n)
"def socket(n,m,k,arr):
    arr.sort(reverse=True)
    devices=m
    curr_socket=0
    e_socket=k
    i=0
    t_socket=0
    count=0
    while i<n:
        if e_socket>=devices:
            return 0
        if curr_socket==0:
            curr_socket+=arr[i]
            count+=1
            e_socket-=1
            t_socket=curr_socket+e_socket
        else:
            if t_socket>=devices:
                return count
            else:
                curr_socket+=arr[i]-1
                count+=1
                t_socket=curr_socket+e_socket
        i+=1
    if t_socket>=devices:
        return count
    return -1

n,m,k=map(int,input().split())
arr=list(map(int,input().split()))
print(socket(n,m,k,arr))",O(nlogn)
"class Solution2(object):
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        m, n = len(matrix), len(matrix[0])
        size = [[0 for j in range(n)] for i in range(m)]
        max_size = 0

        for j in range(n):
            if matrix[0][j] == '1':
                size[0][j] = 1
            max_size = max(max_size, size[0][j])

        for i in range(1, m):
            if matrix[i][0] == '1':
                size[i][0] = 1
            else:
                size[i][0] = 0
            for j in range(1, n):
                if matrix[i][j] == '1':
                    size[i][j] = min(size[i][j - 1],  \
                                     size[i - 1][j],  \
                                     size[i - 1][j - 1]) + 1
                    max_size = max(max_size, size[i][j])
                else:
                    size[i][j] = 0

        return max_size * max_size",O(n ^ 2)
"n, m = int(input()), int(input())
value = False
for j in range(n + 1):
    if pow(2, j) > m:
        value = True
        break
if value:
    print(m)
else:
    print(m % pow(2, n))
",O(1)
"class Solution3(object):
    def rearrangeArray(self, nums):
        pos, neg = [], []
        for i in reversed(range(len(nums))):
            if nums[i] > 0:
                pos.append(nums[i])
            else:
                neg.append(nums[i])
        result = []
        for i in range(len(nums)):
            if i%2 == 0:
                result.append(pos.pop())
            else:
                result.append(neg.pop())
        return result",O(n)
"from math import *
n,x,y=map(int,input().split());g=gcd(x,y);n,x,y,r,h=n//g,x//g,(x+y)//g,n%g,lambda n:max(f(n,0),f(n,1))
def f(n,s):
 d=[-n,-n];d[s]=0
 for i in range(y):d=[max(d[0],d[1]),d[0]+n//y+(i*x%y<n%y)]
 return d[s]
print(h(n+1)*r+h(n)*(g-r))",np
"a,b=list(map(int,input().split()))
c,d=(((b+1)//2)-1,(b-a-1))
print(c if d<0 else c-d if c>d else 0)
",O(1)
"from sys import stdin, stdout
ti = lambda : stdin.readline().strip()
os = lambda i : stdout.write(str(i) + '\n')
ma = lambda fxn, ti : map(fxn, ti.split())
ol = lambda arr : stdout.write(' '.join(element for element in arr) + '\n')
olws = lambda arr : stdout.write(''.join(element for element in arr) + '\n')

class Digit:
	def __init__(self):
		self.count = {}

	def increment(self, k):
		if self.count.has_key(k):
			got = self.count[k]
			self.count[k] += 1
		else:
			self.count[k] = 1

	def found(self, k):
		if self.count.has_key(k):
			return self.count[k]
		else:
			return 0

n, mod = ma(int, ti())
array = ma(int, ti())

ans = 0
digits = [None]*11
for i in range(11):
	digits[i] = Digit()

for i in range(n):
	temp = array[i]%mod

	for j in range(10):
		temp *= 10
		temp %= mod

		digits[j+1].increment(temp)

for i in range(n):
	temp = array[i]
	count = 0
	while temp>0:
		temp /= 10
		count += 1

	find = mod-array[i]%mod
	find %= mod
	ans += digits[count].found(find)

for i in range(n):
	temp1 = array[i]%mod
	temp2 = array[i]

	while temp2 > 0:
		temp2 /= 10
		temp1 *= 10
		temp1 %= mod

	if ((temp1 + array[i])%mod == 0):
		ans -= 1

os(ans)",O(nlogn)
"if __name__ == '__main__':
		n,m = map(int, input().split())
		l = list(map(int, input().split()))
		d = dict()
		if len(set(l)) < n:
			print(0)
		else:
			for i in range (m):
				d.setdefault(l[i],0)
				d[l[i]]+=1
			min1 = 999999999
			for i in d.values():
				if i < min1 :
					min1 = i
			print(min1)",O(n ^ 2)
"class Solution(object):
    def orderOfLargestPlusSign(self, N, mines):
        lookup = {tuple(mine) for mine in mines}
        dp = [[0] * N for _ in range(N)]
        result = 0
        for i in range(N):
            l = 0
            for j in range(N):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = l
            l = 0
            for j in reversed(range(N)):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)

        for j in range(N):
            l = 0
            for i in range(N):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)
            l = 0
            for i in reversed(range(N)):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)
                result = max(result, dp[i][j])
        return result",O(n ^ 2)
"from collections import Counter

def solve(n, ribbons):
	L = len(ribbons[0])
	a = [Counter(r).most_common(1)[0][1] for r in ribbons]

	r = sorted([(x, i) for i, x in enumerate(a)], reverse=True)

	if n == 1:
		c = Counter(a)
		if c[L - 1] == 1:
			for i in range(3):
				if a[i] == L - 1: return i
		if c[L - 1] > 1:
			return 3
		if c[L] + c[L - 2] == 1:
			for i in range(3):
				if a[i] == L or a[i] == L-2:
					return i
		if c[L] + c[L - 2] > 1:
			return 3

	if r[1][0] == r[0][0]:
		return 3
	if r[1][0] + n >= L:
		return 3
	return r[0][1]

	print(a)

def main():
	n = int(input())
	cats = ('Kuro', 'Shiro', 'Katie', 'Draw')

	ribbons = [input().strip() for _ in range(3)]

	k = solve(n, ribbons)
	print(cats[k])

if __name__ == '__main__':
	main()",O(n)
"t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if n == 1:
        print(0)
    else:
        max1 = max2 = -1
        for q in a:
            if q > max1:
                max1, max2 = q, max1
            elif q > max2:
                max2 = q
        print(max(0, min(max2-1, len(a)-2)))
",O(n)
"class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def nodesBetweenCriticalPoints(self, head):
        first = last = -1
        result = float(""inf"")
        i, prev, head = 0, head.val, head.__next__
        while head.__next__:
            if max(prev, head.next.val) < head.val or min(prev, head.next.val) > head.val:
                if first == -1:
                    first = i
                if last != -1:
                    result = min(result, i-last)
                last = i
            i += 1
            prev = head.val
            head = head.__next__
        return [result, last-first] if last != first else [-1, -1]",O(n)
"n, k = map(int,input().split())
arr = list(map(int, input().split()))

def find_segment(arr, n, k):
  f = [0]*100001
  L = count = 0
  R = -1
  while R < n-1:
    R += 1
    if f[arr[R]] == 0:
      count += 1
    f[arr[R]] += 1
    while count == k:
      f[arr[L]] -= 1
      if f[arr[L]] == 0:
        print(L+1, R+1)
        return
      L += 1
  print(-1,-1)
find_segment(arr, n, k)",O(n)
"class Solution:
    def numDecodings(self, s: str) -> int:
        dp = {len(s): 1}
        for i in range(len(s) - 1, -1, -1):
            if s[i] == ""0"":
                dp[i] = 0
            else:
                dp[i] = dp[i + 1]

            if i + 1 < len(s) and (s[i] == ""1"" or
               s[i] == ""2"" and s[i + 1] in ""0123456""
            ):
                dp[i] += dp[i + 2]
        return dp[0]
",O(n)
"from math import factorial
s1,s2=input(),input()
a=s1.count('+')-s2.count('+')
b=s1.count('-')-s2.count('-')
if(a<0 or b<0):
    print(0)
    exit(0)
ans=factorial(a+b)/factorial(a)/factorial(b)
ans/=(2**(a+b))
print(""%.10f""%ans)
",np
"class Solution(object):
    def search(self, nums, target):
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right-left)//2
            if nums[mid] > target:
                right = mid-1
            elif nums[mid] < target:
                left = mid+1
            else:
                return mid
        return -1",O(logn)
"class Solution2(object):
    def specialArray(self, nums):
        MAX_NUM = 1000
        def inplace_counting_sort(nums, reverse=False): 
            count = [0]*(MAX_NUM+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()
    
        inplace_counting_sort(nums, reverse=True)
        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if nums[mid] <= mid:
                right = mid-1
            else:
                left = mid+1
        return -1 if left < len(nums) and nums[left] == left else left",O(n)
"

class Solution(object):
    def minimizedStringLength(self, s):
        return len(set(s))
",O(n)
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
from decimal import Decimal
from fractions import Fraction

INF = float('inf')
mod = int(1e9)+7

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

@bootstrap
def recur(r,g,b):
    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:
        yield 0
        return
    if dp[r][g][b]:
        yield dp[r][g][b]
        return
    if r>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+(yield recur(r-1,g-1,b)))
    if r>0 and b>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+(yield recur(r-1,g,b-1)))
    if b>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+(yield recur(r,g-1,b-1)))
    yield dp[r][g][b]

r,g,b=mdata()
R=sorted(mdata())
G=sorted(mdata())
B=sorted(mdata())
dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]
out(recur(r,g,b))
",O(n ^ 3)
"n, k = map(int, input().split())
teams, freqs = [tuple(int(i) for i in input().split()) for _ in range(n)], {}
teams.sort(key = lambda x: (-x[0], x[1]))
for team in teams:
    freqs[team] = freqs.get(team, 0) + 1
print(freqs[teams[k - 1]])
",O(nlogn)
"def win1():
    if n==k or r[k+1]==n or l[n-k]==1:
        return True
    for i in range(2,n-k+1):
        if l[i-1]==1 and r[i+k]==n and a[i-1]==a[i+k]:
            return True
    return False

def win2():
    if 2*k<n:
        return False
    for i in range(2,n-k+1):
        if l[i-1]!=1 or r[i+k]!=n:
            return False
    return True

if __name__ == ""__main__"":
    s=input().split()
    n,k=int(s[0]),int(s[1])
    s=input().split()
    a=[0]
    l=[0 for i in range(n+1)]
    r=[0 for i in range(n+1)]
    for c in s[0]:
        a.append(int(c))
    l[1],r[n]=1,n
    for i in range(2,n+1):
        if a[i-1]==a[i]:
            l[i]=l[i-1]
        else:
            l[i]=i
        if a[n-i+1]==a[n-i+2]:
            r[n-i+1]=r[n-i+2]
        else:
            r[n-i+1]=n-i+1

    if win1():
        print(""tokitsukaze"")
    elif win2():
        print(""quailty"")
    else:
        print(""once again"")
",O(n)
"class Solution(object):
    def buildArray(self, nums):
        for i in range(len(nums)):
            prev, curr = i, nums[i]
            while curr >= 0 and curr != i:
                nums[prev], nums[curr] = ~nums[curr], ~nums[prev] if prev == i else nums[prev]
                prev, curr = curr, ~nums[prev]
        for i in range(len(nums)):
            if nums[i] < 0:
                nums[i] = ~nums[i]
        return nums",O(n)
"class Solution(object):
    def maxFreeTime(self, eventTime, startTime, endTime):
        def topk(a, k): 
            result = [[float(""-inf"")]*2 for _ in range(k)]
            for x in a:
                for i in range(len(result)):
                    if x > result[i]:
                        result[i], x = x, result[i]
            return result

        result = 0
        startTime.append(eventTime)
        endTime.insert(0, 0)
        diffs = ([startTime[i]-endTime[i], endTime[i]] for i in range(len(startTime)))
        top3 = topk(diffs, 3)
        for i in range(len(startTime)-1):
            for mx, e in top3:
                if e not in (endTime[i], endTime[i+1]) and endTime[i+1]-startTime[i] <= mx:
                    result = max(result, (startTime[i]-endTime[i])+(startTime[i+1]-endTime[i+1])+(endTime[i+1]-startTime[i]))
                    break
            else:
                result = max(result, (startTime[i]-endTime[i])+(startTime[i+1]-endTime[i+1]))
        return result",O(n)
"n = int(input())
l = [input() for _ in range(n)]
l.sort(key=lambda x: len(x))

ok = True
for i in range(n-1):
  if l[i] not in l[i+1]:
    ok = False
    break

if ok:
  print(""YES"")
  print(*l, sep='\n')
else:
  print(""NO"")
",O(nlogn)
"s = input()
while s!="""":
	if s==s[::-1]:
		s=s[:(len(s)-1)]
	else:
		break
print(len(s))",O(n)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def sortList(self, head):
        if head == None or head.__next__ == None:
            return head

        fast, slow, prev = head, head, None
        while fast != None and fast.__next__ != None:
            prev, fast, slow = slow, fast.next.__next__, slow.__next__
        prev.next = None

        sorted_l1 = self.sortList(head)
        sorted_l2 = self.sortList(slow)

        return self.mergeTwoLists(sorted_l1, sorted_l2)

    def mergeTwoLists(self, l1, l2):
        dummy = ListNode(0)

        cur = dummy
        while l1 != None and l2 != None:
            if l1.val <= l2.val:
                cur.next, cur, l1 = l1, l1, l1.__next__
            else:
                cur.next, cur, l2 = l2, l2, l2.__next__

        if l1 != None:
            cur.next = l1
        if l2 != None:
            cur.next = l2

        return dummy.__next__",O(nlogn)
"n, k = map(int, input().split())
s = input()
a = [0] * 26
for i in s:
    a[ord(i) - ord('a')] = 1
ans = 0
i = 0
while i < 26:
    if a[i] > 0:
        ans += i + 1
        k -= 1
        i += 1
        if k == 0:
            print(ans)
            break
    i += 1
else:
    print(-1)",O(n)
"import sys
def ask(x,y,rev):
	if (rev==0):
		print(""? %d %d""%(x,y))
	else:
		print(""? %d %d""%(y,x))
	sys.stdout.flush()
	if (rev==1):
		return -int(input())
	else:
		return int(input())

comp=ask(0,0,0)
nowa=0
nowb=0
rev=0
for i in range(29,-1,-1):
	if (comp<0):
		rev^=1
		nowa,nowb=nowb,nowa
		comp=-comp
	if comp>=0:
		comp=ask(nowa|(1<<i),nowb|(1<<i),rev)
		if (comp<0):
			nowa|=1<<i
			comp=ask(nowa,nowb,rev)
		else:
			tmp=ask(nowa|(1<<i),nowb,rev)
			if (tmp<0):
				nowa|=1<<i
				nowb|=1<<i
if (rev==1):
	nowa,nowb=nowb,nowa
print(""! %d %d""%(nowa,nowb))
",O(logn)
"def check(e,value,pre):
    global maxi,count
    e[str(value)]-=1
    pre+=str(value)
    arr=[]
    for i in e:
        for j in range(e[i]):
            arr.append(i)
    arr.sort(reverse=True)
    st=''
    for i in arr:
        st+=str(i)
    alpha=int(pre+st)
    if alpha<=int(b):
        maxi=max(maxi,int(pre+st))

a=input()
b=input()
maxi=0
d={}
for i in a:
    if i not in d:
        d[i]=1
    else:
        d[i]+=1
maxi=0
num=""""
count=0
if len(a)<len(b):
    check(d.copy(),max(d),'')
else:
    for i in b:
        if i in d and d[i]>0:
            for j in range(int(i)-1,-1,-1):
                if str(j) in d and d[str(j)]>0:
                    check(d.copy(),j,num)
                    break
            check(d.copy(),i,num)
            num+=i
            d[i]-=1

        else:
            j=0
            for j in range(int(i)-1,-1,-1):
                if str(j) in d and d[str(j)]>0:
                    check(d.copy(),j,num)
                    break
            break
print(maxi)",O(n ^ 3)
"a = int(input())
print(25)",O(1)
"class Solution(object):
    def maxProfit(self, prices):
        profit = 0
        for i in range(len(prices) - 1):
            profit += max(0, prices[i + 1] - prices[i])
        return profit

    def maxProfit2(self, prices):
        return sum([max(prices[x + 1] - prices[x], 0) for x in range(len(prices[:-1]))])",O(n)
"import collections


class Solution(object):
    def brightestPosition(self, lights):
        count = collections.Counter()
        for i, r in lights:
            count[i-r] += 1
            count[i+r+1] -= 1
        result = None
        max_cnt = cnt = 0
        for i, c in sorted(count.items()):
            cnt += c
            if cnt > max_cnt:
                max_cnt, result = cnt, i
        return result",O(nlogn)
"import math
n,m,k=map(int,input().split())
horz=[]
vert=[]
if k & 1:
    for i in range(n):
        temp=[-1 for j in range(m)]
        print(*temp)

else:
    for i in range(n):
        temp=list(map(int,input().split()))
        horz.append(temp)
    for i in range(n-1):
        temp=list(map(int,input().split()))
        vert.append(temp)
    dp=[[[0 for i in range(22)] for j in range(m)]for k in range(n)]
    for x in range(2,k+1,2):
        for i in range(n):
            for j in range(m):
                dp[i][j][x]=math.inf
                if i>0:
                     dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-2]+2*vert[i-1][j])
                if i<n-1:
                      dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-2]+2*vert[i][j])
                if j>0:
                     dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-2]+2*horz[i][j-1])
                if j<m-1:
                     dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-2]+2*horz[i][j])
    for i in range(n):
        temp=[]
        for j in range(m):
            temp.append(dp[i][j][k])
        print(*temp)",O(n ^ 3)
"n, k = map(int, input().split())
if n == 1:
    print(0)
elif (k*k -k)//2 +1 < n:
    print(-1)
else:
    g, b = 0, k//2
    while b != 0:
        while g +b <= k and (k*k -k)//2 +1 -((g +b)**2 -(g +b))//2 >= n:
            g += b
        b //= 2
    print(k -g)
",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def rangeSumBST(self, root, L, R):
        result = 0
        s = [root]
        while s:
            node = s.pop()
            if node:
                if L <= node.val <= R:
                    result += node.val
                if L < node.val:
                    s.append(node.left)
                if node.val < R:
                    s.append(node.right)
        return result",O(n)
"n, k, A = map(int, input().rstrip().split())
senators = []
mx_bribe = 0

for i in range(n):
    lvl, loy = map(int, input().rstrip().split())
    senators.append((lvl, loy))
    mx_bribe += (100 - loy) // 10

bribe = [0] * n

def calc(votes):
    bsum, cnt, p = 0, 0, 1.0
    for i, s in enumerate(senators):
        if votes & (1 << i):
            p *= (s[1] + bribe[i]) / 100
            cnt += 1
        else:
            p *= (100 - s[1] - bribe[i]) / 100
            bsum += s[0]

    if cnt > (n / 2):
        return p
    else:
        return p * A / (A + bsum)

def dfs(cur, rk):
    if cur >= n:
        if rk > 0:
            return 0.0
        sm = 0.0
        for i in range(1 << n):
            sm += calc(i)

        return sm

    mx = 0.0
    for i in range(rk + 1):
        if i * 10 + senators[cur][1] > 100:
            break
        bribe[cur] = i * 10
        tmp = dfs(cur+1, rk-i)
        mx = max(tmp, mx)
    return mx

print(dfs(0, min(k, mx_bribe)))
",np
"class Solution2(object):
    def amountOfTime(self, root, start):
        def dfs(curr, start, result):
            if curr is None:
                return [-1, -1]
            left = dfs(curr.left, start, result)
            right = dfs(curr.right, start, result)
            d = -1
            if curr.val == start:
                d = 0
                result[0] = max(left[0], right[0])+1
            elif left[1] >= 0:
                d = left[1]+1
                result[0] = max(result[0], right[0]+1+d)
            elif right[1] >= 0:
                d = right[1]+1
                result[0] = max(result[0], left[0]+1+d)
            return [max(left[0], right[0])+1, d] 

        result = [-1]
        dfs(root, start, result)
        return result[0]",O(n)
"Q = int(input())
for _ in range(Q):
    N, K = map(int, input().split())
    S = input()
    X = [{""R"":0, ""G"":1, ""B"":2}[s] for s in S]
    mi = K
    for i in range(3):
        d = 0
        for j in range(N):
            if X[j] != (i+j) % 3:
                d += 1
            if j >= K and X[j-K] != (i+j-K) % 3:
                d -= 1
            if j >= K-1:
                mi = min(mi, d)
    print(mi)
",O(n)
"import os
from io import BytesIO, IOBase
import sys
from collections import defaultdict, deque, Counter
from math import sqrt, pi, ceil, log, inf, gcd, floor
from itertools import combinations, permutations
from bisect import *
from fractions import Fraction
from heapq import *
from random import randint

def main():
    n, s = map(int, input().split())
    lo, hi = s, n
    ans = n + 1
    while lo <= hi:
        mid = (lo + hi) // 2
        z = sum(map(int, str(mid)))
        if mid >= s + z:
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    print(n - ans + 1)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(logn)
"import sys
input = sys.stdin.readline

n, m = map(int, input().split())
mask = (1 << m) - 1

l = []
for i in range(n):
    l.append(list(map(int,input().split())))

lo = -1
hi = 10 ** 9 + 1
while hi - lo > 1:
    test = (hi + lo) // 2

    things = dict()
    for i in range(n):
        curr = 0
        for v in l[i]:
            curr *= 2
            if v >= test:
                curr += 1
        things[curr] = i

    works = False
    for v1 in things:
        for v2 in things:
            if v1 | v2 == mask:
                outi = things[v1]
                outj = things[v2]
                works = True
                break
        if works:
            break

    if works:
        lo = test
    else:
        hi = test

print(outi + 1, outj + 1)
",np
"import os,io
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
n,m,k=map(int,input().split())
dist1=[]
for i in range(n):
  dist1.append(list(map(int,input().split())))
dist2=[]
for i in range(n-1):
  dist2.append(list(map(int,input().split())))
if k%2:
  print(' '.join(map(str,[-1]*(n*m))))
  exit()
k//=2
dp=[10**9]*((k+1)*n*m)
for i in range(n):
  for j in range(m):
    dp[i*m+j]=0
for t in range(k):
  r=(t+1)*n*m
  q=t*n*m
  for i in range(n):
    for j in range(m):
      if i<n-1:
        dp[r+(i+1)*m+j]=min(dp[r+(i+1)*m+j],dp[q+i*m+j]+2*dist2[i][j])
      if i>0:
        dp[r+(i-1)*m+j]=min(dp[r+(i-1)*m+j],dp[q+i*m+j]+2*dist2[i-1][j])
      if j<m-1:
        dp[r+i*m+j+1]=min(dp[r+i*m+j+1],dp[q+i*m+j]+2*dist1[i][j])
      if j>0:
        dp[r+i*m+j-1]=min(dp[r+i*m+j-1],dp[q+i*m+j]+2*dist1[i][j-1])
ans=[]
for i in range(n):
  for j in range(m):
    ans.append(dp[k*n*m+i*m+j])
print(' '.join(map(str,ans)))",O(n ^ 3)
"def isValidSet(problemSet: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> bool:
    if len(problemSet) >= 2:
        total = sum(problemSet)
        myDelta = max(problemSet) - min(problemSet)
        if minTotalDif <= total <= maxTotalDif and myDelta >= minDelta:
            return True
    return False

def countValidSubsets(problems: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> int:

    def subsetBuilder (problems: list, currentSubset: list, nextElementIndex: int) -> None:
        if isValidSet(currentSubset, minTotalDif, maxTotalDif, minDelta):
            validSubsets.append(currentSubset)
        for i in range(nextElementIndex, len(problems)):
            currentSubset.append(problems[i])
            subsetBuilder(problems, currentSubset, i+1)
            currentSubset.pop(-1)

    index = 0
    currentSubset = []
    validSubsets = []

    subsetBuilder(problems, currentSubset, index)
    return len(validSubsets)

n, l, r, x = input().split()
n = int(n)
l = int(l)
r = int(r)
x = int(x)

probs = [int(prob) for prob in input().split()]

print(countValidSubsets(probs, l, r, x))
",np
"from math import *
l, r = list(map(int, input().split("" "")))
print((2<<floor(log2(l^r)))-1 if l!=r else 0)
",O(logn)
"N, MOD = map(int, input().split())
dp = [[0]*(N+2) for i in range(N+2)]
dp[0][0] = 1
limit = 1000
frac = [1]*limit
for i in range(2,limit):
    frac[i] = i * frac[i-1]%MOD
fraci = [None]*limit
fraci[-1] = pow(frac[-1], MOD -2, MOD)
for i in range(-2, -limit-1, -1):
    fraci[i] = fraci[i+1] * (limit + i + 1) % MOD
bb = [1, 2]
for i in range(1000):
    bb.append(bb[-1] *2 %MOD)
for ln in range(N+1):
    for cnt in range(ln//2, ln+1):
        for k in range(1, N-ln+1):
            cmb = frac[cnt+k] * (fraci[cnt]*fraci[k]%MOD)%MOD
            dp[ln+k+1][cnt+k] += dp[ln][cnt] * (bb[k-1] * cmb % MOD) %MOD
            dp[ln+k+1][cnt+k] %= MOD
R = 0
for x in dp[N+1][:N+1]:
    R = (R+x)%MOD
print(R)
",O(n ^ 3)
"n = int(input())
a = input().split()
d = {}
k = 0
for i in range(len(a)):
    d[a[i]] = i
for s in input().split():
    if d[s] != -1:
        c = d[s]
        print(c - k + 1, end=' ')
        for i in range(k, c + 1):
            d[a[i]] = -1
        k = c + 1
    else:
        print(0, end=' ')
",O(n)
"import math
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

n,m=map(int,input().split())
l=[]
tot=[]
done=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    l.append(input())
colsum=[[0 for i in range(m)]for j in range(n)]
rowsum=[[0 for i in range(m)]for j in range(n)]
col=[[0 for i in range(m)]for j in range(n)]
row=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            rowsum[i][j]=1
            colsum[i][j]=1
            row[i][j]=1
            col[i][j]=1
for i in range(n):
    for j in range(1,m):
        if l[i][j]=='.':
            continue
        rowsum[i][j]+=rowsum[i][j-1]
for i in range(n):
    for j in range(m-2,-1,-1):
        if l[i][j]=='.':
            continue
        row[i][j]+=row[i][j+1]
for i in range(m):
    for j in range(n-2,-1,-1):
        if l[j][i]=='.':
            continue
        col[j][i]+=col[j+1][i]
for i in range(m):
    for j in range(1,n):
        if l[j][i]=='.':
            continue
        colsum[j][i]+=colsum[j-1][i]
def check(x,y):
    i=x
    j=y
    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1
    if ans==0:
        return []
    return [ans]
h=[[0 for i in range(m+1)]for j in range(n)]
v=[[0 for i in range(m)]for j in range(n+1)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            ans=check(i,j)
            for j1 in ans:
                tot.append([i+1,j+1,j1])
                h[i][j-j1]+=1
                h[i][j+j1+1]-=1
                v[i-j1][j]+=1
                v[i+j1+1][j]-=1
for i in range(n):
    for j in range(1,m):
        h[i][j]+=h[i][j-1]
for i in range(m):
    for j in range(1,n):
        v[j][i]+=v[j-1][i]

for i in range(n):
    for j in range(m):
        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:
            print(-1)
            sys.exit(0)
print(len(tot))
for i in tot:
    print(*i)
",O(n ^ 2)
"class Solution(object):
    def validSubarrays(self, nums):
        result = 0
        s = []
        for num in nums:
            while s and s[-1] > num:
                s.pop()
            s.append(num)
            result += len(s)
        return result",O(n)
"n, k = [int(a) for a in input().split()]
power = [int(a) for a in input().split()]
coins = [int(a) for a in input().split()]

dp = [0 for i in range(n)]

def takeSecond(elem):
    return elem[1]

def takeFirst(elem):
    return elem[0]

people = [(power[i], coins[i], i) for i in range(n)]

people.sort(key=takeFirst)

dp[0] = []

for i, p in enumerate(people):
    if i == 0:
        continue
    kills = [i for i in dp[i - 1]]
    kills.append(people[i - 1][1])
    x = []

    if len(kills) > k:
        kills.remove(min(kills))

    dp[i] = kills

x = [(people[i][2], str(sum(dp[i]) + people[i][1])) for i in range(n)]

x.sort(key=takeFirst)

print("" "".join([z[1] for z in x]))
",O(nlogn)
"import itertools




class Solution2(object):
    def beautifulPair(self, nums1, nums2):
        INF = float(""inf"")
        MAX_NEIGHBOR_COUNT = (8+2)//2
        def dist(a, b):
            if a > b:
                a, b = b, a
            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]

        def merge_sort(left, right):
            def update(arr, i): 
                for j in reversed(range(len(arr))):
                    if points[i][1]-points[arr[j]][1] > result[0]:
                        break
                    result[:] = min(result, dist(i, arr[j]))
                else:
                    j = -1
                assert((len(arr)-1)-j <= MAX_NEIGHBOR_COUNT)

            if left == right:
                return
            mid = left+(right-left)//2
            x = points[order[mid]][0] 
            merge_sort(left, mid)
            merge_sort(mid+1, right)
            tmp, tmp_l, tmp_r = [], [], []
            l, r = left, mid+1
            while l <= mid or r <= right:
                if r == right+1 or (l <= mid and points[order[l]][1] <= points[order[r]][1]): 
                    update(tmp_r, order[l])
                    if x-points[order[l]][0] <= result[0]: 
                        tmp_l.append(order[l])
                    tmp.append(order[l])
                    l += 1
                else:
                    update(tmp_l, order[r])
                    if points[order[r]][0]-x <= result[0]: 
                        tmp_r.append(order[r])
                    tmp.append(order[r])
                    r += 1
            order[left:right+1] = tmp

        points = [(i, j) for i, j in zip(nums1, nums2)]
        result = [INF]*3
        lookup = {}
        for i in reversed(range(len(points))):
            if points[i] in lookup:
                result = [0, (i, lookup[points[i]])]
            lookup[points[i]] = i
        if result[0] == 0:
            return result[1]
        order = list(range(len(points)))
        order.sort(key=lambda x: points[x][0])
        merge_sort(0, len(points)-1)
        return result[1:]",O(nlogn)
"class Solution(object):
    def countSubarrays(self, nums):
        result = l = 1
        for i in range(1, len(nums)):
            if nums[i-1] >= nums[i]:
                l = 0
            l += 1
            result += l
        return result",O(n)
"class Solution(object):
    def minimumScore(self, nums, edges):
        def is_ancestor(a, b):
            return left[a] <= left[b] and right[b] <= right[a]

        def iter_dfs():
            cnt = 0
            left = [0]*len(nums)
            right = [0]*len(nums)
            stk = [(1, (0, -1))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p = args
                    left[u] = cnt
                    cnt += 1
                    stk.append((2, (u, p)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, (v, u)))
                elif step == 2:
                    u, p = args
                    for v in adj[u]:
                        if v == p:
                            continue
                        nums[u] ^= nums[v]
                    right[u] = cnt
            return left, right
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        left, right = iter_dfs()
        result = float(""inf"")
        for i in range(1, len(nums)):
            for j in range(i+1, len(nums)):
                if is_ancestor(i, j):
                    a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j]
                elif is_ancestor(j, i):
                    a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i]
                else:
                    a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j]
                result = min(result, max(a, b, c)-min(a, b, c))
        return result",O(n ^ 2)
"import sys
def contain(a, b):
    ax1, ay1, ax2, ay2 = a
    bx1, by1, bx2, by2 = b
    return bx1 <= ax1 and ax2 <= bx2 and by1 <= ay1 and ay2 <= by2
def ask(x1, y1, x2, y2, known=(), memo={}):
    if x2 < x1+1 or y2 < y1+1:
        return 0
    ofs = len(list(filter(lambda rect: contain(rect, (x1, y1, x2, y2)), known)))
    key = (x1+1, y1+1, x2, y2)
    if key in memo:
        return memo[key] - ofs
    print('?', *key)
    sys.stdout.flush()
    memo[key] = int(input())
    return memo[key] - ofs
def binsearch(l, r, p):
    assert l < r
    while l+1 != r:
        m = (l + r) // 2
        if p(m):
            r = m
        else:
            l = m
    return r
def shrink(x1, y1, x2, y2, cnt, known=()):
    assert ask(x1, y1, x2, y2, known=known) == cnt
    x1 = binsearch(x1, x2, lambda x: ask(x, y1, x2, y2, known=known) != cnt) - 1
    y1 = binsearch(y1, y2, lambda y: ask(x1, y, x2, y2, known=known) != cnt) - 1
    x2 = binsearch(x1, x2, lambda x: ask(x1, y1, x, y2, known=known) == cnt)
    y2 = binsearch(y1, y2, lambda y: ask(x1, y1, x2, y, known=known) == cnt)
    assert ask(x1, y1, x2, y2, known=known) == cnt
    assert ask(x1, y1, x2, y2, known=known) == cnt
    return x1, y1, x2, y2
def go(x1, y1, x2, y2):
    assert ask(x1, y1, x2, y2) == 2
    x1, y1, x2, y2 = shrink(x1, y1, x2, y2, 2)
    a = None
    if not a and x1 < x2:
        if ask(x1+1, y1, x2, y2) == 1:
            a = shrink(x1+1, y1, x2, y2, 1)
        elif ask(x1, y1, x2-1, y2) == 1:
            a = shrink(x1, y1, x2-1, y2, 1)
    if not a and y1 < y2:
        if ask(x1, y1+1, x2, y2) == 1:
            a = shrink(x1, y1+1, x2, y2, 1)
        elif ask(x1, y1, x2, y2-1) == 1:
            a = shrink(x1, y1, x2, y2-1, 1)
    if not a:
        a = x1, y1, x2, y2
        return a, a
    else:
        b = shrink(x1, y1, x2, y2, 1, known=[ a ])
        return a, b
n = int(input())
a, b = go(0, 0, n, n)
ax1, ay1, ax2, ay2 = a
bx1, by1, bx2, by2 = b
print('!', ax1+1, ay1+1, ax2, ay2, bx1+1, by1+1, bx2, by2)
",O(logn)
"class Solution(object):
    def twoSum(self, nums, target):
        lookup = {}
        for i, num in enumerate(nums):
            if target - num in lookup:
                return [lookup[target - num], i]
            lookup[num] = i

    def twoSum2(self, nums, target):
        for i in nums:
            j = target - i
            tmp_nums_start_index = nums.index(i) + 1
            tmp_nums = nums[tmp_nums_start_index:]
            if j in tmp_nums:
                return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)]",O(n)
"
import bisect


class Solution(object):
    def lengthOfLIS(self, nums):
        LIS = []
        def insert(target):
            left = bisect.bisect_left(LIS, target)
            if left == len(LIS):
                LIS.append(target)
            else:
                LIS[left] = target
    
        for num in nums:
            insert(num)
        return len(LIS)


",O(nlogn)
"class Solution(object):
    def divisorSubstrings(self, num, k):
        result = curr = 0
        s = list(map(int, str(num)))
        base = 10**(k-1)
        for i, x in enumerate(s):
            if i-k >= 0:
                curr -= s[i-k]*base
            curr = curr*10+x
            if i+1 >= k:
                result += int(curr and num%curr == 0)
        return result",O(logn)
"n = int(input())
ans = 1
for i in range(1, n):
    ans += i * 4
print(ans)",O(n)
"class Solution(object):
    def takeCharacters(self, s, k):
        cnt = [0]*3
        for c in s:
            cnt[ord(c)-ord('a')] += 1
        if min(cnt) < k:
            return -1
        result = left = 0
        for right in range(len(s)):
            cnt[ord(s[right])-ord('a')] -= 1
            while cnt[ord(s[right])-ord('a')] < k:
                cnt[ord(s[left])-ord('a')] += 1
                left += 1
            result = max(result, right-left+1)
        return len(s)-result",O(n)
"class Solution(object):
    def minDeletion(self, nums):
        result = 0
        for i in range(len(nums)-1):
            result += int(i%2 == result%2 and nums[i] == nums[i+1])
        return result+(len(nums)-result)%2",O(n)
"global fact,inv_fact
def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):
	global fact, inv_fact

	max_n = min(max_n, mod - 1)

	fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
	fact[0] = 1
	for i in range(max_n):
		fact[i + 1] = fact[i] * (i + 1) % mod

	inv_fact[-1] = pow(fact[-1], mod - 2, mod)
	for i in reversed(range(max_n)):
		inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

make_nCr_mod()
def comb(n, r):
	mod=10**9+7
	global fact,inv_fact
	res = 1
	while n or r:
		a, b = n % mod, r % mod
		if a < b:
			return 0
		res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
		n //= mod
		r //= mod
	return res
def f():
	dp=[0]*(1000+100)
	dp[1]=1

	for i in range(2,len(dp)):
		o=bin(i).count(""1"")
		if o==1:
			dp[i]=2
		else:
			dp[i]+=dp[o]+1
	return dp

def bit(s,k):
	dp=f()
	l=[]
	ans=0
	ll=len(s)
	ans=0
	ones=0
	if k==0:
		return 1
	for i  in range(ll):
		if s[i]==""0"":
			continue
		else:
			for j in range(max(ones,1),1000):
				if dp[j]==k:
					ans=(ans+comb(ll-i-1,j-ones))%(10**9+7)
					if i==0 and k==1:
						ans-=1
		ones+=1
	if dp[ones]==k:
		ans+=1
	return (ans)%(10**9+7)

s=input().strip()
k=int(input())
print(bit(s,k))",O(n)
"n, K = map(int, input().split())
dp = [[[0] * 4 for j in range(K + 2)] for i in range(n)]
MOD = 998244353
dp[0][1][0] = 1
dp[0][1][1] = 1
dp[0][2][2] = 1
dp[0][2][3] = 1
for i in range(n - 1):
    for j in range(1, K + 1):
        if j < K + 1:
            for k in range(4):
                    dp[i + 1][j][k] += dp[i][j][k]
                    dp[i + 1][j][k] %= MOD

            for k in range(2):
                dp[i + 1][j][k] += dp[i][j][2]
                dp[i + 1][j][k] %= MOD

            for k in range(2):
                dp[i + 1][j][k] += dp[i][j][3]
                dp[i + 1][j][k] %= MOD

    for j in range(1, K):
        for k in range(4):
            if k != 0:
                dp[i + 1][j + 1][k] += dp[i][j][0]
                dp[i + 1][j + 1][k] %= MOD

        for k in range(4):
            if k != 1:
                dp[i + 1][j + 1][k] += dp[i][j][1]
                dp[i + 1][j + 1][k] %= MOD

        if j + 2 < K + 1:
            dp[i + 1][j + 2][2] += dp[i][j][3]
            dp[i + 1][j + 2][2] %= MOD
            dp[i + 1][j + 2][3] += dp[i][j][2]
            dp[i + 1][j + 2][3] %= MOD

num = 0
for i in range(4):
    num += dp[n - 1][K][i]
    num %= MOD

print(num)",np
"n,m=map(int,input().split())
arr=[]
for i in range(m):
    arr.append(list(map(int,input().split())))
count=0
for i in range(m):
    count +=arr[i][0] *(n)
    if n %2==1 and arr[i][1] <0:
        count +=(n//2)*(n//2 +1)*arr[i][1]
    if n %2==1 and arr[i][1] >0:
        count +=(n) *(n-1) *arr[i][1]//2
    if n %2==0 and arr[i][1] <0:
        count +=(n//2)*(n//2 -1)*arr[i][1]
        count +=(n//2) *arr[i][1]
    if n %2==0 and arr[i][1] >0:
        count +=(n) *(n-1) *arr[i][1] //2
print(count /n)",O(n)
"def c(a, b, l, ans, pro):
    if l != 0:
        n = a[:]
        mx = None
        pro1 = pro
        prosh = set()
        for i in range(l):
            pro = pro1
            if a[i] == prosh:
                continue
            elif (a[i] <= b[0] and pro):
                n.pop(i)
                prosh = a[i]
                if pro == True:
                    if a[i] < b[0]:
                        pro = False
                m = c(n, b[1:], l-1, ans+str(a[i]), pro)
                n = a[:]
                if m != None:
                    if mx == None:
                        mx = int(m)
                    elif mx < int(m):
                        mx = int(m)
            elif not(pro):
                a.sort(reverse = True)
                a = list(map(str, a))
                return ans +''.join(a)
            else:
                break
        return mx
    else:
        return ans
a = input()
b = input()
l = len(a)
if len(a) != len(b):
    a = list(a)
    a.sort()
    print(''.join(a[::-1]))
else:
    a = list(map(int, a))
    b = list(map(int, b))
    a.sort()
    n = a[:]
    mx = 0
    prosh = -1
    for i in range(l):
        if a[i] == prosh:
            continue
        elif a[i] != 0 and a[i] <= b[0]:
            n.pop(i)
            prosh = a[i]
            pro = False
            if a[i] == b[0]:
                pro = True
            m = c(n, b[1:], l-1, str(a[i]), pro)
            n = a[:]
            if m != None:
                if mx < int(m):
                    mx = int(m)
        elif a[i] > b[0]:
            break
    print(mx)",O(n ^ 3)
"import string


class Solution(object):
    def validIPAddress(self, IP):
        blocks = IP.split('.')
        if len(blocks) == 4:
            for i in range(len(blocks)):
                if not blocks[i].isdigit() or not 0 <= int(blocks[i]) < 256 or \
                   (blocks[i][0] == '0' and len(blocks[i]) > 1):
                    return ""Neither""
            return ""IPv4""

        blocks = IP.split(':')
        if len(blocks) == 8:
            for i in range(len(blocks)):
                if not (1 <= len(blocks[i]) <= 4) or \
                   not all(c in string.hexdigits for c in blocks[i]):
                    return ""Neither""
            return ""IPv6""
        return ""Neither""",O(1)
"def gns():
    return  list(map(int,input().split()))
n=int(input())
ns=gns()
a='cslnb'
b='sjfnb'
ns.sort()
ans=[]
for i in range(1,n):
    if ns[i]==ns[i-1]:
        ans.append(i)
if len(ans)>=2 or sum(ns)==0:
    print(a)
    quit()
if len(ans)==1:
    i=ans[0]
    if ns[i]==0 or ns[i]-1 in ns:
        print(a)
        quit()
    r=sum(ns)-n*(n-1)//2
    if r%2==0:
        print(a)
        quit()
    else:
        print(b)
        quit()
else:
    r=sum(ns)-n*(n-1)//2
    if r%2==0:
        print(a)
        quit()
    else:
        print(b)
",O(nlogn)
"from sys import stdin
from math import factorial

n, mod = map(int, stdin.readline().split())

def binom(n, m):
    return factorial(n) // factorial(m) // factorial(n-m)

def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):
        sign = 1 if (i-k)%2 == 0 else -1
        ans += sign * binom(k, i) * (i**x)
        ans %= mod
    return ans

def f(x, k):
    return (foo(x, k) * pow(2, x-k, mod)) % mod

ans = 0
for i in range((n+1)//2):
    ans = (ans + f(n-i, i+1))
    ans %= mod
print(ans)
",O(n ^ 3)
"class Solution(object):
    def fillCups(self, amount):
        return max(max(amount), (sum(amount)+1)//2)",O(1)
"n,k=map(int,input().split())
if k>=n-1:
    print(n-1)
else:
    print(k+ ((n-k)*(n-k+1))//2 - 1)",O(1)
"class Solution(object):
    def capitalizeTitle(self, title):
        title = list(title)
        j = 0
        for i in range(len(title)+1):
            if i < len(title) and title[i] != ' ':
                title[i] = title[i].lower()
                continue
            if i-j > 2:
                title[j] = title[j].upper()
            j = i+1
        return """".join(title)",O(n)
"one = list(map(int, input().split()))
two = list(map(int, input().split()))

one_ = sorted([(one[i], one[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))
two_ = sorted([(two[i], two[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))

ones = [one_[0], one_[2], one_[3], one_[1]]
twos = [two_[1], two_[3], two_[2], two_[0]]

L, D, U, R = ones[0][0], ones[0][1], ones[2][1], ones[2][0]

def in_one(point):
    x, y = point

    return L <= x <= R and D <= y <= U

def in_two(point):
    x_0, y_0 = twos[0]

    def U_p(x_):
        return x_ + y_0 - x_0

    def D_m(x_):
        return -x_ + y_0 + x_0

    x_1, y_1 = twos[2]

    def U_m(x_):
        return -x_ + y_1 + x_1

    def D_p(x_):
        return x_ + y_1 - x_1

    x, y = point

    return D_m(x) <= y <= U_p(x) and D_p(x) <= y <= U_m(x)

c_one = ((L + R) / 2, (U + D) / 2)
c_two = ((twos[0][0] + twos[2][0]) / 2, (twos[1][1] + twos[3][1]) / 2)

ones.append(c_one)
twos.append(c_two)

for p in ones:
    if in_two(p):
        print('YES')
        exit()

for p in twos:
    if in_one(p):
        print('YES')
        exit()

print('NO')
",O(1)
"class Solution(object):
    def countBits(self, num):
        res = [0]
        for i in range(1, num + 1):
            res.append((i & 1) + res[i >> 1])
        return res

    def countBits2(self, num):
        s = [0]
        while len(s) <= num:
            s.extend([x + 1 for x in s])
        return s[:num + 1]",O(n)
"import sys
input = lambda : sys.stdin.readline().rstrip()

sys.setrecursionlimit(2*10**5+10)
write = lambda x: sys.stdout.write(x+""\n"")
debug = lambda x: sys.stderr.write(x+""\n"")
writef = lambda x: print(""{:.12f}"".format(x))

def zeta_super(val, n):

    out = val[:]
    for i in range(n):
        for j in range(1<<n):
            if not j>>i&1:
                out[j] += out[j^(1<<i)]
    return out

n = int(input())
a = list(map(int, input().split()))
m = max(a).bit_length()
M = 10**9+7
v = [0]*(1<<m)
for item in a:
    v[item] += 1
v2 = [1]
for i in range(n+1):
    v2.append(v2[-1]*2%M)
nv = zeta_super(v, m)
ans = 0
for b in range(1<<m):
    ans += (v2[nv[b]]-1)*pow(-1, bin(b).count(""1""))
    ans %= M
print(ans%M)",np
"n=int(raw_input())
arr=list(map(int,raw_input().split()))
dict1={}
arr1=[0]*n
for i in range(n):
	arr1[arr[i]-1]=i
for i in range(n):
	dict1[i+1]=[]
for i in range(n):
	for j in range(i-arr[i],-1,-arr[i]):
		if(arr[j]>arr[i]):
			dict1[arr[i]].append(arr[j])
	for j in range(i+arr[i],n,arr[i]):
		if(arr[j]>arr[i]):
			dict1[arr[i]].append(arr[j])
strarr=['.']*n

for i in range(n-1,-1,-1):
	if(len(dict1[arr[arr1[i]]])==0):
		strarr[arr1[i]]='B'
	else:
		if(len(dict1[arr[arr1[i]]])==1 and len(dict1[dict1[arr[arr1[i]]][0]])==0):
			strarr[arr1[i]]='A'
		else:
			flag=0
			for j in dict1[arr[arr1[i]]]:

				if(strarr[arr1[j-1]]=='B'):
					flag=1
					break
			if(flag==1):
				strarr[arr1[i]]='A'
			else:
				strarr[arr1[i]]='B'

print("""".join(x for x in strarr))
",O(n ^ 2)
"
class Solution(object):
    def containsNearbyDuplicate(self, nums, k):
        lookup = {}
        for i, num in enumerate(nums):
            if num not in lookup:
                lookup[num] = i
            else:
                if i - lookup[num] <= k:
                    return True
                lookup[num] = i
        return False

",O(n)
"n = int(input().rstrip())
arr = []
mod = pow(10,9) + 7
indent_num = 0
for i in range(n):
    arr.append(input().rstrip())
    if arr[i] == 'f':
        indent_num += 1
dp = [0 for i in range(indent_num + 1)]
max_indent = 0

cur_indent = 0
pref = [0 for i in range(indent_num + 1)]

def cal_pref(dp, pref):
    pref[0] = dp[0]
    for i in range(1, len(dp)):
        pref[i] = pref[i - 1] + dp[i]

for i in range(n):
    if arr[i] == 'f':
        cur_indent += 1
        max_indent += 1
        continue
    cur = [0 for i in range(indent_num + 1)]
    cal_pref(dp, pref)
    for j in range(cur_indent,indent_num + 1):
        res_idx = j - cur_indent
        res_result = pref[res_idx - 1] if res_idx > 0 else 0
        cur[j] = (pref[indent_num] - res_result) % mod

    cur[max_indent] = 1 if not cur[max_indent] else cur[max_indent]
    dp = cur
    cur_indent = 0

print(sum(dp) % mod)
",O(n ^ 2)
"class Solution(object):
    def getCollisionTimes(self, cars):
        stk = []
        result = [-1.0]*len(cars)
        for i in reversed(range(len(cars))):
            p, s = cars[i]
            while stk and (cars[stk[-1]][1] >= s or 
                           0 < result[stk[-1]] <= float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])):
                stk.pop()
            if stk:
                result[i] = float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])
            stk.append(i)
        return result",O(n)
"line = input()
n = len(line)
temp = [0]
for i in range(1, n):
    for j in range(n-i):
        for k in range(1, n-i-j+1):

            if line[j:j+i] == line[j+k:j+k+i]:
                temp.append(i)
print(max(temp))",O(n ^ 3)
"class Solution(object):
    def maximumBeauty(self, flowers):
        lookup = {}
        prefix = [0]
        result = float(""-inf"")
        for i, f in enumerate(flowers):
            prefix.append(prefix[-1]+f if f > 0 else prefix[-1])
            if not f in lookup:
                lookup[f] = i
                continue
            result = max(result, 2*f+prefix[i+1]-prefix[lookup[f]] if f < 0 else prefix[i+1]-prefix[lookup[f]])
        return result",O(n)
"from sys import stdin
input=stdin.readline

def count(n):

    value=0
    while(n):
        n &= (n-1)
        value+=1

    return value

def nc2(n):
    return (n*(n - 1))//2

def answer():

    dp=[0]*(1 << n)

    dp[(1 << n) - 1]=1

    for mask in range((1 << n) - 1,0,-1):

        m=count(mask)
        if(m==1):continue

        p=1/(nc2(m))

        for i in range(n):
            for j in range(n):
                if(i==j):continue

                if((mask >> i & 1) and (mask >> j & 1)):

                    next_mask=mask ^ (1 << j)
                    dp[next_mask]+=(dp[mask]*p*a[i][j])

    for i in range(n):

        print(dp[1 << i],end=' ')

n=int(input())
a=[list(map(float,input().split())) for i in range(n)]

answer()
print()
",np
"
import collections



class Solution(object):
    def killProcess(self, pid, ppid, kill):
        def killAll(pid, children, killed):
            killed.append(pid)
            for child in children[pid]:
                killAll(child, children, killed)

        result = []
        children = collections.defaultdict(set)
        for i in range(len(pid)):
            children[ppid[i]].add(pid[i])
        killAll(kill, children, result)
        return result


",O(n)
"import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log2, ceil
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from bisect import insort
from collections import Counter
from collections import deque
from heapq import heappush,heappop,heapify
from itertools import permutations,combinations
from itertools import accumulate as ac
mod = int(1e9)+7

ip = lambda : int(stdin.readline())
inp = lambda: map(int,stdin.readline().split())
ips = lambda: stdin.readline().rstrip()
out = lambda x : stdout.write(str(x)+""\n"")

t = 1
for _ in range(t):
    q = ""? {} {}"".format(0,0)
    print(q,flush = True)
    cond = ip()
    cur_a = 0
    cur_b = 0
    for i in range(29,-1,-1):
        xor = (1<<i)
        query_a = cur_a^xor
        query_b = cur_b^xor
        q = ""? {} {}"".format(query_a,query_b)
        print(q,flush = True)
        val = ip()
        if val != cond:
            if cond == -1 and val == 1:
                cur_b ^= xor
                query_a = cur_a
                query_b = cur_b
                q = ""? {} {}"".format(query_a,query_b)
                print(q,flush = True)
                val = ip()
                cond = val
            else:
                cur_a ^= xor
                query_a = cur_a
                query_b = cur_b
                q = ""? {} {}"".format(query_a,query_b)
                print(q,flush = True)
                val = ip()
                cond = val
        else:
            cond = val
            query_a = cur_a^xor
            query_b = cur_b
            q = ""? {} {}"".format(query_a,query_b)
            print(q,flush = True)
            val = ip()
            if val == -1:
                cur_a ^= xor
                cur_b ^= xor
            else:
                pass
    ans = ""! {} {}"".format(cur_a,cur_b)
    print(ans,flush = True)
",O(logn)
"from math import *
from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 2**j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)",O(nlogn)
"string=input()
n=len(string)
count1=[]
long=0
for s_i in range(n):
    for end_i in range(s_i+1,n+1):
        sub=string[s_i:end_i]
        if sub not in count1:
            count1.append(sub)
        else:
            if len(sub)>long:
                long=len(sub)

print(long)
",O(n ^ 3)
"from math import gcd

n = int(input())
d = dict()
qs = []
for i in range(n):
    s = input()
    a = int(s[1:s.index('+')])
    b = int(s[s.index('+') + 1: s.index(')')])
    c = int(s[s.index(')') + 2:])
    a = a + b
    gc = gcd(a, c)
    res = (a // gc, c // gc)
    qs.append(res)
    if res in d:
        d[res] += 1
    else:
        d[res] = 1
for q in qs:
    print(d[q], end=' ')
",O(n)
"from math import inf
n, m, k = map(int, input().split())
horizontal = []
vertical = []
for _ in range(n):
    horizontal.append(list(map(int, input().split())))
for _ in range(n - 1):
    vertical.append(list(map(int, input().split())))
if k & 1:
    ans = [""-1""] * m
    for _ in range(n):
        print(*ans)
else:
    grid = [[0 for i in range(m)] for j in range(n)]
    for _ in range(k // 2):
        X = [[inf for i in range(m)] for j in range(n)]
        for i in range(n):
            for j in range(m):
                if i >= 1:
                    X[i][j] = min(2 * vertical[i - 1][j] + grid[i - 1][j], X[i][j])
                if i < n - 1:
                    X[i][j] = min(2 * vertical[i][j] + grid[i + 1][j], X[i][j])
                if j >= 1:
                    X[i][j] = min(2 * horizontal[i][j - 1] + grid[i][j - 1], X[i][j])
                if j < m - 1:
                    X[i][j] = min(2 * horizontal[i][j] + grid[i][j + 1], X[i][j])

        grid = X[:]
    for _ in range(n):
        print(*grid[_])
",O(n ^ 3)
"import sys
input = sys.stdin.readlines()
n = int(input[0].strip())
m = 10**9 + 7
curr = [0] * (n+20)
last = [0] * (n+20)
curr[0] = 1
for s in range(1,n):
    last, curr = curr, last
    if input[s]=='f\n':
        curr[0] = 0
        for i in range(len(last)-1):
            curr[i+1] = last[i]
    elif input[s]=='s\n':
        curr[-1] = 0
        for i in range(len(last)-2, -1, -1):
            curr[i] = (curr[i+1] + last[i]) % m
s = 0
for x in curr:
    s = (s + x) % m
print(s)",O(n ^ 2)
"class Solution(object):
    def checkPartitioning(self, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        P = manacher(s)
        prefix, suffix = [], []
        for i in range(2, len(P)-2):
            if i-1-P[i] == 0:
                prefix.append(i)
            if i+1+P[i] == len(P)-1:
                suffix.append(i)
        for i in prefix:
            for j in suffix:
                left, right = i+1+P[i], j-1-P[j]
                if left > right:
                    continue
                mid = left + (right-left)//2
                if P[mid] >= mid-left:
                    return True
        return False",O(n ^ 2)
"n=int(input())
ls=list(map(int,input().split()))
ls.sort()
if ls.count(min(ls))==len(ls):
	print('NO')
for i in range(n):
	if ls[i]!=min(ls):
		print(ls[i])
		break
",O(nlogn)
"def power(x, y, p) :
    res = 1

    x = x % p

    while (y > 0) :

        if ((y & 1) == 1) :
            res = (res * x) % p

        y = y >> 1
        x = (x * x) % p

    return res

x,k = map(int,input().split())
if x==0:
    print(0)
else:
    ans = power(2,k,1000000007)
    ans = ans * ((2*x)-1)
    ans = ans+1
    ans=ans%1000000007
    print(ans)",O(logn)
"class Solution(object):
    def maxConsecutive(self, bottom, top, special):
        special.sort()
        result = max(special[0]-bottom, top-special[-1])
        for i in range(1, len(special)):
            result = max(result, special[i]-special[i-1]-1)
        return result",O(nlogn)
"import sys
input=sys.stdin.buffer.readline

n=int(input())
a=list(map(int,input().split()))
dp=[[0]*(n) for i in range(n)]
for i in range(n):
    dp[i][i]=a[i]
count=1
for i in range(n-1):
    for j in range(n-i-1):
        dp[j][j+count]=dp[j][j+count-1]^dp[j+1][j+count]
    count+=1
count=1
for i in range(n-1):
    for j in range(n-i-1):
        dp[j][j+count]=max(dp[j][j+count],dp[j][j+count-1],dp[j+1][j+count])
    count+=1
for i in range(int(input())):
    l,r=map(int,input().split())
    l-=1
    r-=1
    print(dp[l][r])",O(n ^ 2)
"import math
mod=10**9 + 7

def calcpower(num,power,mod):

    if(power==0):
        return 1

    a=[num,]
    temp=num
    for i in range(int(math.log(power,2))):

        temp*=temp
        temp=temp%mod
        a.append(temp%mod)

    power=bin(power)[2:]

    power=power[::-1]
    res=1
    for i in range(len(power)):
        if(int(power[i])):
            res=(res*a[i])%mod
    return res%mod
import sys

x,k=map(int,input().split())

if(x==0):
    print(0)
    sys.exit()
if(k==0):
    print(2*x%mod)
    sys.exit()
ans=(2*x-1)*calcpower(2,k,mod)+1

print(ans%mod)",O(logn)
"MOD = 1000000007
def fast_power(base, power):
    result = 1
    while power > 0:
        if power % 2 == 1:
            result = (result * base) % MOD

        power = power // 2
        base = (base * base) % MOD

    return result

x, k = map(int, input().split())

if x == 0 or k == 0:
    print((x * 2) % MOD)
else:
    d = ((x * 4) - 1) - (x * 2)
    print(((x * 2) + (d * (fast_power(2, k) - 1))) % MOD)",O(logn)
"z,x=map(int,input().split())
z-=1;x-=1
if x*(x+1)/2 < z :
  print(-1)
elif z==0:
    print(0)
elif z==x:
    print(1)
else:
    import sys
    start = 1 ; end = x
    while end > start:
        mid = (end +start)//2
        ans =(x*(x+1)//2)-((mid-1)*(mid)//2 )
        if ans == z:
            print(x-mid+1)
            sys.exit(0)
        elif ans > z:
            start = mid+1
        elif ans < z:
            end = mid
    print(x-end+2)
",O(logn)
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    l=sorted(zip(lst(),range(n)))
    p=0;ans=[0]*(2*n)
    st=[0]*n;ln=0
    s=input()
    for i in range(2*n):

        ch=s[i]
        if ch=='0':
            st[ln]=p
            ans[i]=l[p][1]+1
            ln+=1
            p+=1
        else:
            ans[i]=l[st[ln-1]][1]+1
            ln-=1
    print(*ans)",O(nlogn)
"import os

import string

from math import inf
from functools import lru_cache

if os.getcwd() == 'C:\\Users\\User\\Desktop\\python\\Prog\\CodeForces' \
        or os.environ['COMPUTERNAME'] == 'USER145':
    import pdb

    import sys

    pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout)
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
    from pprint import pprint
    from hypothesis import given, settings
    from hypothesis import strategies as st

def ri():
    return [int(i) for i in input().split()]

def to_bits(l):
    ans = 0
    for i in l:
        ans |= (1 << i - 1)
    return ans

user_masks = [0 for i in range(1 << 10)]
pizzas = [[] for i in range(1 << 10)]

@lru_cache()
def count_sat_users(mask):
    ans = 0
    cmask = mask
    while cmask:
        ans += user_masks[cmask]
        cmask = (cmask - 1) & mask
    return ans

def main():
    n, m = ri()
    for _ in range(n):
        k, *a = ri()
        bits = to_bits(a)
        user_masks[bits] += 1

    ans = (float(-inf), float(inf), -1, -1)

    for i in range(m):
        c, k, *a = ri()
        bits = to_bits(a)
        pizzas[bits].append((c, i + 1, bits))
        pizzas[bits].sort()
        while len(pizzas[bits]) > 2:
            pizzas[bits].pop()

    for mask_F in range(1 << 9):
        for mask_S in range(1 << 9):
            if len(pizzas[mask_F]) and len(pizzas[mask_S]) \
                    and mask_F != mask_S:

                mask = mask_F | mask_S

                satisfied_users = count_sat_users(mask)

                f_pizza = next(iter(pizzas[mask_F]))
                s_pizza = next(iter(pizzas[mask_S]))

                summary_cost = 0
                summary_cost += f_pizza[0]
                summary_cost += s_pizza[0]

                ans = max(ans,
                          (satisfied_users,
                           -summary_cost,
                           s_pizza[1],
                           f_pizza[1]))

                bmask = mask
                while bmask:
                    satisfied_users += user_masks[bmask]
                    bmask = (bmask - 1) & mask

            if len(pizzas[mask_F]) == 2:
                satisfied_users = count_sat_users(mask_F)

                it = iter(pizzas[mask_F])

                f_pizza = next(it)
                s_pizza = next(it)
                summary_cost = 0
                summary_cost += f_pizza[0] + s_pizza[0]
                ans = max(ans,
                          (satisfied_users,
                           -summary_cost,
                           s_pizza[1],
                           f_pizza[1]))

            if len(pizzas[mask_S]) == 2:
                satisfied_users = count_sat_users(mask_S)

                it = iter(pizzas[mask_S])

                f_pizza = next(it)
                s_pizza = next(it)
                summary_cost = 0
                summary_cost += f_pizza[0] + s_pizza[0]
                ans = max(ans,
                          (satisfied_users,
                           -summary_cost,
                           s_pizza[1],
                           f_pizza[1]))

    aans = [ans[2],ans[3]]
    aans.sort()
    print(*aans, sep=' ')

main()
",np
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int,sys.stdin.readline().strip().split()))

for i in range (0, n):
    if a[i] >= 0:
        a[i] = - a[i] - 1

if n % 2 == 1:
    i = a.index(min(a))
    a[i] = - a[i] - 1

a = list(map(str,a))
print("" "".join(a))
",O(n)
"class Solution(object):
    def reorderSpaces(self, text):
        text = list(text)
        space_count, word_count = 0, 0
        for i, c in enumerate(text):
            if c == ' ':
                space_count += 1
            elif i == 0 or text[i-1] == ' ':
                word_count += 1

        left, i = 0, 0
        while i < len(text):
            has_word = False
            while i < len(text) and text[i] != ' ':
                text[left], text[i] = text[i], text[left]
                left += 1
                i += 1
                has_word = True
            if has_word:
                left += 1 
            i += 1

        equal_count = space_count//(word_count-1) if word_count-1 > 0 else 0
        extra_count = space_count%(word_count-1) if word_count-1 > 0 else space_count
        right, i = len(text)-1-extra_count, len(text)-1
        while i >= 0:
            has_word = False
            while i >= 0 and text[i] != ' ':
                text[right], text[i] = text[i], text[right]
                right -= 1
                i -= 1
                has_word = True
            if has_word:
                right -= equal_count 
            i -= 1
        return """".join(text)",O(n)
"class Solution(object):
    def maxProfit(self, prices, fee):
        cash, hold = 0, -prices[0]
        for i in range(1, len(prices)):
            cash = max(cash, hold+prices[i]-fee)
            hold = max(hold, cash-prices[i])
        return cash",O(n)
"class Solution(object):
    def rotatedDigits(self, N):
        A = list(map(int, str(N)))
        invalid, diff = set([3, 4, 7]), set([2, 5, 6, 9])
        def dp(A, i, is_prefix_equal, is_good, lookup):
            if i == len(A): return int(is_good)
            if (i, is_prefix_equal, is_good) not in lookup:
                result = 0
                for d in range(A[i]+1 if is_prefix_equal else 10):
                    if d in invalid: continue
                    result += dp(A, i+1,
                                 is_prefix_equal and d == A[i],
                                 is_good or d in diff,
                                 lookup)
                lookup[i, is_prefix_equal, is_good] = result
            return lookup[i, is_prefix_equal, is_good]

        lookup = {}
        return dp(A, 0, True, False, lookup)",O(logn)
"from math import sqrt as sqrt
n, k = map(int, input().split())
t = int(sqrt(8 * n + 8 * k + 9) + 0.0001)
m = (t - 3) // 2
print(n - m)",O(1)
"class Solution(object):
    def firstPalindrome(self, words):
        def is_palindrome(s):
            i, j = 0, len(s)-1
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        for w in words:
            if is_palindrome(w):
                return w
        return """"",O(n)
"class Solution(object):
    def maxRectangleArea(self, xCoord, yCoord):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret
    
        points = sorted((xCoord[i], yCoord[i]) for i in range(len(xCoord)))
        y_to_idx = {y:idx for idx, y in enumerate(sorted(set(yCoord)))}
        bit = BIT(len(y_to_idx))
        lookup = {}
        result = -1
        for i, (x, y) in enumerate(points):
            y_idx = y_to_idx[y]
            bit.add(y_idx, +1)
            if not (i-1 >= 0 and points[i-1][0] == x):
                continue
            prev_y_idx = y_to_idx[points[i-1][1]]
            curr = bit.query(y_idx)-bit.query(prev_y_idx-1)
            if (prev_y_idx, y_idx) in lookup and lookup[prev_y_idx, y_idx][0] == curr-2:
                result = max(result, (x-lookup[prev_y_idx, y_idx][1])*(y-points[i-1][1]))
            lookup[prev_y_idx, y_idx] = (curr, x)
        return result",O(nlogn)
"import collections



class Solution(object):
    def minCost(self, nums, k):
        dp = [float(""inf"")]*(len(nums)+1)
        dp[0] = 0
        for i in range(len(dp)-1):
            cnt = [0]*len(nums)
            d = 0
            for j in range(i+1, len(dp)):
                cnt[nums[j-1]] += 1
                if cnt[nums[j-1]] == 1:
                    d += 1
                elif cnt[nums[j-1]] == 2:
                    d -= 1
                dp[j] = min(dp[j], dp[i]+k+((j-i)-d))
        return dp[-1]",O(n ^ 2)
"import decimal
decimal.getcontext().prec = 100

a, v = map(decimal.Decimal, input().split())
l, d, w = map(decimal.Decimal, input().split())

def DecimalPow(a, b):
    return decimal.Decimal(a) ** decimal.Decimal(b)

def getLastT(v1, dist):
    t1 = (v - v1) / a
    d1 = v1 * t1 + decimal.Decimal(0.5) * a * DecimalPow(t1, 2)
    if d1 >= dist:
        return (-v1 + (v1 ** decimal.Decimal(2) + 2 * a * dist) ** decimal.Decimal(0.5)) / a
    t2 = (dist - d1) / v
    return t1 + t2

if w >= v:
    t1 = v / a
    if decimal.Decimal(0.5) * a * (t1 ** decimal.Decimal(2)) <= l:
        t2 = (l - decimal.Decimal(0.5) * a * (t1 ** decimal.Decimal(2))) / v
    else:
        t1 = (decimal.Decimal(2) * l / a) ** decimal.Decimal(0.5)
        t2 = 0
    t = t1 + t2
    print('{t:.5f}'.format(t = t))

elif (w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t = getLastT(0, l)
    print('{t:.5f}'.format(t = t))

elif (v ** decimal.Decimal(2) - 0) / (2 * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t2 = -w / a + ((w ** decimal.Decimal(2)) / (2 * (a ** decimal.Decimal(2))) + d / a) ** decimal.Decimal(0.5)
    t1 = w / a + t2
    t3 = getLastT(w, l - d)
    t = t1 + t2 + t3
    print('{t:.5f}'.format(t = t))

else:
    t1 = v / a
    t3 = (v - w) / a
    t2 = (d - ((v ** decimal.Decimal(2) - 0) / (decimal.Decimal(2) * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a))) / v
    t4 = getLastT(w, l - d)
    t = t1 + t2 + t3 + t4
    print('{t:.5f}'.format(t = t))",O(1)
"class Solution(object):
    def makeStringsEqual(self, s, target):
        return ('1' in s) == ('1' in target)",O(n)
"n, k =map(int,input().split())
a = list(map(int, input().split()))
if n == 1:
    print(a[0])
    print(1)
else:
    lst = sorted(a)[-k:]
    ans = sum(lst)
    print(ans)
    c = 0
    ln = len(lst)
    ans = [0]
    cnt = 0
    for i in range(n):
        if cnt == k - 1:
            break
        for j in range(ln):
            if a[i] == lst[j]:
                lst[j] = -1
                ans.append(i + 1)
                cnt += 1
                break
    ln = len(ans)
    for i in range(1,ln):
        print(ans[i] - ans[i - 1], end = "" "")
    print(n - ans[-1])
",O(nlogn)
"l,r = list(map(int,input().split()))
f = 0
def gcd(a,b):
    if b == 0:
        return a
    return gcd(b,a%b)
for a in range(l,r+1):
    for b in range(a+1,r+1):
        for c in range(b+1,r+1):

           if (gcd(a,b) == 1) and (gcd(b,c) == 1) and (gcd(a,c)!=1):
                print(a,b,c)
                f = 1
                break
        if f == 1:
            break
    if f == 1:
        break
else:
    print(-1)
",O(1)
"def solve(mat1: list, mat2: list, K: int) -> list:
    if K % 2 == 1:
        res = [[-1] * n for _ in range(m)]
    else:

        dp = [[[-1] * (K // 2 + 1) for _ in range(n)] for _ in range(m)]
        for k in range(K // 2 + 1):
            for i in range(m):
                for j in range(n):
                    if k == 0:
                        dp[i][j][k] = 0
                    else:
                        if i > 0 and (dp[i][j][k] == -1 or dp[i - 1][j][k - 1] + mat2[i - 1][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i - 1][j][k - 1] + mat2[i - 1][j]
                        if i < m - 1 and (dp[i][j][k] == -1 or dp[i + 1][j][k - 1] + mat2[i][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i + 1][j][k - 1] + mat2[i][j]
                        if j > 0 and (dp[i][j][k] == -1 or dp[i][j - 1][k - 1] + mat1[i][j - 1] < dp[i][j][k]):
                            dp[i][j][k] = dp[i][j - 1][k - 1] + mat1[i][j - 1]
                        if j < n - 1 and (dp[i][j][k] == -1 or dp[i][j + 1][k - 1] + mat1[i][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i][j + 1][k - 1] + mat1[i][j]
        res = [[-1] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                res[i][j] = 2 * dp[i][j][-1]
    for i in range(m):
        for j in range(n):
            if j < n - 1:
                print(res[i][j], end = ' ')
            else:
                print(res[i][j])
    return

m, n, K = map(int, input().split())
mat1 = []
mat2 = []
for _ in range(m):
    mat1.append(list(map(int, input().split())))
for _ in range(m - 1):
    mat2.append(list(map(int, input().split())))
solve(mat1, mat2, K)
",O(n ^ 3)
"import math
def getx(n):
    return math.floor(math.sqrt(n))
def getans(n,x):
    l1=[i for i in range(n,0,-1)]
    l2=[]
    i=0
    while(i<n):
        l2=l2+sorted(l1[i:i+x])
        i+=x
    return l2
n=int(input())
a=getx(n)
ans=getans(n,a)
ans1=[str(i) for i in ans]
print(' '.join(ans1))",O(n)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def inorderTraversal(self, root):
        result, curr = [], root
        while curr:
            if curr.left is None:
                result.append(curr.val)
                curr = curr.right
            else:
                node = curr.left
                while node.right and node.right != curr:
                    node = node.right

                if node.right is None:
                    node.right = curr
                    curr = curr.left
                else:
                    result.append(curr.val)
                    node.right = None
                    curr = curr.right

        return result


",O(n)
"n, m = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))

if max(b) > min(g):
    print(-1)
else:
    total = m*sum(b)
    b.sort()
    g.sort()
    while len(g) > 0:
        current = 0
        count = 1
        if len(b) > 0:
            current = b.pop()
        while len(g) > 0 and g[-1] > current and count < m:
            total += g[-1] - current
            g.pop()
            count += 1
        while len(g) > 0 and g[-1] == current:
            g.pop()
    print(total)
",O(nlogn)
"class Solution:
    def isNStraightHand(self, hand, groupSize):
        if len(hand) % groupSize != 0:
            return False

        count = Counter(hand)
        q = deque()
        last_num, open_groups = -1, 0

        for num in sorted(count):
            if ((open_groups > 0 and num > last_num + 1) or
                open_groups > count[num]
            ):
                return False

            q.append(count[num] - open_groups)
            last_num = num
            open_groups = count[num]

            if len(q) == groupSize:
                open_groups -= q.popleft()

        return open_groups == 0
",O(nlogn)
"class Solution(object):
    def largestTriangleArea(self, points):
        result = 0
        for i in range(len(points)-2):
            for j in range(i+1, len(points)-1):
                for k in range(j+1, len(points)):
                    result = max(result,
                                 0.5 * abs(points[i][0] * points[j][1] +
                                           points[j][0] * points[k][1] +
                                           points[k][0] * points[i][1] -
                                           points[j][0] * points[i][1] -
                                           points[k][0] * points[j][1] -
                                           points[i][0] * points[k][1]))
        return result",O(n ^ 3)
"class Solution(object):
    def closetTarget(self, words, target, startIndex):
        INF = float(""inf"")
        result = INF
        for i, w in enumerate(words):
            if w == target:
                result = min(result, (i-startIndex)%len(words), (startIndex-i)%len(words))
        return result if result != INF else -1",O(n)
"class Solution(object):
    def countSpecialSubsequences(self, nums):
        MOD = 10**9+7
        dp = [0]*3
        for x in nums:
            dp[x] = ((dp[x]+dp[x])%MOD+(dp[x-1] if x-1 >= 0 else 1))%MOD
        return dp[-1]",O(n)
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2002)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2002):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])
",O(n ^ 3)
"from math import factorial
s = input().strip()
new = input().strip()
questions = 0
plus = s.count('+')
minus = s.count('-')
for i in new:
	if i == '+':
		plus -= 1
	elif i == '-':
		minus -= 1
	else:
		questions += 1
if plus < 0 or minus < 0:
	print(0)
else:
	num = factorial(questions)/(factorial(plus)*factorial(minus))
	den = 2**questions
	print(""{0:.10f}"".format(num/den))",np
"class Solution4(object):
    def maxOutput(self, n, edges, price):
        def dfs(u, p):
            dp[u] = price[u]
            for v in adj[u]:
                if v == p:
                    continue
                dp[u] = max(dp[u], dfs(v, u)+price[u])
            return dp[u]
        
        def dfs2(u, p, curr):
            result[0] = max(result[0], curr, dp[u]-price[u])
            top2 = [[curr, p], [0, -1]]
            for v in adj[u]:
                if v == p:
                    continue
                curr = [dp[v], v]
                for i in range(len(top2)):
                    if curr > top2[i]:
                        top2[i], curr = curr, top2[i]
            for v in adj[u]:
                if v == p:
                    continue
                dfs2(v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u])
    
        result = [0]
        dp = [0]*n 
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dfs(0, -1)
        dfs2(0, -1, 0)
        return result[0]",O(n)
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    n = I()
    aa = [LI() for _ in range(n)]
    r = []
    for a,b in aa:
        al = a + (1-a%2)
        ar = b - (1-b%2)
        sa = (ar-al) // 2 + 1
        tr = -(al+ar) * sa // 2

        bl = a + (a%2)
        br = b - (b%2)
        sb = (br-bl) // 2 + 1
        tr += (bl+br) * sb // 2
        r.append(tr)

    return ""\n"".join(map(str,r))

print(main())
",O(1)
"t = int(input())

def get_max(n):
    ans = 0
    while n:
        ans = 4 * ans + 1
        n = n - 1
        if ans > 10**19:
            break
    return ans

for _ in range(t):
    n, k = map(int, input().split())
    if n == 1:
        if k == 1:
            print(""YES 0"")
        else:
            print(""NO"")
    elif n == 2:
        if k <= 2:
            print(""YES 1"")
        elif k != 3 and k <= 5:
            print(""YES 0"")
        else:
            print(""NO"")
    else:
        siz = n - 1
        l = 1
        cnt = 3
        while siz:
            if l <= k < l+cnt:
                print(""YES {}"".format(siz))
                break
            l = l + cnt
            cnt = 2 * cnt + 1
            siz = siz - 1
        else:
            if k <= get_max(n):
                print(""YES 0"")
            else:
                print(""NO"")
",O(n)
"n = int(input())
print(n, 0, 0)",O(1)
"class Solution(object):
    def findLatestTime(self, s):
        result = list(s)
        if result[0] == '?': 
            result[0] = '1' if result[1] == '?' or result[1] <= '1' else '0'
        if result[1] == '?': 
            result[1] = '1' if result[0] == '1' else '9'
        if result[3] == '?':
            result[3] = '5'
        if result[4] == '?':
            result[4] = '9'
        return """".join(result)",O(1)
"n=int(input())
A=list(map(int,input().split()))

if n==1:
    print(A[0])

elif n==2:
    print(abs(A[0]-A[1]))

else:
    SUM=0
    for i in range(n):
        SUM+=abs(A[i])
    ANS=0

    for i in range(n-1):
        if ANS<SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1]):
            ANS=SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1])

    print(ANS)
",O(n)
"n , k = map(int , input().split())
n , k = n-1 , k-1

l = 0
r = k
g = k*(k+1)//2
ans = -1

while l <= r:
 	m = (l+r)//2
 	if g-m*(m+1)//2>=n:
 		ans = k-m
 		l = m+1
 	else:
 		r = m-1

print(ans)",O(logn)
"l, r = map(int, input().split())
if r - l + 1 < 3:
    print(-1)
    exit()
if l % 2 == 0:
    print(l, l+1, l+2)
    exit()
if r - l + 1 > 3:
    print(l+1, l+2, l+3)
    exit()
print(-1)
",O(1)
"import collections



class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def removeZeroSumSublists(self, head):
        curr = dummy = ListNode(0)
        dummy.next = head
        prefix = 0
        lookup = collections.OrderedDict()
        while curr:
            prefix += curr.val
            node = lookup.get(prefix, curr)
            while prefix in lookup:
                lookup.popitem()
            lookup[prefix] = node
            node.next = curr.__next__
            curr = curr.__next__
        return dummy.__next__",O(n)
"n=int(input())
arr=list(map(int,input().split()))
dp=[[-1 for i in range(5+1)] for j in range(n)]
for i in range(1,6):
    dp[0][i] =1
for i in range(1,n):
    if arr[i] > arr[i - 1]:
        for j in range(1,6):
            for k in range(1,j):
                if dp[i-1][k]==1:
                    dp[i][j] =1
                    break
    elif arr[i] <arr[i-1]:
        for j in range(1,6):
            for k in range(j+1,6):
                if dp[i-1][k] ==1:
                    dp[i][j]=1
                    break
    else:
        for j in range(1,6):
            for k in range(1,6):
                if j ==k:
                    continue
                if dp[i-1][k] ==1:
                    dp[i][j] =1
                    break
ans=[]
for i in range(1,6):
    if dp[n-1][i]==1:
        ans.append(i)
        break
if len(ans) ==0:
    print(-1)
    exit()
for i in range(n-2,-1,-1):
    curr=ans[-1]
    if arr[i] >arr[i+1]:
        for j in range(curr+1,6):
            if dp[i][j] ==1:
                ans.append(j)
                break
    elif arr[i] <arr[i+1]:
        for j in range(1,curr):
            if dp[i][j] ==1:
                ans.append(j)
                break
    else:
        for j in range(1,6):
            if j ==curr:
                continue
            if dp[i][j] ==1:
                ans.append(j)
                break
ans=ans[::-1]
print(*ans)
",O(n)
"class Solution(object):
    def numberOfPairs(self, nums):
        cnt = [0]*(max(nums)+1)
        pair_cnt = 0
        for x in nums:
            cnt[x] ^= 1
            if not cnt[x]:
                pair_cnt += 1
        return [pair_cnt, len(nums)-2*pair_cnt]",O(n)
"numeros = [int(i) for i in input().split(' ')]

l = bin(numeros[0])
r = bin(numeros[1])

p = -1

if (len(r) == len(l)):
    for i in range (len(l)):
        if (l[i] != r[i]):
            p = i
            break
    if(numeros[0] != numeros[1]):

        saida = 2**(len(r) - p) - 1
        print(saida)
    else:
        print(0)

else:
    if(numeros[0] != numeros[1]):
        saida = 2**(len(r) - 2) - 1

        print(saida)
    else:
        print(0)
",O(logn)
"x=int(input())
d=x//2
print(d+1)
",O(1)
"import sys
input = sys.stdin.readline

n,k=map(int,input().split())

MIN=0
MAX=n

while True:
    ANS=(MIN+MAX)//2

    if (n-ANS)*(n-ANS+1)//2-ANS>k:
        MIN=ANS+1
    elif (n-ANS)*(n-ANS+1)//2-ANS<k:
        MAX=ANS-1
    else:
        print(ANS)
        break
",O(logn)
"class Solution2(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def bfs():
            lookup = [False]*len(circles)
            q = []
            dst = [False]*len(circles)
            for u in range(len(circles)):
                x, y, r = circles[u]
                if x-r <= 0 or y+r >= Y:
                    lookup[u] = True
                    q.append(u)
                if x+r >= X or y-r <= 0:
                    dst[u] = True
            while q:
                new_q = []
                for u in q:
                    if dst[u]:
                        return True
                    x1, y1, r1 = circles[u]
                    for v in range(len(circles)):
                        x2, y2, r2 = circles[v]
                        if lookup[v] or not check(x1, y1, r1, x2, y2, r2):
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return False

        return not bfs()",O(n ^ 2)
"class Solution2(object):
    def minimalKSum(self, nums, k):
        result = prev = 0
        nums.append(float(""inf""))
        for x in sorted(set(nums)):
            if not k:
                break
            cnt = min((x-1)-prev, k)
            k -= cnt
            result += ((prev+1)+(prev+cnt))*cnt//2
            prev = x
        return result",O(nlogn)
"l=list(map(int,input().split()))
s1,s2,s3,s4=0,0,0,0
for i in l:
	if i==1:
		s1+=1
	if i==2:
		s2+=1
	if i==3:
		s3+=1
	if i==4:
		s4+=1

if s3>2 or s2>1 or s1>0 or (s4==2 and s2==1):
	print(""YES"")
else:
	print(""NO"")",O(1)
"s=list(input())
dic={}
for i in range(0,len(s)):
    for j in range(i,len(s)):
        ele="""".join(s[i:j+1])
        if ele not in dic:
            dic[ele]=1
        else:
            dic[ele]+=1

ans=[]
for key in dic.keys():
    if dic[key]>=2:

        ans.append(len(key))
ans.sort()
if ans==[]:
    print(0)
else:

    print(ans[-1])
",O(n ^ 3)
"from sys import stdin, stdout
from math import sin, tan, cos

x, y, z, t1, t2, t3 = map(int, stdin.readline().split())

if abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3 <= abs(x - y) * t1:
    stdout.write('YES')
else:
    stdout.write('NO')",O(1)
"n = int(input())
s = input()
t = input()
p = [-1, -1]
a = [[-1] * 26 for i in range(26)]
k = 0
for i in range(n):
    if t[i] != s[i]:
        k += 1
for i in range(n):
    if t[i] != s[i]:
        if a[ord(t[i]) - 97][ord(s[i]) - 97] != -1:
            print(k - 2)
            print(a[ord(t[i]) - 97][ord(s[i]) - 97] + 1, i + 1)
            exit()
        a[ord(s[i]) - 97][ord(t[i]) - 97] = i
for i in range(n):
    if t[i] != s[i]:
        for j in range(26):
            if a[j][ord(s[i]) - 97] != -1:
                print(k - 1)
                print(a[j][ord(s[i]) - 97] + 1, i + 1)
                exit()
        a[ord(s[i]) - 97][ord(t[i]) - 97] = i
print(k)
print(-1, -1)
",O(n)
"class Solution2(object):
    def isUnivalTree(self, root):
        return (not root.left or (root.left.val == root.val and self.isUnivalTree(root.left))) and \
               (not root.right or (root.right.val == root.val and self.isUnivalTree(root.right)))",O(n)
"import zlib, base64
exec(zlib.decompress(base64.b64decode(b'eJyFV8lu2zAQPTdfIenAUGhR9FygXxLk4MJu4SJwAscJSIEfX4nLzHtDpT0kGM6+j3w83IYfw8M0BhemL8M0+pBiWuYMBzdGtwjYgMUpWGRWtnFJq6Srkh7g4JqSjW9Jm3wKjdYohIzALkivfuX/m02nYBUJ2ZNVLjZPAM5hrFTR5BFGasLg/RbOvPniIsSU0AXAtMgMnanRShPVFx+QA+jRad5CyWhoMUbIqCBL0RII5jSZd+Fg+sLB7dpNWOItRcaFNKqVyFpKgdkR9ELB2PpzhIJGt1amli/aSDlOQ1W5ymHiJFsYYHCkD0VZsMSmDSMl1XpmYM2R9HtTwgOYgCe3KLwXmJUdMRaiID+w28WKfGVICbfyzMaHNKq36IWCC+Qp7gTLoVYRL+28GH6Pjb7JmDjJ1l6AsDu2CGFzJR5RM58wnDCZ/8it9nlXgzYrihNlNr2dFmUoamj1pv961Y93meJ9B62u0gF2rkXzB3qlJziEzfWuYFHWPJQLSrNZExXlgesBaI1S7dDm4v6AYYZkwNRD40AGaBck3vYLibQi4e7Mpzdhf7YtAgh+loaltc0HVw5zYkuEsS7ggJBtuAiJjOrDswaBanOqF9E6C7ebnO0wdKn5+BjM3k1HOl5245pj1yknlqH5iOnZ4TG5pSsPGSN7oesOHf3AbWGaglqiO/MpdM2Q3zUjZBNwYFBD7Q46XvMWlWxICAFca8Mq7x2nQwpdqS0Pa6nXHaxAQUZTtby1qnH+YLH6sFyySaV6qRYumsLpNS4dRyPdzjkSFitEDDDFtXB6irVwggtgVE55RYBFZW4rWm62iMd91wK4JjOL11vfO9LMUS85aODCdWuK7Mu3g7BkuNqOLKSfJwXMY8k/hxLiokkkR2bGIdiZtTWOCWVgH+1NYMPDXMl+q8siUffUp05hY4Q6alBt8DSSVi3jvlzTAppNKU8dpwppDSokDq2uhenx7tfzdTgP58twPVx+n/z5clv/Xt5ufp7n73efXq4b5ni4PZzeD09++vZzGj4P9/df/zyfL/7p/Hrz19P76fp6OqrcPD/Od38BvToehw==')))
",O(n ^ 2)
"x, k = map(int,input().split())
if x == 0:
    print(0)
    exit()
b = pow(2,k,1000000007)
a = (2*x - 1)%(1000000007)
print((a*b + 1) % 1000000007)",O(logn)
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))
c=[n]*n
for i in range(n):
    c[i]-=(r[i]+l[i])
for i in range(n):
    m=0
    for j in range(0,i):
        if c[j]>c[i]:
            m+=1
    if m!=l[i]:
        exit(print('NO'))
for i in range(n):
    m=0
    for j in range(i+1,n):
        if c[j]>c[i]:
            m+=1
    if m!=r[i]:
        exit(print('NO'))
print('YES')
print(*(c))
",O(n ^ 2)
"MAXN = 200001

def less_sum(s, m):
    n = len(s)
    a = 0
    b = 0
    res = 0
    last = 0

    count = [0 for i in range(-MAXN, MAXN+1)]

    count[0] = 1
    x = 0
    last = 1

    for i in range(n):
        if s[i] > m:
            b += 1
        else:
            a += 1
        x = a-b

        if s[i] > m:
            last -= count[x+1]
        else:
            last += count[x]

        res += last
        count[x] += 1
        last += 1

    return res

n, m = map(int, input().split(' '))
s = list(map(int, input().split(' ')))[0:n]

print(less_sum(s, m) - less_sum(s, m-1))",O(nlogn)
"import math

k,n,s,p = input().split()
k = int(k)
n = int(n)
s = int(s)
p = int(p)

sheet_for_each_person = math.ceil(n/s)

total_sheets_required = k*sheet_for_each_person

no_of_packs = math.ceil( total_sheets_required/p )
print(no_of_packs)",O(1)
"from collections import defaultdict
n,k=map(int,input().split())
arr=list(map(int,input().split()))
xors=defaultdict(int)
xors[0]=1
comp=(1<<k)-1
xor=0
ans=n*(n+1)//2
for a in arr:
    xor^=a
    if(xors[xor]>xors[comp^xor]):
        xor^=comp
    ans-=xors[xor]
    xors[xor]+=1
print(ans)",O(n)
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        n,x=ria()
        a=ria()
        d=Counter(a)
        sa=set(a)
        if len(sa)<n:
            print(0)
        else:
            c=0
            for i in a:
                k=i&x
                if k!=i and k in d:
                    c=1
                    print(1)
                    break
            if c==0:
                z=[]
                for i in a:
                    z.append(i&x)
                if len(set(z))<n:
                    print(2)
                else:
                    print(""-1"")

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n)
"n = int(input())
from collections import defaultdict, Counter
a = defaultdict(list)
count_left = Counter()
count_right = Counter()

for _ in range(n):
	l, r = map(int, input().split())
	count_left[l] += 1
	count_right[r] += 1

count = [0] * (n + 1)

pts = sorted(set(count_left.keys()) | set(count_right.keys()))

c = 0
prev = pts[0]
for pt in pts:

	if count_left[pt]:
		count[c] += pt - prev - 1
		c += count_left[pt]
		count[c] += 1
		c -= count_right[pt]
	else:
		count[c] += pt - prev
		c -= count_right[pt]

	prev = pt

print(' '.join(map(str, count[1:])))",O(nlogn)
"class Solution(object):
    def numberOfWeakCharacters(self, properties):
        properties.sort(cmp=lambda a, b: cmp(b[1], a[1]) if a[0] == b[0] else cmp(a[0], b[0]))
        result = max_d = 0
        for a, d in reversed(properties):
            if d < max_d:
                result += 1
            max_d = max(max_d, d)
        return result

import collections",O(nlogn)
"k = int(input())

total_digit = 0
digit = 1

while k > total_digit + digit * (pow(10, digit) - pow(10, digit - 1)):
    total_digit += digit * (pow(10, digit) - pow(10, digit - 1))
    digit += 1

remaining = k - total_digit - 1
corr_num = str(pow(10, digit - 1) + remaining // digit)
print(corr_num[remaining % digit])
",O(logn)
"success = 0
def solve(b, freq, i, n, res):
    global success
    if i == len(b):
        success = res
    else:
        success = 0
        move = 9
        while move >= 0 and success == 0:
            m = int(b[i])
            if freq[move] > 0 and res * 10 + move <= n * 10 + m:
                res = res * 10 + move
                n = n * 10 + m
                freq[move] -= 1
                if solve(b, freq, i + 1, n, res) == 0:
                    res //= 10
                    n //= 10
                    freq[move] += 1
            move -= 1
    return success

a = input()
b = input()
freq = []
for i in range(10):
    freq.append(0)
v = []
for x in a:
    n = int(x)
    v.append(n)
    freq[n] += 1
v.sort()
ans = 0
if len(b) > len(a):
    m = 1
    for x in v:
        ans = x * m + ans
        m *= 10
else:
    ans = solve(b, freq, 0, 0, 0)
print(ans)",O(n ^ 3)
"import sys,os,io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n = int(input())
c = [int(i) for i in input().split()]
a = [int(i)-1 for i in input().split()]
vis = [-1]*n
ans = 0
for i in range (n):
    ind = i
    while(vis[ind]==-1):
        vis[ind]=i
        ind = a[ind]
    if vis[ind]==i:
        start = ind
        ind = a[ind]
        cost = c[start]
        while(ind!=start):
            cost = min(cost, c[ind])
            ind = a[ind]
        ans+=cost
print(ans)
",O(n)
"def occurrences(string, sub):
    count = start = 0
    while True:
        start = string.find(sub, start) + 1
        if start > 0:
            count += 1
        else:
            return count

class CodeforcesTask23ASolution:
    def __init__(self):
        self.result = ''
        self.string = ''

    def read_input(self):
        self.string = input()

    def process_task(self):
        o_max = 0
        for x in range(len(self.string)):
            for y in range(x):
                m = occurrences(self.string, self.string[y:x])
                if m >= 2:
                    o_max = max(x - y, o_max)
        self.result = str(o_max)

    def get_result(self):
        return self.result

if __name__ == ""__main__"":
    Solution = CodeforcesTask23ASolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())
",O(n ^ 3)
"class Solution(object):
    def lengthOfLongestSubstringKDistinct(self, s, k):
        longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in range(256)]
        for i, char in enumerate(s):
            if visited[ord(char)] == 0:
                distinct_count += 1
            visited[ord(char)] += 1
            while distinct_count > k:
                visited[ord(s[start])] -= 1
                if visited[ord(s[start])] == 0:
                    distinct_count -= 1
                start += 1
            longest = max(longest, i - start + 1)
        return longest",O(n)
"class Solution2(object):
    def reverseList(self, head):
        [begin, end] = self.reverseListRecu(head)
        return begin

    def reverseListRecu(self, head):
        if not head:
            return [None, None]

        [begin, end] = self.reverseListRecu(head.__next__)

        if end:
            end.next = head
            head.next = None
            return [begin, head]
        else:
            return [head, head]",O(n)
"n = int(input().rstrip())
arr = []
mod = pow(10,9) + 7
indent_num = 0
for i in range(n):
    arr.append(input().rstrip())
    if arr[i] == 'f':
        indent_num += 1
dp = [0 for i in range(indent_num + 1)]
first_block_index = 0
max_indent = 0
for i in arr:
    if i != 'f':
        break
    first_block_index += 1
    max_indent += 1

dp[max_indent] = 1

cur_indent = 0
pref = [0 for i in range(indent_num + 1)]
def cal_pref(dp, pref):
    pref[0] = dp[0]
    for i in range(1, len(dp)):
        pref[i] = pref[i - 1] + dp[i]

for i in range(first_block_index + 1,n):
    if arr[i] == 'f':
        cur_indent += 1
        max_indent += 1
        continue

    cur = [0 for i in range(indent_num + 1)]
    cal_pref(dp, pref)
    for j in range(cur_indent,indent_num + 1):
        res_idx = j - cur_indent
        res_result = pref[res_idx - 1] if res_idx > 0 else 0
        cur[j] = (pref[indent_num] - res_result) % mod

    cur[max_indent] = 1 if not cur[max_indent] else cur[max_indent]
    dp = cur
    cur_indent = 0

print(sum(dp) % mod)
",O(n ^ 2)
"a = list(map(int, input().split()))
n = a[0]
k = a[1]
s = input()
m = int(-1)
for i in range(0, n - 1):
    ff = int(0)
    for j in range(0, i + 1):
        if s[j] != s[n - i - 1 + j]:
            ff = 1
            break;
    if ff == 0:
        m = i
print(s, end="""")
for i in range(1, k):
    for j in range(m + 1, n):
        print(s[j], end="""")
",O(n ^ 2)
"n = int(input())
a = sorted(list(map(int, input().split())))
duplicates = {}
d = None
delta = 0
for i, el in enumerate(a, 1):
    if el not in duplicates:
        duplicates[el] = 0
    else:
        d = el
        duplicates[el] += 1
    min_value = i-1
    delta += el - min_value
if sum(duplicates.values()) > 1 or duplicates.get(0, 0) >= 1 or (d is not None and d-1 in duplicates):
    print('cslnb')
elif delta == 0:
    print('cslnb')
elif delta % 2 == 1:
    print('sjfnb')
else:
    print('cslnb')
",O(n)
"n=int(input())
g=n//2
print(g+n)",O(1)
"from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

def mapin():
    return map(int, input().split())

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
x, k = mapin()
p = 1000000007
if(x == 0):
    print(0)
else:
    a = power(2, k, p)

    b = x+x-1
    b %= p
    a = (a*b) % p
    a += 1
    a %= p
    print(a)",O(logn)
"from bisect import bisect_left as bl
from bisect import bisect_right as br
import heapq
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

def factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))

def li():return [int(i) for i in input().rstrip('\n').split(' ')]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n').split(' ')]
def li3():return [int(i) for i in input().rstrip('\n')]

n,L = li()
l = []
for i in range(n):
    l.append(li())

index = defaultdict(list)
for ind,i in enumerate(l):
    index[tuple(i)].append(ind + 1)

l.sort(key = lambda x:x[1])
d = defaultdict(list)

ans = i = tot = currpoints = 0
anspattern = []
he = []

while i < n:

    if l[i][1] + tot <= L:
        tot += l[i][1]
        heapq.heappush(d[l[i][0]],l[i][1])
        currpoints += 1

        if len(d[l[i][0]]) == 1:
            heapq.heappush(he,l[i][0])

    while len(he) and currpoints > he[0]:
        temp = heapq.heappop(he)
        tot -= heapq.heappop(d[temp])
        currpoints -= 1
        if len(d[temp]):heapq.heappush(he,temp)

    if currpoints > ans:

        ans = currpoints

    i += 1
i = tot = currpoints = 0
he = []
d = defaultdict(list)

while i < n:

    if l[i][1] + tot <= L:
        tot += l[i][1]
        heapq.heappush(d[l[i][0]],l[i][1])
        currpoints += 1

        if len(d[l[i][0]]) == 1:
            heapq.heappush(he,l[i][0])

    while len(he) and currpoints > he[0]:
        temp = heapq.heappop(he)
        tot -= heapq.heappop(d[temp])
        currpoints -= 1
        if len(d[temp]):heapq.heappush(he,temp)

    if currpoints == ans:
        anspattern = []
        for i in he:
            for j in d[i]:
                anspattern.append(index[tuple([i,j])][-1])
                index[tuple([i,j])].pop()
        print(ans)
        print(len(anspattern))
        print(*sorted(anspattern))
        exit()

        ans = currpoints

    i += 1",O(nlogn)
"class Solution(object):
    def pivotInteger(self, n):
        x = int(((n+1)*n//2)**0.5+0.5)
        return x if x**2 == (n+1)*n//2 else -1",O(1)
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp=[[[-1 for i in range(205)] for j in range(205)] for k in range(205)]
def recurser(x,y,z):
    if (x>=R and y>=G) or (y>=G and z>=B) or (z>=B and x>=R):
        return 0
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    maxi=0
    if x<R and y<G:
        maxi=max(maxi,r[x]*g[y]+recurser(x+1,y+1,z))
    if y<G and z<B:
        maxi=max(maxi,g[y]*b[z]+recurser(x,y+1,z+1))
    if z<B and x<R:
        maxi=max(maxi,r[x]*b[z]+recurser(x+1,y,z+1))
    dp[x][y][z]=maxi
    return maxi
print(recurser(0,0,0))",O(n ^ 3)
"a , b , c , d , e , f = map(int,input().split())
n , n1 = 1 , a * b + c * d + e * f
while n ** 2 < n1 :
    n += 1
if n ** 2 > n1 :
    print(-1)
    exit()
l = sorted([[max(a,b),min(a,b),'A'], [max(c,d),min(c,d),'B'], [max(e,f),min(e,f),'C']])
if l[2][0] != n:
    print(-1)
    exit()
v = str(n) + '\n' + (l[2][2] * n + '\n') * l[2][1]
if l[0][0] == n and l[1][0] == n:
    for i in range(2):
        v += (l[i][2] * n + '\n') * l[i][1]
else:
    s = n - l[2][1]
    if s not in l[0] or s not in l[1] :
        print(-1)
        exit()
    x , y = l[0][1] if s == l[0][0] else l[0][0] , l[1][1] if s == l[1][0] else l[1][0]
    v += (l[0][2] * x + l[1][2] * y + '\n') * s
print(v)",np
"from sys import stdin,stdout
from math import ceil
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):
    k,n,s,p=lst()
    spp=ceil(n/s)
    tots=spp*k
    print(ceil(tots/p))
",O(1)
"import sys

n = sys.stdin.readline()
n = int(n)
def get_graph(n):
    graph = []
    for _ in range(n):
        entries = list(map(lambda x : int(x), sys.stdin.readline().split("" "")[1:]))
        graph.append(entries)
    return graph

def chain(target, buckets, reverse_bucket, sum_bucket, bucket_num, val):
    mask = 2**bucket_num
    mem = []
    buckets_seen = set({bucket_num})

    og_bucket = bucket_num
    og_val = val
    for _ in range(len(buckets)):
        rem = target - sum_bucket[bucket_num] + val
        if rem not in reverse_bucket:
            return None, []

        new_bucket = reverse_bucket[rem]
        if new_bucket == og_bucket and rem != og_val:
            return None, []
        elif new_bucket == og_bucket and rem == og_val:
            mem.append((rem, bucket_num))
            return mask | 2**new_bucket, mem
        elif new_bucket in buckets_seen:
            return None, []

        buckets_seen.add(new_bucket)
        mask = mask | 2**new_bucket

        mem.append((rem, bucket_num))
        bucket_num = new_bucket
        val = rem
    return None, []

def helper(chains, mask, mem):
    if mask == 0:
        return []
    if mask in mem:
        return mem[mask]

    for i, chain in enumerate(chains):
        if (mask >> i) & 0:
            continue
        for key in chain:
            if key | mask != mask:
                continue

            future = helper(chains, ~key & mask, mem)
            if future is not None:
                mem[mask] = chain[key] + future
                return mem[mask]
    mem[mask] = None
    return None

def solve(n):
    buckets = get_graph(n)
    reverse_bucket = {}
    sum_bucket = [0]* len(buckets)
    total_sum = 0
    for i, bucket in enumerate(buckets):
        for x in bucket:
            total_sum += x
            sum_bucket[i] += x
            reverse_bucket[x] = i

    target = total_sum / len(buckets)

    chains = []
    for i, bucket in enumerate(buckets):
        seto = {}
        for x in bucket:
            key, val = chain(target, buckets, reverse_bucket, sum_bucket, i, x)
            if key is not None:
                seto[key] = val
        chains.append(seto)
    return helper(chains, 2 ** len(buckets) - 1, {}), reverse_bucket

def result(n):
    res, reverse_bucket = solve(n)
    if res is None:
        sys.stdout.write(""No\n"")
    else:
        res = sorted(res, key = lambda x : reverse_bucket[x[0]])
        sys.stdout.write(""Yes\n"")
        for x, y in res:
            x = int(x)
            y = int(y) + 1
            stuff = "" "".join([str(x), str(y), ""\n""])
            sys.stdout.write(stuff)
result(n)",np
"from bisect import bisect_right
n, x, y = map(int, input().split(' '))
s=[0]*n
e=[0]*n
v=[0]*n
c=0
for i in range(n):
    s[i],e[i]=map(int, input().split(' '))
    c+=x+(e[i]-s[i])*y
s.sort()
e.sort()
for i in range(n-2,-1,-1):
    k=bisect_right(s,e[i])
    while (k < n)  and (v[k]==1) and (s[k]-e[i]) * y < x :
        k+=1
    if k==n:
        continue
    if (s[k]-e[i]) * y < x :
        v[k] = 1
        c+=(s[k]-e[i])*y-x

print(c%(10**9+7))",O(nlogn)
"n=int(input())
dict1={}
for i in range(n-1):
    x,y=map(int,input().split())
    try:
        dict1[y].append(x)
    except:
        KeyError
        dict1[y]=[x]
    try:
        dict1[x].append(y)
    except:
        KeyError
        dict1[x]=[y]
arr=list(map(int,input().split()))
if(arr[0]!=1):
    print(""No"")
else:
    j=0
    i=1
    flag=0
    while(i<n and j<n):
        if(arr[j] in dict1[arr[i]]):
            i+=1
        else:
            j+=1
    if(i!=n and j==n):
        print('No')
    else:
        print('Yes')
",O(n)
"import bisect
import itertools


class Solution(object):
    def minArea(self, image, x, y):
        def binarySearch(left, right, find, image, has_one):
            while left <= right: 
                mid = left + (right - left) / 2
                if find(image, has_one, mid): 
                    right = mid - 1
                else:
                    left = mid + 1
            return left


        searchColumns = lambda image, has_one, mid: any([int(row[mid]) for row in image]) == has_one
        left = binarySearch(0, y - 1, searchColumns, image, True)
        right = binarySearch(y + 1, len(image[0]) - 1, searchColumns, image, False)

        searchRows = lambda image, has_one, mid: any(map(int, image[mid])) == has_one
        top = binarySearch(0, x - 1, searchRows, image, True)
        bottom = binarySearch(x + 1, len(image) - 1, searchRows, image, False)

        return (right - left) * (bottom - top)",O(nlogn)
"class Solution:
    def getSum(self, a: int, b: int) -> int:
        mask = 0xFFFFFFFF
        max_int = 0x7FFFFFFF

        while b != 0:
            carry = (a & b) << 1
            a = (a ^ b) & mask
            b = carry & mask

        return a if a <= max_int else ~(a ^ mask)
",O(1)
"n = int(input())

b = [int(_) for _ in input().split()]

e = [[-1] * (n+1) for _ in range(2024)]

d = [[] for _ in range(n)]

for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])",O(n ^ 3)
"

class Solution(object):
    def sortPeople(self, names, heights):
        order = list(range(len(names)))
        order.sort(key=lambda x: heights[x], reverse=True)
        return [names[i] for i in order]
",O(nlogn)
"class Solution(object):
    def longestValidParentheses(self, s):
        def length(it, start, c):
            depth, longest = 0, 0
            for i in it:
                if s[i] == c:
                    depth += 1
                else:
                    depth -= 1
                    if depth < 0:
                        start, depth = i, 0
                    elif depth == 0:
                        longest = max(longest, abs(i - start))
            return longest

        return max(length(range(len(s)), -1, '('), \
                   length(reversed(range(len(s))), len(s), ')'))",O(n)
"class Solution(object):
    def findScore(self, nums):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: (nums[x], x))
        lookup = [False]*len(nums)
        result = 0
        for i in idxs:
            if lookup[i]:
                continue
            lookup[i] = True
            if i-1 >= 0:
                lookup[i-1] = True
            if i+1 < len(lookup):
                lookup[i+1] = True
            result += nums[i]
        return result",O(nlogn)
"class Solution(object):
    def boxDelivering(self, boxes, portsCount, maxBoxes, maxWeight):
        dp = [0]*(len(boxes)+1)
        left, cost, curr = 0, 1, 0
        for right in range(len(boxes)):
            if right == 0 or boxes[right][0] != boxes[right-1][0]:
                cost += 1
            curr += boxes[right][1]
            while right-left+1 > maxBoxes or \
                  curr > maxWeight or \
                  (left+1 < right+1 and dp[left+1] == dp[left]): 
                curr -= boxes[left][1]
                if boxes[left+1][0] != boxes[left][0]:
                    cost -= 1
                left += 1
            dp[right+1] = dp[(left-1)+1] + cost
        return dp[len(boxes)]",O(n)
"from sys import stdin
input=stdin.readline
def check(mid,a,limit):
	res=[]
	s=0
	for r,t,id in a:
		if r>=mid and t+s<=limit:
			res.append(id+1)
			s+=t
		elif t+s>limit:
			break
		if len(res)==mid:
			break

	return res

def f(a,limit):
	a.sort(key=lambda s:s[1])
	ans=None
	lo=0
	hi=10**9
	while lo<=hi:
		mid=(lo+hi)//2
		res=check(mid,a,limit)
		if len(res)>=mid:
			lo=mid+1
			ans=(res,mid)
		else:
			hi=mid-1
	print(ans[1])
	print(ans[1])
	print(*ans[0])

n,limit=map(int,input().strip().split())
q=[]
for i in range(n):
	x,y=map(int,input().strip().split())
	q.append((x,y,i))
f(q,limit)",O(nlogn)
"import random


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def kthLargestLevelSum(self, root, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        arr = []
        q = [root]
        while q:
            new_q = []
            for u in q:
                if u.left:
                    new_q.append(u.left)
                if u.right:
                    new_q.append(u.right)
            arr.append(sum(x.val for x in q))
            q = new_q
        if k-1 >= len(arr):
            return -1
        nth_element(arr, k-1, compare=lambda a, b: a > b)
        return arr[k-1]",O(n)
"class Solution(object):
    def shortestWordDistance(self, words, word1, word2):
        dist = float(""inf"")
        is_same = (word1 == word2)
        i, index1, index2 = 0, None, None
        while i < len(words):
            if words[i] == word1:
                if is_same and index1 is not None:
                    dist = min(dist, abs(index1 - i))
                index1 = i
            elif words[i] == word2:
                index2 = i

            if index1 is not None and index2 is not None:
                dist = min(dist, abs(index1 - index2))
            i += 1

        return dist",O(n)
"def main():
    high = 10 ** 12
    n, m, k = map(int, input().split())
    hozs = []
    for i in range(n):
        hozs.append(list(map(int, input().split())))
    verts = []
    for i in range(n - 1):
        verts.append(list(map(int, input().split())))
    if k % 2:
        for i in range(n):
            print(""-1 "" * m)
        return
    k //= 2
    dp = []
    for i in range(n):
        dp.append([])
        for j in range(m):
            dp[-1].append([])
            for kay in range(k + 1):
                dp[-1][-1].append(0)
    for depth in range(1, k + 1):
        for i in range(n):
            for j in range(m):
                if i == 0:
                    up = high
                else:
                    up = verts[i - 1][j] + dp[i - 1][j][depth - 1]
                if i == n - 1:
                    down = high
                else:
                    down = verts[i][j] + dp[i + 1][j][depth - 1]
                if j == 0:
                    left = high
                else:
                    left = hozs[i][j - 1] + dp[i][j - 1][depth - 1]
                if j == m - 1:
                    right = high
                else:
                    right = hozs[i][j] + dp[i][j + 1][depth - 1]
                min_cost = min(up, down, left, right)

                dp[i][j][depth] += min_cost
    for i in range(n):
        print(*[2 * dp[i][j][k] for j in range(m)])
main()",O(n ^ 3)
"from sys import stdin, gettrace

if not gettrace():
    def input():
        return next(stdin)[:-1]

INF = 10000

def main():
    n = int(input())
    aa = [int(a) for a in input().split()]

    dp = [[0] * (n+1) for _ in range(n)]

    def calc_dp(i, j):
        if i + 1 == j:
            dp[i][j] = aa[i]
        if dp[i][j] != 0:
            return dp[i][j]
        dp[i][j] = -1
        for k in range(i+1, j):
            lf = calc_dp(i, k)
            rg = calc_dp(k, j)
            if lf > 0 and lf == rg:
                dp[i][j] = lf + 1
                break
        return dp[i][j]

    dp2 = list(range(0,n+1))
    for i in range(n):
        for j in range(i+1, n+1):
            if calc_dp(i, j) > 0:
                dp2[j] = min(dp2[j], dp2[i] + 1)
    print(dp2[n])

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"class Solution(object):
    def missingNumber(self, arr):
        def check(arr, d, x):
            return arr[x] != arr[0] + d*x

        d = (arr[-1]-arr[0])//len(arr)
        left, right = 0, len(arr)-1
        while left <= right:
            mid = left + (right-left)//2
            if check(arr, d, mid):
                right = mid-1
            else:
                left = mid+1
        return arr[0] + d*left",O(logn)
"class Solution(object):
    def numDistinct(self, S, T):
        ways = [0 for _ in range(len(T) + 1)]
        ways[0] = 1
        for S_char in S:
            for j, T_char in reversed(list(enumerate(T))):
                if S_char == T_char:
                    ways[j + 1] += ways[j]
        return ways[len(T)]",O(n ^ 2)
"class Solution(object):
    def readBinaryWatch(self, num):
        def bit_count(bits):
            count = 0
            while bits:
                bits &= bits-1
                count += 1
            return count

        return ['%d:%02d' % (h, m) for h in range(12) for m in range(60)
                if bit_count(h) + bit_count(m) == num]

    def readBinaryWatch2(self, num):
        return ['{0}:{1}'.format(str(h), str(m).zfill(2))
                for h in range(12) for m in range(60)
                if (bin(h) + bin(m)).count('1') == num]",O(1)
"read = lambda: map(int, input().split())
n, k = read()
s = input()
c = [0] * 26
for i in range(n):
    if s[i] <= chr(ord('A') + k - 1):
        c[ord(s[i]) - ord('A')] += 1
print(min(c[:k]) * k)",O(n)
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]
ans = []

def check(mid: int) -> bool:
    global ans
    dic = {}
    for i in range(n):
        bit = 0
        for j in range(m):
            if a[i][j] >= mid:
                bit += 1
            bit <<= 1
        dic[bit >> 1] = i
    for x, idx in dic.items():
        for y, idy in dic.items():
            if x | y == 2**m-1:
                ans = idx + 1, idy + 1
                return True
    return False

le = 0
ri = int(1e9)
while le <= ri:
    mid = (le + ri) >> 1
    if check(mid):
        le = mid + 1
    else:
        ri = mid - 1
print(ans[0], ans[1])
",np
"t=int(input())
for i in range(t):
    n=int(input())
    ar=list(map(int,input().split()))
    if(n<=2):
        print(0)
        continue
    ar=sorted(ar)[::-1]
    ans=0
    for i in range(1,n-1):
        if(ar[0]>i and ar[1]>i):
            ans=i
    print(ans)
",O(nlogn)
"class MinIdx_Segtree:
    def __init__(self, N, A):
        self.n = N
        self.INF = int(1e9)
        self.A = A
        while (self.n & (self.n - 1)) != 0:
            self.A.append(self.INF)
            self.n += 1
        self.tree = [0] * (2 * self.n)
        self.build()

    def build(self):
        for i in range(self.n):
            self.tree[self.n + i] = i
        for j in range(self.n - 1, 0, -1):
            a = self.tree[j << 1]
            b = self.tree[(j << 1) + 1]
            if self.A[a] <= self.A[b]:
                self.tree[j] = a
            else:
                self.tree[j] = b

    def update(self, i, val):
        self.A[i] = val
        j = (self.n + i) >> 1
        while j >= 1:
            a = self.tree[j << 1]
            b = self.tree[(j << 1) + 1]
            if self.A[a] <= self.A[b]:
                self.tree[j] = a
            else:
                self.tree[j] = b
            j >>= 1

    def query(self, ql, qh):
        return self._query(1, 0, self.n - 1, ql, qh)

    def _query(self, node, l, h, ql, qh):
        if ql > h or qh < l:
            return self.INF
        if l >= ql and h <= qh:
            return self.tree[node]
        a = self._query(node << 1, l, (l + h) >> 1, ql, qh)
        b = self._query((node << 1) + 1, ((l + h) >> 1) + 1, h, ql, qh)
        if a == self.INF:
            return b
        if b == self.INF:
            return a
        return a if self.A[a] <= self.A[b] else b

class Solution:
    def getMaxArea(self, heights, l, r, st):
        if l > r:
            return 0
        if l == r:
            return heights[l]
        minIdx = st.query(l, r)
        return max(max(self.getMaxArea(heights, l, minIdx - 1, st),
                       self.getMaxArea(heights, minIdx + 1, r, st)),
                   (r - l + 1) * heights[minIdx])

    def largestRectangleArea(self, heights):
        n = len(heights)
        st = MinIdx_Segtree(n, heights)
        return self.getMaxArea(heights, 0, n - 1, st)
",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase

def main():
    a=list(map(int,input().rstrip()))
    b=list(map(int,input().rstrip()))
    ans,la,lb=[],len(a),len(b)
    if la!=lb:
        print(*sorted(a,reverse=True),sep="""")
    else:
        for i in range(lb):
            if b[i] in a:
                ans.append(b[i])
                a.remove(b[i])
            else:
                while i>-1:
                    ma=-1
                    for j in a:
                        if j<b[i]:
                            ma=max(ma,j)
                    if ma!=-1:
                        ans.append(ma)
                        a.remove(ma)
                        break
                    i-=1
                    a.append(ans.pop())
                a.sort()
                while a:
                    ans.append(a.pop())
                break
        print("""".join(str(i) for i in ans))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(n ^ 3)
"class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        q = deque([(root, float(""-inf""), float(""inf""))])

        while q:
            node, left, right = q.popleft()
            if not (left < node.val < right):
                return False
            if node.left:
                q.append((node.left, left, node.val))
            if node.right:
                q.append((node.right, node.val, right))

        return True
",O(n)
"n = int(input())

p = []
for i in range(n):
    la = list(map(float,input().split()))
    p.append(la)

full_bit =  (1<<n) - 1
dp = [0]*(full_bit) + [1]

for i in range(full_bit,0,-1):

    cunt = bin(i)[2:].count('1')

    if cunt == 1 or dp[i] == 0:
        continue

    mul = 1/((cunt*(cunt-1))>>1)

    for x in range(n):
        if (i & (1<<x)) == 0:
            continue
        for y in range(x+1,n):
            if (i & (1<<y)) == 0:
                continue

            dp[i-(1<<y)]+=dp[i]*p[x][y]*mul
            dp[i-(1<<x)]+=dp[i]*p[y][x]*mul

ans = []
for i in range(n):
    ans.append(dp[1<<i])

print(*ans)
",np
"class Solution(object):
    def decode(self, encoded, first):
        result = [first]
        for x in encoded:
            result.append(result[-1]^x)
        return result",O(n)
"class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        pair = [(p, s) for p, s in zip(position, speed)]
        pair.sort(reverse=True)

        fleets = 1
        prevTime = (target - pair[0][0]) / pair[0][1]
        for i in range(1, len(pair)):
            currCar = pair[i]
            currTime = (target - currCar[0]) / currCar[1]
            if currTime > prevTime:
                fleets += 1
                prevTime = currTime
        return fleets
",O(nlogn)
"class Solution(object):
    def stableMountains(self, height, threshold):
        return [i for i in range(1, len(height)) if height[i-1] > threshold]",O(n)
"import sys, os

numbs = [int(x) for x in sys.stdin.buffer.read().split()]
n = numbs.pop(0)

base = []
out = []

for i in range(n):
    x = numbs[i]
    how = 0

    for b,rep in base:
        if x.bit_length() == b.bit_length():
            x ^= b
            how ^= rep

    if x:
        how |= 1 << i

        a = 0
        b = len(base)
        while a < b:
            c = a + b >> 1
            if base[c][0] > x:
                a = c + 1
            else:
                b = c
        base.insert(a, (x, how))

        out.append(0)
    else:
        outind = len(out)
        out.append(-1)

        y = bin(how).encode('ascii')
        ylen = len(y)
        for i in range(2,len(y)):
            if y[i] == 49:
                out.append(ylen - 1 - i)
        out[outind] = len(out) - 1 - outind

os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))
",np
"t=list(map(int,input().split()))
n=t[0]
c=t[1]
a=list(map(int,input().split()))
f=[]
for i in range(0,500001):
	f.append(0)
l=[]
for i in range(0,500001):
	l.append([0])
m=0
for i in range(n):
	l[a[i]].append(f[a[i]]-m)
	if a[i]==c:
		m+=1
	f[a[i]]+=1
	l[a[i]].append(f[a[i]]-m)
ma=0
for i in l:
	mi=0
	for j in i:
		if(j<mi):
			mi=j
		if(ma<j-mi):
			ma=j-mi
print(m+ma)",O(n)
"class Solution(object):
    def countKConstraintSubstrings(self, s, k, queries):
        def count(l):
            return (l+1)*l//2

        result = cnt = left = 0
        prefix = [0]*(len(s)+1)
        lookup = [-1]*len(s)
        for right in range(len(s)):
            cnt += int(s[right] == '1')
            while not (cnt <= k or (right-left+1)-cnt <= k):
                cnt -= int(s[left] == '1')
                left += 1
            result += right-left+1
            prefix[right+1] = prefix[right]+(right-left+1)
            lookup[left] = right
        assert(lookup[0] != -1)
        for i in range(len(s)-1):
            if lookup[i+1] == -1:
                lookup[i+1] = lookup[i]
        return [count(min(lookup[left], right)-left+1)+(prefix[right+1]-prefix[min(lookup[left], right)+1]) for left, right in queries]",O(n)
"import math

no_of_moves , no_of_candy = map(int,input().split())

total_candy = now_candy = 1
now_moves = 1

if(no_of_moves == 0 or (no_of_moves ==1 and no_of_candy == 1)):
    print(0)
else:
    while True:

        now_candy = now_candy + 1
        total_candy += now_candy
        now_moves += 1
        if(total_candy -(no_of_moves - now_moves) == no_of_candy):
            break

    print(no_of_moves - now_moves)",O(logn)
"n, k = list(map(int, input().split()))
arr = list(map(int, input().split()))

count = [0]*(int(1e5+1))

for i in arr:
    count[i] += 1

s = sum([1 if i>0 else 0 for i in count])
if s < k:
    print('-1 -1')
    exit()

r = n-1
while True:
    if count[arr[r]] == 1:
        s -= 1
        if s < k:
            s += 1
            break
    count[arr[r]] -= 1
    r -= 1

l=0
while True:
    if count[arr[l]] == 1:
        s -= 1
        if s < k:
            s += 1
            break
    count[arr[l]] -= 1
    l += 1

print(l+1, r+1)
",O(n)
"mod = int(1e9 + 7)

n = int(input())
a = [int(_) for _ in input().split()]

freq = {i: 0 for i in range(100001)}
power = {0: 1}
for i in range(1, 100001):
    power[i] = (2 * power[i - 1]) % mod

for v in a:
    freq[v] += 1

dp = {i: 0 for i in range(100001)}
for gcd in range(100000, 0, -1):
    mult = 2
    total = freq[gcd]
    complement = 0

    while mult * gcd <= 100000:
        total += freq[mult * gcd]
        complement += dp[mult * gcd]
        mult += 1
    dp[gcd] = (power[total] - 1 - complement + mod) % mod

print(dp[1])",np
"n,queries = list(map(int,input().split()))
l = list(map(int,input().split()))
if(queries==0):
	exit()
maxval = max(l)
pairs = []
count = 0
f = l[0]
secix = 1
while(f!=maxval):

	count+=1
	f = l[0]
	s = l[secix]
	pairs.append([f,s])
	f,s= max(f,s), min(f,s)
	l[0] = f
	l.append(s)
	secix+=1

l = [l[0]]+l[secix:]

for i in range(n-1):
	pairs.append([maxval,l[1+i]])

for m in range(queries):
	q = int(input())
	if(q<=count):
		print(str(pairs[q-1][0]),str(pairs[q-1][1]))
	else:
		q-=(count+1)
		pos = count+(q%(n-1))
		print(str(pairs[pos][0]),str(pairs[pos][1]))",O(n)
"import sys as _sys

_sys.setrecursionlimit(2**14)

_cache = dict()

class _SortedSeqs:

    def __init__(self, seqs):
        self.seqs = tuple(tuple(sorted(seq)) for seq in seqs)

    def __hash__(self):
        return id(self)

def compute_max_area(r_seq, g_seq, b_seq):
    sorted_seqs_obj = _SortedSeqs((r_seq, g_seq, b_seq))
    seqs_sizes = tuple(map(len, sorted_seqs_obj.seqs))
    return _compute_max_area(sorted_seqs_obj, seqs_sizes)

def _compute_max_area(sorted_seqs_obj, seqs_sizes):
    cache_key = (sorted_seqs_obj, seqs_sizes)
    if cache_key in _cache.keys():
        return _cache[cache_key]

    seqs = sorted_seqs_obj.seqs
    nonempty_seqs_n = _how_many_nonempty(seqs_sizes)

    if nonempty_seqs_n < 2:
        ab_seqs_indices_list = []

    elif nonempty_seqs_n == 2:
        ab_seqs_indices = [i for i, seq_size in enumerate(seqs_sizes) if seq_size > 0]
        ab_seqs_indices_list = [ab_seqs_indices]

    else:
        assert nonempty_seqs_n == 3
        seqs_indices_sorted_by_size = [
            i for i, seq in sorted(
                enumerate(seqs),
                key=lambda pair: (pair[1][seqs_sizes[pair[0]]-1], seqs_sizes[pair[0]])
            )
        ]
        ab_seqs_indices_1 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[0]
        ab_seqs_indices_2 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[1]
        ab_seqs_indices_list = [ab_seqs_indices_1, ab_seqs_indices_2]

    max_areas_variants = []
    for a_seq_index, b_seq_index in ab_seqs_indices_list:
        a_seq_last = seqs[a_seq_index][seqs_sizes[a_seq_index]-1]
        b_seq_last = seqs[b_seq_index][seqs_sizes[b_seq_index]-1]
        new_seqs_sizes = list(seqs_sizes)
        new_seqs_sizes[a_seq_index] -= 1
        new_seqs_sizes[b_seq_index] -= 1
        max_area = _compute_max_area(sorted_seqs_obj, tuple(new_seqs_sizes))
        max_area += a_seq_last * b_seq_last
        max_areas_variants.append(max_area)

    max_area = max(max_areas_variants, default=0)

    _cache[cache_key] = max_area
    return max_area

def _how_many_nonempty(seqs_sizes):
    return len([size for size in seqs_sizes if size > 0])

def main():
    r_n, g_n, b_n = map(int, input().split())
    r_seq = tuple(map(int, input().split()))
    g_seq = tuple(map(int, input().split()))
    b_seq = tuple(map(int, input().split()))
    result = compute_max_area(r_seq, g_seq, b_seq)
    print(result)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"class Solution(object):
    def getMaxLen(self, nums):
        result, neg_cnt, last_zero_pos, first_valid_neg_pos = 0, 0, -1, -1
        for i in range(len(nums)):
            if nums[i] == 0:
                neg_cnt = 0
                last_zero_pos = i
                first_valid_neg_pos = -1
                continue
            if nums[i] < 0:
                if first_valid_neg_pos == -1:
                    first_valid_neg_pos = i
                neg_cnt += 1
            result = max(result, i-(last_zero_pos if neg_cnt%2 == 0 else first_valid_neg_pos))
        return result",O(n)
"n = int(input())
A = [int(i) for i in input().split()]
A = list(set(A))
A.sort()
if len(A)>1:
    print(A[1])
else:
    print(""NO"")
",O(nlogn)
"rgb = 'RGB' * 1000
for q in range(int(input())):
    n, k = [int(s) for s in input().split()]
    s = input()
    ans = 3000
    for w in range(3):
        for e in range(n - k + 1):
            temp = 0
            for i in range(k):
                if s[e + i] != rgb[w + i]:
                    temp += 1
            ans = min(ans, temp)
    print(ans)",O(n ^ 2)
"import sys
from collections import deque, defaultdict
input = lambda: sys.stdin.readline().rstrip()
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = [s[j] if i>>j&1 else '_' for j in range(k)]
            Ans.add(''.join(ans))
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = 1
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = 0
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag and T:
        print('YES')
        print(*[t+1 for t in T], sep = ' ')
    else:
        print('NO')

main()",np
"a = list(map(int,input().split()))
if a.count(1)>=1 or a.count(2)>=2 or a.count(3)==3 or (a.count(2)==1 and a.count(4)==2):
    print(""YES"")
else:
    print(""NO"")",O(1)
"n=int(input())
a=str(n)
m=len(a)
b=int(a[0:m-1])
c=int(a[0:m-2]+a[-1])
d=max(n,b,c)
print(d)
",O(1)
"import itertools



class Solution(object):
    def minimumCosts(self, regular, express, expressCost):
        result = []
        dp = [0, expressCost] 
        for r, e in zip(regular, express):
            dp = [min(dp[0]+r, dp[1]+e), min(dp[0]+(r+expressCost), dp[1]+e)]
            result.append(min(dp[0], dp[1]))
        return result",O(n)
"class Solution2(object):
    def evenProduct(self, nums):
        result = cnt = 0
        for i, x in enumerate(nums):
            if x%2 == 0:
                cnt = i+1
            result += cnt
        return result",O(n)
"import sys
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, sys.stdin.readline().strip().split())
def listinput(): return list(map(int, sys.stdin.readline().strip().split()))
n=iinput()
color=['purple','green','blue','orange','red','yellow']
gem=['Power','Time','Space','Soul','Reality','Mind']
for _ in range(n):
    s=input()
    indexofcolor=color.index(s)
    color.remove(s)
    gem.pop(indexofcolor)
print(len(gem))
for i in gem:
    print(i)",O(1)
"n, k = map(int, input().split())
nums = list(map(int, input().split()))
counts = [{} for _ in range(11)]
for n in nums:
    a = n
    for i in range(11):
        r = a % k
        try:
            counts[i][r] += 1
        except KeyError:
            counts[i][r] = 1
        a *= 10
res = 0
for i in nums:
    wo = str(i)
    le = len(wo)
    mimo = (k-(i % k)) % k
    if mimo in counts[le]:
        res += counts[le][mimo]
        if int(wo+wo) % k == 0:
            res -= 1
print(res)",O(nlogn)
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def lcm(a, b):
    return (a * b) / gcd(a, b)

def main():
    n=int(input())
    if n<6:
        print(-1)
    else:
        for i in range(2, n-2+1):
            print(1, i)
        print(2, n-1)
        print(2, n)
    for i in range(1,n):
        print(i, i+1)

    return

if __name__ == ""__main__"":
    main()",O(n)
"import collections



class Solution(object):
    def maximumRobots(self, chargeTimes, runningCosts, budget):
        result = left = curr = 0
        dq = collections.deque()
        for right in range(len(chargeTimes)):
            while dq and chargeTimes[dq[-1]] <= chargeTimes[right]:
                dq.pop()
            dq.append(right)
            curr += runningCosts[right]
            if chargeTimes[dq[0]]+(right-left+1)*curr > budget:
                if dq[0] == left:
                    dq.popleft()
                curr -= runningCosts[left]
                left += 1
        return right-left+1",O(n)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
for x in r:
    print(*x, sep='')
",O(n ^ 2)
"class Solution(object):
    def sumOddLengthSubarrays(self, arr):
        def ceil_divide(a, b):
            return (a+(b-1))//b
        return sum(x * ceil_divide((i-0+1)*((len(arr)-1)-i+1), 2) for i, x in enumerate(arr))",O(n)
"import operator
from functools import reduce


class Solution2(object):
    def subtractProductAndSum(self, n):
        A = list(map(int, str(n)))
        return reduce(operator.mul, A) - sum(A)",O(logn)
"a = [0 for i in range(100)]
b = [0 for i in range(100)]
for i in range(1, 100):
	a[i] = a[i - 1] * 2 + 1
	b[i] = b[i - 1] + a[i]
def calc(x):
	return (4 ** x - 1) // 3
for i in range(int(input())):
	n, k = map(int, input().split())
	if n > 35:
		print(""YES "" + str(n - 1))
	elif 1 + calc(n - 1) >= k:
		print(""YES "" + str(n - 1))
	elif calc(n) < k:
		print(""NO"")
	else:
		for i in range(1, (n + 1)):
			if b[i] <= k and k <= calc(n) - (2 ** (i + 1) - 1) * calc(n - i):
				print(""YES "" + str(n - i))
				break
		else:
			print(""NO"")",O(logn)
"import math
n, r = list(map(int, input().split(' ')))
l = 2 * r * math.sin(math.pi/n)
R = l * r / (-l + 2*r)
print(R)",O(1)
"

class Solution(object):
    def minimumRemoval(self, beans):
        beans.sort()
        return sum(beans) - max(x*(len(beans)-i)for i, x in enumerate(beans))
",O(nlogn)
"def main():
	l, r = map(int , input().split())
	if l == r :
		print(0)
	else :
		rs = """"
		while (r):
			rs += '1' if r%2 else '0'
			r //= 2
		for i in range(len(rs), 65):
			rs += '0'

		ls = """"
		while (l):
			ls += '1' if l%2 else '0'
			l //= 2
		for i in range(len(ls), 65):
			ls += '0'

		pos = -1
		for i in range(64, -1, -1):

			if (rs[i] == '1' and ls[i] == '0'):
				pos = i
				break

		ans = 2**(pos+1) - 1
		print(ans)

if __name__ == '__main__':
	main()",O(logn)
"import math
import collections
def do():
    n = int(input())
    nums = map(int, input().split("" ""))
    count = collections.defaultdict(int)
    for num in nums:
        for i in range(1, int(math.sqrt(num))+1):
            cp = num // i
            if num % i == 0:
                count[i] += 1
            if cp != i and num % cp == 0:
                count[cp] += 1
    maxk = max(count.keys())
    freq = {k: (1 << count[k]) - 1 for k in count}
    for k in sorted(count.keys(), reverse=True):
        for kk in range(k << 1, maxk+1, k):
            freq[k] -= freq[kk] if kk in freq else 0
    return freq[1] % (10**9 + 7)

print(do())",np
"import itertools


class Solution(object):
    def distanceBetweenBusStops(self, distance, start, destination):
        if start > destination:
            start, destination = destination, start
        s_to_d = sum(itertools.islice(distance, start, destination))
        d_to_s = sum(itertools.islice(distance, 0, start)) + \
                 sum(itertools.islice(distance, destination, len(distance)))
        return min(s_to_d, d_to_s)",O(n)
"import math

n=int(input())
k=1
while(n > 9*k*(10**(k-1))):
    n = n - 9*k*(10**(k-1))
    k = k + 1
remainder = n%k
if remainder == 0:
    remainder = k
if k==1:
    quoteint = math.ceil(n/k)
else:
    adder = ""9""*(k-1)
    adder = int(adder)
    quoteint = math.ceil(n/k) + adder
print(str(quoteint)[remainder-1])
",O(logn)
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal

mod = int(1e9) + 7
INF=float('inf')

n=int(data())
l=mdata()
c=mdata()
d=dict()
for i in range(n):
    if d.get(l[i]):
        d[l[i]]=min(d[l[i]],c[i])
    else:
        d[l[i]]=c[i]
for i in l:
    lis=list(d.keys())
    for j in lis:
        g = math.gcd(i, j)
        if d.get(g):
            d[g]=min(d[g],d[i]+d[j])
        else:
            d[g] = d[i] + d[j]
if 1 in d:
    out(d[1])
else:
    out(-1)
",np
"l, r = map(int, input().split())
target, final = l ^ r, 1
while target:
    target >>= 1
    final <<= 1
print(final - 1)
",O(logn)
"import itertools


class Solution(object):
    def numTilings(self, N):
        M = int(1e9+7)

        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) % M \
                     for col in ZB] for row in A]

        T = [[1, 0, 0, 1], 
             [1, 0, 1, 0], 
             [1, 1, 0, 0], 
             [1, 1, 1, 0]] 

        return matrix_mult([[1, 0, 0, 0]], matrix_expo(T, N))[0][0]",O(logn)
"t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    a = sorted(a)
    print(min(a[-2]-1, n-2))
",O(nlogn)
"n,m = map(int,input().split())
arr1 = list(map(int,input().split()))
arr2 = list(map(int,input().split()))

print(*sorted([x for x in arr2 if x in arr1],key = lambda k:arr1.index(k)))",O(n ^ 2)
"import os,sys
from io import BytesIO, IOBase

from collections import deque, Counter,defaultdict as dft
from heapq import heappop ,heappush
from math import log,sqrt,factorial,cos,tan,sin,radians,log2,ceil,floor
from bisect import bisect,bisect_left,bisect_right
from decimal import *
import sys,threading
from itertools import permutations, combinations
from copy import deepcopy
input = sys.stdin.readline

ii = lambda: int(input())
si = lambda: input().rstrip()
mp = lambda: map(int, input().split())
ms=  lambda: map(str,input().strip().split("" ""))
ml = lambda: list(mp())
mf = lambda: map(float, input().split())

alphs = ""abcdefghijklmnopqrstuvwxyz""

def solve():

    def seq(nd,i):
        case=0
        vis[nd]=1
        for lnk in d[nd]:

            if not vis[lnk]:
                i,case=seq(lnk,i)
                if case:return i,case
            else:
                if lnk not in seen:

                    case=1
                    break

        order[i]=nd
        seen.add(nd)

        return i-1,case

    def chk(word,dct,i):
        if i==k:
            res.append(dct['
        else:
            if word[i] in dct:
                chk(word,dct[word[i]],i+1)
            if '_' in dct:
                chk(word,dct['_'],i+1)

    n,m,k=map(int,input().split())
    trie={}
    global case
    case=0
    for i in range(n):
        word=input()
        dct=trie
        for w in word:
            if w not in dct:
                dct[w]={}
            dct=dct[w]
        dct['
    d=dft(list)
    for i in range(m):

        word,idx=input().split()
        idx=int(idx)
        res=[]
        chk(word,trie,0)

        temp=0
        for num in res:
            if num!=idx:
                d[idx].append(num)
            else:
                temp=1
        if not temp:
            case=1

    order=[0]*(n+1)
    vis=[0]*(n+1)
    seen=set()
    idx=n

    for i in range(1,n+1):
        if not vis[i]:
            idx,tp=seq(i,idx)
            if tp:
                case=1
                break

    if case:
        print(""NO"")
    else:
        print(""YES"")
        print(*order[1:])

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    tc=1

    for i in range(tc):
    	solve()",np
"import collections
from functools import cmp_to_key

import sys
def getIntList():
    return list(map(int, input().split()))

n,a,b = getIntList()
a0 = a
b0 = b
if a0>b0:
    a0,b0 = b,a
if n==2 and (a0,b0) == (1,1):
    print('NO')
    sys.exit()
if n==3 and (a0,b0) == (1,1):
    print('NO')
    sys.exit()
if a>1 and b>1:
    print('NO')
    sys.exit()

mat = [['0' for y in range(n)]for x in range(n)]
mat1 = [['1' for y in range(n)]for x in range(n)]
if b==1:
    for x in range(n-a):
        mat[x][x+1] = '1'
        mat[x+1][x] = '1'
else:
    mat = mat1
    for x in range(n):
        mat[x][x] = '0'
    for x in range(n-b):
        mat[x][x+1] = '0'
        mat[x+1][x] = '0'

print('YES')
for x in range(n):
    print(''.join(mat[x]))
",O(n ^ 2)
"n,k=map(int,input().split())
if n>=k:
    print((k-1)//2)
elif n*2>k:
    print(n-k//2)
else: print(0)
",O(1)
"n,U=map(int,input().split())
Ar=list(map(int,input().split()))
R = 0;
ans = -1;
for i in range(n):
    while R + 1 < n and Ar[R + 1] - Ar[i] <= U:
        R+=1
    if i+1 < R:
        ans = max((Ar[R] - Ar[i + 1]) / (Ar[R] - Ar[i]),ans);
print(ans)
",O(nlogn)
"class Solution(object):
    def lengthOfLongestSubstring(self, s):
        result, left = 0, 0
        lookup = {}
        for right in range(len(s)):
            if s[right] in lookup:
                left = max(left, lookup[s[right]]+1)
            lookup[s[right]] = right
            result = max(result, right-left+1)
        return result",O(n)
"n = int(input())

b = list(map(int, input().split()))
a1 = [0]
a2 = [b[0]]

for x in b[1:]:
	new_a = a1[-1]
	if x - new_a > a2[-1]:
		new_a = x - a2[-1]
	new_a2 = x - new_a
	a1.append(new_a)
	a2.append(new_a2)
print(*(a1+a2[::-1]))",O(n)
"n=int(input())
fa=[0,0]+list(map(int,input().split()))
delta=[0]*(n+1)
suml=[0]*(n+1)
for i in range(n,0,-1):
	if suml[i]==0:
		suml[i]=1
	delta[suml[i]]+=1
	suml[fa[i]]+=suml[i]

for i in range(1,n+1):
	delta[i]+=delta[i-1]
ans=0
for i in range(1,n+1):
	while delta[ans]<i:
		ans+=1
	print(""%d ""%ans,end="""")
print(""\n"")",O(n)
"n, m = map(int, input().split())
a = 0
while m:
    a += n//m
    n, m = m, n % m
print(a)
",O(1)
"from math import ceil
n = int(input())
if n == 1:
    print(1)
    exit(0)
if n == 2:
	print('1 2')
	exit(0)
elif n == 3:
	print('1 1 3')
	exit(0)
o = 0
if n&1:
	n -= 1
	o = 1
ans, i, t = '1 ' * ceil(n / 2), 1, n
n = ceil(n/2)
j = 2
while n > 1:
	ans += (str(j) + ' ') * ((n // 2) if t&1 else ceil(n/2))
	i += 1
	j = pow(2, i)
	n //= 2
print(('1 ' if o else '') + ans + str((j//2)*(t//(j//2))))
",O(nlogn)
"import collections



class Solution(object):
    def largestInteger(self, nums, k):
        if k == len(nums):
            return max(nums)
        cnt = collections.defaultdict(int)
        for x in nums:
            cnt[x] += 1
        if k == 1:
            return max(x for x, v in cnt.items() if v == 1) if any(v == 1 for v in cnt.values()) else -1
        result = -1
        if cnt[nums[0]] == 1:
            result = max(result, nums[0])
        if cnt[nums[-1]] == 1:
            result = max(result, nums[-1])
        return result",O(n)
"n,k = map(int, raw_input().split())

def area(height):
    return n * height

def bin_search(low, high):
    if (high == low):
        return high
    if high - low == 1:
        if area(low) >= k:
            return low
        return high
    midd = (high + low) // 2
    if area(midd) > k:
        return bin_search(low, midd)
    return bin_search(midd, high)

print(bin_search(0, 1000000000000000000))",O(logn)
"def func(mid,s):
    p=0
    q=mid
    while (mid>0):
        p+=mid%10
        mid=mid//10

    if (q-p)>=s:
        return True
    else:
        return False
n,s=map(int,input().split())
do=1
up=10**18
an=n+1
while (up>=do):
    mid=(up+do)//2
    if func(mid,s):
        up=mid-1
        an=mid
    else:
        do=mid+1
if an>n:
    print(0)
else:
    print(n-an+1)",O(logn)
"def sum_from1(k):
      return (k*(k+1))//2
def sum_of_subtraction(p,k):
      if p<=1:
            return sum_from1(k)
      else:
            return sum_from1(k)-sum_from1(p-1)
n,k=map(int,input().split())
if n==1:
      print(0)
elif n<=k:
      print(1)
else:
      n-=1
      k-=1
      if n>sum_from1(k):
            print(-1)
      else:
            s=1
            e=k

            while s<e:
                  mid=(s+e)//2
                  r=sum_of_subtraction(mid,k)

                  if r==n:
                        print(k-mid+1)
                        break
                  elif r>n:
                        s=mid+1
                  else:
                        e=mid
            else:
                  print(k-s+2)
",O(logn)
"class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        if len(s1) > len(s2):
            return False

        s1Count, s2Count = [0] * 26, [0] * 26
        for i in range(len(s1)):
            s1Count[ord(s1[i]) - ord('a')] += 1
            s2Count[ord(s2[i]) - ord('a')] += 1

        matches = 0
        for i in range(26):
            matches += (1 if s1Count[i] == s2Count[i] else 0)

        l = 0
        for r in range(len(s1), len(s2)):
            if matches == 26:
                return True

            index = ord(s2[r]) - ord('a')
            s2Count[index] += 1
            if s1Count[index] == s2Count[index]:
                matches += 1
            elif s1Count[index] + 1 == s2Count[index]:
                matches -= 1

            index = ord(s2[l]) - ord('a')
            s2Count[index] -= 1
            if s1Count[index] == s2Count[index]:
                matches += 1
            elif s1Count[index] - 1 == s2Count[index]:
                matches -= 1
            l += 1
        return matches == 26
",O(n)
"class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q:
            return True
        if p and q and p.val == q.val:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
        else:
            return False
",O(n)
"import heapq



class Solution(object):
    def convertArray(self, nums):
        def f(nums):
            result = 0
            max_heap = []
            for x in nums:
                if max_heap and x < -max_heap[0]:
                    result += -heapq.heappop(max_heap)-x
                    heapq.heappush(max_heap, -x)
                heapq.heappush(max_heap, -x)
            return result
        
        return min(f(nums), f((x for x in reversed(nums))))",O(nlogn)
"class Solution2(object):
    def arrangeCoins(self, n):
        def check(mid, n):
            return mid*(mid+1) <= 2*n

        left, right = 1, n
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid, n):
                right = mid-1
            else:
                left = mid+1
        return right",O(logn)
"n,k = input().split()
n,k = int(n),int(k)

ini,fin = 1,k-1
if n == 1:
	print(""0"")
	exit(0)

if 1 + (k*(k-1) )//2 < n:
	print(""-1"")
	exit(0)

while ini < fin:
	mid = (ini+fin)//2
	s = 1 + (k-1)*mid - (mid*(mid-1))//2
	if s>=n:
		fin = mid
	else:
		ini = mid+1

print(ini)",O(logn)
"class Solution2(object):
    def arrayPairSum(self, nums):
        nums.sort()
        result = 0
        for i in range(0, len(nums), 2):
            result += nums[i]
        return result",O(nlogn)
"def main():
    q = int(input())
    for i in range(q):
        n, k = map(int, input().split())
        s = input()
        min_ans = 10 ** 9
        for i in range(n - k + 1):
            count1 = 0
            count2 = 0
            count3 = 0
            for j in range(k):
                if (i + j) % 3 == 0:
                    if s[i + j] != ""R"":
                        count1 += 1
                    if s[i + j] != ""G"":
                        count2 += 1
                    if s[i + j] != ""B"":
                        count3 += 1
                if (i + j) % 3 == 1:
                    if s[i + j] != ""G"":
                        count1 += 1
                    if s[i + j] != ""B"":
                        count2 += 1
                    if s[i + j] != ""R"":
                        count3 += 1
                if (i + j) % 3 == 2:
                    if s[i + j] != ""B"":
                        count1 += 1
                    if s[i + j] != ""R"":
                        count2 += 1
                    if s[i + j] != ""G"":
                        count3 += 1
            min_ans = min(min_ans, count1, count2, count3)
        print(min_ans)
main()",O(n ^ 2)
"class Solution(object):
    def mostCompetitive(self, nums, k):
        stk = []
        for i, x in enumerate(nums):
            while stk and stk[-1] > x and len(stk)+(len(nums)-i) > k:
                stk.pop()
            if len(stk) < k:
                stk.append(x)
        return stk",O(n)
"import sys,atexit
from io import BytesIO
inp = BytesIO(sys.stdin.buffer.read())
input = lambda:inp.readline().decode('ascii')
buf = BytesIO()
sys.stdout.write = lambda s: buf.write(s.encode('ascii'))
atexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue()))

n,m = map(int,input().split())
if m%2 == 0:
    steps = []
    for j in range(m//2):
        for i in range(n):
            steps.append((j,i))
            steps.append((m-j-1,n-i-1))
else:
    steps = []
    for j in range(m//2):
        for i in range(n):
            steps.append((j,i))
            steps.append((m-j-1,n-i-1))
    l = 0
    r = n-1
    mid = m//2
    while l<=r:
        steps.append((mid,l))
        if l != r:
            steps.append((mid,r))
        l += 1
        r -= 1

for x,y in steps:
    print(y+1,x+1)
",O(n ^ 2)
"class Solution(object):
    def countSubarrays(self, nums, k):
        result = total = left = 0
        for right in range(len(nums)):
            total += nums[right]
            while total*(right-left+1) >= k:
                total -= nums[left]
                left += 1
            result += right-left+1
        return result",O(n)
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n,m = inpl()
cnt = [0]*n
c = inpl_1()
for x in c: cnt[x] += 1
print(min(cnt))",O(n ^ 2)
"import sys
from array import array
import typing as Tp

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def main():
    l, r, k = map(int, input().split())

    valid_bits, is_valid_bits = [], [0] * 1024

    for bit in range(1024):
        if bin(bit).count('1') <= k:
            valid_bits.append(bit)
            is_valid_bits[bit] = 1

    mod = 998244353

    def solve(ub):
        dp = array('i', [0]) * 1024
        dp_cnt = array('i', [0]) * 1024
        next_dp = array('i', [0]) * 1024
        next_dp_cnt = array('i', [0]) * 1024
        boundary_dp, b_bit = 0, 0

        for e, digit in zip(range(len(str(ub)) - 1, -1, -1), map(int, str(ub))):
            base = pow(10, e, mod)

            for bit in valid_bits:
                for d in range(10):
                    nextbit = bit | (1 << d)
                    if is_valid_bits[nextbit]:
                        next_dp[nextbit] = (
                            next_dp[nextbit] + dp[bit]
                            + base * d * dp_cnt[bit]
                        ) % mod

                        next_dp_cnt[nextbit] += dp_cnt[bit]
                        if next_dp_cnt[nextbit] >= mod:
                            next_dp_cnt[nextbit] -= mod

            for d in range(digit):
                nextbit = b_bit | (1 << d)
                if is_valid_bits[nextbit]:
                    next_dp[nextbit] = (
                        next_dp[nextbit] + boundary_dp + base * d
                    ) % mod
                    next_dp_cnt[nextbit] += 1

            b_bit |= (1 << digit)
            boundary_dp = (boundary_dp + base * digit) % mod

            for i in valid_bits:
                dp[i] = next_dp[i]
                dp_cnt[i] = next_dp_cnt[i]
                next_dp[i] = next_dp_cnt[i] = 0

            dp[0], dp_cnt[0] = 0, 1
            dp[1] = dp_cnt[1] = 0

        return (sum(dp) + (boundary_dp if is_valid_bits[b_bit] else 0)) % mod

    print((solve(r) - solve(l - 1)) % mod)

if __name__ == '__main__':
    main()
",O(n ^ 3)
"
class Solution(object):
    def oddEvenList(self, head):
        if head:
            odd_tail, cur = head, head.__next__
            while cur and cur.__next__:
                even_head = odd_tail.__next__
                odd_tail.next = cur.__next__
                odd_tail = odd_tail.__next__
                cur.next = odd_tail.__next__
                odd_tail.next = even_head
                cur = cur.__next__
        return head

",O(n)
"n, k = map(int, input().split())
grid = [['.']*n for i in range(4)]
if k % 2 == 0:
    for i in range(k//2):
        grid[1][1+i], grid[2][1+i] = '
else:
    m = n//2
    if k > n - 2:
        for i in range(1, n-1):
            grid[1][i] = '
        for i in range(1, (k-n+2)//2 + 1):
            grid[2][m+i], grid[2][m-i] = '
    else:
        grid[1][m] = '
        if k > 1:
            for i in range(1, k//2 + 1):
                grid[1][m-i], grid[1][m+i] = '
print('YES')
for i in grid:
    print(''.join(i))",O(n)
"first,last=input().split()
username=first[0]
first=first[1:]
while first!="""" and first[0]<last[0]:
    username=username+first[0]
    first=first[1:]
print(username+last[0])",O(n)
"import collections
import itertools



class Solution(object):
    def minimumTotalCost(self, nums1, nums2):
        cnt = collections.Counter()
        result = 0
        for i, (x, y) in enumerate(zip(nums1, nums2)):
            if x != y:
                continue
            cnt[x] += 1
            result += i
        if not cnt:
            return 0
        majority = max(iter(cnt.keys()), key=lambda x: cnt[x])
        remain = cnt[majority]-(sum(cnt.values())-cnt[majority])
        if remain <= 0:
            return result
        for i, (x, y) in enumerate(zip(nums1, nums2)):
            if x == y or majority in (x, y):
                continue
            result += i
            remain -= 1
            if not remain:
                return result
        return -1",O(n)
"def func():
    N = 520
    K = 12
    C = 100 * 1000 + 11
    n, k = [int(x) for x in list(raw_input().split(' '))]
    c = [0 for _ in range(C)]
    f = [0 for _ in range(C)]

    dp = [[0 for _ in range(K*(N))] for _ in range(N)]

    a = [int(x) for x in list(raw_input().split(' '))]
    for x in a:
        c[x] += 1

    b = [int(x) for x in list(raw_input().split(' '))]
    for x in b:
        f[x] += 1

    h = [0]+[int(x) for x in list(raw_input().split(' '))]

    for i in range(n):
        for j in range(n*k + 1):
            for cur in range(k+1):
                dp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur])

    ans = 0
    for i in range(C):
        if f[i] != 0:
            ans += dp[f[i]][c[i]]

    return ans

if __name__ == ""__main__"":
    print(func())
",O(n ^ 3)
"q = int(input())
b = []
for m in range(q):
    n, k = map(int, input().split())
    l = input()
    k1 = 'R'
    k2 = 'G'
    k3 = 'B'
    for i in range(1, k):
        if k1[i - 1] == 'R':
            k1 = k1 + 'G'
        if k1[i - 1] == 'G':
            k1 = k1 + 'B'
        if k1[i - 1] == 'B':
            k1 = k1 + 'R'
        if k2[i - 1] == 'R':
            k2 = k2 + 'G'
        if k2[i - 1] == 'G':
            k2 = k2 + 'B'
        if k2[i - 1] == 'B':
            k2 = k2 + 'R'
        if k3[i - 1] == 'R':
            k3 = k3 + 'G'
        if k3[i - 1] == 'G':
            k3 = k3 + 'B'
        if k3[i - 1] == 'B':
            k3 = k3 + 'R'
    minn = n

    for i in range(n - k + 1):
        tec = 0
        for j in range(k):
            if l[i + j] != k1[j]:
                tec += 1
        if tec < minn: minn = tec
    for i in range(n - k + 1):
        tec = 0
        for j in range(k):
            if l[i + j] != k2[j]:
                tec += 1
        if tec < minn: minn = tec
    for i in range(n - k + 1):
        tec = 0
        for j in range(k):
            if l[i + j] != k3[j]:
                tec += 1

        if tec < minn: minn = tec
    b.append(minn)
for i in range(q):
    print(b[i])
",O(n ^ 2)
"import collections


class Solution(object):
    def maxResult(self, nums, k):
        score = 0
        dq = collections.deque()
        for i, num in enumerate(nums):
            if dq and dq[0][0] == i-k-1:
                dq.popleft()
            score = num if not dq else dq[0][1]+num
            while dq and dq[-1][1] <= score:
                dq.pop()
            dq.append((i, score))
        return score",O(n)
"
class Solution(object):
    def simplifyPath(self, path):
        stack, tokens = [], path.split(""/"")
        for token in tokens:
            if token == "".."" and stack:
                stack.pop()
            elif token != "".."" and token != ""."" and token:
                stack.append(token)
        return ""/"" + ""/"".join(stack)

",O(n)
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy

def main():
    n = rint()
    a1, a2 = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n))
    for i in range(4):
        if a2.mat in [a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()]:
            exit(print('Yes'))
    print('No')

class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

            if id != None:
                for i in range(r):
                    self.mat[i][i] = 1

    def __add__(self, other):
        mat0 = Matrix(self.r, self.c)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]

        return mat0

    def __mul__(self, other):
        mat0 = Matrix(self.r, other.c)

        for i in range(self.r):
            for j in range(other.c):
                for k in range(self.c):
                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]

        return mat0

    def dot_mul(self, other):
        res = 0
        for i in range(self.r):
            for j in range(self.c):
                res += self.mat[i][j] * other.mat[j][i]

        return res

    def trace(self):
        res = 0
        for i in range(self.r):
            res += self.mat[i][i]

        return res

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def mat_pow(self, mat, p, mod=None):
        sq = Matrix(mat.r, mat.r, id=1)

        while p:
            if p & 1:
                p -= 1
                sq = sq * mat

            p //= 2
            mat = mat * mat

        return sq.mat

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",O(n ^ 2)
"n,m = int(input()),int(input())
if n < 27:
    print(m%2**n)
else:
    print(m)",O(1)
"class Solution4(object):
    def specialArray(self, nums):
        nums.sort(reverse=True) 
        for i in range(len(nums)): 
            if nums[i] <= i:
                break
        else:
            i += 1
        return -1 if i < len(nums) and nums[i] == i else i",O(nlogn)
"def possible(a,index,a1,b):
    rem = []
    for i in range(len(a)):
        if i != index:
            rem.append(a[i])

    a3 = a1[:]
    rem.sort()
    a3.append(a[index])
    a3.extend(rem)
    a2 = ''
    for i in a3:
        a2 += str(i)

    if int(a2) <= b:
        return True

    return False

def main():
    a = list(map(int,input()))
    b = int(input())

    a.sort(reverse = True)
    a1 = []
    for pos in range(len(a)):
        for i in range(len(a)):
            if possible(a,i,a1,b):
                a1.append(a[i])
                a.pop(i)
                break

    for i in a1:
        print(i,end = '')

main()
",O(n ^ 3)
"s = input()
for i in range(len(s), 0, -1):
	for j in range(len(s) - i + 1):
		if s[j: j + i] in s[j + 1:]:
			print(i)
			exit()
print(0)",O(n ^ 3)
"n, l, r, x = map(int, input().split())
d = list(map(int, input().split()))
ans = 0
for i in range(pow(2, n)-1, -1, -1):
	s = bin(i)[2:]
	while(len(s) < n):
		s = ""0""+s
	diff = 0
	t = []
	for j in range(n):
		if(s[j]=='1'):
			diff += d[j]
			t.append(d[j])
	t.sort()

	if(l <= diff <= r and t[-1]-t[0] >= x):
		ans += 1
print(ans)",np
"import sys
input = sys.stdin.readline
n, m = map(int, input().split())

MOD = m
MAX_N = 10**3

fac = [1] + [0] * MAX_N
for i in range(1, MAX_N+1):
    fac[i] = fac[i-1] * (i) % MOD

fac_inv = [1] + [0] * MAX_N

fac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD)
for i in range(MAX_N, 1, -1):
    fac_inv[i-1] = fac_inv[i] * i % MOD

def mod_nCr(n, r):
    if n < r or n < 0 or r < 0:
        return 0
    tmp = fac_inv[n-r] * fac_inv[r] % MOD
    return tmp * fac[n] % MOD

pow2 = [0] * (n+1)
pow2[0] = 1
for i in range(1, n+1):
    pow2[i] = pow2[i-1] * 2 % MOD

table = [[0] * 500 for _ in range(500)]
for i in range(500):
    for j in range(i+1):
        table[i][j] = mod_nCr(i, j)

dp = [[0] * (n+1) for _ in range(n)]
for i in range(n):
    dp[i][i+1] = pow2[i]
for i in range(n-1):
    for j in range(i // 2 + 1, n-1):
        if dp[i][j] == 0:
            continue
        dp[i][j] %= MOD
        for k in range(1, n-j):
            if i + k + 1 >= n:
                break

            dp[i+k+1][j+k] += dp[i][j] * pow2[k-1] * table[k + j][k]

ans = sum(dp[-1]) % MOD
print(ans)",O(n ^ 3)
"n, U = list(map(int, input().split()))
E = list(map(int, input().split()))

ind_i = 0
prev_ind_k = ind_i + 2

maxi_efficiency = -1
turn = 0
for ind_i in range(0, n - 2):
    ind_j = ind_i + 1
    prev_ind_k = max(prev_ind_k, ind_i + 2)
    Ei = E[ind_i]
    Ej = E[ind_j]
    for ind_k in range(prev_ind_k, n + 1):

        if ind_k == n:
            prev_ind_k = n - 1
            break
        Ek = E[ind_k]
        if (Ek - Ei) > U:
            prev_ind_k = ind_k - 1
            break

        efficiency = (Ek - Ej) / (Ek - Ei)

        if efficiency > maxi_efficiency:

            maxi_efficiency = efficiency

print(maxi_efficiency)
",O(nlogn)
"list1=input()
l=list1.split()
l=[int(item) for item in l]

n,m,k=l

a=input()
a1=map(int,a.split())

a1=list(sorted(a1))

count=0
for i in range(len(a1)):
    if k>=m:
        break
    else:
        k+=a1.pop()-1
        count+=1

if k>=m:
    print(count)
else:
    print(""-1"")",O(nlogn)
"def ints():
 return list(map(int,input().split()))
n,k=ints()
a,t=ints(),ints()
ans=sum(a[ii] for ii in range(n) if t[ii])
bb=[a[ii] if t[ii]==0 else 0 for ii in range(n)]
ll=0
rr=k
tmp=sws=sum(bb[:k])
while rr<n:
 sws-=bb[ll]
 sws+=bb[rr]
 ll+=1
 rr+=1
 tmp=max(tmp,sws)
ans+=tmp
print(ans)
",O(n)
"class Solution(object):
    def exclusiveTime(self, n, logs):
        result = [0] * n
        stk, prev = [], 0
        for log in logs:
            tokens = log.split("":"")
            if tokens[1] == ""start"":
                if stk:
                    result[stk[-1]] += int(tokens[2]) - prev
                stk.append(int(tokens[0]))
                prev = int(tokens[2])
            else:
                result[stk.pop()] += int(tokens[2]) - prev + 1
                prev = int(tokens[2]) + 1
        return result",O(n)
"class Solution(object):
    def findMaxLength(self, nums):
        result, count = 0, 0
        lookup = {0: -1}
        for i, num in enumerate(nums):
            count += 1 if num == 1 else -1
            if count in lookup:
                result = max(result, i - lookup[count])
            else:
                lookup[count] = i

        return result",O(n)
"l,r = map(int,input().split())
if l%2:
    l+=1
if r-l<2:
    print(-1)
else:
    print(l,l+1,l+2)
",O(1)
"from collections import defaultdict, Counter,deque
from math import sqrt, log10, log, floor, factorial,gcd
from bisect import bisect_left, bisect_right
from itertools import permutations,combinations
import sys, io, os
input = sys.stdin.readline
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

inf = float('inf')
mod = 10 ** 9 + 7
def yn(a): print(""YES"" if a else ""NO"")
ceil = lambda a, b: (a + b - 1) // b
lim=22
po=[1<<j for j in range(lim+1)]
maxbits=lim
masks=po[lim]
dp=[-1]*masks
t=1

for i in range(1):
    n=int(input())
    l=[int(i) for i in input().split()]
    for i in l:
        dp[i]=i
    for i in range(masks):
        for j in range(maxbits):
            if dp[i]==-1 and i&(1<<j):
                dp[i]=dp[i-(1<<j)]
    ans=[dp[i^(masks-1)] for i in l]
    print(*ans)
",np
"from sys import stdin, stdout

nxt = []

def find_it(s, left, right):
    global nxt
    dp = [[1000 for i in range(len(right) + 1)] for j in range(len(left) + 1)]
    dp[0][0] = 0
    for i in range(len(left)+1):
        for j in range(len(right)+1):
            if dp[i][j] > len(s):
                continue
            if j < len(right) and nxt[ord(right[j]) - 97][dp[i][j]] != -1:
                if nxt[ord(right[j]) - 97][dp[i][j]] < dp[i][j+1]:
                    dp[i][j+1] = nxt[ord(right[j]) - 97][dp[i][j]] +1
            if i < len(left) and nxt[ord(left[i]) - 97][dp[i][j]] != - 1:
                if nxt[ord(left[i]) - 97][dp[i][j]] < dp[i+1][j]:
                    dp[i+1][j] = nxt[ord(left[i]) - 97][dp[i][j]] +1
    if dp[len(left)][len(right)] != 1000:
        return True
    else:
        return False

def main():
    global nxt
    n = int(stdin.readline())
    for _ in range(n):
        s = stdin.readline().rstrip()
        t = stdin.readline().rstrip()
        nxt = [[-1 for _ in range(len(s)+1)] for i in range(26)]
        for i,x in enumerate(s):
            nxt[ord(x) - 97][i] = i
        for i in range(26):
            for j in range(len(s)-1 ,-1,-1):
                if nxt[i][j] != j:
                    nxt[i][j] = nxt[i][j+1]

        r = False
        for i in range(len(t)):
            res = find_it(s, t[:i], t[-len(t)+i:])
            if res is True:
                r = True
                break

        if r is True:
            stdout.write(""YES\n"")
        else:
            stdout.write(""NO\n"")

main()",O(n ^ 3)
"if __name__ == ""__main__"":
    n = int(input())
    nums = [int(a) for a in input().strip().split()]
    counts = 0

    for i in range(n-1):
        for j in range(i + 1, n):
            if nums[i] > nums[j]:
                counts += 1

    ans = counts % 2
    ans_tmp = []
    m = int(input())
    for i in range(m):
        l, r = [int(a) for a in input().strip().split()]

        tmp = r - l + 1
        tmp_count = (tmp * (tmp - 1) // 2)
        if tmp_count % 2 == 1:
            ans = (ans + 1) % 2
        ans_tmp.append(ans)

    for i in range(m):
        ans = ans_tmp[i]
        if ans % 2 == 1:
            print(""odd"")
        else:
            print(""even"")
",O(n ^ 2)
"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def rotateRight(self, head, k):
        if not head or not head.__next__:
            return head

        n, cur = 1, head
        while cur.__next__:
            cur = cur.__next__
            n += 1
        cur.next = head

        cur, tail = head, cur
        for _ in range(n - k % n):
            tail = cur
            cur = cur.__next__
        tail.next = None

        return cur",O(n)
"n,k = map(int,input().split())
a = list(map(int,input().split()))
p = sorted(a)
p = p[-k:]
s = sum(p)
print(s)
idx = 0
i = 0
count = 0
ans = []
while len(ans)<k-1:
    idx+=1
    count+=1
    if a[i] in p:
        p.remove(a[i])
        ans.append(count)
        count = 0
    i+=1
for i in ans:
    print(i,end = "" "")
print(n-idx)
",O(nlogn)
"from io import BytesIO, IOBase
import sys
import math
import os
from collections import defaultdict
from math import ceil
from bisect import bisect_left, bisect_left

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")
def mint(): return map(int, input().split())
def mfloat(): return map(float, input().split())

def solve():
    n, m, k = mint()
    horizontal = [list(mint()) for i in range(n)]
    vertical = [list(mint()) for i in range(n-1)]
    if k%2 or max(n, m)==1:
        for i in range(n):
            print(*[-1]*m)
        return

    dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]
    for length in range(1, k//2+1):
        for i in range(n):
            for j in range(m):

                left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]
                right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]
                top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]
                bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]
                dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k//2]*2, end=' ')
        print()

def main():

    t = 1
    for _ in range(t):
        solve()

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"n, k = map( int, input().split() )

d = n - k
d = d // 2

l = []

while n > 0:
    i = min(n,d)
    while i>0:
        l.append('1')
        i -= 1
        n -= 1
    if n > 0:
        l.append('0')
        n -= 1

print( """".join( l ) )",O(n ^ 2)
"def good(x1, y1, x2, y2):
    if (x1 > x2):
        x1, x2 = x2, x1
        y1, y2 = y2, y1
    return (x2 >= y1)

def check(cent):
    for i in range(n):
        if (not good(cent - t, cent + t, x[i] - a[i], x[i] + a[i])):
            return 0
    return 1

n, t = map(int, input().split())
x = [0] * n
a = [0] * n
for i in range(n):
    x[i], a[i] = map(int, input().split())
    x[i] *= 2

ans = set()

for i in range(n):
    val1 = x[i] - a[i] - t
    val2 = x[i] + a[i] + t
    if (check(val1)):
        ans.add(val1)
    if (check(val2)):
        ans.add(val2)
print(len(ans))
",O(nlogn)
"from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 1<<j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)
",O(nlogn)
"from operator import itemgetter

n = int(input())
if n == 1:
    print(1)
else:
    pi = list(map(int,input().split()))
    ai = [1] * (n+1)
    ai[0] = 10**9
    for i in pi:
        ai[i] = 0
    for i in range(n-2,-1,-1):
        ai[pi[i]] += ai[i+2]
    ai.sort()
    for i in range(n):
        print(ai[i],end="" "")
",O(n)
"class Solution2(object):
    def pseudoPalindromicPaths (self, root):
        def dfs(node, count):
            if not root:
                return 0
            count ^= 1 << (node.val-1)
            return int(node.left == node.right and count&(count-1) == 0) + \
                   dfs(node.left, count) + dfs(node.right, count)
        return dfs(root, 0)",O(n)
"a=int(input())
b=list(map(int,input().split()))
z=max(b)
if z==1:b[b.index(z)]=2
else:b[b.index(z)]=1
print(*sorted(b))",O(nlogn)
"class Solution(object):
    def maxWeight(self, pizzas):
        l = len(pizzas)//4
        pizzas.sort(reverse=True)
        return sum(pizzas[i] for i in range((l+1)//2))+sum(pizzas[i] for i in range((l+1)//2+1, ((l+1)//2+1)+(l//2)*2, 2))",O(nlogn)
"class Solution(object):
    def compressedString(self, word):
        result = []
        cnt = 0
        for i in range(len(word)):
            cnt += 1
            if cnt == 9 or (i+1 == len(word) or word[i+1] != word[i]):
                result.append(""%s%s"" % (cnt, word[i]))
                cnt = 0
        return """".join(result)",O(n)
"from math import *
from fractions import *
def li():
  return list(map(int, input().split("" "")))
n,k = li()
if k == 1:
  print(""1"" + ""0""*(n-1))
else:
  a = (n-k)//2
  p = ""1"" + ""0""*a
  ans = p * (n//(a+1)) + p[:(n%(a+1))]
  print(ans)",O(1)
"n,m = map(int,input().split())
xi = list(map(int,input().split()))
ti = list(map(int,input().split()))
ai = [0] * (m+2)
ar = [0] * (m+2)
ar[-1] = 10**11
ar[0] = -100000000000
j = 1
n2 = n + m
for i in range(n2):
    if ti[i] == 1:
        ar[j] = xi[i]
        j += 1
i1 = 0
i2 = 1
for i in range(n2):
        if ti[i] == 1:
            i2 += 1
            i1 += 1
            continue
        num = xi[i] - ar[i1]
        num2 = ar[i2] - xi[i]
        if num <= num2:
            ai[i1] += 1
        else:
            ai[i2] += 1
for i in range(1,m+1):
    print(ai[i],end="" "")
",O(n)
"import itertools


class Solution2(object):
    def restoreString(self, s, indices):
        result = ['']*len(s)
        for i, c in zip(indices, s):
            result[i] = c
        return """".join(result)",O(n)
"from sys import stdin
MOD = 1000000007
s = stdin.readline().strip()
n = len(s)
buc = [0] * 101
fac = [0] * (n + 1)
inv = [0] * (n + 1)
dp = [0] * (n + 1)

ans = [[0] * 55 for _ in range(55)]

def find(c: 'str') -> 'int':
    if 'A' <= c <= 'Z':
        return ord(c) - ord('A') + 26
    else:
        return ord(c) - ord('a')

for i in s:
    buc[find(i)] += 1

fac[0] = 1
for i in range(1, n + 1):
    fac[i] = (fac[i - 1] * i) % MOD
inv[n] = pow(fac[n], MOD - 2, MOD)
for i in range(n - 1, -1, -1):
    inv[i] = (inv[i + 1] * (i + 1)) % MOD

num = pow(fac[n // 2], 2, MOD)
for i in range(0, 52):
    num = (num * inv[buc[i]]) % MOD

dp[0] = 1

for i in range(0, 52):
    if not buc[i]:
        continue
    for j in range(n, buc[i] - 1, -1):
        dp[j] += dp[j - buc[i]]
        if dp[j] >= MOD:
            dp[j] -= MOD
for i in range(52):
    ans[i][i] = dp[n // 2]

for i in range(52):
    if not buc[i]:
        continue
    temp_dp = dp.copy()
    for k in range(buc[i], n + 1):
        temp_dp[k] -= temp_dp[k - buc[i]]
        if temp_dp[k] < 0:
            temp_dp[k] += MOD

    for j in range(i + 1, 52):
        if not buc[j]:
            continue
        for k in range(buc[j], n + 1):
            temp_dp[k] -= temp_dp[k - buc[j]]
            if temp_dp[k] < 0:
                temp_dp[k] += MOD
        ans[i][j] = (2 * temp_dp[n // 2]) % MOD

        for k in range(n, buc[j] - 1, -1):
            temp_dp[k] += temp_dp[k - buc[j]]
            if temp_dp[k] >= MOD:
                temp_dp[k] -= MOD

q = int(input())
l = stdin.read().splitlines()
for i in l:
    x, y = map(int, i.split())
    l, r = find(s[x - 1]), find(s[y - 1])
    if l > r:
        l, r = r, l
    print(num * ans[l][r] % MOD)
",O(n ^ 3)
"class Solution(object):
    def atMostNGivenDigitSet(self, D, N):
        str_N = str(N)
        set_D = set(D)
        result = sum(len(D)**i for i in range(1, len(str_N)))
        i = 0
        while i < len(str_N):
            result += sum(c < str_N[i] for c in D) * (len(D)**(len(str_N)-i-1))
            if str_N[i] not in set_D:
                break
            i += 1
        return result + int(i == len(str_N))",O(logn)
"n,m=map(int,input().split())
arr=[ int(x) for x in input().split()]

arr=sorted(arr,reverse=True)
arr.append(0)

isum=sum(arr)
ans=[]
top=arr[0]
for i in range(n):
	if(arr[i]==1):
		ans.append(1)
		arr[i+1]=1
		continue
	if(arr[i+1] >arr[i]):
		arr[i+1]=arr[i]
	if arr[i]-arr[i+1]==0:
		ans.append(1)
		h=1
	else:
		ans.append(arr[i]-arr[i+1])
		h=arr[i]-arr[i+1]

	top=arr[i]-h
	arr[i+1]=top

print(isum-sum(ans))",O(nlogn)
"import math

SPACE = ' '

def get_data(file_name):
    result = list()
    state = 0
    data = list()

    try:
        for line in open(file_name, 'r').readlines():
            line = line.strip()
            if state == 0:
                if line == 'Input':
                    data = list()
                    state = 1
                elif line == 'Answer':
                    state = 2
            elif state == 1:
                data += list(map(int, line.split(SPACE)))
                state = 11
            elif state == 11:
                data += list(map(int, line.split(SPACE)))
                state = 0
            elif state == 2:
                data.append(float(line))
                result.append(data)
                state = 0
    except FileNotFoundError:
        print(f'File {file_name} not found.')
    return result

def time(d=None, v=None, v0=0, steady=False):
    if steady:
        return d / v

    if d is None:

        return (v - v0) / ACCEL

    if v is None:
        v = vel(d=d, v0=v0)
    return (2 * d) / (v + v0)

def dist(t=None, v=None, v0=0, steady=False):
    if steady:
        return v * t

    if t is None:

        return (pow(v, 2) - pow(v0, 2)) / (2 * ACCEL)

    return (1 / 2) * (v + v0) * t

def vel(d=None, t=None, v0=0, steady=False):
    if steady:
        return d / t

    if d is None:

        return t * ACCEL - v0

    return pow(2 * d * ACCEL + v0 ** 2, 1 / 2)

def can_ignore_sign(v, w, d):
    return v <= w or d <= dist(v=w)

def ignore_sign(v, w, l):
    dmax = dist(v=v)
    if l <= dmax:
        return time(d=l)
    return time(v=v) + time(d=l - dmax, v=v, steady=True)

def get_time(a, v, l, d, w):
    global ACCEL
    ACCEL = a

    if can_ignore_sign(v, w, d):
        return ignore_sign(v, w, l)

    tmax, dmax = time(v=v), dist(v=v)
    tlim_max, dlim_max = time(v=v, v0=w), dist(v=v, v0=w)
    if dmax + dlim_max <= d:

        res = tmax + time(d=d - dmax - dlim_max, v=v, steady=True) + tlim_max
    else:

        res = time(v=w) + time(v=vel(d=(d - dist(v=w)) / 2, v0=w), v0=w) * 2

    x = d + dist(v=v) - dist(v=w)
    if x >= l:

        res += time(d=l - d, v0=w)
        return res
    return res + time(v=v, v0=w) + time(d=l - x, v=v, steady=True)

if __name__ == '__main__':
    a, v = map(int, input().split())
    l, d, w = map(int, input().split())
    print(get_time(a, v, l, d, w))
",O(1)
"import sys
from math import sqrt, gcd, ceil, log, floor
from bisect import bisect, bisect_left
from collections import defaultdict, Counter, deque
from heapq import heapify, heappush, heappop
input = sys.stdin.readline
read = lambda: list(map(int, input().strip().split()))

MOD = 10**9 + 7

def main():

	r, g, b = read()
	r_ar=sorted(read(), reverse = True); g_ar = sorted(read(), reverse = True); b_ar = sorted(read(), reverse = True)
	N = 201
	dp = [[[-1]*N for i in range(N)]for j in range(N)]

	def f(x, y, z):

		if ((x >= r) + (y >= g) + (z >= b)) >= 2:
			return(0)
		if dp[x][y][z] != -1:
			return(dp[x][y][z])
		maxi = 0
		if x < r and y < g:
			maxi = max(maxi, r_ar[x]*g_ar[y] + f(x+1, y+1, z))
		if z < b and y < g:
			maxi = max(maxi, b_ar[z]*g_ar[y] + f(x, y+1, z+1))
		if x < r and z < b:
			maxi = max(maxi, r_ar[x]*b_ar[z] + f(x+1, y, z+1))
		dp[x][y][z] = maxi
		return(maxi)
	print(f(0, 0, 0))

if __name__ == ""__main__"":
	main()",O(n ^ 3)
"n = int(input())
dis = list(map(lambda x: int(x) << 1, input().split()))
ter = input()
st, ans = 0, 0
time = {'G': 5, 'W': 3, 'L': 1}
delta = {'G':1, 'W':1, 'L':-1}
hasWater = False
convert = 0
for i in range(n):
	st += dis[i] * delta[ter[i]]
	ans += dis[i] * time[ter[i]]

	if ter[i] == 'W':
		hasWater = True
	elif ter[i] == 'G':
		convert += dis[i]
	if st < 0:
		if hasWater:
			ans += (-st) * 3
		else:
			ans += (-st) * 5
		st = 0
	convert = min(convert, st // 2)

ans -= 4 * convert
ans -= 2 * (st // 2 - convert)
print(ans // 2)
",O(n)
"import collections
from functools import reduce



class Solution(object):
    def getSum(self, nums):
        def count(d):
            result = 0
            cnt = collections.defaultdict(int)
            prefix = collections.defaultdict(int)
            for x in nums:
                c = (cnt[x-d]+1)%MOD
                cnt[x] = (cnt[x]+c)%MOD
                total = (prefix[x-d]+x*c)%MOD
                prefix[x] = (prefix[x]+total)%MOD
                result = (result+total)%MOD
            return result
    
        MOD = 10**9+7
        return (count(+1)+count(-1)-reduce(lambda accu, x: (accu+x)%MOD, nums, 0))%MOD",O(n)
"s = input()
s = s*3
n = len(s)
m,curr=1,1
for i in range(n-1):
    if s[i]!=s[i+1]:
        curr+=1
        m=max(curr,m)
    else:
        curr=1
print(min(m,n//3))
",O(n)
"k = int(input())
n = 0
i = 0
while (k > n):
    n += pow(10, i) * 9 * (i + 1)
    i = i + 1
n -= pow(10, i - 1) * 9 * i
k -= n
t = (k - 1) / i
r = k % i
if (r == 0):
    r = i
m = pow(10, i - 1) + t
m = int(m)
ans = int(m / pow(10,i - r)) % 10
print(ans)

def pow(i):
    n = 1
    for x in range(0,i):
        n*=10
    return n
",O(logn)
"class Solution(object):
    def countPairs(self, nums1, nums2):
        for i in range(len(nums1)):
            nums1[i] -= nums2[i]
        nums1.sort()
        result = 0
        left, right = 0, len(nums1)-1
        while left < right:
            if nums1[left] > 0 or -nums1[left] < nums1[right]:
                result += right-left
                right -= 1
            else:
                left += 1
        return result",O(nlogn)
"from math import factorial as fact
s1 = input()
s2 = input()
plus1 = s1.count(""+"")
minus1 = s1.count(""-"")

plus2 = s2.count(""+"")
minus2 = s2.count(""-"")
qCount = s2.count(""?"")

if(plus1==plus2 and minus1==minus2):
	print(1)
else:
	plusReq = plus1 - plus2
	minusReq = minus1 - minus2
	if(plusReq >= 0 and minusReq >= 0):
		ans = (0.5**qCount)*fact(qCount)/(fact(plusReq)*fact(minusReq))
		print(ans)

	else:
		print(0)
",np
"class Solution(object):
    def hIndex(self, citations):
        n = len(citations)
        left, right = 0, n - 1
        while left <= right:
            mid = (left + right) / 2
            if citations[mid] >= n - mid:
                right = mid - 1
            else:
                left = mid + 1
        return n - left",O(logn)
"n=int(input())
s=input()
cur=0
for a in s:
    cur=max(cur,0)
    if(a=='-'):
        cur-=1
    else: cur+=1
    cur=max(cur,0)
print(cur)",O(n)
"import heapq
from heapq import heappush as push_
from heapq import heappop  as pop_

class heapT():
    def __init__(self, T):
        self.Q     = []
        self.curT  = 0
        self.maxT  = T
        self.his   = []

    def push(self, t, index):
        push_(self.Q, (-t, index))
        self.his.append(index)
        self.curT += t

        while self.curT > self.maxT:
            self.pop()

    def pop(self):
        t, ind     = pop_(self.Q)
        self.his.append(ind)
        self.curT -= t * -1

    def normalize(self, length):
        while len(self.Q) > length:
            self.pop()

def solve(a, n, T):
    a    =  sorted(a, key=lambda x:x[0], reverse=True)
    H    =  heapT(T)

    max_ = -1
    pos  = None

    for ak, t, ind in a:
        H.push(t, ind)
        H.normalize(ak)

        if len(H.Q) >  max_:
            max_ = len(H.Q)
            pos  = len(H.his)

    d = {}
    if pos is not None:
        for x in H.his[:pos]:
            if x not in d:
                d[x] = 1
            else:
                del d[x]

    if len(d) > 0:
        print(len(d))
        print(len(d))
        print(' '.join([str(x+1) for x in d]))
    else:
        print('0'+'\n'+'0')

n, T =  map(int, input().split())
a    =  [list(map(int, input().split())) + [_] for _ in range(n)]
solve(a, n, T)
",O(nlogn)
"from bisect import bisect_left
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = []
        dp.append(nums[0])

        LIS = 1
        for i in range(1, len(nums)):
            if dp[-1] < nums[i]:
                dp.append(nums[i])
                LIS += 1
                continue

            idx = bisect_left(dp, nums[i])
            dp[idx] = nums[i]

        return LIS
",O(nlogn)
"class Solution(object):
    def isGoodArray(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result = nums[0]
        for num in nums:
            result = gcd(result, num)
            if result == 1:
                break
        return result == 1",O(n)
"n=int(input())
s=list()
for i in range(n):
    x=input()
    s.append(x)
a=sorted(s,key=len)
c=1
for i in range(n-1):
    if(a[i] not in a[i+1]):
        c=0
        break
if(c==0):
    print('NO')
else:
    print('YES')
    for i in range(n):
        print(a[i])",O(nlogn)
"k=int(input())
x=0
c=0
while(x<k):
    x+=9*(10**c)*(c+1)
    c+=1
p=(x-k)%c
k=((10**c)-int(((x-k)/c))-1)
k=str(k)
print(k[len(k)-(p)-1])",O(logn)
"class Solution(object):
    def replaceDigits(self, s):
        return """".join(chr(ord(s[i-1])+int(s[i])) if i%2 else s[i] for i in range(len(s)))",O(n)
"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def diameterOfBinaryTree(self, root):
        def iter_dfs(node):
            result = 0
            stk = [(1, [node, [0]])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    result = max(result, ret1[0]+ret2[0])
                    ret[0] = 1+max(ret1[0], ret2[0])
            return result
        
        return iter_dfs(root)",O(n)
"n,k=map(int,input().split())

ar=[-1 for i in range(256)]
ls=list(map(int,input().split()))

for e in ls:
    if ar[e]==-1:
        tmp=max(0,e-k+1)
        for i in range(tmp,e+1):
            if ar[i]!=-1 and ar[i]!=i:
                tmp+=1
                continue
            else:
                while i<=e:
                    ar[i]=tmp
                    i+=1
    print(ar[e],end="" "")
",O(n ^ 2)
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i+4-4],effect[j][i+3-3],inf*inf)

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"n, m=[int(k) for k in input().split()]
w=[int(k) for k in input().split()]
w=[0]+w+[m]
c, d=[], []
res=0
for j in range(n+1):
    c.append(res)
    if j%2==0:
        res+=w[j+1]-w[j]
res=0
for j in range(n+1, -1, -1):
    if j%2==0 and j!=n+1:
        res+=w[j+1]-w[j]
    d.append(res)
d=d[::-1]
mx=d[0]
for j in range(n+1):
    mx=max(c[j]+(w[j+1]-w[j]-1)+(m-w[j+1]-d[j+1]), mx)

print(mx)",O(n)
"class Solution(object):
    def maxHeight(self, cuboids):
        for cuboid in cuboids:
            cuboid.sort()
        cuboids.append([0, 0, 0])
        cuboids.sort()
        dp = [0]*len(cuboids)
        for i in range(1, len(cuboids)):
            for j in range(i):
                if all(cuboids[j][k] <= cuboids[i][k] for k in range(3)):
                    dp[i] = max(dp[i], dp[j]+cuboids[i][2])
        return max(dp)",O(n ^ 2)
"n, k = map(int, input().split())
values, single, l, r = [int(i) for i in input().split()], set(), -1, -1
for i in range(n):
    single.add(values[i])
    if len(single) == k:
        l, r = 1, i + 1
        break
single = set()
for i in range(r - 1, max(-1, l - 2), -1):
    single.add(values[i])
    if len(single) == k:
        l = i + 1
        break

if len(single) < k:
    print(-1, -1)
else:
    print(l, r)
",O(n)
"a,b = map(int, input().split())
x, y, z = map(int, input().split())

ans = max(0, 2*x+y-a)+max(0, 3*z+y-b)
print(ans)
",O(1)
"def resistors(a,b):
    ans=0
    while b:
        ans+=a//b
        a,b=b,a%b
    return ans
a,b=map(int,input().strip().split())
print(resistors(a,b))",O(1)
"k1,k2,k3=map(int,input().split())
a=[k1,k2,k3];a=sorted(a)
if a[0]==1 or a.count(2)>=2 or a.count(3)==3:print(""YES"")
elif a.count(4)==2 and a.count(2)==1:print(""YES"")
else:print(""NO"")
",O(1)
"class Solution(object):
    def minOperations(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        cnt = nums.count(1)
        if cnt:
            return len(nums)-cnt
        result = float(""inf"")
        for i in range(len(nums)): 
            g = nums[i]
            for j in range(i+1, len(nums)):
                g = gcd(g, nums[j])
                if g == 1:
                    result = min(result, j-i)
                    break
        return result+(len(nums)-1) if result != float(""inf"") else -1",O(n ^ 2)
"import itertools



class Solution(object):
    def sumSubarrayMins(self, A):
        M = 10**9 + 7

        left, s1 = [0]*len(A), []
        for i in range(len(A)):
            count = 1
            while s1 and s1[-1][0] > A[i]:
                count += s1.pop()[1]
            left[i] = count
            s1.append([A[i], count])

        right, s2 = [0]*len(A), []
        for i in reversed(range(len(A))):
            count = 1
            while s2 and s2[-1][0] >= A[i]:
                count += s2.pop()[1]
            right[i] = count
            s2.append([A[i], count])

        return sum(a*l*r for a, l, r in zip(A, left, right)) % M",O(n)
"import sys

input = sys.stdin.readline

r, g, b = map(int, input().split())
sticks, dp, ans = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)], [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0

for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            ans = max(ans, dp[i][j][k])
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])
print(ans)
",O(n ^ 3)
"N, M = map(int, input().split())

grid = []
for _ in range(N):
    grid.append(list(input()))

def check(grid, i, j, sx, sy):
    if i - sx >= 0 and j - sy >= 0 and i + 2 - sx < N and j + 2 - sy < M:
        i -= sx
        j -= sy
        v = grid[i][j] == '
        return v

    return False

prev = False
for m in range(M):
    for n in range(N):
        if grid[n][m] == '
            if not (check(grid, n, m, 0, 0) or check(grid, n, m, 1, 0) or check(grid, n, m, 2, 0) or check(grid, n, m, 0, 1) or check(grid, n, m, 2, 1) or check(grid, n, m, 0, 2) or check(grid, n, m, 1, 2) or check(grid, n, m, 2, 2)):
                print(""NO"")
                exit(0)

print(""YES"")
",O(n ^ 2)
"class Solution(object):
    def clumsy(self, N):
        if N <= 2:
            return N
        if N <= 4:
            return N+3
        
        if N % 4 == 0:
            return N+1
        elif N % 4 <= 2:
            return N+2
        return N-1",O(1)
"n = int(input())
l1 = list(input().split())
l2 = []
for i in l1:
    l2.append(int(i))
l1 = set(l2)
l1 = list(l1)
for i in range(0, len(l1)):
    for j in range(i + 1, len(l1)):
        if l1[i] > l1[j]:
            temp = l1[j]
            l1[j] = l1[i]
            l1[i] = temp
if len(l1) > 1:
    print(l1[1])
else:
    print('NO')
",O(nlogn)
"class Solution(object):
    def squareIsWhite(self, coordinates):
        return (ord(coordinates[0])-ord('a'))%2 != (ord(coordinates[1])-ord('1'))%2",O(1)
"n = int(input())
data = [int(i) for i in input().split()]
data.sort()
ans = [0]*n
col = 0
for i in range(n):
    if ans[i] == 0:
        col += 1
        ans[i] = 1
        d = data[i]
        for j in range(i+1, n):
            if data[j] % d == 0:
                ans[j] = 1
print(col)
",O(n ^ 2)
"import random



class Solution(object):
    def maxSubsequence(self, nums, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        partition = nums[:]
        nth_element(partition, k-1, compare=lambda a, b: a > b)
        cnt = sum(partition[i] == partition[k-1] for i in range(k))
        result = []
        for x in nums:
            if x > partition[k-1]:
                result.append(x)
            elif x == partition[k-1] and cnt > 0:
                cnt -= 1
                result.append(x)
        return result",O(n)
"class Solution2(object):
    def rangeBitwiseAnd(self, m, n):
        i, diff = 0, n-m
        while diff:
            diff >>= 1
            i += 1
        return n & m >> i << i",O(1)
"read = lambda: map(int, input().split())
def sq(x):
    return int(x ** 0.5) ** 2 == x
t = int(input())
for _ in range(t):
    n = int(input())
    if (n % 2 == 0 and sq(n // 2)) or (n % 4 == 0 and sq(n // 4)):
        print('YES')
    else:
        print('NO')",O(1)
"from sys import stdin

add = lambda a, b: (a % mod + b % mod) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(2)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, k + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i & 1][val][k2] = add(mem[(i - 1) & 1][j][k1], mem[i & 1][val][k2])

    for j in range(1, k + 1):
        for k1 in range(4):
            mem[(i - 1) & 1][j][k1] = 0

print(sum(mem[(n - 1) & 1][k]) % mod)
",np
"n = int(input())
x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())
x3, y3 = map(int, input().split())
if (x2 < x1 and x3 < x1 or x2 > x1 and x3 > x1) and (y2 < y1 and y3 < y1 or y2 > y1 and y3 > y1):
    print(""YES"")
else:
    print(""NO"")
",O(1)
"class Solution(object):
    def maximumOddBinaryNumber(self, s):
        a = list(s)
        left = 0
        for i in range(len(a)):
            if a[i] != '1':
                continue
            a[i], a[left] = a[left], a[i]
            left += 1
        if a[-1] != '1':
            a[-1], a[left-1] = a[left-1], a[-1]
        return """".join(a)",O(n)
"from sys import stdin,stdout
from collections import deque
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))
PI=float('inf')
M=10**9+7
for _ in range(1):
    n=nmbr()
    s=[input() for _ in range(n)]
    dp=[[0 for _ in range(n+1)] for _ in range(n+1)]
    dp[0][0]=1
    for i in range(1,n):
        for j in range(n):
            if i>=1 and s[i-1]=='f':
                if j>=1:dp[i][j]=dp[i-1][j-1]-(dp[i-1][j])
            elif i>=1:
                dp[i][j]=dp[i-1][j]
            dp[i][j]%=M
        for k in range(n-1,-1,-1):
            dp[i][k]=(dp[i][k]+dp[i][k+1])%M

    print(dp[n-1][0]%M)",O(n ^ 2)
"n = int(input())
arr = list(map(int,input().split()))
arr.sort()
if n>=2 and  arr[0]==arr[1]==0:
	print(""cslnb"")
else:
	flag=0
	for i in range(n-2):
		if arr[i]==arr[i+1]==arr[i+2]:
			flag=1
			break
	if flag==1:
		print(""cslnb"")
	else:
		flag=0
		ind=0
		for i in range(n-1):
			if arr[i]==arr[i+1]:
				ind = i
				flag+=1
		if flag==1 and ind>0 and arr[ind-1]==arr[ind]-1:
			print(""cslnb"")

		elif flag>=2:
			print(""cslnb"")
		else:
			safe = 0
			for i in range(n):

				if arr[i]-i>=0:
					safe+=arr[i]-i

			if safe%2==0:
				print(""cslnb"")
			else:
				print(""sjfnb"")",O(nlogn)
"x, k= [int(x) for x in raw_input().split()]

MOD = 10 ** 9 + 7

def modulus(a, b, m):

    if b == 0:
        return 1
    if b == 1:
        return a % m

    result = int(modulus(a, b // 2, m))

    if b % 2 == 0:
        return  int (( (result % m) * (result % m) ) % m)
    else:
        return int (( (result % m) * (result % m) * (a % m)) % m)

def pow_mod(x, y, z):
    ""Calculate (x ** y) % z efficiently.""
    number = 1
    while y:
        if y & 1:
            number = number * x % z
        y >>= 1
        x = x * x % z
    return number
if x == 0:
    print(0)
elif k != 0:
    print( int( ( (modulus(2, k + 1, MOD) * (x % MOD) ) % MOD - (modulus(2, k, MOD)) % MOD + 1 + MOD) % MOD ))
else:
    print(int((x % MOD) * 2 % MOD) )",O(logn)
"import itertools



class Solution(object):
    def minOperations(self, nums1, nums2, k):
        cnt1 = cnt2 = 0
        for x, y in zip(nums1, nums2):
            if y == x:
                continue
            if k == 0 or (y-x)%k:
                return -1
            if x < y:
                cnt1 += (y-x)//k
            else:
                cnt2 += (x-y)//k
        return cnt1 if cnt1 == cnt2 else -1",O(n)
"class Solution(object):
    def pathInZigZagTree(self, label):
        count = 2**label.bit_length()
        result = []
        while label >= 1:
            result.append(label)
            label = ((count//2) + ((count-1)-label)) // 2
            count //= 2
        result.reverse()
        return result",O(logn)
"
import itertools


class Solution(object):
    def shortestToChar(self, S, C):
        result = [len(S)] * len(S)
        prev = -len(S)
        for i in itertools.chain(range(len(S)),
                                 reversed(range(len(S)))):
            if S[i] == C:
                prev = i
            result[i] = min(result[i], abs(i-prev))
        return result

",O(n)
"class Solution(object):
    def numDecodings(self, s):
        M, W = 1000000007, 3
        dp = [0] * W
        dp[0] = 1
        dp[1] = 9 if s[0] == '*' else dp[0] if s[0] != '0' else 0
        for i in range(1, len(s)):
            if s[i] == '*':
                dp[(i + 1) % W] = 9 * dp[i % W]
                if s[i - 1] == '1':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 9 * dp[(i - 1) % W]) % M
                elif s[i - 1] == '2':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 6 * dp[(i - 1) % W]) % M
                elif s[i - 1] == '*':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 15 * dp[(i - 1) % W]) % M
            else:
                dp[(i + 1) % W] = dp[i % W] if s[i] != '0' else 0
                if s[i - 1] == '1':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M
                elif s[i - 1] == '2' and s[i] <= '6':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M
                elif s[i - 1] == '*':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + (2 if s[i] <= '6' else 1) * dp[(i - 1) % W]) % M
        return dp[len(s) % W]",O(n)
"import collections


class Solution(object):
    def distinctNumbers(self, nums, k):
        result = []
        count = collections.Counter()
        for i, num in enumerate(nums):
            count[num] += 1
            if i >= k:
                count[nums[i-k]] -= 1
                if not count[nums[i-k]]:
                    del count[nums[i-k]]
            if i+1 >= k:
                result.append(len(count))
        return result",O(n)
"n, M = map(int, input().split())
A = list(map(int, input().split()))
A = [0]+A+[M]
D = []
for i in range(n+1):
    D.append(A[i+1]-A[i])

E = []
O = []
for i, d in enumerate(D):
    if i%2 == 0:
        E.append(d)
        O.append(0)
    else:
        O.append(d)
        E.append(0)
from itertools import accumulate
CE = [0]+E
CE = list(accumulate(CE))
CO = [0]+O
CO = list(accumulate(CO))

ans = CE[-1]
for i in range(n+1):
    if D[i] == 1:
        continue
    temp = CE[i]+(D[i]-1)+CO[-1]-CO[i+1]

    ans = max(ans, temp)
print(ans)
",O(n)
"

class Solution(object):
    def createBinaryTree(self, descriptions):
        nodes = {}
        children = set()
        for p, c, l in descriptions:
            parent = nodes.setdefault(p, TreeNode(p))
            child = nodes.setdefault(c, TreeNode(c))
            if l:
                parent.left = child
            else:
                parent.right = child
            children.add(c)
        return nodes[next(p for p in nodes.keys() if p not in children)]
",O(n)
"def rotate(L):
    L1 = ['' for i in range(n)]
    for i in range(n):
        for j in range(n):
            L1[n - j - 1] += L[i][j]
    return L1

def flip_v(L):
    L1 = []
    for i in range(n):
        L1.append(L[i][::-1])
    return L1

def flip_h(L):
    L1 = []
    for i in range(n):
        L1.append(L[n - i - 1])
    return L1

n = int(input())
L = []
M = []
for i in range(n):
    L.append(input())
for i in range(n):
    M.append(input())
L1 = rotate(L)
L2 = rotate(L1)
L3 = rotate(L2)
L4 = flip_v(L)
L5 = flip_h(L)
L6 = rotate(L4)
L7 = rotate(L6)
L8 = rotate(L7)
L9 = rotate(L5)
L10 = rotate(L9)
L11 = rotate(L10)
if L == M or L1 == M or L2 == M or L3 == M or L4 == M or L5 == M or L6 == M or L7 == M or L8 == M or L9 == M or L10 == M or L11 == M:
    print('Yes')
else:
    print('No')",O(n ^ 2)
"a = int(input())
s = {}
ans = 0
for i in range(a - 1):
    v, c = map(int, input().split())
    if v in s:
        s[v].append(c)
    else:
        s[v] = [c]
    if c in s:
        s[c].append(v)
    else:
        s[c] = [v]
c = 0
for i in range(1, a + 1):
    if len(s[i]) > 2:
        c += 1
        ans = i
if c > 1:
    print(""No"")
elif c == 0:
    print(""Yes"")
    print(1)
    for i in s:
        if len(s[i]) == 1:
            print(i, end="" "")
else:
    print(""Yes"")
    print(len(s[ans]))
    k = []
    for i in s:
        if len(s[i]) == 1:
            k.append(i)
    for i in k:
        print(min(ans, i), max(ans, i))
",O(n)
"def detect_cycle(n,edges):
        visited = [False]*n
        stack = []
        color = [0]*n
        for v in range(n):
            if not visited[v]:
                if dfs_visit(v,edges,visited,stack,color):
                    return stack
        return None

def dfs_visit(v,edges,visited,stack,color):
        visited[v] = True
        stack.append(v)
        color[v] = 1
        for u in edges[v]:
            if not visited[u]:
               if dfs_visit(u,edges,visited,stack,color):
                   return True

            elif color[u] == 1:
                stack.append(u)
                return True

        color[v] = 2
        stack.pop(stack.index(v))
        return False

if __name__ == '__main__':
        n,m = map(int,input().split())
        edges = [[] for i in range(n)]
        for _ in range(m):
            u,v  = map(int,input().split())
            edges[u - 1].append(v - 1)

        inCycle = detect_cycle(n,edges)
        if inCycle:
            possible = False
            index = inCycle.index(inCycle[-1])
            inCycle = inCycle[index:]
            for v in range(len(inCycle) - 1):
                edges[inCycle[v]].remove(inCycle[v + 1])
                if detect_cycle(n,edges) is None:
                    possible = True
                    break
                else:
                    edges[inCycle[v]].append(inCycle[v + 1])
        else: possible = True
print('YES' if possible else 'NO')
",O(n ^ 2)
"import collections


class Solution(object):
    def isEscapePossible(self, blocked, source, target):
        R, C = 10**6, 10**6
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def bfs(blocks, source, target):
            max_area_surrounded_by_blocks = len(blocks)*(len(blocks)-1)//2
            lookup = set([source])
            if len(lookup) > max_area_surrounded_by_blocks:
                return True
            q = collections.deque([source])
            while q:
                source = q.popleft()
                if source == target:
                    return True
                for direction in directions:
                    nr, nc = source[0]+direction[0], source[1]+direction[1]
                    if not ((0 <= nr < R) and
                            (0 <= nc < C) and 
                            (nr, nc) not in lookup and
                            (nr, nc) not in blocks):
                        continue
                    lookup.add((nr, nc))
                    if len(lookup) > max_area_surrounded_by_blocks:
                        return True
                    q.append((nr, nc))
            return False
        
        return bfs(set(map(tuple, blocked)), tuple(source), tuple(target)) and \
               bfs(set(map(tuple, blocked)), tuple(target), tuple(source))",O(n ^ 2)
"import math

types_of_toy , toy_pair = map(int,input().split())

if(toy_pair <= types_of_toy ):
    print(math.floor( ( toy_pair - 1 ) /2))
elif( toy_pair <= 2*types_of_toy - 1):
    print(math.floor( ( types_of_toy +1 -(toy_pair - types_of_toy) )/ 2))
else:
    print(0)
",O(1)
"class Solution:
    def checkValidString(self, s: str) -> bool:
        n = len(s)
        memo = [[None] * (n + 1) for _ in range(n + 1)]

        def dfs(i, open):
            if open < 0:
                return False
            if i == n:
                return open == 0
            if memo[i][open] is not None:
                return memo[i][open]

            if s[i] == '(':
                result = dfs(i + 1, open + 1)
            elif s[i] == ')':
                result = dfs(i + 1, open - 1)
            else:
                result = (dfs(i + 1, open) or
                          dfs(i + 1, open + 1) or
                          dfs(i + 1, open - 1))

            memo[i][open] = result
            return result

        return dfs(0, 0)
",O(n ^ 2)
"index = int(input())

total = 9
n = 1

while index > total:
    total += (n + 1) * (10**n) * 9
    n += 1
last = 10**(n - 1)
total -= n * 9 * last
index = index - total

r = index % (n)
k = index // n

number = last + k

if r == 0:
    print(str(number - 1)[n-1])
else:
    print(str(number)[r - 1])
",O(1)
"
class Solution(object):
    def reverseWords(self, s):
        return ' '.join(reversed(s.split()))

",O(n)
"import sys
sys.setrecursionlimit(int(1e7))

def main():
    n = int(input().strip())
    print(2*(n*(n-1))+1)
    return

while 1:
    try: main()
    except EOFError: break",O(1)
"get = lambda : list(map(int, input().split(' ')))
n, m, k = get()
rlist, clist = [], []
for _ in range(n):
    rlist.append(get())
for _ in range(n-1):
    clist.append(get())

dway = [[0,1],[0,-1],[1,0],[-1,0]]
if k%2:
    res = [[-1]*m for _ in range(n)]
else:
    flist = [[0]*m for _ in range(n)]
    for _ in range(k//2):
        glist = [[10**9]*m for _ in range(n)]
        for dx, dy in dway:
            klist = rlist if dx == 0 else clist
            for x in range(n):
                for y in range(m):
                    xx, yy = x+dx, y+dy
                    if not (0<=xx<n) or not (0<=yy<m):
                        continue
                    tx = xx if dx==-1 else x
                    ty = yy if dy==-1 else y
                    glist[x][y] = min(glist[x][y], flist[xx][yy] + klist[tx][ty] * 2)
        flist = glist
    res = flist
for row in res:
    print(' '.join(map(str, row)))",O(n ^ 3)
"n,s=int(input()),input()
p,q,r=len(set(s)),{},10**6
for i in range(n):
    q[s[i]]=i
    if len(q)==p:r=min(r,max(q.values())-min(q.values()))
print(r+1)",O(n)
"from sys import stdin, stdout
mod=(10**9)+7
mod1=mod-1
def modinv(n,p):
    return pow(n,p-2,p)
def ncr(n,r,p):
    t=((fact[n])*(modinv(fact[r],p)%p)*(modinv(fact[n-r],p)%p))%p
    return t
def GCD(x, y):
   while(y):
       x, y = y, x % y
   return x
def BS(arr, l, r, x):
    if r >= l:
        mid = l + (r - l)/2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return BS(arr, l, mid-1, x)
        else:
            return BS(arr, mid+1, r, x)
    else:n -1
from bisect import bisect_left as bl
from bisect import bisect_right as br
import itertools
import math
from Queue import Queue as Q
import heapq
from random import randint as rn
def comp(x,y):
    if(x[0]<y[0]):
        return -1
    elif(x[0]==y[0]):
        if(x[1]<y[1]):
            return -1
        else:
            return 1
    else:
        return 1

q=[]
for _ in range(input()):
    a=int(stdin.readline())
    b=map(int,stdin.readline().split())
    w={}
    for i in range(a):
        if(w.has_key(b[i])):
            w[b[i]]+=1
        else:
            w[b[i]]=1
    s=-1
    l=0
    mi=2325234324324234
    d=[]
    for i in w:
        if(w[i]>=4):
            t=[str(i),str(i),str(i),str(i)]
            q.append("" "".join(t))
            l=1
            break
        if(w[i]>=2):
            d.append(i)
    if(l==1):
        continue
    d.sort()
    for i in range(len(d)):
        if(s==-1):
            s=d[i]
        else:
            r=float(s)/float(d[i])
            r+=float(d[i])/float(s)
            if(r<mi):
                p=[str(d[i]),str(s)]
                mi=r
            s=d[i]
    p=p*2
    q.append("" "".join(p))
stdout.write(""\n"".join(q))
",O(nlogn)
"import sys
input=sys.stdin.readline
n,k=map(int,input().split())
theorems=list(map(int,input().split()))
sleep=list(map(int,input().split()))
tsum=[]
ts=0
sleepsum=[]
slsum=0
for i in range(n):
    ts+=theorems[i]
    tsum.append(ts)
    if(sleep[i]==1):
        slsum+=theorems[i]
    sleepsum.append(slsum)

maxdiff=0

maxdiff=tsum[k-1]-sleepsum[k-1]
for i in range(1,n-k+1):
    diff=(tsum[i+k-1]-tsum[i-1])-(sleepsum[i+k-1]-sleepsum[i-1])

    maxdiff=max(maxdiff,diff)

print(slsum+maxdiff)",O(n)
"from math import inf

a=[0,0]
a[0]=[str(c)for c in list(input().strip()) ]
a[1]=[str(X) for X in list(input().strip())]

an = [-inf,-inf,-inf]
if a[0][0]==a[1][0]=='0':
    an[0]=0
elif  a[0][0]!=a[1][0]:
    an[1]=0
x=0
for i in range(1,len(a[0])) :

    if an[0]==0:
        if a[0][i]==a[1][i]=='0':
            x+=1

            an=[-inf,0 ,-inf]
        elif a[0][i]!=a[1][i]:
            x+=1
            an=[-inf]*3
        else:
            an = [-inf, -inf, -inf]
    elif an[1]==0:
        if a[0][i]==a[1][i]=='0':
            x+=1
            an=[-inf,-inf ,-inf]
        elif a[0][i]!=a[1][i]:
            pass
        else:
            an=[-inf,-inf ,-inf]
    else:
        if a[0][i]==a[1][i]=='0':

            an=[0,-inf ,-inf]
        elif a[0][i]!=a[1][i]:
            an=[-inf,0,-inf]
        else:
            an=[-inf,-inf ,-inf]

print(x)",O(1)
"from math import log
from collections import deque
n,k=map(int,input().split())
s=list(map(int,input().split()))
ans=0
s.sort()
s1=deque(s)
for j in range(11):
    d=dict()
    z=10**j
    for i in s:
        y=i*z
        u=y%k
        if u in d:
            d[u]+=1
        else:
            d.update({u:1})
    aux=0
    for i in s1:
        y=i
        lg=int(log(i,10))+1
        lg=10**lg
        if lg==z:
            d[(y*z)%k]-=1
            x=(k-y%k)
            if y%k==0:
                x=0
            if x in d:
                ans+=d[x]
            d[(y*z)%k]+=1
            aux+=1
        else:
            break
    for i in range(aux):
        s1.popleft()

print(ans)
",O(nlogn)
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
print('\n'.join(map(lambda x: ''.join(map(str, x)), r)))
",O(n ^ 2)
"class Solution(object):
    def convertDateToBinary(self, date):
        return ""-"".join([bin(int(x))[2:] for x in date.split('-')])",O(1)
"def checksq(n):
    m = int(n**0.5)
    if m * m == n:
        return m
    m += 1
    if m * m == n:
        return m
    return -1

def main():

    n = int(input())

    if n % 2 == 1:
        print(""NO"")
        return
    if checksq(n // 2) != -1:
        print('YES')
        return
    n //= 2
    if n % 2 == 1:
        print('NO')
        return
    if checksq(n // 2) != -1:
        print('YES')
    else:
        print('NO')

for i in range(int(input())):
    main()",O(1)
"class Solution(object):
    def partitionLabels(self, S):
        lookup = {c: i for i, c in enumerate(S)}
        first, last = 0, 0
        result = []
        for i, c in enumerate(S):
            last = max(last, lookup[c])
            if i == last:
                result.append(i-first+1)
                first = i+1
        return result",O(n)
"class Solution2(object):
    def numWays(self, n, k):
        if n == 0:
            return 0
        elif n == 1:
            return k
        ways = [0] * n
        ways[0] = k
        ways[1] = (k - 1) * ways[0] + k
        for i in range(2, n):
            ways[i] = (k - 1) * (ways[i - 1] + ways[i - 2])
        return ways[n - 1]",O(n)
"import collections



class Solution2(object):
    def maxFrequencyScore(self, nums, k):
        MOD = 10**9+7
        result = curr = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            if i >= k:
                curr = (curr-pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD
                cnt[nums[i-k]] -= 1
                if cnt[nums[i-k]]:
                    curr = (curr+pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD
            if cnt[nums[i]]:
               curr = (curr-pow(nums[i], cnt[nums[i]], MOD))%MOD
            cnt[nums[i]] += 1
            curr = (curr+pow(nums[i], cnt[nums[i]], MOD))%MOD
            if i >= k-1:
                result = max(result, curr)
        return result",O(n)
"n , m=map(int,input().split())
l1=list(map(int,input().split()))
l2=list(map(int,input().split()))
l3=[]
for i in range(n):
    for j in range(m):
        if l1[i]==l2[j]:
            if l1[i] is not l3:
                l3.append(l1[i])
print(*l3)
",O(n ^ 2)
"class Solution(object):
    def findMissingAndRepeatedValues(self, grid):
        n = len(grid)
        a_xor_b = 0
        for i in range(n**2):
            r, c = divmod(i, n)
            a_xor_b ^= grid[r][c]^(i+1)
        base = a_xor_b&-a_xor_b
        result = [0]*2
        for i in range(n**2):
            r, c = divmod(i, len(grid[0]))
            result[1 if (i+1)&base != 0 else 0] ^= i+1
            result[1 if grid[r][c]&base != 0 else 0] ^= grid[r][c]
        if any(x == result[1] for row in grid for x in row):
            result[0], result[1] = result[1], result[0]
        return result",O(n ^ 2)
"from random import randint

mod = 10**9 + 7
d = {}
n, m, l = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
def go(i, j, k):
    val = i * 40401 + j * 201 + k
    ret = 0
    if val in d:
        return d[val]
    elif i < n and j < m and k < l:
        ret = max(a[i] * b[j] + go(i + 1, j + 1, k), b[j] * c[k] + go(i, j + 1, k + 1), c[k] * a[i] + go(i + 1, j, k + 1))
    elif i < n and j < m:
        ret = a[i] * b[j] + go(i + 1, j + 1, k)
    elif j < m and k < l:
        ret = b[j] * c[k] + go(i, j + 1, k + 1)
    elif k < l and i < n:
        ret = c[k] * a[i] + go(i + 1, j, k + 1)
    d[val] = ret
    return ret

a.sort(reverse = True)
b.sort(reverse = True)
c.sort(reverse = True)
print(go(0, 0, 0))
",O(n ^ 3)
"class Solution(object):
    def isValidPalindrome(self, s, k):
        if s == s[::-1]: 
            return True

        dp = [[1] * len(s) for _ in range(2)]
        for i in reversed(range(len(s))):
            for j in range(i+1, len(s)):
                if s[i] == s[j]:
                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2
                else:
                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])
        return len(s) <= k + dp[0][-1]",O(n ^ 2)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def levelOrderBottom(self, root):
        if root is None:
            return []

        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            current = next_level
            result.append(vals)

        return result[::-1]",O(n)
"class Solution(object):
    def findKthPositive(self, arr, k):
        def check(arr, k, x):
            return arr[x]-(x+1) < k

        left, right = 0, len(arr)-1
        while left <= right:
            mid = left + (right-left)//2
            if not check(arr, k, mid):
                right = mid-1
            else:
                left = mid+1
        return right+1+k",O(logn)
"import io
import os
import sys

input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

def prdbg(*args, **kwargs):
    print(*args, **kwargs)
    pass

def get_str():
    return input().decode().strip()

def rint():
    return map(int, input().split())

def oint():
    return int(input())

def valid(i1,i2,i3):
    if (i1+i2+i3)%2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2\
            or i2 > i1 + i3 or i1 > i2 + i3:
        return False
    return True

def dfs(i1,i2,i3):

    if (i1 + i2 + i3) % 2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2 \
                or i2 > i1 + i3 or i1 > i2 + i3:
        return -2
    if dp[i1][i2][i3] != -1:
        return dp[i1][i2][i3]
    ret1 = dfs(i1-1, i2-1, i3)
    if ret1 >= 0 :
        ret1 += a1[i1]*a2[i2]
    ret2 = dfs(i1-1, i2, i3-1)
    if ret2 >= 0:
        ret2 += a1[i1]*a3[i3]
    ret3 = dfs(i1, i2-1, i3-1)
    if ret3 >= 0:
        ret3 += a2[i2]*a3[i3]
    ret = max(ret1, ret2, ret3)
    dp[i1][i2][i3] = ret
    return ret

n1, n2, n3 = rint()
a1, a2, a3 = list(rint()), list(rint()), list(rint())
a1.sort(reverse=True)
a2.sort(reverse=True)
a3.sort(reverse=True)
a1 = [0] + a1
a2 = [0] + a2
a3 = [0] + a3
n1 += 1
n2 += 1
n3 += 1

dp = [[[-1 for i3 in range(n3)] for i2 in range(n2)] for i1 in range(n1)]
dp[1][1][0] = a1[1]*a2[1]
dp[1][0][1] = a1[1]*a3[1]
dp[0][1][1] = a2[1]*a3[1]
dp[0][0][0] = -2

for i1 in range(n1):
    for i2 in range(n2):
        for i3 in range(n3):
            dfs(i1, i2, i3)
ans = -1
for i1 in range(n1):
    for i2 in range(n2):
        for i3 in range(n3):
            ans = max(ans, dp[i1][i2][i3])

print(ans)
",O(n ^ 3)
"x, y, z, t1, t2, t3 = [int(i) for i in input().split()]
if abs(z-x)*t2 + 3 * t3 + abs(x-y)*t2 <= abs(x-y)*t1:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"def strongly_connected_components(adj): 
    def strongconnect(v):
        index[v] = index_counter[0]
        lowlinks[v] = index_counter[0]
        index_counter[0] += 1
        stack_set[v] = True
        stack.append(v)
        for w in adj[v]:
            if index[w] == -1:
                strongconnect(w)
                lowlinks[v] = min(lowlinks[v], lowlinks[w])
            elif stack_set[w]:
                lowlinks[v] = min(lowlinks[v], index[w])
        if lowlinks[v] == index[v]:
            connected_component = []
            w = None
            while w != v:
                w = stack.pop()
                stack_set[w] = False
                connected_component.append(w)
            result.append(connected_component)

    index_counter, index, lowlinks = [0], [-1]*len(adj), [-1]*len(adj)
    stack, stack_set = [], [False]*len(adj)
    result = []
    for v in range(len(adj)):
        if index[v] == -1:
            strongconnect(v)
    return result


class Solution(object):
    def minRunesToAdd(self, n, crystals, flowFrom, flowTo):
        adj = [[] for _ in range(n)]
        for i in range(len(flowFrom)):
            adj[flowFrom[i]].append(flowTo[i])
        lookup = [-1]*n
        sccs = strongly_connected_components(adj)
        for i, scc in enumerate(sccs):
            for x in scc:
                lookup[x] = i
        result = [False]*len(sccs)
        for u in range(n):
            for v in adj[u]:
                if lookup[v] != lookup[u]:
                    result[lookup[v]] = True
        for x in crystals:
            result[lookup[x]] = True
        return sum(not x for x in result)",O(n)
"n,k = map(int,input().split())
r = 0
for _ in range(n):
    h,m = map(int,input().split())
    t = 60*h+m
    if(t>r+k):
        break
    r = t+k+1
print(r//60,r%60)",O(n)
"from sortedcontainers import SortedList
import collections



class Solution(object):
    def findXSum(self, nums, k, x):
        def update(v, d, curr):
            if d == 1:
                sl.add((-cnt[v], -v))
            if sl.index((-cnt[v], -v)) < x:
                curr += d*cnt[v]*v
                if x < len(sl):
                    nc, nv = sl[x]
                    curr -= d*nc*nv
            if d != 1:
                sl.remove((-cnt[v], -v))
            return curr

        sl = SortedList()
        cnt = collections.defaultdict(int)
        result = []
        curr = 0
        for i, v in enumerate(nums):
            if v in cnt:
                curr = update(v, -1, curr)
            cnt[v] += 1
            curr = update(v, +1, curr)
            if i < k-1:
                continue
            result.append(curr)
            curr = update(nums[i-(k-1)], -1, curr)
            cnt[nums[i-(k-1)]] -= 1
            if cnt[nums[i-(k-1)]]:
                curr = update(nums[i-(k-1)], +1, curr)
            else:
                del cnt[nums[i-(k-1)]]
        return result",O(nlogn)
"n=int(input())
l1=[]
l2=[]
for _ in range(n):
    l1.append(input())
for _ in range(n):
    l2.append(input())
c=0
for i in range(n):
    if(l1[i]  in l2):
        l2.remove(l1[i])
    else:
        c+=1

print(c)
",O(n)
"n, m = [int(v) for v in input().split()]

a = []
for _ in range(n):
    a.append([int(v) for v in input()])

colsums = [sum(a[i][j] for i in range(n)) for j in range(m)]

for row in a:
    if all(rv < sv for (rv, sv) in zip(row, colsums)):
        print(""YES"")
        exit()

print(""NO"")
",O(n ^ 2)
"import itertools


class Solution(object):
    def gridGame(self, grid):
        result = float(""inf"")
        left, right = 0, sum(grid[0])
        for a, b in zip(grid[0], grid[1]):
            right -= a
            result = min(result, max(left, right))
            left += b
        return result",O(n)
"class Solution_Wrong_Greedy_SkipList(object):
    def minimumIncompatibility(self, nums, k):
        def greedy(nums, k, is_reversed):
            count = collections.Counter(nums)
            if max(count.values()) > k:
                return -1
            ordered_set = SkipList() if not is_reversed else SkipList(end=float(""-inf""), cmp=lambda x, y: x > y)
            freq_to_nodes = collections.defaultdict(collections.OrderedDict)
            for x in sorted(list(count.keys()), reverse=is_reversed):
                ordered_set.add(x)
                freq_to_nodes[count[x]][x] = count[x]
            stks = [[] for _ in range(k)] 
            curr = 0
            while ordered_set: 
                if len(stks)-curr in freq_to_nodes: 
                    for x in freq_to_nodes[len(stks)-curr].keys(): 
                        for i in range(curr, len(stks)):
                            stks[i].append(x)
                        count.pop(x)
                        ordered_set.remove(ordered_set.find(x))
                    freq_to_nodes.pop(len(stks)-curr)
                it = ordered_set.begin()
                while it != ordered_set.end():
                    x = it.val
                    stks[curr].append(x)
                    freq_to_nodes[count[x]].pop(x)
                    if not freq_to_nodes[count[x]]:
                        freq_to_nodes.pop(count[x])
                    count[x] -= 1 
                    if not count[x]:
                        count.pop(x)
                        it = ordered_set.remove(it) 
                    else:
                        freq_to_nodes[count[x]][x] = count[x]
                        it = it.nexts[0]
                    if len(stks[curr]) == len(nums)//k:
                        curr += 1
                        break
            return sum([max(stk)-min(stk) for stk in stks])

        return min(greedy(nums, k, False), greedy(nums, k, True))",O(nlogn)
"from collections import Counter
n, k = map(int, input().split())
c = Counter(input())
ans = min(c[chr(ord('A') + i)] for i in range(k))
print(k * ans)
",O(n)
"from math import sqrt

def dist(speed, time):

	return speed * time + a * time**2 / 2

def travelTime(distance, speed):

	tAll = (- speed + sqrt(speed**2 + 2 * distance * a)) / a

	tMax = (v - speed) / a

	if tMax >= tAll:
		return tAll
	else:
		return tMax + (distance - dist(speed, tMax)) / v

a, v = map(int, input().split())
l, d, w = map(int, input().split())

if v <= w:
	print(travelTime(l, 0))
else:
	tw = w / a

	dw = dist(0, tw)

	if dw >= d:
		print(travelTime(l, 0))
	else:
		print(tw + 2 * travelTime((d - dw) / 2, w) + travelTime(l - d, w))
",O(1)
"class Solution(object):
    def isPreorder(self, nodes):
        stk = [nodes[0][0]]
        for i in range(1, len(nodes)):
            while stk and stk[-1] != nodes[i][1]:
                stk.pop()                
            if not stk:
                return False            
            stk.append(nodes[i][0])            
        return True",O(n)
"from sortedcontainers import SortedList



class Solution(object):
    def minimumPairRemoval(self, nums):
        def add(i):
            if 0 <= i < right[i] < len(nums):
                sl.add([nums[i]+nums[right[i]], i])
                if nums[i] > nums[right[i]]:
                    cnt[0] += 1

        def remove(i):
            if 0 <= i < right[i] < len(nums):
                sl.remove([nums[i]+nums[right[i]], i])
                if nums[i] > nums[right[i]]:
                    cnt[0] -= 1

        left = list(range(-1, (len(nums)+1)-1))
        right = list(range(1, len(nums)+1))
        cnt = [sum(nums[i] > nums[i+1] for i in range(len(nums)-1))]
        sl = SortedList([nums[i]+nums[i+1], i] for i in range(len(nums)-1))
        result = 0
        while cnt[0]:
            _, i = sl[0]
            remove(left[i])
            remove(i)
            remove(right[i])
            nums[i] += nums[right[i]]
            left[right[right[i]]] = i
            right[i] = right[right[i]]
            add(left[i])
            add(i)
            result += 1
        return result",O(nlogn)
"for x in range(int(input())):
	a,b = map(int,input().split())
	if a > b or a == b:c,d = a,b
	else:c,d = b,a
	e = [0]
	def fun(c,d):
		e[0] += c // d
		f = d
		d = c % d
		c = f
		if f > 0 and d > 0:
			fun(c,d)
	fun(c,d)
	print(e[0])",O(1)
"
class Solution(object):
    def uniqueMorseRepresentations(self, words):
        MORSE = ["".-"", ""-..."", ""-.-."", ""-.."", ""."", ""..-."", ""--."",
                 ""...."", "".."", "".---"", ""-.-"", "".-.."", ""--"", ""-."",
                 ""---"", "".--."", ""--.-"", "".-."", ""..."", ""-"", ""..-"",
                 ""...-"", "".--"", ""-..-"", ""-.--"", ""--..""]

        lookup = {"""".join(MORSE[ord(c) - ord('a')] for c in word) \
                  for word in words}
        return len(lookup)

",O(n)
"def bina(bi):
    binary1 = bi
    decimal, i, n = 0, 0, 0
    while(bi != 0):
        dec = bi % 10
        decimal = decimal + dec * pow(2, i)
        bi = bi//10
        i += 1
    return decimal
def con(n):
   return bin(n).replace(""0b"", """")
l,r=map(int,input().split())
k=con(l)
m=con(r)
k=list(str(k))
m=list(str(m))
j=len(m)-len(k)
k=['0']*j + k

c=0
for i in range(len(m)):
    if k[i]!=m[i]:
        c=1
    if k[i]==m[i] and k[i]=='1' and c==1:
        k[i]='0'
    elif k[i]==m[i] and k[i]=='0' and c==1:
        k[i]='1'
k=int(''.join(k))
m=int(''.join(m))
print(bina(k)^bina(m))",O(logn)
"class Solution(object):
    def triangularSum(self, nums):
        def exp_mod(p, mod):
            result = [p]
            while result[-1]*p%10 != result[0]:
                 result.append(result[-1]*p%10)
            return [result[-1]]+result[:-1]

        def inv_mod(x, mod):
            y = x
            while y*x%10 != 1:
                y = y*x%10
            return y

        def factor_p(x, p, cnt, diff):
            if x == 0:
                return x, cnt
            while x%p == 0:
                x //= p
                cnt += diff
            return x, cnt
    
        EXP = {p:exp_mod(p, 10) for p in (2, 5)} 
        INV = {i:inv_mod(i, 10) for i in range(1, 10) if i%2 and i%5} 
        result = 0
        nCr = 1
        cnt = {2:0, 5:0}
        for i in range(len(nums)):
            if not cnt[2] and not cnt[5]:
                result = (result + nCr*nums[i])%10
            elif cnt[2] and not cnt[5]:
                result = (result + nCr*EXP[2][cnt[2]%len(EXP[2])]*nums[i])%10
            elif not cnt[2] and cnt[5]:
                result = (result + nCr*EXP[5][cnt[5]%len(EXP[5])]*nums[i])%10
            mul, cnt[2] = factor_p((len(nums)-1)-i, 2, cnt[2], 1)
            mul, cnt[5] = factor_p(mul, 5, cnt[5], 1)
            div, cnt[2] = factor_p(i+1, 2, cnt[2], -1)
            div, cnt[5] = factor_p(div, 5, cnt[5], -1)
            nCr = nCr*mul%10
            nCr = nCr*INV[div%10]%10
        return result",O(n)
"n = int(input())
left = []
right = []
for i in range(n):
	data = input().split()
	left.append(int(data[0]))
	right.append(int(data[1]))

left.sort()
right.sort()
i = 0
j = 0
count = 1
ans = [0] * (n + 1)
left += [max(right) + 1]
right += [max(right) + 2]
while (i < n) and (j < n):
	while left[i + 1] <= right[j]:
		ans[count] += (left[i + 1] - left[i])
		count += 1
		i += 1
	ans[count] += (right[j] - left[i] + 1)
	i += 1
	count -= 1

	while ((i == n) or (right[j + 1] < left[i])) and (j < n - 1):
		ans[count] += (right[j + 1] - right[j])
		count -= 1
		j += 1
	ans[count] += (left[i] - right[j] - 1)
	j += 1
	count += 1

for i in range(1, n + 1):
	print(ans[i], end = "" "")
print()
",O(nlogn)
"import collections


class Solution2(object):
    def numberOfSubarrays(self, nums, k):
        result = 0
        dq = collections.deque([-1])
        for i in range(len(nums)):
            if nums[i]%2:
                dq.append(i)
            if len(dq) > k+1:
                dq.popleft()
            if len(dq) == k+1:
                result += dq[1]-dq[0]
        return result",O(n)
"x, y, z, t1, t2, t3 = map(int, input().split())
lift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3
stairs = t1 * abs(x - y)
if lift <= stairs:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"import sys
reader = (s.rstrip() for s in sys.stdin)
inp = reader.__next__

n, m = map(int, inp().split())
arr = tuple(tuple(map(int, inp().split())) for i in range(n))
lower_bound = 0
upper_bound = int(1e9) + 1
mask = (1 << m) - 1

ans = (0, 0)

def can_upper(mid):
	global ans

	d = dict()
	for i in range(n):
		bit = 0
		for j in range(m):
			if arr[i][j] >= mid:
				bit += 1 << j
		d[bit] = i

	keys = tuple(d.keys())
	for i in range(len(keys)):
		a1 = keys[i]
		for j in range(i, len(keys)):
			a2 = keys[j]
			if a1 | a2 == mask:
				ans = (d[a1], d[a2])
				return True
	return False

while upper_bound - lower_bound > 1:
	middle = (upper_bound + lower_bound) >> 1
	if can_upper(middle):
		lower_bound = middle
	else:
		upper_bound = middle

print(ans[0] + 1, ans[1] + 1)",np
"import re
input()
print(sum(len(f)-2 for f in re.findall('x{3,}',input())))",O(n)
"n, l, r, x = map(int, input().split())
arr = list(map(int, input().split()))
res = 0
for j in range(1, 2**n):
    a = [arr[i] for i in range(n) if (((j >> i) & 1) == 1)]
    s = sum(a)
    res += (max(a) - min(a) >= x and s >= l and s <= r)
print(res)
",np
"class Solution(object):
    def beautifulIndices(self, s, a, b, k):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    yield i-j
                    j = prefix[j]

        result = []
        if not (len(a) <= len(s) and len(b) <= len(s)):
            return result
        lookup = list(KMP(s, b))
        j = 0
        for i in KMP(s, a):
            while j < len(lookup) and lookup[j] < i-k:
                j += 1
            if j < len(lookup) and lookup[j] <= i+k:
                result.append(i)
        return result",O(n)
"class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        res = 0

        def dfs(root):
            nonlocal res

            if not root:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            res = max(res, left + right)

            return 1 + max(left, right)

        dfs(root)
        return res
",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

def main():
    n, k = RLL()
    dp = [[0]*4 for _ in range(k+2)]
    dp[1][0] = 1
    dp[1][3] = 1
    dp[2][1] = 1
    dp[2][2] = 1
    tag = 0
    for i in range(2, n+1):
        new = [[0]*4 for _ in range(k+2)]
        for j in range(1, k+2):
            for l in range(4):
                tag+=1
                new[j][l] = ((dp[j][l])%mod + (new[j][l])%mod)%mod
                if l==0 or l==3:
                    new[j][l] = ((dp[j-1][l^3])%mod + (new[j][l])%mod)%mod
                    new[j][l] = (((dp[j][1])%mod+(dp[j][2])%mod) + (new[j][l])%mod)%mod
                elif l==1 or l==2:
                    new[j][l] = (((dp[j-1][0])%mod+(dp[j-1][3])%mod) + (new[j][l])%mod)%mod
                    if j-2>=0: new[j][l] = ((dp[j-2][l^3])%mod + (new[j][l])%mod)%mod
        dp = new
    print(sum(dp[k])%mod)

if __name__ == ""__main__"":
    main()
",np
"import sys
input = lambda: sys.stdin.readline().rstrip()

from collections import deque, defaultdict
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = ''
            for j in range(k):
                if i>>j&1:
                    ans = ''.join([ans, s[j]])
                else:
                    ans = ''.join([ans, '_'])
            Ans.add(ans)
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = 1
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = 0
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag == 0 or not T:
        print('NO')
    else:
        print('YES')
        print(*[t+1 for t in T], sep = ' ')

main()",np
"from collections import deque
from collections import OrderedDict
import math

import sys
import os
import threading
import bisect

import operator

import heapq

from atexit import register
from io import BytesIO

import io

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

r,g,b = map(int, input().split())
a = []
for i in range(3):
    a.append([int(x) for x in input().split()])
    a[i].sort(reverse=True)

dp = [[[0 for i in range(205)] for j in range(205)] for k in range(205)]
answer = 0

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i<r and j<g:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k], dp[i][j][k]+a[0][i]*a[1][j])
            if i<r and k<b:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1], dp[i][j][k]+a[0][i]*a[2][k])
            if j<g and k<b:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1], dp[i][j][k]+a[1][j]*a[2][k])
            answer=max(answer, dp[i][j][k])
print(answer)

sys.exit(0)

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person(""heelo"", 27)

print(help(Person))

age = 26
name = 'Swaroop'
print('Возрас {} -- {} лет'.format(name, age))
print(help(object))
",O(n ^ 3)
"class Solution(object):
    def numberOfMatches(self, n):
        return n-1",O(1)
"from collections import Counter

n,k=list(map(int,input().split()))
x=list(map(int,input().split()))

dd=Counter()
for i in range(k):

    dd[x[i]]=dd[x[i]]+1

final=0
for i in range(1,k+1):
    ans=0
    d=dd.copy()
    for j in range(n):
        for jj in d:
            if d[jj]>=i:
                d[jj]-=i
                ans=ans+1
                break
    if ans>=n:
        final=i
    else:
        break
print(final)",O(nlogn)
"class Solution2(object):
    def clearDigits(self, s):
        result = []
        for x in s:
            if x.isdigit():
                result.pop()
                continue
            result.append(x)
        return """".join(result)",O(n)
"n = int(input())
a = [int(i) for i in input().split()]

d = {}
power = [2**i for i in range(31)]
ans = []
for i in a:
    d[i] = 0

for num in d.keys():
    for p in power:
        if num+p in d:
            ans = [num, num+p]
            if num+p+p in d:
                print(3)
                ans.append(num+p+p)
                print(*ans)
                exit()
if ans:
    print(2)
    print(*ans)
else:
    print(1)
    print(a[0])
",O(nlogn)
"from math import *

n,k = map(int,input().split())
ans = [0] * n

lul = 2**k - 1
A = list(map(int,input().split()))
ans[0]  = A[0]
for j in range(1, n):
    ans[j] = ans[j-1]^A[j]

d = dict()
for j in range(n):
    if ans[j] in d:
        d[ans[j]]+=1;
    else:
        d[ans[j]] = 1

ans =0
def huy(n):
    return n*(n-1)//2
for j in d:
    now = d[j]

    xor = lul^j
    cur = now

    if xor in d :

        now2 = d[xor]

        cur += now2

        ans += huy(cur//2+cur%2)
        ans+=huy(cur//2)
        if j ==0:
            ans+=2*(cur//2)
    else:
        if(j==0 or xor ==0):
            ans+= 2*(cur//2)
        ans += 2*huy(cur // 2 + cur % 2)
        ans += 2*huy(cur // 2)
print(huy(n+1) - ans//2)",O(n)
"from sys import stdin, stdout
from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial

def get(l, r):
    if l > r:
        return 0

    if l & 1:
        return (-l - r) * (r - l + 2) // 4
    else:
        return (l + r) * (r - l + 2) // 4

def solution(l, r):
    l1, l2, r1, r2 = l, l, r, r

    if l & 1:
        l2 += 1
    else:
        l1 += 1

    if r & 1:
        r2 -= 1
    else:
        r1 -= 1

    return get(l1, r1) + get(l2, r2)

q = int(stdin.readline())
for i in range(q):
    l, r = map(int, stdin.readline().split())
    stdout.write(str(solution(l, r)) + '\n')",O(1)
"n, m = list(map(int, input().split()))
cl = []
for i in range(n):
  cl.append(input())

def is_squad(x, y):
  if cl[x][y]=='
    return True
  else:
    return False

def cv(x, y):
  counter = 0
  if x-2>=0 and y+2<=m-1 and is_squad(x-2, y):
    return True

  elif x-1>=0 and x+1<=n-1 and y+2<=m-1 and is_squad(x-1, y):
    return True

  elif x+2<=n-1 and y+2<=m-1 and is_squad(x, y):
    return True

  elif x+2<=n-1 and y+1<=m-1 and y-1>=0 and is_squad(x, y-1):
    return True

  elif x+2<=n-1 and y-2>=0 and is_squad(x, y-2):
    return True

  elif x+1<=n-1 and x-1>=0 and y-2>=0 and is_squad(x-1, y-2):
    return True

  elif x-2>=0 and y-2>=0 and is_squad(x-2, y-2):
    return True

  elif x-2>=0 and y-1>=0 and y+1<=m-1 and is_squad(x-2, y-1):
    return True
  else:
    return False

for i in range(n):
  for j in range(m):
    if cl[i][j]=='
      if not cv(i, j):
        print('NO')
        exit()

print('YES')",O(n ^ 2)
"t=int(input())
for _ in range(t):
	n,k=list(map(int,input().split()))
	if n>=32:
		print(""YES ""+str(n-1))
	else:
		ans=-1
		for i in range(1,n+1):
			p=(4**i)-(2**(i+1))+1
			p*=(((4**(n-i))-1)//3)
			g=(((4**i)-1)//3)
			p+=(((4**i)-1)//3)
			g=(((4**i)-1)//3)-(((4**(i-1))-1)//3)
			if g<=k and p>=k:
				ans=n-i
				break
		if ans!=-1:
			print(""YES ""+str(ans))
		else:
			print(""NO"")",O(logn)
"class Solution(object):
    def findThePrefixCommonArray(self, A, B):
        result = [0]*len(A)
        cnt = collections.Counter()
        curr = 0
        for i, (a, b) in enumerate(zip(A, B)):
            cnt[a] += 1
            if cnt[a] == 2:
                curr += 1
            cnt[b] += 1
            if cnt[b] == 2:
                curr += 1
            result[i] = curr
        return result",O(n)
"import sys

def query(c, d):
    print('? %d %d' % (c, d))
    sys.stdout.flush()
    res = int(input())
    return res

a = 0
b = 0
big = query(0, 0)

for i in range(29, -1, -1):
    p = query(a ^ (1 << i), b)
    q = query(a, b ^ (1 << i))
    if p == q:
        if big == 1:
            a ^= 1 << i
        else:
            b ^= 1 << i
        big = p
    elif p == -1:
        a ^= 1 << i
        b ^= 1 << i

print('! %d %d' % (a, b))
sys.stdout.flush()
",O(logn)
"a = input().split()
st = set([])
cnt = [[0 for i in range(9)] for i in range(3)]
for e in a:
    cnt['mps'.index(e[1])][int(e[0]) - 1] = 1
    st.add(e)
answ = len(st) - 1
for i in range(3):
    for j in range(7):
        answ = min(answ, 3 - sum(cnt[i][j:j + 3]))
print(answ)",O(n)
"import collections



class Solution(object):
    def minimumKeypresses(self, s):
        return sum(cnt*(i//9+1) for i, cnt in enumerate(sorted(iter(collections.Counter(s).values()), reverse=True)))",O(n)
"from math import *
from cmath import *
from itertools import *
from decimal import *
from fractions import *
from sys import *
from types import CodeType, new_class

n, m = map(int, (input().split()))
a = [int(x) for x in input().split()]
b = [int(x) for x in input().split()]
for x in a:
    if x in b:
        print(x, end = ' ')",O(n ^ 2)
"n = int(input())
lis = list(map(int, input(). split()))
sor = sorted(lis)
cnt = 0
for i in range(n):
    if lis[i] != sor[i]:
        cnt += 1
if cnt > 2:
    print(""NO"")
else:
    print(""YES"")",O(nlogn)
"class Solution(object):
    def reverseParentheses(self, s):
        stk, lookup = [], {}
        for i, c in enumerate(s):
            if c == '(':
                stk.append(i)
            elif c == ')':
                j = stk.pop()
                lookup[i], lookup[j] = j, i
        result = []
        i, d = 0, 1
        while i < len(s):
            if i in lookup:
                i = lookup[i]
                d *= -1
            else:
                result.append(s[i])
            i += d
        return """".join(result)",O(n)
"def isPoss(n, arrs, nvals):
    masks = set()
    midx = {}
    for pos,arr in enumerate(arrs):
        mask = 0
        for i in range(nvals):
            if arr[i]>=n:
                mask += 1<<i
        midx[mask] = pos+1
        masks.add(mask)

    for m1 in masks:
        for m2 in masks:
            if m1|m2 == (1<<nvals)-1:
                return midx[m1], midx[m2]

    return -1, -1

narr, nvals = map(int, input().split())

arrs = []
for i in range(narr):
    arrs.append(list(map(int, input().split())))

mn = -1
mx = 10**9+1
while mn < mx-1:
    mid = (mn + mx) // 2
    a,b = isPoss(mid, arrs, nvals)
    if a != -1:
        mn = mid
    else:
        mx = mid - 1

for i in range(1,-1,-1):
    a,b = isPoss(mn+i, arrs, nvals)
    if a != -1:
        print(a,b)
        break
",np
"def is_prime(num):
    if num > 1:
        for i in range(2, num):
            if (num % i) == 0:
               return  False
        else:
            return True
    else:
        return False

n = int(input())
temp = 0
first = 0
second = 0
if n % 2 == 0:
    temp = int(n/2)
    first = temp
    second = n - temp
    while is_prime(first) or is_prime(second):
        first -= 1
        second += 1
        if first + second == n and (not is_prime(first) and not is_prime(second)):
            break
else:
    temp = int(n / 2)
    first = temp
    second = n - first
    while is_prime(first) or is_prime(second):
        first -= 1
        second += 1
        if first + second == n and (not is_prime(first) and not is_prime(second)):
            break
print(first,end="" "")
print(second)",O(1)
"class Solution(object):
    def checkIfPrerequisite(self, n, prerequisites, queries):
        def floydWarshall(n, graph): 
            reachable = set([x[0]*n+x[1] for x in graph]) 
            for k in range(n): 
                for i in range(n): 
                    for j in range(n): 
                        if i*n+j not in reachable and (i*n+k in reachable and k*n+j in reachable):
                            reachable.add(i*n+j)
            return reachable

        reachable = floydWarshall(n, prerequisites)
        return [i*n+j in reachable for i, j in queries]",O(n ^ 3)
"
import collections



class Solution(object):
    def maxFrequencyElements(self, nums):
        cnt = collections.Counter(nums)
        mx = max(cnt.values())
        return sum(v for v in cnt.values() if v == mx)
",O(n)
"cnt = [0]*2
class Solution2(object):
    def countKReducibleNumbers(self, s, k):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]  
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def popcount(x):
            return bin(x).count('1')
      
        while len(s)-1 >= len(cnt): 
            cnt.append(cnt[popcount(len(cnt))]+1)
        result = curr = 0
        for i in range(len(s)):
            if s[i] != '1':
                continue
            for c in range((len(s)-(i+1))+1):
                if cnt[curr+c] < k:
                    result = (result+nCr(len(s)-(i+1), c))%MOD
            curr += 1
        return (result-1)%MOD",O(n ^ 2)
"class Solution(object):
    def flipLights(self, n, m):
        if m == 0:
            return 1
        if n == 1:
            return 2
        if m == 1 and n == 2:
            return 3
        if m == 1 or n == 2:
            return 4
        if m == 2:
            return 7
        return 8",O(1)
"import random



class Solution(object):
    def outerTrees(self, trees):
        def dist(a, b):
            return ((a[0]-b[0])**2 + (a[1]-b[1])**2)**0.5

        def inside(c, p):
            return dist(c[0], p) < c[1]+EPS

        def circle_center(bx, by, cx, cy):
            B = bx*bx + by*by
            C = cx*cx + cy*cy
            D = bx*cy - by*cx
            return [float(cy*B - by*C)/(2*D),
                    float(bx*C - cx*B)/(2*D)]

        def circle_from_2_points(A, B):
            C = [(A[0]+B[0])/2.0, (A[1]+B[1])/2.0]
            return [C, dist(A, B)/2.0]

        def circle_from_3_points(A, B, C):
            I = circle_center(B[0]-A[0], B[1]-A[1],
                              C[0]-A[0], C[1]-A[1])
            I[0] += A[0]
            I[1] += A[1]
            return [I, dist(I, A)]

        def trivial(boundaries): 
            if not boundaries:
                return None
            if len(boundaries) == 1:
                return [boundaries[0], 0.0]
            if len(boundaries) == 2:
                return circle_from_2_points(boundaries[0], boundaries[1])
            return circle_from_3_points(boundaries[0], boundaries[1], boundaries[2])

        def Welzl(points, boundaries, curr):
            if curr == len(points) or len(boundaries) == 3:
                return trivial(boundaries)
            result = Welzl(points, boundaries, curr+1)
            if result is not None and inside(result, points[curr]):
                return result
            boundaries.append(points[curr])
            result = Welzl(points, boundaries, curr+1)
            boundaries.pop()
            return result

        EPS = 1e-5
        random.seed(0)
        random.shuffle(trees)
        result = Welzl(trees, [], 0)
        return result[0][0], result[0][1], result[1]",O(n)
"class Solution(object):
    def smallestBeautifulString(self, s, k):
        def check(i):
            return (i-1 < 0 or arr[i-1] != arr[i]) and (i-2 < 0 or arr[i-2] != arr[i])

        arr = [ord(x)-ord('a') for x in s]
        for i in reversed(range(len(arr))):
            arr[i] += 1
            while not check(i):
                arr[i] += 1
            if arr[i] < k:
                break
        else:
            return """"
        for j in range(i+1, len(arr)):
            arr[j] = 0
            while not check(j):
                arr[j] += 1
        return """".join([chr(ord('a')+x) for x in arr])",O(n)
"from sys import stdin, stdout
import heapq
from collections import defaultdict
import math
import bisect

def main():
    n,m,k = list(map(int, stdin.readline().split()))
    right = []
    for _ in range(n):
        right.append(list(map(int, stdin.readline().split())))
    down = []
    for _ in range(n-1):
        down.append(list(map(int, stdin.readline().split())))
    if k % 2 == 1:
        for _ in range(n):
            stdout.write("" "".join([""-1"" for _ in range(m)])+""\n"")
        return
    dp = [[0 for _ in range(m)] for _ in range(n)]
    for x in range(1, (k//2) + 1):
        tmp = [[math.inf for _ in range(m)] for _ in range(n)]
        for i in range(n):
            for j in range(m):
                if i:
                    tmp[i][j] = min(tmp[i][j], dp[i-1][j] + 2 * down[i-1][j])
                if i < n-1:
                    tmp[i][j] = min(tmp[i][j], dp[i + 1][j] + 2 * down[i][j])
                if j:
                    tmp[i][j] = min(tmp[i][j], dp[i][j - 1] + 2 * right[i][j - 1])
                if j < m-1:
                    tmp[i][j] = min(tmp[i][j], dp[i][j + 1] + 2 * right[i][j])
        dp = tmp

    for i in range(n):
        stdout.write("" "".join([str(x) for x in dp[i]]) + ""\n"")

main()",O(n ^ 3)
"
import collections


class Solution(object):
    def canBeEqual(self, target, arr):
        return collections.Counter(target) == collections.Counter(arr)


",O(n)
"import math;
def getIntList():
    return list(map(int, input().split()));
def getTransIntList(n):
    first=getIntList();
    m=len(first);
    result=[[0]*n for _ in range(m)];
    for i in range(m):
        result[i][0]=first[i];
    for j in range(1, n):
        curr=getIntList();
        for i in range(m):
            result[i][j]=curr[i];
    return result;
n, a, b = getIntList();
if a>1 and b>1:
    print('NO');
elif a==b==1 and (n==2 or n==3):
    print('NO');
else:
    c=max(a, b);
    m=[[0]*n for _ in range(n)];
    for i in range(n-c):
        m[i][i+1]=1;
        m[i+1][i]=1;
    if b>1:
        for i in range(n):
            for j in range(n):
                if i!=j:
                    m[i][j]=1-m[i][j];
    print('YES');
    for i in range(n):
        print(''.join(map(str, m[i])));",O(n ^ 2)
"class Solution(object):
    def findMinArrowShots(self, points):
        if not points:
            return 0

        points.sort()

        result = 0
        i = 0
        while i < len(points):
            j = i + 1
            right_bound = points[i][1]
            while j < len(points) and points[j][0] <= right_bound:
                right_bound = min(right_bound, points[j][1])
                j += 1
            result += 1
            i = j
        return result",O(nlogn)
"M = 10 ** 9 + 7
x, k = map(int, input().split())
if x == 0: print(0); exit(0)
P = pow(2, k, M)
r = (P * x) % M - (0.5 * (-1 + P)) % M
print(int((2 * r + M) % M))
",O(logn)
"c = [[0 for i in range(5205)] for j in range(5205)]
K = 998244353
inv = [0 for i in range(5205)]

def mu(a, n):
	if n == 0: return 1
	q = mu(a, n // 2)
	if n % 2 == 0:
		return q * q % K
	else: return q * q % K * a % K

def calc(m, d, S):
	res = 0
	if m == 0:
		if S == 0: return 1
		return 0

	for u in range(0, m + 1):
		if (u * d > S): break
		U = c[m][u] * c[S - u * d + m - 1][m - 1] % K
		if u % 2 == 0:
			res = (res + U) % K
		else: res = (res - U + K) % K
	return res

c[0][0] = 1
inv[0] = 1
for i in range(1, 5101):
	inv[i] = mu(i, K - 2)

for i in range(1, 5101):
	c[i][0] = 1
	for j in range (1, i):
		c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % K
	c[i][i] = 1

p, s, r = map(int, input().split())

res = 0
den = 0

for i in range(1, p + 1):
	A = 0
	for d in range(r, s // i + 1):
		if (i < p): A = (A + calc(p - i, d, s - d * i)) % K
		else:
			if (s - i * d == 0): A += 1
	A = A * inv[i] % K
	res = (res + A * c[p - 1][i - 1] % K) % K

den = c[s - r + p - 1][p - 1]
res = res * mu(den, K - 2) % K
print(res)
",O(n ^ 3)
"from sys import stdin,stdout
input=stdin.readline

def count(audrey,imba,banget):
    return((imba-audrey-1)%(banget-1))

n,q=map(int,input().split())
L=list(map(int,input().split()))
maxi=max(L)
indexmax=L.index(maxi)
P=[]
for i in range(indexmax):
    P.append((L[0],L[1]))
    if L[0]<L[1]:
        L.append(L.pop(0))
    else:
        L.append(L.pop(1))
Y=tuple(L[1:])
for p in range(q):
    m=int(input())
    if m<=indexmax:
        print(str(P[m-1][0])+' '+str(P[m-1][1]))
    else:
        stdout.write(str(maxi)+' '+str(Y[count(indexmax,m,n)])+'\n')",O(n)
"def sfy(n):
    if n == 1: return [1]
    elif n == 2: return [1, 2]
    elif n == 3: return [1, 1, 3]
    else:
        if n % 2 == 0: return [1]*(n//2) + [2*x for x in sfy(n//2)]
        else:
            return [1]*(1 + n//2) + [2*x for x in sfy(n//2)]
print("" "".join([str(x) for x in sfy(int(input()))]))
",O(nlogn)
"class Solution(object):
    def largestRectangleArea(self, heights):
        stk, result = [-1], 0
        for i in range(len(heights)+1):
            while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):
                result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))
            stk.append(i) 
        return result",O(n)
"rank = 1
n = int(input())
score = sum(map(int,input().split()))
for i in range(n-1):
    student = sum(map(int,input().split()))
    if(student > score):
        rank += 1
print(rank)",O(n)
"n = int(input())
c = [0] + [int(j) for j in input().split()]
a = [0] + [int(j) for j in input().split()]
vis = [0] * (n + 1)
ans = 0
for i in range(1, n + 1):
    x = i
    while vis[x] == 0:
        vis[x] = i
        x = a[x]
    if vis[x] != i:
        continue
    v = x
    mn = c[x]
    while a[x] != v:
        x = a[x]
        mn = min(mn, c[x])
    ans += mn
print(ans)
",O(n)
"x1, y1, x2, y2, x3, y3, x4, y4 = map(int, input().split())
X1, Y1, X2, Y2, X3, Y3, X4, Y4 = map(int, input().split())

x = [x1, x2, x3, x4]
y = [y1, y2, y3, y4]
x = list(set(x))
y = list(set(y))
x.sort()
y.sort()
xl, xr = x
yl, yr = y

if xl <= X1 <= xr and yl  <= Y1 <= yr:
    print('YES')
    exit()
if xl <= X2 <= xr and yl  <= Y2 <= yr:
    print('YES')
    exit()
if xl <= X3 <= xr and yl  <= Y3 <= yr:
    print('YES')
    exit()
if xl <= X4 <= xr and yl  <= Y4 <= yr:
    print('YES')
    exit()

CX, CY = (X1+X2+X3+X4)//4,  (Y1+Y2+Y3+Y4)//4
X1, X2, X3, X4 = X1-CX, X2-CX, X3-CX, X4-CX
Y1, Y2, Y3, Y4 = Y1-CY, Y2-CY, Y3-CY, Y4-CY

if xl <= CX <= xr and yl  <= CY <= yr:
    print('YES')
    exit()

A = 0
for X in (X1, X2, X3, X4):
    A = max(A, abs(X))
if abs(x1-CX)+abs(y1-CY) <= A:
    print('YES')
    exit()
if abs(x2-CX)+abs(y2-CY) <= A:
    print('YES')
    exit()
if abs(x3-CX)+abs(y3-CY) <= A:
    print('YES')
    exit()
if abs(x4-CX)+abs(y4-CY) <= A:
    print('YES')
    exit()
print('NO')
",O(1)
"from math import gcd
def t_prime(n):
    if n == 1:        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:            return False
    return True
primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))
if k == 1: print(0);exit()
for i in range(n):
    for j in range(i):
        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)
powers = set();count = 0;outLs = [];pgood = []
for p in primes:
    curr = [];    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:            v2 //= p
        if v2 == 1:   curr.append(v);   powers.add(v)
    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)
order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])
if len(order) == 0:    print(0); exit()
if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1;    need = -1;    last = []
    for v in l:
        if v in powers:            continue
        v2 = v;        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):  extra = v;     last = primesn;    need = len(last);   assert need >= 2
    if need == -1 or 2 * need + 1 > k:  print(0);   exit()
    other = [];    out = [extra]
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:   works = True;           break
        if works:       out.append(a);   out.append(b)
        else:       other.append(a);      other.append(b)
    assert len(out) == 2 * need + 1;    assert (k - 2 * need - 1) % 2 == 0; ret = out + other[:(k - 2*need - 1)];    assert len(ret) == k; print(' '.join(map(str,ret)));    exit()
out = [];need = k
for i in range(len(order)):
    assert need != 1

    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0

assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",np
"n=int(raw_input())

l=list(map(int,raw_input().split()))

index = []
ans=[]
for i in range(n):
	index.append(i+1)
	ans.append(0)

l1,index1 = zip(*sorted(zip(l, index),reverse=True))

for i in range(n):

	k=1
	flag=False
	while (index1[i]-k*l1[i])>0:
		if l[index1[i]-k*l1[i]-1]>l[index1[i]-1]:
			if ans[index1[i]-k*l1[i]-1]==""B"":
				ans[index1[i]-1]=""A""
				flag=True
				break
		k+=1

	k=1
	if flag==False:
		while (index1[i]+k*l1[i])<=n:
			if l[index1[i]+k*l1[i]-1]>l[index1[i]-1]:
				if ans[index1[i]+k*l1[i]-1]==""B"":
					ans[index1[i]-1]=""A""
					flag=True
					break
			k+=1

	if flag==False:
		ans[index1[i]-1]=""B""

print(''.join(ans))
",O(nlogn)
"class Solution2(object):
    def appealSum(self, s):
        result = cnt = 0
        lookup = [-1]*26
        for i, c in enumerate(s):
            cnt += i-lookup[ord(c)-ord('a')]
            lookup[ord(c)-ord('a')] = i
            result += cnt
        return result",O(n)
"class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        stones.sort()
        n = len(stones)

        while n > 1:
            cur = stones.pop() - stones.pop()
            n -= 2
            if cur > 0:
                l, r = 0, n
                while l < r:
                    mid = (l + r) // 2
                    if stones[mid] < cur:
                        l = mid + 1
                    else:
                        r = mid
                pos = l
                n += 1
                stones.append(0)
                for i in range(n - 1, pos, -1):
                    stones[i] = stones[i - 1]
                stones[pos] = cur

        return stones[0] if n > 0 else 0
",O(n ^ 2)
"import sys
from array import array

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

n = int(input())
prob = [tuple(map(float, input().split())) for _ in range(n)]
full_bit = (1 << n) - 1
dp = [0.0] * full_bit + [1.0]

for bit in range(full_bit, 0, -1):
    popcount = len([1 for i in range(n) if (1 << i) & bit])
    if popcount == 1 or dp[bit] == 0.0:
        continue
    div = 1 / ((popcount * (popcount - 1)) >> 1)

    for i in range(n):
        if ((1 << i) & bit) == 0:
            continue
        for j in range(i + 1, n):
            if ((1 << j) & bit) == 0:
                continue
            dp[bit - (1 << j)] += dp[bit] * prob[i][j] * div
            dp[bit - (1 << i)] += dp[bit] * prob[j][i] * div

print(*(dp[1 << i] for i in range(n)))
",np
"n,l,r,x = map(int,input().split())
A = list(map(int,input().split()))
count = 0
for i in range(1<<n):
    total = 0
    mn = 1e6
    mx = -1e6
    for k in range(n):
        if (i & (1<<k)):
            total += A[k]
            mn = min(A[k],mn)
            mx = max(A[k],mx)
    if total<=r and total>=l and mx-mn>=x:
        count += 1
print(count)",np
"n,k = map(int,input().split())
arr = list(map(int,input().split()))
bs = [[x,i+1] for i,x in enumerate(arr)]
bs.sort(reverse=True)
cs = [bs[i][1] for i in range(k)]
ans = sum(bs[i][0] for i in range(k))
cs.sort()
print(ans)
if k==1:
    print(n)
else:
    print(cs[0],end="" "")

    for i in range(1,k-1):
        print(cs[i]-cs[i-1],end="" "")
    print(n-cs[k-2])
",O(nlogn)
"n, u = map(int, input().split())
e = list(map(int, input().split()))
ans = -1
k = 2
for i in range(n-2):
    while k<n-1 and e[k+1] - e[i] <= u:
        k+=1
    if i < k-1 and e[k] - e[i] <= u:
        ans = max(ans,(e[k]-e[i+1]) / (e[k]-e[i]))
print(ans)",O(nlogn)
"class Solution2(object):
    def climbStairs(self, n):
        prev, current = 0, 1
        for i in range(n):
            prev, current = current, prev + current,
        return current",O(n)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

zz = ( (1,-1), (0,2), (1,-1) )
now = (0,0)
for i in range(N):
    print(now[0],now[1])
    now = ( now[0] + zz[i%3] [0] , now[1] + zz[i%3][1])
",O(n)
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left,bisect
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
n,k=map(int,input().split())
x,y=1,n
f=0
while(x<=y):
    m=(x+y)//2
    s=0
    p=m
    while(p>0):
        s+=p%10
        p=p//10
    m1=m-1
    s1=0
    p=m1
    while(p>0):
        s1+=p%10
        p=p//10
    if m==0 or (m-s>=k and m1-s1<k):
        f=1
        break
    elif m-s<k:
        x=m+1
    else:
        y=m-1
if f:
    print(n-m+1)
else:
    print(0)
",O(logn)
"import sys
import io, os
import math
from heapq import *
gcd = math.gcd
sqrt = math.sqrt
ceil = math.ceil

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
def strinp(testcases):
    k = 5
    if (testcases == -1 or testcases == 1):
        k = 1
    f = str(input())
    f = f[2:len(f) - k]
    return f
def ind(ch):
    return ord(ch)-ord(""a"")
def main():
    n=int(input())
    b=[0]
    cost=b+list(map(int, input().split()))
    arr=b+list(map(int, input().split()))
    nv=[-1]*(n+1)
    colors=[]
    c=0
    for i in range(1,n+1):
        if(nv[i]!=-1):
            continue
        nv[i]=c
        dest=arr[i]
        while(nv[dest]==-1):
            nv[dest]=c
            dest=arr[dest]
        if(nv[dest]==c):
            colors.append(dest)
        c+=1
    s=0
    for i in colors:
        mi=cost[i]
        nxt=arr[i]
        while(nxt!=i):
            mi=min(mi,cost[nxt])
            nxt=arr[nxt]
        s+=mi
    print(s)
main()",O(n)
"def cross(a, b):
    return a[0] * b[1] - a[1] * b[0]

def f(v, i1, i2):
    d = [v[i2][i] - v[i1][i] for i in range(len(v[i1]))]

    res = []
    for x in v:
        d2 = [x[i] - v[i1][i] for i in range(len(v[i1]))]
        if cross(d, d2) != 0:
            res.append(x)

    return res

n = int(input())
if n <= 4:
    print(""YES"")
    exit(0)

v = []
for i in range(n):
    v.append(list(map(int, input().split())))

ok = False
for first in range(3):
    if ok:
        break

    for second in range(first+1, 3):
        other = f(v, first, second)

        if len(other) <= 2:
            ok = True
            break

        remainder = f(other, 0, 1)

        if not remainder:
            ok = True

if ok:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"import math
import random
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict

mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1

class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):

        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n

class SegmentTree1:
    def __init__(self, data, default=300006, func=lambda a, b: min(a , b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b:a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] <=key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEndOfWord = False
class Trie:
    def __init__(self):
        self.root = self.getNode()
    def getNode(self):
        return TrieNode()
    def _charToIndex(self, ch):
        return ord(ch) - ord('a')
    def insert(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                pCrawl.children[index] = self.getNode()
            pCrawl = pCrawl.children[index]
        pCrawl.isEndOfWord = True
    def search(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                return False
            pCrawl = pCrawl.children[index]
        return pCrawl != None and pCrawl.isEndOfWord

class Node:
    def __init__(self, data):
        self.data = data
        self.count=0
        self.left = None
        self.right = None
class BinaryTrie:
    def __init__(self):
        self.root = Node(0)
    def insert(self, pre_xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = pre_xor & (1 << i)
            if val:
                if not self.temp.right:
                    self.temp.right = Node(0)
                self.temp = self.temp.right
                self.temp.count+=1
            if not val:
                if not self.temp.left:
                    self.temp.left = Node(0)
                self.temp = self.temp.left
                self.temp.count += 1
        self.temp.data = pre_xor
    def query(self, xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = xor & (1 << i)
            if not val:
                if self.temp.left and self.temp.left.count>0:
                    self.temp = self.temp.left
                elif self.temp.right:
                    self.temp = self.temp.right
            else:
                if self.temp.right and self.temp.right.count>0:
                    self.temp = self.temp.right
                elif self.temp.left:
                    self.temp = self.temp.left
            self.temp.count-=1
        return xor ^ self.temp.data

n=int(input())
l=list(map(int,input().split()))
fi=[""even"",""odd""]
q=defaultdict(int)
e=[0]*(n+1)
s=SegmentTree(e)
ans=0
for j in range(n):
    ans+=s.query(l[j]+1,n)
    s.__setitem__(l[j],1)
fi1=ans
for i in range(int(input())):
    a,b=map(int,input().split())
    a-=1
    b-=1
    fi1+=((b-a+1)*(b-a))//2
    print(fi[fi1%2])",O(n ^ 2)
"class Solution2(object):
    def buildArray(self, nums):
        return [nums[x] for x in nums]",O(n)
"n = int(input())
a = [int(s) for s in input().split()]
ans = [None]*n

def get(p):

    if ans[p] is not None:
        return ans[p]
    elif a[p] == 1:
        ans[p] = ""A""
    elif a[p] == n:
        ans[p] = ""B""
    else:
        for i in range(p+a[p], n, a[p]):
            if a[i] > a[p]:
                if get(i) == ""B"":
                    ans[p] = ""A""
                    return ans[p]
        for i in range(p-a[p], -1, -a[p]):
            if a[i] > a[p]:
                if get(i) == ""B"":
                    ans[p] = ""A""
                    return ans[p]
        ans[p] = ""B""
    return ans[p]

if n == 1:
    print(""B"")
else:
    for i in range(n-1, -1, -1):
        get(i)
    print(''.join(ans))",O(n)
"import operator
from functools import reduce


class Solution2(object):
    def xorOperation(self, n, start):
        return reduce(operator.xor, (i for i in range(start, start+2*n, 2)))",O(n)
"class Solution(object):
    def averageOfLevels(self, root):
        result = []
        q = [root]
        while q:
            total, count = 0, 0
            next_q = []
            for n in q:
                total += n.val
                count += 1
                if n.left:
                    next_q.append(n.left)
                if n.right:
                    next_q.append(n.right)
            q = next_q
            result.append(float(total) / count)
        return result",O(n)
"from math import ceil, sqrt

t = 1
for test in range(1,t+1):
    n,m = (map(int, input().split()))
    arr = [[""."" for i in range(m)] for i in range(n)]
    arr2 = []
    for i in range(n):
        arr2.append(list(input()))
    for i in range(1,n-1):
        for j in range(1,m-1):
            if arr2[i+1][j] == arr2[i][j+1]==arr2[i+1][j+1]==arr2[i-1][j]==arr2[i][j-1]==arr2[i-1][j-1]==arr2[i+1][j-1]==arr2[i-1][j+1]==""
                arr[i+1][j] = arr[i][j+1]=arr[i+1][j+1]=arr[i-1][j]=arr[i][j-1]=arr[i-1][j-1]=arr[i+1][j-1]=arr[i-1][j+1]=""

    if arr == arr2:
        print(""YES"")
    else:
        print(""NO"")
",O(n ^ 2)
"for _ in range(int(input())):
    n,m=map(int,input().split())

    a=[[int(x) for x in input().split()] for j in range(n)]

    x=[[a[i][j] for i in range(n)] for j  in range(m)]
    x.sort(key=lambda xx:-max(xx))
    dp=[[0 for i in range(1<<n)] for j in range(m+1)]
    an=0

    for i in range(m):
        for prev in range(1<<n):
            for pres in range(1<<n):

                for j in range(n):

                    ma=0
                    if prev^pres!=prev+pres:
                        continue
                    for st in range(n):

                        if pres&(1<<st):
                            ma+=x[i][(st+j)%n]

                    dp[i+1][pres^prev]=max(dp[i+1][pres^prev],dp[i][prev]+ma)

    print(dp[m][(1<<n)-1])",np
"import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

L, R = map(int, input().split())

for i in range(64, -1, -1):
    if L & (1 << i) != R & (1 << i):
        print((1 << (i+1)) - 1)
        exit(0)
print(0)",O(logn)
"n = int(input())

dp = [0] * 1000007

majak = [0] * 1000007

q = 1000007

p = 0

for i in range(n):

    a, b = map(int, input().split())

    q = min(q, a)

    majak[a] = b

dp[q] = 1

ma = 1

for i in range(q + 1, 1000003, 1):

    if(majak[i] == 0):

        dp[i] = dp[i - 1]

    else:

        dp[i] = dp[i - majak[i] - 1] + 1

        ma = max(ma, dp[i])

print(n - ma)
",O(n)
"import itertools

kol1 = {'+': 0, '-': 0, '?': 0}
kol2 = {'+': 0, '-': 0, '?': 0}

s1 = input()
s2 = input()

for s in s1:
    kol1[s] += 1

for s in s2:
    kol2[s] += 1

if (kol1['+']==kol2['+'] and kol1['-']==kol2['-']):
    print('1.0')
    exit()

mod1 = kol1['+'] - kol1['-']
mod2 = kol2['+'] - kol2['-']
mod3 = abs(mod2-mod1)
if (mod3>kol2['?']):
    print(0.0)
    exit()

list_comb = [1, -1]
sum_pos = 0
col = 0

for comb in itertools.product(list_comb, repeat=kol2['?']):
    if sum(comb)==mod3:
        sum_pos += 1
    col+=1

print(sum_pos/col)",np
"R,G,B = list(map(int, input().split()))
r = sorted(list(map(int, input().split())), reverse =True)
g = sorted(list(map(int, input().split())), reverse =True)
b = sorted(list(map(int, input().split())), reverse =True)
def f(x,y,z):
    m1 = 0
    m2 = 0
    m3 = 0
    if(x<R and y<G):
        if(dpt[x+1][y+1][z]==-1):
            dpt[x+1][y+1][z] = f(x+1,y+1,z)
        m1 = r[x]*g[y] + dpt[x+1][y+1][z]
    if(y<G and z<B):
        if(dpt[x][y+1][z+1]==-1):
            dpt[x][y+1][z+1] = f(x,y+1,z+1)
        m2 = g[y]*b[z] + dpt[x][y+1][z+1]
    if(z<B and x<R):
        if(dpt[x+1][y][z+1]==-1):
            dpt[x+1][y][z+1] = f(x+1,y,z+1)
        m3 = r[x]*b[z] + dpt[x+1][y][z+1]
    dpt[x][y][z] = max(m1,m2,m3)
    return dpt[x][y][z]
dpt = [[[-1 for _ in range(B+1)]for _ in range(G+1)]for _ in range(R+1)]
print(f(0,0,0))",O(n ^ 3)
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp=[[[-1]*(B+1) for i in range(G+1)] for j in range(R+1)]
def calc(nr,ng,nb):
  if dp[nr][ng][nb]!=-1:
    return dp[nr][ng][nb]
  res=0
  if nr<R and ng<G:
    res=max(res,calc(nr+1,ng+1,nb)+r[nr]*g[ng])
  if nr<R and nb<B:
    res=max(res,calc(nr+1,ng,nb+1)+r[nr]*b[nb])
  if ng<G and nb<B:
    res=max(res,calc(nr,ng+1,nb+1)+g[ng]*b[nb])
  dp[nr][ng][nb]=res
  return res
print(calc(0,0,0))",O(n ^ 3)
"from sys import stdin, stdout, maxsize
from math import inf

R = lambda : stdin.readline().strip()
RL = lambda f=None: list(map(f, R().split(' '))) if f else list(R().split(' '))

output = lambda x: stdout.write(str(x) + '\n')
output_list = lambda x: output(' '.join(map(str, x)))

n, m, K = RL(int)

if K%2:
    for i in range(n):
        print( *(m*[-1]) )
    exit()

hor = [ RL(int) +[inf] for i in range(n) ]
vert = [ RL(int) for i in range(n-1) ] + [ m*[inf] ]

K = K//2
dp = [ [m*[inf] for i in range(n)] for j in range(0, K+1)]

dp[0] = [m*[0] for i in range(n)]

def valid(i, j):
    if -1 < i < n and  -1 < j < m:
        return True
    return False

for k in range(1, K+1):
    for i in range(n):
        for j in range(m):
            if valid(i, j+1):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j+1] + 2*hor[i][j])
            if valid(i+1, j):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i+1][j] + 2*vert[i][j])
            if valid(i-1, j):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i-1][j] + 2*vert[i-1][j])
            if valid(i, j-1):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j-1] + 2*hor[i][j-1])

for i in dp[-1]:
    print(*i)
",O(n ^ 3)
"class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children


class Solution(object):

    def serialize(self, root):
        def dfs(node, vals):
            if not node:
                return
            vals.append(str(node.val))
            for child in node.children:
                dfs(child, vals)
            vals.append(
        
        vals = []
        dfs(root, vals)
        return "" "".join(vals)


    def deserialize(self, data):
        def isplit(source, sep):
            sepsize = len(sep)
            start = 0
            while True:
                idx = source.find(sep, start)
                if idx == -1:
                    yield source[start:]
                    return
                yield source[start:idx]
                start = idx + sepsize
                
        def dfs(vals):
            val = next(vals)
            if val == 
                return None
            root = Node(int(val), [])
            child = dfs(vals)
            while child:
                root.children.append(child)
                child = dfs(vals)
            return root

        if not data:
            return None
    
        return dfs(iter(isplit(data, ' ')))",O(n)
"n=int(input())
l1=list(map(int,input().split()))
ans=0
l1.sort()
visited=[0]*n
for i in range(n):
    if visited[i]==1:
        continue
    visited[i]=1
    ans+=1
    for j in range(i+1,n):
        if visited[j]==0 and l1[j]%l1[i]==0:
            visited[j]=1
print(ans)",O(n ^ 2)
"a = int(input())
lister = input().split()
lister = [int(i) for i in lister]

ans = dict()

def findans(n):
	if n in ans:
		return ans[n]
	mod = n%lister[n]
	ok = True
	if n + lister[n] >= a and n - lister[n] < 0:
		ok = False
	else:
		for i in range(mod, a, lister[n]):
			if i != n and lister[i] > lister[n]:
				ok = ok and findans(i)

		ok = not(ok)

	ans[n] = ok
	return ok

for i in range(len(lister)):
	findans(i)

level = []
for i in range(a):
	if ans[i] == True:
		level.append('A')
	else:
		level.append('B')

print(''.join(level))",O(n ^ 2)
"import sys
class Graph:
    verticies = {}
    nodesCount = 0

    class Vertex:
        def __init__(self, label, endPoint=None):
            self.label = label
            self.edges = []
            self.visitedToken = 0
            self.endPoint = endPoint

    class Edge:
        residual = None

        def __init__(self, from_, to_, isResidual, maxCapacity):
            self.from_ = from_
            self.to_ = to_
            self.isResidual = isResidual
            self.capacity = maxCapacity
            self.flow = 0

        def augment(self, bootleneck):
            self.flow += bootleneck
            self.residual.flow -= bootleneck

        def remainingCapacity(self):
            return self.capacity - self.flow

    def addEdge(self, from_, to_, capacity):
        from_ = self.verticies[from_]
        to_ = self.verticies[to_]
        if from_.endPoint and from_.endPoint != to_:
            from_ = from_.endPoint

        main = self.Edge(from_, to_, False, capacity)
        residual = self.Edge(to_, from_, True, 0)

        main.residual = residual
        residual.residual = main

        from_.edges.append(main)
        to_.edges.append(residual)

    def addVertex(self, label, *args):
        self.nodesCount += 1
        self.verticies[label] = self.Vertex(label)

    def maxFlow(self, f, t):
        f = self.verticies[f]
        t = self.verticies[t]
        visitedToken = 1
        flow = 0

        def dfs(node, bootleneck=sys.maxsize):
            node.visitedToken = visitedToken
            bootleneck_backup = bootleneck

            if node == t:
                return bootleneck

            for edge in node.edges:
                if edge.remainingCapacity() == 0 or edge.to_.visitedToken == visitedToken:
                    continue

                bootleneck = dfs(edge.to_, min(
                    bootleneck, edge.remainingCapacity()))
                if bootleneck:
                    edge.augment(bootleneck)
                    return bootleneck
                else:
                    bootleneck = bootleneck_backup

            return 0

        while True:
            bootleneck = dfs(f)

            if not bootleneck:
                break

            flow += bootleneck
            visitedToken += 1

        return flow

g = Graph()

n, m = map(int, input().split())
vv = list(map(int, input().split()))

for i in range(n+m+2):
    g.addVertex(i)

for i, v in enumerate(vv):
    g.addEdge(m+i+1, n+m+1, v)

s = 0

for i in range(1, m+1):
    a, b, c = map(int, input().split())
    s += c

    g.addEdge(0, i, c)
    g.addEdge(i, a+m, c)
    g.addEdge(i, b+m, c)

print(s-g.maxFlow(0, n+m+1))
",O(n ^ 3)
"import sys

n, m, k = map(int, input().split())

hor = [list(map(int, input().split())) for _ in range(n)]

ver = [list(map(int, input().split())) for _ in range(n-1)]

if k % 2:
    for i in range(n):
        print(*([-1]*m))
    sys.exit()

k = k // 2
dp = [[[0]*m for _ in range(n)] for _ in range(k+1)]

for x in range(1, k+1):
    for y in range(n):
        for z in range(m):
            hold = float('inf')
            if y != 0:
                hold = min(hold, dp[x-1][y-1][z] + ver[y-1][z] )
            if y != n-1:
                hold = min(hold, dp[x-1][y+1][z] + ver[y][z] )
            if z != 0:
                hold = min(hold, dp[x-1][y][z-1] + hor[y][z-1] )
            if z != m-1:
                hold = min(hold, dp[x-1][y][z+1] + hor[y][z] )
            dp[x][y][z] = hold

for row in dp[k]:
    print(*map(lambda i: i*2, row))
",O(n ^ 3)
"import sys
input = sys.stdin.buffer.readline

def process(A):
    d = {}
    final = set([])
    for x in A:
        if x not in d:
            d[x] = 0
        d[x]+=1
        if d[x] >= 4:
            return [x, x, x, x]
        if d[x] >= 2:
            final.add(x)
    L = sorted(final)
    answer = [float('inf'), None, None]
    for i in range(len(L)-1):
        a = L[i]
        b = L[i+1]
        a1 = a/b+b/a
        answer = min(answer, [a1, a, b])
    a1, a, b = answer
    return [a, a, b, b]

t = int(input())
for i in range(t):
    n = int(input())
    A = [int(x) for x in input().split()]
    a, b, c, d = process(A)
    print(f'{a} {b} {c} {d}')",O(nlogn)
"n,m,k=map(int,input().split())

MOD=1000000009

x=m-(n//k*(k-1)+(n%k))

if (x<=0):exit(print(m%MOD))

print(((m-x)+((pow(2,x+1, MOD)+2*MOD)-2)*k-x*(k-1))%MOD)",O(logn)
"class Solution(object):
    def maxNumberOfApples(self, arr):
        LIMIT = 5000
        arr.sort()
        result, total = 0, 0
        for x in arr:
            if total+x > LIMIT:
                break
            total += x
            result += 1
        return result",O(nlogn)
"n = int(input())

if(n>=0):
    print(n)
    exit()
else:
    n=str(abs(n))
    n1=int(n[:len(n)-1])

    temp=n[len(n)-1]

    n2=n[:len(n)-2]

    n2=int(n2+temp)

if(n1<=n2):
    if(n1!=0):
        print('-'+str(n1))
    else:
        print(0)
else:
    if(n2!=0):
        print('-'+str(n2))
    else:
        print(0)",O(1)
"class Solution(object):
    def isPossible(self, n, edges):
        adj = [set() for _ in range(n)]
        for u, v in edges:
            adj[u-1].add(v-1)
            adj[v-1].add(u-1)
        odds = [u for u in range(n) if len(adj[u])%2]
        if len(odds) == 0:
            return True
        if len(odds) == 2:
            return any(odds[0] not in adj[u] and odds[1] not in adj[u] for u in range(n))
        if len(odds) == 4:
            return ((odds[0] not in adj[odds[1]] and odds[2] not in adj[odds[3]]) or
                    (odds[0] not in adj[odds[2]] and odds[1] not in adj[odds[3]]) or
                    (odds[0] not in adj[odds[3]] and odds[1] not in adj[odds[2]]))
        return False",O(n)
"import os
import sys
from math import *
from collections import *

from bisect import *
from io import BytesIO, IOBase

def vsInput():
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA = ""abcdefghijklmnopqrstuvwxyz/""
M = 1000000007
EPS = 1e-6

def Ceil(a, b):
    return a // b + int(a % b > 0)

def value():
    return tuple(map(int, input().split()))

def array():
    return [int(i) for i in input().split()]

def Int():
    return int(input())

def Str():
    return input()

def arrayS():
    return [i for i in input().split()]

n = int(input())
if n == 0:
    print(0)
else:
    print(n // 2 + 1 if n % 2 != 0 else n + 1)
",O(1)
"n = int(input())
a = []
for i in range(n):
    a.append(list(map(int,input().split()))+[i+1])
a.sort(key = lambda e:e[0])
f = 0
for i in range(n-1):
    if a[i][0] == a[i+1][0]:
        if a[i][1] >= a[i+1][1]:
            print(a[i+1][2],a[i][2])
        else:print(a[i][2],a[i+1][2])
        f =1
        break
    if a[i][1] >= a[i+1][1]:
        f = 1
        print(a[i+1][2],a[i][2])
        break
if f == 0:print(-1,-1)
",O(nlogn)
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

Q, = getIntList()
for _ in range(Q):
    N, M, K  = getIntList()
    if max(N,M) >K:
        print(-1)
        continue
    r = K
    if N%2!= K%2:
        r-=1
    if M%2!= K%2:
        r-=1
    print(r)
",O(1)
"from itertools import combinations as cmb
n ,l ,r ,x = map(int , input().split())
*a , = map(int ,input().split())
b = []
a.sort()
for i in range(2 ,n+1):
    b.extend(cmb(a ,i))
ans = 0
for i in b:

    if(sum(i) >= l and sum(i) <= r):
        if(i[-1]-i[0] >= x):

            ans+=1

print(ans)",np
"class Solution(object):
    def getSum(self, a, b):
        bit_length = 32
        neg_bit, mask = (1 << bit_length) >> 1, ~(~0 << bit_length)

        a = (a | ~mask) if (a & neg_bit) else (a & mask)
        b = (b | ~mask) if (b & neg_bit) else (b & mask)

        while b:
            carry = a & b
            a ^= b
            a = (a | ~mask) if (a & neg_bit) else (a & mask)
            b = carry << 1
            b = (b | ~mask) if (b & neg_bit) else (b & mask)

        return a

    def getSum2(self, a, b):
        MAX = 0x7FFFFFFF
        MIN = 0x80000000
        mask = 0xFFFFFFFF
        while b:
            a, b = (a ^ b) & mask, ((a & b) << 1) & mask
        return a if a <= MAX else ~(a ^ mask)

    def minus(self, a, b):
        b = self.getSum(~b, 1)
        return self.getSum(a, b)

    def multiply(self, a, b):
        isNeg = (a > 0) ^ (b > 0)
        x = a if a > 0 else self.getSum(~a, 1)
        y = b if b > 0 else self.getSum(~b, 1)
        ans = 0
        while y & 0x01:
            ans = self.getSum(ans, x)
            y >>= 1
            x <<= 1
        return self.getSum(~ans, 1) if isNeg else ans

    def divide(self, a, b):
        isNeg = (a > 0) ^ (b > 0)
        x = a if a > 0 else self.getSum(~a, 1)
        y = b if b > 0 else self.getSum(~b, 1)
        ans = 0
        for i in range(31, -1, -1):
            if (x >> i) >= y:
                x = self.minus(x, y << i)
                ans = self.getSum(ans, 1 << i)
        return self.getSum(~ans, 1) if isNeg else ans",O(1)
"class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        numSet = set(nums)
        longest = 0

        for num in numSet:
            if (num - 1) not in numSet:
                length = 1
                while (num + length) in numSet:
                    length += 1
                longest = max(length, longest)
        return longest
",O(n)
"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        for i in range(len(numbers)):
            l, r = i + 1, len(numbers) - 1
            tmp = target - numbers[i]
            while l <= r:
                mid = l + (r - l)//2
                if numbers[mid] == tmp:
                    return [i + 1, mid + 1]
                elif numbers[mid] < tmp:
                    l = mid + 1
                else:
                    r = mid - 1
        return []
",O(nlogn)
"n = int(input())

lst = []
for x in range(n):
    (a, b) = map(int, input().split())
    lst.append((a, b))

def scal(x1, y1, x2, y2, x3, y3):
    if (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1) == 0:
        return True
    return False

def check():
    for x in range(n - 2):
        if len(s2) >= 3:
            if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):
                return False
        if scal(lst[0][0], lst[0][1], lst[1][0], lst[1][1], lst[x + 2][0], lst[x + 2][1]):
            s1.append(x + 2)
        else:
            s2.append(x + 2)
    if len(s2) >= 3:
        if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):
            return False
    return True

flag = True

if n >= 5:
    s1 = []
    s2 = []
    if not check():
        lst[1], lst[s2[0]] = lst[s2[0]], lst[1]
        x = s2[0]
        s1 = []
        s2 = []
        if not check():
            lst[0], lst[s2[0]] = lst[s2[0]], lst[0]
            s1 = []
            s2 = []
            if not check():
                flag = False

if flag:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        n = len(matrix)
        rotated = [[0] * n for _ in range(n)]

        for i in range(n):
            for j in range(n):
                rotated[j][n - 1 - i] = matrix[i][j]

        for i in range(n):
            for j in range(n):
                matrix[i][j] = rotated[i][j]
",O(n ^ 2)
"import math

if __name__ == '__main__':
    n, m, k, l = map(int, input().split())
    one_friend = (k + l) // m + int((k + l) % m != 0)
    if one_friend * m > n:
        print(-1)
    else:
        print(one_friend)
",O(1)
"n=int(input())
arr=[]
for i in range(n):
    arr.append(input())

arr.sort(key=lambda x: len(x))
flag=False
for i in range(n-2,-1,-1):
    if arr[i] not in arr[i+1]:
        flag=True
        break

if flag:
    print(""NO"")
else:
    print(""YES"")
    for i in arr:
        print(i)",O(nlogn)
"class Solution(object):
    def minimizeConcatenatedLength(self, words):
        dp = [[float(""-inf"")]*26 for _ in range(2)]
        dp[0][ord(words[0][-1])-ord('a')] = dp[1][ord(words[0][0])-ord('a')] = 0
        for i in range(1, len(words)):
            new_dp = [[float(""-inf"")]*26 for _ in range(2)]
            for right in range(2):
                for c in range(26):
                    if dp[right][c] == float(""-inf""):
                        continue
                    l = c if right else ord(words[i-1][0])-ord('a')
                    r = c if not right else ord(words[i-1][-1])-ord('a')
                    new_dp[0][r] = max(new_dp[0][r], dp[right][c]+int(ord(words[i][-1])-ord('a') == l))
                    new_dp[1][l] = max(new_dp[1][l], dp[right][c]+int(r == ord(words[i][0])-ord('a')))
            dp = new_dp
        return sum(len(w) for w in words)-max(dp[right][c] for right in range(2) for c in range(26))",O(n)
"n,k = [int(x) for x in input().split()]
a = []
for _ in range(n):
    a.append([int(x) for x in input().split()])

a.sort(key = lambda x: x[1])
a.sort(reverse=True,key=lambda x: x[0])
b=a[k-1]
print(a.count(b))",O(nlogn)
"n=int(input())
arr=[int(x) for x in input().split()]
pos=dict()
if(n==1):print(""B"")
else:
    for i in range(n):
        pos[arr[i]]=i
    ans=[""Q""]*n

    ans[pos[1]]=""A""
    ans[pos[n]]=""B""
    for i in range(n-1,0,-1):
        flag=0
        p=pos[i]
        j=1
        while(p+j*i<n):
            if(ans[p+j*i]==""B""):
                flag=1
                ans[pos[i]]=""A""
                break
            j+=1
        if(flag==0):
            j=1
            while(p-j*i>=0):
                if(ans[p-j*i]=='B'):
                    flag=1
                    ans[pos[i]]=""A""
                    break
                j+=1
        if(flag==0):ans[pos[i]]=""B""
    print("""".join(ans))
",O(nlogn)
"n=int(input())
a=[int(x) for x in input().split()]
pro=n*(n-1)//2
dic={}
for item in a:
    if item not in dic:
        dic[item]=1
    else:
        dic[item]+=1
counter=0
for item in dic:
    if 0 in dic and dic[0]>=2:
        print('cslnb')
        break
    if dic[item]>2:
        print('cslnb')
        break
    elif dic[item]==2:
        if counter==1 or item-1 in dic:
            print('cslnb')
            break
        else:
            counter=1
else:
    if (sum(a)-pro)%2==1:
        print('sjfnb')
    else:
        print('cslnb')
",O(n)
"MOD = 998244353

def main():
    n = int(input())
    a = [int(x) for x in input().split(' ')]

    p, sp, s, ss = 0, 0, 0, 0
    for x in a:
        ss = (2 * ss + s) % MOD
        s = (s + x) % MOD
        p = (ss + sp + s) % MOD
        sp = (sp + p) % MOD
    print(p)

if __name__ == '__main__':
    main()
",O(n)
"class Solution(object):
    def minimumOneBitOperations(self, n):
        def gray_to_binary(n):
            result = 0
            while n:
                result ^= n
                n >>= 1
            return result
        return gray_to_binary(n)",O(logn)
"class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isCousins(self, root, x, y):
        def dfs(root, x, depth, parent):
            if not root:
                return False
            if root.val == x:
                return True
            depth[0] += 1
            prev_parent, parent[0] = parent[0], root
            if dfs(root.left, x, depth, parent):
                return True
            parent[0] = root
            if dfs(root.right, x, depth, parent):
                return True
            parent[0] = prev_parent
            depth[0] -= 1
            return False
        
        depth_x, depth_y = [0], [0]
        parent_x, parent_y = [None], [None]
        return dfs(root, x, depth_x, parent_x) and \
               dfs(root, y, depth_y, parent_y) and \
               depth_x[0] == depth_y[0] and \
               parent_x[0] != parent_y[0]",O(n)
"n = int(input())
fst, nxt, lst, des = [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)]
cnt = 0

def add(u, v) :
	global cnt
	cnt += 1
	if fst[u] == 0 :
		fst[u] = cnt
	else :
		nxt[lst[u]] = cnt
	lst[u], des[cnt] = cnt, v

for i in range(1, n) :
	u, v = map(int, input().split())

	add(u, v)
	add(v, u)

a = list(map(int, input().split()))
deep = [0 for i in range(n + 1)]
deep[1] = 1
now, res = 1, 1
Ans = 0

for i in range(0, n) :
	if deep[a[i]] == 0 :
		Ans = 1
		break
	elif deep[a[i]] < now :
		Ans = 1
		break
	else :
		b = fst[a[i]]
		res += 1
		while b > 0 :
			if deep[des[b]] == 0 :
				deep[des[b]] = res
			b = nxt[b]
		now = deep[a[i]]

if Ans == 0 :
	print(""Yes"")
else :
	print(""No"")
",O(nlogn)
"class Solution(object):
    def minEnd(self, n, x):
        n -= 1
        base_n = base_x = 1
        while base_n <= n:
            if (x&base_x) == 0:
                if n&base_n:
                    x |= base_x
                base_n <<= 1
            base_x <<= 1
        return x",O(logn)
"import random


class Solution_TLE(object):
    def getStrongest(self, arr, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def partition_around_pivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == n:
                    return
                elif new_pivot_idx > n:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
        
        nth_element(arr, (len(arr)-1)//2)
        m = arr[(len(arr)-1)//2]
        nth_element(arr, k, lambda a, b: abs(a-m) > abs(b-m) if abs(a-m) != abs(b-m) else a > b)
        return arr[:k]",O(n)
"T = input().split(' ')
n = int(T[0])
m = int(T[1])
S = input().split(' ')
for i in range(n):
    S[i] = int(S[i])
ind = 0
for k in range(n):
    if S[k] == m:
        ind = k
k = ind
P = [0]*(n+1)
N = [0]*(n+1)
R = [0]*(n-k)
L = [0]*(k+1)
for i in range(k):
    if S[k-1-i] < m:
        L[k-1-i] = L[k-i] - 1
    else:
        L[k-1-i] = L[k-i] + 1
for i in range(n-k-1):
    if S[k+1+i] > m:
        R[1+i] = R[i] + 1
    else:
        R[1+i] = R[i] - 1
c = 0
for el in R:
    if el >= 0:
        P[el]+=1
        if el == 0:
            N[el]+=1
    else:
        N[-el]+=1
for el in L:
    if el >= 1:
        c = c + N[el] + N[el-1]
    else:
        c = c + P[-el] + P[-el+1]
print(c)
",O(nlogn)
"class Solution2(object):
    def countRangeSum(self, nums, lower, upper):
        def countAndMergeSort(sums, start, end, lower, upper):
            if end - start <= 0: 
                return 0

            mid = start + (end - start) / 2
            count = countAndMergeSort(sums, start, mid, lower, upper) + \
                    countAndMergeSort(sums, mid + 1, end, lower, upper)
            j, k, r = mid + 1, mid + 1, mid + 1
            tmp = []
            for i in range(start, mid + 1):
                while k <= end and sums[k] - sums[i] < lower:
                    k += 1
                while j <= end and sums[j] - sums[i] <= upper:
                    j += 1
                count += j - k

                while r <= end and sums[r] < sums[i]:
                    tmp.append(sums[r])
                    r += 1
                tmp.append(sums[i])

            sums[start:start+len(tmp)] = tmp
            return count

        sums = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            sums[i + 1] = sums[i] + nums[i]
        return countAndMergeSort(sums, 0, len(sums) - 1, lower, upper)",O(nlogn)
"class Solution(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):
        boxes.sort(reverse=True)
        result = 0
        for h in boxes:
            if h > warehouse[result]:
                continue
            result += 1
            if result == len(warehouse):
                break
        return result",O(nlogn)
"import sys
input=sys.stdin.readline
hashi=dict()
for i in range(1,10**5):
    hashi[i*i]=1
    hashi[(2*i*i)]=1
t=int(input())
for you in range(t):
    n=int(input())
    if(n%2):
        print(""NO"")
        continue
    z=n//2
    if(z in hashi):
        print(""YES"")
    else:
        print(""NO"")
",O(1)
"import sys

f = sys.stdin

def line():
    return f.readline().strip().split()

def powers(limit):
    size = limit+1
    p = [1]*size
    for n in range(1,size):
        p[n] = (2*p[n-1]) % M

    return p

def binomials(limit):
    size = limit+1
    bc = [[0 for k in range(size)] for n in range(size)]
    for n in range(size):
        bc[n][0]=1

    for n in range(1,size):
        for k in range(1,n+1):
            bc[n][k] = bc[n-1][k-1] + bc[n-1][k]
            bc[n][k] %= M

    return bc

def solve():

    size = N+1
    dp = [[0 for _ in range(size)] for _ in range(size)]
    dp[1][0]=1

    for i in range(2,size):
        for k in range(1,i):
            for j in range(1,k):
                dp[i][j] += BC[i-j][k-j] * dp[k-1][j-1] * POW[i-k-1]
                dp[i][j] %= M
        dp[i][0] = POW[i-1]

    res=0
    for j in range(0,N-1):
        res = (res + dp[N][j]) % M

    return str(res)

T = 1
for test in range(1,T+1):
    N,M = map(int,line())

    BC = binomials(N)
    POW = powers(N)

    print(solve())

f.close()",O(n ^ 3)
"import sys
input = lambda: sys.stdin.readline().rstrip()

N, M, K = map(int, input().split())
if K % 2:
    for _ in range(N):
        print(*[-1] * M)
    exit()
A = [[int(a) for a in input().split()] for _ in range(N)]
B = [[int(a) for a in input().split()] for _ in range(N-1)]
X = [[0] * M for _ in range(N)]
inf = 1 << 30
for k in range(1, K // 2 + 1):
    nX = [[inf] * M for _ in range(N)]
    for i in range(N):
        for j in range(M):
            if i: nX[i][j] = min(nX[i][j], X[i-1][j] + B[i-1][j])
            if i < N - 1: nX[i][j] = min(nX[i][j], X[i+1][j] + B[i][j])
            if j: nX[i][j] = min(nX[i][j], X[i][j-1] + A[i][j-1])
            if j < M - 1: nX[i][j] = min(nX[i][j], X[i][j+1] + A[i][j])
    X = nX
for x in X:
    print(*[a * 2 for a in x])
",O(n ^ 3)
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        indices = {}

        for i, n in enumerate(nums):
            indices[n] = i

        for i, n in enumerate(nums):
            diff = target - n
            if diff in indices and indices[diff] != i:
                return [i, indices[diff]]
",O(n)
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n = int(input())
*a, = map(int, input().split())
dp = [[0 for i in range(n + 1)] for j in range(n + 1)]
for i in range(n):
    dp[0][i] = a[i]
for i in range(1, n):
    for j in range(n - i + 1):
        dp[i][j] = dp[i - 1][j] ^ dp[i - 1][j + 1]
for i in range(1, n):
    for j in range(n - i):
        dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i - 1][j + 1])
for i in range(int(input())):
    l, r = map(int, input().split())
    print(dp[r - l][l - 1])",O(n ^ 2)
"def push(d, u, v):
    if u not in d:
        d[u] = []
    if v not in d:
        d[v] = []
    d[u].append(v)
    d[v].append(u)

def push_v(d, u, val):
    if u not in d:
        d[u] = 0
    d[u] += val

n, k = map(int, input().split())
g    = {}

for _ in  range(n-1):
    u, v = map(int, input().split())
    push(g, u, v)

deg1 = []
used = [0] * (n+1)

for u in g:
    if len(g[u]) == 1:
        used[u]  = 1
        deg1.append(u)

flg = True
while k > 0:
    if k >= 1 and len(deg1) < 3:
        flg=False
        break

    cnt = {}
    for u in deg1:
        for v in g[u]:
            if used[v] == 0:
                push_v(cnt, v, 1)

    for v in deg1:
        used[v] = 1

    deg1 = []

    for v, val in cnt.items():
        if val < 3:
            flg=False
            break
        deg1.append(v)

    if flg==False:
        break
    k-=1

if flg==True and len(deg1) > 1:
    flg=False

if flg==False:
    print('NO')
else:
    print('YES')
",O(nlogn)
"class Solution(object):
    def judgeCircle(self, moves):
        v, h = 0, 0
        for move in moves:
            if move == 'U':
                v += 1
            elif move == 'D':
                v -= 1
            elif move == 'R':
                h += 1
            elif move == 'L':
                h -= 1
        return v == 0 and h == 0",O(n)
"class Solution:
    def numDecodings(self, s: str) -> int:
        dp = dp2 = 0
        dp1 = 1
        for i in range(len(s) - 1, -1, -1):
            if s[i] == ""0"":
                dp = 0
            else:
                dp = dp1

            if i + 1 < len(s) and (s[i] == ""1"" or
               s[i] == ""2"" and s[i + 1] in ""0123456""
            ):
                dp += dp2
            dp, dp1, dp2 = 0, dp, dp1
        return dp1
",O(n)
"k1,k2,k3=map(int,input().split())
a=[k1,k2,k3];a=sorted(a)

i=0
while i<=5000:
 if dp[i]==0 and i+a[0]<=5000:
   while i+a[0]<=5000:
     dp[i]=1
     i=i+a[0]
 else:i+=1

while i<=5000:
 if dp[i]==0 and i+a[1]<=5000:
   while i+a[1]<=5000:
     dp[i]=1
     i=i+a[1]
 else:i+=1

while i<=5000:
 if dp[i]==0 and i+a[2]<=5000:
   while i+a[2]<=5000:
     dp[i]=1
     i=i+a[2]
 else:i+=1

if dp.count(0)==0:print(""YES"")
else:print(""NO"")
",O(1)
"class Solution2(object):
    def rotate(self, nums, k):
        def apply_cycle_permutation(k, offset, cycle_len, nums):
            tmp = nums[offset]
            for i in range(1, cycle_len):
                nums[(offset + i * k) % len(nums)], tmp = tmp, nums[(offset + i * k) % len(nums)]
            nums[offset] = tmp

        k %= len(nums)
        num_cycles = gcd(len(nums), k)
        cycle_len = len(nums) / num_cycles
        for i in range(num_cycles):
            apply_cycle_permutation(k, i, cycle_len, nums)",O(n)
"class Solution2(object):
    def getRow(self, rowIndex):
        result = [1]
        for i in range(1, rowIndex + 1):
            result = [1] + [result[j - 1] + result[j] for j in range(1, i)] + [1]
        return result",O(n ^ 2)
"n, m = map(int, input().split())

top = [-1, -1]
bottom = [-1, -1]

for i in range(n):
    s = input()
    left = s.find('B')
    if left != -1:
        right = s.rfind('B')
        c = (right - left) // 2 + 1
        print(i + c, left + c)
        break
",O(n ^ 2)
"p1, g1, ig1 = 104857601, 3, 34952534
p2, g2, ig2 = 111149057, 3, 37049686
p3, g3, ig3 = 113246209, 7, 16178030
z1 = 439957480532171226961446
z2 = 879898597692195524486915
z3 = 8496366309945115353
ppp = p1 * p2 * p3
W1 = [pow(g1, (p1 - 1) >> i, p1) for i in range(22)]
W2 = [pow(g2, (p2 - 1) >> i, p2) for i in range(22)]
W3 = [pow(g3, (p3 - 1) >> i, p3) for i in range(22)]
iW1 = [pow(ig1, (p1 - 1) >> i, p1) for i in range(22)]
iW2 = [pow(ig2, (p2 - 1) >> i, p2) for i in range(22)]
iW3 = [pow(ig3, (p3 - 1) >> i, p3) for i in range(22)]

def fft1(k, f):
    for l in range(k, 0, -1):
        d = 1 << l - 1
        U = [1]
        for i in range(d):
            U.append(U[-1] * W1[l] % p1)

        for i in range(1 << k - l):
            for j in range(d):
                s = i * 2 * d + j
                f[s], f[s+d] = (f[s] + f[s+d]) % p1, U[j] * (f[s] - f[s+d]) % p1
def fft2(k, f):
    for l in range(k, 0, -1):
        d = 1 << l - 1
        U = [1]
        for i in range(d):
            U.append(U[-1] * W2[l] % p2)

        for i in range(1 << k - l):
            for j in range(d):
                s = i * 2 * d + j
                f[s], f[s+d] = (f[s] + f[s+d]) % p2, U[j] * (f[s] - f[s+d]) % p2
def fft3(k, f):
    for l in range(k, 0, -1):
        d = 1 << l - 1
        U = [1]
        for i in range(d):
            U.append(U[-1] * W3[l] % p3)

        for i in range(1 << k - l):
            for j in range(d):
                s = i * 2 * d + j
                f[s], f[s+d] = (f[s] + f[s+d]) % p3, U[j] * (f[s] - f[s+d]) % p3

def ifft1(k, f):
    for l in range(1, k + 1):
        d = 1 << l - 1
        for i in range(1 << k - l):
            u = 1
            for j in range(i * 2 * d, (i * 2 + 1) * d):
                f[j+d] *= u
                f[j], f[j+d] = (f[j] + f[j+d]) % p1, (f[j] - f[j+d]) % p1
                u = u * iW1[l] % p1
def ifft2(k, f):
    for l in range(1, k + 1):
        d = 1 << l - 1
        for i in range(1 << k - l):
            u = 1
            for j in range(i * 2 * d, (i * 2 + 1) * d):
                f[j+d] *= u
                f[j], f[j+d] = (f[j] + f[j+d]) % p2, (f[j] - f[j+d]) % p2
                u = u * iW2[l] % p2
def ifft3(k, f):
    for l in range(1, k + 1):
        d = 1 << l - 1
        for i in range(1 << k - l):
            u = 1
            for j in range(i * 2 * d, (i * 2 + 1) * d):
                f[j+d] *= u
                f[j], f[j+d] = (f[j] + f[j+d]) % p3, (f[j] - f[j+d]) % p3
                u = u * iW3[l] % p3

def convolve(a, b):
    n0 = len(a) + len(b) - 1
    if len(a) < 50 or len(b) < 50:
        ret = [0] * n0
        if len(a) > len(b): a, b = b, a
        for i, aa in enumerate(a):
            for j, bb in enumerate(b):
                ret[i+j] = (ret[i+j] + aa * bb) % P
        return ret

    k = (n0).bit_length()
    n = 1 << k
    a = a + [0] * (n - len(a))
    b = b + [0] * (n - len(b))

    a1 = [x % p1 for x in a]
    a2 = [x % p2 for x in a]
    a3 = [x % p3 for x in a]
    b1 = [x % p1 for x in b]
    b2 = [x % p2 for x in b]
    b3 = [x % p3 for x in b]
    fft1(k, a1), fft1(k, b1)
    fft2(k, a2), fft2(k, b2)
    fft3(k, a3), fft3(k, b3)
    for i in range(n): a1[i] = a1[i] * b1[i] % p1
    for i in range(n): a2[i] = a2[i] * b2[i] % p2
    for i in range(n): a3[i] = a3[i] * b3[i] % p3
    ifft1(k, a1)
    ifft2(k, a2)
    ifft3(k, a3)
    invn1 = pow(n, p1 - 2, p1)
    invn2 = pow(n, p2 - 2, p2)
    invn3 = pow(n, p3 - 2, p3)
    for i in range(n0): a1[i] = a1[i] * invn1 % p1
    for i in range(n0): a2[i] = a2[i] * invn2 % p2
    for i in range(n0): a3[i] = a3[i] * invn3 % p3
    return [(x1 * z1 + x2 * z2 + x3 * z3) % ppp % P for x1, x2, x3 in zip(a1[:n0], a2[:n0], a3[:n0])]
def chk(L):
    return [fa[i] * x % P for i, x in enumerate(L)]
def chkinv(L):
    return [fainv[i] * x % P for i, x in enumerate(L)]
N, P = map(int, input().split())

nn = 1001

fa = [1] * (nn+1)
fainv = [1] * (nn+1)
for i in range(nn):
    fa[i+1] = fa[i] * (i+1) % P
fainv[-1] = pow(fa[-1], P-2, P)
for i in range(nn)[::-1]:
    fainv[i] = fainv[i+1] * (i+1) % P

X = [[] for _ in range(444)]
Y = [[] for _ in range(444)]
X[0] = [1]
X[1] = [0, 1]
X[2] = [0, 1, 1]
X[3] = [0, 0, 4, 1]

Y[0] = [1]
Y[1] = [1, 0]
Y[2] = [0, 2, 0]
Y[3] = [0, 1, 4, 0]

for i in range(4, 404):
    X[i] = [0] * i + [1]
    Y[i] = [0] * (i + 1)
    for j in range(1, i):
        k = i - j
        X[i][j] = (X[i-1][j-1] * (2 * k + 1) + X[i-2][j-1] * k) % P
        Y[i][j] = (Y[i-1][j-1] * (2 * k) + Y[i-2][j-1] * (k-1)) % P

X = [chkinv(a) for a in X]
Y = [chkinv(a) for a in Y]

ANS = [0] * (N + 1)
for i in range(N):
    t = convolve(X[i], X[N-1-i])
    for j, a in enumerate(t):
        ANS[j] = (ANS[j] + a) % P

ans = 0
for i, a in enumerate(ANS):
    ans = (ans + a * fa[i]) % P
print(ans)
",O(n ^ 3)
"import sys
input = sys.stdin.readline
def main():
    n,m,k = map(int,input().split())
    if k%2==1:
        for i in range(n):
            for j in  range(m):
                print(-1,end="" "")
            print()
        return 0
    kk=k
    maps= [[[0 for i in range(4)] for j in range(m)] for ii in range(n)]

    dp=[[[1e9 for i in range(k//2+1)] for j in range(m)] for ii in range(n)]
    for i in range(n):
            for j in range(m):
                dp[i][j][0]=0
    for i in range(n):
        s=list(map(int,input().split()))
        for j in range(m-1):
            maps[i][j][0]=s[j]
            maps[i][j+1][1]=s[j]
    for i in range(n-1):
        s=list(map(int,input().split()))
        for j in range(m):
            maps[i][j][2]=s[j]
            maps[i+1][j][3]=s[j]
    for k in range(1,kk//2+1):
        for i in range(n):
            for j in range(m):
                if j<m-1:
                    dp[i][j+1][k]=min(dp[i][j+1][k],dp[i][j][k-1]+maps[i][j][0])
                if i<n-1:
                    dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k-1]+maps[i][j][2])
                if i>0:
                    dp[i-1][j][k]=min(dp[i-1][j][k],dp[i][j][k-1]+maps[i][j][3])
                if j>0:
                    dp[i][j-1][k]=min(dp[i][j-1][k],dp[i][j][k-1]+maps[i][j][1])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k]*2,end="" "")
        print()
main()
",O(n ^ 3)
"n=int(input())
f=[input().strip()==""f"" for ii in range(n)]
mod=10**9+7
def summ(a,b):
 return (a+b)%mod
dp=[1]
for ii in range(1,n):
 pf=f[ii-1]
 if pf:
  dp.insert(0,0)
 else:
  for jj in reversed(range(1,len(dp))):
   dp[jj-1]=summ(dp[jj-1],dp[jj])
ans=0
for vv in dp:
 ans=summ(ans,vv)
print(ans)
",O(n ^ 2)
"class Solution(object):
    def minOperations(self, nums):
        def popcount(n):
            result = 0
            while n:
                n &= n-1
                result += 1
            return result

        result, max_len = 0, 1
        for num in nums:
            result += popcount(num)
            max_len = max(max_len, num.bit_length())
        return result + (max_len-1)",O(nlogn)
"def find(x):
    if root==x:
        u=root
    else:
        i=0
        s=2**i
        while x%s==0:
            i+=1
            s=2**i
        s=s//2
        y=i+1
        if (x-s)%(2**y)!=0:
            u=x-s
        else:
            u=x+s
    return u
n,q=list(map(int,input().split()))
root=(n+1)//2
for j in range(q):
    n1=int(input())
    str1=input()
    for j in range(len(str1)):
        up=find(n1)
        if str1[j]=='U':
            n1=(up)
        elif n1%2==0:
            if str1[j]=='L':
                if n1!=root:
                    n1=(n1-abs((up-n1)//2))
                else:
                    n1=(n1-n1//2)
            elif str1[j]=='R':
                if n1!=root:
                    n1=(n1+abs((up-n1)//2))
                elif n1%2==0:
                    n1=n1+n1//2
    print(n1)",np
"n,s = [int(x) for x in input().split()]
def check(x):
    y = list(str(x))
    ans = x
    for i in y:
        ans-=int(i)
    if (ans>=s):
        return True
    return False

ans = 0
l = 1
r = n
while(l<=r):
    m = (l+r)//2
    if (check(m)):
        ans = n-m+1
        r = m-1
    else:
        l = m+1
print(ans)",O(logn)
"class Solution3(object):
    def findMaximumElegance(self, items, k):
        items.sort(reverse=True)
        result = curr = 0
        lookup = set()
        stk = []
        for i in range(k):
            if items[i][1] in lookup:
                stk.append(items[i][0])
            curr += items[i][0]
            lookup.add(items[i][1])
        result = curr+len(lookup)**2
        for i in range(k, len(items)):
            if items[i][1] in lookup:
                continue
            if not stk:
                break
            curr += items[i][0]-stk.pop()
            lookup.add(items[i][1])
            result = max(result, curr+len(lookup)**2)
        return result",O(nlogn)
"from math import gcd

def t_prime(n):
    if n == 1:
        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:
            return False
    return True

primes = [i for i in range(2,10**5) if t_prime(i)]
pset = set(primes)

n, k = map(int, input().split())
l = list(map(int, input().split()))

if k == 1:
    print(0)
    exit()

for i in range(n):
    for j in range(i):
        u, v = l[i], l[j]
        poss = gcd(u,v)
        poss2 = max(u,v)//poss
        smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:
            primes.append(smol)
            pset.add(smol)

powers = set()

count = 0
outLs = []
pgood = []
for p in primes:
    curr = []
    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:
            v2 //= p
        if v2 == 1:
            curr.append(v)
            powers.add(v)
    if len(curr) > 1:
        count += len(curr)
        outLs.append(curr)
        pgood.append(p)

order = [(len(lis), lis) for lis in outLs]
order.sort(key = lambda x: x[0])

if len(order) == 0:
    print(0)
    exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []

    for v in l:
        if v in powers:
            continue

        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2

    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()

    other = []
    out = [extra]

    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k

    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1

    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0

assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:
        break

    if v in powers:
        continue

    v2 = v
    for p in pgood:
        while v2 % p == 0:
            v2 //= p
    if v2 == 1:
        out.append(v)
        need -= 1

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)
",np
"def mypw2(deg):
    if (deg >= 1500) : return 2 ** 150

    return 2 ** deg

def sol():
    n, k = map(int, input().split())
    if (k == 0):
        print(""YES"", n)
        return
    for side in range(1, n + 1):
        MIN = mypw2(side + 1) - side - 2
        MAX = mypw2(2 * n) - mypw2(2 * n - side + 1) + mypw2(side + 1) + mypw2(2 * n - 2 * side) - 2;
        MAX //= 3

        if (MIN <= k <= MAX):
            print(""YES"", n - side)
            return
    print(""NO"")

def main():
    t = int(input())
    for i in range(t):
        sol()

main()",O(logn)
"class Solution(object):
    def check(self, nums):
        count = 0
        for i in range(len(nums)):
            if nums[i] > nums[(i+1)%len(nums)]:
                count += 1
                if count > 1:
                    return False
        return True",O(n)
"class Solution(object):
    def minimumChairs(self, s):
        result = curr = 0
        for x in s:
            curr += +1 if x == ""E"" else -1
            result = max(result, curr)
        return result",O(n)
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
def ctd(chr): return ord(chr)-ord(""a"")
mod = 998244353
INF = float('inf')

from math import gcd

def main():
    n = N()
    larr = RLL()
    carr = RLL()

    dic = {}
    dic[0] = 0

    for i in range(n):
        l, c = larr[i], carr[i]
        ndic = dic.copy()
        for j in dic:
            now = gcd(j, l)
            if now not in ndic:
                ndic[now] = c+dic[j]
            else:
                ndic[now] = min(ndic[now], dic[j]+c)
        dic = ndic

    print(dic.get(1, -1))

if __name__ == ""__main__"":
    main()
",np
"d4i=[0,-1,0,1]
d4j=[-1,0,1,0]

def main():

    n,m,k=readIntArr()
    horizontalEdges=[]
    for _ in range(n):
        horizontalEdges.append(readIntArr())
    verticalEdges=[]
    for _ in range(n-1):
        verticalEdges.append(readIntArr())

    if k%2==1:
        ans=makeArr(-1,[n,m])
    else:
        dp=makeArr(inf,[n,m,k//2+1])
        for i in range(n):
            for j in range(m):
                dp[i][j][0]=0
        for nM in range(1,k//2+1):
            for i in range(n):
                for j in range(m):

                    if j+1<m:
                        dp[i][j][nM]=min(dp[i][j][nM],
                                         dp[i][j+1][nM-1]+horizontalEdges[i][j])

                    if j-1>=0:
                        dp[i][j][nM]=min(dp[i][j][nM],
                                         dp[i][j-1][nM-1]+horizontalEdges[i][j-1])

                    if i+1<n:
                        dp[i][j][nM]=min(dp[i][j][nM],
                                         dp[i+1][j][nM-1]+verticalEdges[i][j])

                    if i-1>=0:
                        dp[i][j][nM]=min(dp[i][j][nM],
                                         dp[i-1][j][nM-1]+verticalEdges[i-1][j])
        ans=makeArr(0,[n,m])
        for i in range(n):
            for j in range(m):
                ans[i][j]=dp[i][j][k//2]*2

    multiLineArrayOfArraysPrint(ans)

    return

import sys
input=sys.stdin.buffer.readline

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))

def readIntArr():
    return [int(x) for x in input().split()]

def makeArr(defaultVal,dimensionArr):
    dv=defaultVal;da=dimensionArr
    if len(da)==1:return [dv for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]

def queryInteractive(x,y):
    print('? {} {}'.format(x,y))
    sys.stdout.flush()
    return int(input())

def answerInteractive(ans):
    print('! {}'.format(ans))
    sys.stdout.flush()

inf=float('inf')

MOD=998244353

for _abc in range(1):
    main()",O(n ^ 3)
"import random



class Solution(object):
    def putMarbles(self, weights, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        for i in range(len(weights)-1):
            weights[i] += weights[i+1]
        weights.pop()
        result = 0
        nth_element(weights, (k-1)-1, compare=lambda a, b: a > b)
        result += sum(weights[i] for i in range(k-1))
        nth_element(weights, (k-1)-1)
        result -= sum(weights[i] for i in range(k-1))
        return result",O(n)
"import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def minMalwareSpread(self, graph, initial):
        union_find = UnionFind(len(graph))
        for i in range(len(graph)):
            for j in range(i+1, len(graph)):
                if graph[i][j] == 1:
                    union_find.union_set(i, j)
        union_size = collections.Counter(union_find.find_set(i) for i in range(len(graph)))
        malware_count = collections.Counter(union_find.find_set(i) for i in initial)
        return min(initial, key=lambda x: [malware_count[union_find.find_set(x)] > 1,
                                           -union_size[union_find.find_set(x)],
                                           x])",O(n ^ 2)
"
import itertools


class Solution(object):
    def printVertically(self, s):
        return ["""".join(c).rstrip() for c in itertools.zip_longest(*s.split(), fillvalue=' ')]
",O(n)
"class Solution(object):
    def countSubstrings(self, s, c):
        n = s.count(c)
        return (n+1)*n//2",O(n)
"n, x = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
s = set(a)
mv = 999
if len(s) < n:
    print(0)
else:
    for i in a:
        if i & x != i and i & x in s:
            print(1)
            break
    else:
        k = [i & x for i in a]
        if len(set(k)) < n:
            print(2)
        else:
            print(-1)
",O(n)
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    a = list(map(int, input().split()))
    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[i] > a[j]:
                cnt += 1
    even = cnt % 2 == 0
    q = int(input())
    for _ in range(q):
        l, r = map(int, input().split())
        len = r - l + 1
        pairs = len * (len-1) // 2
        if pairs % 2 == 1:
            even = not even
        if even:
            print('even')
        else:
            print('odd')

main()",O(n ^ 2)
"n, k = list(map(int, input().strip().split()))
arr = list(map(int, input().strip().split()))
k -= 1
arr_new = sorted([arr[i+1]-arr[i] for i in range(n-1)], reverse=True)
print(arr[-1]-arr[0]-sum(arr_new[:k]))
",O(nlogn)
"def parse(line):
	i = 0
	while line[i].isalpha():
		i += 1
	i1 = i
	while i < len(line) and line[i].isdigit():
		i += 1
	return line[:i1], int(line[i1:i]), line[i:]

for _ in range(int(input())):
	a1, n1, rest = parse(input())
	if rest:
		_, n2, _ = parse(rest)
		a2 = ''
		while n2:
			r = (n2 - 1) % 26
			a2 = chr(r + ord('A')) + a2
			n2 = (n2 - r - 1) // 26
		print(a2 + str(n1))
	else:
		n2 = 0
		for c in a1:
			n2 = 26 * n2 + (ord(c) - ord('A') + 1)
		print(f'R{n1}C{n2}')
",O(n)
"from math import inf

n = int(input())
s_list = list(map(int, input().split()))
c_list = list(map(int, input().split()))

total_min = inf
for j in range(n):
    min_i = inf
    for i in range(0, j):
        if s_list[i] < s_list[j]:
            min_i = min(min_i, c_list[i])

    min_k = inf
    for k in range(j + 1, n):
        if s_list[k] > s_list[j]:
            min_k = min(min_k, c_list[k])

    total_min = min(total_min, min_i + c_list[j] + min_k)
if total_min != inf:
    print(total_min)
else:
    print(-1)",O(n ^ 2)
"import sys
from math import floor, ceil

r = lambda: sys.stdin.readline().strip()

a = [[0] * 2 for i in range(3)]

def abs(x):
    if x < 0:
        x = -x
    return x

def calcLen(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2) + 1

def main():
    a[0][0], a[0][1] = map(int, r().split())
    a[1][0], a[1][1] = map(int, r().split())
    a[2][0], a[2][1] = map(int, r().split())
    xMax = max(a[0][0], a[1][0], a[2][0])
    xMin = min(a[0][0], a[1][0], a[2][0])
    yMax = max(a[0][1], a[1][1], a[2][1])
    yMin = min(a[0][1], a[1][1], a[2][1])

    pathLen = xMax - xMin + yMax - yMin + 1
    for i in range(3):
        for j in range(3):
            px = a[i][0]
            py = a[j][1]
            sum = 0
            for k in range(3):
                sum += (calcLen(a[k][0], a[k][1], px, py))
            sum -= 2
            if sum == pathLen:
                break
        if sum == pathLen:
            break
    sq = [[0]*(yMax+1) for i in range(xMax+1)]
    for i in range(3):
        if px == a[i][0]:
            c = -1
            if py > a[i][1]:
                c = 1
            for j in range(a[i][1], py, c):
                sq[px][j]=1
        elif py== a[i][1]:
            c = -1
            if px > a[i][0]:
                c= 1
            for j in range(a[i][0], px, c):
                sq[j][py] = 1
        else:
            c = -1
            if py > a[i][1]:
                c = 1
            for j in range(a[i][1], py + c, c):
                sq[a[i][0]][j] = 1

            c = -1
            if px > a[i][0]:
                c= 1
            for j in range(a[i][0], px, c):
                sq[j][py] = 1
    sq[px][py] = 1
    ans = []
    for i in range(xMax + 1):
        for j in range(yMax + 1):
            if sq[i][j] == 1:
                ans.append((i, j))
    print(len(ans))
    for i in ans:
        print(i[0], i[1])

main()
",O(1)
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()

        def dfs(i, prev):
            if i == len(intervals):
                return 0
            res = dfs(i + 1, prev)
            if prev == -1 or intervals[prev][1] <= intervals[i][0]:
                res = max(res, 1 + dfs(i + 1, i))
            return res

        return len(intervals) - dfs(0, -1)
",O(2 ^ n)
"class Solution:
    def jump(self, nums: List[int]) -> int:
        def dfs(i):
            if i == len(nums) - 1:
                return 0
            if nums[i] == 0:
                return float('inf')

            end = min(len(nums) - 1, i + nums[i])
            res = float('inf')
            for j in range(i + 1, end + 1):
                res = min(res, 1 + dfs(j))
            return res

        return dfs(0)
",O(n!)
"class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        def dfs(i, flag):
            if i == len(nums):
                return 0 if flag else -1e6
            if flag:
                return max(0, nums[i] + dfs(i + 1, True))
            return max(dfs(i + 1, False), nums[i] + dfs(i + 1, True))
        return dfs(0, False)
",O(2 ^ n)
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        def dfs(i):
            if i == len(nums) - 1:
                return True
            end = min(len(nums) - 1, i + nums[i])
            for j in range(i + 1, end + 1):
                if dfs(j):
                    return True
            return False

        return dfs(0)
",O(n!)
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        def backtrack(i, total):
            if i ==len(nums):
                return  total == target

            return (backtrack(i + 1, total + nums[i]) +
                    backtrack(i + 1, total - nums[i]))

        return backtrack(0, 0)
",O(2 ^ n)
"class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2:
            return False

        def dfs(i, target):
            if i >= len(nums):
                return target == 0
            if target < 0:
                return False

            return dfs(i + 1, target) or dfs(i + 1, target - nums[i])

        return dfs(0, sum(nums) // 2)
",O(2 ^ n)
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:

        def dfs(i, j):
            if i == len(nums):
                return 0

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            return LIS

        return dfs(0, -1)
",O(2 ^ n)
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        def dfs(i, buying):
            if i >= len(prices):
                return 0

            cooldown = dfs(i + 1, buying)
            if buying:
                buy = dfs(i + 1, not buying) - prices[i]
                return max(buy, cooldown)
            else:
                sell = dfs(i + 2, not buying) + prices[i]
                return max(sell, cooldown)

        return dfs(0, True)
",O(2 ^ n)
"class Solution:
    def numDecodings(self, s: str) -> int:

        def dfs(i):
            if i == len(s):
                return 1
            if s[i] == '0':
                return 0

            res = dfs(i + 1)
            if i < len(s) - 1:
                if (s[i] == '1' or
                   (s[i] == '2' and s[i + 1] < '7')):
                    res += dfs(i + 2)

            return res

        return dfs(0)
",O(2 ^ n)
"class Solution:
    def rob(self, nums: List[int]) -> int:

        def dfs(i):
            if i >= len(nums):
                return 0
            return max(dfs(i + 1),
                       nums[i] + dfs(i + 2))

        return dfs(0)
",O(2 ^ n)
"class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:

        def dfs(i):
            if i >= len(cost):
                return 0
            return cost[i] + min(dfs(i + 1), dfs(i + 2))

        return min(dfs(0), dfs(1))
",O(2 ^ n)
"class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        def dfs(i, flag):
            if i >= len(nums) or (flag and i == len(nums) - 1):
                return 0

            return max(dfs(i + 1, flag),
                       nums[i] + dfs(i + 2, flag or i == 0))
        return max(dfs(0, True), dfs(1, False))
",O(2 ^ n)
"class Solution:
    def climbStairs(self, n: int) -> int:

        def dfs(i):
            if i >= n:
                return i == n
            return dfs(i + 1) + dfs(i + 2)

        return dfs(0)
",O(2 ^ n)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if self.isSafe(r, c, board):
                    board[r][c] = ""Q""
                    backtrack(r + 1)
                    board[r][c] = "".""

        backtrack(0)
        return res

    def isSafe(self, r: int, c: int, board):
        row = r - 1
        while row >= 0:
            if board[row][c] == ""Q"":
                return False
            row -= 1

        row, col = r - 1, c - 1
        while row >= 0 and col >= 0:
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col -= 1

        row, col = r - 1, c + 1
        while row >= 0 and col < len(board):
            if board[row][col] == ""Q"":
                return False
            row -= 1
            col += 1
        return True
",O(n!)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = set()
        posDiag = set()
        negDiag = set()

        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue

                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                board[r][c] = ""Q""

                backtrack(r + 1)

                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = [False] * n
        posDiag = [False] * (n * 2)
        negDiag = [False] * (n * 2)
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if col[c] or posDiag[r + c] or negDiag[r - c + n]:
                    continue
                col[c] = True
                posDiag[r + c] = True
                negDiag[r - c + n] = True
                board[r][c] = ""Q""

                backtrack(r + 1)

                col[c] = False
                posDiag[r + c] = False
                negDiag[r - c + n] = False
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col = 0
        posDiag = 0
        negDiag = 0
        res = []
        board = [["".""] * n for i in range(n)]

        def backtrack(r):
            nonlocal col, posDiag, negDiag
            if r == n:
                copy = ["""".join(row) for row in board]
                res.append(copy)
                return
            for c in range(n):
                if ((col & (1 << c)) or (posDiag & (1 << (r + c)))
                    or (negDiag & (1 << (r - c + n)))):
                    continue
                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = ""Q""

                backtrack(r + 1)

                col ^= (1 << c)
                posDiag ^= (1 << (r + c))
                negDiag ^= (1 << (r - c + n))
                board[r][c] = "".""

        backtrack(0)
        return res
",O(n!)
"import collections


class Solution(object):
    def numSquarefulPerms(self, A):
        def dfs(candidate, x, left, count, result):
            count[x] -= 1
            if left == 0:
                result[0] += 1
            for y in candidate[x]:
                if count[y]:
                    dfs(candidate, y, left-1, count, result)
            count[x] += 1

        count = collections.Counter(A)
        candidate = {i: {j for j in count if int((i+j)**0.5) ** 2 == i+j} 
                           for i in count}

        result = [0]
        for x in count:
            dfs(candidate, x, len(A)-1, count, result)
        return result[0]",O(n!)
"class Solution(object):
    def totalNQueens(self, n):
        def dfs(row):
            if row == n:
                return 1
            result = 0
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                result += dfs(row+1)
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False
            return result

        result = []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        return dfs(0)",O(n!)
"class Solution(object):
    def countArrangement(self, N):
        def countArrangementHelper(n, arr):
            if n <= 0:
                return 1
            count = 0
            for i in range(n):
                if arr[i] % n == 0 or n % arr[i] == 0:
                    arr[i], arr[n-1] = arr[n-1], arr[i]
                    count += countArrangementHelper(n - 1, arr)
                    arr[i], arr[n-1] = arr[n-1], arr[i]
            return count

        return countArrangementHelper(N, list(range(1, N+1)))",O(n!)
"class Solution(object):
    def constructDistancedSequence(self, n):
        def backtracking(n, i, result, lookup):
            if i == len(result):
                return True
            if result[i]:
                return backtracking(n, i+1, result, lookup)
            for x in reversed(range(1, n+1)):
                j = i if x == 1 else i+x
                if lookup[x] or j >= len(result) or result[j]:
                    continue
                result[i], result[j], lookup[x] = x, x, True
                if backtracking(n, i+1, result, lookup):
                    return True
                result[i], result[j], lookup[x] = 0, 0, False
            return False

        result, lookup = [0]*(2*n-1), [False]*(n+1)
        backtracking(n, 0, result, lookup)
        return result",O(n!)
"class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):
        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
            if visited in lookup:
                return lookup[visited]

            mask = 1
            for i in range(maxChoosableInteger):
                if visited & mask == 0:
                    if i + 1 >= desiredTotal or \
                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):
                        lookup[visited] = True
                        return True
                mask <<= 1
            lookup[visited] = False
            return False

        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
            return False

        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})",O(n!)
"class Solution(object):
    def grayCode(self, n):
        result = [0]
        for i in range(n):
            for n in reversed(result):
                result.append(1 << i | n)
        return result",O(2 ^ n)
"class Solution2(object):
    def grayCode(self, n):
        return [i >> 1 ^ i for i in range(1 << n)]",O(2 ^ n)
"class Solution2(object):
    def maxLength(self, arr):
        def bitset(s):
            result = 0
            for c in s:
                if result & power[ord(c)-ord('a')]:
                    return 0
                result |= power[ord(c)-ord('a')]
            return result
    
        bitsets = [bitset(x) for x in arr]
        result = 0
        for i in range(power[len(arr)]):
            curr_bitset, curr_len = 0, 0
            while i:
                j = i & -i 
                i ^= j
                j = log2[j] 
                if not bitsets[j] or (curr_bitset & bitsets[j]):
                    break
                curr_bitset |= bitsets[j]
                curr_len += len(arr[j])
            else:
                result = max(result, curr_len)
        return result",O(2 ^ n)
