code,label
"

class Solution(object):
    def minimumLines(self, stockPrices):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a
    
        stockPrices.sort()
        result = 0
        prev = None
        for i in range(1, len(stockPrices)):
            dy, dx = stockPrices[i][1]-stockPrices[i-1][1], stockPrices[i][0]-stockPrices[i-1][0]
            g = gcd(dy, dx)
            if not prev or prev != (dy//g, dx//g):
                prev = (dy//g, dx//g)
                result += 1
        return result
",nlogn
"

class Solution(object):
    def resultGrid(self, image, threshold):
        def check(i, j):
            return (all(abs(image[ni][nj]-image[ni+1][nj]) <= threshold for ni in range(i-1, i+1) for nj in range(j-1, j+2)) and
                    all(abs(image[ni][nj]-image[ni][nj+1]) <= threshold for ni in range(i-1, i+2) for nj in range(j-1, j+1)))
            
        result = [[0]*len(image[0]) for _ in range(len(image))]
        cnt = [[0]*len(image[0]) for _ in range(len(image))]
        for i in range(1, len(image)-1):
            for j in range(1, len(image[0])-1):
                if not check(i, j):
                    continue
                total = sum(image[ni][nj] for ni in range(i-1, i+2) for nj in range(j-1, j+2))//9
                for ni in range(i-1, i+2):
                    for nj in range(j-1, j+2):
                        cnt[ni][nj] += 1
                        result[ni][nj] += total
        for i in range(len(image)):
            for j in range(len(image[0])):
                if cnt[i][j]:
                    result[i][j] //= cnt[i][j]
                else:
                    result[i][j] = image[i][j]
        return result
",m * n
"

class Solution(object):
    def lastVisitedIntegers(self, words):
        PREV = ""prev""
        result, stk = [], []
        i = -1
        for x in words:
            if x == PREV:
                result.append(stk[i] if i >= 0 else -1)
                i -= 1
                continue
            stk.append(int(x))
            i = len(stk)-1
        return result
",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def increasingBST(self, root):
        def increasingBSTHelper(root, tail):
            if not root:
                return tail
            result = increasingBSTHelper(root.left, root)
            root.left = None
            root.right = increasingBSTHelper(root.right, tail)
            return result
        return increasingBSTHelper(root, None)

",n
"

class Solution(object):
    def minimumCost(self, m, n, horizontalCut, verticalCut):
        horizontalCut.sort()
        verticalCut.sort()
        result = 0
        cnt_h = cnt_v = 1
        while horizontalCut or verticalCut:
            if not verticalCut or (horizontalCut and horizontalCut[-1] > verticalCut[-1]):
                result += horizontalCut.pop()*cnt_h
                cnt_v += 1
            else:
                result += verticalCut.pop()*cnt_v
                cnt_h += 1
        return result


",mlogm + nlogn
"
class Solution2(object):
    def minimumCost(self, m, n, horizontalCut, verticalCut):
        horizontalCut.sort(reverse=True)
        verticalCut.sort(reverse=True)
        result = i = j = 0
        while i < len(horizontalCut) or j < len(verticalCut):
            if j == len(verticalCut) or (i < len(horizontalCut) and horizontalCut[i] > verticalCut[j]):
                result += horizontalCut[i]*(j+1)
                i += 1
            else:
                result += verticalCut[j]*(i+1)
                j += 1
        return result

",mlogm + nlogn
"

MOD = 10**9+7
FACT, INV, INV_FACT = [[1]*2 for _ in range(3)]
def nCr(n, k):
    if n < k:
        return 0
    while len(INV) <= n: 
        FACT.append(FACT[-1]*len(INV) % MOD)
        INV.append(INV[MOD%len(INV)]*(MOD-MOD//len(INV)) % MOD) 
        INV_FACT.append(INV_FACT[-1]*INV[-1] % MOD)
    return (FACT[n]*INV_FACT[n-k] % MOD) * INV_FACT[k] % MOD


class Solution(object):
    def minMaxSums(self, nums, k):
        MOD = 10**9+7
        nums.sort()
        result = 0
        cnt = 1
        for i in range(len(nums)):
            result = (result+(nums[i]+nums[~i])*cnt)%MOD
            cnt = (cnt*2-nCr(i, k-1)) % MOD
        return result


",nlogn
"
class Solution2(object):
    def minMaxSums(self, nums, k):
        MOD = 10**9+7
        nums.sort()
        result = 0
        cnt = 1
        for i in range(len(nums)):
            cnt = reduce(lambda accu, x: (accu+x)%MOD, (nCr(i, j) for j in range(min(i, k-1)+1)), 0)
            result = (result+(nums[i]+nums[~i])*cnt)%MOD
        return result
",nlogn + n * k
"

class Solution(object):
    def countFairPairs(self, nums, lower, upper):
        def count(x):
            cnt = 0
            left, right = 0, len(nums)-1
            while left < right:
                if nums[left]+nums[right] <= x:
                    cnt += right-left
                    left += 1
                else:
                    right -= 1
            return cnt
        
        nums.sort()
        return count(upper)-count(lower-1)
",nlogn
"

class Solution(object):
    def countCollisions(self, directions):
        result = cnt = 0
        smooth = 1
        for x in directions:
            if x == 'R':
                cnt += 1
            elif x == 'S' or (cnt or not smooth):
                result += cnt+int(x == 'L')
                cnt = smooth = 0
        return result
",n
"

class Solution(object):
    def transformArray(self, nums):
        cnt = 0
        for x in nums:
            if x%2:
                continue
            nums[cnt] = 0
            cnt += 1
        for i in range(cnt, len(nums)):
            nums[i] = 1
        return nums
",n
"

class Solution(object):
    def sumDistance(self, nums, s, d):
        MOD = 10**9+7
        for i in range(len(nums)):
            nums[i] += d if s[i] == 'R' else -d
        nums.sort()
        return reduce(lambda x, y: (x+y)%MOD, ((i-(len(nums)-(i+1)))*x for i, x in enumerate(nums)))
",nlogn
"
import collections
import functools



class Solution(object):
    def addBoldTag(self, s, dict):
        lookup = [0] * len(s)
        for d in dict:
            pos = s.find(d)
            while pos != -1:
                lookup[pos:pos+len(d)] = [1] * len(d)
                pos = s.find(d, pos + 1)

        result = []
        for i in range(len(s)):
            if lookup[i] and (i == 0 or not lookup[i-1]):
                result.append(""<b>"")
            result.append(s[i])
            if lookup[i] and (i == len(s)-1 or not lookup[i+1]):
                result.append(""</b>"")
        return """".join(result)


",n * d * l
"
class Solution2(object):
    def addBoldTag(self, s, words):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for i, word in enumerate(words):
            functools.reduce(dict.__getitem__, word, trie).setdefault(""_end"")

        lookup = [False] * len(s)
        for i in range(len(s)):
            curr = trie
            k = -1
            for j in range(i, len(s)):
                if s[j] not in curr:
                    break
                curr = curr[s[j]]
                if ""_end"" in curr:
                    k = j
            for j in range(i, k+1):
                lookup[j] = True

        result = []
        for i in range(len(s)):
            if lookup[i] and (i == 0 or not lookup[i-1]):
                result.append(""<b>"")
            result.append(s[i])
            if lookup[i] and (i == len(s)-1 or not lookup[i+1]):
                result.append(""</b>"")
        return """".join(result)

",n * l
"

class Solution(object):
    def largeGroupPositions(self, S):
        result = []
        i = 0
        for j in range(len(S)):
            if j == len(S)-1 or S[j] != S[j+1]:
                if j-i+1 >= 3:
                    result.append([i, j])
                i = j+1
        return result

",n
"
class Solution(object):
    def placeWordInCrossword(self, board, word):
        def get_val(mat, i, j, transposed):
            return mat[i][j] if not transposed else mat[j][i]

        def get_vecs(mat, transposed):
            for i in range(len(mat) if not transposed else len(mat[0])):
                yield (get_val(mat, i, j, transposed) for j in range(len(mat[0]) if not transposed else len(mat)))

        for direction in (lambda x: iter(x), reversed):
            for transposed in range(2):
                for row in get_vecs(board, transposed):
                    it, matched = direction(word), True
                    for c in row:
                        if c == 
                            if next(it, None) is None and matched:
                                return True
                            it, matched = direction(word), True
                            continue
                        if not matched:
                            continue
                        nc = next(it, None)
                        matched = (nc is not None) and c in (nc, ' ')
                    if (next(it, None) is None) and matched:
                        return True
        return False


",m * n
"class Solution2(object):
    def placeWordInCrossword(self, board, word):
        words = [word, word[::-1]]
        for mat in (board, list(zip(*board))):
            for row in mat:
                blocks = ''.join(row).split(
                for s in blocks:
                    if len(s) != len(word):
                        continue
                    for w in words:
                        if all(s[i] in (w[i], ' ') for i in range(len(s))):
                            return True
        return False
",m * n
"

class Solution(object):
    def totalStrength(self, strength):
        MOD = 10**9+7
        curr = 0
        prefix = [0]*(len(strength)+1)
        for i in range(len(strength)):
            curr = (curr+strength[i])%MOD
            prefix[i+1] = (prefix[i]+curr)%MOD
        stk, result = [-1], 0
        for i in range(len(strength)+1):
            while stk[-1] != -1 and (i == len(strength) or strength[stk[-1]] >= strength[i]):
                x, y, z = stk[-2]+1, stk.pop(), i-1
                result = (result+(strength[y]*((y-x+1)*(prefix[z+1]-prefix[y])-(z-y+1)*(prefix[y]-prefix[max(x-1, 0)]))))%MOD
            stk.append(i)
        return result


",n
"
class Solution2(object):
    def totalStrength(self, strength):
        MOD = 10**9+7
        prefix, prefix2 = [0]*(len(strength)+1), [0]*(len(strength)+1)
        for i in range(len(strength)):
            prefix[i+1] = (prefix[i]+strength[i])%MOD
            prefix2[i+1] = (prefix2[i]+strength[i]*(i+1))%MOD
        suffix, suffix2 = [0]*(len(strength)+1), [0]*(len(strength)+1)
        for i in reversed(range(len(strength))):
            suffix[i] = (suffix[i+1]+strength[i])%MOD
            suffix2[i] = (suffix2[i+1]+strength[i]*(len(strength)-i))%MOD
        stk, result = [-1], 0
        for i in range(len(strength)+1):
            while stk[-1] != -1 and (i == len(strength) or strength[stk[-1]] >= strength[i]):
                x, y, z = stk[-2]+1, stk.pop(), i-1
                result = (result+(strength[y]*((z-y+1)*((prefix2[y+1]-prefix2[x])-x*(prefix[y+1]-prefix[x]))+
                                               (y-x+1)*((suffix2[y+1]-suffix2[z+1])-(len(strength)-(z+1))*(suffix[y+1]-suffix[z+1])))))%MOD
            stk.append(i)
        return result
",n
"

class Solution(object):
    def timeTaken(self, edges):
        def topological_traversal():
            p = [-2]*len(adj)
            p[0] = -1
            topological_order = [0]
            for u in topological_order:
                for v in reversed(adj[u]):
                    if p[v] != -2:
                        continue
                    p[v] = u
                    topological_order.append(v)
            for u in reversed(topological_order):
                for v in adj[u]:
                    if v == p[u]:
                        continue
                    curr = [(1+int(v%2 == 0))+dp[v][0][0], v]
                    for i in range(len(dp[u])):
                        if curr > dp[u][i]:
                            curr, dp[u][i] = dp[u][i], curr

        def bfs():
            q = [(0, -1, 0)]
            while q:
                new_q = []
                for u, p, curr in q:
                    result[u] = max(dp[u][0][0], curr)
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u, (1+int(u%2 == 0))+max((dp[u][0][0] if dp[u][0][1] != v else dp[u][1][0]), curr)))
                q = new_q
    
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = [[[0, -1] for _ in range(2)] for _ in range(len(edges)+1)]
        topological_traversal()
        result = [0]*(len(edges)+1)
        bfs()
        return result


",n
"
class Solution2(object):
    def timeTaken(self, edges):
        def dfs1(u, p):
            for v in adj[u]:
                if v == p:
                    continue
                dfs1(v, u)
                curr = [(1+int(v%2 == 0))+dp[v][0][0], v]
                for i in range(len(dp[u])):
                    if curr > dp[u][i]:
                        curr, dp[u][i] = dp[u][i], curr

        def dfs2(u, p, curr):
            result[u] = max(dp[u][0][0], curr)
            for v in adj[u]:
                if v == p:
                    continue
                dfs2(v, u, (1+int(u%2 == 0))+max((dp[u][0][0] if dp[u][0][1] != v else dp[u][1][0]), curr))

        adj = [[] for _ in range(len(edges)+1)]
        for u, v, in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = [[[0, -1] for _ in range(2)] for _ in range(len(edges)+1)]
        dfs1(0, -1)
        result = [0]*(len(edges)+1)
        dfs2(0, -1, 0)
        return result
",n
"
class Solution(object):
    def findPeakGrid(self, mat):
        def get_vec(mat, i):
            return mat[i] if len(mat) > len(mat[0]) else (mat[j][i] for j in range(len(mat)))

        def check(mat, x):
            return max(get_vec(mat, x)) > max(get_vec(mat, x+1))

        left, right = 0, (max(len(mat), len(mat[0]))-1)-1
        while left <= right:
            mid = left + (right-left)//2
            if check(mat, mid):
                right = mid-1
            else:
                left = mid+1
        mav_val = max(get_vec(mat, left))
        result = [left, next(i for i, x in enumerate(get_vec(mat, left)) if x == mav_val)]
        return result if len(mat) > len(mat[0]) else result[::-1]
","min(n, m) * log(max(n, m))"
"

class Solution(object):
    def sortPeople(self, names, heights):
        order = list(range(len(names)))
        order.sort(key=lambda x: heights[x], reverse=True)
        return [names[i] for i in order]
",nlogn
"
class Solution(object):
    def longestBeautifulSubstring(self, word):
        result = 0
        l = cnt = 1
        for i in range(len(word)-1):
            if word[i] > word[i+1]:
                l = cnt = 1
            else:
                l += 1
                cnt += int(word[i] < word[i+1])
            if cnt == 5:
                result = max(result, l)
        return result
",n
"
class Solution(object):
    def minDifficulty(self, jobDifficulty, d):
        if len(jobDifficulty) < d:
            return -1
        
        dp = [[float(""inf"")]*len(jobDifficulty) for _ in range(d)]
        dp[0][0] = jobDifficulty[0]
        for i in range(1, len(jobDifficulty)):
            dp[0][i] = max(dp[0][i-1], jobDifficulty[i])
        for i in range(1, d):
            for j in range(i, len(jobDifficulty)):
                curr_max = jobDifficulty[j]
                for k in reversed(range(i, j+1)):
                    curr_max = max(curr_max, jobDifficulty[k])
                    dp[i][j] = min(dp[i][j], dp[i-1][k-1] + curr_max)
        return dp[d-1][len(jobDifficulty)-1]
",d * n^2
"
class InfiniteStream:
    def __next__(self):
        pass



class Solution(object):
    def findPattern(self, stream, pattern):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        prefix = getPrefix(pattern)
        i = j = -1
        while True:
            d = next(stream)
            i += 1
            while j+1 > 0 and pattern[j+1] != d:
                j = prefix[j]
            if pattern[j+1] == d:
                j += 1
            if j+1 == len(pattern):
                return i-j
        return -1
",p + n
"

class Solution(object):
    def minDays(self, n):
        def memoization(lookup, i):
            if i <= 1:
                return i
            if i not in lookup:
                lookup[i] = 1+min(i%2+memoization(lookup, i//2),
                                  i%3+memoization(lookup, i//3))
            return lookup[i]

        lookup = {}
        return memoization(lookup, n)


",(logn)^2
"class Solution2(object):
    def minDays(self, n):
        result = 0
        q, lookup = [n], set([n])
        while q:
            new_q = []
            for i in q: 
                if not i:
                    return result
                if i-1 not in lookup:
                    lookup.add(i-1)
                    new_q.append(i-1)
                if i%2 == 0 and i//2 not in lookup:
                    lookup.add(i//2)
                    new_q.append(i//2)
                if i%3 == 0 and i//3 not in lookup:
                    lookup.add(i//3)
                    new_q.append(i//3)
            result += 1
            q = new_q
        return result
",(logn)^2
"
class Solution(object):
    def subsetXORSum(self, nums):
        result = 0
        for x in nums:
            result |= x
        return result * 2**(len(nums)-1)
",n
"
import itertools



class Solution(object):
    def minimumCosts(self, regular, express, expressCost):
        result = []
        dp = [0, expressCost] 
        for r, e in zip(regular, express):
            dp = [min(dp[0]+r, dp[1]+e), min(dp[0]+(r+expressCost), dp[1]+e)]
            result.append(min(dp[0], dp[1]))
        return result
",n
"
import collections


class Solution(object):
    def minFlips(self, mat):
        directions = [(0, 0), (0, 1), (1, 0), (0, -1), (-1, 0)]
        start = sum(val << r*len(mat[0])+c for r, row in enumerate(mat) for c, val in enumerate(row))
        q = collections.deque([(start, 0)])
        lookup = {start}
        while q:
            state, step = q.popleft()
            if not state:
                return step
            for r in range(len(mat)):
                for c in range(len(mat[0])):
                    new_state = state
                    for dr, dc in directions:
                        nr, nc = r+dr, c+dc
                        if 0 <= nr < len(mat) and 0 <= nc < len(mat[0]):
                            new_state ^= 1 << nr*len(mat[0])+nc
                    if new_state in lookup:
                        continue
                    lookup.add(new_state)
                    q.append((new_state, step+1))
        return -1
",(m * n) * 2^(m * n)
"

class Solution(object):
    def maxDistance(self, s, k):
        result = x = y = 0
        for i, c in enumerate(s, 1):
            if c == 'E':
                x += 1
            elif c == 'W':
                x -= 1
            elif c == 'N':
                y += 1
            elif c == 'S':
                y -= 1
            result = max(result, min(abs(x)+abs(y)+2*k, i))
        return result
",n
"
import itertools


class Solution(object):
    def dietPlanPerformance(self, calories, k, lower, upper):
        total = sum(itertools.islice(calories, 0, k))
        result = int(total > upper)-int(total < lower)
        for i in range(k, len(calories)):
            total += calories[i]-calories[i-k]
            result += int(total > upper)-int(total < lower)
        return result
",n
"
import collections

    
class Solution(object):
    def uncommonFromSentences(self, A, B):
        count = collections.Counter(A.split())
        count += collections.Counter(B.split())
        return [word for word in count if count[word] == 1]

",m + n
"
import collections

class Solution(object):
    def longestArithSeqLength(self, A):
        dp = collections.defaultdict(int)
        for i in range(len(A)-1):
            for j in range(i+1, len(A)):
                v =  A[j]-A[i]
                dp[v, j] = max(dp[v, j], dp[v, i]+1)
        return max(dp.values())+1
",n^2
"
class Solution(object):
    def maxScore(self, cardPoints, k):
        result, total, curr, left = float(""inf""), 0, 0, 0
        for right, point in enumerate(cardPoints):
            total += point
            curr += point
            if right-left+1 > len(cardPoints)-k:
                curr -= cardPoints[left]
                left += 1
            if right-left+1 == len(cardPoints)-k:
                result = min(result, curr)
        return total-result
",n
"
from collections import Counter

class Solution(object):
    def originalDigits(self, s):
        cnts = [Counter(_) for _ in [""zero"", ""one"", ""two"", ""three"", \
                                     ""four"", ""five"", ""six"", ""seven"", \
                                     ""eight"", ""nine""]]

        order = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]

        unique_chars = ['z', 'o', 'w', 't', 'u', \
                        'f', 'x', 's', 'g', 'n']

        cnt = Counter(list(s))
        res = []
        for i in order:
            while cnt[unique_chars[i]] > 0:
                cnt -= cnts[i]
                res.append(i)
        res.sort()

        return """".join(map(str, res))

",n
"
class Solution(object):
    def longestCommonSubpath(self, n, paths):
        def RabinKarp(arr, x): 
            hashes = tuple([reduce(lambda h,x: (h*p+x)%MOD, (arr[i] for i in range(x)), 0) for p in P])
            powers = [pow(p, x, MOD) for p in P]
            lookup = {hashes}
            for i in range(x, len(arr)):
                hashes = tuple([(hashes[j]*P[j] - arr[i-x]*powers[j] + arr[i])%MOD for j in range(len(P))]) 
                lookup.add(hashes)
            return lookup
        
        def check(paths, x):
            intersect = RabinKarp(paths[0], x)
            for i in range(1, len(paths)):
                intersect = set.intersection(intersect, RabinKarp(paths[i], x))
                if not intersect:
                    return False
            return True

        MOD, P = 10**9+7, (113, 109) 
        left, right = 1, min(len(p) for p in paths)
        while left <= right:
            mid = left + (right-left)//2
            if not check(paths, mid):
                right = mid-1
            else:
                left = mid+1
        return right


",m * nlogn
"class Solution2(object):
    def longestCommonSubpath(self, n, paths):
        def RabinKarp(arr, x):
            h = reduce(lambda h,x: (h*P+x)%MOD, (arr[i] for i in range(x)), 0)
            power = pow(P, x, MOD)
            lookup = {h}
            for i in range(x, len(arr)):
                h = (h*P - arr[i-x]*power + arr[i])%MOD
                lookup.add(h)
            return lookup
        
        def check(paths, x):
            intersect = RabinKarp(paths[0], x)
            for i in range(1, len(paths)):
                intersect = set.intersection(intersect, RabinKarp(paths[i], x))
                if not intersect:
                    return False
            return True

        MOD, P = 10**11+19, max(x for p in paths for x in p)+1 
        left, right = 1, min(len(p) for p in paths)
        while left <= right:
            mid = left + (right-left)//2
            if not check(paths, mid):
                right = mid-1
            else:
                left = mid+1
        return right
",m * nlogn
"
class Solution(object):
    def toHexspeak(self, num):
        lookup = {0:'O', 1:'I'}
        for i in range(6):
            lookup[10+i] = chr(ord('A')+i)
        result = []
        n = int(num)
        while n:
            n, r = divmod(n, 16)
            if r not in lookup:
                return ""ERROR""
            result.append(lookup[r])
        return """".join(reversed(result))


",n
"class Solution2(object):
    def toHexspeak(self, num):
        result = hex(int(num)).upper()[2:].replace('0', 'O').replace('1', 'I')
        return result if all(c in ""ABCDEFOI"" for c in result) else ""ERROR""
",n
"
import heapq



class Solution(object):
    def minimumCost(self, nums, k, dist):
        def get_top(heap, total):
            while abs(heap[0][1]) < i-(1+dist):
                heapq.heappop(heap)
                total[0] -= 1
            return heap[0]
            
        def lazy_delete(heap, total):
            total[0] += 1
            if total[0] <= len(heap)-total[0]:
                return
            heap[:] = [x for x in heap if abs(x[1]) > i-(1+dist)]
            heapq.heapify(heap)
            total[0] = 0

        max_heap, min_heap = [], []
        total1, total2 = [0], [0]
        mn, curr = float(""inf""), 0
        for i in range(1, len(nums)):
            heapq.heappush(max_heap, (-nums[i], i))
            curr += nums[i]
            if i > k-1:
                x, idx = get_top(max_heap, total1)
                heapq.heappop(max_heap)
                curr -= -x
                heapq.heappush(min_heap, (-x, -idx))
            if i > 1+dist:
                x, idx = get_top(min_heap, total2)
                if (x, idx) <= (nums[i-(1+dist)], -(i-(1+dist))):
                    lazy_delete(min_heap, total2)
                else:
                    lazy_delete(max_heap, total1)
                    heapq.heappop(min_heap)
                    curr -= nums[i-(1+dist)]-x
                    heapq.heappush(max_heap, (-x, -idx))
            if i >= k-1:
                mn = min(mn, curr)
        return nums[0]+mn


",nlogd
"import heapq
import collections



class Solution2(object):
    def minimumCost(self, nums, k, dist):
        def get_top(heap, cnt, total):
            while heap[0] in cnt:
                x = heapq.heappop(heap)
                cnt[x] -= 1
                if cnt[x] == 0:
                    del cnt[x]
                total[0] -= 1
            return heap[0]

        def lazy_delete(heap, cnt, total, x):
            cnt[x] += 1
            total[0] += 1
            if total[0] <= len(heap)-total[0]:
                return
            new_heap = []
            for x in heap:
                if x not in cnt:
                    new_heap.append(x)
                    continue
                cnt[x] -= 1
                if cnt[x] == 0:
                    del cnt[x]
            total[0] = 0
            heapq.heapify(new_heap)
            heap[:] = new_heap

        max_heap, min_heap = [], []
        cnt1, cnt2 = collections.Counter(), collections.Counter()
        total1, total2 = [0], [0]
        mn, curr = float(""inf""), 0
        for i in range(1, len(nums)):
            heapq.heappush(max_heap, -nums[i])
            curr += nums[i]
            if (len(max_heap)-total1[0]) > k-1:
                x = get_top(max_heap, cnt1, total1)
                curr -= -x
                heapq.heappush(min_heap, -heapq.heappop(max_heap))
            if (len(max_heap)-total1[0])+(len(min_heap)-total2[0]) > 1+dist:
                x = get_top(min_heap, cnt2, total2)
                if x <= nums[i-(1+dist)]:
                    lazy_delete(min_heap, cnt2, total2, nums[i-(1+dist)])
                else:
                    lazy_delete(max_heap, cnt1, total1, -nums[i-(1+dist)])
                    heapq.heappop(min_heap)
                    curr -= nums[i-(1+dist)]-x
                    heapq.heappush(max_heap, -x)
            if len(max_heap)-total1[0] == k-1:
                mn = min(mn, curr)
        return nums[0]+mn


",nlogd
"from sortedcontainers import SortedList



class Solution3(object):
    def minimumCost(self, nums, k, dist):
        sl1, sl2 = SortedList(), SortedList()
        mn, curr = float(""inf""), 0
        for i in range(1, len(nums)):
            sl1.add(nums[i])
            curr += nums[i]
            if len(sl1) > k-1:
                curr -= sl1[-1]
                sl2.add(sl1.pop())
            if len(sl1)+len(sl2) > 1+dist:
                if sl2[0] <= nums[i-(1+dist)]:
                    sl2.remove(nums[i-(1+dist)])
                else:
                    sl1.remove(nums[i-(1+dist)])
                    curr -= nums[i-(1+dist)]-sl2[0]
                    sl1.add(sl2.pop(0))
            if len(sl1) == k-1:
                mn = min(mn, curr)
        return nums[0]+mn


",nlogd
"from sortedcontainers import SortedList



class Solution4(object):
    def minimumCost(self, nums, k, dist):
        sl = SortedList(nums[1:1+(1+dist)])
        mn = curr = sum(sl[:k-1])
        for i in range(1+(1+dist), len(nums)):
            sl.add(nums[i])
            curr += min(nums[i]-sl[k-1], 0)
            curr -= min(nums[i-(1+dist)]-sl[k-1], 0)
            sl.remove(nums[i-(1+dist)])
            mn = min(mn, curr)
        return nums[0]+mn
",nlogd
"
import itertools



class Solution(object):
    def minimumTime(self, jobs, workers):
        def ceil_divide(a, b):
            return (a+(b-1))//b

        jobs.sort()
        workers.sort()
        return max(ceil_divide(j, w) for j, w in zip(jobs, workers))
",nlogn
"
MAX_N = 1000
MOD = 10**9+7
dp = [[0]*MAX_N for _ in range(MAX_N)]
for i in range(len(dp)):
    dp[i][0] = 1
    for j in range(1, i+1):
        dp[i][j] = (dp[i-1][j-1] + dp[i-1][j])%MOD


class Solution(object):
    def numOfWays(self, nums):
        def iter_dfs(nums):
            result = [0]
            stk = [[1, [nums, result]]]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    nums, ret = params
                    if len(nums) <= 2:
                        ret[0] = 1
                        continue
                    left = [v for v in nums if v < nums[0]]
                    right = [v for v in nums if v > nums[0]]
                    ret[0] = dp[len(left)+len(right)][len(left)]
                    ret1, ret2 = [0], [0]
                    stk.append([2, [ret1, ret2, ret]])
                    stk.append([1, [right, ret2]])
                    stk.append([1, [left, ret1]])
                elif step == 2:
                    ret1, ret2, ret = params
                    ret[0] = ret[0]*ret1[0] % MOD
                    ret[0] = ret[0]*ret2[0] % MOD
            return result[0]

        return (iter_dfs(nums)-1)%MOD


",n^2
"class Solution(object):
    def numOfWays(self, nums):
        def dfs(nums):
            if len(nums) <= 2:
                return 1
            left = [v for v in nums if v < nums[0]]
            right = [v for v in nums if v > nums[0]]
            result = dp[len(left)+len(right)][len(left)]
            result = result*dfs(left) % MOD
            result = result*dfs(right) % MOD
            return result

        return (dfs(nums)-1)%MOD
",n^2
"

class Solution(object):
    def minimumCardPickup(self, cards):
        lookup = {}
        result = float(""inf"")
        for i, x in enumerate(cards):
            if x in lookup:
                result = min(result, i-lookup[x]+1)
            lookup[x] = i
        return result if result != float(""inf"") else -1
",n
"

class Solution(object):
    def percentageLetter(self, s, letter):
        return 100*s.count(letter)//len(s)
",n
"

class ListNode(object):
    def __init__(self, val=0, next=None):
        pass



class Solution(object):
    def splitCircularLinkedList(self, list):
        head1 = list
        slow, fast = head1, head1.__next__
        while head1  != fast.__next__:
            slow = slow.__next__
            fast = fast.next.__next__ if head1 != fast.next.__next__ else fast.__next__
        head2 = slow.__next__
        slow.next, fast.next = head1, head2
        return [head1, head2]
",n
"

class Solution(object):
    def findValueOfPartition(self, nums):
        nums.sort()
        return min(nums[i+1]-nums[i] for i in range(len(nums)-1))
",nlogn
"
import itertools


class Solution(object):
    def compareVersion(self, version1, version2):
        n1, n2 = len(version1), len(version2)
        i, j = 0, 0
        while i < n1 or j < n2:
            v1, v2 = 0, 0
            while i < n1 and version1[i] != '.':
                v1 = v1 * 10 + int(version1[i])
                i += 1
            while j < n2 and version2[j] != '.':
                v2 = v2 * 10 + int(version2[j])
                j += 1
            if v1 != v2:
                return 1 if v1 > v2 else -1
            i += 1
            j += 1

        return 0

",n
"

class Solution2(object):
    def compareVersion(self, version1, version2):
        v1, v2 = version1.split("".""), version2.split(""."")

        if len(v1) > len(v2):
            v2 += ['0' for _ in range(len(v1) - len(v2))]
        elif len(v1) < len(v2):
            v1 += ['0' for _ in range(len(v2) - len(v1))]

        i = 0
        while i < len(v1):
            if int(v1[i]) > int(v2[i]):
                return 1
            elif int(v1[i]) < int(v2[i]):
                return -1
            else:
                i += 1

        return 0

    def compareVersion2(self, version1, version2):
        v1 = [int(x) for x in version1.split('.')]
        v2 = [int(x) for x in version2.split('.')]
        while len(v1) != len(v2):
            if len(v1) > len(v2):
                v2.append(0)
            else:
                v1.append(0)
        return cmp(v1, v2)

    def compareVersion3(self, version1, version2):
        splits = (list(map(int, v.split('.'))) for v in (version1, version2))
        return cmp(*list(zip(*itertools.zip_longest(*splits, fillvalue=0))))

    def compareVersion4(self, version1, version2):
        main1, _, rest1 = ('0' + version1).partition('.')
        main2, _, rest2 = ('0' + version2).partition('.')
        return cmp(int(main1), int(main2)) or len(rest1 + rest2) and self.compareVersion4(rest1, rest2)


",n
"
class Solution(object):
    def minSwaps(self, s):
        result = curr = 0
        for c in s:
            if c == ']':
                curr += 1
                result = max(result, curr)
            else:
                curr -= 1
        return (result+1)//2
",n
"
class Solution(object):
    def combinationSum4(self, nums, target):
        dp = [0] * (target+1)
        dp[0] = 1
        nums.sort()

        for i in range(1, target+1):
            for j in range(len(nums)):
                if nums[j] <= i:
                    dp[i] += dp[i - nums[j]]
                else:
                    break

        return dp[target]

",nlon + n * t
"
import itertools


class Solution(object):
    def checkArithmeticSubarrays(self, nums, l, r):
        def is_arith(n):
            mx, mn, lookup = max(n), min(n), set(n)
            if mx == mn:
                return True
            d, r = divmod(mx-mn, len(n)-1)
            if r:
                return False
            return all(i in lookup for i in range(mn, mx, d))
    
        result = []
        for left, right in zip(l, r):
            result.append(is_arith(nums[left:right+1]))
        return result
",n * q
"
class Solution(object):

    def __init__(self, n):
        self.__i = 0      
        self.__values = [None]*n

    def insert(self, id, value):
        id -= 1
        self.__values[id] = value
        result = []
        if self.__i != id:
            return result
        while self.__i < len(self.__values) and self.__values[self.__i]:
            result.append(self.__values[self.__i])
            self.__i += 1
        return result
",1
"
class Solution(object):
    def minEatingSpeed(self, piles, H):
        def possible(piles, H, K):
            return sum((pile-1)//K+1 for pile in piles) <= H

        left, right = 1, max(piles)
        while left <= right:
            mid = left + (right-left)//2
            if possible(piles, H, mid):
                right = mid-1
            else:
                left = mid+1
        return left

",nlogr
"
class Solution(object):
    def checkStraightLine(self, coordinates):
        i, j = coordinates[:2]
        return all(i[0] * j[1] - j[0] * i[1] +
                   j[0] * k[1] - k[0] * j[1] +
                   k[0] * i[1] - i[0] * k[1] == 0
                   for k in coordinates)
",n
"
class Solution(object):
    def maxNumOfSubstrings(self, s):
        def find_right_from_left(s, first, last, left):
            right, i = last[ord(s[left])-ord('a')], left
            while i <= right:
                if first[ord(s[i])-ord('a')] < left:
                    return -1
                right = max(right, last[ord(s[i])-ord('a')])
                i += 1
            return right
            
        first, last = [float(""inf"")]*26, [float(""-inf"")]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        result = [""""]
        right = float(""inf"")
        for left, c in enumerate(s):
            if left != first[ord(c)-ord('a')]:
                continue
            new_right = find_right_from_left(s, first, last, left)
            if new_right == -1:
                continue
            if left > right:
                result.append("""")
            right = new_right
            result[-1] = s[left:right+1]
        return result


",n
"class Solution2(object):
    def maxNumOfSubstrings(self, s):
        def find_right_from_left(s, first, last, left):
            right, i = last[ord(s[left])-ord('a')], left
            while i <= right:
                if first[ord(s[i])-ord('a')] < left:
                    return -1
                right = max(right, last[ord(s[i])-ord('a')])
                i += 1
            return right

        first, last = [float(""inf"")]*26, [float(""-inf"")]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        intervals = []
        for c in range(len(first)):
            if first[c] == float(""inf""):
                continue
            left, right = first[c], find_right_from_left(s, first, last, first[c])
            if right != -1:
                intervals.append((right, left))
        intervals.sort() 
        result, prev = [], -1
        for right, left in intervals:
            if left <= prev:
                continue
            result.append(s[left:right+1])
            prev = right
        return result
",n
"

class Solution(object):
    def separateSquares(self, squares):
        class SegmentTreeRecu(object):
            def __init__(self, sorted_x):
                self.sorted_x = sorted_x
                n = len(sorted_x)-1
                l = 1<<((n-1).bit_length()+1)
                self.tree = [0]*l
                self.cnt = [0]*l
        
            def update(self, ql, qr, v, l, r, i): 
                if ql >= r or qr <= l:
                    return
                if ql <= l and r <= qr:
                    self.cnt[i] += v
                else:
                    m = l+(r-l)//2
                    self.update(ql, qr, v, l, m, 2*i)
                    self.update(ql, qr, v, m, r, 2*i+1)
                if self.cnt[i] > 0:
                    self.tree[i] = self.sorted_x[r]-self.sorted_x[l]
                else:
                    if r-l == 1:
                        self.tree[i] = 0
                    else:
                        self.tree[i] = self.tree[2*i]+self.tree[2*i+1]
    
        events = []
        x_set = set()
        for x, y, l in squares:
            events.append((y, 1, x, x+l))
            events.append((y+l, -1, x, x+l))
            x_set.add(x)
            x_set.add(x+l)
        events.sort(key=lambda e: e[0])
        sorted_x = sorted(x_set) 
        x_to_idx = {x:i for i, x in enumerate(sorted_x)}
        st = SegmentTreeRecu(sorted_x)
        prev = events[0][0]
        intervals = []
        for y, v, x1, x2 in events:
            if y != prev:
                intervals.append([prev, y, st.tree[1]])
                prev = y
            st.update(x_to_idx[x1], x_to_idx[x2], v, 0, len(sorted_x)-1, 1)
        expect = sum((y2-y1)*curr for y1, y2, curr in intervals)/2.0
        total = 0.0
        for y1, y2, curr in intervals:
            if total+(y2-y1)*curr >= expect:
                break
            total += (y2-y1)*curr
        return y1+(expect-total)/curr
",nlogn
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def getLonelyNodes(self, root):
        result = []
        stk = [root]
        while stk:
            node = stk.pop()
            if not node:
                continue
            if node.left and not node.right:
                result.append(node.left.val)
            elif node.right and not node.left:
                result.append(node.right.val)
            stk.append(node.right)
            stk.append(node.left)
        return result


",n
"class Solution2(object):
    def getLonelyNodes(self, root):
        def dfs(node, result):
            if not node:
                return
            if node.left and not node.right:
                result.append(node.left.val)
            elif node.right and not node.left:
                result.append(node.right.val)
            dfs(node.left, result)
            dfs(node.right, result)

        result = []
        dfs(root, result)
        return result
",n
"
class Solution(object):
    def getDescentPeriods(self, prices):
        result = l = 0
        for i in range(len(prices)):
            l += 1
            if i+1 == len(prices) or prices[i]-1 != prices[i+1]:
                result += l*(l+1)//2
                l = 0
        return result
",n
"
import bisect


class Solution(object):
    def findClosestElements(self, arr, k, x):
        i = bisect.bisect_left(arr, x)
        left, right = i-1, i
        while k:
            if right >= len(arr) or \
               (left >= 0 and abs(arr[left]-x) <= abs(arr[right]-x)):
                left -= 1
            else:
                right += 1
            k -= 1
        return arr[left+1:right]

",logn + k
"
import heapq


class Solution(object):
    def maxEvents(self, events):
        events.sort(reverse=True)
        min_heap = []
        result = 0
        for d in range(1, max(events, key=lambda x:x[1])[1]+1):
            while events and events[-1][0] == d:
                heapq.heappush(min_heap, events.pop()[1])
            while min_heap and min_heap[0] == d-1:
                heapq.heappop(min_heap)
            if not min_heap:
                continue
            heapq.heappop(min_heap)
            result += 1       
        return result
",r + nlogn
"
class Solution(object):
    def maximumScore(self, nums, multipliers):
        dp = [0]*(len(multipliers)+1)
        for l, m in enumerate(reversed(multipliers), start=len(nums)-len(multipliers)):
            dp = [max(m*nums[i]+dp[i+1], m*nums[i+l]+dp[i]) for i in range(len(dp)-1)]
        return dp[0]
",m^2
"

class Solution(object):
    def maximumSumOfHeights(self, maxHeights):
        left = [0]*len(maxHeights)
        stk = [-1]
        curr = 0
        for i in range(len(maxHeights)):
            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:
                j = stk.pop()
                curr -= (j-stk[-1])*maxHeights[j]
            curr += (i-stk[-1])*maxHeights[i]
            stk.append(i)
            left[i] = curr
        stk = [len(maxHeights)]
        result = right = curr = 0
        for i in reversed(range(len(maxHeights))):
            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:
                j = stk.pop()
                curr -= (stk[-1]-j)*maxHeights[j]
            curr += (stk[-1]-i)*maxHeights[i]
            stk.append(i)
            right = curr
            result = max(result, left[i]+right-maxHeights[i])
        return result
",n
"
class Solution(object):
    def decode(self, encoded, first):
        result = [first]
        for x in encoded:
            result.append(result[-1]^x)
        return result
",n
"
import collections


class Solution(object):
    def canReach(self, arr, start):
        q, lookup = collections.deque([start]), set([start])
        while q:
            i = q.popleft()
            if not arr[i]:
                return True
            for j in [i-arr[i], i+arr[i]]:
                if 0 <= j < len(arr) and j not in lookup:
                    lookup.add(j)
                    q.append(j) 
        return False
",n
"
import bisect
from functools import reduce


class Solution(object):
    def countRoutes(self, locations, start, finish, fuel):
        MOD = 10**9+7

        s, f = locations[start], locations[finish]
        locations.sort()
        start, finish = bisect.bisect_left(locations, s), bisect.bisect_left(locations, f)

        left = [[0]*(fuel+1) for _ in range(len(locations))] 
        right = [[0]*(fuel+1) for _ in range(len(locations))] 
        for f in range(1, fuel+1):
            for j in range(len(locations)-1):
                d = locations[j+1]-locations[j]
                if f > d:
                    left[j][f] = (right[j+1][f-d] + 2*left[j+1][f-d] % MOD) % MOD
                elif f == d:
                    left[j][f] = int(j+1 == start)
            for j in range(1, len(locations)):
                d = locations[j]-locations[j-1]
                if f > d:
                    right[j][f] = (left[j-1][f-d] + 2*right[j-1][f-d] % MOD) % MOD
                elif f == d:
                    right[j][f] = int(j-1 == start)
        result = int(start == finish)
        for f in range(1, fuel+1):
            result = ((result + left[finish][f]) % MOD + right[finish][f]) % MOD
        return result


",nlogn + n * f
"class Solution2(object):
    def countRoutes(self, locations, start, finish, fuel):
        MOD = 10**9+7
        dp = [[0]*(fuel+1) for _ in range(len(locations))]
        dp[start][0] = 1
        for f in range(fuel+1):
            for i in range(len(locations)):
                for j in range(len(locations)):
                    if i == j:
                        continue
                    d = abs(locations[i]-locations[j])
                    if f-d < 0:
                        continue
                    dp[i][f] = (dp[i][f]+dp[j][f-d])%MOD
        return reduce(lambda x, y: (x+y)%MOD, dp[finish])
",n^2 * f
"
class Solution(object):
    def getAverages(self, nums, k):
        total, l = 0, 2*k+1
        result = [-1]*len(nums)
        for i in range(len(nums)):
            total += nums[i]
            if i-l >= 0:
                total -= nums[i-l]
            if i >= l-1:
                result[i-k] = total//l
        return result
",n
"
class Solution(object):
    def addOperators(self, num, target):
        result, expr = [], []
        val, i = 0, 0
        val_str = """"
        while i < len(num):
            val = val * 10 + ord(num[i]) - ord('0')
            val_str += num[i]
            if str(val) != val_str:
                break
            expr.append(val_str)
            self.addOperatorsDFS(num, target, i + 1, 0, val, expr, result)
            expr.pop()
            i += 1
        return result

    def addOperatorsDFS(self, num, target, pos, operand1, operand2, expr, result):
        if pos == len(num) and operand1 + operand2 == target:
            result.append("""".join(expr))
        else:
            val, i = 0, pos
            val_str = """"
            while i < len(num):
                val = val * 10 + ord(num[i]) - ord('0')
                val_str += num[i]
                if str(val) != val_str:
                    break

                expr.append(""+"" + val_str)
                self.addOperatorsDFS(num, target, i + 1, operand1 + operand2, val, expr, result)
                expr.pop()

                expr.append(""-"" + val_str)
                self.addOperatorsDFS(num, target, i + 1, operand1 + operand2, -val, expr, result)
                expr.pop()

                expr.append(""*"" + val_str)
                self.addOperatorsDFS(num, target, i + 1, operand1, operand2 * val, expr, result)
                expr.pop()

                i += 1


",4^n
"

class Solution(object):
    def longestDecomposition(self, text):
        def compare(text, l, s1, s2):
            for i in range(l):
                if text[s1+i] != text[s2+i]:
                    return False
            return True

        MOD = 10**9+7
        D = 26
        result = 0
        left, right, l, pow_D = 0, 0, 0, 1
        for i in range(len(text)):
            left = (D*left + (ord(text[i])-ord('a'))) % MOD
            right = (pow_D*(ord(text[-1-i])-ord('a')) + right) % MOD
            l += 1
            pow_D = (pow_D*D) % MOD 
            if left == right and compare(text, l, i-l+1, len(text)-1-i):
                result += 1
                left, right, l, pow_D = 0, 0, 0, 1
        return result
",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sortedArrayToBST(self, nums):
        return self.sortedArrayToBSTRecu(nums, 0, len(nums))

    def sortedArrayToBSTRecu(self, nums, start, end):
        if start == end:
            return None
        mid = start + self.perfect_tree_pivot(end - start)
        node = TreeNode(nums[mid])
        node.left = self.sortedArrayToBSTRecu(nums, start, mid)
        node.right = self.sortedArrayToBSTRecu(nums, mid + 1, end)
        return node

    def perfect_tree_pivot(self, n):
        x = 1
        x = 1 << (n.bit_length() - 1) 

        if x // 2 - 1 <= (n - x):
            return x - 1 
        else:
            return n - x // 2 

",n
"class Solution2(object):
    def sortedArrayToBST(self, nums):
        self.iterator = iter(nums)
        return self.helper(0, len(nums))
    
    def helper(self, start, end):
        if start == end:
            return None
        
        mid = (start + end) // 2
        left = self.helper(start, mid)
        current = TreeNode(next(self.iterator))
        current.left = left
        current.right = self.helper(mid+1, end)
        return current
",n
"
class Solution(object):
    def minimumSize(self, nums, maxOperations):
        def check(nums, maxOperations, x):
            return sum((num+x-1)//x-1 for num in nums) <= maxOperations
    
        left, right = 1, max(nums)
        while left <= right:
            mid = left + (right-left)//2
            if check(nums, maxOperations, mid):
                right = mid-1
            else:
                left = mid+1
        return left
",nlogm
"

class Solution(object):
    def longestIdealString(self, s, k):
        dp = [0]*26
        for c in s:
            x = ord(c)-ord('a')
            dp[x] = max(dp[i] for i in range(max(x-k, 0), min(x+k+1, 26)))+1
        return max(dp)
",n
"

class Solution(object):
    def minChanges(self, n, k):
        def popcount(x):
            return bin(x).count('1')

        return popcount(n^k) if n&k == k else -1


",logn
"
class Solution2(object):
    def minChanges(self, n, k):
        def popcount(x):
            return bin(x).count('1')

        return popcount(n^k) if n|(n^k) == n else -1
",logn
"

class Node(object):
    def __init__(self, val="" "", left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def expTree(self, s):
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(Node(val=operators.pop(), left=left, right=right))

        precedence = {'+':0, '-':0, '*':1, '/':1}
        operands, operators, operand = [], [], 0
        for i in range(len(s)):
            if s[i].isdigit():
                operand = operand*10 + int(s[i])
                if i == len(s)-1 or not s[i+1].isdigit():
                    operands.append(Node(val=str(operand)))
                    operand = 0
            elif s[i] == '(':
                operators.append(s[i])
            elif s[i] == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif s[i] in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] >= precedence[s[i]]:
                    compute(operands, operators)
                operators.append(s[i])
        while operators:
            compute(operands, operators)
        return operands[-1]
",n
"
class Solution(object):
    def maxSumMinProduct(self, nums):
        MOD = 10**9+7
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        stk, result = [-1], 0
        for i in range(len(nums)+1):
            while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] >= nums[i]):
                result = max(result, nums[stk.pop()]*(prefix[(i-1)+1]-prefix[stk[-1]+1]))
            stk.append(i) 
        return result%MOD
",n
"
import collections


class Solution(object):
    def canReorderDoubled(self, A):
        count = collections.Counter(A)
        for x in sorted(count, key=abs):
            if count[x] > count[2*x]:
                return False
            count[2*x] -= count[x]
        return True
",n + klogk
"
import collections



class Solution(object):
    def medianOfUniquenessArray(self, nums):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(k):
            result = 0
            cnt = collections.Counter()
            left = 0
            for right in range(len(nums)):
                cnt[nums[right]] += 1
                while len(cnt) == k+1:
                    cnt[nums[left]] -= 1
                    if cnt[nums[left]] == 0:
                        del cnt[nums[left]]
                    left += 1
                result += right-left+1
            return result >= total-result

        total = (len(nums)+1)*len(nums)//2
        return binary_search(1, len(set(nums)), check)
",nlogn
"
class Solution(object):
    def areNumbersAscending(self, s):
        prev = curr = -1
        for i, c in enumerate(s):
            if c.isdigit():
                curr = max(curr, 0)*10+int(c)
                continue
            if prev != -1 and curr != -1 and prev >= curr:
                return False
            if curr != -1:
                prev = curr
            curr = -1            
        return curr == -1 or prev < curr


",n
"class Solution2(object):
    def areNumbersAscending(self, s):
        nums = [int(x) for x in s.split() if x.isdigit()]
        return all(nums[i] < nums[i+1] for i in range(len(nums)-1))
",n
"
class Solution(object):
    def kthFactor(self, n, k):
        def kth_factor(n, k=0):
            mid = None
            i = 1
            while i*i <= n:
                if not n%i:
                    mid = i
                    k -= 1
                    if not k:
                        break
                i += 1
            return mid, -k
    
        mid, count = kth_factor(n)
        total = 2*count-(mid*mid == n)
        if k > total:
            return -1
        result = kth_factor(n, k if k <= count else total-(k-1))[0]
        return result if k <= count else n//result


",sqrt(n)
"class Solution2(object):
    def kthFactor(self, n, k):
        result = []
        i = 1
        while i*i <= n:
            if not n%i:
                if i*i != n:
                    result.append(i)
                k -= 1
                if not k:
                    return i
            i += 1
        return -1 if k > len(result) else n//result[-k]
",sqrt(n)
"
from collections import deque


class Solution(object):
    def maxSlidingWindow(self, nums, k):
        result, dq = [], deque()
        for i in range(len(nums)):
            if dq and i-dq[0] == k:
                dq.popleft()
            while dq and nums[dq[-1]] <= nums[i]:
                dq.pop()
            dq.append(i)
            if i >= k-1:
                result.append(nums[dq[0]])
        return result
",n
"

class Solution(object):
    def furthestDistanceFromOrigin(self, moves):
        curr = cnt = 0
        for x in moves:
            if x == 'L':
                curr -= 1
            elif x == 'R':
                curr += 1
            else:
                cnt += 1
        return abs(curr)+cnt
",n
"

class Solution(object):
    def maxDistance(self, side, points, k):
        def binary_search_right(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right

        def check(d):
            intervals = [(0, 0, 1)]
            i = 0
            for right in range(1, len(p)):
                left, cnt = right, 1
                while i < len(intervals):
                    l, r, c = intervals[i]
                    if p[right]-p[r] < d:
                        break
                    if (p[l]+4*side)-p[right] >= d:
                        if c+1 >= cnt:
                            cnt = c+1
                            left = l
                    i += 1
                intervals.append((left, right, cnt))
            return max(x[2] for x in intervals) >= k

        p = []
        for x, y in points:
            if x == 0:
                p.append(0*side+y)
            elif y == side:
                p.append(1*side+x)
            elif x == side:
                p.append(2*side+(side-y))
            else:
                p.append(3*side+(side-x))
        p.sort()
        return binary_search_right(1, 4*side//k, check)


",nlogn + nlogs
"
class Solution2(object):
    def maxDistance(self, side, points, k):
        def binary_search_right(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right

        def check(d):
            intervals = [(0, 0, 1)]
            i = 0
            for right in range(1, len(sorted_points)):
                left, cnt = right, 1
                while i < len(intervals):
                    l, r, c = intervals[i]
                    if abs(sorted_points[right][0]-sorted_points[r][0])+abs(sorted_points[right][1]-sorted_points[r][1]) < d:
                        break
                    if abs(sorted_points[right][0]-sorted_points[l][0])+abs(sorted_points[right][1]-sorted_points[l][1]) >= d:
                        if c+1 >= cnt:
                            cnt = c+1
                            left = l
                    i += 1
                intervals.append((left, right, cnt))
            return max(x[2] for x in intervals) >= k

        p = [[] for _ in range(4)]
        for x, y in points:
            if x == 0:
                p[0].append((x, y))
            elif y == side:
                p[1].append((x, y))
            elif x == side:
                p[2].append((x, y))
            else:
                p[3].append((x, y))
        p[0].sort()
        p[1].sort()
        p[2].sort(reverse=True)
        p[3].sort(reverse=True)
        sorted_points = [x for i in range(4) for x in p[i]]
        return binary_search_right(1, 4*side//k, check)


",nlogn + nlogs
"import bisect



class Solution3(object):
    def maxDistance(self, side, points, k):
        def binary_search_right(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right

        def check(i, d):
            j = i
            for _ in range(k-1):
                j = bisect.bisect_left(p, p[j]+d, lo=j+1)
                if j == len(p):
                    return False
            return (p[i]+4*side)-p[j] >= d

        p = []
        for x, y in points:
            if x == 0:
                p.append(0*side+y)
            elif y == side:
                p.append(1*side+x)
            elif x == side:
                p.append(2*side+(side-y))
            else:
                p.append(3*side+(side-x))
        p.sort()
        result = 1
        for i in range(len(p)-k+1):
            if p[-1]-p[i] <= result*(k-1): 
                break
            result = binary_search_right(result+1, 4*side//k, lambda x: check(i, x))
        return result


",nlogn + n * (k * logn) * logs
"import bisect



class Solution4(object):
    def maxDistance(self, side, points, k):
        def binary_search_right(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right

        def check(d):
            for i in range(len(points)):
                j = i
                for _ in range(k-1):
                    j = bisect.bisect_left(p, p[j]+d, lo=j+1, hi=i+len(points))
                    if j == i+len(points):
                        break
                else:
                    if p[i+len(points)]-p[j] >= d:
                        return True
            return False

        p = []
        for x, y in points:
            if x == 0:
                p.append(0*side+y)
            elif y == side:
                p.append(1*side+x)
            elif x == side:
                p.append(2*side+(side-y))
            else:
                p.append(3*side+(side-x))
        p.sort()
        p += [x+4*side for x in p]
        return binary_search_right(1, 4*side//k, check)
",nlogn + (n * k * logn) * logs
"
class Solution(object):
    def newInteger(self, n):
        result, base = 0, 1
        while n > 0:
            result += (n%9) * base
            n /= 9
            base *= 10
        return result

",logn
"
import heapq



class Solution(object):
    def mostBooked(self, n, meetings):
        meetings.sort()
        min_heap = [(meetings[0][0], i) for i in range(n)]
        result = [0]*n
        for s, e in meetings:
            while min_heap and min_heap[0][0] < s:
                _, i = heapq.heappop(min_heap)
                heapq.heappush(min_heap, (s, i))
            e2, i = heapq.heappop(min_heap)
            heapq.heappush(min_heap, (e2+(e-s), i))
            result[i] += 1
        return max(range(n), key=lambda x:result[x])


",mlogm + n + mlogn
"import heapq



class Solution2(object):
    def mostBooked(self, n, meetings):
        meetings.sort()
        unused, used = list(range(n)), []
        result = [0]*n
        for s, e in meetings:
            while used and used[0][0] <= s:
                _, i = heapq.heappop(used)
                heapq.heappush(unused, i)
            if unused:
                i = heapq.heappop(unused)
                heapq.heappush(used, (e, i))
            else:
                e2, i = heapq.heappop(used)
                heapq.heappush(used, (e2+(e-s), i))
            result[i] += 1
        return max(range(n), key=lambda x:result[x])
",mlogm + n + mlogn
"

def linear_sieve_of_eratosthenes(n): 
    primes = []
    spf = [-1]*(n+1) 
    for i in range(2, n+1):
        if spf[i] == -1:
            spf[i] = i
            primes.append(i)
        for p in primes:
            if i*p > n or p > spf[i]:
                break
            spf[i*p] = p
    return spf


MAX_N = 100
SPF = linear_sieve_of_eratosthenes(MAX_N)
class Solution(object):
    def maximumPrimeDifference(self, nums):
        left = next(i for i in range(len(nums)) if SPF[nums[i]] == nums[i])
        right = next(i for i in reversed(range(len(nums))) if SPF[nums[i]] == nums[i])
        return right-left
",r + n
"
import collections



class Solution(object):
    def verticalOrder(self, root):
        cols = collections.defaultdict(list)
        queue = [(root, 0)]
        for node, i in queue:
            if node:
                cols[i].append(node.val)
                queue += (node.left, i - 1), (node.right, i + 1)
        return [cols[i] for i in range(min(cols.keys()),
                                        max(cols.keys()) + 1)] if cols else []

",n
"

class Solution(object):
    def sumRemoteness(self, grid):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        def bfs(i, j):
            total, cnt = grid[i][j], 1
            grid[i][j] = -1
            q = [(i, j)]
            while q:
                new_q = []
                for i, j in q:
                    for di, dj in DIRECTIONS:
                        ni, nj = i+di, j+dj
                        if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj] != -1):
                            continue
                        total += grid[ni][nj]
                        cnt += 1
                        grid[ni][nj] = -1
                        new_q.append((ni, nj))
                q = new_q
            return total, cnt
    
        groups = [bfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] != -1]
        total = sum(t for t, _ in groups)
        return sum((total-t)*c for t, c in groups)
",n^2
"
class Solution(object):
    def timeRequiredToBuy(self, tickets, k):
        return sum(min(x, tickets[k] if i <= k else tickets[k]-1) for i, x in enumerate(tickets))
",n
"
class Solution(object):
    def kMirror(self, k, n):
        def mirror(n, base, odd):
            result = n
            if odd:
                n //= base
            while n:
                result = result*base+n%base
                n //= base
            return result

        def num_gen(base):
            prefix_num, total = [1]*2, [base]*2
            odd = 1
            while True:
                x = mirror(prefix_num[odd], base, odd)
                prefix_num[odd] += 1
                if prefix_num[odd] == total[odd]:
                    total[odd] *= base
                    odd ^= 1
                yield x

        def reverse(n, base):
            result = 0
            while n:
                result = result*base+n%base
                n = n//base
            return result

        def mirror_num(gen, base):
            while True:
                x = next(gen)
                if x == reverse(x, base):
                    break
            return x

        base1, base2 = k, 10 
        gen = num_gen(base1)
        return sum(mirror_num(gen, base2) for _ in range(n))


",10^6
"class Solution2(object):
    def kMirror(self, k, n):
        def num_gen(k):
            digits = ['0']
            while True:
                for i in range(len(digits)//2, len(digits)): 
                    if int(digits[i])+1 < k:
                        digits[i] = digits[-1-i] = str(int(digits[i])+1)
                        break
                    digits[i] = digits[-1-i] = '0'
                else:
                    digits.insert(0, '1')
                    digits[-1] = '1'
                yield """".join(digits)
        
        def mirror_num(gen):
            while True:
                x = int(next(gen, k), k)
                if str(x) == str(x)[::-1]:
                    break
            return x

        gen = num_gen(k)
        return sum(mirror_num(gen) for _ in range(n))
",10^6
"

class Solution(object):
    def passThePillow(self, n, time):
        return n-abs((n-1)-(time%(2*(n-1))))
",1
"

class Solution(object):
    def maximumsSplicedArray(self, nums1, nums2):
        def kadane(a):
            result = curr = 0
            for x in a:
                curr = max(curr+x, 0)
                result = max(result, curr)
            return result
    
        return max(sum(nums1)+kadane((nums2[i]-nums1[i] for i in range(len(nums1)))),
                   sum(nums2)+kadane((nums1[i]-nums2[i] for i in range(len(nums2)))))
",n
"
class Solution(object):
    def canJump(self, A):
        reachable = 0
        for i, length in enumerate(A):
            if i > reachable:
                break
            reachable = max(reachable, i + length)
        return reachable >= len(A) - 1

",n
"

class Solution(object):
    def isZeroArray(self, nums, queries):
        events = [0]*(len(nums)+1)
        for l, r in queries:
            events[l] += 1
            events[r+1] -= 1
        curr = 0
        for i in range(len(nums)):
            curr += events[i]
            if nums[i] > curr:
                return False
        return True
",n + q
"
class Trie(object):
    def __init__(self, bit_length):
        self.__root = {}
        self.__bit_length = bit_length
        
    def insert(self, num):
        node = self.__root
        for i in reversed(range(self.__bit_length)):
            curr = (num>>i) & 1
            if curr not in node:
                node[curr] = {}
            node = node[curr]
                
    def query(self, num):
        if not self.__root: 
            return -1
        node, result = self.__root, 0
        for i in reversed(range(self.__bit_length)):
            curr = (num>>i) & 1
            if 1^curr in node:
                node = node[1^curr]
                result |= 1<<i
            else:
                node = node[curr]
        return result


class Solution(object):
    def maximizeXor(self, nums, queries):
        nums.sort()
        max_val = max(nums[-1], max(queries, key=lambda x: x[0])[0])
        queries = sorted(enumerate(queries), key=lambda x: x[1][1])        
        trie = Trie(max_val.bit_length())
        result = [-1]*len(queries)
        j = 0
        for i, (x, m) in queries:
            while j < len(nums) and nums[j] <= m:
                trie.insert(nums[j])
                j += 1
            result[i] = trie.query(x)
        return result
",nlogn + mlogm + nlogk + mlogk
"

class Trie(object):
    def __init__(self, bit_length):
        self.__root = {}
        self.__bit_length = bit_length
        
    def insert(self, num):
        node = self.__root
        for i in reversed(range(self.__bit_length)):
            curr = (num>>i) & 1
            if curr not in node:
                node[curr] = {}
            node = node[curr]
                
    def query(self, num):
        if not self.__root: 
            return -1
        node, result = self.__root, 0
        for i in reversed(range(self.__bit_length)):
            curr = (num>>i) & 1
            if 1^curr in node:
                node = node[1^curr]
                result |= 1<<i
            else:
                node = node[curr]
        return result


class Solution(object):
    def maxXor(self, n, edges, values):
        def iter_dfs():
            lookup = [0]*len(values)
            stk = [(1, 0, -1)]
            while stk:
                step, u, p = stk.pop()
                if step == 1:
                    stk.append((2, u, p))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, v, u))
                elif step == 2:
                    lookup[u] = values[u]+sum(lookup[v] for v in adj[u] if v != p)
            return lookup

        def iter_dfs2():
            trie = Trie(lookup[0].bit_length())
            result = [0]
            stk = [(1, (0, -1, result))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    ret[0] = max(trie.query(lookup[u]), 0)
                    stk.append((3, (u,)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_ret = [0]
                        stk.append((2, (new_ret, ret)))
                        stk.append((1, (v, u, new_ret)))
                elif step == 2:
                    new_ret, ret = args
                    ret[0] = max(ret[0], new_ret[0])
                elif step == 3:
                    u = args[0]
                    trie.insert(lookup[u])
            return result[0]
        
        adj = [[] for _ in range(len(values))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        lookup = iter_dfs()
        return iter_dfs2()


",nlogr
"
class Trie(object):
    def __init__(self, bit_length):
        self.__root = {}
        self.__bit_length = bit_length
        
    def insert(self, num):
        node = self.__root
        for i in reversed(range(self.__bit_length)):
            curr = (num>>i) & 1
            if curr not in node:
                node[curr] = {}
            node = node[curr]
                
    def query(self, num):
        if not self.__root: 
            return -1
        node, result = self.__root, 0
        for i in reversed(range(self.__bit_length)):
            curr = (num>>i) & 1
            if 1^curr in node:
                node = node[1^curr]
                result |= 1<<i
            else:
                node = node[curr]
        return result


class Solution2(object):
    def maxXor(self, n, edges, values):
        def dfs(u, p):
            lookup[u] = values[u]+sum(dfs(v, u) for v in adj[u] if v != p)
            return lookup[u]

        def dfs2(u, p):
            result = max(trie.query(lookup[u]), 0)
            for v in adj[u]:
                if v == p:
                    continue
                result = max(result, dfs2(v, u))
            trie.insert(lookup[u])
            return result
        
        adj = [[] for _ in range(len(values))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        lookup = [0]*len(values)
        dfs(0, -1)
        trie = Trie(lookup[0].bit_length())
        return dfs2(0, -1)
",nlogr
"


class Solution(object):
    def minOperations(self, nums, target):
        def floor_log2_x(x):
            return x.bit_length()-1

        total = sum(nums)
        if total < target:
            return -1

        cnt = [0]*(floor_log2_x(max(nums))+1)
        for x in nums:
            cnt[floor_log2_x(x)] += 1
        result = 0
        for i in reversed(range(len(cnt))):
            for _ in range(cnt[i]):
                x = 1<<i
                if x <= target:
                    target -= x
                    total -= x
                elif total-x >= target:
                    total -= x
                else:
                    cnt[i-1] += 2
                    result += 1
        return result


",n
"

class Solution2(object):
    def minOperations(self, nums, target):
        total = sum(nums)
        if total < target:
            return -1

        nums.sort()
        result = 0
        while target:
            x = nums.pop()
            if x <= target:
                target -= x
                total -= x
            elif total-x >= target:
                total -= x
            else:
                nums.append(x//2)
                nums.append(x//2)
                result += 1
        return result


",nlogn
"import heapq




class Solution3(object):
    def minOperations(self, nums, target):
        total = sum(nums)
        if total < target:
            return -1

        result = 0
        max_heap = [-x for x in nums]
        heapq.heapify(max_heap)
        while target:
            x = -heapq.heappop(max_heap)
            if x <= target:
                target -= x
                total -= x
            elif total-x >= target:
                total -= x
            else:
                heapq.heappush(max_heap, -x//2)
                heapq.heappush(max_heap, -x//2)
                result += 1
        return result


",nlogn
"

class Solution4(object):
    def minOperations(self, nums, target):
        def floor_log2_x(x):
            return x.bit_length()-1

        if sum(nums) < target:
            return -1

        cnt = [0]*(floor_log2_x(max(nums))+1)
        for x in nums:
            cnt[floor_log2_x(x)] += 1
        result = i = 0
        while i < len(cnt):
            if target&(1<<i):
                if not cnt[i]:
                    j = next(j for j in range(i, len(cnt)) if cnt[j])
                    result += j-i
                    j = i
                    cnt[i] -= 1
                    continue
                cnt[i] -= 1
            if i+1 < len(cnt):
                cnt[i+1] += cnt[i]//2
            i += 1
        return result
",nlogr
"
class Solution(object):
    def reverseOnlyLetters(self, S):
        def getNext(S):
            for i in reversed(range(len(S))):
                if S[i].isalpha():
                    yield S[i]

        result = []
        letter = getNext(S)
        for i in range(len(S)):
            if S[i].isalpha():
                result.append(next(letter))
            else:
                result.append(S[i])
        return """".join(result)

",n
"
class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        result, prev, curr = 0, 0, 0
        for n in nums:
            if n == 0:
                result = max(result, prev+curr+1)
                prev, curr = curr, 0
            else:
                curr += 1
        return min(max(result, prev+curr+1), len(nums))

",n
"

class Solution(object):
    def maximumSumOfHeights(self, maxHeights):
        left = [0]*len(maxHeights)
        stk = [-1]
        curr = 0
        for i in range(len(maxHeights)):
            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:
                j = stk.pop()
                curr -= (j-stk[-1])*maxHeights[j]
            curr += (i-stk[-1])*maxHeights[i]
            stk.append(i)
            left[i] = curr
        stk = [len(maxHeights)]
        result = right = curr = 0
        for i in reversed(range(len(maxHeights))):
            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:
                j = stk.pop()
                curr -= (stk[-1]-j)*maxHeights[j]
            curr += (stk[-1]-i)*maxHeights[i]
            stk.append(i)
            right = curr
            result = max(result, left[i]+right-maxHeights[i])
        return result
",n
"

class Solution(object):
    def minimalKSum(self, nums, k):
        result = k*(k+1)//2
        curr = k+1
        for x in sorted(set(nums)):
            if x < curr:
                result += curr-x
                curr += 1
        return result


",nlogn
"
class Solution2(object):
    def minimalKSum(self, nums, k):
        result = prev = 0
        nums.append(float(""inf""))
        for x in sorted(set(nums)):
            if not k:
                break
            cnt = min((x-1)-prev, k)
            k -= cnt
            result += ((prev+1)+(prev+cnt))*cnt//2
            prev = x
        return result
",nlogn
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maximumAverageSubtree(self, root):
        def maximumAverageSubtreeHelper(root, result):
            if not root:
                return [0.0, 0]
            s1, n1 = maximumAverageSubtreeHelper(root.left, result)
            s2, n2 = maximumAverageSubtreeHelper(root.right, result)
            s = s1+s2+root.val
            n = n1+n2+1
            result[0] = max(result[0], s / n)
            return [s, n]

        result = [0]
        maximumAverageSubtreeHelper(root, result)
        return result[0]
",n
"
class Solution(object):
    def removeKdigits(self, num, k):
        result = []
        for d in num:
            while k and result and result[-1] > d:
                result.pop()
                k -= 1
            result.append(d)
        return ''.join(result).lstrip('0')[:-k or None] or '0'

",n
"

class RopeTreeNode(object):
    def __init__(self, len=0, val="""", left=None, right=None):
        pass



class Solution(object):
    def getKthCharacter(self, root, k):
        while root.len:
            l = max(root.left.len, len(root.left.val)) if root.left else 0
            if k <= l:
                root = root.left
            else:
                k -= l
                root = root.right
        return root.val[k-1]
",h
"
import heapq


class Solution(object):
    def lastStoneWeight(self, stones):
        max_heap = [-x for x in stones]
        heapq.heapify(max_heap)
        for i in range(len(stones)-1):
            x, y = -heapq.heappop(max_heap), -heapq.heappop(max_heap)
            heapq.heappush(max_heap, -abs(x-y))
        return -max_heap[0]
",nlogn
"
import collections


class Solution(object):
    def numOfPairs(self, nums, target):
        lookup = collections.Counter()
        result = 0
        for num in nums:
            cnt1, cnt2 = lookup[-(len(target)-len(num))], lookup[len(target)-len(num)]
            if target.startswith(num):
                result += cnt1
                lookup[len(num)] += 1
            if target.endswith(num):
                result += cnt2
                lookup[-len(num)] += 1
        return result


",n * l
"import collections


class Solution2(object):
    def numOfPairs(self, nums, target):
        prefix, suffix = collections.Counter(), collections.Counter()
        result = 0
        for num in nums:
            if target.startswith(num):
                result += suffix[len(target)-len(num)]
            if target.endswith(num):
                result += prefix[len(target)-len(num)]
            if target.startswith(num):
                prefix[len(num)] += 1
            if target.endswith(num):
                suffix[len(num)] += 1
        return result
",n * l
"
class Node(object):
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight


class Solution(object):
    def construct(self, grid):
        def dfs(grid, x, y, l):
            if l == 1:
                return Node(grid[x][y] == 1, True, None, None, None, None)
            half = l // 2
            topLeftNode = dfs(grid, x, y, half)
            topRightNode = dfs(grid, x, y+half, half)
            bottomLeftNode = dfs(grid, x+half, y, half)
            bottomRightNode = dfs(grid, x+half, y+half, half)
            if topLeftNode.isLeaf and topRightNode.isLeaf and \
               bottomLeftNode.isLeaf and bottomRightNode.isLeaf and \
               topLeftNode.val == topRightNode.val == bottomLeftNode.val == bottomRightNode.val:
                return Node(topLeftNode.val, True, None, None, None, None)
            return Node(True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode)
        
        if not grid:
            return None
        return dfs(grid, 0, 0, len(grid))

",n
"
class Solution(object):
    def missingElement(self, nums, k):
        def missing_count(nums, x):
            return (nums[x]-nums[0]+1)-(x-0+1)

        def check(nums, k, x):
            return k > missing_count(nums, x)

        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if not check(nums, k, mid):
                right = mid-1
            else:
                left = mid+1
        assert(check(nums, k, right))
        return nums[right] + (k-missing_count(nums, right))
",logn
"
class Solution(object):
    def numberOfCleanRooms(self, room):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        result = r = c = d = 0
        while not room[r][c]&(1<<(d+1)):
            result += (room[r][c]>>1) == 0
            room[r][c] |= (1<<(d+1))
            dr, dc = directions[d]
            nr, nc = r+dr, c+dc
            if 0 <= nr < len(room) and 0 <= nc < len(room[0]) and not (room[nr][nc]&1):
                r, c = nr, nc
            else:
                d = (d+1)%4
        return result
",m * n
"
class Solution(object):
    def floodFill(self, image, sr, sc, newColor):
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def dfs(image, r, c, newColor, color):
            if not (0 <= r < len(image) and \
                    0 <= c < len(image[0]) and \
                    image[r][c] == color):
                return

            image[r][c] = newColor
            for d in directions:
                dfs(image, r+d[0], c+d[1], newColor, color)

        color = image[sr][sc]
        if color == newColor: return image
        dfs(image, sr, sc, newColor, color)
        return image

",m * n
"
class Solution(object):
    def findMedianSortedArrays(self, nums1, nums2):
        def binary_search(left, right, check):
            while left <= right:
                mid = left+(right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def getKth(A, B, k):
            m, n = len(A), len(B)
            if m > n:
                m, n = n, m
                A, B = B, A
            i = binary_search(max(k-n, 0), min(m, k)-1, lambda i: A[i] >= B[k-1-i])
            return max(A[i-1] if i-1 >= 0 else float(""-inf""), B[k-1-i] if k-1-i >= 0 else float(""-inf""))

        len1, len2 = len(nums1), len(nums2)
        if (len1+len2) % 2 == 1:
            return getKth(nums1, nums2, (len1+len2)//2+1)
        else:
            return (getKth(nums1, nums2, (len1+len2)//2)+getKth(nums1, nums2, (len1+len2)//2+1))*0.5    


","log(min(m, n))"
"
class Solution_Generic(object):
    def findMedianSortedArrays(self, nums1, nums2):
        def binary_search(left, right, check):
            while left <= right:
                mid = left+(right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def getKth(arrays, k):
            def check(num):
                return sum(binary_search(0, len(arr)-1, lambda x: arr[x] > num) for arr in arrays) >= k
    
            return binary_search(min(arr[0] for arr in arrays if arr), max(arr[-1] for arr in arrays if arr), check)

        array = [nums1, nums2]
        total = sum(len(nums) for nums in array)
        if total % 2 == 1:
            return getKth(array, total//2+1)
        else:
            return (getKth(array, total//2)+getKth(array, total//2+1))*0.5
","log(max(m, n)) * log(max_val - min_val)"
"
import bisect
import itertools


class Solution(object):
    def minArea(self, image, x, y):
        def binarySearch(left, right, find, image, has_one):
            while left <= right: 
                mid = left + (right - left) / 2
                if find(image, has_one, mid): 
                    right = mid - 1
                else:
                    left = mid + 1
            return left


        searchColumns = lambda image, has_one, mid: any([int(row[mid]) for row in image]) == has_one
        left = binarySearch(0, y - 1, searchColumns, image, True)
        right = binarySearch(y + 1, len(image[0]) - 1, searchColumns, image, False)

        searchRows = lambda image, has_one, mid: any(map(int, image[mid])) == has_one
        top = binarySearch(0, x - 1, searchRows, image, True)
        bottom = binarySearch(x + 1, len(image) - 1, searchRows, image, False)

        return (right - left) * (bottom - top)

",nlogn
"

class Solution(object):
    def takeCharacters(self, s, k):
        cnt = [0]*3
        for c in s:
            cnt[ord(c)-ord('a')] += 1
        if min(cnt) < k:
            return -1
        result = left = 0
        for right in range(len(s)):
            cnt[ord(s[right])-ord('a')] -= 1
            while cnt[ord(s[right])-ord('a')] < k:
                cnt[ord(s[left])-ord('a')] += 1
                left += 1
            result = max(result, right-left+1)
        return len(s)-result
",n
"
class Solution(object):
    def checkPartitioning(self, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        P = manacher(s)
        prefix, suffix = [], []
        for i in range(2, len(P)-2):
            if i-1-P[i] == 0:
                prefix.append(i)
            if i+1+P[i] == len(P)-1:
                suffix.append(i)
        for i in prefix:
            for j in suffix:
                left, right = i+1+P[i], j-1-P[j]
                if left > right:
                    continue
                mid = left + (right-left)//2
                if P[mid] >= mid-left:
                    return True
        return False


",n^2
"class Solution2(object):
    def checkPartitioning(self, s):
        dp = [[False]*len(s) for _ in range(len(s))]
        for i in reversed(range(len(s))):
            for j in range(i, len(s)):
                if s[i] == s[j] and (j-i < 2 or dp[i+1][j-1]):
                    dp[i][j] = True
        for i in range(1, len(s)-1):
            if not dp[0][i-1]:
                continue
            for j in range(i+1, len(s)):
                if not dp[j][-1]:
                    continue
                if dp[i][j-1]:
                    return True
        return False
",n^2
"

class Solution(object):
    def minimumOperations(self, grid):
        INF = float(""inf"")
        MAX_VALUE = 9
        dp = [0]*(MAX_VALUE+1)
        for j in range(len(grid[0])):
            new_dp = [INF]*(MAX_VALUE+1)
            cnt = [0]*(MAX_VALUE+1)
            for i in range(len(grid)):
                cnt[grid[i][j]] += 1
            k1 = min(range(MAX_VALUE+1), key=lambda x: dp[x])
            k2 = min((i for i in range(MAX_VALUE+1) if i != k1), key=lambda x: dp[x])
            for i in range(MAX_VALUE+1):
                new_dp[i] = min(new_dp[i], (dp[k1] if i != k1 else dp[k2])+(len(grid)-cnt[i]))
            dp = new_dp
        return min(dp)


",n * (m + 10)
"
class Solution2(object):
    def minimumOperations(self, grid):
        INF = float(""inf"")
        MAX_VALUE = 9
        dp = [0]*(MAX_VALUE+1)
        for j in range(len(grid[0])):
            new_dp = [INF]*(MAX_VALUE+1)
            cnt = [0]*(MAX_VALUE+1)
            for i in range(len(grid)):
                cnt[grid[i][j]] += 1
            for i in range(MAX_VALUE+1):
                new_dp[i] = min(new_dp[i], min(dp[k] for k in range(MAX_VALUE+1) if k != i)+(len(grid)-cnt[i]))
            dp = new_dp
        return min(dp)
",n * (m + 100)
"

class Solution(object):
    def maximumTastiness(self, price, k):
        def check(x): 
            cnt = prev = 0
            for i in range(len(price)):
                if prev and price[i]-prev < x:
                    continue
                cnt += 1
                if cnt == k:
                    break
                prev = price[i]
            return cnt >= k

        price.sort()
        left, right = 1, price[-1]-price[0]
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right
",nlogr
"
import itertools
import heapq


class Solution(object):
    def busiestServers(self, k, arrival, load):
        count = [0]*k
        min_heap_of_endtimes = []
        min_heap_of_nodes_after_curr = []
        min_heap_of_nodes_before_curr = list(range(k))
        for i, (t, l) in enumerate(zip(arrival, load)):
            if i % k == 0:
                min_heap_of_nodes_before_curr, min_heap_of_nodes_after_curr = [], min_heap_of_nodes_before_curr
            while min_heap_of_endtimes and min_heap_of_endtimes[0][0] <= t:
                _, free = heapq.heappop(min_heap_of_endtimes)
                if free < i % k:
                    heapq.heappush(min_heap_of_nodes_before_curr, free)
                else:
                    heapq.heappush(min_heap_of_nodes_after_curr, free)
            min_heap_of_candidates = min_heap_of_nodes_after_curr if min_heap_of_nodes_after_curr else min_heap_of_nodes_before_curr
            if not min_heap_of_candidates:
                continue
            node = heapq.heappop(min_heap_of_candidates)
            count[node] += 1
            heapq.heappush(min_heap_of_endtimes, (t+l, node))
        max_count = max(count)
        return [i for i in range(k) if count[i] == max_count]


",nlogk
"import sortedcontainers 
import itertools
import heapq



class Solution2(object):
    def busiestServers(self, k, arrival, load):
        count = [0]*k 
        min_heap_of_endtimes = []
        availables = sortedcontainers.SortedList(range(k)) 
        for i, (t, l) in enumerate(zip(arrival, load)):
            while min_heap_of_endtimes and min_heap_of_endtimes[0][0] <= t:
                _, free = heapq.heappop(min_heap_of_endtimes) 
                availables.add(free) 
            if not availables: 
                continue
            idx = availables.bisect_left(i % k) % len(availables) 
            node = availables.pop(idx) 
            count[node] += 1
            heapq.heappush(min_heap_of_endtimes, (t+l, node)) 
        max_count = max(count)
        return [i for i in range(k) if count[i] == max_count]
",nlogk
"
import collections


class Solution(object):
    def countLargestGroup(self, n):
        count = collections.Counter()
        for x in range(1, n+1):
            count[sum(map(int, str(x)))] += 1
        max_count = max(count.values())
        return sum(v == max_count for v in count.values())
",nlogn
"

class Solution(object):
    def count(self, num1, num2, min_sum, max_sum):
        MOD = 10**9+7
        def f(x):
            dp = [[0]*(max_sum+1) for _ in range(2)]
            dp[0][0] = dp[1][0] = 1
            for i in reversed(range(len(x))):
                new_dp = [[0]*(max_sum+1) for _ in range(2)]
                for t in range(2):
                    for total in range(max_sum+1):
                        for d in range(min((int(x[i]) if t else 9), total)+1):
                            new_dp[t][total] = (new_dp[t][total]+dp[int(t and d == int(x[i]))][total-d])%MOD
                dp = new_dp
            return reduce(lambda x, y: (x+y)%MOD, (dp[1][total] for total in range(min_sum, max_sum+1)))

        return (f(num2)-f(str(int(num1)-1)))%MOD
",n * m
"
from sortedcontainers import SortedList



class Solution(object):
    def getSubarrayBeauty(self, nums, k, x):
        result = []
        sl = SortedList()
        for i, v in enumerate(nums): 
            if i-k >= 0:
                sl.remove(nums[i-k])
            sl.add(v)
            if i-k+1 >= 0:
                result.append(min(sl[x-1], 0))
        return result 
",nlogk
"
import itertools



class Solution(object):
    def maxCompatibilitySum(self, students, mentors):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 

        def score(s, m):
            return sum(int(a == b) for a, b in zip(s, m))

        return -hungarian([[-score(s, m) for m in mentors] for s in students])[0]


",m^2 * (n + m)
"
class Solution2(object):
    def maxCompatibilitySum(self, students, mentors):
        def popcount(n): 
            result = 0
            while n:
                n &= n-1
                result += 1
            return result

        def masks(vvi):
            result = []
            for vi in vvi:
                mask, bit = 0, 1
                for i in range(len(vi)):
                    if vi[i]:
                        mask |= bit
                    bit <<= 1
                result.append(mask)
            return result

        nums1, nums2 = masks(students), masks(mentors)
        dp = [(0, 0)]*(2**len(nums2))
        for mask in range(len(dp)):
            bit = 1
            for i in range(len(nums2)):
                if (mask&bit) == 0:
                    dp[mask|bit] = max(dp[mask|bit], (dp[mask][0]+(len(students[0])-popcount(nums1[dp[mask][1]]^nums2[i])), dp[mask][1]+1))
                bit <<= 1
        return dp[-1][0]
",m * (n + 2^m)
"

class Solution(object):
    def waysToReachTarget(self, target, types):
        MOD = 10**9+7
        dp = [0]*(target+1)
        dp[0] = 1
        for c, m in types:
            for i in reversed(range(1, target+1)):
                for j in range(1, min(i//m, c)+1):
                    dp[i] = (dp[i]+dp[i-j*m])%MOD
        return dp[-1]


",n * t * c
"
class Solution2(object):
    def waysToReachTarget(self, target, types):
        MOD = 10**9+7
        dp = [0]*(target+1)
        dp[0] = 1
        for c, m in types:
            new_dp = [0]*(target+1)
            for i in range(target+1):
                for j in range(min((target-i)//m, c)+1):
                    new_dp[i+j*m] = (new_dp[i+j*m]+dp[i])%MOD
            dp = new_dp
        return dp[-1]
",n * t * c
"

class Solution(object):
    def minimumXORSum(self, nums1, nums2):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 
        
        adj = [[0]*len(nums2) for _ in range(len(nums1))]
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                adj[i][j] = nums1[i]^nums2[j]
        return hungarian(adj)[0]


",n^3
"
class Solution2(object):
    def minimumXORSum(self, nums1, nums2):
        dp = [(float(""inf""), float(""inf""))]*(2**len(nums2))
        dp[0] = (0, 0)
        for mask in range(len(dp)):
            bit = 1
            for i in range(len(nums2)):
                if (mask&bit) == 0:
                    dp[mask|bit] = min(dp[mask|bit], (dp[mask][0]+(nums1[dp[mask][1]]^nums2[i]), dp[mask][1]+1))
                bit <<= 1
        return dp[-1][0]
",n * 2^n
"
class Solution(object):
    def minDistance(self, word1, word2):
        m, n = len(word1), len(word2)
        dp = [[0] * (n+1) for _ in range(2)]
        for i in range(m):
            for j in range(n):
                dp[(i+1)%2][j+1] = max(dp[i%2][j+1], \
                                       dp[(i+1)%2][j], \
                                       dp[i%2][j] + (word1[i] == word2[j]))
        return m + n - 2*dp[m%2][n]

",m * n
"
import collections



class Point(object):
    def __init__(self, a=0, b=0):
        self.x = a
        self.y = b

class Solution(object):
    def maxPoints(self, points):
        max_points = 0
        for i, start in enumerate(points):
            slope_count, same = collections.defaultdict(int), 1
            for j in range(i + 1, len(points)):
                end = points[j]
                if start.x == end.x and start.y == end.y:
                    same += 1
                else:
                    slope = float(""inf"")
                    if start.x - end.x != 0:
                        slope = (start.y - end.y) * 1.0 / (start.x - end.x)
                    slope_count[slope] += 1

            current_max = same
            for slope in slope_count:
                current_max = max(current_max, slope_count[slope] + same)

            max_points = max(max_points, current_max)

        return max_points

",n^2
"

class Solution(object):
    def closetTarget(self, words, target, startIndex):
        INF = float(""inf"")
        result = INF
        for i, w in enumerate(words):
            if w == target:
                result = min(result, (i-startIndex)%len(words), (startIndex-i)%len(words))
        return result if result != INF else -1
",n
"
class Solution(object):
    def lenLongestFibSubseq(self, A):
        lookup = set(A)
        result = 2
        for i in range(len(A)):
            for j in range(i+1, len(A)):
                x, y, l = A[i], A[j], 2
                while x+y in lookup:
                    x, y, l = y, x+y, l+1
                result = max(result, l)
        return result if result > 2 else 0

",n^2
"
import collections


class Solution(object):
    def countGoodSubstrings(self, s):
        K = 3

        result = 0
        count = collections.Counter()
        for i in range(len(s)):
            if i >= K:
                count[s[i-K]] -= 1
                if not count[s[i-K]]:
                    del count[s[i-K]]
            count[s[i]] += 1
            if len(count) == K:
                result += 1
        return result
",n
"
import itertools



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def getTargetCopy(self, original, cloned, target):
        def preorder_gen(node):
            stk = [node]
            while stk:
                node = stk.pop()
                if not node:
                    continue
                yield node
                stk.append(node.right)
                stk.append(node.left)
            
        for node1, node2 in zip(preorder_gen(original),
                                           preorder_gen(cloned)):
            if node1 == target:
                return node2
",n
"

class Solution(object):
    def sumOfSquares(self, nums):
        result = 0
        for i in range(1, int(len(nums)**0.5)+1):
            if len(nums)%i:
                continue
            result += nums[i-1]**2
            if len(nums)//i != i:
                result += nums[len(nums)//i-1]**2
        return result
",sqrt(n)
"

class Solution(object):
    def maximizeSum(self, nums, k):
        return max(nums)*k+k*(k-1)//2
",n
"

class Solution(object):
    def reverseDegree(self, s):
        return sum(i*(26-(ord(x)-ord('a'))) for i, x in enumerate(s, 1))
",n
"
import collections


class Solution(object):

    def __init__(self):
        self.__dq = collections.deque()
        self.__printed = set()

    def shouldPrintMessage(self, timestamp, message):
        while self.__dq and self.__dq[0][0] <= timestamp - 10:
            self.__printed.remove(self.__dq.popleft()[1])
        if message in self.__printed:
            return False
        self.__dq.append((timestamp, message))
        self.__printed.add(message)
        return True

    
",1
"

class Solution(object):
    def minimumSum(self, nums):
        INF = float(""inf"")

        right = [INF]*len(nums)
        curr = INF
        for i in reversed(range(len(nums))):
            right[i] = curr
            curr = min(curr, nums[i])
        result = curr = INF
        for i in range(len(nums)):
            if curr < nums[i] > right[i]:
                result = min(result, curr+nums[i]+right[i])
            curr = min(curr, nums[i])
        return result if result != INF else -1


",n
"
class Solution2(object):
    def minimumSum(self, nums):
        INF = float(""inf"")

        left = [INF]*len(nums)
        curr = INF
        for i in range(len(nums)):
            left[i] = curr
            curr = min(curr, nums[i])
        right = [INF]*len(nums)
        curr = INF
        for i in reversed(range(len(nums))):
            right[i] = curr
            curr = min(curr, nums[i])
        result = INF
        for i in range(len(nums)):
            if left[i] < nums[i] > right[i]:
                result = min(result, left[i]+nums[i]+right[i])
        return result if result != INF else -1
",n
"
import bisect



class Solution(object):
    def maximumCount(self, nums):
        return max(bisect.bisect_left(nums, 0)-0, len(nums)-bisect.bisect_left(nums, 1))
",logn
"
class Solution(object):
    def dayOfTheWeek(self, day, month, year):
        DAYS = [""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", \
                ""Thursday"", ""Friday"", ""Saturday""]

        if month < 3:
            month += 12
            year -= 1
        c, y = divmod(year, 100)
        w = (c//4 - 2*c + y + y//4 + 13*(month+1)//5 + day - 1) % 7
        return DAYS[w]
",1
"
class Solution(object):
    def subarrayBitwiseORs(self, A):
        result, curr = set(), {0}
        for i in A:
            curr = {i} | {i | j for j in curr}
            result |= curr
        return len(result)

",32 * n
"
class Solution(object):
    def numSpecialEquivGroups(self, A):
        def count(word):
            result = [0]*52
            for i, letter in enumerate(word):
                result[ord(letter)-ord('a') + 26*(i%2)] += 1
            return tuple(result)

        return len({count(word) for word in A})

",n * l
"
import collections


class Solution(object):
    def minOperations(self, nums1, nums2):
        if len(nums1)*6 < len(nums2) or len(nums1) > len(nums2)*6:
            return -1
        diff = sum(nums2)-sum(nums1)
        if diff < 0:
            nums1, nums2 = nums2, nums1
            diff = -diff
        count = collections.Counter(6-num for num in nums1)
        count += collections.Counter(num-1 for num in nums2)
        result = 0
        for i in reversed(range(1, 6)):
            if not count[i]:
                continue
            cnt = min(count[i], (diff+i-1)//i)
            result += cnt
            diff -= i*cnt
            if diff <= 0:
                break
        return result
",m + n
"

class Solution(object):
    def smallestPalindrome(self, s):
        cnt = [0]*26
        for i in range(len(s)//2):
            cnt[ord(s[i])-ord('a')] += 1
        result = [chr(ord('a')+i)*c for i, c in enumerate(cnt)]
        if len(s)%2:
            result.append(s[len(s)//2])
        result.extend((result[i] for i in reversed(range(len(result)-len(s)%2))))
        return """".join(result)
",n + 26
"
import collections



class Solution(object):
    def oddString(self, words):
        for i in range(len(words[0])-1):
            lookup = collections.defaultdict(list)
            for j, w in enumerate(words):
                if len(lookup[ord(w[i+1])-ord(w[i])]) < 2:
                    lookup[ord(w[i+1])-ord(w[i])].append(j)
            if len(lookup) == 2:
                return next(words[l[0]] for l in lookup.values() if len(l) == 1)


",m * n
"import collections



class Solution2(object):
    def oddString(self, words):
        cnt = collections.Counter(tuple(ord(w[i+1])-ord(w[i]) for i in range(len(w)-1)) for w in words)
        target = next(k for k, v in cnt.items() if v == 1)
        return next(w for w in words if tuple(ord(w[i+1])-ord(w[i]) for i in range(len(w)-1)) == target)
",m * n
"

class Solution(object):
    def sumImbalanceNumbers(self, nums):
        right = [len(nums)]*len(nums)
        lookup = [len(nums)]*((len(nums)+1)+1)
        for i in reversed(range(len(nums))):
            right[i] = min(lookup[nums[i]], lookup[nums[i]+1]) 
            lookup[nums[i]] = i
        result = left = 0
        lookup = [-1]*((len(nums)+1)+1)
        for i in range(len(nums)):
            left = lookup[nums[i]+1]
            lookup[nums[i]] = i
            result += (i-left)*(right[i]-i)
        return result - (len(nums)+1)*len(nums)//2 


",n
"
class Solution2(object):
    def sumImbalanceNumbers(self, nums):
        result = 0
        for right in range(len(nums)):
            lookup = {nums[right]}
            curr = 0
            for left in reversed(range(right)):
                if nums[left] not in lookup:
                    lookup.add(nums[left])
                    curr += 1-(nums[left]-1 in lookup)-(nums[left]+1 in lookup)
                result += curr
        return result
",n^2
"

class Node(object):
    def __init__(self, val=0, left=None, right=None, random=None):
        self.val = val
        self.left = left
        self.right = right
        self.random = random



class NodeCopy(object):
    def __init__(self, val=0, left=None, right=None, random=None):
        pass


class Solution(object):
    def copyRandomBinaryTree(self, root):
        def iter_dfs(node, callback):
            result = None
            stk = [node]
            while stk:
                node = stk.pop()
                if not node:
                    continue
                left_node, copy = callback(node)
                if not result:
                    result = copy
                stk.append(node.right)
                stk.append(left_node)
            return result
    
        def merge(node):
            copy = NodeCopy(node.val)
            node.left, copy.left = copy, node.left
            return copy.left, copy
        
        def clone(node):
            copy = node.left
            node.left.random = node.random.left if node.random else None
            node.left.right = node.right.left if node.right else None
            return copy.left, copy
        
        def split(node):
            copy = node.left
            node.left, copy.left = copy.left, copy.left.left if copy.left else None
            return node.left, copy
    
        iter_dfs(root, merge)
        iter_dfs(root, clone)
        return iter_dfs(root, split)


",n
"class Solution_Recu(object):
    def copyRandomBinaryTree(self, root):
        def dfs(node, callback):
            if not node:
                return None
            left_node, copy = callback(node)
            dfs(left_node, callback)
            dfs(node.right, callback) 
            return copy
    
        def merge(node):
            copy = NodeCopy(node.val)
            node.left, copy.left = copy, node.left
            return copy.left, copy
        
        def clone(node):
            copy = node.left
            node.left.random = node.random.left if node.random else None
            node.left.right = node.right.left if node.right else None
            return copy.left, copy
        
        def split(node):
            copy = node.left
            node.left, copy.left = copy.left, copy.left.left if copy.left else None
            return node.left, copy
    
        dfs(root, merge)
        dfs(root, clone)
        return dfs(root, split)


",n
"import collections


class Solution2(object):
    def copyRandomBinaryTree(self, root):
        lookup = collections.defaultdict(lambda: NodeCopy())
        lookup[None] = None
        stk = [root]
        while stk:
            node = stk.pop()
            if not node:
                continue
            lookup[node].val = node.val
            lookup[node].left = lookup[node.left]
            lookup[node].right = lookup[node.right]
            lookup[node].random = lookup[node.random]
            stk.append(node.right)
            stk.append(node.left)
        return lookup[root]


",n
"import collections


class Solution2_Recu(object):
    def copyRandomBinaryTree(self, root):
        def dfs(node, lookup):
            if not node:
                return
            lookup[node].val = node.val
            lookup[node].left = lookup[node.left]
            lookup[node].right = lookup[node.right]
            lookup[node].random = lookup[node.random]
            dfs(node.left, lookup)
            dfs(node.right, lookup)
    
        lookup = collections.defaultdict(lambda: NodeCopy())
        lookup[None] = None
        dfs(root, lookup)
        return lookup[root]
",n
"
class Solution(object):
    def shortestDistanceColor(self, colors, queries):
        dp = [[-1 for _ in range(len(colors))] for _ in range(3)]
        dp[colors[0]-1][0] = 0
        for i in range(1, len(colors)):
            for color in range(3):
                dp[color][i] = dp[color][i-1]
            dp[colors[i]-1][i] = i

        dp[colors[len(colors)-1]-1][len(colors)-1] = len(colors)-1
        for i in reversed(range(len(colors)-1)):
            for color in range(3):
                if dp[color][i+1] == -1:
                    continue
                if dp[color][i] == -1 or \
                   abs(dp[color][i+1]-i) < abs(dp[color][i]-i):
                    dp[color][i] = dp[color][i+1]
            dp[colors[i]-1][i] = i
         
        return [abs(dp[color-1][i]-i) if dp[color-1][i] != -1 else -1 \
                    for i, color in queries]
",n
"
class Solution(object):
    def canMakeArithmeticProgression(self, arr):
        m = min(arr)
        d = (max(arr)-m)//(len(arr)-1)
        if not d:
            return True
        i = 0
        while i < len(arr):
            if arr[i] == m+i*d:
                i += 1
            else:
                j, r = divmod(arr[i]-m, d)
                if r or j >= len(arr) or arr[i] == arr[j]:
                    return False
                arr[i], arr[j] = arr[j], arr[i]
        return True
",n
"

class Solution(object):
    def countPathsWithXorValue(self, grid, k):
        MOD = 10**9+7
        MAX_R = 16
        dp = [[0]*MAX_R for _ in range(len(grid[0]))]
        dp[0][0] = 1
        for i in range(len(grid)):
            new_dp = [[0]*MAX_R for _ in range(len(grid[0]))]
            for j in range(len(grid[0])):
                for v in range(MAX_R):
                    new_dp[j][grid[i][j]^v] = (dp[j][v]+(new_dp[j-1][v] if j-1 >= 0 else 0)) % MOD
            dp = new_dp
        return dp[-1][k]
",m * n * r
"




class Solution(object):
    def canTransform(self, start, end):
        if start.count('X') != end.count('X'):
            return False
        i, j = 0, 0
        while i < len(start) and j < len(end):
            while i < len(start) and start[i] == 'X':
                i += 1
            while j < len(end) and end[j] == 'X':
                j += 1
            if (i < len(start)) != (j < len(end)):
                return False
            elif i < len(start) and j < len(end):
                if start[i] != end[j] or \
                   (start[i] == 'L' and i < j) or \
                   (start[i] == 'R' and i > j):
                    return False
            i += 1
            j += 1
        return True

",n
"
import collections



class Solution(object):
    def numWays(self, words, target):
        MOD = 10**9+7
        dp = [0]*(len(target)+1)
        dp[0] = 1
        for i in range(len(words[0])):
            count = collections.Counter(w[i] for w in words)
            for j in reversed(range(len(target))):
                dp[j+1] += dp[j]*count[target[j]] % MOD
        return dp[-1] % MOD


",l * (w + n)
"import collections


class Solution2(object):
    def numWays(self, words, target):
        MOD = 10**9+7
        dp = [[0]*(len(target)+1) for _ in range(2)]
        for i in range(len(dp)):
            dp[i][0] = 1
        for i in range(len(words[0])):
            count = collections.Counter(w[i] for w in words)
            for j in reversed(range(len(target))):
                dp[(i+1)%2][j+1] = dp[i%2][j+1]+dp[i%2][j]*count[target[j]] % MOD
        return dp[(len(words[0]))%2][-1] % MOD
",l * (w + n)
"

class Solution(object):
    def stringHash(self, s, k):
        result = (chr(ord('a')+reduce(lambda accu, x: (accu+x)%26,  (ord(s[i+j])-ord('a') for j in range(k)), 0)) for i in range(0, len(s), k))
        return """".join(result)
",n
"
import collections


class Solution(object):
    def maxEqualFreq(self, nums):
        result = 0
        count = collections.Counter()
        freq = [0 for _ in range(len(nums)+1)]
        for i, n in enumerate(nums, 1):
            freq[count[n]] -= 1
            freq[count[n]+1] += 1
            count[n] += 1
            c = count[n]
            if freq[c]*c == i and i < len(nums):
                result = i+1
            remain = i-freq[c]*c
            if freq[remain] == 1 and remain in [1, c+1]:
                result = i
        return result
",n
"
class Solution(object):
    def firstDayBeenInAllRooms(self, nextVisit):
        MOD = 10**9+7

        dp = [0]*len(nextVisit)
        for i in range(1, len(dp)):
            dp[i] = (dp[i-1]+1+(dp[i-1]-dp[nextVisit[i-1]])+1)%MOD
        return dp[-1]
",n
"

class Solution(object):
    def findMaxFish(self, grid):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        def bfs(i, j):
            result = grid[i][j]
            grid[i][j] = 0
            q = [(i, j)]
            while q:
                new_q = []
                for i, j in q:
                    for di, dj in DIRECTIONS:
                        ni, nj = i+di, j+dj
                        if not (0 <= ni < len(grid) and
                                0 <= nj < len(grid[0]) and
                                grid[ni][nj]):
                            continue
                        result += grid[ni][nj]
                        grid[ni][nj] = 0
                        new_q.append((ni, nj))
                q = new_q
            return result

        result = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]:
                    result = max(result, bfs(i, j))
        return result


",m * n
"
class Solution2(object):
    def findMaxFish(self, grid):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        def dfs(i, j):
            result = grid[i][j]
            grid[i][j] = 0
            stk = [(i, j)]
            while stk:
                i, j = stk.pop()
                for di, dj in reversed(DIRECTIONS):
                    ni, nj = i+di, j+dj
                    if not (0 <= ni < len(grid) and
                            0 <= nj < len(grid[0]) and
                            grid[ni][nj]):
                        continue
                    result += grid[ni][nj]
                    grid[ni][nj] = 0
                    stk.append((ni, nj))
            return result

        result = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]:
                    result = max(result, dfs(i, j))
        return result
",m * n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isCompleteTree(self, root):
        end = False
        current = [root]
        while current:
            next_level = []
            for node in current:
                if not node:
                    end = True
                    continue
                if end:
                    return False
                next_level.append(node.left)
                next_level.append(node.right)
            current = next_level
        return  True


",n
"class Solution2(object):
    def isCompleteTree(self, root):
        prev_level, current = [], [(root, 1)]
        count = 0
        while current:
            count += len(current)
            next_level = []
            for node, v in current:
                if not node:
                    continue
                next_level.append((node.left, 2*v))
                next_level.append((node.right, 2*v+1))
            prev_level, current = current, next_level
        return prev_level[-1][1] == count
",n
"
class Solution(object):
    def repeatedStringMatch(self, A, B):
        def check(index):
            return all(A[(i+index) % len(A)] == c
                       for i, c in enumerate(B))

        M, p = 10**9+7, 113
        p_inv = pow(p, M-2, M)
        q = (len(B)+len(A)-1) // len(A)

        b_hash, power = 0, 1
        for c in B:
            b_hash += power * ord(c)
            b_hash %= M
            power = (power*p) % M

        a_hash, power = 0, 1
        for i in range(len(B)):
            a_hash += power * ord(A[i%len(A)])
            a_hash %= M
            power = (power*p) % M

        if a_hash == b_hash and check(0): return q

        power = (power*p_inv) % M
        for i in range(len(B), (q+1)*len(A)):
            a_hash = (a_hash-ord(A[(i-len(B))%len(A)])) * p_inv
            a_hash += power * ord(A[i%len(A)])
            a_hash %= M
            if a_hash == b_hash and check(i-len(B)+1):
                return q if i < q*len(A) else q+1

        return -1

",n + m
"
class Solution(object):
    def isIdealPermutation(self, A):
        return all(abs(v-i) <= 1 for i,v in enumerate(A))


",n
"
class Solution(object):
    def findSubsequences(self, nums):
        def findSubsequencesHelper(nums, pos, seq, result):
            if len(seq) >= 2:
                result.append(list(seq))
            lookup = set()
            for i in range(pos, len(nums)):
                if (not seq or nums[i] >= seq[-1]) and \
                   nums[i] not in lookup:
                    lookup.add(nums[i])
                    seq.append(nums[i])
                    findSubsequencesHelper(nums, i+1, seq, result)
                    seq.pop()

        result, seq = [], []
        findSubsequencesHelper(nums, 0, seq, result)
        return result

",n * 2^n
"

class Solution(object):
    def flipAndInvertImage(self, A):
        for row in A:
            for i in range((len(row)+1) // 2):
                row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1
        return A

",n^2
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def levelOrderBottom(self, root):
        if root is None:
            return []

        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            current = next_level
            result.append(vals)

        return result[::-1]

",n
"

class Solution(object):
    def maxArrayValue(self, nums):
        result = curr = 0
        for i in reversed(range(len(nums))):
            if nums[i] > curr:
                curr = 0
            curr += nums[i]
            result = max(result, curr)
        return result
",n
"
class Solution(object):
    def addToArrayForm(self, A, K):
        A.reverse()
        carry, i = K, 0
        A[i] += carry
        carry, A[i] = divmod(A[i], 10)
        while carry:
            i += 1
            if i < len(A):
                A[i] += carry
            else:
                A.append(carry)
            carry, A[i] = divmod(A[i], 10)
        A.reverse()
        return A
",n + logk
"
import collections
from functools import reduce


class Solution(object):
    def countMaxOrSubsets(self, nums):
        dp = collections.Counter([0])
        for x in nums:
            for k, v in list(dp.items()):
                dp[k|x] += v
        return dp[reduce(lambda x, y: x|y, nums)]
","min(2^n, m * n)"
"
class Solution(object):
    def queryString(self, S, N):
        return all(bin(i)[2:] in S for i in reversed(range(N//2, N+1)))
",n^2
"
class Solution(object):
    def checkValidString(self, s):
        lower, upper = 0, 0 
        for c in s:
            lower += 1 if c == '(' else -1
            upper -= 1 if c == ')' else -1
            if upper < 0: break
            lower = max(lower, 0)
        return lower == 0 

",n
"

class Street:
    def openDoor(self):
        pass
    def closeDoor(self):
        pass
    def isDoorOpen(self):
        pass
    def moveRight(self):
        pass
    def moveLeft(self):
        pass



class Solution(object):
    def houseCount(self, street, k):
        for _ in range(k):
            street.closeDoor()
            street.moveRight()
        for result in range(k+1):
            if street.isDoorOpen():
                break
            street.openDoor()
            street.moveRight()
        return result
",k
"

class Solution(object):
    def maxCollectedFruits(self, fruits):
        n = len(fruits)
        for i in range(n):
            for j in range(i+1, n-(i+1)):
                fruits[i][j] = 0
        for i in range(1, n-1):
            for j in range(i+1, n):
                fruits[i][j] += max(fruits[i-1][j-1], fruits[i-1][j], fruits[i-1][j+1] if j+1 < n else 0)
        for j in range(n):
            for i in range(j+1, n-(j+1)):
                fruits[i][j] = 0
        for j in range(1, n-1):
            for i in range(j+1, n):
                fruits[i][j] += max(fruits[i-1][j-1], fruits[i][j-1], fruits[i+1][j-1] if i+1 < n else 0)
        return sum(fruits[i][i] for i in range(n))+fruits[-2][-1]+fruits[-1][-2]
    
",n^2
"
import itertools


class Solution(object):
    def ambiguousCoordinates(self, S):
        def make(S, i, n):
            for d in range(1, n+1):
                left = S[i:i+d]
                right = S[i+d:i+n]
                if ((not left.startswith('0') or left == '0')
                        and (not right.endswith('0'))):
                    yield """".join([left, '.' if right else '', right])

        return [""({}, {})"".format(*cand)
                for i in range(1, len(S)-2)
                for cand in itertools.product(make(S, 1, i),
                                              make(S, i+1, len(S)-2-i))]

",n^4
"

class Solution(object):
    def maxFreeTime(self, eventTime, startTime, endTime):
        def topk(a, k): 
            result = [[float(""-inf"")]*2 for _ in range(k)]
            for x in a:
                for i in range(len(result)):
                    if x > result[i]:
                        result[i], x = x, result[i]
            return result

        result = 0
        startTime.append(eventTime)
        endTime.insert(0, 0)
        diffs = ([startTime[i]-endTime[i], endTime[i]] for i in range(len(startTime)))
        top3 = topk(diffs, 3)
        for i in range(len(startTime)-1):
            for mx, e in top3:
                if e not in (endTime[i], endTime[i+1]) and endTime[i+1]-startTime[i] <= mx:
                    result = max(result, (startTime[i]-endTime[i])+(startTime[i+1]-endTime[i+1])+(endTime[i+1]-startTime[i]))
                    break
            else:
                result = max(result, (startTime[i]-endTime[i])+(startTime[i+1]-endTime[i+1]))
        return result
",n
"
class Solution(object):
    def totalHammingDistance(self, nums):
        result = 0
        for i in range(32):
            counts = [0] * 2
            for num in nums:
                counts[(num >> i) & 1] += 1
            result += counts[0] * counts[1]
        return result


",n
"
class Solution(object):
    def mostCompetitive(self, nums, k):
        stk = []
        for i, x in enumerate(nums):
            while stk and stk[-1] > x and len(stk)+(len(nums)-i) > k:
                stk.pop()
            if len(stk) < k:
                stk.append(x)
        return stk
",n
"
class Solution(object):
    def multiply(self, A, B):
        m, n, l = len(A), len(A[0]), len(B[0])
        res = [[0 for _ in range(l)] for _ in range(m)]
        for i in range(m):
            for k in range(n):
                if A[i][k]:
                    for j in range(l):
                        res[i][j] += A[i][k] * B[k][j]
        return res

",m * n * l
"
import collections
import itertools



class Solution(object):
    def countPairs(self, n, edges, queries):
        degree = [0]*(n+1)
        shared = collections.Counter((min(n1, n2), max(n1, n2)) for n1, n2 in edges)
        for u, v in edges:
            degree[u] += 1
            degree[v] += 1
        cnt = [0]*(2*(max(degree[1:])+1))
        count = collections.Counter(degree[1:])
        for i, j in itertools.product(count, count): 
            if i < j:
                cnt[i+j] += count[i]*count[j]
            elif i == j:
                cnt[i+j] += count[i]*(count[i]-1)//2
        for (i, j), shared_degree in shared.items():
            cnt[degree[i]+degree[j]] -= 1
            cnt[degree[i]+degree[j]-shared_degree] += 1
        for i in reversed(range(len(cnt)-1)): 
            cnt[i] += cnt[i+1]
        return [cnt[q+1] if q+1 < len(cnt) else 0 for q in queries]


",n + e + q
"import collections



class Solution2(object):
    def countPairs(self, n, edges, queries):
        degree = [0]*(n+1)
        shared = collections.Counter((min(n1, n2), max(n1, n2)) for n1, n2 in edges)
        for n1, n2 in edges:
            degree[n1] += 1
            degree[n2] += 1
        sorted_degree = sorted(degree)
        result = []
        for k, q in enumerate(queries):
            left, right = 1, n
            cnt = 0
            while left < right:
                if q < sorted_degree[left]+sorted_degree[right]:
                    cnt += right-left
                    right -= 1
                else:
                    left += 1
            for (i, j), shared_degree in shared.items():
                if degree[i]+degree[j]-shared_degree <= q < degree[i]+degree[j]:
                    cnt -= 1
            result.append(cnt)
        return result
",nlogn + q * (n + e)
"
class Solution(object):
    def reverseString(self, s):
        i, j = 0, len(s) - 1
        while i < j:
            s[i], s[j] = s[j], s[i]
            i += 1
            j -= 1
",n
"

class Solution(object):
    def onesMinusZeros(self, grid):
        rows = [sum(grid[i][j] for j in range(len(grid[0]))) for i in range(len(grid))]
        cols = [sum(grid[i][j] for i in range(len(grid))) for j in range(len(grid[0]))]
        return [[rows[i]+cols[j]-(len(grid)-rows[i])-(len(grid[0])-cols[j]) for j in range(len(grid[0]))] for i in range(len(grid))]
",m * n
"
import collections
import itertools



class Solution(object):
    def mostPopularCreator(self, creators, ids, views):
        cnt = collections.Counter()
        lookup = collections.defaultdict(lambda: (float(""inf""), float(""inf"")))
        for c, i, v in zip(creators, ids, views):
            cnt[c] += v
            lookup[c] = min(lookup[c], (-v, i))
        mx = max(cnt.values())
        return [[k, lookup[k][1]] for k, v in cnt.items() if v == mx]
",n
"
import collections


class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def serialize(self, root):
        def serializeHelper(node, vals):
            if node:
                vals.append(node.val)
                serializeHelper(node.left, vals)
                serializeHelper(node.right, vals)

        vals = []
        serializeHelper(root, vals)

        return ' '.join(map(str, vals))


    def deserialize(self, data):
        def deserializeHelper(minVal, maxVal, vals):
            if not vals:
                return None

            if minVal < vals[0] < maxVal:
                val = vals.popleft()
                node = TreeNode(val)
                node.left = deserializeHelper(minVal, val, vals)
                node.right = deserializeHelper(val, maxVal, vals)
                return node
            else:
                return None

        vals = collections.deque([int(val) for val in data.split()])

        return deserializeHelper(float('-inf'), float('inf'), vals)



",n
"

class Solution(object):
    def minMoves(self, target, maxDoubles):
        result = 0
        while target > 1 and maxDoubles:
            result += 1+target%2
            target //= 2
            maxDoubles -= 1
        return result+(target-1)
",logn
"
class BIT(object): 
    def __init__(self, n):
        self.__bit = [0] * n

    def add(self, i, val):
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def sum(self, i):
        result = 0
        while i > 0:
            result += self.__bit[i]
            i -= (i & -i)
        return result


class Solution(object):
    def processQueries(self, queries, m):
        bit = BIT(2*m+1)
        lookup = {}
        for i in range(1, m+1):
            bit.add(m+i, 1)
            lookup[i] = m+i
        result, curr = [], m
        for q in queries:
            i = lookup.pop(q)
            result.append(bit.sum(i-1))
            bit.add(i, -1)
            lookup[q] = curr
            bit.add(curr, 1)
            curr -= 1
        return result
",nlogn
"
import collections


class Solution(object):
    def displayTable(self, orders):
        table_count = collections.defaultdict(collections.Counter)
        for _, table, food in orders:
            table_count[int(table)][food] += 1
        foods = sorted({food for _, _, food in orders})
        result = [[""Table""]]
        result[0].extend(foods)
        for table in sorted(table_count):
            result.append([str(table)])
            result[-1].extend(str(table_count[table][food]) for food in foods)
        return result
",n + tlogt + flogf
"
class Solution(object):
    def averageWaitingTime(self, customers):
        avai = wait = 0.0
        for a, t in customers:
            avai = max(avai, a)+t
            wait += avai-a
        return wait/len(customers)
",n
"
class Solution(object):
    def minMoves(self, nums):
        return sum(nums) - len(nums) * min(nums)

",n
"

class Solution(object):
    def isPossible(self, n, edges):
        adj = [set() for _ in range(n)]
        for u, v in edges:
            adj[u-1].add(v-1)
            adj[v-1].add(u-1)
        odds = [u for u in range(n) if len(adj[u])%2]
        if len(odds) == 0:
            return True
        if len(odds) == 2:
            return any(odds[0] not in adj[u] and odds[1] not in adj[u] for u in range(n))
        if len(odds) == 4:
            return ((odds[0] not in adj[odds[1]] and odds[2] not in adj[odds[3]]) or
                    (odds[0] not in adj[odds[2]] and odds[1] not in adj[odds[3]]) or
                    (odds[0] not in adj[odds[3]] and odds[1] not in adj[odds[2]]))
        return False
",n
"
class Solution(object):
    def productExceptSelf(self, nums):
        if not nums:
            return []

        left_product = [1 for _ in range(len(nums))]
        for i in range(1, len(nums)):
            left_product[i] = left_product[i - 1] * nums[i - 1]

        right_product = 1
        for i in range(len(nums) - 2, -1, -1):
            right_product *= nums[i + 1]
            left_product[i] = left_product[i] * right_product

        return left_product

",n
"

MOD = 10**9+7
FACT, INV, INV_FACT = [[1]*2 for _ in range(3)]
def nCr(n, k):
    while len(INV) <= n: 
        FACT.append(FACT[-1]*len(INV) % MOD)
        INV.append(INV[MOD%len(INV)]*(MOD-MOD//len(INV)) % MOD) 
        INV_FACT.append(INV_FACT[-1]*INV[-1] % MOD)
    return (FACT[n]*INV_FACT[n-k] % MOD) * INV_FACT[k] % MOD


class Solution(object):
    def countGoodArrays(self, n, m, k):
        return (nCr(n-1, k)*(m*pow(m-1, (n-1)-k, MOD)))%MOD
",n + logm
"
import collections


class Solution(object):
    def differByOne(self, dict):
        MOD, P = 10**9+7, 113

        hashes = [0]*len(dict)
        for i, word in enumerate(dict):
            for c in word:
                hashes[i] = (P*hashes[i] + (ord(c)-ord('a'))) % MOD

        base = 1
        for p in reversed(range(len(dict[0]))):        
            lookup = collections.defaultdict(list)
            for i, word in enumerate(dict):
                new_hash = (hashes[i] - base*(ord(word[p])-ord('a'))) % MOD
                if new_hash in lookup:
                    for j in lookup[new_hash]:
                        if dict[j][:p]+dict[j][p+1:] == word[:p]+word[p+1:]:
                            return True
                lookup[new_hash].append(i)
            base = P*base % MOD
        return False
",n * m
"

class Solution(object):
    def maximumSubarrayXor(self, nums, queries):
        dp = [[nums[i] if j == 0 else 0 for j in range(len(nums)-i)] for i in range(len(nums))]
        for i in reversed(range(len(nums))):
            for l in range(1, len(nums)-i):
                dp[i][l] = dp[i][l-1]^dp[i+1][l-1]
        for i in reversed(range(len(nums))):
            for l in range(1, len(nums)-i):
                dp[i][l] = max(dp[i][l], dp[i][l-1], dp[i+1][l-1])
        return [dp[i][j-i] for i, j in queries]


",n^2 + q
"
class Solution2(object):
    def maximumSubarrayXor(self, nums, queries):
        dp = [[nums[i] if i == j else 0 for j in range(len(nums))] for i in range(len(nums))]
        for i in reversed(range(len(nums))):
            for j in range(i+1, len(nums)):
                dp[i][j] = dp[i][j-1]^dp[i+1][j]
        for i in reversed(range(len(nums))):
            for j in range(i+1, len(nums)):
                dp[i][j] = max(dp[i][j], dp[i][j-1], dp[i+1][j])
        return [dp[i][j] for i, j in queries]
",n^2 + q
"

class Solution(object):
    def isThereAPath(self, grid):
        if (len(grid)+len(grid[0])-1)%2:
            return False
        dp_left = [[float(""inf"")]*(len(grid[0])+1) for _ in range(2)]
        dp_left[0][1] = dp_left[1][0] = 0
        dp_right = [[float(""-inf"")]*(len(grid[0])+1) for _ in range(2)]
        dp_right[0][1] = dp_right[1][0] = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                dp_left[(i+1)%2][j+1] = min(dp_left[i%2][j+1], dp_left[(i+1)%2][j])+grid[i][j]
                dp_right[(i+1)%2][j+1] = max(dp_right[i%2][j+1], dp_right[(i+1)%2][j])+grid[i][j]
        return dp_left[len(grid)%2][-1] <= (len(grid)+len(grid[0])-1)//2 <= dp_right[len(grid)%2][-1]
",m * n
"

class Solution(object):
    def findTheString(self, lcp):
        result = [-1]*len(lcp)
        curr = 0
        for i in range(len(lcp)):
            if result[i] != -1:
                continue
            if curr == 26:
                return """"
            for j in range(i, len(lcp[0])):
                if lcp[i][j]:
                    result[j] = curr
            curr += 1
        for i in reversed(range(len(lcp))):
            for j in reversed(range(len(lcp[0]))):
                if lcp[i][j] != ((lcp[i+1][j+1]+1 if i+1 < len(lcp) and j+1 < len(lcp[0]) else 1) if result[i] == result[j] else 0):
                    return ''
        return """".join([chr(ord('a')+x) for x in result])
",n^2
"
class Solution(object):
    def robotSim(self, commands, obstacles):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        x, y, i = 0, 0, 0
        lookup = set(map(tuple, obstacles))
        result = 0
        for cmd in commands:
            if cmd == -2:
                i = (i-1) % 4
            elif cmd == -1:
                i = (i+1) % 4
            else:
                for k in range(cmd):
                    if (x+directions[i][0], y+directions[i][1]) not in lookup:
                        x += directions[i][0]
                        y += directions[i][1]
                        result = max(result, x*x + y*y)
        return result

",n + k
"
class Solution(object):
    def countGoodNumbers(self, n):
        def powmod(a, b, mod):
            a %= mod
            result = 1
            while b:
                if b&1:
                    result = (result*a)%mod
                a = (a*a)%mod
                b >>= 1
            return result

        MOD = 10**9 + 7
        return powmod(5, (n+1)//2%(MOD-1), MOD)*powmod(4, n//2%(MOD-1), MOD) % MOD


",logn
"class Solution2(object):
    def countGoodNumbers(self, n):
        MOD = 10**9 + 7
        return pow(5, (n+1)//2%(MOD-1), MOD)*pow(4, n//2%(MOD-1), MOD) % MOD
",logn
"

class Solution(object):
    def pushDominoes(self, dominoes):
        force = [0]*len(dominoes)

        f = 0
        for i in range(len(dominoes)):
            if dominoes[i] == 'R':
                f = len(dominoes)
            elif dominoes[i] == 'L':
                f = 0
            else:
                f = max(f-1, 0)
            force[i] += f

        f = 0
        for i in reversed(range(len(dominoes))):
            if dominoes[i] == 'L':
                f = len(dominoes)
            elif dominoes[i] == 'R':
                f = 0
            else:
                f = max(f-1, 0)
            force[i] -= f

        return """".join('.' if f == 0 else 'R' if f > 0 else 'L'
                       for f in force)

",n
"


import collections


class AhoNode(object):
    def __init__(self):
        self.children = collections.defaultdict(AhoNode)
        self.indices = []
        self.suffix = None
        self.output = None


class AhoTrie(object):

    def step(self, letter):
        while self.__node and letter not in self.__node.children:
            self.__node = self.__node.suffix
        self.__node = self.__node.children[letter] if self.__node else self.__root
        return self.__get_ac_node_outputs(self.__node)
    
    def __init__(self, patterns):
        self.__root = self.__create_ac_trie(patterns)
        self.__node = self.__create_ac_suffix_and_output_links(self.__root)
    
    def __create_ac_trie(self, patterns): 
        root = AhoNode()
        for i, pattern in enumerate(patterns):
            node = root
            for c in pattern:
                node = node.children[c]
            node.indices.append(i)
        return root

    def __create_ac_suffix_and_output_links(self, root): 
        queue = collections.deque()
        for node in root.children.values():
            queue.append(node)
            node.suffix = root

        while queue:
            node = queue.popleft()
            for c, child in node.children.items():
                queue.append(child)
                suffix = node.suffix
                while suffix and c not in suffix.children:
                    suffix = suffix.suffix
                child.suffix = suffix.children[c] if suffix else root
                child.output = child.suffix if child.suffix.indices else child.suffix.output
                
        return root

    def __get_ac_node_outputs(self, node): 
        result = []
        for i in node.indices:
            result.append(i)
        output = node.output
        while output:
            for i in output.indices:
                result.append(i)
            output = output.output
        return result
    

class Solution(object):
    def indexPairs(self, text, words):
        result = []
        reversed_words = [w[::-1] for w in words]
        trie = AhoTrie(reversed_words)
        for i in reversed(range(len(text))):
            for j in trie.step(text[i]):
                result.append([i, i+len(reversed_words[j])-1])
        result.reverse()
        return result
",n + m + z
"

class Solution(object):
    def maxFrequencyScore(self, nums, k):
        nums.sort()
        result = left = curr = 0
        for right in range(len(nums)):
            curr += nums[right]-nums[(left+right)//2]
            if not curr <= k:
                curr -= nums[((left+1)+right)//2]-nums[left]
                left += 1
        return right-left+1


",nlogn
"
class Solution2(object):
    def maxFrequencyScore(self, nums, k):
        nums.sort()
        result = left = curr = 0
        for right in range(len(nums)):
            curr += nums[right]-nums[(left+right)//2]
            while not curr <= k:
                curr -= nums[((left+1)+right)//2]-nums[left]
                left += 1
            result = max(result, right-left+1)
        return result


",nlogn
"
class Solution3(object):
    def maxFrequencyScore(self, nums, k):
        def check(l):
            return any((prefix[i+l]-prefix[i+(l+1)//2])-(prefix[i+l//2]-prefix[i]) <= k for i in range(len(nums)-l+1))

        nums.sort()
        prefix = [0]*(len(nums)+1)
        for i, x in enumerate(nums):
            prefix[i+1] = prefix[i]+x
        left, right = 1, len(nums)
        while left <= right:
            mid = left+(right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right
",nlogn
"

class Solution(object):
    def primePalindrome(self, N):
        def is_prime(n):
            if n < 2 or n % 2 == 0:
                return n == 2
            return all(n % d for d in range(3, int(n**.5) + 1, 2))

        if 8 <= N <= 11:
            return 11
        for i in range(10**(len(str(N))//2), 10**5):
            j = int(str(i) + str(i)[-2::-1])
            if j >= N and is_prime(j):
                return j

",n^(1/2) * (logn + n^(1/2))
"
import itertools


class Solution(object):
    def fib(self, N):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) \
                     for col in ZB] for row in A]

        T = [[1, 1],
             [1, 0]]
        return matrix_mult([[1, 0]], matrix_expo(T, N))[0][1] 


",logn
"class Solution2(object):
    def fib(self, N):
        prev, current = 0, 1
        for i in range(N):
            prev, current = current, prev + current,
        return prev
",n
"
import heapq



class Solution(object):
    def maxPoints(self, grid, queries):
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        min_heap = [(grid[0][0], 0, 0)]
        lookup = [[False]*len(grid[0]) for _ in range(len(grid))]
        lookup[0][0] = True
        mx = 0
        cnt = collections.Counter()
        while min_heap:
            curr, i, j = heapq.heappop(min_heap)
            mx = max(mx, curr)
            cnt[mx] += 1
            for di, dj in directions:
                ni, nj = i+di, j+dj
                if not (0 <= ni < len(grid) and
                        0 <= nj < len(grid[0]) and
                        not lookup[ni][nj]):
                    continue
                lookup[ni][nj] = True
                heapq.heappush(min_heap, (grid[ni][nj], ni, nj))
        vals = sorted(cnt.keys())
        prefix = [0]*(len(vals)+1)
        for i in range(len(vals)):
            prefix[i+1] += prefix[i]+cnt[vals[i]]
        return [prefix[bisect.bisect_left(vals, x)] for x in queries]
",(m * n + q) * log(m * n)
"
class Solution(object):
    def getLengthOfOptimalCompression(self, s, k):
        def length(cnt):
            l = 2 if cnt >= 2 else 1
            while cnt >= 10:
                l += 1
                cnt //= 10
            return l

        dp = [[len(s)]*(k+1) for _ in range(len(s)+1)]
        dp[0][0] = 0
        for i in range(1, len(s)+1):
            for j in range(k+1):
                if i-1 >= 0 and j-1 >= 0:
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1])
                keep = delete = 0
                for m in range(i, len(s)+1):
                    if s[i-1] == s[m-1]:
                        keep += 1
                    else:
                        delete += 1
                    if j+delete <= k:
                        dp[m][j+delete] = min(dp[m][j+delete], dp[i-1][j]+length(keep))
        return dp[len(s)][k]
",n^2 * k
"

class Solution(object):
    def kthCharacter(self, k):
        def popcount(x):
            return bin(x)[2:].count('1')

        return chr(ord('a')+popcount(k-1)%26)
",1
"
class Solution(object):
    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):
        max_run = -1
        i = max_prof = prof = waiting = 0
        run = 1
        while i < len(customers) or waiting > 0:
            if i < len(customers):
                waiting += customers[i] 
                i += 1
            boarding = min(waiting, 4) 
            waiting -= boarding
            prof += boarding * boardingCost - runningCost 
            if prof > max_prof:
                max_prof = prof
                max_run = run
            run += 1
        return max_run
",n
"

class Solution(object):
    def findLonely(self, nums):
        cnt = collections.Counter(nums)
        return [x for x in nums if cnt[x] == 1 and x-1 not in cnt and x+1 not in cnt]
",n
"



import collections
from functools import reduce


class Solution(object):
    def deleteDuplicateFolder(self, paths):
        def mark(node, lookup, node_ids):
            id_pairs = []
            for subfolder_id, child in node.items():
                if child == ""_del"":
                    continue
                id_pairs.append((subfolder_id, mark(child, lookup, node_ids)))
            id_pairs.sort()
            node_id = node_ids[tuple(id_pairs)]
            if node_id:
                if node_id in lookup:
                    lookup[node_id][""_del""]
                    node[""_del""]
                else:
                    lookup[node_id] = node
            return node_id

        def sweep(node, id_folders, path, result):
            if path:
                result.append([id_folders[i] for i in path])
            for subfolder_id, child in node.items():
                if ""_del"" in child:
                    continue
                path.append(subfolder_id)
                sweep(child, id_folders, path, result)
                path.pop()

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        folder_ids = collections.defaultdict()
        folder_ids.default_factory = folder_ids.__len__
        id_folders = {}
        for path in paths:
            node = trie
            for folder in path:
                if folder_ids[folder] not in id_folders:
                    id_folders[folder_ids[folder]] = folder
                node = node[folder_ids[folder]]
        node_ids = collections.defaultdict()
        node_ids.default_factory = node_ids.__len__
        mark(trie, {}, node_ids)
        result = []
        sweep(trie, id_folders, [], result)
        return result


",n * m * l + tlogt + l * t
"


import collections


class Solution2(object):
    def deleteDuplicateFolder(self, paths):
        def mark(node, lookup):
            serialized_tree = ""("" + """".join(subfolder + mark(child, lookup) for subfolder, child in sorted(node.items()) if child != ""_del"") + "")""
            if serialized_tree != ""()"":
                if serialized_tree in lookup:
                    lookup[serialized_tree][""_del""]
                    node[""_del""]
                else:
                    lookup[serialized_tree] = node
            return serialized_tree
        
        def sweep(node, path, result):
            if path:
                result.append(path[:])
            for subfolder, child in node.items():
                if ""_del"" in child:
                    continue
                path.append(subfolder)
                sweep(child, path, result)
                path.pop()

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for path in paths:
            reduce(dict.__getitem__, path, trie)
        mark(trie, {})
        result = []
        sweep(trie, [], result)
        return result
",n * m * l + l * tlogt + l * t^2
"

class Solution(object):
    def minOperations(self, nums):
        result = 0
        for x in nums:
            if x^(result&1):
                continue
            result += 1
        return result
",n
"
class Solution(object):
    def minPairSum(self, nums):
        nums.sort()
        return max(nums[i]+nums[-1-i] for i in range(len(nums)//2))
",nlogn
"
import itertools


class Solution(object):
    def minMovesToSeat(self, seats, students):
        seats.sort()
        students.sort()
        return sum(abs(a-b) for a, b in zip(seats, students))
",nlogn
"
import heapq
from sortedcontainers import SortedList



class Solution(object):
    def findMaximumElegance(self, items, k):
        curr = 0
        lookup = set()
        stk = []
        for p, c in heapq.nlargest(k, items):
            if c in lookup:
                stk.append(p)
            curr += p
            lookup.add(c)
        sl = SortedList()
        lookup2 = {}
        for p, c in items:
            if c in lookup:
                continue
            if c in lookup2:
                if lookup2[c] >= p:
                    continue
                sl.remove((lookup2[c], c))
            sl.add((p, c))
            lookup2[c] = p
            if len(sl) > len(stk):
                del lookup2[sl[0][1]]
                del sl[0]
        result = curr+len(lookup)**2
        for p, c in reversed(sl):
            curr += p-stk.pop()
            lookup.add(c)
            result = max(result, curr+len(lookup)**2) 
        return result


",nlogk
"import random
import collections


class Solution2(object):
    def findMaximumElegance(self, items, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        def nlargest(k, nums):
            nth_element(nums, k-1, compare=lambda a, b: a > b)
            return sorted(nums[:k], reverse=True)
    
        curr = 0
        lookup = set()
        stk = []
        for p, c in nlargest(k, items):
            if c in lookup:
                stk.append(p)
            curr += p
            lookup.add(c)
        lookup2 = collections.defaultdict(int)
        for p, c in items:
            if c in lookup:
                continue
            lookup2[c] = max(lookup2[c], p)
        l = len(lookup)
        result = curr+l**2
        for p in nlargest(min(len(stk), len(lookup2)), list(lookup2.values())):
            curr += p-stk.pop()
            l += 1
            result = max(result, curr+l**2) 
        return result


",n + klogk
"
class Solution3(object):
    def findMaximumElegance(self, items, k):
        items.sort(reverse=True)
        result = curr = 0
        lookup = set()
        stk = []
        for i in range(k):
            if items[i][1] in lookup:
                stk.append(items[i][0])
            curr += items[i][0]
            lookup.add(items[i][1])
        result = curr+len(lookup)**2
        for i in range(k, len(items)):
            if items[i][1] in lookup:
                continue
            if not stk:
                break
            curr += items[i][0]-stk.pop()
            lookup.add(items[i][1])
            result = max(result, curr+len(lookup)**2)
        return result
",nlogn
"

class Solution(object):
    def splitMessage(self, message, limit):
        cnt, l, total, base = 1, 1, len(message)+1, 1
        while 3+l*2 < limit:
            if total+(3+l)*cnt <= limit*cnt:
                break
            cnt += 1
            if cnt == base*10:
                l += 1
                base *= 10
            total += l
        if 3+l*2 >= limit:
            return []
        result = []
        j = 0
        for i in range(cnt):
            l = limit-(3+len(str(i+1))+len(str(cnt)))
            result.append(""%s<%s/%s>""%(message[j:j+l], i+1, cnt))
            j += l
        return result
",n + rlogr
"

class Solution(object):
    def answerString(self, word, numFriends):
        if numFriends == 1:
            return word
        idx = l = 0
        for i in range(1, len(word)):
            if word[i] == word[idx+l]:
                l += 1
            elif word[i] < word[idx+l]:
                l = 0
            elif word[i] > word[idx+l]:
                if word[i-l] >= word[i]:
                    idx = i-l
                else:
                    idx = i
                l = 0
        return word[idx:len(word)-max((numFriends-1)-idx, 0)]



",n
"
class Solution2(object):
    def answerString(self, word, numFriends):
        if numFriends == 1:
            return word
        m = len(word)-(numFriends-1)
        c = max(word)
        return max(word[i:i+m] for i in range(len(word)) if word[i] == c)
",n * m
"
class Solution(object):
    def reconstructQueue(self, people):
        people.sort(key=lambda h_k: (-h_k[0], h_k[1]))

        blocks = [[]]
        for p in people:
            index = p[1]

            for i, block in enumerate(blocks):
                if index <= len(block):
                    break
                index -= len(block)
            block.insert(index, p)

            if len(block) * len(block) > len(people):
                blocks.insert(i+1, block[len(block)/2:])
                del block[len(block)/2:]

        return [p for block in blocks for p in block]


",n * sqrt(n)
"class Solution2(object):
    def reconstructQueue(self, people):
        people.sort(key=lambda h_k1: (-h_k1[0], h_k1[1]))
        result = []
        for p in people:
            result.insert(p[1], p)
        return result

",n^2
"
import collections
import itertools
import heapq



class Solution(object):
    def mostFrequentIDs(self, nums, freq):
        result = []
        cnt = collections.Counter()
        max_heap = []
        for x, f in zip(nums, freq):
            cnt[x] += f
            heapq.heappush(max_heap, (-cnt[x], x))
            while max_heap and -max_heap[0][0] != cnt[max_heap[0][1]]:
                heapq.heappop(max_heap)
            result.append(-max_heap[0][0] if max_heap else 0)
        return result


",nlogn
"import collections
import itertools
from sortedcontainers import SortedList



class Solution2(object):
    def mostFrequentIDs(self, nums, freq):
        result = []
        cnt = collections.Counter()
        cnt2 = collections.Counter()
        sl = SortedList()
        for x, f in zip(nums, freq):
            sl.discard((cnt[x], cnt2[cnt[x]]))
            cnt2[cnt[x]] -= 1
            if cnt2[cnt[x]]:
                sl.add((cnt[x], cnt2[cnt[x]]))
            cnt[x] += f
            sl.discard((cnt[x], cnt2[cnt[x]]))
            cnt2[cnt[x]] += 1
            sl.add((cnt[x], cnt2[cnt[x]]))
            result.append(sl[-1][0])
        return result
",nlogn
"

class Solution(object):
    def largestSquareArea(self, bottomLeft, topRight):
        result = 0
        for i in range(len(bottomLeft)):
            for j in range(i+1, len(bottomLeft)):
                max_x = max(bottomLeft[i][0], bottomLeft[j][0])
                min_x = min(topRight[i][0], topRight[j][0])
                max_y = max(bottomLeft[i][1], bottomLeft[j][1])
                min_y = min(topRight[i][1], topRight[j][1])
                result = max(result, min(min_x-max_x, min_y-max_y))
        return result**2


",n^2
"
class Solution2(object):
    def largestSquareArea(self, bottomLeft, topRight):
        return max(max(min(min(topRight[i][0], topRight[j][0])-max(bottomLeft[i][0], bottomLeft[j][0]), min(topRight[i][1], topRight[j][1])-max(bottomLeft[i][1], bottomLeft[j][1])) for i in range(len(bottomLeft)) for j in range(i+1, len(bottomLeft))), 0)**2
",n^2
"
class Solution(object):
    def numDecodings(self, s):
        M, W = 1000000007, 3
        dp = [0] * W
        dp[0] = 1
        dp[1] = 9 if s[0] == '*' else dp[0] if s[0] != '0' else 0
        for i in range(1, len(s)):
            if s[i] == '*':
                dp[(i + 1) % W] = 9 * dp[i % W]
                if s[i - 1] == '1':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 9 * dp[(i - 1) % W]) % M
                elif s[i - 1] == '2':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 6 * dp[(i - 1) % W]) % M
                elif s[i - 1] == '*':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 15 * dp[(i - 1) % W]) % M
            else:
                dp[(i + 1) % W] = dp[i % W] if s[i] != '0' else 0
                if s[i - 1] == '1':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M
                elif s[i - 1] == '2' and s[i] <= '6':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M
                elif s[i - 1] == '*':
                    dp[(i + 1) % W] = (dp[(i + 1) % W] + (2 if s[i] <= '6' else 1) * dp[(i - 1) % W]) % M
        return dp[len(s) % W]

",n
"
class Solution(object):
    def numSubseq(self, nums, target):
        MOD = 10**9 + 7
        nums.sort()
        result = 0
        left, right = 0, len(nums)-1
        while left <= right:
            if nums[left]+nums[right] > target:
                right -= 1
            else:
                result = (result+pow(2, right-left, MOD))%MOD
                left += 1
        return result
",nlogn
"
import collections


class Solution(object):
    def largestMerge(self, word1, word2):
        q1 = collections.deque(word1)
        q2 = collections.deque(word2)
        result = []
        while q1 or q2:
            if q1 > q2:
                result.append(q1.popleft())
            else:
                result.append(q2.popleft())
        return """".join(result)
",n * m
"
class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1) 

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret



class Solution(object):
    def treeQueries(self, n, edges, queries):
        def iter_dfs():
            L, R, dist, lookup = [0]*n, [0]*n, [0]*n, [0]*n
            cnt = 0
            stk = [(1, (0, -1, 0))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, d = args
                    L[u] = cnt
                    cnt += 1
                    dist[u] = d
                    stk.append((2, (u,)))
                    for v, w in adj[u]:
                        if v == p:
                            continue
                        lookup[v] = w
                        stk.append((1, (v, u, d+w)))
                elif step == 2:
                    u = args[0]
                    R[u] = cnt
            return L, R, dist, lookup

        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            u -= 1
            v -= 1
            adj[u].append((v, w))
            adj[v].append((u, w))
        L, R, dist, lookup = iter_dfs()
        bit = BIT(n)
        result = []
        for q in queries:
            if q[0] == 1:
                _, u, v, w = q
                u -= 1
                v -= 1
                if L[u] > L[v]:
                    u, v = v, u 
                diff = w-lookup[v]
                bit.add(L[v], diff)
                bit.add(R[v], -diff)
                lookup[v] = w
            else:
                _, x = q
                x -= 1
                result.append(dist[x]+bit.query(L[x]))
        return result


",nlogn
"
class Solution2(object):
    def treeQueries(self, n, edges, queries):
        def dfs(u, p, d):
            L[u] = cnt[0]
            cnt[0] += 1
            dist[u] = d
            for v, w in adj[u]:
                if v == p:
                    continue
                lookup[v] = w
                dfs(v, u, d+w)
            R[u] = cnt[0]

        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            u -= 1
            v -= 1
            adj[u].append((v, w))
            adj[v].append((u, w))
        L, R, dist, lookup = [0]*n, [0]*n, [0]*n, [0]*n
        cnt = [0]
        dfs(0, -1, 0)
        bit = BIT(n)
        result = []
        for q in queries:
            if q[0] == 1:
                _, u, v, w = q
                u -= 1
                v -= 1
                if L[u] > L[v]:
                    u, v = v, u 
                diff = w-lookup[v]
                bit.add(L[v], diff)
                bit.add(R[v], -diff)
                lookup[v] = w
            else:
                _, x = q
                x -= 1
                result.append(dist[x]+bit.query(L[x]))
        return result
",nlogn
"
class Solution(object):
    def isBoomerang(self, points):
        return (points[0][0] - points[1][0]) * (points[0][1] - points[2][1]) - \
               (points[0][0] - points[2][0]) * (points[0][1] - points[1][1]) != 0
",1
"
class Solution(object):
    def binarySearchableNumbers(self, nums):
        right = [float(""inf"")]*(len(nums)+1)
        for i in reversed(range(1, len(nums)+1)):
            right[i-1] = min(right[i], nums[i-1])
        result, left = set(), float(""-inf"")
        for i in range(len(nums)):
            if left <= nums[i] <= right[i+1]:
                result.add(nums[i])
            left = max(left, nums[i])
        return len(result)
",n
"

class Solution(object):
    def isCovered(self, ranges, left, right):
        RANGE_SIZE = 50

        interval = [0]*(RANGE_SIZE+1)
        for l, r in ranges:
            interval[l-1] += 1
            interval[(r-1)+1] -= 1
        cnt = 0
        for i in range((right-1)+1):
            cnt += interval[i]
            if i >= left-1 and not cnt:
                return False
        return True


",n + r
"
class Solution2(object):
    def isCovered(self, ranges, left, right):
        ranges.sort()
        for l, r in ranges:
            if l <= left <= r:
                left = r+1
        return left > right


",nlogn
"class Solution3(object):
    def isCovered(self, ranges, left, right):
        return all(any(l <= i <= r for l, r in ranges) for i in range(left, right+1))
",n * r
"
class Solution(object):
    def getNoZeroIntegers(self, n):
        a, curr, base = 0, n, 1
        while curr: 
            if curr % 10 == 0 or (curr % 10 == 1 and curr != 1):
                a += base
                curr -= 10 
            a += base
            base *= 10
            curr //= 10
        return [a, n-a]


",logn
"class Solution2(object):
    def getNoZeroIntegers(self, n):
        return next([a, n-a] for a in range(1, n) if '0' not in '{}{}'.format(a, n-a))
",nlogn
"
import collections


class Solution(object):
    def canMouseWin(self, grid, catJump, mouseJump):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        DRAW, MOUSE, CAT = list(range(3))
        def parents(m, c, t):
            if t == CAT:
                for nm in graph[m, MOUSE^CAT^t]:
                    yield nm, c, MOUSE^CAT^t
            else:
                for nc in graph[c, MOUSE^CAT^t]:
                    yield m, nc, MOUSE^CAT^t

        R, C = len(grid), len(grid[0])
        N = R*C
        WALLS = set()
        FOOD, MOUSE_START, CAT_START = [-1]*3
        for r in range(R):
            for c in range(C):
                if grid[r][c] == 'M':
                    MOUSE_START = r*C + c
                elif grid[r][c] == 'C':
                    CAT_START = r*C + c
                elif grid[r][c] == 'F':
                    FOOD = r*C + c
                elif grid[r][c] == 
                    WALLS.add(r*C + c)

        graph = collections.defaultdict(set)
        jump = {MOUSE:mouseJump, CAT:catJump}
        for r in range(R):
            for c in range(C):
                if grid[r][c] == 
                    continue
                pos = r*C + c
                for t in [MOUSE, CAT]:
                    for dr, dc in directions:
                        for d in range(jump[t]+1):
                            nr, nc = r+dr*d, c+dc*d
                            if not (0 <= nr < R and 0 <= nc < C and grid[nr][nc] != 
                                break
                            graph[pos, t].add(nr*C + nc)

        degree = {}
        for m in range(N):
            for c in range(N):
                degree[m, c, MOUSE] = len(graph[m, MOUSE])
                degree[m, c, CAT] = len(graph[c, CAT])
        color = collections.defaultdict(int)
        q = collections.deque()
        for i in range(N):
            if i in WALLS or i == FOOD:
                continue
            color[FOOD, i, CAT] = MOUSE
            q.append((FOOD, i, CAT, MOUSE))
            color[i, FOOD, MOUSE] = CAT
            q.append((i, FOOD, MOUSE, CAT))
            for t in [MOUSE, CAT]:
                color[i, i, t] = CAT
                q.append((i, i, t, CAT))
        while q:
            i, j, t, c = q.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if nt == c:
                    color[ni, nj, nt] = c
                    q.append((ni, nj, nt, c))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = c
                    q.append((ni, nj, nt, c))
        return color[MOUSE_START, CAT_START, MOUSE] == MOUSE


",(m * n)^2 * (m + n)
"import collections


class Solution2(object):
    def canMouseWin(self, grid, catJump, mouseJump):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        DRAW, MOUSE, CAT = list(range(3))
        def parents(m, c, t):
            if t == CAT:
                for nm in graph[m, MOUSE^CAT^t]:
                    yield nm, c, MOUSE^CAT^t
            else:
                for nc in graph[c, MOUSE^CAT^t]:
                    yield m, nc, MOUSE^CAT^t

        R, C = len(grid), len(grid[0])
        N = R*C
        WALLS = set()
        FOOD, MOUSE_START, CAT_START = [-1]*3
        for r in range(R):
            for c in range(C):
                if grid[r][c] == 'M':
                    MOUSE_START = r*C + c
                elif grid[r][c] == 'C':
                    CAT_START = r*C + c
                elif grid[r][c] == 'F':
                    FOOD = r*C + c
                elif grid[r][c] == 
                    WALLS.add(r*C + c)
        graph = collections.defaultdict(set)
        jump = {MOUSE:mouseJump, CAT:catJump}
        for r in range(R):
            for c in range(C):
                if grid[r][c] == 
                    continue
                pos = r*C + c
                for t in [MOUSE, CAT]:
                    for dr, dc in directions:
                        for d in range(jump[t]+1):
                            nr, nc = r+dr*d, c+dc*d
                            if not (0 <= nr < R and 0 <= nc < C and grid[nr][nc] != 
                                break
                            graph[pos, t].add(nr*C + nc)

        degree = {}
        for m in range(N):
            for c in range(N):
                degree[m, c, CAT] = len(graph[c, CAT])
        color = collections.defaultdict(int)
        q1 = collections.deque()
        for i in range(N):
            if i in WALLS or i == FOOD:
                continue
            color[FOOD, i, CAT] = MOUSE
            q1.append((FOOD, i, CAT))
            color[i, FOOD, MOUSE] = CAT
            for t in [MOUSE, CAT]:
                color[i, i, t] = CAT
        while q1:
            i, j, t = q1.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if t == CAT:
                    color[ni, nj, nt] = MOUSE
                    q1.append((ni, nj, nt))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = MOUSE
                    q1.append((ni, nj, nt))
        return color[MOUSE_START, CAT_START, MOUSE] == MOUSE
",(m * n)^2 * (m + n)
"


class Solution(object):
    def openLock(self, deadends, target):
        dead = set(deadends)
        q = [""0000""]
        lookup = {""0000""}
        depth = 0
        while q:
            next_q = []
            for node in q:
                if node == target: return depth
                if node in dead: continue
                for i in range(4):
                    n = int(node[i])
                    for d in (-1, 1):
                        nn = (n+d) % 10
                        neighbor = node[:i] + str(nn) + node[i+1:]
                        if neighbor not in lookup:
                            lookup.add(neighbor)
                            next_q.append(neighbor)
            q = next_q
            depth += 1
        return -1

",k * n^k + d
"
class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1)

    def add(self, i, val):
        i += 1
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret



class Solution(object):
    def minMovesToMakePalindrome(self, s):
        idxs = [[] for _ in range(26)]
        for i, c in enumerate(s):
            idxs[ord(c)-ord('a')].append(i)
        targets, pairs = [0]*len(s), []
        for c, idx in enumerate(idxs):
            for i in range(len(idx)//2):
                pairs.append((idx[i], idx[~i]))
            if len(idx)%2:
                targets[idx[len(idx)//2]] = len(s)//2
        pairs.sort()
        for i, (l, r) in enumerate(pairs):
            targets[l], targets[r] = i, (len(s)-1)-i
        bit = BIT(len(s))
        result = 0
        for i in targets:
            result += i-bit.query(i-1) 
            bit.add(i, 1)
        return result


",nlogn
"
class Solution2(object):
    def minMovesToMakePalindrome(self, s):
        s = list(s)
        result = 0
        while s:
            i = s.index(s[-1])
            if i == len(s)-1:
                result += i//2
            else:
                result += i
                s.pop(i)
            s.pop()
        return result
",n^2
"
import collections
import heapq


class Solution(object):
    def highFive(self, items):
        min_heaps = collections.defaultdict(list)
        for i, val in items:
            heapq.heappush(min_heaps[i], val)
            if len(min_heaps[i]) > 5:
                heapq.heappop(min_heaps[i])
        return [[i, sum(min_heaps[i]) // len(min_heaps[i])] for i in sorted(min_heaps)]
",nlogn
"
class Solution(object):
    def goodDaysToRobBank(self, security, time):
        right = [0]
        for i in reversed(range(1, len(security))):
            right.append(right[-1]+1 if security[i] >= security[i-1] else 0)
        right.reverse()
        result = []
        left = 0
        for i in range(len(security)):
            if left >= time and right[i] >= time:
                result.append(i)
            if i+1 < len(security):
                left = left+1 if security[i] >= security[i+1] else 0
        return result
",n
"
import threading


class Solution(object):
    def __init__(self):
        self.__l = threading.Lock()
        self.__nH = 0
        self.__nO = 0
        self.__releaseHydrogen = None
        self.__releaseOxygen = None

    def hydrogen(self, releaseHydrogen):
        with self.__l:
            self.__releaseHydrogen = releaseHydrogen
            self.__nH += 1
            self.__output()

    def oxygen(self, releaseOxygen):
        with self.__l:
            self.__releaseOxygen = releaseOxygen
            self.__nO += 1
            self.__output()

    def __output(self):
        while self.__nH >= 2 and \
              self.__nO >= 1:
            self.__nH -= 2
            self.__nO -= 1
            self.__releaseHydrogen()
            self.__releaseHydrogen()
            self.__releaseOxygen()


",n
"
class Solution2(object):
    def __init__(self):
        self.__nH = 0
        self.__nO = 0
        self.__cv = threading.Condition()

    def hydrogen(self, releaseHydrogen):
        with self.__cv:
            while (self.__nH+1) - 2*self.__nO > 2:
                self.__cv.wait()
            self.__nH += 1
            releaseHydrogen()
            self.__cv.notifyAll()

    def oxygen(self, releaseOxygen):
        with self.__cv:
            while 2*(self.__nO+1) - self.__nH > 2:
                self.__cv.wait()
            self.__nO += 1
            releaseOxygen()
            self.__cv.notifyAll()
",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def maxDepth(self, root):
        if root is None:
            return 0
        else:
            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1

",n
"
import collections


class Solution(object):
    def subtreeWithAllDeepest(self, root):
        Result = collections.namedtuple(""Result"", (""node"", ""depth""))

        def dfs(node):
            if not node:
                return Result(None, 0)
            left, right = dfs(node.left), dfs(node.right)
            if left.depth > right.depth:
                return Result(left.node, left.depth+1)
            if left.depth < right.depth:
                return Result(right.node, right.depth+1)
            return Result(node, left.depth+1)

        return dfs(root).node

",n
"
class Solution(object):
    def cheapestJump(self, A, B):
        result = []
        if not A or A[-1] == -1:
            return result
        n = len(A)
        dp, next_pos = [float(""inf"")] * n, [-1] * n
        dp[n-1] = A[n-1]
        for i in reversed(range(n-1)):
            if A[i] == -1:
                continue
            for j in range(i+1, min(i+B+1,n)):
                if A[i] + dp[j] < dp[i]:
                    dp[i] = A[i] + dp[j]
                    next_pos[i] = j
        if dp[0] == float(""inf""):
            return result
        k = 0
        while k != -1:
            result.append(k+1)
            k = next_pos[k]
        return result

",n * B
"

class Solution(object):
    def differenceOfSums(self, n, m):
        def arithmetic_progression_sum(a, d, l):
            return (a+(a+(l-1)*d))*l//2
    
        return arithmetic_progression_sum(1, 1, n) - 2*arithmetic_progression_sum(m, m, n//m)


",1
"
class Solution2(object):
    def differenceOfSums(self, n, m):
        return (n+1)*n//2 - 2*(((n//m+1)*(n//m)//2)*m)
",1
"
import collections


class Solution(object):
    def minJumps(self, arr):
        groups = collections.defaultdict(list)
        for i, x in enumerate(arr):
            groups[x].append(i)
        q = collections.deque([(0, 0)])
        lookup = set([0])
        while q:
            pos, step = q.popleft()
            if pos == len(arr)-1:
                break
            neighbors = set(groups[arr[pos]] + [pos-1, pos+1])
            groups[arr[pos]] = []
            for p in neighbors:
                if p in lookup or not 0 <= p < len(arr):
                    continue
                lookup.add(p)
                q.append((p, step+1)) 
        return step
",n
"

class Solution(object):
    def smallestNumber(self, pattern):
        result = []
        for i in range(len(pattern)+1):
            if not (i == len(pattern) or pattern[i] == 'I'):
                continue
            for x in reversed(list(range(len(result)+1, (i+1)+1))):
                result.append(x)
        return """".join(map(str, result))
",n
"

class Solution(object):
    def maxActiveSectionsAfterTrade(self, s, queries):
        class SparseTable(object):
            def __init__(self, arr, fn):
                self.fn = fn
                self.bit_length = [0]
                n = len(arr)
                k = n.bit_length()-1 
                for i in range(k+1):
                    self.bit_length.extend(i+1 for _ in range(min(1<<i, (n+1)-len(self.bit_length))))
                self.st = [[0]*n for _ in range(k+1)]
                if not self.st:
                    return
                self.st[0] = arr[:]
                for i in range(1, k+1): 
                    for j in range((n-(1<<i))+1):
                        self.st[i][j] = fn(self.st[i-1][j], self.st[i-1][j+(1<<(i-1))])
        
            def query(self, L, R): 
                i = self.bit_length[R-L+1]-1
                return self.fn(self.st[i][L], self.st[i][R-(1<<i)+1])

        lookup = [-1]*len(s)
        idxs = []
        cnt1 = 0
        for i, x in enumerate(s):
            if x == '0':
                if i-1 >= 0 and s[i-1] == '0':
                    idxs[-1][1] += 1
                else:
                    idxs.append([i, 1])
            else:
                cnt1 += 1
            lookup[i] = len(idxs)-1
        if not idxs:
            return [cnt1]*len(queries)
        arr = [0]*(len(idxs)-1)
        for i in range(len(idxs)-1):
            arr[i] = idxs[i][1]+idxs[i+1][1]
        st = SparseTable(arr, max)
        result = [cnt1]*len(queries)
        for i, (l, r) in enumerate(queries):
            left, right  = lookup[l]+1, lookup[r]-int(s[r] == '0')
            left_cnt = idxs[lookup[l]][1]-(l-idxs[lookup[l]][0]) if lookup[l] != -1 else -1
            right_cnt = r-idxs[lookup[r]][0]+1 if lookup[r] != -1 else -1
            if left <= right-1:
                result[i] = max(result[i], cnt1 + st.query(left, right-1))
            if s[l] == '0' and s[r] == '0' and lookup[l]+1 == lookup[r]:
                result[i] = max(result[i], cnt1+left_cnt+right_cnt)
            if s[l] == '0' and lookup[l]+1 <= right:
                result[i] = max(result[i], cnt1+left_cnt+idxs[lookup[l]+1][1])
            if s[r] == '0' and left <= lookup[r]-1:
                result[i] = max(result[i], cnt1+right_cnt+idxs[lookup[r]-1][1])
        return result
",nlogn + q
"
class Solution(object):
    def nextGreaterElements(self, nums):
        result, stk = [0] * len(nums), []
        for i in reversed(range(2*len(nums))):
            while stk and stk[-1] <= nums[i % len(nums)]:
                stk.pop()
            result[i % len(nums)] = stk[-1] if stk else -1
            stk.append(nums[i % len(nums)])
        return result

",n
"
class Solution(object):
    def rotate(self, matrix):
        n = len(matrix)

        for i in range(n):
            for j in range(n - i):
                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]

        for i in range(n / 2):
            for j in range(n):
                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]

        return matrix

",n^2
"class Solution2(object):
    def rotate(self, matrix):
        return [list(reversed(x)) for x in zip(*matrix)]

",n^2
"
class Solution(object):
    def minTimeToVisitAllPoints(self, points):
        return sum(max(abs(points[i+1][0] - points[i][0]),
                       abs(points[i+1][1] - points[i][1]))
                   for i in range(len(points)-1))
",n
"
class Solution(object):
    def findCenter(self, edges):
        return edges[0][edges[0][1] in edges[1]]
",1
"
import itertools
from sortedcontainers import SortedList



class Solution(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        def query(sl, k):
            j = sl.bisect_left((k,))
            return sl[j-1][1] if j-1 >= 0 else NEG_INF
    
        def update(sl, k, v):
            j = sl.bisect_left((k,))
            if j < len(sl) and sl[j][0] == k:
                if not (sl[j][1] < v):
                    return
                del sl[j]
            elif not (j-1 < 0 or sl[j-1][1] < v):
                return
            sl.add((k, v))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]

        result = NEG_INF
        sl1, sl2 = SortedList(), SortedList()
        for price, profit in zip(prices, profits):
            result = max(result, query(sl2, price)+profit)
            update(sl1, price, profit)
            update(sl2, price, query(sl1, price)+profit)
        return result if result != NEG_INF else -1


",nlogn
"from sortedcontainers import SortedList



class Solution2(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")

        right = [NEG_INF]*len(prices)
        sl = SortedList()
        for i in reversed(range(len(prices))):
            j = sl.bisect_left((-prices[i],))
            if j-1 >= 0:
                right[i] = sl[j-1][1]
            if not (j-1 < 0 or sl[j-1][1] < profits[i]):
                continue
            sl.add((-prices[i], profits[i]))
            j = sl.bisect_left((-prices[i], profits[i]))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]
        result = NEG_INF
        sl = SortedList()
        for i in range(len(prices)):
            j = sl.bisect_left((prices[i],))
            if j-1 >= 0:
                result = max(result, sl[j-1][1]+profits[i]+right[i])
            if not (j-1 < 0 or sl[j-1][1] < profits[i]):
                continue
            sl.add((prices[i], profits[i]))
            j = sl.bisect_left((prices[i], profits[i]))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]
        return result if result != NEG_INF else -1


",nlogn
"import itertools



class Solution3(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [NEG_INF]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret

        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}
        result = NEG_INF
        bit1, bit2 = BIT(len(price_to_idx), default=NEG_INF, fn=max), BIT(len(price_to_idx), default=NEG_INF, fn=max)
        for price, profit in zip(prices, profits):
            result = max(result, bit2.query(price_to_idx[price]-1)+profit)
            bit1.update(price_to_idx[price], profit)
            bit2.update(price_to_idx[price], bit1.query(price_to_idx[price]-1)+profit)
        return result if result != NEG_INF else -1


",nlogn
"import itertools



class Solution4(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y),
                         update_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(self.tree[x], h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}
        result = NEG_INF
        st1, st2 = SegmentTree(len(price_to_idx)), SegmentTree(len(price_to_idx))
        for price, profit in zip(prices, profits):
            mx2 = st2.query(0, price_to_idx[price]-1)
            if mx2 is not None:
                result = max(result, mx2+profit)
            st1.update(price_to_idx[price], profit)
            mx1 = st1.query(0, price_to_idx[price]-1)
            if mx1 is not None:
                st2.update(price_to_idx[price], mx1+profit)
        return result if result != NEG_INF else -1


",nlogn
"
class Solution5(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y),
                         update_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(self.tree[x], h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}
        right = [NEG_INF]*len(prices)
        st = SegmentTree(len(price_to_idx))
        for i in reversed(range(len(prices))):
            right[i] = st.query(price_to_idx[prices[i]]+1, len(price_to_idx)-1)
            st.update(price_to_idx[prices[i]], profits[i])
        result = NEG_INF
        st = SegmentTree(len(price_to_idx))
        for i in range(len(prices)):
            left = st.query(0, price_to_idx[prices[i]]-1)
            if left is not None and right[i] is not None:
                result = max(result, left+profits[i]+right[i])
            st.update(price_to_idx[prices[i]], profits[i])
        return result if result != NEG_INF else -1
",nlogn
"

class Solution(object):
    def minZeroArray(self, nums, queries):
        def binary_search(left, right, check):
            while left <= right:
                mid = left+(right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(k):
            events = [0]*(len(nums)+1)
            for i in range(k):
                events[queries[i][0]] += queries[i][2]
                events[queries[i][1]+1] -= queries[i][2]
            curr = 0
            for i in range(len(nums)):
                curr += events[i]
                if nums[i] > curr:
                    return False
            return True
        
        result = binary_search(0, len(queries), check)
        return result if result <= len(queries) else -1
",(n + q) * logn
"

class Solution(object):
    def minimizeMax(self, nums, p):
        def check(x):
            i = cnt = 0
            while i+1 < len(nums) and cnt < p:
                if nums[i+1]-nums[i] <= x:
                    i += 1
                    cnt += 1
                i += 1
            return cnt == p

        nums.sort()
        left, right = 0, nums[-1]-nums[0]
        while left <= right:
            mid = left + (right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return left
",nlogn + nlogr
"

class Solution(object):
    def greatestLetter(self, s):
        lookup = set(s)
        result = """"
        for c in s:
            if c.isupper() and lower(c) in s:
                if c > result:
                    result = c
        return result


",n
"import itertools
import string



class Solution2(object):
    def greatestLetter(self, s):
        lookup = set(s)
        return next((C for c, C in zip(reversed(string.ascii_lowercase), reversed(string.ascii_uppercase)) if c in lookup and C in lookup), """")
   
",n
"

class Solution(object):
    def sellingWood(self, m, n, prices):
        dp = [[0]*(n+1) for i in range(m+1)]
        for h, w, p in prices:
            dp[h][w] = p
        for i in range(1, m+1):
            for j in range(1, n+1):
                for k in range(1, i//2+1):
                    dp[i][j] = max(dp[i][j], dp[k][j]+dp[i-k][j])
                for k in range(1, j//2+1):
                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[i][j-k])
        return dp[m][n]
",m * n * (m + n)
"

class Solution(object):
    def divisorGame(self, n):
        return n % 2 == 0


",1
"
class Solution2(object):
    def divisorGame(self, n):
        def factors(n):
            result = [[] for _ in range(n+1)]
            for i in range(1, n+1):
                for j in range(i, n+1, i):
                    result[j].append(i)
            return result

        FACTORS = factors(n)
        dp = [False]*(n+1)
        for i in range(2, n+1):
            dp[i] = any(not dp[i-j] for j in FACTORS[i] if j != i)
        return dp[-1]


",nlogn
"
class Solution3(object):
    def divisorGame(self, n):
        def factors(n):
            result = [[] for _ in range(n+1)]
            for i in range(1, n+1):
                for j in range(i, n+1, i):
                    result[j].append(i)
            return result
    
        def memoization(n):
            if lookup[n] is None:
                lookup[n] = any(not memoization(n-i) for i in FACTORS[n] if i != n)
            return lookup[n]

        FACTORS = factors(n)
        lookup = [None]*(n+1)
        return memoization(n)


",nlogn
"
class Solution4(object):
    def divisorGame(self, n):
        def factors(n):
            for i in range(1, n+1):
                if i*i > n:
                    break
                if n%i:
                    continue
                yield i
                if n//i != i:
                    yield n//i
    
        def memoization(n):
            if lookup[n] is None:
                lookup[n] = any(not memoization(n-i) for i in factors(n) if i != n)
            return lookup[n]

        lookup = [None]*(n+1)
        return memoization(n)


",n^(3/2)
"
class Solution5(object):
    def divisorGame(self, n):
        def factors(n):
            for i in range(1, n+1):
                if n%i:
                    continue
                yield i
    
        def memoization(n):
            if lookup[n] is None:
                lookup[n] = any(not memoization(n-i) for i in factors(n) if i != n)
            return lookup[n]

        lookup = [None]*(n+1)
        return memoization(n)
",n^2
"
class Solution(object):
    def minimumDeletions(self, nums):
        i, j = nums.index(min(nums)), nums.index(max(nums))
        if i > j:
            i, j = j, i
        return min((i+1)+(len(nums)-j), j+1, len(nums)-i)
",n
"
class Solution(object):
    def getRow(self, rowIndex):
        result = [0] * (rowIndex + 1)
        for i in range(rowIndex + 1):
            old = result[0] = 1
            for j in range(1, i + 1):
                old, result[j] = result[j], old + result[j]
        return result

    def getRow2(self, rowIndex):
        row = [1]
        for _ in range(rowIndex):
            row = [x + y for x, y in zip([0] + row, row + [0])]
        return row

    def getRow3(self, rowIndex):
        if rowIndex == 0: return [1]
        res = [1, 1]

        def add(nums):
            res = nums[:1]
            for i, j in enumerate(nums):
                if i < len(nums) - 1:
                    res += [nums[i] + nums[i + 1]]
            res += nums[:1]
            return res

        while res[1] < rowIndex:
            res = add(res)
        return res


",n^2
"class Solution2(object):
    def getRow(self, rowIndex):
        result = [1]
        for i in range(1, rowIndex + 1):
            result = [1] + [result[j - 1] + result[j] for j in range(1, i)] + [1]
        return result


",n^2
"

class Solution(object):
    def minimumBeautifulSubstrings(self, s):
        max_pow_5 = 1
        while max_pow_5*5 <= (1<<len(s))-1:
            max_pow_5 *= 5
        dp = [float(""inf"")]*(len(s)+1)
        dp[0] = 0
        for i in range(len(s)):
            if s[i] == '0':
                continue
            curr = 0
            for j in range(i, len(s)):
                curr = curr*2+int(s[j])
                if max_pow_5%curr == 0:
                    dp[j+1] = min(dp[j+1], dp[(i-1)+1]+1)
        return dp[-1] if dp[-1] != float(""inf"") else -1


",n^2
"
class Solution2(object):
    def minimumBeautifulSubstrings(self, s):
        max_pow_5 = 1
        while max_pow_5*5 <= (1<<len(s))-1:
            max_pow_5 *= 5
        dp = [float(""inf"")]*(len(s)+1)
        dp[0] = 0
        for i in range(len(s)):
            curr = 0
            for j in reversed(range(i+1)):
                curr += int(s[j])<<(i-j)
                if s[j] == '1' and max_pow_5%curr == 0:
                    dp[i+1] = min(dp[i+1], dp[(j-1)+1]+1)
        return dp[-1] if dp[-1] != float(""inf"") else -1
",n^2
"

class Solution(object):
    def minimumMoney(self, transactions):
        return sum(max(a-b, 0) for a, b in transactions)+max(a-max(a-b, 0) for a, b in transactions) 
",n
"
import collections


class Solution(object):
    def solve(self, board):
        if not board:
            return

        q = collections.deque()

        for i in range(len(board)):
            if board[i][0] == 'O':
                board[i][0] = 'V'
                q.append((i, 0))
            if board[i][len(board[0])-1] == 'O':
                board[i][len(board[0])-1] = 'V'
                q.append((i, len(board[0])-1))

        for j in range(1, len(board[0])-1):
            if board[0][j] == 'O':
                board[0][j] = 'V'
                q.append((0, j))
            if board[len(board)-1][j] == 'O':
                board[len(board)-1][j] = 'V'
                q.append((len(board)-1, j))

        while q:
            i, j = q.popleft()
            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if 0 <= x < len(board) and 0 <= y < len(board[0]) and \
                   board[x][y] == 'O':
                    board[x][y] = 'V'
                    q.append((x, y))

        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] != 'V':
                    board[i][j] = 'X'
                else:
                    board[i][j] = 'O'
",m * n
"
import itertools



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def leafSimilar(self, root1, root2):
        def dfs(node):
            if not node:
                return
            if not node.left and not node.right:
                yield node.val
            for i in dfs(node.left):
                yield i
            for i in dfs(node.right):
                yield i
        return all(a == b for a, b in
                   itertools.zip_longest(dfs(root1), dfs(root2)))

",n
"

class Solution(object):
    def maximumCandies(self, candies, k):
        def check(x):
            return sum(c//x for c in candies) >= k

        left, right = 1, max(candies)
        while left <= right:
            mid = left+(right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right
",nlogr
"
import random



class Solution(object):
    def maximizeSumOfWeights(self, edges, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def iter_dfs():
            cnt = [[0]*2 for _ in range(len(adj))]
            stk = [(1, 0, -1)]
            while stk:
                step, u, p = stk.pop()
                if step == 1:
                    stk.append((2, u, p))
                    for v, w in reversed(adj[u]):
                        if v == p:
                            continue
                        stk.append((1, v, u))
                elif step == 2:
                    curr = 0
                    diff = []
                    for v, w in adj[u]:
                        if v == p:
                            continue
                        curr += cnt[v][0]
                        diff.append(max((cnt[v][1]+w)-cnt[v][0], 0))
                    if k-1 < len(diff):
                        nth_element(diff, k-1, lambda a, b: a > b)
                    cnt[u][0] = curr+sum(diff[i] for i in range(min(k, len(diff))))
                    cnt[u][1] = curr+sum(diff[i] for i in range(min(k-1, len(diff))))
            return cnt[0][0]
    
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        return iter_dfs()


",n
"import random



class Solution2(object):
    def maximizeSumOfWeights(self, edges, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def dfs(u, p):
            result = 0
            diff = []
            for v, w in adj[u]:
                if v == p:
                    continue
                cnt = dfs(v, u)
                result += cnt[0]
                diff.append(max((cnt[1]+w)-cnt[0], 0))
            if k-1 < len(diff):
                nth_element(diff, k-1, lambda a, b: a > b)
            return (result+sum(diff[i] for i in range(min(k, len(diff)))), result+sum(diff[i] for i in range(min(k-1, len(diff)))))

        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        return dfs(0, -1)[0]
",n
"
import collections
import itertools


class Solution(object):
    def removeSubfolders(self, folder):
        def dfs(curr, path, result):
            if ""_end"" in curr:
                result.append(""/"" + ""/"".join(path))
                return
            for c in curr:
                if c == ""_end"":
                    continue
                path.append(c)
                dfs(curr[c], path, result)
                path.pop()

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for f in folder:
            f_list = f.split(""/"")
            reduce(dict.__getitem__,
                   itertools.islice(f_list, 1, len(f_list)),
                   trie).setdefault(""_end"")
        result = []
        dfs(trie, [], result)
        return result
  
",n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def rangeSumBST(self, root, L, R):
        result = 0
        s = [root]
        while s:
            node = s.pop()
            if node:
                if L <= node.val <= R:
                    result += node.val
                if L < node.val:
                    s.append(node.left)
                if node.val < R:
                    s.append(node.right)
        return result
",n
"
class Solution(object):
    def elementInNums(self, nums, queries):
        result = []
        for t, i in queries:
            t %= 2*len(nums)
            if t+i < len(nums):
                result.append(nums[t+i])
            elif i < t-len(nums):
                result.append(nums[i])
            else:
                result.append(-1)
        return result
",n
"
import heapq



class Solution(object):
    def halveArray(self, nums):
        target = sum(nums)/2.0
        max_heap = [-x for x in nums]
        heapq.heapify(max_heap)
        result = 1
        while max_heap:
            x = -heapq.heappop(max_heap)/2.0
            target -= x
            if target <= 0.0:
                break
            heapq.heappush(max_heap, -x)
            result += 1
        return result
",nlogn
"

class Solution(object):
    def maxNumberOfAlloys(self, n, k, budget, composition, stock, cost):
        def count(machine, budget):
            def cnt(x):
                return stock[x]//machine[x]
    
            idxs = list(range(n))
            idxs.sort(key=cnt)
            result = cnt(idxs[0])
            prefix = curr = discount = 0
            for i in range(n):
                curr += cost[idxs[i]]*machine[idxs[i]]
                discount += cost[idxs[i]]*(stock[idxs[i]]%machine[idxs[i]])
                if i+1 != n and cnt(idxs[i+1])-cnt(idxs[i]) == 0:
                    continue
                prefix += curr
                budget += discount
                curr = discount = 0
                mn = min((cnt(idxs[i+1])-cnt(idxs[i]) if i+1 < n else float(""inf"")), budget//prefix)
                if mn == 0:
                    break
                budget -= prefix*mn
                result += mn
            return result

        return max(count(machine, budget) for machine in composition)


",k * nlogn
"
class Solution2(object):
    def maxNumberOfAlloys(self, n, k, budget, composition, stock, cost):
        def check(x):
            for machine in composition:
                curr = 0
                for i in range(n):
                    curr += max(x*machine[i]-stock[i], 0)*cost[i]
                    if curr > budget:
                        break
                if curr <= budget:
                    return True
            return False

        left, right = 1, min(stock)+budget
        while left <= right:
            mid = left+(right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right
",k * n * logr
"
class Solution(object):
    def pruneTree(self, root):
        if not root:
            return None
        root.left = self.pruneTree(root.left)
        root.right = self.pruneTree(root.right)
        if not root.left and not root.right and root.val == 0:
            return None
        return root

",n
"
import itertools


class Solution(object):
    def magicalString(self, n):
        def gen(): 
            for c in 1, 2, 2:
                yield c
            for i, c in enumerate(gen()):
                if i > 1:
                    for _ in range(c):
                        yield i % 2 + 1

        return sum(c & 1 for c in itertools.islice(gen(), n))

",n
"
class Solution(object):
    def isPossible(self, nums):
        pre, cur = float(""-inf""), 0
        cnt1, cnt2, cnt3 = 0, 0, 0
        i = 0
        while i < len(nums):
            cnt = 0
            cur = nums[i]
            while i < len(nums) and cur == nums[i]:
                cnt += 1
                i += 1

            if cur != pre + 1:
                if cnt1 != 0 or cnt2 != 0:
                    return False
                cnt1, cnt2, cnt3 = cnt, 0, 0
            else:
                if cnt < cnt1 + cnt2:
                    return False
                cnt1, cnt2, cnt3 = max(0, cnt - (cnt1 + cnt2 + cnt3)), \
                                   cnt1, \
                                   cnt2 + min(cnt3, cnt - (cnt1 + cnt2))
            pre = cur
        return cnt1 == 0 and cnt2 == 0

",n
"

class Solution(object):
    def colorTheArray(self, n, queries):
        def update(i):
            if not nums[i]:
                return 0
            cnt = 0
            if i-1 >= 0 and nums[i-1] == nums[i]:
                cnt += 1
            if i+1 < n and nums[i+1] == nums[i]:
                cnt += 1
            return cnt

        nums = [0]*n
        result = [0]*len(queries)
        curr = 0
        for idx, (i, c) in enumerate(queries):
            curr -= update(i)
            nums[i] = c
            curr += update(i)
            result[idx] = curr
        return result
",n + q
"
class Solution(object):
    def beautifulArray(self, N):
        result = [1]
        while len(result) < N:
            result = [i*2 - 1 for i in result] + [i*2 for i in result]
        return [i for i in result if i <= N]
",n
"

class Solution(object):
    def canSplitArray(self, nums, m):
        return len(nums) <= 2 or any(nums[i]+nums[i+1] >= m for i in range(len(nums)-1))
",n
"

class Solution(object):
    def minSizeSubarray(self, nums, target):
        INF = float(""inf"")
        q, target = divmod(target, sum(nums))
        if not target:
            return q*len(nums)
        result = INF
        curr = left = 0
        for right in range((len(nums)-1)+(len(nums)-1)):
            curr += nums[right%len(nums)]
            while curr > target:
                curr -= nums[left%len(nums)]
                left += 1
            if curr == target:
                result = min(result, right-left+1)
        return result+q*len(nums) if result != INF else -1


",n
"
class Solution2(object):
    def minSizeSubarray(self, nums, target):
        INF = float(""inf"")
        q, target = divmod(target, sum(nums))
        if not target:
            return q*len(nums)
        result = INF
        lookup = {0:-1}
        prefix = 0
        for right in range((len(nums)-1)+(len(nums)-1)):
            prefix += nums[right%len(nums)]
            if prefix-target in lookup:
                result = min(result, right-lookup[prefix-target])
            lookup[prefix] = right
        return result+q*len(nums) if result != INF else -1
",n
"

class Solution(object):
    def minimumRemoval(self, beans):
        beans.sort()
        return sum(beans) - max(x*(len(beans)-i)for i, x in enumerate(beans))
",nlogn
"

class Solution(object):
    def checkDistances(self, s, distance):
        for i in range(len(s)):
            if i+distance[ord(s[i])-ord('a')]+1 >= len(s) or s[i+distance[ord(s[i])-ord('a')]+1] != s[i]:
                return False
            distance[ord(s[i])-ord('a')] = -1
        return True
",n
"
from sortedcontainers import SortedList



class Solution(object):
    def shortestDistanceAfterQueries(self, n, queries):
        sl = SortedList(range(n))
        result = []
        for u, v in queries:
            for i in reversed(range(sl.bisect_right(u), sl.bisect_left(v))): 
                sl.pop(i)
            result.append(len(sl)-1)
        return result
",nlogn
"
import itertools
from functools import reduce



class Solution(object):
    def minimumCost(self, target, words, costs):
        INF = float(""inf"")
        def query(i):
            curr = trie
            for j in range(i, len(target)):
                x = target[j]
                if x not in curr:
                    break
                curr = curr[x]
                if ""_end"" in curr:
                    dp[j+1] = min(dp[j+1], dp[i]+curr[""_end""])

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for w, c in zip(words, costs):
            node = reduce(dict.__getitem__, w, trie)
            if ""_end"" not in node:
                node[""_end""] = INF
            node[""_end""] = min(node[""_end""], c)
        dp = [INF]*(len(target)+1)
        dp[0] = 0
        for i in range(len(target)):
            if dp[i] == INF:
                continue
            query(i)
        return dp[-1] if dp[-1] != INF else -1


",n^2 + w * l
"import itertools



class Solution2(object):
    def minimumCost(self, target, words, costs):
        INF = float(""inf"")
        class Trie(object):
            def __init__(self):
                self.__nodes = []
                self.__mns = []
                self.__new_node()
            
            def __new_node(self):
                self.__nodes.append([-1]*26)
                self.__mns.append(INF)
                return len(self.__nodes)-1

            def add(self, w, c):
                curr = 0
                for x in w:
                    x = ord(x)-ord('a')
                    if self.__nodes[curr][x] == -1:
                        self.__nodes[curr][x] = self.__new_node()
                    curr = self.__nodes[curr][x]
                self.__mns[curr] = min(self.__mns[curr], c)
            
            def query(self, i):
                curr = 0
                for j in range(i, len(target)):
                    x = ord(target[j])-ord('a')
                    if self.__nodes[curr][x] == -1:
                        break
                    curr = self.__nodes[curr][x]
                    if self.__mns[curr] != INF:
                        dp[j+1] = min(dp[j+1], dp[i]+self.__mns[curr])
    
        trie = Trie()
        for w, c in zip(words, costs):
            trie.add(w, c)
        dp = [INF]*(len(target)+1)
        dp[0] = 0
        for i in range(len(target)):
            if dp[i] == INF:
                continue
            trie.query(i)
        return dp[-1] if dp[-1] != INF else -1
",n^2 + w * l
"
class Solution(object):
    def minSpeedOnTime(self, dist, hour):
        def ceil(a, b):
            return (a+b-1)//b

        def total_time(dist, x):
            return sum(ceil(dist[i], x) for i in range(len(dist)-1)) + float(dist[-1])/x

        def check(dist, hour, x):
            return total_time(dist, x) <= hour

        MAX_SPEED = 10**7
        if not check(dist, hour, MAX_SPEED):
            return -1
        left, right = 1, MAX_SPEED
        while left <= right:
            mid = left + (right-left)//2
            if check(dist, hour, mid):
                right = mid-1
            else:
                left = mid+1
        return left
",nlogr
"

class Solution(object):
    def findMaximalUncoveredRanges(self, n, ranges):
        ranges.sort()
        covered = [[-1, -1]]
        for left, right in ranges:
            if covered[-1][1] < left:
                covered.append([left, right])
                continue
            covered[-1][1] = max(covered[-1][1], right)    
        covered.append([n, n])        
        return [[covered[i-1][1]+1, covered[i][0]-1] for i in range(1, len(covered)) if covered[i-1][1]+1 <= covered[i][0]-1]
",nlogn
"
import collections


class Solution(object):
    def pathSum(self, root, sum):
        def pathSumHelper(root, curr, sum, lookup):
            if root is None:
                return 0
            curr += root.val
            result = lookup[curr-sum] if curr-sum in lookup else 0
            lookup[curr] += 1
            result += pathSumHelper(root.left, curr, sum, lookup) + \
                      pathSumHelper(root.right, curr, sum, lookup)
            lookup[curr] -= 1
            if lookup[curr] == 0:
                del lookup[curr]
            return result

        lookup = collections.defaultdict(int)
        lookup[0] = 1
        return pathSumHelper(root, 0, sum, lookup)


",n
"class Solution2(object):
    def pathSum(self, root, sum):
        def pathSumHelper(root, prev, sum):
            if root is None:
                return 0

            curr = prev + root.val
            return int(curr == sum) + \
                   pathSumHelper(root.left, curr, sum) + \
                   pathSumHelper(root.right, curr, sum)

        if root is None:
            return 0

        return pathSumHelper(root, 0, sum) + \
               self.pathSum(root.left, sum) + \
               self.pathSum(root.right, sum)

",n^2
"
import collections



class Solution(object):
    def numberOfPairs(self, nums1, nums2, k):
        cnt = [0]*(max(nums1)+1)
        for x, c in collections.Counter(k*x for x in nums2).items():
            for i in range(1, (len(cnt)-1)//x+1):
                cnt[i*x] += c
        return sum(cnt[x] for x in nums1)


",rlogr + n + m
"
class Solution2(object):
    def numberOfPairs(self, nums1, nums2, k):
        return sum(x%(k*y) == 0 for x in nums1 for y in nums2)
",n * m
"

class Solution(object):
    def lexicographicallySmallestArray(self, nums, limit):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        groups = []
        for i in range(len(nums)):
            if i-1 < 0 or nums[idxs[i]]-nums[idxs[i-1]] > limit:
                groups.append([])
            groups[-1].append(idxs[i])
        result = [-1]*len(nums)
        for g in groups:
            for i, j in enumerate(sorted(g)):
                result[j] = nums[g[i]]
        return result
",nlogn
"
class ArrayReader(object):
   def compareSub(self, l, r, x, y):
       pass

   def length(self):
       pass

class Solution(object):
    def getIndex(self, reader):
        left, right = 0, reader.length()-1
        while left < right:
            mid = left + (right-left)//2
            if reader.compareSub(left, mid, mid if (right-left+1)%2 else mid+1, right) >= 0:
                right = mid
            else:
                left = mid+1
        return left
",logn
"
import itertools



class Solution(object):
    def countPrefixes(self, words, s):
        return sum(map(s.startswith, words))
",n * l
"
import collections


class Solution(object):
    def numTriplets(self, nums1, nums2):
        def two_product(nums, i):
            count = 0
            lookup = collections.defaultdict(int)
            for num in nums:
                if i%num:
                    continue
                count += lookup[i//num]
                lookup[num] += 1
            return count
        
        result = 0
        for num in nums1:
            result += two_product(nums2, num**2)
        for num in nums2:
            result += two_product(nums1, num**2)
        return result
",m * n
"

import collections
import itertools


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        return True


class Solution(object):
    def generateSentences(self, synonyms, text):
        def assign_id(x, lookup, inv_lookup):
            if x in lookup:
                return
            lookup[x] = len(lookup)
            inv_lookup[lookup[x]] = x
        
        lookup, inv_lookup = {}, {}
        for u, v in synonyms:
            assign_id(u, lookup, inv_lookup), assign_id(v, lookup, inv_lookup)
        union_find = UnionFind(len(lookup))
        for u, v in synonyms:
            union_find.union_set(lookup[u], lookup[v])
        groups = collections.defaultdict(list)
        for i in range(len(union_find.set)):
            groups[union_find.find_set(i)].append(i)
        result = []
        for w in text.split(' '):
            if w not in lookup:
                result.append([w])
                continue
            result.append(sorted([inv_lookup[x] for x in groups[union_find.find_set(lookup[w])]]))
        return ["" "".join(sentense) for sentense in itertools.product(*result)]
",p*l * log(p*l)
"
import itertools
import bisect


class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):
        jobs = sorted(zip(endTime, startTime, profit))
        dp = [(0, 0)]
        for e, s, p in jobs:
            i = bisect.bisect_right(dp, (s+1, 0))-1
            if dp[i][1]+p > dp[-1][1]:
                dp.append((e, dp[i][1]+p))
        return dp[-1][1]


",nlogn
"import heapq
class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):
        min_heap = list(zip(startTime, endTime, profit))
        heapq.heapify(min_heap)
        result = 0
        while min_heap:
            s, e, p = heapq.heappop(min_heap)
            if s < e:
                heapq.heappush(min_heap, (e, s, result+p))
            else:
                result = max(result, p)
        return result
",nlogn
"

class Solution(object):
    def maxSum(self, grid):
        def total(i, j):
            return (grid[i][j]+grid[i][j+1]+grid[i][j+2]+
                               grid[i+1][j+1]+
                    grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2])

        return max(total(i, j) for i in range(len(grid)-2) for j in range(len(grid[0])-2))
",m * n
"

class Solution(object):
    def specialPerm(self, nums):
        MOD = 10**9+7
        def backtracking(i, mask):
            if mask == (1<<len(nums))-1:
                return 1
            if lookup[i+1][mask] == -1:
                total = 0
                for j in range(len(nums)):
                    if mask&(1<<j):
                        continue
                    if not (i == -1 or nums[i]%nums[j] == 0 or nums[j]%nums[i] == 0):
                        continue
                    total = (total+backtracking(j, mask|(1<<j)))%MOD
                lookup[i+1][mask] = total
            return lookup[i+1][mask]

        lookup = [[-1]*(1<<len(nums)) for _ in range(len(nums)+1)]
        return backtracking(-1, 0)
",n^2 * 2^n
"

class Solution(object):
    def appendCharacters(self, s, t):
        i = -1
        for j, c in enumerate(t):
            for i in range(i+1, len(s)):
                if s[i] == c:
                    break
            else:
                return len(t)-j
        return 0
",n
"

class Solution(object):
    def buildMatrix(self, k, rowConditions, colConditions):
        def topological_sort(conditions):
            adj = [[] for _ in range(k)]
            in_degree = [0]*k
            for u, v in conditions:
                u -= 1
                v -= 1
                adj[u].append(v)
                in_degree[v] += 1
            result = []
            q = [u for u in range(k) if not in_degree[u]]
            while q:
                new_q = []
                for u in q:
                    result.append(u)
                    for v in adj[u]:
                        in_degree[v] -= 1
                        if in_degree[v]:
                            continue
                        new_q.append(v)
                q = new_q
            return result

        row_order = topological_sort(rowConditions)
        if len(row_order) != k:
            return []
        col_order = topological_sort(colConditions)
        if len(col_order) != k:
            return []
        row_idx = {x:i for i, x in enumerate(row_order)}
        col_idx = {x:i for i, x in enumerate(col_order)}
        result = [[0]*k for _ in range(k)]
        for i in range(k):
            result[row_idx[i]][col_idx[i]] = i+1
        return result
",k^2 + r + c
"
class Solution(object):
    def maxDistance(self, colors):
        result = 0
        for i, x in enumerate(colors):
            if x != colors[0]:
                result = max(result, i)
            if x != colors[-1]:
                result = max(result, len(colors)-1-i)
        return result

",n
"
class Solution(object):
    def countNegatives(self, grid):
        result, c = 0, len(grid[0])-1
        for row in grid:
            while c >= 0 and row[c] < 0:
                c -= 1
            result += len(grid[0])-1-c
        return result
",m + n
"
class Solution(object):
    def sumOddLengthSubarrays(self, arr):
        def ceil_divide(a, b):
            return (a+(b-1))//b
        return sum(x * ceil_divide((i-0+1)*((len(arr)-1)-i+1), 2) for i, x in enumerate(arr))
",n
"
class Solution(object):
    def addDigits(self, num):
        return (num - 1) % 9 + 1 if num > 0 else 0

",1
"
class Solution(object):
    def minDeletionSize(self, A):
        result = 0
        for c in range(len(A[0])):
            for r in range(1, len(A)):
                if A[r-1][c] > A[r][c]:
                    result += 1
                    break
        return result


",n * l
"import itertools


class Solution2(object):
    def minDeletionSize(self, A):
        result = 0
        for col in zip(*A):
            if any(col[i] > col[i+1] for i in range(len(col)-1)):
                result += 1
        return result
",n * l
"

class Solution(object):
    def minLength(self, s):
        stk = []
        for c in s:
            if stk and ((stk[-1] == 'A' and c == 'B') or (stk[-1] == 'C' and c == 'D')):
                stk.pop()
                continue
            stk.append(c)
        return len(stk)
",n
"
class Solution(object):
    def findDuplicates(self, nums):
        result = []
        for i in nums:
            if nums[abs(i)-1] < 0:
                result.append(abs(i))
            else:
                nums[abs(i)-1] *= -1
        return result


",n
"class Solution2(object):
    def findDuplicates(self, nums):
        result = []
        i = 0
        while i < len(nums):
            if nums[i] != nums[nums[i]-1]:
                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
            else:
                i += 1

        for i in range(len(nums)):
            if i != nums[i]-1:
                result.append(nums[i])
        return result


",n
"from collections import Counter
class Solution3(object):
    def findDuplicates(self, nums):
        return [elem for elem, count in list(Counter(nums).items()) if count == 2]

",n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def twoSumBSTs(self, root1, root2, target):
        def inorder_gen(root, asc=True):
            result, stack = [], [(root, False)]
            while stack:
                root, is_visited = stack.pop()
                if root is None:
                    continue
                if is_visited:
                    yield root.val
                else:
                    if asc:
                        stack.append((root.right, False))
                        stack.append((root, True))
                        stack.append((root.left, False))
                    else:
                        stack.append((root.left, False))
                        stack.append((root, True))
                        stack.append((root.right, False))
        
        left_gen, right_gen = inorder_gen(root1, True), inorder_gen(root2, False)
        left, right = next(left_gen), next(right_gen)
        while left is not None and right is not None:
            if left + right < target:
                left = next(left_gen)
            elif left + right > target:
                right = next(right_gen)
            else:
                return True
        return False
",n
"

class Solution(object):
    def categorizeBox(self, length, width, height, mass):
        bulky = any(x >= 10**4 for x in (length, width, height)) or length*width*height >= 10**9
        heavy = mass >= 100
        if bulky and heavy:
            return ""Both""
        if bulky:
            return ""Bulky""
        if heavy:
            return ""Heavy""
        return ""Neither""


",1
"
class Solution2(object):
    def categorizeBox(self, length, width, height, mass):
        CATEGORIES = [""Neither"", ""Heavy"", ""Bulky"", ""Both""]
        i = 2*(any(x >= 10**4 for x in (length, width, height)) or length*width*height >= 10**9)+int(mass >= 100)
        return CATEGORIES[i]
",1
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def amountOfTime(self, root, start):
        def iter_dfs(root, start):
            result = -1
            stk = [(1, (root, [-1]*2))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    curr, ret = args
                    if curr is None:
                        continue
                    left, right = [-1]*2, [-1]*2
                    stk.append((2, (curr, left, right, ret)))
                    stk.append((1, (curr.right, right)))
                    stk.append((1, (curr.left, left)))
                elif step == 2:
                    curr, left, right, ret = args
                    d = -1
                    if curr.val == start:
                        d = 0
                        result = max(left[0], right[0])+1
                    elif left[1] >= 0:
                        d = left[1]+1
                        result = max(result, right[0]+1+d)
                    elif right[1] >= 0:
                        d = right[1]+1
                        result = max(result, left[0]+1+d)
                    ret[:] = [max(left[0], right[0])+1, d] 
            return result

        return iter_dfs(root, start)


",n
"
class Solution2(object):
    def amountOfTime(self, root, start):
        def dfs(curr, start, result):
            if curr is None:
                return [-1, -1]
            left = dfs(curr.left, start, result)
            right = dfs(curr.right, start, result)
            d = -1
            if curr.val == start:
                d = 0
                result[0] = max(left[0], right[0])+1
            elif left[1] >= 0:
                d = left[1]+1
                result[0] = max(result[0], right[0]+1+d)
            elif right[1] >= 0:
                d = right[1]+1
                result[0] = max(result[0], left[0]+1+d)
            return [max(left[0], right[0])+1, d] 

        result = [-1]
        dfs(root, start, result)
        return result[0]


",n
"
class Solution3(object):
    def amountOfTime(self, root, start):
        def bfs(root):
            adj = collections.defaultdict(list)
            q = [root]
            while q:
                new_q = []
                for u in q:
                    for v in (u.left, u.right):
                        if v is None:
                            continue
                        adj[u.val].append(v.val)
                        adj[v.val].append(u.val)
                        new_q.append(v)
                q = new_q
            return adj

        def bfs2(adj, start):
            result = -1
            q = [start]
            lookup = {start}
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if v in lookup:
                            continue
                        lookup.add(v)
                        new_q.append(v)
                q = new_q
                result += 1
            return result

        adj = bfs(root)
        return bfs2(adj, start)
",n
"

class Solution(object):
    def findThePrefixCommonArray(self, A, B):
        result = [0]*len(A)
        cnt = collections.Counter()
        curr = 0
        for i, (a, b) in enumerate(zip(A, B)):
            cnt[a] += 1
            if cnt[a] == 2:
                curr += 1
            cnt[b] += 1
            if cnt[b] == 2:
                curr += 1
            result[i] = curr
        return result
",n
"

class Solution(object):
    def numberCount(self, a, b):
        def popcount(x):
            return bin(x).count('1')

        def count2(n):
            if n == 0:
                return 0
            result = cnt = 1
            for i in range(n-1):
                cnt *= 9-i
                result += cnt
            return 9*result

        def count(x):
            n = base = 1
            while x//(base*10):
                base *= 10
                n += 1
            result = count2(n-1)
            lookup = 0
            cnt = reduce(lambda accu, i: accu*(9-i), range(n-1), 1)
            for i in range(n):
                d = (x//base)%10
                base //= 10
                mask = lookup&(((1<<d)-1)-int(i == 0))
                result += ((d-int(i == 0))-popcount(mask))*cnt
                cnt //= 9-i
                if lookup&(1<<d):
                    break
                lookup |= 1<<d
            return result

        return count(b+1)-count(a)


",logb
"
class Solution2(object):
    def numberCount(self, a, b):
        fact = [1]*2
        def nPr(n, k):
            while len(fact) <= n: 
                fact.append(fact[-1]*len(fact))
            return fact[n]//fact[n-k]
        
        def popcount(x):
            return bin(x).count('1')

        def count(x):
            digits = list(map(int, str(x)))
            result = 9*sum(nPr(9, i) for i in range(len(digits)-1))
            lookup = 0
            for i, d in enumerate(digits):
                mask = lookup&(((1<<d)-1)-int(i == 0))
                result += ((d-int(i == 0))-popcount(mask))*nPr(10-(i+1), len(digits)-(i+1))
                if lookup&(1<<d):
                    break
                lookup |= 1<<d
            return result

        return count(b+1)-count(a)


",logb
"
class Solution3(object):
    def numberCount(self, a, b):
        def check(x):
            lookup = 0
            while x:
                if lookup&(1<<(x%10)):
                    return False
                lookup |= (1<<(x%10))
                x //= 10
            return True

        return sum(check(x) for x in range(a, b+1))


",blogb
"
class Solution4(object):
    def numberCount(self, a, b):
        return sum(len(set(str(x))) == len(str(x)) for x in range(a, b+1))
",blogb
"
class Solution(object):
    def removeOnes(self, grid):
        return all(grid[i] == grid[0] or all(grid[i][j] != grid[0][j] for j in range(len(grid[0]))) for i in range(1, len(grid)))
",m * n
"
class Solution(object):
    def numberOfSubarrays(self, nums, k):
        def atMost(nums, k):
            result, left, count = 0, 0, 0
            for right, x in enumerate(nums):
                count += x%2
                while count > k:
                    count -= nums[left]%2
                    left += 1
                result += right-left+1
            return result

        return atMost(nums, k) - atMost(nums, k-1)


",n
"import collections


class Solution2(object):
    def numberOfSubarrays(self, nums, k):
        result = 0
        dq = collections.deque([-1])
        for i in range(len(nums)):
            if nums[i]%2:
                dq.append(i)
            if len(dq) > k+1:
                dq.popleft()
            if len(dq) == k+1:
                result += dq[1]-dq[0]
        return result
",n
"
class Solution(object):
    def convert(self, s, numRows):
        if numRows == 1:
            return s
        step, zigzag = 2 * numRows - 2, """"
        for i in range(numRows):
            for j in range(i, len(s), step):
                zigzag += s[j]
                if 0 < i < numRows - 1 and j + step - 2 * i < len(s):
                    zigzag += s[j + step - 2 * i]
        return zigzag

",n
"
class Solution(object):
    def lengthOfLongestSubstringTwoDistinct(self, s):
        longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in range(256)]
        for i, char in enumerate(s):
            if visited[ord(char)] == 0:
                distinct_count += 1
            visited[ord(char)] += 1
            while distinct_count > 2:
                visited[ord(s[start])] -= 1
                if visited[ord(s[start])] == 0:
                    distinct_count -= 1
                start += 1
            longest = max(longest, i - start + 1)
        return longest


",n
"from collections import Counter


class Solution2(object):
    def lengthOfLongestSubstringTwoDistinct(self, s):
        counter = Counter()
        left, max_length = 0, 0
        for right, char in enumerate(s):
            counter[char] += 1
            while len(counter) > 2:
                counter[s[left]] -= 1
                if counter[s[left]] == 0:
                    del counter[s[left]]
                left += 1
            max_length = max(max_length, right-left+1)
        return max_length
",n
"
class Solution(object):
    def numRollsToTarget(self, d, f, target):
        MOD = 10**9+7
        dp = [[0 for _ in range(target+1)] for _ in range(2)]
        dp[0][0] = 1
        for i in range(1, d+1):
            dp[i%2] = [0 for _ in range(target+1)]
            for k in range(1, f+1):
                for j in range(k, target+1):
                    dp[i%2][j] = (dp[i%2][j] + dp[(i-1)%2][j-k]) % MOD
        return dp[d%2][target] % MOD
",d * f * t
"

class Street:
    def closeDoor(self):
        pass
    def isDoorOpen(self):
        pass
    def moveRight(self):
        pass



class Solution(object):
    def houseCount(self, street, k):
        while not street.isDoorOpen():
            street.moveRight()
        result = 0
        for i in range(k+1):
            if i and street.isDoorOpen():
                street.closeDoor()
                result = i
            street.moveRight()
        return result
",k
"
import collections



class Solution(object):
    def distinctSequences(self, n):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        if n == 1:
            return 6
        MOD = 10**9 + 7
        dp = [[0]*6 for _ in range(6)]
        for i in range(6):
            for j in range(6):
                if i != j and gcd(i+1, j+1) == 1:
                    dp[i][j] = 1
        for _ in range(n-2):
            new_dp = [[0]*6 for _ in range(6)]
            for i in range(6):
                for j in range(6):
                    if not dp[i][j]:
                        continue
                    for k in range(6):
                        if not dp[j][k]:
                            continue
                        if k != i:
                            new_dp[i][j] = (new_dp[i][j]+dp[j][k]) % MOD
            dp = new_dp
        return sum(dp[i][j] for i in range(6) for j in range(6)) % MOD
",6^3 * n
"
import itertools


class Solution(object):
    def knightDialer(self, N):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) % M \
                     for col in ZB] for row in A]
        
        M = 10**9 + 7
        T = [[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],
             [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
             [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
             [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],
             [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
             [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
             [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],
             [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
             [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],
             [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]]
        return sum(map(sum, matrix_expo(T, N-1))) % M


",logn
"class Solution2(object):
    def knightDialer(self, N):
        M = 10**9 + 7
        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [],
                 [1, 7, 0], [2, 6], [1, 3], [2, 4]]

        dp = [[1 for _ in range(10)] for _ in range(2)]
        for i in range(N-1):
            dp[(i+1) % 2] = [0] * 10
            for j in range(10):
                for nei in moves[j]:
                    dp[(i+1) % 2][nei] += dp[i % 2][j]
                    dp[(i+1) % 2][nei] %= M
        return sum(dp[(N-1) % 2]) % M
",n
"

class Solution(object):
    def constructTransformedArray(self, nums):
        return [nums[(i+nums[i])%len(nums)] for i in range(len(nums))]
",n
"

class Solution(object):
    def minimumTime(self, time, totalTrips):
        def check(time, totalTrips, x):
            return sum(x//t for t in time) >= totalTrips

        left, right = 1, max(time)*totalTrips
        while left <= right:
            mid = left + (right-left)//2
            if check(time, totalTrips, mid):
                right = mid-1
            else:
                left = mid+1
        return left
",nlogr
"
class Solution(object):
    def findUnsortedSubarray(self, nums):
        n = len(nums)
        left, right = -1, -2
        min_from_right, max_from_left = nums[-1], nums[0]
        for i in range(1, n):
            max_from_left = max(max_from_left, nums[i])
            min_from_right = min(min_from_right, nums[n-1-i])
            if nums[i] < max_from_left: right = i
            if nums[n-1-i] > min_from_right: left = n-1-i


",n
"class Solution2(object):
    def findUnsortedSubarray(self, nums):
        a = sorted(nums)
        left, right = 0, len(nums) -1
        while (nums[left] == a[left] or nums[right] == a[right]):
            if right - left <= 1:
                return 0
            if nums[left] == a[left]:
                left += 1
            if nums[right] == a[right]:
                right -= 1
        return right - left + 1

",nlogn
"
class Solution(object):
    def calculateMinimumHP(self, dungeon):
        DP = [float(""inf"") for _ in dungeon[0]]
        DP[-1] = 1

        for i in reversed(range(len(dungeon))):
            DP[-1] = max(DP[-1] - dungeon[i][-1], 1)
            for j in reversed(range(len(dungeon[i]) - 1)):
                min_HP_on_exit = min(DP[j], DP[j + 1])
                DP[j] = max(min_HP_on_exit - dungeon[i][j], 1)

        return DP[0]

",m * n
"class Solution2(object):
    def calculateMinimumHP(self, dungeon):
        maximum_loses = 0
        for rooms in dungeon:
            for room in rooms:
                if room < 0:
                    maximum_loses += abs(room)

        return self.binarySearch(dungeon, maximum_loses)

    def binarySearch(self, dungeon, maximum_loses):
        start, end = 1, maximum_loses + 1
        result = 0
        while start < end:
            mid = start + (end - start) / 2
            if self.DP(dungeon, mid):
                end = mid
            else:
                start = mid + 1
        return start

    def DP(self, dungeon, HP):
        remain_HP = [0 for _ in dungeon[0]]
        remain_HP[0] = HP + dungeon[0][0]
        for j in range(1, len(remain_HP)):
            if remain_HP[j - 1] > 0:
                remain_HP[j] = max(remain_HP[j - 1] + dungeon[0][j], 0)

        for i in range(1, len(dungeon)):
            if remain_HP[0] > 0:
                remain_HP[0] = max(remain_HP[0] + dungeon[i][0], 0)
            else:
                remain_HP[0] = 0

            for j in range(1, len(remain_HP)):
                remain = 0
                if remain_HP[j - 1] > 0:
                    remain = max(remain_HP[j - 1] + dungeon[i][j], remain)
                if remain_HP[j] > 0:
                    remain = max(remain_HP[j] + dungeon[i][j], remain)
                remain_HP[j] = remain

        return remain_HP[-1] > 0

",m * n logk
"

class Solution(object):
    def phonePrefix(self, numbers):
        numbers.sort()
        return all(not numbers[i+1].startswith(numbers[i]) for i in range(len(numbers)-1))


",l * nlogn
"
class Solution2(object):
    def phonePrefix(self, numbers):
        class Trie(object):
            def __init__(self):
                self.__nodes = []
                self.__new_node()
            
            def __new_node(self):
                self.__nodes.append([-1]*(10+1))
                return len(self.__nodes)-1

            def add(self, s):
                made = False
                curr = 0
                for i in range(len(s)):
                    x = ord(s[i])-ord('0')
                    if self.__nodes[curr][x] == -1:
                        self.__nodes[curr][x] = self.__new_node()
                        made = True
                    elif self.__nodes[self.__nodes[curr][x]][-1] == True:
                        return False
                    curr = self.__nodes[curr][x]
                self.__nodes[curr][-1] = True
                return made
    
        trie = Trie()
        return all(trie.add(x) for x in numbers)
",n * l
"
class Solution(object):
    def knightProbability(self, N, K, r, c):
        directions = \
            [[ 1, 2], [ 1, -2], [ 2, 1], [ 2, -1], \
             [-1, 2], [-1, -2], [-2, 1], [-2, -1]]
        dp = [[[1 for _ in range(N)] for _ in range(N)] for _ in range(2)]
        for step in range(1, K+1):
            for i in range(N):
                for j in range(N):
                    dp[step%2][i][j] = 0
                    for direction in directions:
                        rr, cc = i+direction[0], j+direction[1]
                        if 0 <= cc < N and 0 <= rr < N:
                            dp[step%2][i][j] += 0.125 * dp[(step-1)%2][rr][cc]

        return dp[K%2][r][c]

",k * n^2
"
class Solution(object):
    def numTimesAllBlue(self, light):
        result, right = 0, 0
        for i, num in enumerate(light, 1):
            right = max(right, num)
            result += (right == i)
        return result
",n
"
import collections


class Solution(object):
    def countCharacters(self, words, chars):
        def check(word, chars, count):
            if len(word) > len(chars):
                return False
            curr_count = collections.Counter()
            for c in word:
                curr_count[c] += 1
                if c not in count or count[c] < curr_count[c]:
                    return False
            return True
        
        count = collections.Counter(chars)
        return sum(len(word) for word in words if check(word, chars, count))

",m * n
"

class Solution(object):
    def findTheLongestBalancedSubstring(self, s):
        result = 0
        for i in range(len(s)):
            left, right = i+1, i
            while left-1 >= 0 and right+1 < len(s) and s[left-1] == '0' and s[right+1] == '1':
                left -= 1
                right += 1
            result = max(result, right-left+1)
        return result


",n
"
class Solution2(object):
    def findTheLongestBalancedSubstring(self, s):
        result = 0
        prev, cnt = [0]*2, [0]*2
        for c in s:
            cnt[int(c)] += 1
            if cnt[int(c)^1]:
                prev[int(c)^1], cnt[int(c)^1] = cnt[int(c)^1], 0
            result = max(result, 2*min(prev[0], cnt[1]))
        return result
",n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def maxAncestorDiff(self, root):
        result = 0
        stack = [(root, 0, float(""inf""))]
        while stack:
            node, mx, mn = stack.pop()
            if not node:
                continue
            result = max(result, mx-node.val, node.val-mn)
            mx = max(mx, node.val)
            mn = min(mn, node.val)
            stack.append((node.left, mx, mn))
            stack.append((node.right, mx, mn))
        return result


",n
"
class Solution2(object):
    def maxAncestorDiff(self, root):
        def maxAncestorDiffHelper(node, mx, mn): 
            if not node:
                return 0
            result = max(mx-node.val, node.val-mn)
            mx = max(mx, node.val)
            mn = min(mn, node.val)
            result = max(result, maxAncestorDiffHelper(node.left, mx, mn))
            result = max(result, maxAncestorDiffHelper(node.right, mx, mn))
            return result

        return maxAncestorDiffHelper(root, 0, float(""inf""))
",n
"
class Solution(object):
    def minFlips(self, s):
        result = float(""inf"")
        cnt1 = cnt2 = 0
        for i in range(2*len(s)-1 if len(s)%2 else len(s)):
            if i >= len(s):
                cnt1 -= int(s[i%len(s)])^((i-len(s))%2)^0
                cnt2 -= int(s[i%len(s)])^((i-len(s))%2)^1
            cnt1 += int(s[i%len(s)])^(i%2)^0
            cnt2 += int(s[i%len(s)])^(i%2)^1
            if i >= len(s)-1:
                result = min(result, cnt1, cnt2)
        return result
",n
"
class Solution(object):
    def eliminateMaximum(self, dist, speed):
        for i in range(len(dist)):
            dist[i] = (dist[i]-1)//speed[i]
        dist.sort()
        result = 0
        for i in range(len(dist)):
            if result > dist[i]:
                break
            result += 1
        return result
",nlogn
"

class Solution(object):
    def resultsArray(self, nums, k):
        result = [-1]*(len(nums)-k+1)
        left = 0
        for right in range(len(nums)):
            if nums[right]-nums[left] != right-left:
                left = right
            if right-left+1 == k:
                result[left] = nums[right]
                left += 1
        return result


",n
"
class Solution2(object):
    def resultsArray(self, nums, k):
        return [nums[i+k-1] if all(nums[j]+1 == nums[j+1] for j in range(i, i+k-1)) else -1 for i in range(len(nums)-k+1)]
",n^2
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self is None:
            return ""Nil""
        else:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def deleteDuplicates(self, head):
        dummy = ListNode(0)
        pre, cur = dummy, head
        while cur:
            if cur.__next__ and cur.next.val == cur.val:
                val = cur.val
                while cur and cur.val == val:
                    cur = cur.__next__
                pre.next = cur
            else:
                pre.next = cur
                pre = cur
                cur = cur.__next__
        return dummy.__next__

",n
"
import itertools
import bisect


class Solution(object):
    def minimumDifference(self, nums):
        left, right = nums[:len(nums)//2], nums[len(nums)//2:]
        total1, total2 = sum(left), sum(right)
        result = float(""inf"")
        for k in range(len(left)+1): 
            sums = sorted(2*sum(comb)-total1 for comb in itertools.combinations(left, k))
            for comb in itertools.combinations(right, len(left)-k): 
                diff = 2*sum(comb)-total2
                i = bisect.bisect_left(sums, -diff)
                if i < len(sums):
                    result = min(result, abs(sums[i]+diff))
                if i > 0:
                    result = min(result, abs(sums[i-1]+diff))
        return result
",n * 2^n
"
import heapq



class Solution(object):
    def kBigIndices(self, nums, k):
        right = [False]*len(nums)
        max_heap1 = []
        for i in reversed(range(len(nums))):
            if len(max_heap1) == k and nums[i] > -max_heap1[0]:
                right[i] = True
            heapq.heappush(max_heap1, -nums[i])
            if len(max_heap1) == k+1:
                heapq.heappop(max_heap1)
        result = 0
        max_heap2 = []
        for i in range(len(nums)):
            if len(max_heap2) == k and nums[i] > -max_heap2[0] and right[i]:
                result += 1
            heapq.heappush(max_heap2, -nums[i])
            if len(max_heap2) == k+1:
                heapq.heappop(max_heap2)
        return result


",nlogk
"from sortedcontainers import SortedList



class Solution2(object):
    def kBigIndices(self, nums, k):
        sl1, sl2 = SortedList(), SortedList(nums)
        result = 0
        for x in nums:
            sl2.remove(x)
            if sl1.bisect_left(x) >= k and sl2.bisect_left(x) >= k:
                result += 1
            sl1.add(x)
        return result
",nlogn
"
class Solution(object):
    def numDupDigitsAtMostN(self, N):
        def P(m, n):
            result = 1
            for _ in range(n):
                result *= m
                m -= 1
            return result

        digits = list(map(int, str(N+1)))
        result = 0

        for i in range(1, len(digits)):
            result += P(9, 1)*P(9, i-1)
        prefix_set = set()
        for i, x in enumerate(digits):
            for y in range(1 if i == 0 else 0, x):
                if y in prefix_set:
                    continue
                result += P(9-i, len(digits)-i-1)
            if x in prefix_set:
                break
            prefix_set.add(x)
        return N-result
",logn
"
class Solution(object):
    def findBuildings(self, heights):
        result = []
        for i, h in enumerate(heights):
            while result and heights[result[-1]] <= h:
                result.pop()
            result.append(i)
        return result


",n
"class Solution2(object):
    def findBuildings(self, heights):
        result = []
        for i in reversed(range(len(heights))):
            if not result or heights[result[-1]] < heights[i]:
                result.append(i)
        result.reverse()
        return result
",n
"

class Solution(object):
    def smallestNumber(self, n):
        return (1<<n.bit_length())-1
",1
"

class Solution(object):
    def divisorSubstrings(self, num, k):
        result = curr = 0
        s = list(map(int, str(num)))
        base = 10**(k-1)
        for i, x in enumerate(s):
            if i-k >= 0:
                curr -= s[i-k]*base
            curr = curr*10+x
            if i+1 >= k:
                result += int(curr and num%curr == 0)
        return result
",logn
"
import collections


class Solution(object):
    def longestSubsequence(self, arr, difference):
        result = 1
        lookup = collections.defaultdict(int)
        for i in range(len(arr)):
            lookup[arr[i]] = lookup[arr[i]-difference] + 1
            result = max(result, lookup[arr[i]])
        return result
",n
"
class Solution(object):
    def maxVowels(self, s, k):
        VOWELS = set(""aeiou"")
        result = curr = 0
        for i, c in enumerate(s):
            curr += c in VOWELS
            if i >= k:
                curr -= s[i-k] in VOWELS
            result = max(result, curr)
        return result
",n
"
class Solution(object):
    def getSum(self, a, b):
        bit_length = 32
        neg_bit, mask = (1 << bit_length) >> 1, ~(~0 << bit_length)

        a = (a | ~mask) if (a & neg_bit) else (a & mask)
        b = (b | ~mask) if (b & neg_bit) else (b & mask)

        while b:
            carry = a & b
            a ^= b
            a = (a | ~mask) if (a & neg_bit) else (a & mask)
            b = carry << 1
            b = (b | ~mask) if (b & neg_bit) else (b & mask)

        return a

    def getSum2(self, a, b):
        MAX = 0x7FFFFFFF
        MIN = 0x80000000
        mask = 0xFFFFFFFF
        while b:
            a, b = (a ^ b) & mask, ((a & b) << 1) & mask
        return a if a <= MAX else ~(a ^ mask)

    def minus(self, a, b):
        b = self.getSum(~b, 1)
        return self.getSum(a, b)

    def multiply(self, a, b):
        isNeg = (a > 0) ^ (b > 0)
        x = a if a > 0 else self.getSum(~a, 1)
        y = b if b > 0 else self.getSum(~b, 1)
        ans = 0
        while y & 0x01:
            ans = self.getSum(ans, x)
            y >>= 1
            x <<= 1
        return self.getSum(~ans, 1) if isNeg else ans

    def divide(self, a, b):
        isNeg = (a > 0) ^ (b > 0)
        x = a if a > 0 else self.getSum(~a, 1)
        y = b if b > 0 else self.getSum(~b, 1)
        ans = 0
        for i in range(31, -1, -1):
            if (x >> i) >= y:
                x = self.minus(x, y << i)
                ans = self.getSum(ans, 1 << i)
        return self.getSum(~ans, 1) if isNeg else ans


",1
"

class Solution(object):
    def remainingMethods(self, n, k, invocations):
        def bfs():
            lookup = [False]*n
            lookup[k] = True
            q = [k]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return lookup

        adj = [[] for _ in range(n)]
        for u, v in invocations:
            adj[u].append(v)
        lookup = bfs()
        return [u for u in range(n) if not lookup[u]] if all(lookup[u] == lookup[v] for u, v in invocations) else list(range(n))
",n + e
"
class Solution(object):
    def xorOperation(self, n, start):
        def xorNums(n, start):
            def xorNumsBeginEven(n, start):
                assert(start%2 == 0)
                return ((n//2)%2)^((start+n-1) if n%2 else 0)

            return start^xorNumsBeginEven(n-1, start+1) if start%2 else xorNumsBeginEven(n, start)
        
        return int(n%2 and start%2) + 2*xorNums(n, start//2)


",1
"import operator
from functools import reduce


class Solution2(object):
    def xorOperation(self, n, start):
        return reduce(operator.xor, (i for i in range(start, start+2*n, 2)))
",n
"

class Solution(object):
    def maxScore(self, nums):
        return sum(nums)-min(nums) if len(nums)%2 else sum(nums)-min(nums[i]+nums[i+1] for i in range(len(nums)-1))
",n
"

class Solution(object):
    def minimumOperations(self, nums):
        return sum(x%3 != 0 for x in nums)


",n
"
class Solution2(object):
    def minimumOperations(self, nums):
        return sum(min(x%3, 3-x%3) for x in nums)
",n
"
class Solution(object):
    def canPartition(self, nums):
        s = sum(nums)
        if s % 2:
            return False

        dp = [False] * (s/2 + 1)
        dp[0] = True
        for num in nums:
            for i in reversed(range(1, len(dp))):
                if num <= i:
                    dp[i] = dp[i] or dp[i - num]
        return dp[-1]

",n * s
"
class Solution(object):
    def numMovesStonesII(self, stones):
        stones.sort()
        left, min_moves = 0, float(""inf"")
        max_moves = max(stones[-1]-stones[1], stones[-2]-stones[0]) - (len(stones)-2)
        for right in range(len(stones)):
            while stones[right]-stones[left]+1 > len(stones):
                left += 1
            if len(stones)-(right-left+1) == 1 and stones[right]-stones[left]+1 == len(stones)-1:
                min_moves = min(min_moves, 2) 
            else:
                min_moves = min(min_moves, len(stones)-(right-left+1)) 
        return [min_moves, max_moves]
",nlogn
"

class Solution(object):
    def maxWeight(self, pizzas):
        l = len(pizzas)//4
        pizzas.sort(reverse=True)
        return sum(pizzas[i] for i in range((l+1)//2))+sum(pizzas[i] for i in range((l+1)//2+1, ((l+1)//2+1)+(l//2)*2, 2))
",nlogn
"
class Solution(object):
    def corpFlightBookings(self, bookings, n):
        result = [0]*(n+1)
        for i, j, k in bookings:
            result[i-1] += k
            result[j] -= k
        for i in range(1, len(result)):
            result[i] += result[i-1]
        result.pop()
        return result
",n
"

class Solution(object):
    def maxPartitionsAfterOperations(self, s, k):
        def popcount(n):
            n = (n & 0x55555555) + ((n >> 1) & 0x55555555)
            n = (n & 0x33333333) + ((n >> 2) & 0x33333333)
            n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)
            n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)
            n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)
            return n

        left = [0]*(len(s)+1)
        left_mask = [0]*(len(s)+1)
        cnt = mask = 0
        for i in range(len(s)):
            mask |= 1<<(ord(s[i])-ord('a'))
            if popcount(mask) > k:
                cnt += 1
                mask = 1<<(ord(s[i])-ord('a'))
            left[i+1] = cnt
            left_mask[i+1] = mask
        right = [0]*(len(s)+1)
        right_mask = [0]*(len(s)+1)
        cnt = mask = 0
        for i in reversed(range(len(s))):
            mask |= 1<<(ord(s[i])-ord('a'))
            if popcount(mask) > k:
                cnt += 1
                mask = 1<<(ord(s[i])-ord('a'))
            right[i] = cnt
            right_mask[i] = mask

        result = 0
        for i in range(len(s)):
            curr = left[i]+right[i+1]
            mask = left_mask[i]|right_mask[i+1]
            if popcount(left_mask[i]) == popcount(right_mask[i+1]) == k and popcount(mask) != 26:
                curr += 3
            elif popcount(mask)+int(popcount(mask) != 26) > k: 
                curr += 2
            else:
                curr += 1
            result = max(result, curr)
        return result
",n
"
class Solution(object):
    def fullJustify(self, words, maxWidth):
        def addSpaces(i, spaceCnt, maxWidth, is_last):
            if i < spaceCnt:
                return 1 if is_last else (maxWidth // spaceCnt) + int(i < maxWidth % spaceCnt)
            return 0

        def connect(words, maxWidth, begin, end, length, is_last):
            s = [] 
            n = end - begin
            for i in range(n):
                s += words[begin + i],
                s += ' ' * addSpaces(i, n - 1, maxWidth - length, is_last),
            line = """".join(s)
            if len(line) < maxWidth:
                line += ' ' * (maxWidth - len(line))
            return line

        res = []
        begin, length = 0, 0
        for i in range(len(words)):
            if length + len(words[i]) + (i - begin) > maxWidth:
                res += connect(words, maxWidth, begin, i, length, False),
                begin, length = i, 0
            length += len(words[i])

        res += connect(words, maxWidth, begin, len(words), length, True),
        return res


",n
"
import heapq


class Solution(object):
    def furthestBuilding(self, heights, bricks, ladders):
        min_heap = []
        for i in range(len(heights)-1):
            diff = heights[i+1]-heights[i]
            if diff > 0:
                heapq.heappush(min_heap, diff)
            if len(min_heap) <= ladders: 
                continue
            bricks -= heapq.heappop(min_heap) 
            if bricks < 0: 
                return i
        return len(heights)-1
",nlogk
"
import collections


class Solution(object):
    def numPairsDivisibleBy60(self, time):
        result = 0
        count = collections.Counter()
        for t in time:
            result += count[-t%60]
            count[t%60] += 1
        return result
",n
"
class Solution(object):
    def numJewelsInStones(self, J, S):
        lookup = set(J)
        return sum(s in lookup for s in S)


",m + n
"
class Solution(object):
    def findContestMatch(self, n):
        matches = list(map(str, list(range(1, n+1))))
        while len(matches)/2:
            matches = [""({},{})"".format(matches[i], matches[-i-1]) for i in range(len(matches)/2)]
        return matches[0]


",n
"
class Solution(object):
    def kEmptySlots(self, flowers, k):
        days = [0] * len(flowers)
        for i in range(len(flowers)):
            days[flowers[i]-1] = i
        result = float(""inf"")
        i, left, right = 0, 0, k+1
        while right < len(days):
            if days[i] < days[left] or days[i] <= days[right]:
                if i == right:
                    result = min(result, max(days[left], days[right]))
                left, right = i, k+1+i
            i += 1
        return -1 if result == float(""inf"") else result+1


",n
"
class Solution(object):
    def largestOverlap(self, A, B):
        count = [0] * (2*len(A)-1)**2
        for i, row in enumerate(A):
            for j, v in enumerate(row):
                if not v:
                    continue
                for i2, row2 in enumerate(B):
                    for j2, v2 in enumerate(row2):
                        if not v2:
                            continue
                        count[(len(A)-1+i-i2)*(2*len(A)-1) +
                              len(A)-1+j-j2] += 1
        return max(count)

",n^4
"

class Solution(object):
    def findNumber(self):
        BIT_COUNT = 30
        result = 0
        prev = commonBits(0)
        for i in range(BIT_COUNT):
            curr = commonBits(1<<i)
            if curr-prev == 1:
                result |= 1<<i
            prev = curr
        return result


",logr
"
class Solution2(object):
    def findNumber(self):
        BIT_COUNT = 30
        return reduce(lambda accu, i: accu|(1<<i if commonBits(1<<i)-commonBits(1<<i) == 1 else 0), range(BIT_COUNT), 0)
",logr
"
class Solution(object):
    def decompressRLElist(self, nums):
        return [nums[i+1] for i in range(0, len(nums), 2) for _ in range(nums[i])]
",n
"
class Solution(object):
    def printTree(self, root):
        def getWidth(root):
            if not root:
                return 0
            return 2 * max(getWidth(root.left), getWidth(root.right)) + 1

        def getHeight(root):
            if not root:
                return 0
            return max(getHeight(root.left), getHeight(root.right)) + 1

        def preorderTraversal(root, level, left, right, result):
            if not root:
                return
            mid = left + (right-left)/2
            result[level][mid] = str(root.val)
            preorderTraversal(root.left, level+1, left, mid-1, result)
            preorderTraversal(root.right, level+1, mid+1, right, result)

        h, w = getHeight(root), getWidth(root)
        result = [[""""] * w for _ in range(h)]
        preorderTraversal(root, 0, 0, w-1, result)
        return result

",h * 2^h
"

class Solution(object):
    def maxOperations(self, s):
        result = curr = 0
        for i in range(len(s)):
            if s[i] == '1':
                curr += 1
            elif i+1 == len(s) or s[i+1] == '1':
                result += curr
        return result


",n
"
class Solution2(object):
    def maxOperations(self, s):
        result = curr = 0
        for i in range(len(s)):
            if s[i] != '1':
                continue
            curr += 1
            if i+1 < len(s) and s[i+1] == '0':
                result += curr
        return result
",n
"
class Solution(object):
    def projectionArea(self, grid):
        result = 0
        for i in range(len(grid)):
            max_row, max_col = 0, 0
            for j in range(len(grid)):
                if grid[i][j]:
                    result += 1
                max_row = max(max_row, grid[i][j])
                max_col = max(max_col, grid[j][i])
            result += max_row + max_col
        return result

",n^2
"
class Solution(object):
    def minOperations(self, nums):
        def unique(nums):
            left = 0
            for right in range(1, len(nums)):
                if nums[left] != nums[right]:
                    left += 1
                    nums[left] = nums[right]
            return left

        def erase(nums, i):
            while len(nums) > i+1:
                nums.pop()

        n = len(nums)
        nums.sort()
        erase(nums, unique(nums))
        result = l = 0
        for i in range(len(nums)):
            if nums[i] <= nums[i-l]+n-1:
                l += 1
        return n-l


",nlogn
"class Solution2(object):
    def minOperations(self, nums):
        n = len(nums)
        nums = sorted(set(nums))
        result = right = 0
        for left in range(len(nums)):
            while right < len(nums) and nums[right] <= nums[left]+n-1:
                right += 1
            result = max(result, right-left)
        return n-result
",nlogn
"
class Solution(object):
    def isSubtree(self, s, t):
        def isSame(x, y):
            if not x and not y:
                return True
            if not x or not y:
                return False
            return x.val == y.val and \
                   isSame(x.left, y.left) and \
                   isSame(x.right, y.right)

        def preOrderTraverse(s, t):
            return s != None and \
                   (isSame(s, t) or \
                    preOrderTraverse(s.left, t) or \
                    preOrderTraverse(s.right, t))

        return preOrderTraverse(s, t)

",m * n
"
class Solution(object):
    def findLeaves(self, root):
        def findLeavesHelper(node, result):
            if not node:
                return -1
            level = 1 + max(findLeavesHelper(node.left, result), \
                            findLeavesHelper(node.right, result))
            if len(result) < level + 1:
                result.append([])
            result[level].append(node.val)
            return level

        result = []
        findLeavesHelper(root, result)
        return result

",n
"
class Solution(object):
    def isAlienSorted(self, words, order):
        lookup = {c: i for i, c in enumerate(order)}
        for i in range(len(words)-1):
            word1 = words[i]
            word2 = words[i+1]
            for k in range(min(len(word1), len(word2))):
                if word1[k] != word2[k]:
                    if lookup[word1[k]] > lookup[word2[k]]:
                        return False
                    break
            else:
                if len(word1) > len(word2):
                    return False
        return True
",n * l
"

class Solution(object):
    def countOfPeaks(self, nums, queries):
        class BIT(object): 
            def __init__(self, nums):
                self.__bit = [0]*(len(nums)+1) 
                for i in range(1, len(self.__bit)):
                    self.__bit[i] = nums[i-1] + self.__bit[i-1]
                for i in reversed(range(1, len(self.__bit))):
                    last_i = i - (i & -i)
                    self.__bit[i] -= self.__bit[last_i]

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret

        def check(i):
            return nums[i-1] < nums[i] > nums[i+1]

        def update(x, d):
            for i in range(max(x-1, 1), min((x+1)+1, len(nums)-1)):
                if check(i):
                    bit.add(i, d)

        bit = BIT([int(1 <= i <= len(nums)-2 and check(i)) for i in range(len(nums))])
        result = []
        for t, x, y in queries:
            if t == 1:
                result.append(bit.query(y-1)-bit.query((x+1)-1) if y-1 >= x+1 else 0)
                continue
            update(x, -1)
            nums[x] = y
            update(x, +1)
        return result


",n + qlogn
"
class Solution2(object):
    def countOfPeaks(self, nums, queries):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret

        def check(i):
            return nums[i-1] < nums[i] > nums[i+1]

        def update(x, d):
            for i in range(max(x-1, 1), min((x+1)+1, len(nums)-1)):
                if check(i):
                    bit.add(i, d)

        bit = BIT(len(nums))
        for i in range(1, len(nums)-1):
            if check(i):
                bit.add(i, +1)
        result = []
        for t, x, y in queries:
            if t == 1:
                result.append(bit.query(y-1)-bit.query((x+1)-1) if y-1 >= x+1 else 0)
                continue
            update(x, -1)
            nums[x] = y
            update(x, +1)
        return result
",nlogn + qlogn
"
class Solution(object):
    def numTeams(self, rating):
        result = 0
        for i in range(1, len(rating)-1):
            less, greater = [0]*2, [0]*2
            for j in range(len(rating)):
                if rating[i] > rating[j]:
                    less[i < j] += 1
                if rating[i] < rating[j]:
                    greater[i < j] += 1
            result += less[0]*greater[1] + greater[0]*less[1]
        return result
",n^2
"
class Solution(object):
    def minPartitions(self, n):
        return int(max(n))
",n
"
import itertools



class Solution(object):
    def relocateMarbles(self, nums, moveFrom, moveTo):
        lookup = set(nums)
        for a, b in zip(moveFrom, moveTo):
            lookup.remove(a)
            lookup.add(b)
        return sorted(lookup)
",nlogn
"
class Solution(object):
    def minCost(self, costs):
        if not costs:
            return 0

        min_cost = [costs[0], [0, 0, 0]]

        n = len(costs)
        for i in range(1, n):
            min_cost[i % 2][0] = costs[i][0] + \
                                 min(min_cost[(i - 1) % 2][1], min_cost[(i - 1) % 2][2])
            min_cost[i % 2][1] = costs[i][1] + \
                                 min(min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][2])
            min_cost[i % 2][2] = costs[i][2] + \
                                 min(min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][1])

        return min(min_cost[(n - 1) % 2])

",n
"class Solution2(object):
    def minCost(self, costs):
        if not costs:
            return 0

        n = len(costs)
        for i in range(1, n):
            costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])
            costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])
            costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])

        return min(costs[n - 1])

",n
"
import heapq



class Solution(object):
    def resultsArray(self, queries, k):
        result = []
        max_heap = []
        for x, y in queries:
            heapq.heappush(max_heap, -(abs(x)+abs(y)))
            if len(max_heap) == k+1:
                heapq.heappop(max_heap)
            result.append(-max_heap[0] if len(max_heap) == k else -1)
        return result
",qlogk
"

class Solution(object):
    def arrayChange(self, nums, operations):
        lookup = {x:i for i, x in enumerate(nums)}
        for x, y in operations:
            lookup[y] = lookup.pop(x)
        for x, i in lookup.items():
            nums[i] = x
        return nums


",n + m
"
class Solution2(object):
    def arrayChange(self, nums, operations):
        lookup = {x:i for i, x in enumerate(nums)}
        for x, y in operations:
            nums[lookup[x]] = y
            lookup[y] = lookup.pop(x)
        return nums
",n + m
"
import random



class Solution(object):
    def highestRankedKItems(self, grid, pricing, start, k):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def get_val(x):
            return (lookup[x[0]][x[1]], grid[x[0]][x[1]], x[0], x[1])
    
        result = []
        q = [start]
        lookup = [[-1]*len(grid[0]) for _ in range(len(grid))]
        d = lookup[start[0]][start[1]] = 0
        while q:
            if len(result) >= k:
                if len(result) > k:
                    nth_element(result, k-1, compare=lambda a, b: get_val(a) < get_val(b))
                    result = result[:k]
                break
            new_q = []
            for r, c in q:
                if pricing[0] <= grid[r][c] <= pricing[1]:
                    result.append([r, c])
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] and lookup[nr][nc] == -1):
                        continue
                    lookup[nr][nc] = d+1
                    new_q.append((nr, nc))
            q = new_q
            d += 1
        result.sort(key=lambda x: get_val(x))
        return result
",m * n + klogk
"
class Solution(object):
    def canDivideIntoSubsequences(self, nums, K):
        curr, max_count = 1, 1
        for i in range(1, len(nums)):
            curr = 1 if nums[i-1] < nums[i] else curr+1
            max_count = max(max_count, curr)
        return K*max_count <= len(nums)
",n
"
class Solution(object):
    def countPalindromicSubsequences(self, S):
        def dp(i, j, prv, nxt, lookup):
            if lookup[i][j] is not None:
                return lookup[i][j]
            result = 1
            if i <= j:
                for x in range(4):
                    i0 = nxt[i][x]
                    j0 = prv[j][x]
                    if i <= i0 <= j:
                        result = (result + 1) % P
                    if None < i0 < j0:
                        result = (result + dp(i0+1, j0-1, prv, nxt, lookup)) % P
            result %= P
            lookup[i][j] = result
            return result

        prv = [None] * len(S)
        nxt = [None] * len(S)

        last = [None] * 4
        for i in range(len(S)):
            last[ord(S[i])-ord('a')] = i
            prv[i] = tuple(last)

        last = [None] * 4
        for i in reversed(range(len(S))):
            last[ord(S[i])-ord('a')] = i
            nxt[i] = tuple(last)

        P = 10**9 + 7
        lookup = [[None] * len(S) for _ in range(len(S))]
        return dp(0, len(S)-1, prv, nxt, lookup) - 1

",n^2
"

class Solution(object):
    def largestIsland(self, grid):
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def dfs(r, c, index, grid):
            if not (0 <= r < len(grid) and
                    0 <= c < len(grid[0]) and
                    grid[r][c] == 1):
                return 0
            result = 1
            grid[r][c] = index
            for d in directions:
                result += dfs(r+d[0], c+d[1], index, grid)
            return result

        area = {}
        index = 2
        for r in range(len(grid)):
            for c in range(len(grid[r])):
                if grid[r][c] == 1:
                    area[index] = dfs(r, c, index, grid)
                    index += 1

        result = max(list(area.values()) or [0])
        for r in range(len(grid)):
            for c in range(len(grid[r])):
                if grid[r][c] == 0:
                    seen = set()
                    for d in directions:
                        nr, nc = r+d[0], c+d[1]
                        if not (0 <= nr < len(grid) and
                                0 <= nc < len(grid[0]) and
                                grid[nr][nc] > 1):
                            continue
                        seen.add(grid[nr][nc])
                    result = max(result, 1 + sum(area[i] for i in seen))
        return result

",n^2
"

class Solution(object):
    def numberOfArrays(self, differences, lower, upper):
        total = mn = mx = 0
        for x in differences:
            total += x
            mn = min(mn, total)
            mx = max(mx, total)
        return max((upper-lower)-(mx-mn)+1, 0)
",n
"

class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y),
                 update_fn=lambda x, y: y if x is None else x+y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h)
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))



class Solution(object):
    def minDayskVariants(self, points, k):
        def add_rec(rec, intervals):
            x0, y0, x1, y1 = rec
            intervals.append([[x0,   +1], [y0, y1]])
            intervals.append([[x1+1, -1], [y0, y1]])

        def check(points, k, l): 
            intervals = []
            y_set = set()
            for x, y in points:
                add_rec([x-l, y-l, x+l, y+l], intervals)
                y_set.add(y-l)
                y_set.add(y+l)
            intervals.sort()
            y_to_idx = {y:i for i, y in enumerate(sorted(y_set))} 
            st = SegmentTree(len(y_to_idx))
            for [_, v], [y0, y1] in intervals: 
                st.update(y_to_idx[y0], y_to_idx[y1], v)
                if st.query(0, len(y_to_idx)-1) >= k:
                    return True
            return False
                
        points = [[x+y, x-y] for x, y in points] 
        min_x = min(points)[0]
        max_x = max(points)[0]
        min_y = min(points, key=lambda x: x[1])[1]
        max_y = max(points, key=lambda x: x[1])[1]
        left, right = 0, ((max_x-min_x)+(max_y-min_y)+1)//2
        while left <= right:
            mid = left + (right-left)//2
            if check(points, k, mid):
                right = mid-1
            else:
                left = mid+1
        return left


",nlogn * logr
"import collections



class Solution2(object):
    def minDayskVariants(self, points, k):
        def add_rec(rec, intervals):
            x0, y0, x1, y1 = rec
            intervals[x0][y0] += 1
            intervals[x0][y1+1] -= 1
            intervals[x1+1][y0] -= 1
            intervals[x1+1][y1+1] += 1

        def check(points, k, l): 
            intervals = collections.defaultdict(lambda:collections.defaultdict(int))
            y_set = set()
            for x, y in points:
                add_rec([x-l, y-l, x+l, y+l], intervals)
                y_set.add(y-l)
                y_set.add(y+l+1)
            sorted_y = sorted(y_set)
            sorted_x = sorted(intervals.keys())
            count = collections.Counter()
            for x in sorted_x: 
                for y, c in intervals[x].items():
                    count[y] += c
                cnt = 0
                for y in sorted_y:
                    cnt += count[y]
                    if cnt >= k:
                        return True
            return False
                
        points = [[x+y, x-y] for x, y in points] 
        min_x = min(points)[0]
        max_x = max(points)[0]
        min_y = min(points, key=lambda x: x[1])[1]
        max_y = max(points, key=lambda x: x[1])[1]
        left, right = 0, ((max_x-min_x)+(max_y-min_y)+1)//2
        while left <= right:
            mid = left + (right-left)//2
            if check(points, k, mid):
                right = mid-1
            else:
                left = mid+1
        return left
",n^2 * logr
"
import collections
import itertools

class Solution(object):
    def findAllRecipes(self, recipes, ingredients, supplies):
        indegree = collections.defaultdict(int)
        adj = collections.defaultdict(list)
        for r, ingredient in zip(recipes, ingredients): 
            indegree[r] = len(ingredient)
            for ing in ingredient:
                adj[ing].append(r)
        result = []
        recipes = set(recipes)
        q = supplies
        while q: 
            new_q = []
            for u in q:
                if u in recipes:
                    result.append(u)
                for v in adj[u]:
                    indegree[v] -= 1
                    if not indegree[v]:
                        new_q.append(v)
            q = new_q
        return result 
",|E|
"

class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []


class Solution(object):
    def diameter(self, root):
        def iter_dfs(root):
            result = [0]*2
            stk = [(1, (root, result))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    for child in reversed(node.children):
                        ret2 = [0]*2
                        stk.append((2, (ret2, ret)))
                        stk.append((1, (child, ret2)))
                else:
                    ret2, ret = params
                    ret[0] = max(ret[0], ret2[0], ret[1]+ret2[1]+1)
                    ret[1] = max(ret[1], ret2[1]+1)
            return result
        
        return iter_dfs(root)[0]


",n
"class Solution2(object):
    def diameter(self, root):
        def dfs(node):
            max_dia, max_depth = 0, 0
            for child in node.children:
                child_max_dia, child_max_depth = dfs(child)
                max_dia = max(max_dia, child_max_dia, max_depth+child_max_depth+1)
                max_depth = max(max_depth, child_max_depth+1)
            return max_dia, max_depth
        
        return dfs(root)[0]
",n
"

class Solution(object):
    def maximumEvenSplit(self, finalSum):
        if finalSum%2:
            return []
        result = []
        i = 2
        while i <= finalSum:
            result.append(i)
            finalSum -= i
            i += 2
        result[-1] += finalSum
        return result
",sqrt(n)
"

class Solution(object):
    def valueAfterKSeconds(self, n, k):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            if not (0 <= k <= n):
                return 0
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        return nCr(n+k-1, k)


",n + k
"
class Solution2(object):
    def valueAfterKSeconds(self, n, k):
        MOD = 10**9+7
        prefix = [1]*n
        for _ in range(k):
            for i in range(1, n):
                prefix[i] = (prefix[i]+prefix[i-1])%MOD
        return prefix[-1]

",n * k
"
class Solution(object):
    def maximumTime(self, time):
        result = list(time)
        for i, c in enumerate(time): 
            if c != ""?"":
                continue
            if i == 0:
                result[i] = '2' if result[i+1] in ""?0123"" else '1'
            elif i == 1:
                result[i] = '3' if result[0] == '2' else '9'
            elif i == 3:
                result[i] = '5'
            elif i == 4:
                result[i] = '9'
        return """".join(result)
",1
"
import pandas as pd



def Solution(animals: pd.DataFrame) -> pd.DataFrame:
     return animals[animals['weight'] > 100].sort_values(by=""weight"", ascending=False)[['name']]
",nlogn
"

class Solution(object):
    def maxNonDecreasingLength(self, nums1, nums2):
        result = 1
        dp = [1]*2
        for i in range(len(nums1)-1):
            dp = [max((dp[0]+1 if nums1[i] <= nums1[i+1] else 1), (dp[1]+1 if nums2[i] <= nums1[i+1] else 1)),
                  max((dp[0]+1 if nums1[i] <= nums2[i+1] else 1), (dp[1]+1 if nums2[i] <= nums2[i+1] else 1))]
            result = max(result, max(dp))
        return result
",n
"

class Solution(object):
    def mergeSimilarItems(self, items1, items2):
        return sorted((Counter(dict(items1))+Counter(dict(items2))).items())
",(m + n) * log(m + n)
"

class Solution(object):
    def maxContainers(self, n, w, maxWeight):
        return min(maxWeight//w, n*n)
",1
"
class Solution(object):
    def minDays(self, bloomDay, m, k):
        def check(bloomDay, m, k, x):
            result = count = 0
            for d in bloomDay:
                count = count+1 if d <= x else 0
                if count == k:
                    count = 0
                    result += 1
                    if result == m:
                        break
            return result >= m

        if m*k > len(bloomDay):
            return -1
        left, right = 1, max(bloomDay)
        while left <= right:
            mid = left + (right-left)//2
            if check(bloomDay, m, k, mid):
                right = mid-1
            else:
                left = mid+1
        return left
",nlogd
"

class Solution(object):
    def maxNiceDivisors(self, primeFactors):
        MOD = 10**9 + 7
        if primeFactors <= 3:
            return primeFactors
        if primeFactors % 3 == 0: 
            return pow(3, primeFactors//3, MOD)
        if primeFactors % 3 == 1: 
            return (2*2*pow(3, (primeFactors-4)//3, MOD)) % MOD
        return (2*pow(3, (primeFactors-2)//3, MOD)) % MOD 
",logn
"
class Solution(object):
    def superpalindromesInRange(self, L, R):
        def is_palindrome(k):
            return str(k) == str(k)[::-1]

        K = int((10**((len(R)+1)*0.25)))
        l, r = int(L), int(R)

        result = 0

        for k in range(K):
            s = str(k)
            t = s + s[-2::-1]
            v = int(t)**2
            if v > r:
                break
            if v >= l and is_palindrome(v):
                result += 1

        for k in range(K):
            s = str(k)
            t = s + s[::-1]
            v = int(t)**2
            if v > r:
                break
            if v >= l and is_palindrome(v):
                result += 1

        return result

",n^0.25 * logn
"

class Solution(object):
    def countSubmatrices(self, grid, k):
        result = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i-1 >= 0:
                    grid[i][j] += grid[i-1][j]
                if j-1 >= 0:
                    grid[i][j] += grid[i][j-1]
                if i-1 >= 0 and j-1 >= 0:
                    grid[i][j] -= grid[i-1][j-1]
                if grid[i][j] <= k:
                    result += 1
        return result
",n * m
"
import collections



class Solution(object):
    def canBeEqual(self, s1, s2):
        return all(collections.Counter(s1[j] for j in range(i, len(s1), 2)) == collections.Counter(s2[j] for j in range(i, len(s2), 2)) for i in range(2))


",1
"
class Solution2(object):
    def canBeEqual(self, s1, s2):
        return (((s1[0] == s2[0] and s1[2] == s2[2]) or (s1[0] == s2[2] and s1[2] == s2[0])) and
                ((s1[1] == s2[1] and s1[3] == s2[3]) or (s1[1] == s2[3] and s1[3] == s2[1])))
",1
"
import sortedcontainers


class Solution(object):
    def maxDepthBST(self, order):
        depths = sortedcontainers.SortedDict({float(""-inf""):0, float(""inf""):0})
        values_view = list(depths.values())
        result = 0
        for x in order:
            i = depths.bisect_right(x)
            depths[x] = max(values_view[i-1:i+1])+1
            result = max(result, depths[x])
        return result
",nlogn
"
class Solution(object):
    def findRLEArray(self, encoded1, encoded2):
        result = []
        i = j = remain1 = remain2 = 0
        while (remain1 or i < len(encoded1)) and (remain2 or j < len(encoded2)):
            if not remain1:
                remain1 = encoded1[i][1]
                i += 1
            if not remain2:
                remain2 = encoded2[j][1]
                j += 1
            cnt = min(remain1, remain2)
            remain1 -= cnt
            remain2 -= cnt
            if result and result[-1][0] == encoded1[i-1][0]*encoded2[j-1][0]:
                result[-1][1] += cnt
            else:
                result.append([encoded1[i-1][0]*encoded2[j-1][0], cnt])
        return result
",m + n
"

class Solution(object):
    def minimumArrayLength(self, nums):
        mn = min(nums)
        return (nums.count(mn)+1)//2 if all(x%mn == 0 for x in nums) else 1
",n
"
import collections



class Solution(object):
    def countCompleteSubarrays(self, nums):
        nums_set = set(nums)
        result = left = 0
        cnt = collections.Counter()
        for right in range(len(nums)):
            cnt[nums[right]] += 1
            while len(cnt) == len(nums_set):
                cnt[nums[left]] -= 1
                if cnt[nums[left]] == 0:
                    del cnt[nums[left]]
                left += 1
            result += left
        return result
",n
"
class Solution(object):
    def minOperations(self, boxes):
        result = [0]*len(boxes)
        for direction in (lambda x:x, reversed):
            cnt = accu = 0
            for i in direction(range(len(boxes))):
                result[i] += accu
                if boxes[i] == '1':
                    cnt += 1
                accu += cnt
        return result
",n
"

class Solution(object):
    def secondsToRemoveOccurrences(self, s):
        result = cnt = 0
        for c in s: 
            if c == '0':
                cnt += 1
                continue
            if cnt:
                result = max(result+1, cnt)
        return result 
",n
"
import itertools


class Solution(object):
    def printVertically(self, s):
        return ["""".join(c).rstrip() for c in itertools.zip_longest(*s.split(), fillvalue=' ')]
",n
"
import random


class Solution(object):
    def minDifference(self, nums):
        def nth_element(nums, left, n, right, compare=lambda a, b: a < b):
            def partition_around_pivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == n:
                    return
                elif new_pivot_idx > n:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1

        k = 4
        if len(nums) <= k:
            return 0
        nth_element(nums, 0, k, len(nums)-1)
        nums[:k] = sorted(nums[:k])
        nth_element(nums, k, max(k, len(nums)-k), len(nums)-1)
        nums[-k:] = sorted(nums[-k:])
        return min(nums[-k+i]-nums[i] for i in range(k))
",n + klogk
"

class Solution(object):
    def sumDigitDifferences(self, nums):
        base, l = 1, 0
        while base <= nums[0]:
            base *= 10
            l += 1
        cnts = [[0]*10 for _ in range(l)]
        for x in nums:
            for i in range(l):
                cnts[i][x%10] += 1
                x //= 10
        return sum(c*(len(nums)-c) for cnt in cnts for c in cnt)//2
",nlogr
"

class Solution(object):
    def numberOfStableArrays(self, zero, one, limit):
        MOD = 10**9+7
        dp = [[[0]*2 for _ in range(one+1)] for _ in range(zero+1)]
        for i in range(zero+1):
            dp[i][0][0] = 1 if i <= limit else 0
        for j in range(one+1):
            dp[0][j][1] = 1 if j <= limit else 0
        for i in range(1, zero+1):
            for j in range(1, one+1):
                dp[i][j][0] = (dp[i-1][j][0]+dp[i-1][j][1])%MOD
                dp[i][j][1] = (dp[i][j-1][0]+dp[i][j-1][1])%MOD
                if i-limit-1 >= 0:
                    dp[i][j][0] = (dp[i][j][0]-dp[i-limit-1][j][1])%MOD
                if j-limit-1 >= 0:
                    dp[i][j][1] = (dp[i][j][1]-dp[i][j-limit-1][0])%MOD
        return (dp[-1][-1][0]+dp[-1][-1][1])%MOD


",n * m
"
class Solution2(object):
    def numberOfStableArrays(self, zero, one, limit):
        MOD = 10**9+7
        dp = [[[0]*2 for _ in range(one+1)] for _ in range(zero+1)]
        dp[0][0][0] = dp[0][0][1] = 1
        for i in range(zero+1):
            for j in range(one+1):
                for k in range(1, limit+1):
                    if i-k >= 0:
                        dp[i][j][0] = (dp[i][j][0]+dp[i-k][j][1])%MOD
                    if j-k >= 0:
                        dp[i][j][1] = (dp[i][j][1]+dp[i][j-k][0])%MOD
        return (dp[-1][-1][0]+dp[-1][-1][1])%MOD
",n * m * l
"
class Solution(object):
    def maxSumTwoNoOverlap(self, A, L, M):
        for i in range(1, len(A)):
            A[i] += A[i-1]
        result, L_max, M_max = A[L+M-1], A[L-1], A[M-1]
        for i in range(L+M, len(A)):
            L_max = max(L_max, A[i-M] - A[i-L-M])
            M_max = max(M_max, A[i-L] - A[i-L-M])
            result = max(result,
                         L_max + A[i] - A[i-M],
                         M_max + A[i] - A[i-L])
        return result
",n
"
import random
import itertools



class Solution(object):
    def topStudents(self, positive_feedback, negative_feedback, report, student_id, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        pos, neg = set(positive_feedback), set(negative_feedback)
        arr = []
        for i, r in zip(student_id, report):
            score = sum(3 if w in pos else -1 if w in neg else 0 for w in r.split())
            arr.append((-score, i))
        nth_element(arr, k-1)
        return [i for _, i in sorted(arr[:k])]
",pf * l + nf * l + n * l + klogk
"
import heapq



class Solution(object):
    def minimumDifference(self, nums):
        max_heap = []
        for i in range(len(nums)//3):
            heapq.heappush(max_heap, -nums[i])
        prefix = [0]*(len(nums)//3+1)
        prefix[0] = -sum(max_heap)
        for i in range(len(nums)//3):
            x = -heapq.heappushpop(max_heap, -nums[i+len(nums)//3])
            prefix[i+1] = prefix[i]-x+nums[i+len(nums)//3]

        min_heap = []
        for i in reversed(range(len(nums)//3*2, len(nums))):
            heapq.heappush(min_heap, nums[i])
        suffix = sum(min_heap)
        result = prefix[len(nums)//3]-suffix
        for i in reversed(range(len(nums)//3)):
            x = heapq.heappushpop(min_heap, nums[i+len(nums)//3])
            suffix += -x+nums[i+len(nums)//3]
            result = min(result, prefix[i]-suffix)
        return result
",nlogn
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def levelOrder(self, root):
        if root is None:
            return []
        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            current = next_level
            result.append(vals)
        return result

",n
"

class Solution(object):
    def alternateDigitSum(self, n):
        result = 0
        sign = 1
        while n:
            sign *= -1
            result += sign*(n%10)
            n //= 10
        return sign*result
",logn
"
import heapq



class Solution(object):
    def minEliminationTime(self, timeReq, splitTime):
        heapq.heapify(timeReq)
        for _ in range(len(timeReq)-1):
            heapq.heappush(timeReq, max(heapq.heappop(timeReq), heapq.heappop(timeReq))+splitTime)
        return timeReq[0]
",nlogn
"
import collections



class Solution(object):
    def generateString(self, str1, str2):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        n, m = len(str1), len(str2)
        candidate = ['*']*(n+m-1)
        prefix = getPrefix(str2)
        prev = -m
        for i, x in enumerate(str1):
            if x != 'T':
                continue
            diff = i-prev
            if diff < m:
                if prefix[m-1]+1 == m-diff:
                    candidate[prev+m:i+m] = str2[m-diff:]
                else:
                    return """"
            else:
                candidate[i:i+m] = str2
            prev = i
        result = list(str2)+[
        idxs = []
        for i in range(m+1, len(result)):
            if result[i] == '*':
                result[i] = 'a'
                idxs.append(i)
        prefix = getPrefix(result)
        dq = collections.deque()
        i, j = m+1, 0
        while i-(m+1) < n:
            while dq and dq[0] < i:
                dq.popleft()
            while j < len(idxs) and idxs[j] <= i+(m-1):
                dq.append(idxs[j])
                j += 1
            if str1[i-(m+1)] == 'F' and prefix[i+(m-1)]+1 == m:
                if not dq:
                    return """"
                result[dq[-1]] = 'b'
                i += m
            else:
                i += 1
        return """".join(result[m+1:])


",n + m
"import collections



class Solution2(object):
    def generateString(self, str1, str2):
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        n, m = len(str1), len(str2)
        candidate = ['*']*(n+m-1)
        z = z_function(str2)
        prev = -m
        for i, x in enumerate(str1):
            if x != 'T':
                continue
            diff = i-prev
            if diff < m:
                if z[diff] == m-diff:
                    candidate[prev+m:i+m] = str2[m-diff:]
                else:
                    return """"
            else:
                candidate[i:i+m] = str2
            prev = i
        result = list(str2)+[
        idxs = []
        for i in range(m+1, len(result)):
            if result[i] == '*':
                result[i] = 'a'
                idxs.append(i)
        z = z_function(result)
        dq = collections.deque()
        i, j = m+1, 0
        while i-(m+1) < n:
            while dq and dq[0] < i:
                dq.popleft()
            while j < len(idxs) and idxs[j] <= i+(m-1):
                dq.append(idxs[j])
                j += 1
            if str1[i-(m+1)] == 'F' and z[i] == m:
                if not dq:
                    return """"
                result[dq[-1]] = 'b'
                i += m
            else:
                i += 1
        return """".join(result[m+1:])
",n + m
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def bstFromPreorder(self, preorder):
        def bstFromPreorderHelper(preorder, left, right, index):
            if index[0] == len(preorder) or \
               preorder[index[0]] < left or \
               preorder[index[0]] > right:
                return None

            root = TreeNode(preorder[index[0]])
            index[0] += 1
            root.left = bstFromPreorderHelper(preorder, left, root.val, index)
            root.right = bstFromPreorderHelper(preorder, root.val, right, index)
            return root
        
        return bstFromPreorderHelper(preorder, float(""-inf""), float(""inf""), [0])
",n
"
class Solution(object):
    def countVowelStrings(self, n):
        def nCr(n, r): 
            if n-r < r:
                return nCr(n, n-r)
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
    
        return nCr(n+4, 4) 
",1
"
import collections


class Solution(object):
    def maxResult(self, nums, k):
        score = 0
        dq = collections.deque()
        for i, num in enumerate(nums):
            if dq and dq[0][0] == i-k-1:
                dq.popleft()
            score = num if not dq else dq[0][1]+num
            while dq and dq[-1][1] <= score:
                dq.pop()
            dq.append((i, score))
        return score
",n
"

class Solution2(object):
    def findChampion(self, n, edges):
        lookup = [False]*n
        for u, v in edges:
            lookup[v] = True
        result = -1
        for u in range(n):
            if lookup[u]:
                continue
            if result != -1:
                return -1
            result = u
        return result


",n
"
class Solution2(object):
    def findChampion(self, n, edges):
        lookup = {v for _, v in edges}
        return next(u for u in range(n) if u not in lookup) if len(lookup) == n-1 else -1
",n
"
import collections


class Solution(object):
    def groupThePeople(self, groupSizes):
        groups, result = collections.defaultdict(list), []
        for i, size in enumerate(groupSizes):
            groups[size].append(i)
            if len(groups[size]) == size:
                result.append(groups.pop(size))
        return result
",n
"
class Solution(object):
    def maxDepth(self, s):
        result = curr = 0
        for c in s:
            if c == '(':
                curr += 1
                result = max(result, curr)
            elif c == ')':
                curr -= 1
        return result
",n
"
class Solution(object):
    def sumOfLeftLeaves(self, root):
        def sumOfLeftLeavesHelper(root, is_left):
            if not root:
                return 0
            if not root.left and not root.right:
                return root.val if is_left else 0
            return sumOfLeftLeavesHelper(root.left, True) + \
                   sumOfLeftLeavesHelper(root.right, False)

        return sumOfLeftLeavesHelper(root, False)

",n
"

class Solution(object):
    def maxTotalReward(self, rewardValues):
        mx = max(rewardValues)
        dp = 1
        mask = (1<<mx)-1
        for v in sorted(set(rewardValues)):
            x = dp&((1<<v)-1)
            dp |= (x<<v)&mask
        return mx+(dp.bit_length()-1)


",nlogn + r^2
"
class Solution2(object):
    def maxTotalReward(self, rewardValues):
        dp = 1
        for v in sorted(set(rewardValues)):
            x = dp&((1<<v)-1)
            dp |= x<<v
        return dp.bit_length()-1


",nlogn + r^2
"
class Solution3(object):
    def maxTotalReward(self, rewardValues):
        mx = max(rewardValues)
        dp = [False]*((mx-1)+1)
        dp[0] = True
        for v in sorted(set(rewardValues)):
            for x in range(min(v, mx-v)):
                dp[x+v] |= dp[x]
        return mx+next(x for x in reversed(range(len(dp))) if dp[x])


",nlogn + r^2
"
class Solution4(object):
    def maxTotalReward(self, rewardValues):
        dp = [False]*((max(rewardValues)*2-1)+1)
        dp[0] = True
        for v in sorted(set(rewardValues)):
            for x in range(v):
                dp[x+v] |= dp[x]
        return next(x for x in reversed(range(len(dp))) if dp[x])
",nlogn + r^2
"
import collections



class Solution(object):
    def largestPalindromic(self, num):
        cnt = collections.Counter(num)
        result = []
        for i in reversed(range(10)):
            if not cnt[str(i)]//2 or (i == 0 and not result):
                continue
            for _ in range(cnt[str(i)]//2):
                result.append(str(i))
        result.append(max([k for k, v in cnt.items() if v%2] or [""""]))
        for i in reversed(range(len(result)-1)):
            result.append(result[i])
        return """".join(result) or ""0""
",n
"
import collections
import operator
from functools import reduce



class Solution(object):
    def beautifulSubsets(self, nums, k):
        def count(x):
            y = x
            while y-k in cnt:
                y -= k
            dp = [1, 0] 
            for i in range(y, x+1, k):
                dp = [dp[0]+dp[1], dp[0]*((1<<cnt[i])-1)]
            return sum(dp)

        cnt = collections.Counter(nums)
        return reduce(operator.mul, (count(i) for i in cnt.keys() if i+k not in cnt))-1
",n
"
class Solution(object):
    def diagonalSum(self, mat):
        return sum(mat[i][i]+mat[~i][i] for i in range(len(mat))) - (mat[len(mat)//2][len(mat)//2] if len(mat)%2 == 1 else 0)
",n
"
import collections



class Solution(object):
    def minCost(self, nums, k):
        dp = [float(""inf"")]*(len(nums)+1)
        dp[0] = 0
        for i in range(len(dp)-1):
            cnt = [0]*len(nums)
            d = 0
            for j in range(i+1, len(dp)):
                cnt[nums[j-1]] += 1
                if cnt[nums[j-1]] == 1:
                    d += 1
                elif cnt[nums[j-1]] == 2:
                    d -= 1
                dp[j] = min(dp[j], dp[i]+k+((j-i)-d))
        return dp[-1]
",n^2
"
class Solution(object):
    def addStrings(self, num1, num2):
        result = []
        i, j, carry = len(num1) - 1, len(num2) - 1, 0

        while i >= 0 or j >= 0 or carry:
            if i >= 0:
                carry += ord(num1[i]) - ord('0')
                i -= 1
            if j >= 0:
                carry += ord(num2[j]) - ord('0')
                j -= 1
            result.append(str(carry % 10))
            carry /= 10
        result.reverse()

        return """".join(result)

    def addStrings2(self, num1, num2):
        length = max(len(num1), len(num2))
        num1 = num1.zfill(length)[::-1]
        num2 = num2.zfill(length)[::-1]
        res, plus = '', 0
        for index, num in enumerate(num1):
            tmp = str(int(num) + int(num2[index]) + plus)
            res += tmp[-1]
            if int(tmp) > 9:
                plus = 1
            else:
                plus = 0
        if plus:
            res += '1'
        return res[::-1]

",n
"
import random



class Solution(object):
    def minimumCost(self, nums):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        nth_element(nums, 1+(2-1), 1)
        return nums[0]+nums[1]+nums[2]


",n
"
class Solution2(object):
    def minimumCost(self, nums):
        def topk(a, k):
            result = [float(""inf"")]*k
            for x in a:
                for i in range(len(result)):
                    if x < result[i]:
                        result[i], x = x, result[i]
            return result

        return nums[0]+sum(topk((nums[i] for i in range(1, len(nums))), 2))
",n
"

class Solution(object):
    def constructProductMatrix(self, grid):
        MOD = 12345
        right = [1]*(len(grid)*len(grid[0])+1)
        for i in reversed(range(len(grid))):
            for j in reversed(range(len(grid[0]))):
                right[i*len(grid[0])+j] = (right[(i*len(grid[0])+j)+1]*grid[i][j])%MOD
        left = 1
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                grid[i][j], left = (left*right[(i*len(grid[0])+j)+1])%MOD, (left*grid[i][j])%MOD
        return grid


",m * n
"
class Solution2(object):
    def constructProductMatrix(self, grid):
        MOD = 12345
        left = [1]*(len(grid)*len(grid[0])+1)
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                left[(i*len(grid[0])+j)+1] = (left[i*len(grid[0])+j]*grid[i][j])%MOD
        right = [1]*(len(grid)*len(grid[0])+1)
        for i in reversed(range(len(grid))):
            for j in reversed(range(len(grid[0]))):
                right[i*len(grid[0])+j] = (right[(i*len(grid[0])+j)+1]*grid[i][j])%MOD
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                grid[i][j] = (left[i*len(grid[0])+j]*right[(i*len(grid[0])+j)+1])%MOD
        return grid
",m * n
"
class Solution(object):
    def minOperations(self, nums):
        def popcount(n):
            result = 0
            while n:
                n &= n-1
                result += 1
            return result

        result, max_len = 0, 1
        for num in nums:
            result += popcount(num)
            max_len = max(max_len, num.bit_length())
        return result + (max_len-1)
",nlogn
"
class Solution(object):
    def removeDuplicates(self, A):
        if not A:
            return 0

        last, i, same = 0, 1, False
        while i < len(A):
            if A[last] != A[i] or not same:
                same = A[last] == A[i]
                last += 1
                A[last] = A[i]
            i += 1

        return last + 1

",n
"
from sortedcontainers import SortedList



class Solution(object):
    def minThreshold(self, nums, k):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(x):
            sl = SortedList()
            cnt = 0
            for i in reversed(nums):
                cnt += sl.bisect_left(i)-sl.bisect_left(i-x)
                sl.add(i)
            return cnt >= k

        mx, right = nums[0], 0
        for i in range(1, len(nums)):
            right = max(right, mx-nums[i])
            mx = max(mx, nums[i])
        result = binary_search(0, right, check)
        return result if result <= right else -1
",nlogn * logr
"
import bisect


class Solution(object):
    def minAbsoluteSumDiff(self, nums1, nums2):
        MOD = 10**9+7

        sorted_nums1 = sorted(nums1)
        result = max_change = 0
        for i in range(len(nums2)):
            diff = abs(nums1[i]-nums2[i])
            result = (result+diff)%MOD
            if diff < max_change:
                continue
            j = bisect.bisect_left(sorted_nums1, nums2[i])
            if j != len(sorted_nums1):
                max_change = max(max_change, diff-abs(sorted_nums1[j]-nums2[i]))
            if j != 0:
                max_change = max(max_change, diff-abs(sorted_nums1[j-1]-nums2[i]))
        return (result-max_change)%MOD
",nlogn
"
import collections



class Solution(object):
    def longestSpecialPath(self, edges, nums):
        def iter_dfs():
            result = [float(""inf"")]*2
            lookup = collections.defaultdict(lambda: -1)
            prefix = [0]
            stk = [(1, (0, -1, 0, -1))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, d, left = args
                    prev_d, lookup[nums[u]-1] = lookup[nums[u]-1], d
                    left = max(left, prev_d)
                    result = min(result, [-(prefix[(d-1)+1]-prefix[left+1]), d-left])
                    stk.append((4, (u, prev_d)))
                    stk.append((2, (u, p, d, left, 0)))
                elif step == 2:
                    u, p, d, left, i = args
                    if i == len(adj[u]):
                        continue
                    stk.append((2, (u, p, d, left, i+1)))
                    v, l = adj[u][i]
                    if v == p:
                        continue
                    prefix.append(prefix[-1]+l)
                    stk.append((3, None))
                    stk.append((1, (v, u, d+1, left)))
                elif step == 3:
                    prefix.pop()
                elif step == 4:
                    u, prev_d = args
                    lookup[nums[u]-1] = prev_d
            return [-result[0], result[1]]
    
        adj = [[] for _ in range(len(nums))]
        for u, v, l in edges:
            adj[u].append((v, l))
            adj[v].append((u, l))        
        return iter_dfs()


",n + e
"import collections



class Solution2(object):
    def longestSpecialPath(self, edges, nums):
        def dfs(u, p, d, left):
            prev_d, lookup[nums[u]-1] = lookup[nums[u]-1], d
            left = max(left, prev_d)
            result[0] = min(result[0], [-(prefix[(d-1)+1]-prefix[left+1]), d-left])
            for v, l in adj[u]:
                if v == p:
                    continue
                prefix.append(prefix[-1]+l)
                dfs(v, u, d+1, left)
                prefix.pop()
            lookup[nums[u]-1] = prev_d
    
        adj = [[] for _ in range(len(nums))]
        for u, v, l in edges:
            adj[u].append((v, l))
            adj[v].append((u, l))
        lookup = collections.defaultdict(lambda: -1)
        prefix = [0]
        result = [[float(""inf""), float(""inf"")]]
        dfs(0, -1, 0, -1)
        return [-result[0][0], result[0][1]]
",n + e
"

class Solution(object):
    def kthPalindrome(self, queries, intLength):
        def reverse(x):
            result = 0
            while x:
                result = result*10+x%10
                x //= 10
            return result

        def f(l, x):
            x = 10**((l-1)//2)+(x-1)
            if x > 10**((l+1)//2)-1:
                return -1
            return x*10**(l//2)+reverse(x//10 if l%2 else x)

        return [f(intLength, x) for x in queries]


",n * l
"
class Solution2(object):
    def kthPalindrome(self, queries, intLength):
        def f(l, x):
            if 10**((l-1)//2)+(x-1) > 10**((l+1)//2)-1:
                return -1
            s = str(10**((l-1)//2)+(x-1))
            return int(s+s[::-1][l%2:])

        return [f(intLength, x) for x in queries]
",n * l
"
class Solution(object):
    def maximumNumberOfOnes(self, width, height, sideLength, maxOnes):
        if width < height:
            width, height = height, width


        R, r = divmod(height, sideLength)
        C, c = divmod(width, sideLength)
        assert(R <= C)
        area_counts = [(r*c, (R+1)*(C+1)), \
                       (r*(sideLength-c), (R+1)*C), \
                       ((sideLength-r)*c, R*(C+1)), \
                       ((sideLength-r)*(sideLength-c), R*C)]
        result = 0
        for area, count in area_counts:
            area = min(maxOnes, area)
            result += count*area
            maxOnes -= area
            if not maxOnes:
                break
        return result
",1
"
class Solution(object):
    def splitLoopedString(self, strs):
        tmp = []
        for s in strs:
            tmp += max(s, s[::-1])
        s = """".join(tmp)

        result, st = ""a"", 0
        for i in range(len(strs)):
            body = """".join([s[st + len(strs[i]):], s[0:st]])
            for p in strs[i], strs[i][::-1]:
                for j in range(len(strs[i])):
                    if p[j] >= result[0]:
                        result = max(result, """".join([p[j:], body, p[:j]]))
            st += len(strs[i])
        return result

",n^2
"

class Solution(object):
    def averageOfLevels(self, root):
        result = []
        q = [root]
        while q:
            total, count = 0, 0
            next_q = []
            for n in q:
                total += n.val
                count += 1
                if n.left:
                    next_q.append(n.left)
                if n.right:
                    next_q.append(n.right)
            q = next_q
            result.append(float(total) / count)
        return result

",n
"
class Solution(object):
    def generateAbbreviations(self, word):
        def generateAbbreviationsHelper(word, i, cur, res):
            if i == len(word):
                res.append("""".join(cur))
                return
            cur.append(word[i])
            generateAbbreviationsHelper(word, i + 1, cur, res)
            cur.pop()
            if not cur or not cur[-1][-1].isdigit():
                for l in range(1, len(word) - i + 1):
                    cur.append(str(l))
                    generateAbbreviationsHelper(word, i + l, cur, res)
                    cur.pop()

        res, cur = [], []
        generateAbbreviationsHelper(word, 0, cur, res)
        return res


",n * 2^n
"

class Solution(object):
    def haveConflict(self, event1, event2):
        return max(event1[0], event2[0]) <= min(event1[1], event2[1])
",1
"
import itertools


class Solution(object):
    def maxCoins(self, piles):
        piles.sort()
        return sum(itertools.islice(piles, len(piles)//3, len(piles), 2))
",nlogn
"

class Solution(object):
    def maxScoreIndices(self, nums):
        result = []
        mx = zeros = 0
        total = sum(nums)
        for i in range(len(nums)+1):
            zeros += ((nums[i-1] if i else 0) == 0)
            if zeros+(total-(i-zeros)) > mx:
                mx = zeros+(total-(i-zeros))
                result = []
            if zeros+(total-(i-zeros)) == mx:
                result.append(i)
        return result
",n
"
import operator
from functools import reduce



class Solution(object):
    def xorBeauty(self, nums):
        return reduce(operator.xor, nums)
",n
"

class Solution(object):
    def earliestSecondToMarkIndices(self, nums, changeIndices):
        def check(t):
            lookup = [-1]*len(nums)
            for i in range(t):
                lookup[changeIndices[i]-1] = i
            if -1 in lookup:
                return False
            cnt = 0
            for i in range(t):
                if i != lookup[changeIndices[i]-1]:
                    cnt += 1
                    continue
                cnt -= nums[changeIndices[i]-1]
                if cnt < 0:
                    return False
            return True

        left, right = sum(nums)+len(nums), len(changeIndices) 
        while left <= right:
            mid = left+(right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return left if left <= len(changeIndices) else -1
",mlogm
"
import math


class Solution(object):
    def poorPigs(self, buckets, minutesToDie, minutesToTest):
        return int(math.ceil(math.log(buckets) / math.log(minutesToTest / minutesToDie + 1)))

",1
"
class Solution(object):
    def checkIfPangram(self, sentence):
        return len(set(sentence)) == 26
",n
"
import collections
from functools import reduce



class Solution(object):
    def minimumValueSum(self, nums, andValues):
        INF = float(""inf"")
        L = max(nums).bit_length()
        def update(cnt, x, d):
            for i in range(L):
                if x&(1<<i):
                    cnt[i] += d
        
        def mask(cnt, l):
            return reduce(lambda accu, i: accu|(1<<i), (i for i  in range(L) if cnt[i] == l), 0)

        dp = [INF]*(len(nums)+1)
        dp[0] = 0
        for j in range(len(andValues)):
            new_dp = [INF]*(len(nums)+1)
            cnt = [0]*L
            l = [0]*len(dp)
            dq = collections.deque()
            left = idx = j
            for right in range(j, len(nums)):
                update(cnt, nums[right], +1)
                if mask(cnt, right-left+1) <= andValues[j]:
                    while left <= right:
                        if mask(cnt, right-left+1) > andValues[j]:
                            break
                        update(cnt, nums[left], -1)
                        left += 1
                    left -= 1
                    update(cnt, nums[left], +1) 
                if (andValues[j]&nums[right]) == andValues[j]:
                    l[right + 1] = l[right]+1
                if mask(cnt, right-left+1) != andValues[j]:
                    continue
                while idx <= left:
                    while dq and dp[dq[-1]] >= dp[idx]:
                        dq.pop()
                    dq.append(idx)
                    idx += 1
                while dq and dq[0] < left-l[left]:
                    dq.popleft()
                if dq:
                    new_dp[right+1] = dp[dq[0]]+nums[right]
            dp = new_dp
        return dp[-1] if dp[-1] != INF else -1


",n * m * logr
"
class Solution2(object):
    def minimumValueSum(self, nums, andValues):
        INF = float(""inf"")
        class SparseTable(object):
            def __init__(self, arr, fn):
                self.fn = fn
                self.bit_length = [0]
                n = len(arr)
                k = n.bit_length()-1 
                for i in range(k+1):
                    self.bit_length.extend(i+1 for _ in range(min(1<<i, (n+1)-len(self.bit_length))))
                self.st = [[0]*n for _ in range(k+1)]
                self.st[0] = arr[:]
                for i in range(1, k+1): 
                    for j in range((n-(1<<i))+1):
                        self.st[i][j] = fn(self.st[i-1][j], self.st[i-1][j+(1<<(i-1))])
        
            def query(self, L, R): 
                i = self.bit_length[R-L+1]-1 
                return self.fn(self.st[i][L], self.st[i][R-(1<<i)+1])
        
        dp = [INF]*(len(nums)+1)
        dp[0] = 0
        for j in range(len(andValues)):
            new_dp = [INF]*(len(nums)+1)
            masks = []
            st = SparseTable(dp, min)
            for i in range(j, len(nums)):
                masks.append([nums[i], i])
                for x in masks:
                    x[0] &= nums[i]
                masks = [x for k, x in enumerate(masks) if k == 0 or masks[k-1][0] != masks[k][0]]
                for k, [mask, left] in enumerate(masks):
                    if mask == andValues[j]:
                        right = masks[k+1][1]-1 if k+1 != len(masks) else i
                        new_dp[i+1] = min(new_dp[i+1], st.query(left, right)+nums[i])
                        break
            dp = new_dp
        return dp[-1] if dp[-1] != INF else -1


",n * m * (logn + logr)
"import collections



class Solution3(object):
    def minimumValueSum(self, nums, andValues):
        INF = float(""inf"")
        FULL_MASK = (1<<max(nums).bit_length())-1
        def memoization(i, j, mask): 
            if i == len(nums) and j == len(andValues):
                return 0
            if i == len(nums) or j == len(andValues) or mask < andValues[j]:
                return INF 
            if  mask not in lookup[i][j]:
                curr = memoization(i+1, j, mask&nums[i])
                if mask&nums[i] == andValues[j]:
                    curr = min(curr, nums[i]+memoization(i+1, j+1, FULL_MASK))
                lookup[i][j][mask] = curr
            return lookup[i][j][mask]
    
        lookup = [[collections.defaultdict(int) for _ in range(len(andValues))] for _ in range(len(nums))]
        result = memoization(0, 0, FULL_MASK)
        return result if result != INF else -1
",n * m * logr
"
import heapq


class Solution(object):
    def smallestChair(self, times, targetFriend):
        events = []
        for i, (s, e) in enumerate(times): 
            events.append((s, True, i))
            events.append((e, False, i))
        events.sort()

        lookup = {}
        min_heap = []
        for _, arrival, i in events: 
            if not arrival: 
                heapq.heappush(min_heap, lookup.pop(i))
                continue
            lookup[i] = heapq.heappop(min_heap) if min_heap else len(lookup)
            if i == targetFriend:
                break
        return lookup[targetFriend]
",nlogn
"
class Solution(object):
    def targetIndices(self, nums, target):
        less = sum(x < target for x in nums)
        return list(range(less, less+sum(x == target for x in nums)))
",n
"
class Solution(object):
    def findMinArrowShots(self, points):
        if not points:
            return 0

        points.sort()

        result = 0
        i = 0
        while i < len(points):
            j = i + 1
            right_bound = points[i][1]
            while j < len(points) and points[j][0] <= right_bound:
                right_bound = min(right_bound, points[j][1])
                j += 1
            result += 1
            i = j
        return result

",nlogn
"
import collections


class Solution(object):
    def palindromePairs(self, words):
        def is_palindrome(s, i, j):
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True
 
        res = []
        lookup = collections.defaultdict(dict)
        for i, word in enumerate(words):
            lookup[len(word)][word] = i

        for i in range(len(words)):
            for j in range(len(words[i]) + 1):
                if j in lookup and is_palindrome(words[i], j, len(words[i])-1):
                    suffix = words[i][:j][::-1]
                    bucket = lookup[len(suffix)]
                    if suffix in bucket and bucket[suffix] != i:
                        res.append([i, bucket[suffix]])
                if j > 0 and len(words[i])-j in lookup and is_palindrome(words[i], 0, j-1):
                    prefix = words[i][j:][::-1]
                    bucket = lookup[len(prefix)]
                    if prefix in bucket and bucket[prefix] != i:
                        res.append([bucket[prefix], i])
        return res


",n * k^2
"
class Solution_TLE(object):
    def palindromePairs(self, words):
        def manacher(s, P):
            def preProcess(s):
                if not s:
                    return ['^', '$']
                T = ['^']
                for c in s:
                    T +=  [
                T += [
                return T

            T = preProcess(s)
            center, right = 0, 0
            for i in range(1, len(T) - 1):
                i_mirror = 2 * center - i
                if right > i:
                    P[i] = min(right - i, P[i_mirror])
                else:
                    P[i] = 0
                while T[i + 1 + P[i]] == T[i - 1 - P[i]]:
                    P[i] += 1
                if i + P[i] > right:
                    center, right = i, i + P[i]

        prefix, suffix = collections.defaultdict(list), collections.defaultdict(list)
        for i, word in enumerate(words):
            P = [0] * (2 * len(word) + 3)
            manacher(word, P)
            for j in range(len(P)):
                if j - P[j] == 1:
                    prefix[word[(j + P[j]) // 2:]].append(i)
                if j + P[j] == len(P) - 2:
                    suffix[word[:(j - P[j]) // 2]].append(i)
        res = []
        for i, word in enumerate(words):
            for j in prefix[word[::-1]]:
                if j != i:
                    res.append([i, j])
            for j in suffix[word[::-1]]:
                if len(word) != len(words[j]):
                    res.append([j, i])
        return res


",n * k^2
"
class TrieNode(object):
    def __init__(self):
        self.word_idx = -1
        self.leaves = {}

    def insert(self, word, i):
        cur = self
        for c in word:
            if not c in cur.leaves:
                cur.leaves[c] = TrieNode()
            cur = cur.leaves[c]
        cur.word_idx = i

    def find(self, s, idx, res):
        cur = self
        for i in reversed(range(len(s))):
            if s[i] in cur.leaves:
                cur = cur.leaves[s[i]]
                if cur.word_idx not in (-1, idx) and \
                   self.is_palindrome(s, i - 1):
                    res.append([cur.word_idx, idx])
            else:
                break

    def is_palindrome(self, s, j):
        i = 0
        while i <= j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True

class Solution_MLE(object):
    def palindromePairs(self, words):
        res = []
        trie = TrieNode()
        for i in range(len(words)):
            trie.insert(words[i], i)

        for i in range(len(words)):
            trie.find(words[i], i, res)

        return res

",n * k^2
"
import heapq


class Solution(object):
    def connectSticks(self, sticks):
        heapq.heapify(sticks)
        result = 0
        while len(sticks) > 1:
            x, y = heapq.heappop(sticks), heapq.heappop(sticks)
            result += x+y
            heapq.heappush(sticks, x+y)
        return result
",nlogn
"
class Solution(object):
    def searchMatrix(self, matrix, target):
        m = len(matrix)
        if m == 0:
            return False

        n = len(matrix[0])
        if n == 0:
            return False

        i, j = 0, n - 1
        while i < m and j >= 0:
            if matrix[i][j] == target:
                return True
            elif matrix[i][j] > target:
                j -= 1
            else:
                i += 1

        return False

",m + n
"

class Solution(object):
    def distributeCookies(self, cookies, k):
        total = [0]*(1<<len(cookies))
        for mask in range(1<<len(cookies)):
            total[mask] = sum(cookies[i] for i in range(len(cookies)) if mask&(1<<i))
        dp = [[float(""inf"")]*(1<<len(cookies)) for _ in range(2)]
        dp[0][0] = 0
        for i in range(k):
            for mask in range(1<<len(cookies)):
                submask = mask
                while submask:
                    dp[(i+1)%2][mask] = min(dp[(i+1)%2][mask], max(total[submask], dp[i%2][mask^submask]))
                    submask = (submask-1)&mask
        return dp[k%2][-1]
",k * 3^n
"

class Solution(object):
    def minimizeStringValue(self, s):
        def counting_sort(cnt):
            for i in range(len(cnt)):
                for _ in range(cnt[i]):
                    yield i
        
        def fill(cnt):
            result = [0]*26
            a = [(x, i) for i, x in enumerate(cnt)]
            a.sort()
            total = s.count('?')
            curr = 0
            for i in range(len(a)-1):
                if curr+(a[i+1][0]-a[i][0])*(i+1) > total:
                    break
                curr += (a[i+1][0]-a[i][0])*(i+1)
            else:
                i = len(a)-1
            q, r = divmod(total-curr, i+1)
            for j in range(i+1):
                result[a[j][1]] = (a[i][0]-a[j][0])+q
            cnt2 = [0]*26
            for j in range(i+1):
                cnt2[a[j][1]] += 1
            it = counting_sort(cnt2)
            for _ in range(r):
                result[next(it)] += 1
            return result
    
        cnt = [0]*26
        for x in s:
            if x == '?':
                continue
            cnt[ord(x)-ord('a')] += 1
        it = counting_sort(fill(cnt))
        result = list(s)
        for i in range(len(result)):
            if result[i] != '?':
                continue
            result[i] = chr(ord('a')+next(it))
        return """".join(result)


",n + 26 * log(26)
"import heapq



class Solution2(object):
    def minimizeStringValue(self, s):
        def counting_sort(cnt):
            for i in range(len(cnt)):
                for _ in range(cnt[i]):
                    yield i

        cnt = [0]*26
        for x in s:
            if x == '?':
                continue
            cnt[ord(x)-ord('a')] += 1
        min_heap = [(x, i) for i, x in enumerate(cnt)]
        heapq.heapify(min_heap)
        cnt2 = [0]*26
        for _ in range(s.count('?')):
            c, i = heapq.heappop(min_heap)
            heapq.heappush(min_heap, (c+1, i))
            cnt2[i] += 1
        it = counting_sort(cnt2)
        result = list(s)
        for i in range(len(result)):
            if result[i] != '?':
                continue
            result[i] = chr(ord('a')+next(it))
        return """".join(result)


",n + n * log(26)
"
class Solution3(object):
    def minimizeStringValue(self, s):
        def counting_sort(cnt):
            for i in range(len(cnt)):
                for _ in range(cnt[i]):
                    yield i
    
        cnt = [0]*26
        for x in s:
            if x == '?':
                continue
            cnt[ord(x)-ord('a')] += 1
        cnt2 = [0]*26
        for _ in range(s.count('?')):
            i = min(range(len(cnt)), key=lambda x: cnt[x]+cnt2[x])
            cnt2[i] += 1
        it = counting_sort(cnt2)
        result = list(s)
        for i in range(len(result)):
            if result[i] != '?':
                continue
            result[i] = chr(ord('a')+next(it))
        return """".join(result)
",n + n * 26
"

class Solution(object):
    def addMinimum(self, word):
        return 3*(sum(i-1 < 0 or word[i-1] >= word[i] for i in range(len(word))))-len(word)
 
",n
"
class Solution(object):
    def largestMagicSquare(self, grid):
        def get_sum(prefix, a, b):
            return prefix[b+1]-prefix[a]

        def check(grid, prefix_row, prefix_col, l, i, j):
            diag, anti_diag = 0, 0
            for d in range(l):
                diag += grid[i+d][j+d]
                anti_diag += grid[i+d][j+l-1-d]
            if diag != anti_diag:
                return False
            for ni in range(i, i+l):
                if diag != get_sum(prefix_row[ni], j, j+l-1):
                    return False
            for nj in range(j, j+l):
                if diag != get_sum(prefix_col[nj], i, i+l-1):
                    return False  
            return True

        prefix_row = [[0]*(len(grid[0])+1) for _ in range(len(grid))]
        prefix_col = [[0]*(len(grid)+1) for _ in range(len(grid[0]))]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                prefix_row[i][j+1] = prefix_row[i][j] + grid[i][j]
                prefix_col[j][i+1] = prefix_col[j][i] + grid[i][j]
        for l in reversed(range(1, min(len(grid), len(grid[0]))+1)):
            for i in range(len(grid)-(l-1)):
                for j in range(len(grid[0])-(l-1)):
                    if check(grid, prefix_row, prefix_col, l, i, j):
                        return l
        return 1
","max(m, n) * min(m, n)^3"
"

class Solution(object):
    def catchMaximumAmountofPeople(self, team, dist):
        result = i = j = 0
        while i < len(team) and j < len(team):
            if i+dist < j or team[i] != 1:
                i += 1
            elif j+dist < i or team[j] != 0:
                j += 1
            else:
                result += 1
                i += 1
                j += 1
        return result


",n
"
class Solution2(object):
    def catchMaximumAmountofPeople(self, team, dist):
        result = j = 0
        for i in range(len(team)):
            if not team[i]:
                continue
            while j < i-dist:
                j += 1
            while j <= min(i+dist, len(team)-1):
                if team[j] == 0:
                    break
                j += 1
            if j <= min(i+dist, len(team)-1):
                result += 1
                j += 1
        return result
",n
"
class NestedInteger(object):
   def __init__(self, value=None):
       def isInteger(self):
       def add(self, elem):
       def setInteger(self, value):
       def getInteger(self):
       def getList(self):
       class Solution(object):
    def deserialize(self, s):
        if not s:
            return NestedInteger()

        if s[0] != '[':
            return NestedInteger(int(s))

        stk = []

        i = 0
        for j in range(len(s)):
            if s[j] == '[':
                stk += NestedInteger(),
                i = j+1
            elif s[j] in ',]':
                if s[j-1].isdigit():
                    stk[-1].add(NestedInteger(int(s[i:j])))
                if s[j] == ']' and len(stk) > 1:
                    cur = stk[-1]
                    stk.pop()
                    stk[-1].add(cur)
                i = j+1

        return stk[-1]

",n
"
import collections
import itertools


class Solution(object):
    def rearrangeString(self, s, k):
        if not k:
            return s
        cnts = collections.Counter(s)
        bucket_cnt = max(cnts.values())
        if not ((bucket_cnt-1)*k+sum(x == bucket_cnt for x in cnts.values()) <= len(s)):
            return """"
        result = [0]*len(s)
        i = (len(s)-1)%k
        for c in itertools.chain((c for c, v in cnts.items() if v == bucket_cnt), (c for c, v in cnts.items() if v != bucket_cnt)):
            for _ in range(cnts[c]):
                result[i] = c
                i += k
                if i >= len(result):
                    i = (i-1)%k
        return """".join(result)


",n
"import collections
import itertools



class Solution2(object):
    def rearrangeString(self, s, k):
        if not k:
            return s
        cnts = collections.Counter(s)
        bucket_cnt = (len(s)+k-1)//k
        if not (max(cnts.values()) <= bucket_cnt and list(cnts.values()).count(bucket_cnt) <= (len(s)-1)%k+1):
            return """"
        result = [0]*len(s)
        i = 0
        for c in itertools.chain((c for c, v in cnts.items() if v == bucket_cnt),
                                 (c for c, v in cnts.items() if v <= bucket_cnt-2),
                                 (c for c, v in cnts.items() if v == bucket_cnt-1)):
            for _ in range(cnts[c]):
                result[i] = c
                i += k
                if i >= len(result):
                    i = i%k+1
        return """".join(result)


",n
"import collections
import itertools


class Solution3(object):
    def rearrangeString(self, s, k):
        cnts = collections.Counter(s)
        bucket_cnt = max(cnts.values())
        buckets = [[] for _ in range(bucket_cnt)]
        i = 0
        for c in itertools.chain((c for c, v in cnts.items() if v == bucket_cnt),
                                 (c for c, v in cnts.items() if v == bucket_cnt-1),
                                 (c for c, v in cnts.items() if v <= bucket_cnt-2)):
            for _ in range(cnts[c]):
                buckets[i].append(c)
                i = (i+1) % max(cnts[c], bucket_cnt-1)
        if any(len(buckets[i]) < k for i in range(len(buckets)-1)):
            return """"
        return """".join(["""".join(x) for x in buckets])


",n
"from collections import Counter
from heapq import heappush, heappop
class Solution4(object):
    def rearrangeString(self, s, k):
        if k <= 1:
            return s

        cnts = Counter(s)
        heap = []
        for c, cnt in cnts.items():
            heappush(heap, [-cnt, c])

        result = []
        while heap:
            used_cnt_chars = []
            for _ in range(min(k, len(s) - len(result))):
                if not heap:
                    return """"
                cnt_char = heappop(heap)
                result.append(cnt_char[1])
                cnt_char[0] += 1
                if cnt_char[0] < 0:
                    used_cnt_chars.append(cnt_char)
            for cnt_char in used_cnt_chars:
                heappush(heap, cnt_char)

        return """".join(result)
",nlogc
"
class Solution(object):
    def findOriginalArray(self, changed):
        if len(changed)%2:
            return []
        cnts = collections.Counter(changed)
        for x in sorted(cnts.keys()):
            if cnts[x] > cnts[2*x]:
                return []
            cnts[2*x] -= cnts[x] if x else cnts[x]//2
        return list(cnts.elements())
",n + klogk
"

class Solution(object):
    def resultArray(self, nums):
        a, b = [nums[0]], [nums[1]]
        for i in range(2, len(nums)):
            if a[-1] > b[-1]:
                a.append(nums[i])
            else:
                b.append(nums[i])
        return a+b
",n
"
import pandas as pd



def Solution(report: pd.DataFrame) -> pd.DataFrame:
    return report.melt(
        id_vars=[""product""],
        value_vars=[f""quarter_{i}"" for i in range(1, 4+1)],
        var_name=""quarter"",
        value_name=""sales"",
    )
",n
"
class Solution(object):
    def angleClock(self, hour, minutes):
        angle1 = (hour % 12 * 60.0 + minutes) / 720.0
        angle2 = minutes / 60.0
        diff = abs(angle1-angle2)
        return min(diff, 1.0-diff) * 360.0
",1
"
class Solution(object):
    def shortestDistance(self, words, word1, word2):
        dist = float(""inf"")
        i, index1, index2 = 0, None, None
        while i < len(words):
            if words[i] == word1:
                index1 = i
            elif words[i] == word2:
                index2 = i

            if index1 is not None and index2 is not None:
                dist = min(dist, abs(index1 - index2))
            i += 1

        return dist

",n
"
class Solution(object):
    def getMaximumConsecutive(self, coins):
        coins.sort()
        result = 1
        for c in coins:
            if c > result:
                break
            result += c
        return result
",nlogn
"
import collections


class Solution(object):
    def sumOfDistancesInTree(self, N, edges):
        def dfs(graph, node, parent, count, result):
            for nei in graph[node]:
                if nei != parent:
                    dfs(graph, nei, node, count, result)
                    count[node] += count[nei]
                    result[node] += result[nei]+count[nei]

        def dfs2(graph, node, parent, count, result):
            for nei in graph[node]:
                if nei != parent:
                    result[nei] = result[node]-count[nei] + \
                                  len(count)-count[nei]
                    dfs2(graph, nei, node, count, result)

        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        count = [1] * N
        result = [0] * N

        dfs(graph, 0, None, count, result)
        dfs2(graph, 0, None, count, result)
        return result

",n
"
import collections
import itertools



class Solution(object):
    def timeTaken(self, arrival, state):
        def go_until(t):
            while curr[0] <= t and any(q):
                if not q[direction[0]]:
                    direction[0] ^= 1
                result[q[direction[0]].popleft()] = curr[0]
                curr[0] += 1
    
        UNKNOWN, ENTERING, EXITING = list(range(-1, 1+1))
        result = [0]*len(arrival)
        curr, direction = [float(""-inf"")], [UNKNOWN]
        q = [collections.deque(), collections.deque()]
        for i, (a, s) in enumerate(zip(arrival, state)):
            go_until(a-1)
            q[s].append(i)
            if not (a <= curr[0]):
                curr, direction = [a], [EXITING]
        go_until(float(""inf""))
        return result
",n
"
class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def makeConnected(self, n, connections):
        if len(connections) < n-1:
            return -1
        union_find = UnionFind(n)
        for i, j in connections:
            union_find.union_set(i, j)
        return union_find.count - 1


",|E| + |V|
"import collections


class Solution2(object):
    def makeConnected(self, n, connections):
        def dfs(i, lookup):
            if i in lookup:
                return 0
            lookup.add(i)
            if i in G:
                for j in G[i]:
                    dfs(j, lookup)
            return 1

        if len(connections) < n-1:
            return -1
        G = collections.defaultdict(list)
        for i, j in connections:
            G[i].append(j)
            G[j].append(i)
        lookup = set()
        return sum(dfs(i, lookup) for i in range(n)) - 1
",|E| + |V|
"
class Solution(object):
    def findPaths(self, m, n, N, x, y):
        M = 1000000000 + 7
        dp = [[[0 for _ in range(n)] for _ in range(m)] for _ in range(2)]
        for moves in range(N):
            for i in range(m):
                for j in range(n):
                    dp[(moves + 1) % 2][i][j] = (((1 if (i == 0) else dp[moves % 2][i - 1][j]) + \
                                                  (1 if (i == m - 1) else dp[moves % 2][i + 1][j])) % M + \
                                                 ((1 if (j == 0) else dp[moves % 2][i][j - 1]) + \
                                                  (1 if (j == n - 1) else dp[moves % 2][i][j + 1])) % M) % M
        return dp[N % 2][x][y]

",N * m * n
"
class Solution(object):
    def maxSubArrayLen(self, nums, k):
        sums = {}
        cur_sum, max_len = 0, 0
        for i in range(len(nums)):
            cur_sum += nums[i]
            if cur_sum == k:
                max_len = i + 1
            elif cur_sum - k in sums:
                max_len = max(max_len, i - sums[cur_sum - k])
            if cur_sum not in sums:
                sums[cur_sum] = i 
        return max_len

",n
"
class Solution(object):
    def maxBuilding(self, n, restrictions):
        restrictions.extend([[1, 0], [n, n-1]])
        restrictions.sort()
        for i in reversed(range(len(restrictions)-1)):
            restrictions[i][1] = min(restrictions[i][1], restrictions[i+1][1]+(restrictions[i+1][0]-restrictions[i][0]))
        result = 0
        for i in range(1, len(restrictions)):
            restrictions[i][1] = min(restrictions[i][1], restrictions[i-1][1]+(restrictions[i][0]-restrictions[i-1][0]))
            left, h1 = restrictions[i-1]
            right, h2 = restrictions[i]
            result = max(result, max(h1, h2)+((right-left)-abs(h1-h2))//2)
        return result
",nlogn
"

class Solution(object):
    def maxStrength(self, nums):
        if all(x <= 0 for x in nums) and sum(x < 0 for x in nums) <= 1:
            return max(nums)
        result = reduce(lambda x, y: x*y, (x for x in nums if x))
        return result if result > 0 else result//max(x for x in nums if x < 0)
",n
"

class Solution(object):
    def theMaximumAchievableX(self, num, t):
        return num+2*t
",1
"
class Solution(object):
    def mincostTickets(self, days, costs):
        durations = [1, 7, 30]
        W = durations[-1]
        dp = [float(""inf"") for i in range(W)]
        dp[0] = 0
        last_buy_days = [0, 0, 0]
        for i in range(1,len(days)+1):
            dp[i%W] = float(""inf"")
            for j in range(len(durations)):
                while i-1 < len(days) and \
                      days[i-1] > days[last_buy_days[j]]+durations[j]-1:
                    last_buy_days[j] += 1 
                dp[i%W] = min(dp[i%W], dp[last_buy_days[j]%W]+costs[j])
        return dp[len(days)%W]
",n
"
class Solution(object):
    def canEat(self, candiesCount, queries):
        prefix = [0]*(len(candiesCount)+1)
        for i, c in enumerate(candiesCount):
            prefix[i+1] = prefix[i]+c
        return [prefix[t]//c < d+1 <= prefix[t+1]//1 for t, d, c in queries]
",n
"

class Solution(object):
    def countBattleships(self, board):
        if not board or not board[0]:
            return 0

        cnt = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                cnt += int(board[i][j] == 'X' and
                           (i == 0 or board[i - 1][j] != 'X') and
                           (j == 0 or board[i][j - 1] != 'X'))
        return cnt

",m * n
"
class Solution(object):
    def merge(self, A, m, B, n):
        last, i, j = m + n - 1, m - 1, n - 1

        while i >= 0 and j >= 0:
            if A[i] > B[j]:
                A[last] = A[i]
                last, i = last - 1, i - 1
            else:
                A[last] = B[j]
                last, j = last - 1, j - 1

        while j >= 0:
                A[last] = B[j]
                last, j = last - 1, j - 1

",n
"
import collections


class Solution(object):
    def subarraySum(self, nums, k):
        result = 0
        accumulated_sum = 0
        lookup = collections.defaultdict(int)
        lookup[0] += 1
        for num in nums:
            accumulated_sum += num
            result += lookup[accumulated_sum - k]
            lookup[accumulated_sum] += 1
        return result

",n
"
import itertools



class Solution(object):
    def maxPointsInsideSquare(self, points, s):
        INF = float(""inf"")
        lookup = [INF for _ in range(26)]
        d = INF
        for c, (x, y) in zip(s, points):
            k = ord(c)-ord('a')
            mn2 = max(abs(x), abs(y))
            if mn2 < lookup[k]:
                mn2, lookup[k] = lookup[k], mn2
            d = min(d, mn2)
        return sum(mn1 < d for mn1 in lookup)
",n + 26
"
import collections



class Solution(object):
    def squareFreeSubsets(self, nums):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return primes

        MAX_NUM = max(nums)
        PRIMES = linear_sieve_of_eratosthenes(MAX_NUM)
        MASKS = [0]*(MAX_NUM+1)
        for x in range(MAX_NUM+1):
            y = x
            for i, p in enumerate(PRIMES):
                if y%p:
                    continue
                if y%p**2 == 0:
                    MASKS[x] = 0
                    break
                MASKS[x] |= (1<<i)
                y //= p
        MOD = 10**9+7

        cnt = collections.Counter(nums)
        arr = [x for x in cnt.keys() if x != 1]
        dp = [1]*(1<<len(PRIMES))
        for x in arr:
            if not MASKS[x]:
                continue
            for mask in reversed(range(len(dp))):
                 if MASKS[x]&mask == 0:
                    dp[mask|MASKS[x]] = (dp[mask|MASKS[x]]+cnt[x]*dp[mask])%MOD
        return (dp[-1]*pow(2, cnt[1], MOD)-1)%MOD if 1 in cnt else (dp[-1]-1)%MOD


",n + m * 2^p
"import collections



class Solution2(object):
    def squareFreeSubsets(self, nums):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return primes

        MAX_NUM = max(nums)
        PRIMES = linear_sieve_of_eratosthenes(MAX_NUM)
        MASKS = [0]*(MAX_NUM+1)
        for x in range(MAX_NUM+1):
            y = x
            for i, p in enumerate(PRIMES):
                if y%p:
                    continue
                if y%p**2 == 0:
                    MASKS[x] = 0
                    break
                MASKS[x] |= (1<<i)
                y //= p
        MOD = 10**9+7

        cnt = collections.Counter(nums)
        arr = [x for x in cnt.keys() if x != 1]
        dp = [[-1]*(1<<len(PRIMES)) for i in range(len(arr))]
        def memoization(i, mask):
            if i == len(arr):
                return 1
            if dp[i][mask] == -1:
                dp[i][mask] = memoization(i+1, mask)
                if MASKS[arr[i]] and (MASKS[arr[i]]&mask) == MASKS[arr[i]]:
                    dp[i][mask] = (dp[i][mask]+cnt[arr[i]]*memoization(i+1, mask^MASKS[arr[i]]))%MOD
            return dp[i][mask]
    
        return (memoization(0, (1<<len(PRIMES))-1)*pow(2, cnt[1], MOD)-1)%MOD if 1 in cnt else (memoization(0, (1<<len(PRIMES))-1)-1)%MOD
",n + m * 2^p
"

class Solution(object):
    def countKeyChanges(self, s):
        return sum(s[i].lower() != s[i+1].lower() for i in range(len(s)-1))
",n
"

class Solution(object):
    def findFinalValue(self, nums, original):
        lookup = set(nums)
        while original in lookup:
            original *= 2
        return original
",n
"
import collections


class Solution(object):
    def groupStrings(self, strings):
        groups = collections.defaultdict(list)
        for s in strings: 
            groups[self.hashStr(s)].append(s)

        result = []
        for key, val in groups.items():
            result.append(sorted(val))

        return result

    def hashStr(self, s):
        base = ord(s[0])
        hashcode = """"
        for i in range(len(s)):
            if ord(s[i]) - base >= 0:
                hashcode += chr(ord('a') + ord(s[i]) - base)
            else:
                hashcode += chr(ord('a') + ord(s[i]) - base + 26)
        return hashcode

",nlogn
"
import collections



class Solution(object):
    def maxFrequencyElements(self, nums):
        cnt = collections.Counter(nums)
        mx = max(cnt.values())
        return sum(v for v in cnt.values() if v == mx)
",n
"
class Solution(object):
    def canCross(self, stones):
        if stones[1] != 1:
            return False

        last_jump_units = {s: set() for s in stones}
        last_jump_units[1].add(1)
        for s in stones[:-1]:
            for j in last_jump_units[s]:
                for k in (j-1, j, j+1):
                    if k > 0 and s+k in last_jump_units:
                        last_jump_units[s+k].add(k)
        return bool(last_jump_units[stones[-1]])

",n^2
"

class Solution(object):
    def minValidStrings(self, words, target):
        MOD, P = 10**9+7, 131
        power = [1]
        for _ in range(len(target)):
            power.append(power[-1]*P%MOD)
        lookup = set()
        for w in words:
            h = 0
            for x in w:
                h = (h*P+(ord(x)-ord('a')+1))%MOD
                lookup.add(h)
        dp = [0]*(len(target)+1)
        left = h = 0
        for right in range(len(target)):
            h = (h*P+(ord(target[right])-ord('a')+1))%MOD
            while right-left+1 >= 1 and h not in lookup:
                h = (h-(ord(target[left])-ord('a')+1)*power[(right-left+1)-1])%MOD
                left += 1
            if right-left+1 == 0:
                return -1
            dp[right+1] = dp[(right-(right-left+1))+1]+1
        return dp[-1]


",n + w * l
"import collections


class AhoNode(object):
    def __init__(self):
        self.children = collections.defaultdict(AhoNode)
        self.suffix = None
        self.length = 0 


class AhoTrie(object):

    def step(self, letter):
        while self.__node and letter not in self.__node.children:
            self.__node = self.__node.suffix
        self.__node = self.__node.children[letter] if self.__node else self.__root
        return self.__get_ac_node_outputs(self.__node)
    
    def __init__(self, patterns):
        self.__root = self.__create_ac_trie(patterns)
        self.__node = self.__create_ac_suffix_and_output_links(self.__root)
    
    def __create_ac_trie(self, patterns): 
        root = AhoNode()
        for i, pattern in enumerate(patterns):
            node = root
            for l, c in enumerate(pattern, 1): 
                node = node.children[c]
                node.length = l 
        return root

    def __create_ac_suffix_and_output_links(self, root): 
        queue = collections.deque()
        for node in root.children.values():
            queue.append(node)
            node.suffix = root

        while queue:
            node = queue.popleft()
            for c, child in node.children.items():
                queue.append(child)
                suffix = node.suffix
                while suffix and c not in suffix.children:
                    suffix = suffix.suffix
                child.suffix = suffix.children[c] if suffix else root
                
        return root

    def __get_ac_node_outputs(self, node): 
        return node.length 



class Solution2(object):
    def minValidStrings(self, words, target):
        trie = AhoTrie(words)
        dp = [0]*(len(target)+1)
        for i in range(len(target)):
            l = trie.step(target[i])
            if not l:
                return -1
            dp[i+1] = dp[(i-l)+1]+1
        return dp[-1]


",n + w * l
"
class Solution3(object):
    def minValidStrings(self, words, target):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern, callback):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                callback(i, j)
                if j+1 == len(pattern):
                    j = prefix[j]

        def update(i, j):
            lookup[i] = max(lookup[i], j+1)

        lookup = [0]*len(target)
        for w in words:
            KMP(target, w, update)
        dp = [0]*(len(target)+1)
        for i in range(len(target)):
            if not lookup[i]:
                return -1
            dp[i+1] = dp[(i-lookup[i])+1]+1
        return dp[-1]
",w * (l + n)
"

class Solution(object):
    def maxProfit(self, prices):
        profit = 0
        for i in range(len(prices) - 1):
            profit += max(0, prices[i + 1] - prices[i])
        return profit

    def maxProfit2(self, prices):
        return sum([max(prices[x + 1] - prices[x], 0) for x in range(len(prices[:-1]))])

",n
"
class Solution(object):
    def minimumCost(self, sentence, k):
        def lens(sentence):
            j = len(sentence)-1
            for i in reversed(range(-1, len(sentence))):
                if i == -1 or sentence[i] == ' ':
                    yield j-i
                    j = i-1

        word_lens, dp = [], [] 
        t = -1
        for l in lens(sentence):
            word_lens.append(l)
            dp.append(float(""inf""))
            t += l+1
            if t <= k:
                dp[-1] = 0
                continue
            total = l
            for j in reversed(range(len(dp)-1)):
                dp[-1] = min(dp[-1], dp[j] + (k-total)**2)
                total += (word_lens[j]+1)
                if total > k:
                    word_lens = word_lens[j:] 
                    dp = dp[j:]
                    break
        return dp[-1] if dp else 0


",s + n * k
"class Solution2(object):
    def minimumCost(self, sentence, k):
        word_lens = []
        j = 0
        for i in range(len(sentence)+1):
            if i != len(sentence) and sentence[i] != ' ':
                continue
            word_lens.append(i-j)
            j = i+1
        dp = [float(""inf"")]*(len(word_lens)) 
        i, total = len(word_lens)-1, -1
        while i >= 0 and total + (word_lens[i]+1) <= k: 
            total += (word_lens[i]+1)
            dp[i] = 0
            i -= 1
        for i in reversed(range(i+1)):
            total = word_lens[i]
            for j in range(i+1, len(dp)):
                dp[i] = min(dp[i], dp[j] + (k-total)**2)
                total += (word_lens[j]+1)
                if total > k:
                    break
        return dp[0]


",s + n * k
"class Solution3(object):
    def minimumCost(self, sentence, k):
        word_lens = []
        j = 0
        for i in range(len(sentence)+1):
            if i != len(sentence) and sentence[i] != ' ':
                continue
            word_lens.append(i-j)
            j = i+1
        dp = [float(""inf"")]*(1+(len(word_lens)-1)) 
        dp[0] = 0
        for i in range(1, (len(word_lens)-1)+1):
            total = word_lens[i-1]
            for j in reversed(range(i)):
                dp[i] = min(dp[i], dp[j] + (k-total)**2)
                if j-1 < 0:
                    continue
                total += (word_lens[j-1]+1)
                if total > k:
                    break
        i, total = len(word_lens)-1, -1
        while i >= 0 and total + (word_lens[i]+1) <= k: 
            total += (word_lens[i]+1)
            i -= 1
        return min(dp[j] for j in range(i+1, len(dp)))
",s + n * k
"

class Solution(object):
    def hardestWorker(self, n, logs):
        return logs[max(range(len(logs)), key=lambda x: (logs[x][1]-(logs[x-1][1] if x-1 >= 0 else 0), -logs[x][0]))][0]
",l
"
class Solution(object):
    def nthPersonGetsNthSeat(self, n):
        return 0.5 if n != 1 else 1.0

",1
"class Solution2(object):
    def nthPersonGetsNthSeat(self, n):
        dp = [0.0]*2
        dp[0] = 1.0 
        for i in range(2, n+1):
            dp[(i-1)%2] = 1.0/i+dp[(i-2)%2]*(i-2)/i
        return dp[(n-1)%2]
",n
"
class Solution(object):
    def getMinDistance(self, nums, target, start):
        for i in range(len(nums)):
            if (start-i >= 0 and nums[start-i] == target) or \
               (start+i < len(nums) and nums[start+i] == target):
                break
        return i
",n
"
class Solution(object):
    def minDistance(self, height, width, tree, squirrel, nuts):
        def distance(a, b):
            return abs(a[0] - b[0]) + abs(a[1] - b[1])

        result = 0
        d = float(""inf"")
        for nut in nuts:
            result += (distance(nut, tree) * 2)
            d = min(d, distance(nut, squirrel) - distance(nut, tree))
        return result + d

",n
"
import collections


class Solution(object):
    def sequenceReconstruction(self, org, seqs):
        if not seqs:
            return False
        pos = [0] * (len(org) + 1)
        for i in range(len(org)):
            pos[org[i]] = i

        is_matched = [False] * (len(org) + 1)
        cnt_to_match = len(org) - 1
        for seq in seqs:
            for i in range(len(seq)):
                if not 0 < seq[i] <= len(org):
                    return False
                if i == 0:
                    continue
                if pos[seq[i-1]] >= pos[seq[i]]:
                    return False
                if is_matched[seq[i-1]] == False and pos[seq[i-1]] + 1 == pos[seq[i]]:
                    is_matched[seq[i-1]] = True
                    cnt_to_match -= 1

        return cnt_to_match == 0


",n * s
"class Solution2(object):
    def sequenceReconstruction(self, org, seqs):
        graph = collections.defaultdict(set)
        indegree = collections.defaultdict(int)
        integer_set = set()
        for seq in seqs:
            for i in seq:
                integer_set.add(i)
            if len(seq) == 1:
                if seq[0] not in indegree:
                    indegree[seq[0]] = 0
                continue
            for i in range(len(seq)-1):
                if seq[i] not in indegree:
                    indegree[seq[i]] = 0
                if seq[i+1] not in graph[seq[i]]:
                    graph[seq[i]].add(seq[i+1])
                    indegree[seq[i+1]] += 1

        cnt_of_zero_indegree = 0
        res = []
        q = []
        for i in indegree:
            if indegree[i] == 0:
                cnt_of_zero_indegree += 1
                if cnt_of_zero_indegree > 1:
                    return False
                q.append(i)

        while q:
            i = q.pop()
            res.append(i)
            cnt_of_zero_indegree = 0
            for j in graph[i]:
                indegree[j] -= 1
                if indegree[j] == 0:
                    cnt_of_zero_indegree += 1
                    if cnt_of_zero_indegree > 1:
                        return False
                    q.append(j)
        return res == org and len(org) == len(integer_set)

",|V| + |E|
"

class Solution(object):
    def accountBalanceAfterPurchase(self, purchaseAmount):
        return 100-(purchaseAmount+5)//10*10
",1
"
from collections import deque

class Solution(object):

    def __init__(self):
        self.__k = 300
        self.__dq = deque()
        self.__count = 0

    def hit(self, timestamp):
        self.getHits(timestamp)
        if self.__dq and self.__dq[-1][0] == timestamp:
            self.__dq[-1][1] += 1
        else:
            self.__dq.append([timestamp, 1])
        self.__count += 1

    def getHits(self, timestamp):
        while self.__dq and self.__dq[0][0] <= timestamp - self.__k:
            self.__count -= self.__dq.popleft()[1]
        return self.__count


",1
"
class Solution(object):
    def setZeroes(self, matrix):
        first_col = reduce(lambda acc, i: acc or matrix[i][0] == 0, range(len(matrix)), False)
        first_row = reduce(lambda acc, j: acc or matrix[0][j] == 0, range(len(matrix[0])), False)

        for i in range(1, len(matrix)):
            for j in range(1, len(matrix[0])):
                if matrix[i][j] == 0:
                    matrix[i][0], matrix[0][j] = 0, 0

        for i in range(1, len(matrix)):
            for j in range(1, len(matrix[0])):
                if matrix[i][0] == 0 or matrix[0][j] == 0:
                    matrix[i][j] = 0

        if first_col:
            for i in range(len(matrix)):
                matrix[i][0] = 0

        if first_row:
            for j in range(len(matrix[0])):
                matrix[0][j] = 0

",m * n
"
import collections



class Solution(object):
    def longestValidSubstring(self, word, forbidden):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for w in forbidden:
            reduce(dict.__getitem__, w, trie)[""_end""]
        result = 0
        right = len(word)-1
        for left in reversed(range(len(word))):
            node = trie
            for i in range(left, right+1):
                if word[i] not in node: 
                    break
                node = node[word[i]]
                if ""_end"" in node:
                    right = i-1
                    break
            result = max(result, right-left+1)
        return result
",(m + n) * l
"
class Solution(object):
    def maxScoreSightseeingPair(self, A):
        result, curr = 0, 0
        for x in A:
            result = max(result, curr+x)
            curr = max(curr, x)-1
        return result
",n
"
import collections


class Solution(object):
    def largestUniqueNumber(self, A):
        A.append(-1)
        return max(k for k,v in list(collections.Counter(A).items()) if v == 1)
",n
"
import heapq


class Solution(object):
    def maxAverageRatio(self, classes, extraStudents):
        def profit(a, b):
            return float(a+1)/(b+1)-float(a)/b

        max_heap = [(-profit(a, b), a, b) for a, b in classes]
        heapq.heapify(max_heap)
        while extraStudents:
            v, a, b = heapq.heappop(max_heap)
            a, b = a+1, b+1
            heapq.heappush(max_heap, (-profit(a, b), a, b))
            extraStudents -= 1
        return sum(float(a)/b for v, a, b in max_heap)/len(classes)
",n + mlogn
"

class Solution(object):
    def zeroFilledSubarray(self, nums):
        result = 0
        prev = -1
        for i in range(len(nums)):
            if nums[i]:
                prev = i
                continue
            result += i-prev
        return result
",n
"

class Solution(object):
    def canAliceWin(self, a, b):
        def is_closely_greater(a, b):
            return ord(a[0])-ord(b[0]) <= 1 and a > b

        result = True
        i, j = 0, -1
        for _ in range(len({w[0] for w in a})+len({w[0] for w in b})): 
            j = next((j for j in range(j+1, len(b)) if is_closely_greater(b[j], a[i])), len(b))
            if j == len(b):
                break
            while j+1 < len(b) and b[j+1][0] == b[j][0]: 
                j += 1
            a, b, i, j, result = b, a, j, i, not result
        return result
",m + n
"
import collections


class Solution(object):
    def isEscapePossible(self, blocked, source, target):
        R, C = 10**6, 10**6
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def bfs(blocks, source, target):
            max_area_surrounded_by_blocks = len(blocks)*(len(blocks)-1)//2
            lookup = set([source])
            if len(lookup) > max_area_surrounded_by_blocks:
                return True
            q = collections.deque([source])
            while q:
                source = q.popleft()
                if source == target:
                    return True
                for direction in directions:
                    nr, nc = source[0]+direction[0], source[1]+direction[1]
                    if not ((0 <= nr < R) and
                            (0 <= nc < C) and 
                            (nr, nc) not in lookup and
                            (nr, nc) not in blocks):
                        continue
                    lookup.add((nr, nc))
                    if len(lookup) > max_area_surrounded_by_blocks:
                        return True
                    q.append((nr, nc))
            return False
        
        return bfs(set(map(tuple, blocked)), tuple(source), tuple(target)) and \
               bfs(set(map(tuple, blocked)), tuple(target), tuple(source))
",n^2
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def distributeCoins(self, root):
        def dfs(root, result):
            if not root:
                return 0
            left, right = dfs(root.left, result), dfs(root.right, result)
            result[0] += abs(left) + abs(right)
            return root.val + left + right - 1

        result = [0]
        dfs(root, result)
        return result[0]
",n
"

class Solution(object):
    def numberOfRightTriangles(self, grid):
        def get(i, j):
            return grid[i][j] if n < m else grid[j][i]

        n, m = len(grid), len(grid[0])
        result = 0
        cnt1 = [sum(get(i, j) for j in range(max(n, m))) for i in range(min(n, m))]
        for j in range(max(n, m)):
            cnt2 = sum(get(i, j) for i in range(min(n, m)))
            result += sum((cnt1[i]-1)*(cnt2-1) for i in range(min(n, m)) if get(i, j))
        return result


",n * m
"
class Solution2(object):
    def numberOfRightTriangles(self, grid):
        n, m = len(grid), len(grid[0])
        cnt1 = [sum(grid[i][j] for j in range(m)) for i in range(n)]
        cnt2 = [sum(grid[i][j] for i in range(n)) for j in range(m)]
        return sum((cnt1[i]-1)*(cnt2[j]-1) for i in range(n) for j in range(m) if grid[i][j])


",n * m
"
class Solution3(object):
    def numberOfRightTriangles(self, grid):
        def get(i, j):
            return grid[i][j] if n < m else grid[j][i]

        def count(direction):
            result = 0
            cnt = [0]*min(n, m)
            for j in direction(range(max(n, m))):
                c = sum(get(i, j) for i in range(len(cnt)))
                for i in range(len(cnt)):
                    if get(i, j) == 0:
                        continue
                    result += cnt[i]
                    cnt[i] += c-1
            return result
        
        n, m = len(grid), len(grid[0])
        return count(lambda x: x)+count(reversed)
",n * m
"
import collections


class Solution(object):
    def frequencySort(self, s):
        freq = collections.defaultdict(int)
        for c in s:
            freq[c] += 1

        counts = [""""] * (len(s)+1)
        for c in freq:
            counts[freq[c]] += c

        result = """"
        for count in reversed(range(len(counts)-1)):
            for c in counts[count]:
                result += c * count

        return result

",n
"

class Solution(object):
    def uniqueXorTriplets(self, nums):
        return 1<<len(nums).bit_length() if len(nums) >= 3 else len(nums)
",logn
"

class Solution(object):
    def pathExistenceQueries(self, n, nums, maxDiff, queries):
        prefix = [0]*n
        for i in range(n-1):
            prefix[i+1] = prefix[i]+int(nums[i+1]-nums[i] > maxDiff)
        return [prefix[i] == prefix[j] for i, j in queries]
",n + q
"
import itertools



class Solution(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        def check(s1, s2):
            return len(s1) == len(s2) and sum(a != b for a, b in zip(s1, s2)) == 1

        dp = [[1, -1] for _ in range(n)]
        for i in reversed(range(n)):
            for j in range(i+1, n):
                if groups[i] != groups[j] and check(words[j], words[i]):
                    dp[i] = max(dp[i], [dp[j][0]+1, j])
        result = []
        i = max(range(n), key=lambda x: dp[x])
        while i != -1:
            result.append(words[i])
            i = dp[i][1]
        return result


",n^2
"import itertools



class Solution2(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        def check(s1, s2):
            return len(s1) == len(s2) and sum(a != b for a, b in zip(s1, s2)) == 1

        dp = [[1, -1] for _ in range(n)]
        for i in range(n):
            for j in range(i):
                if groups[i] != groups[j] and check(words[j], words[i]):
                    dp[i] = max(dp[i], [dp[j][0]+1, j])
        result = []
        i = max(range(n), key=lambda x: dp[x])
        while i != -1:
            result.append(words[i])
            i = dp[i][1]
        result.reverse()
        return result


",n^2
"import itertools



class Solution3(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        def check(s1, s2):
            return len(s1) == len(s2) and sum(a != b for a, b in zip(s1, s2)) == 1

        dp = [[] for _ in range(n)]
        for i in range(n):
            for j in range(i):
                if groups[i] != groups[j] and check(words[j], words[i]) and len(dp[j]) > len(dp[i]):
                    dp[i] = dp[j]
            dp[i] = dp[i]+[i]
        return [words[x] for x in max(dp, key=lambda x: len(x))]
",n^2
"
class Solution(object):
    _num = [0]
    def numSquares(self, n):
        num = self._num
        while len(num) <= n:
            num += min(num[-i*i] for i in range(1, int(len(num)**0.5+1))) + 1,
        return num[n]

",n * sqrt(n)
"

class Solution(object):
    def sortEvenOdd(self, nums):
        def partition(index, nums):
            for i in range(len(nums)):
                j = i
                while nums[i] >= 0:
                    j = index(j)
                    nums[i], nums[j] = nums[j], ~nums[i] 
            for i in range(len(nums)):
                nums[i] = ~nums[i] 

        def inplace_counting_sort(nums, left, right, reverse=False): 
            if right-left+1 == 0:
                return
            count = [0]*(max(nums[i] for i in range(left, right+1))+1)
            for i in range(left, right+1):
                count[nums[i]] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(left, right+1)): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = left+count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(left, right+1):
                nums[i] = ~nums[i] 
            if reverse: 
                while left < right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 1
                    right -= 1

        partition(lambda i: i//2 if i%2 == 0 else (len(nums)+1)//2+i//2, nums)
        inplace_counting_sort(nums, 0, (len(nums)+1)//2-1)
        inplace_counting_sort(nums, (len(nums)+1)//2, len(nums)-1, True)
        partition(lambda i: 2*i if i < (len(nums)+1)//2 else 1+2*(i-(len(nums)+1)//2), nums)
        return nums


",n
"
class Solution2(object):
    def sortEvenOdd(self, nums):
        def partition(index, nums):
            for i in range(len(nums)):
                j = i
                while nums[i] >= 0:
                    j = index(j)
                    nums[i], nums[j] = nums[j], ~nums[i] 
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
        
        partition(lambda i: i//2 if i%2 == 0 else (len(nums)+1)//2+i//2, nums)
        nums[:(len(nums)+1)//2], nums[(len(nums)+1)//2:] = sorted(nums[:(len(nums)+1)//2]), sorted(nums[(len(nums)+1)//2:], reverse=True)
        partition(lambda i: 2*i if i < (len(nums)+1)//2 else 1+2*(i-(len(nums)+1)//2), nums)
        return nums


",nlogn
"
class Solution3(object):
    def sortEvenOdd(self, nums):
        nums[::2], nums[1::2] = sorted(nums[::2]), sorted(nums[1::2], reverse=True)
        return nums
",nlogn
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def str2tree(self, s):
        def str2treeHelper(s, i):
            start = i
            if s[i] == '-': i += 1
            while i < len(s) and s[i].isdigit(): i += 1
            node = TreeNode(int(s[start:i]))
            if i < len(s) and s[i] == '(':
                i += 1
                node.left, i = str2treeHelper(s, i)
                i += 1
            if i < len(s) and s[i] == '(':
                i += 1
                node.right, i = str2treeHelper(s, i)
                i += 1
            return node, i

        return str2treeHelper(s, 0)[0] if s else None

",n
"
class SegmentTreeNode(object):
    def __init__(self, start, end):
        self.start, self.end = start, end
        self.total = self.count = 0
        self._left = self._right = None

    def mid(self):
        return (self.start+self.end) // 2

    def left(self):
        self._left = self._left or SegmentTreeNode(self.start, self.mid())
        return self._left

    def right(self):
        self._right = self._right or SegmentTreeNode(self.mid(), self.end)
        return self._right

    def update(self, X, i, j, val):
        if i >= j:
            return 0
        if self.start == i and self.end == j:
            self.count += val
        else:
            self.left().update(X, i, min(self.mid(), j), val)
            self.right().update(X, max(self.mid(), i), j, val)
        if self.count > 0:
            self.total = X[self.end]-X[self.start]
        else:
            self.total = self.left().total + self.right().total
        return self.total


class Solution(object):
    def rectangleArea(self, rectangles):
        OPEN, CLOSE = 1, -1
        events = []
        X = set()
        for x1, y1, x2, y2 in rectangles:
            events.append((y1, OPEN, x1, x2))
            events.append((y2, CLOSE, x1, x2))
            X.add(x1)
            X.add(x2)
        events.sort()
        X = sorted(X)
        Xi = {x: i for i, x in enumerate(X)}

        st = SegmentTreeNode(0, len(X)-1)
        result = 0
        cur_x_sum = 0
        cur_y = events[0][0]
        for y, typ, x1, x2 in events:
            result += cur_x_sum * (y-cur_y)
            cur_x_sum = st.update(X, Xi[x1], Xi[x2], typ)
            cur_y = y
        return result % (10**9+7)

",nlogn
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))


class Solution(object):
    def reverseList(self, head):
        dummy = ListNode(float(""-inf""))
        while head:
            dummy.next, head.next, head = head, dummy.next, head.next
        return dummy.__next__

",n
"
class Solution2(object):
    def reverseList(self, head):
        [begin, end] = self.reverseListRecu(head)
        return begin

    def reverseListRecu(self, head):
        if not head:
            return [None, None]

        [begin, end] = self.reverseListRecu(head.__next__)

        if end:
            end.next = head
            head.next = None
            return [begin, head]
        else:
            return [head, head]

",n
"

class Solution(object):
    def findPrefixScore(self, nums):
        curr = 0
        for i in range(len(nums)):
            curr = max(curr, nums[i])
            nums[i] += (nums[i-1] if i-1 >= 0 else 0)+curr
        return nums
",n
"
import collections


class Solution(object):
    def distanceK(self, root, target, K):
        def dfs(parent, child, neighbors):
            if not child:
                return
            if parent:
                neighbors[parent.val].append(child.val)
                neighbors[child.val].append(parent.val)
            dfs(child, child.left, neighbors)
            dfs(child, child.right, neighbors)

        neighbors = collections.defaultdict(list)
        dfs(None, root, neighbors)
        bfs = [target.val]
        lookup = set(bfs)
        for _ in range(K):
            bfs = [nei for node in bfs
                   for nei in neighbors[node]
                   if nei not in lookup]
            lookup |= set(bfs)
        return bfs

",n
"
import math


class Solution(object):
    def visiblePoints(self, points, angle, location):
        arr, extra = [], 0
        for p in points:
            if p == location:
                extra += 1
                continue
            arr.append(math.atan2(p[1]-location[1], p[0]-location[0]))
        arr.sort()
        arr.extend([x + 2.0*math.pi for x in arr]) 
        d = 2.0*math.pi * (angle/360.0)
        left = result = 0
        for right in range(len(arr)):
            while arr[right]-arr[left] > d:
                left += 1
            result = max(result, right-left+1)
        return result + extra
",nlogn
"
import itertools


class Solution(object):
    def destCity(self, paths):
        A, B = list(map(set, zip(*paths)))
        return (B-A).pop()
",n
"

class Solution(object):
    def validStrings(self, n):
        def backtracking(i):
            if i == n:
                result.append("""".join(curr))
                return
            if not curr or curr[-1] == '1':
                curr.append('0')
                backtracking(i+1)
                curr.pop()
            curr.append('1')
            backtracking(i+1)
            curr.pop()

        result, curr = [], []
        backtracking(0)
        return result


",n * 2^n
"
class Solution2(object):
    def validStrings(self, n):
        q = [[]]
        for _ in range(n):
            new_q = []
            for x in q:
                if not x or x[-1] == '1':
                    new_q.append(x+['0'])
                new_q.append(x+['1'])
            q = new_q
        return ["""".join(x) for x in q]
",n * 2^n
"

class Solution(object):
    def reachableNodes(self, n, edges, restricted):
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = 0
        lookup = [False]*n
        for x in restricted:
            lookup[x] = True
        q = [0]
        lookup[0] = True
        while q:
            new_q = []
            for u in q:
                result += 1
                for v in adj[u]:
                    if lookup[v]:
                        continue
                    lookup[v] = True
                    new_q.append(v)
            q = new_q
        return result
",n
"
import collections
import random


class Solution(object):
    def canDistribute(self, nums, quantity):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        count = collections.Counter(nums)
        total = (1<<len(quantity))-1
        requirement = [0]*(total+1)
        for mask in range(len(requirement)): 
            base = 1
            for i in range(len(quantity)): 
                if mask&base:
                    requirement[mask] += quantity[i]
                base <<= 1
        dp = [[0]*(total+1) for _ in range(2)]
        dp[0][0] = 1
        i = 0
        cnts = list(count.values())
        if len(quantity) < len(cnts): 
            nth_element(cnts, len(quantity)-1, lambda a, b: a > b)
            cnts = cnts[:len(quantity)]
        for cnt in cnts: 
            dp[(i+1)%2] = [0]*(total+1)
            for mask in reversed(range(total+1)):
                dp[(i+1)%2][mask] |= dp[i%2][mask]
                submask = mask
                while submask > 0:
                    if requirement[submask] <= cnt and dp[i%2][mask^submask]:
                        dp[(i+1)%2][mask] = 1
                    submask = (submask-1)&mask
            i += 1
        return dp[len(cnts)%2][total]
",n + m * 3^m
"
class Solution(object):
    def maxTurbulenceSize(self, A):
        result = 1
        start = 0
        for i in range(1, len(A)):
            if i == len(A)-1 or \
               cmp(A[i-1], A[i]) * cmp(A[i], A[i+1]) != -1:
                result = max(result, i-start+1)
                start = i
        return result
",n
"

class Solution(object):
    def numberOfComponents(self, properties, k):
        def bfs(u):
            q = [u]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q

        p_set = [set(p) for p in properties]
        adj = [[] for _ in range(len(properties))]
        for i in range(len(p_set)):
            for j in range(i+1, len(p_set)):
                if sum(x in p_set[j] for x in p_set[i]) >= k:
                    adj[i].append(j)
                    adj[j].append(i)
        lookup = [False]*len(properties)
        result = 0
        for i in range(len(properties)):
            if lookup[i]:
                continue
            bfs(i)
            result += 1
        return result


",n^2 * m
"
class Solution2(object):
    def numberOfComponents(self, properties, k):
        class UnionFind(object): 
            def __init__(self, n):
                self.set = list(range(n))
                self.rank = [0]*n

            def find_set(self, x):
                stk = []
                while self.set[x] != x: 
                    stk.append(x)
                    x = self.set[x]
                while stk:
                    self.set[stk.pop()] = x
                return x

            def union_set(self, x, y):
                x, y = self.find_set(x), self.find_set(y)
                if x == y:
                    return False
                if self.rank[x] > self.rank[y]: 
                    x, y = y, x
                self.set[x] = self.set[y]
                if self.rank[x] == self.rank[y]:
                    self.rank[y] += 1
                return True
    
        p_set = [set(p) for p in properties]
        uf = UnionFind(len(properties))
        return len(properties)-sum(sum(x in p_set[j] for x in p_set[i]) >= k and uf.union_set(i, j) for i in range(len(p_set)) for j in range(i+1, len(p_set)))
",n^2 * m
"

class Solution(object):
    def closestMeetingNode(self, edges, node1, node2):
        def dfs(node):
            lookup = {}
            i = 0
            while node != -1:
                if node in lookup:
                    break
                lookup[node] = i
                i += 1
                node = edges[node]
            return lookup
        
        lookup1, lookup2 = dfs(node1), dfs(node2)
        intersect = set(lookup1.keys())&set(lookup2.keys())
        return min(intersect, key=lambda x: (max(lookup1[x], lookup2[x]), x)) if intersect else -1
",n
"
class TrieNode(object):
    def __init__(self):
        self.is_string = False
        self.leaves = {}


class Solution(object):
    def __init__(self):
        self.root = TrieNode()

    def addWord(self, word):
        curr = self.root
        for c in word:
            if c not in curr.leaves:
                curr.leaves[c] = TrieNode()
            curr = curr.leaves[c]
        curr.is_string = True

    def search(self, word):
        return self.searchHelper(word, 0, self.root)

    def searchHelper(self, word, start, curr):
        if start == len(word):
            return curr.is_string
        if word[start] in curr.leaves:
            return self.searchHelper(word, start+1, curr.leaves[word[start]])
        elif word[start] == '.':
            for c in curr.leaves:
                if self.searchHelper(word, start+1, curr.leaves[c]):
                    return True

        return False


","min(n, h)"
"
class Solution(object):
    def oddEvenJumps(self, A):
        def findNext(idx):
            result = [None]*len(idx)
            stack = []
            for i in idx:
                while stack and stack[-1] < i:
                    result[stack.pop()] = i
                stack.append(i)
            return result
        
        idx = sorted(list(range(len(A))), key = lambda i: A[i])
        next_higher = findNext(idx)
        idx.sort(key = lambda i: -A[i])
        next_lower = findNext(idx)

        odd, even = [False]*len(A), [False]*len(A)
        odd[-1], even[-1] = True, True
        for i in reversed(range(len(A)-1)):
            if next_higher[i]:
                odd[i] = even[next_higher[i]]
            if next_lower[i]:
                even[i] = odd[next_lower[i]]
        return sum(odd)
",nlogn
"

class Solution(object):
    def minUnlockedIndices(self, nums, locked):
        result = mx = cnt = 0
        for i in range(len(nums)):
            if mx < nums[i]:
                mx = nums[i]
                cnt = 0
            elif mx > nums[i]:
                if mx != nums[i]+1:
                    return -1
                result += cnt
                cnt = 0
            cnt += locked[i]
        return result
",n
"

class Solution(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def iter_dfs():
            lookup = [False]*len(circles)
            stk = []
            dst = [False]*len(circles)
            for u in range(len(circles)):
                x, y, r = circles[u]
                if x-r <= 0 or y+r >= Y:
                    lookup[u] = True
                    stk.append(u)
                if x+r >= X or y-r <= 0:
                    dst[u] = True
            while stk:
                u = stk.pop()
                if dst[u]:
                    return True
                x1, y1, r1 = circles[u]
                for v in range(len(circles)):
                    x2, y2, r2 = circles[v]
                    if lookup[v] or not check(x1, y1, r1, x2, y2, r2):
                        continue
                    lookup[v] = True
                    stk.append(v)
            return False

        return not iter_dfs()


",n^2
"
class Solution2(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def bfs():
            lookup = [False]*len(circles)
            q = []
            dst = [False]*len(circles)
            for u in range(len(circles)):
                x, y, r = circles[u]
                if x-r <= 0 or y+r >= Y:
                    lookup[u] = True
                    q.append(u)
                if x+r >= X or y-r <= 0:
                    dst[u] = True
            while q:
                new_q = []
                for u in q:
                    if dst[u]:
                        return True
                    x1, y1, r1 = circles[u]
                    for v in range(len(circles)):
                        x2, y2, r2 = circles[v]
                        if lookup[v] or not check(x1, y1, r1, x2, y2, r2):
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return False

        return not bfs()


",n^2
"
class Solution3(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def iter_dfs(src, dst):
            lookup = [False]*len(adj)
            lookup[src] = True
            stk = [src]
            while stk:
                u = stk.pop()
                if u == dst:
                    return True
                for v in adj[u]:
                    if lookup[v]:
                        continue
                    lookup[v] = True
                    stk.append(v)
            return False

        adj = [[] for _ in range(len(circles)+2)]
        for u in range(len(circles)):
            x1, y1, r1 = circles[u]
            if x1-r1 <= 0 or y1+r1 >= Y:
                adj[u].append(len(circles))
                adj[len(circles)].append(u)
            if x1+r1 >= X or y1-r1 <= 0:
                adj[u].append(len(circles)+1)
                adj[len(circles)+1].append(u)
            for v in range(u):
                x2, y2, r2 = circles[v]
                if not check(x1, y1, r1, x2, y2, r2):
                    continue
                adj[u].append(v)
                adj[v].append(u)
        return not iter_dfs(len(circles), len(circles)+1)


",n^2
"
class Solution4(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def bfs(src, dst):
            lookup = [False]*len(adj)
            lookup[src] = True
            q = [src]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return lookup[dst]

        adj = [[] for _ in range(len(circles)+2)]
        for u in range(len(circles)):
            x1, y1, r1 = circles[u]
            if x1-r1 <= 0 or y1+r1 >= Y:
                adj[u].append(len(circles))
                adj[len(circles)].append(u)
            if x1+r1 >= X or y1-r1 <= 0:
                adj[u].append(len(circles)+1)
                adj[len(circles)+1].append(u)
            for v in range(u):
                x2, y2, r2 = circles[v]
                if not check(x1, y1, r1, x2, y2, r2):
                    continue
                adj[u].append(v)
                adj[v].append(u)
        return not bfs(len(circles), len(circles)+1)


",n^2
"
class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True


class Solution5(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        uf = UnionFind(len(circles)+2)
        for u in range(len(circles)):
            x1, y1, r1 = circles[u]
            if x1-r1 <= 0 or y1+r1 >= Y:
                uf.union_set(u, len(circles))
            if x1+r1 >= X or y1-r1 <= 0:
                uf.union_set(u, len(circles)+1)
            for v in range(u):
                x2, y2, r2 = circles[v]
                if not check(x1, y1, r1, x2, y2, r2):
                    continue
                uf.union_set(u, v)
        return uf.find_set(len(circles)) != uf.find_set(len(circles)+1)
",n^2
"
import bisect


class Solution(object):
    def findTheDistanceValue(self, arr1, arr2, d):
        arr2.sort()
        result, i, j = 0, 0, 0
        for x in arr1:
            j = bisect.bisect_left(arr2, x)
            left = arr2[j-1] if j-1 >= 0 else float(""-inf"")
            right = arr2[j] if j < len(arr2) else float(""inf"")
            result += left+d < x < right-d
        return result


",(n + m) * logm
"class Solution2(object):
    def findTheDistanceValue(self, arr1, arr2, d):
        arr1.sort(), arr2.sort()
        result, i, j = 0, 0, 0
        while i < len(arr1) and j < len(arr2):
            if arr1[i]-arr2[j] > d:
                j += 1
                continue
            result += arr2[j]-arr1[i] > d
            i += 1
        return result+len(arr1)-i
",nlogn + mlogm
"
class Solution(object):
    def isPalindrome(self, x):
        if x < 0:
            return False
        copy, reverse = x, 0

        while copy:
            reverse *= 10
            reverse += copy % 10
            copy //= 10

        return x == reverse

",1
"

class Solution(object):
    def maximumMatchingIndices(self, nums1, nums2):
        return max(sum(nums2[j] == nums1[(i+j)%len(nums1)] for j in range(len(nums2))) for i in range(len(nums1)))
",n^2
"
class Solution(object):
    def strongPasswordChecker(self, s):
        missing_type_cnt = 3
        if any('a' <= c <= 'z' for c in s):
            missing_type_cnt -= 1
        if any('A' <= c <= 'Z' for c in s):
            missing_type_cnt -= 1
        if any(c.isdigit() for c in s):
            missing_type_cnt -= 1

        total_change_cnt = 0
        one_change_cnt, two_change_cnt, three_change_cnt = 0, 0, 0
        i = 2
        while i < len(s):
            if s[i] == s[i-1] == s[i-2]:
                length = 2
                while i < len(s) and s[i] == s[i-1]:
                    length += 1
                    i += 1

                total_change_cnt += length / 3
                if length % 3 == 0:
                    one_change_cnt += 1
                elif length % 3 == 1:
                    two_change_cnt += 1
                else:
                    three_change_cnt += 1
            else:
                i += 1

        if len(s) < 6:
            return max(missing_type_cnt, 6 - len(s))
        elif len(s) <= 20:
            return max(missing_type_cnt, total_change_cnt)
        else:
            delete_cnt = len(s) - 20

            total_change_cnt -= min(delete_cnt, one_change_cnt * 1) / 1
            total_change_cnt -= min(max(delete_cnt - one_change_cnt, 0), two_change_cnt * 2) / 2
            total_change_cnt -= min(max(delete_cnt - one_change_cnt - 2 * two_change_cnt, 0), three_change_cnt * 3) / 3

            return delete_cnt + max(missing_type_cnt, total_change_cnt)

",n
"

class Solution(object):
    def getLargestOutlier(self, nums):
        result = float(""-inf"")
        total = sum(nums)
        cnt = collections.defaultdict(int)
        for x in nums:
            cnt[x] += 1
        for x in nums:
            if (total-x)%2:
                continue
            target = (total-x)//2
            if target in cnt and (cnt[target]-int(target == x) >= 1):
                result = max(result, x)
        return result
",n
"
import itertools


class Solution(object):
    def maxSumRangeQuery(self, nums, requests):
        def addmod(a, b, mod): 
            a %= mod
            b %= mod
            if mod-a <= b:
                b -= mod
            return a+b
        
        def mulmod(a, b, mod): 
            a %= mod
            b %= mod
            if a < b:
                a, b = b, a
            result = 0
            while b > 0:
                if b%2 == 1:
                    result = addmod(result, a, mod)
                a = addmod(a, a, mod)
                b //= 2
            return result

        MOD = 10**9+7

        count = [0]*len(nums)
        for start, end in requests:
            count[start] += 1
            if end+1 < len(count):
                count[end+1] -= 1
        for i in range(1, len(count)):
            count[i] += count[i-1]
        nums.sort()
        count.sort()
        result = 0
        for i, (num, c) in enumerate(zip(nums, count)):
            result = (result+num*c)%MOD
        return result
",nlogn
"
class Solution(object):
    def checkIfExist(self, arr):
        lookup = set()
        for x in arr:
            if 2*x in lookup or \
               (x%2 == 0 and x//2 in lookup):
                return True
            lookup.add(x)
        return False
",n
"

class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def nextLargerNodes(self, head):
        result, stk = [], []
        while head:
            while stk and stk[-1][1] < head.val:
                result[stk.pop()[0]] = head.val
            stk.append([len(result), head.val])
            result.append(0)
            head = head.__next__
        return result
",n
"
class Solution(object):

    def encode(self, strs):
        encoded_str = """"
        for s in strs:
            encoded_str += ""%0*x"" % (8, len(s)) + s
        return encoded_str


    def decode(self, s):
        i = 0
        strs = []
        while i < len(s):
            l = int(s[i:i+8], 16)
            strs.append(s[i+8:i+8+l])
            i += 8+l
        return strs

",n
"

class Solution(object):
    def shortestBeautifulSubstring(self, s, k):
        def check(r1, r2):
            if r1[1]-r1[0]+1 > r2[1]-r2[0]+1:
                return False
            if r1[1]-r1[0]+1 < r2[1]-r2[0]+1:
                return True
            for i, j in zip(range(r1[0], r1[1]+1), range(r2[0], r2[1]+1)):
                if s[i] != s[j]:
                    return s[i] < s[j]
            return False
    
        result = []
        left = curr = 0
        for right in range(len(s)):
            curr += s[right] == '1'
            while curr == k+1:
                curr -= s[left] == '1'
                left += 1
            while left < len(s) and s[left] == '0':
                left += 1
            if curr == k:
                if not result or check([left, right], result):
                    result = [left, right]
        return s[result[0]:result[1]+1] if result else """"
",n^2
"
class Solution(object):
    def minPatches(self, nums, n):
        result = reachable = 0
        for x in nums:
            if x > n:
                break
            while not reachable >= x-1:
                result += 1
                reachable += reachable+1
            reachable += x
        while not reachable >= n:
            result += 1
            reachable += reachable+1
        return result


",s + logn
"class Solution2(object):
    def minPatches(self, nums, n):
        result = reachable = 0
        for x in nums:
            while not reachable >= x-1:
                result += 1
                reachable += reachable+1
                if reachable >= n:
                    return result
            reachable += x
            if reachable >= n:
                return result
        while not reachable >= n:
            result += 1
            reachable += reachable+1
        return result


",s + logn
"class Solution3(object):
    def minPatches(self, nums, n):
        patch, miss, i = 0, 1, 0
        while miss <= n:
            if i < len(nums) and nums[i] <= miss:
                miss += nums[i]
                i += 1
            else:
                miss += miss
                patch += 1

        return patch

",s + logn
"
class Solution(object):
    def isHappy(self, n):
        lookup = {}
        while n != 1 and n not in lookup:
            lookup[n] = True
            n = self.nextNumber(n)
        return n == 1

    def nextNumber(self, n):
        new = 0
        for char in str(n):
            new += int(char)**2
        return new

",k
"

class Solution(object):
    def maxPalindromes(self, s, k):
        result = prev = 0
        for mid in range(2*len(s)-1):
            left, right = mid//2, mid//2+mid%2
            while left >= prev and right < len(s) and s[left] == s[right]:
                if right-left+1 >= k:
                    prev = right+1
                    result += 1
                    break
                left, right = left-1, right+1
        return result
",n * k
"

class Solution(object):
    def alternatingSubarray(self, nums):
        result = l = -1
        for i in range(len(nums)-1):
            if l != -1 and nums[i-1] == nums[i+1]:
                l += 1
            else:
                l = 2 if nums[i+1]-nums[i] == 1 else -1
            result = max(result, l)
        return result
",n
"
class TrieNode(object):
    def __init__(self):
        self.is_string = False
        self.leaves = {}


class Solution(object):

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        cur = self.root
        for c in word:
            if not c in cur.leaves:
                cur.leaves[c] = TrieNode()
            cur = cur.leaves[c]
        cur.is_string = True

    def search(self, word):
        node = self.childSearch(word)
        if node:
            return node.is_string
        return False

    def startsWith(self, prefix):
        return self.childSearch(prefix) is not None

    def childSearch(self, word):
        cur = self.root
        for c in word:
            if c in cur.leaves:
                cur = cur.leaves[c]
            else:
                return None
        return cur


",n
"

class Solution(object):
    def divideString(self, s, k, fill):
        return [s[i:i+k] + fill*(i+k-len(s)) for i in range(0, len(s), k)]
",n
"

class Solution(object):
    def maxRepeating(self, sequence, word):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if len(sequence) < len(word):
            return 0

        prefix = getPrefix(word)
        result, count, j, prev = 0, 0, -1, -1
        for i in range(len(sequence)):
            while j > -1 and word[j+1] != sequence[i]:
                j = prefix[j]
            if word[j+1] == sequence[i]:
                j += 1
            if j+1 == len(word):     
                count = count+1 if i-prev == len(word) else 1
                result = max(result, count)
                j, prev = -1, i
        return result


",n
"
class Solution2(object):
    def maxRepeating(self, sequence, word):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if len(sequence) < len(word):
            return 0

        new_word = word*(len(sequence)//len(word))
        prefix = getPrefix(new_word)
        result, j = 0, -1
        for i in range(len(sequence)):
            while j > -1 and new_word[j+1] != sequence[i]:
                j = prefix[j]
            if new_word[j+1] == sequence[i]:
                j += 1
            result = max(result, j+1)
            if j+1 == len(new_word):     
                break
        return result//len(word)
",n
"
class Solution(object):
    def findCircleNum(self, M):
        class UnionFind(object):
            def __init__(self, n):
                self.set = list(range(n))
                self.count = n

            def find_set(self, x):
               if self.set[x] != x:
                   self.set[x] = self.find_set(self.set[x]) 
               return self.set[x]

            def union_set(self, x, y):
                x_root, y_root = list(map(self.find_set, (x, y)))
                if x_root != y_root:
                    self.set[min(x_root, y_root)] = max(x_root, y_root)
                    self.count -= 1

        circles = UnionFind(len(M))
        for i in range(len(M)):
            for j in range(len(M)):
                if M[i][j] and i != j:
                    circles.union_set(i, j)
        return circles.count


",n^2
"
import itertools



class Solution(object):
    def minOperations(self, nums1, nums2, k):
        cnt1 = cnt2 = 0
        for x, y in zip(nums1, nums2):
            if y == x:
                continue
            if k == 0 or (y-x)%k:
                return -1
            if x < y:
                cnt1 += (y-x)//k
            else:
                cnt2 += (x-y)//k
        return cnt1 if cnt1 == cnt2 else -1
",n
"

class Solution(object):
    def scoreOfParentheses(self, S):
        result, depth = 0, 0
        for i in range(len(S)):
            if S[i] == '(':
                depth += 1
            else:
                depth -= 1
                if S[i-1] == '(':
                    result += 2**depth
        return result


",n
"class Solution2(object):
    def scoreOfParentheses(self, S):
        stack = [0]
        for c in S:
            if c == '(':
                stack.append(0)
            else:
                last = stack.pop()
                stack[-1] += max(1, 2*last)
        return stack[0]

",n
"
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def reverseEvenLengthGroups(self, head):
        prev, l = head, 2
        while prev.__next__:
            curr, cnt = prev, 0
            for _ in range(l):
                if not curr.__next__:
                    break
                cnt += 1
                curr = curr.__next__
            l += 1
            if cnt%2:
                prev = curr
                continue
            curr, last = prev.__next__, None
            for _ in range(cnt):
                curr.next, curr, last = last, curr.next, curr
            prev.next.next, prev.next, prev = curr, last, prev.next
        return head
",n
"
class Solution(object):
    def constructArray(self, n, k):
        result = []
        left, right = 1, n
        while left <= right:
            if k % 2:
                result.append(left)
                left += 1
            else:
                result.append(right)
                right -= 1
            if k > 1:
                k -= 1
        return result

",n
"

class Solution(object):
    def countMatchingSubarrays(self, nums, pattern):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i, x in enumerate(text):
                while j+1 > 0 and pattern[j+1] != x:
                    j = prefix[j]
                if pattern[j+1] == x:
                    j += 1
                if j+1 == len(pattern):
                    yield i-j
                    j = prefix[j]

        return sum(1 for _ in KMP((cmp(nums[i+1], nums[i]) for i in range(len(nums)-1)), pattern))
",n
"
class Solution(object):
    def matrixBlockSum(self, mat, K):
        m, n = len(mat), len(mat[0])
        accu = [[0 for _ in range(n+1)] for _ in range(m+1)]
        for i in range(m):
            for j in range(n):
                accu[i+1][j+1] = accu[i+1][j]+accu[i][j+1]-accu[i][j]+mat[i][j]
        result = [[0 for _ in range(n)] for _ in range(m)]        
        for i in range(m):
            for j in range(n):
                r1, c1, r2, c2 = max(i-K, 0), max(j-K, 0), min(i+K+1, m), min(j+K+1, n)
                result[i][j] = accu[r2][c2]-accu[r1][c2]-accu[r2][c1]+accu[r1][c1]
        return result
",m * n
"
import random


class Solution(object):
    def kthLargestValue(self, matrix, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
        
        
        vals = []
        for r in range(len(matrix)):
            curr = 0
            for c in range(len(matrix[0])):
                curr = curr^matrix[r][c]
                if r == 0:
                    matrix[r][c] = curr
                else:
                    matrix[r][c] = curr^matrix[r-1][c]
                vals.append(matrix[r][c])
        nth_element(vals, k-1, compare=lambda a, b: a > b)
        return vals[k-1]
",m * n
"
class Solution(object):
    def countPoints(self, points, queries):
        result = []
        for i, j, r in queries:
            result.append(0)
            for x, y in points:
                if (x-i)**2+(y-j)**2 <= r**2:
                    result[-1] += 1
        return result
",q * n
"

class Solution(object):
    def minimumIndex(self, nums):
        def boyer_moore_majority_vote():
            result, cnt = None, 0
            for x in nums:
                if not cnt:
                    result = x
                if x == result:
                    cnt += 1
                else:
                    cnt -= 1
            return result
        
        m = boyer_moore_majority_vote()
        total, cnt = nums.count(m), 0
        for i, x in enumerate(nums):
            if x == m:
                cnt += 1
            if cnt*2 > i+1 and (total-cnt)*2 > len(nums)-(i+1):
                return i
        return -1
",n
"

class Solution(object):
    def maximumXOR(self, nums):
        return reduce(lambda x, y: x|y, nums)
",n
"

class Solution(object):
    def longestPalindromicSubsequence(self, s, k):
        dp = [[[1 if i == j else 0 for _ in range(k+1)] for j in range(len(s))] for i in range(len(s))]
        for i in reversed(range(len(s)-1)):
            for j in range(i+1, len(s)):
                for x in range(k+1):
                    if s[i] == s[j]:
                        dp[i][j][x] = dp[i+1][j-1][x]+2
                    else:
                        dp[i][j][x] = max(dp[i+1][j][x], dp[i][j-1][x])
                        diff = abs(ord(s[i])-ord(s[j]))
                        c = min(diff, 26-diff)
                        if x >= c:
                            dp[i][j][x] = max(dp[i][j][x], dp[i+1][j-1][x-c]+2)
        return dp[0][-1][k]
",n^2 * k
"

class Solution(object):
    def maxKilledEnemies(self, grid):
        result = 0
        if not grid or not grid[0]:
            return result

        down = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]
        right = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]
        for i in reversed(range(len(grid))):
            for j in reversed(range(len(grid[0]))):
                if grid[i][j] != 'W':
                    if i + 1 < len(grid):
                        down[i][j] = down[i + 1][j]
                    if j + 1 < len(grid[0]):
                        right[i][j] = right[i][j + 1]
                    if grid[i][j] == 'E':
                        down[i][j] += 1
                        right[i][j] += 1

        up = [0 for _ in range(len(grid[0]))]
        for i in range(len(grid)):
            left = 0
            for j in range(len(grid[0])):
                if grid[i][j] == 'W':
                    up[j], left = 0, 0
                elif grid[i][j] == 'E':
                    up[j] += 1
                    left += 1
                else:
                    result = max(result,
                                 left + up[j] + right[i][j] + down[i][j])

        return result

",m * n
"
class Solution(object):
    def convertToTitle(self, n):
        result = []
        while n:
            result += chr((n-1)%26 + ord('A'))
            n = (n-1)//26
        result.reverse()
        return """".join(result)

",logn
"
import collections



class Solution(object):
    def minimumOperationsToMakeKPeriodic(self, word, k):
        cnt = collections.Counter(word[i:i+k]for i in range(0, len(word), k))
        return len(word)//k-max(cnt.values())
",n
"


import itertools
import operator


class Solution(object):
    def minProductSum(self, nums1, nums2):
        def inner_product(vec1, vec2):
            return sum(map(operator.mul, vec1, vec2))


        nums1.sort()
        nums2.sort(reverse=True)
        return inner_product(nums1, nums2)
",nlogn
"

class Solution(object):
    def minMovesToCaptureTheQueen(self, a, b, c, d, e, f):
        if a == e and not (a == c and (b-d)*(f-d) < 0):
            return 1
        if b == f and not (b == d and (a-c)*(e-c) < 0):
            return 1
        if c+d == e+f and not (c+d == a+b and (c-a)*(e-a) < 0):
            return 1
        if c-d == e-f and not (c-d == a-b and (d-b)*(f-b) < 0):
            return 1
        return 2
",1
"
import collections


class Solution(object):
    def subarraysWithMoreZerosThanOnes(self, nums):
        MOD = 10**9+7

        lookup = collections.defaultdict(int)
        lookup[0] = 1
        result = total = same = more = 0
        for x in nums:
            total += 1 if x == 1 else -1
            new_same = lookup[total]
            new_more = (same+more+1)%MOD if x == 1 else (more-new_same)%MOD
            lookup[total] += 1
            result = (result+new_more)%MOD
            same, more = new_same, new_more
        return result


",n
"class Solution2(object):
    def subarraysWithMoreZerosThanOnes(self, nums):
        MOD = 10**9+7

        lookup = {0:-1}
        dp = [0]*len(nums)
        result = total = 0
        for i, x in enumerate(nums):
            total += 1 if x == 1 else -1
            if total not in lookup:
                if total > 0:
                    dp[i] = i+1
            else:
                j = lookup[total]
                if j != -1:
                    dp[i] = dp[j]
                if x > 0:
                    dp[i] += (i-1)-j
            lookup[total] = i
            result = (result+dp[i])%MOD
        return result
",n
"

class Solution(object):
    def sumIndicesWithKSetBits(self, nums, k):
        def next_popcount(n): 
            lowest_bit = n&-n
            left_bits = n+lowest_bit
            changed_bits = n^left_bits
            right_bits = (changed_bits//lowest_bit)>>2
            return left_bits|right_bits

        result = 0 
        i = (1<<k)-1
        while i < len(nums):
            result += nums[i]
            if i == 0:
                break
            i = next_popcount(i)
        return result


","C(ceil(log2(n)), k)"
"
class Solution2(object):
    def sumIndicesWithKSetBits(self, nums, k):
        def popcount(x):
            return bin(x)[1:].count('1')
        
        return sum(x for i, x in enumerate(nums) if popcount(i) == k)
",n
"

class Solution(object):
    def maximumLength(self, nums, k):
        result = 0
        for i in range(k):
            dp = [0]*k
            for x in nums:
                dp[x%k] = dp[(i-x)%k]+1
            result = max(result, max(dp))
        return result
",n * k
"
class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None


class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

    def find(self, key):
        curr = self.head
        while curr:
            if curr.key == key:
                break
            curr = curr.__next__
        return curr


class Solution(object):

    def __init__(self):
        self.__data = [LinkedList() for _ in range(10000)]

    def put(self, key, value):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            node.val = value
        else:
            l.insert(ListNode(key, value))

    def get(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            return node.val
        else:
            return -1

    def remove(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            l.delete(node)



",1
"

class Solution(object):
    def countCompleteComponents(self, n, edges):
        def bfs(u):
            if lookup[u]:
                return False
            v_cnt = e_cnt = 0
            lookup[u] = True
            q = [u]
            while q:
                new_q = []
                v_cnt += len(q)
                for u in q:
                    e_cnt += len(adj[u])
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return v_cnt*(v_cnt-1) == e_cnt

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        lookup = [False]*n
        return sum(bfs(u) for u in range(n) if not lookup[u])
",n
"

class Solution(object):
    def partitionString(self, s):
        result, left = 1, 0
        lookup = {}
        for i, x in enumerate(s):
            if x in lookup and lookup[x] >= left:
                left = i
                result += 1
            lookup[x] = i
        return result
",n
"
import collections



class Solution(object):
    def canFinish(self, numCourses, prerequisites):
        adj = collections.defaultdict(list)
        in_degree = collections.Counter()
        for u, v in prerequisites:
            in_degree[u] += 1
            adj[v].append(u)
        result = []
        q = [u for u in range(numCourses) if u not in in_degree]
        while q:
            new_q = []
            for u in q:
                result.append(u)
                for v in adj[u]:
                    in_degree[v] -= 1
                    if in_degree[v] == 0:
                        new_q.append(v)
            q = new_q
        return len(result) == numCourses


",|V| + |E|
"import collections



class Solution2(object):
    def canFinish(self, numCourses, prerequisites):
        adj = collections.defaultdict(list)
        in_degree = collections.Counter()
        for u, v in prerequisites:
            in_degree[u] += 1
            adj[v].append(u)
        result = []
        stk = [u for u in range(numCourses) if u not in in_degree]
        while stk:
            u = stk.pop()
            result.append(u)
            for v in adj[u]:
                in_degree[v] -= 1
                if in_degree[v] == 0:
                    stk.append(v)
        return len(result) == numCourses
",|V| + |E|
"

class Solution(object):
    def minLength(self, s, numOps):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def lengths():
            cnt = 0
            for i in range(len(s)):
                cnt += 1
                if i+1 == len(s) or s[i+1] != s[i]:
                    yield cnt
                    cnt = 0
    
        def check(x):
            if x == 1:
                cnt = sum(int(x) != i%2 for i, x in enumerate(s))
                return min(cnt, len(s)-cnt) <= numOps
            return sum(l//(x+1) for l in lengths()) <= numOps
    
        return binary_search(1, len(s), check)


",nlogn
"
class Solution2(object):
    def minLength(self, s, numOps):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(x):
            if x == 1:
                cnt = sum(int(x) != i%2 for i, x in enumerate(s))
                return min(cnt, len(s)-cnt) <= numOps
            return sum(l//(x+1) for l in arr) <= numOps
    
        arr = []
        cnt = 0
        for i in range(len(s)):
            cnt += 1
            if i+1 == len(s) or s[i+1] != s[i]:
                arr.append(cnt)
                cnt = 0
        return binary_search(1, len(s), check)
",nlogn
"
class Solution(object):
    def singleNonDuplicate(self, nums):
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right - left) / 2
            if not (mid%2 == 0 and mid+1 < len(nums) and \
                    nums[mid] == nums[mid+1]) and \
               not (mid%2 == 1 and nums[mid] == nums[mid-1]):
                right = mid-1
            else:
                left = mid+1
        return nums[left]

",logn
"

class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def nodesBetweenCriticalPoints(self, head):
        first = last = -1
        result = float(""inf"")
        i, prev, head = 0, head.val, head.__next__
        while head.__next__:
            if max(prev, head.next.val) < head.val or min(prev, head.next.val) > head.val:
                if first == -1:
                    first = i
                if last != -1:
                    result = min(result, i-last)
                last = i
            i += 1
            prev = head.val
            head = head.__next__
        return [result, last-first] if last != first else [-1, -1]
",n
"
import collections



class Solution(object):
    def beautifulSubstrings(self, s, k):
        VOWELS = set(""aeiou"")
        prefix = [0]*(len(s)+1)
        for i in range(len(s)):
            prefix[i+1] = prefix[i]+(+1 if s[i] in VOWELS else -1)
        new_k = 1
        x = k
        for i in range(2, k+1):
            if i*i > k:
                break
            cnt = 0
            while x%i == 0:
                x //= i
                cnt += 1
            if cnt:
                new_k *= i**((cnt+1)//2+int(i == 2))
        if x != 1:
            new_k *= x**((1+1)//2+int(x == 2))
        cnt = collections.Counter()
        result = 0
        for i, p in enumerate(prefix):
            result += cnt[p, i%new_k]
            cnt[p, i%new_k] += 1
        return result
",n + sqrt(k)
"
class Solution(object):
    def queensAttacktheKing(self, queens, king):
        dirctions = [(-1, 0), (0, 1), (1, 0), (0, -1),
                     (-1, 1), (1, 1), (1, -1), (-1, -1)]
        result = []
        lookup = {(i, j) for i, j in queens}
        for dx, dy in dirctions:
            for i in range(1, 8):
                x, y = king[0] + dx*i, king[1] + dy*i
                if (x, y) in lookup:
                    result.append([x, y])
                    break
        return result
",1
"
import itertools
import heapq


class Solution(object):
    def mincostToHireWorkers(self, quality, wage, K):
        result, qsum = float(""inf""), 0
        max_heap = []
        for r, q in sorted([float(w)/q, q] for w, q in zip(wage, quality)):
            qsum += q
            heapq.heappush(max_heap, -q)
            if len(max_heap) > K:
                qsum -= -heapq.heappop(max_heap)
            if len(max_heap) == K:
                result = min(result, qsum*r)
        return result

",nlogn
"

class Solution(object):
    def rowAndMaximumOnes(self, mat):
        return max(([i, mat[i].count(1)] for i in range(len(mat))), key=lambda x: x[1])
",m * n
"
import collections



class Solution(object):
    def maximumLength(self, nums, k):
        lookup = {x:i for i, x in enumerate(set(nums))}
        dp = [[0]*len(lookup) for _ in range(k+1)]
        result = [0]*(k+1)
        for x in nums:
            x = lookup[x]
            for i in reversed(range(k+1)):
                dp[i][x] = max(dp[i][x], result[i-1] if i-1 >= 0 else 0)+1
                result[i] = max(result[i], dp[i][x])
        return result[k]


",n * k
"import collections



class Solution2(object):
    def maximumLength(self, nums, k):
        dp = [collections.defaultdict(int) for _ in range(k+1)]
        result = [0]*(k+1)
        for x in nums:
            for i in reversed(range(k+1)):
                dp[i][x] = max(dp[i][x], result[i-1] if i-1 >= 0 else 0)+1
                result[i] = max(result[i], dp[i][x])
        return result[k]


",n * k
"
class Solution(object):
    def maximumLength(self, nums, k):
        dp = [[0]*(k+1) for _ in range(len(nums))]
        result = 0
        for i in range(len(nums)):
            dp[i][0] = 1
            for l in range(k+1):
                for j in range(i):
                    dp[i][l] = max(dp[i][l], dp[j][l]+1 if nums[j] == nums[i] else 1, dp[j][l-1]+1 if l-1 >= 0 else 1)
                result = max(result, dp[i][l])
        return result
",n^2 * k
"

class Solution(object):
    def tourOfKnight(self, m, n, r, c):
        DIRECTIONS = ((1, 2), (-1, 2), (1, -2), (-1, -2),
                      (2, 1), (-2, 1), (2, -1), (-2, -1))
        def backtracking(r, c, i):
            def degree(x):
                cnt = 0
                r, c = x
                for dr, dc in DIRECTIONS:
                    nr, nc = r+dr, c+dc
                    if 0 <= nr < m and 0 <= nc < n and result[nr][nc] == -1:
                        cnt += 1
                return cnt

            if i == m*n:
                return True
            candidates = []
            for dr, dc in DIRECTIONS:
                nr, nc = r+dr, c+dc
                if 0 <= nr < m and 0 <= nc < n and result[nr][nc] == -1:
                    candidates.append((nr, nc))
            for nr, nc in sorted(candidates, key=degree): 
                result[nr][nc] = i
                if backtracking(nr, nc, i+1):
                    return True
                result[nr][nc] = -1
            return False
    
        result = [[-1]*n for _ in range(m)]
        result[r][c] = 0
        backtracking(r, c, 1)
        return result


",m * n
"
class Solution2(object):
    def tourOfKnight(self, m, n, r, c):
        DIRECTIONS = ((1, 2), (-1, 2), (1, -2), (-1, -2),
                      (2, 1), (-2, 1), (2, -1), (-2, -1))
        def backtracking(r, c, i):
            if i == m*n:
                return True
            for dr, dc in DIRECTIONS:
                nr, nc = r+dr, c+dc
                if not (0 <= nr < m and 0 <= nc < n and result[nr][nc] == -1):
                    continue
                result[nr][nc] = i
                if backtracking(nr, nc, i+1):
                    return True
                result[nr][nc] = -1
            return False
    
        result = [[-1]*n for _ in range(m)]
        result[r][c] = 0
        backtracking(r, c, 1)
        return result
",8^(m * n - 1)
"

class Solution(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        result = right = gap = 0
        for left, (l, _) in enumerate(tiles):
            if left-1 >= 0:
                gap -= tiles[left][0]-tiles[left-1][1]-1
            r = l+carpetLen-1
            while right+1 < len(tiles) and r+1 >= tiles[right+1][0]:
                right += 1
                gap += tiles[right][0]-tiles[right-1][1]-1
            result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap)
        return result


",nlogn
"
class Solution2(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        result = left = gap = 0
        for right in range(len(tiles)):
            if right-1 >= 0:
                gap += tiles[right][0]-tiles[right-1][1]-1
            l = tiles[right][1]-carpetLen+1
            while not (tiles[left][1]+1 >= l):
                left += 1
                gap -= tiles[left][0]-tiles[left-1][1]-1
            result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap)
        return result


",nlogn
"import bisect



class Solution3(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        prefix = [0]*(len(tiles)+1)
        for i, (l, r) in enumerate(tiles):
            prefix[i+1] = prefix[i]+(r-l+1)
        result = 0
        for left, (l, _) in enumerate(tiles):
            r = l+carpetLen-1
            right = bisect.bisect_right(tiles, [r+1])-1
            extra = max(tiles[right][1]-r, 0)
            result = max(result, (prefix[right+1]-prefix[left])-extra)
        return result


",nlogn
"import bisect



class Solution4(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        prefix = [0]*(len(tiles)+1)
        for i, (l, r) in enumerate(tiles):
            prefix[i+1] = prefix[i]+(r-l+1)
        result = 0
        for right, (_, r) in enumerate(tiles):
            l = r-carpetLen+1
            left = bisect.bisect_right(tiles, [l])
            if left-1 >= 0 and tiles[left-1][1]+1 >= l:
                left -= 1
            extra = max(l-tiles[left][0], 0)
            result = max(result, (prefix[right+1]-prefix[left])-extra)
        return result
",nlogn
"
import collections


class Solution(object):
    def groupAnagrams(self, strs):
        anagrams_map, result = collections.defaultdict(list), []
        for s in strs:
            sorted_str = ("""").join(sorted(s))
            anagrams_map[sorted_str].append(s)
        for anagram in list(anagrams_map.values()):
            anagram.sort()
            result.append(anagram)
        return result


",n * glogg
"
class Solution(object):
    def maxUncrossedLines(self, A, B):
        if len(A) < len(B):
            return self.maxUncrossedLines(B, A)

        dp = [[0 for _ in range(len(B)+1)] for _ in range(2)]
        for i in range(len(A)):
            for j in range(len(B)):
                dp[(i+1)%2][j+1] = max(dp[i%2][j] + int(A[i] == B[j]),
                                       dp[i%2][j+1],
                                       dp[(i+1)%2][j])
        return dp[len(A)%2][len(B)]
",m * n
"
class Solution(object):
    def letterCasePermutation(self, S):
        result = [[]]
        for c in S:
            if c.isalpha():
                for i in range(len(result)):
                    result.append(result[i][:])
                    result[i].append(c.lower())
                    result[-1].append(c.upper())
            else:
                for s in result:
                    s.append(c)
        return list(map("""".join, result))

",n * 2^n
"

class Solution(object):
    def minDamage(self, power, damage, health):
        def ceil_divide(a, b):
            return (a+b-1)//b
        
        idxs = list(range(len(health)))
        idxs.sort(key=lambda i: float(ceil_divide(health[i], power))/damage[i])
        result = t = 0
        for i in idxs:
            t += ceil_divide(health[i], power)
            result += t*damage[i]
        return result
",nlogn
"
class Solution(object):
    def canThreePartsEqualSum(self, A):
        total = sum(A)
        if total % 3 != 0:
            return False
        parts, curr = 0, 0
        for x in A:
            curr += x
            if curr == total//3:
                parts += 1
                curr = 0
        return parts >= 3
",n
"
class Solution(object):
    def getWinner(self, arr, k):
        result = arr[0]
        count = 0
        for i in range(1, len(arr)):
            if arr[i] > result:
                result = arr[i]
                count = 0
            count += 1
            if (count == k):
                break
        return result
",n
"

class Solution(object):
    def findArray(self, pref):
        for i in reversed(range(1, len(pref))):
            pref[i] ^= pref[i-1]
        return pref
",n
"

class Solution(object):
    def separateSquares(self, squares):
        events = []
        for x, y, l in squares:
            events.append((y, 1, l))
            events.append((y+l, -1, l))
        events.sort(key=lambda e: e[0])
        total = curr = 0.0
        prev = events[0][0]
        for y, v, l in events:
            if y != prev:
                total += (y-prev)*curr
                prev = y
            curr += l*v
        expect = total/2.0
        total = curr = 0.0
        prev = events[0][0]
        for y, v, l in events:
            if y != prev:
                if total+(y-prev)*curr >= expect:
                    break
                total += (y-prev)*curr
                prev = y
            curr += l*v
        return prev+(expect-total)/curr


",nlogn
"
class Solution2(object):
    def separateSquares(self, squares):
        EPS = 1e-5
        def binary_search(left, right, check):
            while right-left > EPS:
                mid = left+(right-left)/2.0
                if check(mid):
                    right = mid
                else:
                    left = mid
            return left
    
        def check(k):
            result = 0
            for x, y, l in squares:
                if y >= k:
                    result += l**2
                elif y+l <= k:
                    result -= l**2
                else:
                    result += l*(((y+l)-k)-(k-y))
            return result <= 0
    
        return binary_search(min(y for _, y, _ in squares), max(y+l for _, y, l in squares), check)
",nlogr
"
import threading
import queue



   def getUrls(self, url):
       pass


class Solution(object):
    NUMBER_OF_WORKERS = 8
    
    def __init__(self):
        self.__cv = threading.Condition()
        self.__q = queue.Queue()

    def crawl(self, startUrl, htmlParser):
        SCHEME = ""http://""
        def hostname(url):
            pos = url.find('/', len(SCHEME))
            if pos == -1:
                return url
            return url[:pos]

        def worker(htmlParser, lookup):
            while True:
                from_url = self.__q.get()
                if from_url is None:
                    break
                name = hostname(from_url)
                for to_url in htmlParser.getUrls(from_url):
                    if name != hostname(to_url):
                        continue
                    with self.__cv:
                        if to_url not in lookup:
                           lookup.add(to_url)
                           self.__q.put(to_url)
                self.__q.task_done()

        workers = []
        self.__q = queue.Queue()
        self.__q.put(startUrl)
        lookup = set([startUrl])
        for i in range(self.NUMBER_OF_WORKERS):
            t = threading.Thread(target=worker, args=(htmlParser, lookup))
            t.start()
            workers.append(t)
        self.__q.join()
        for t in workers:
            self.__q.put(None)
        for t in workers:
            t.join()
        return list(lookup)


",|V| + |E|
"import threading
import collections


class Solution2(object):
    NUMBER_OF_WORKERS = 8
    
    def __init__(self):
        self.__cv = threading.Condition()
        self.__q = collections.deque()
        self.__working_count = 0

    def crawl(self, startUrl, htmlParser):
        SCHEME = ""http://""
        def hostname(url):
            pos = url.find('/', len(SCHEME))
            if pos == -1:
                return url
            return url[:pos]

        def worker(htmlParser, lookup):
            while True:
                with self.__cv:
                    while not self.__q:
                        self.__cv.wait()
                    from_url = self.__q.popleft()
                    if from_url is None:
                        break
                    self.__working_count += 1
                name = hostname(from_url)
                for to_url in htmlParser.getUrls(from_url):
                    if name != hostname(to_url):
                        continue
                    with self.__cv:
                        if to_url not in lookup:
                           lookup.add(to_url)
                           self.__q.append(to_url)
                           self.__cv.notifyAll()
                with self.__cv:
                    self.__working_count -= 1
                    if not self.__q and not self.__working_count:
                        self.__cv.notifyAll()

        workers = []
        self.__q = collections.deque([startUrl])
        lookup = set([startUrl])
        for i in range(self.NUMBER_OF_WORKERS):
            t = threading.Thread(target=worker, args=(htmlParser, lookup))
            t.start()
            workers.append(t)
        with self.__cv:
            while self.__q or self.__working_count:
                self.__cv.wait()
            for i in range(self.NUMBER_OF_WORKERS):
                self.__q.append(None)
            self.__cv.notifyAll()
        for t in workers:
            t.join()
        return list(lookup)
",|V| + |E|
"
class Solution(object):
    def longestValidParentheses(self, s):
        def length(it, start, c):
            depth, longest = 0, 0
            for i in it:
                if s[i] == c:
                    depth += 1
                else:
                    depth -= 1
                    if depth < 0:
                        start, depth = i, 0
                    elif depth == 0:
                        longest = max(longest, abs(i - start))
            return longest

        return max(length(range(len(s)), -1, '('), \
                   length(reversed(range(len(s))), len(s), ')'))


",n
"class Solution2(object):
    def longestValidParentheses(self, s):
        longest, last, indices = 0, -1, []
        for i in range(len(s)):
            if s[i] == '(':
                indices.append(i)
            elif not indices:
                last = i
            else:
                indices.pop()
                if not indices:
                    longest = max(longest, i - last)
                else:
                    longest = max(longest, i - indices[-1])
        return longest

",n
"
import collections



class Solution(object):
    def minimumKeypresses(self, s):
        return sum(cnt*(i//9+1) for i, cnt in enumerate(sorted(iter(collections.Counter(s).values()), reverse=True)))
",n
"

class Solution(object):
    def maxSubstringLength(self, s, k):
        def erase_overlap_intervals(intervals):
            intervals.sort(key=lambda interval: interval[1])
            result, right = 0, float(""-inf"")
            for l, r in intervals:
                if l <= right:
                    result += 1
                else:
                    right = r
            return result

        cnt = [0]*26
        lookup1, lookup2 = [-1]*26, [-1]*26
        for i, c in enumerate(s):
            cnt[ord(c)-ord('a')] += 1
            if lookup1[ord(c)-ord('a')] == -1:
                lookup1[ord(c)-ord('a')] = i
            lookup2[ord(c)-ord('a')] = i 
        intervals = []
        for i in lookup1:
            if i == -1:
                continue
            for j in lookup2:
                if j == -1 or i > j:
                    continue
                total = sum(cnt[c] for c in range(len(cnt)) if i <= lookup1[c] <= lookup2[c] <= j)
                if total == j-i+1 and total < len(s):
                    intervals.append((i, j))
        return len(intervals)-erase_overlap_intervals(intervals) >= k


",n + 26^3
"
class Solution2(object):
    def maxSubstringLength(self, s, k):
        def erase_overlap_intervals(intervals):
            intervals.sort(key=lambda interval: interval[1])
            result, right = 0, float(""-inf"")
            for l, r in intervals:
                if l <= right:
                    result += 1
                else:
                    right = r
            return result

        cnt = [0]*26
        lookup1, lookup2 = [-1]*26, [-1]*26
        for i, c in enumerate(s):
            cnt[ord(c)-ord('a')] += 1
            if lookup1[ord(c)-ord('a')] == -1:
                lookup1[ord(c)-ord('a')] = i
            lookup2[ord(c)-ord('a')] = i 
        intervals = []
        for i in range(len(s)):
            if i != lookup1[ord(s[i])-ord('a')]:
                continue
            x = i+1
            j = lookup2[ord(s[i])-ord('a')]
            while x <= j and lookup1[ord(s[x])-ord('a')] >= i:
                j = max(j, lookup2[ord(s[x])-ord('a')])
                x += 1
            if x == j+1 and (i != 0 or j != len(s)-1):
                intervals.append((i, j))
        return len(intervals)-erase_overlap_intervals(intervals) >= k
",26 * n + 26 * log(26)
"
class Solution(object):
    def smallestRangeI(self, A, K):
        return max(0, max(A) - min(A) - 2*K)

",n
"

class Node:
    def __init__(self, val):
        pass

class Solution(object):
    def lowestCommonAncestor(self, p, q):
        a, b = p, q
        while a != b:
            a = a.parent if a else q
            b = b.parent if b else p
        return a


",h
"class Solution2(object):
    def lowestCommonAncestor(self, p, q):
        def depth(node):
            d = 0
            while node:
                node = node.parent
                d += 1
            return d
        
        p_d, q_d = depth(p), depth(q)
        while p_d > q_d:
            p = p.parent
            p_d -= 1
        while p_d < q_d:
            q = q.parent
            q_d -= 1
        while p != q:
            p = p.parent
            q = q.parent
        return p
",h
"

class Solution(object):
    def makeIntegerBeautiful(self, n, target):
        total, m = 0, n
        while m:
            total += m%10
            m //= 10
        m, l = n, 0
        while total > target:
            while True:
                total -= m%10
                m //= 10
                l += 1
                if m%10 != 9:
                    break
            total += 1
            m += 1
        return m*10**l-n
",logn
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def partition(self, head, x):
        dummySmaller, dummyGreater = ListNode(-1), ListNode(-1)
        smaller, greater = dummySmaller, dummyGreater

        while head:
            if head.val < x:
                smaller.next = head
                smaller = smaller.__next__
            else:
                greater.next = head
                greater = greater.__next__
            head = head.__next__

        smaller.next = dummyGreater.__next__
        greater.next = None

        return dummySmaller.__next__

",n
"
import collections



class Solution(object):
    def longestEqualSubarray(self, nums, k):
        cnt = collections.Counter()
        result = left = 0
        for right in range(len(nums)):
            cnt[nums[right]] += 1
            result = max(result, cnt[nums[right]])
            if right-left+1 > result+k:
                cnt[nums[left]] -= 1
                left += 1
        return result
",n
"
class Solution(object):
    def minOperations(self, nums):
        result = prev = 0
        for curr in nums:
            if prev < curr:
                prev = curr
                continue
            prev += 1
            result += prev-curr                
        return result
",n
"
class Solution(object):
    def asteroidCollision(self, asteroids):
        result = []
        for x in asteroids:
            if x > 0:
                result.append(x)
                continue
            while result and 0 < result[-1] < -x:
                result.pop()
            if result and 0 < result[-1]:
                if result[-1] == -x:
                    result.pop()
                continue
            result.append(x)
        return result


",n
"class Solution2(object):
    def asteroidCollision(self, asteroids):
        result = []
        for x in asteroids:
            while result and x < 0 < result[-1]:
                if result[-1] < -x:
                    result.pop()
                    continue
                elif result[-1] == -x:
                    result.pop()
                break
            else:
                result.append(x)
        return result
",n
"

class Solution(object):
    def findPermutation(self, nums):
        INF = float(""inf"")
        n = len(nums)
        dp = [[(INF, -1) for _ in range(n-1)] for _ in range(1<<(n-1))]
        for i in range(n-1):
            dp[1<<i][i] = (abs((i+1)-nums[0]), -1)
        for mask in range(1<<(n-1)):
            for i in range(n-1):
                if mask&(1<<i) == 0:
                    continue
                for j in range(n-1):
                    if j == i or mask&(1<<j) == 0:
                        continue
                    dp[mask][i] = min(dp[mask][i], (dp[mask^(1<<i)][j][0]+abs((i+1)-nums[j+1]), j))
        _, i = min((dp[-1][i][0]+abs(0-nums[i+1]), i) for i in range(n-1))
        result = [0]
        mask = (1<<(n-1))-1
        while i != -1:
            result.append(i+1)
            mask, i = mask^(1<<i), dp[mask][i][1]
        return result
",(n-1)^2 * 2^(n-1)
"
import collections


class Solution(object):
    def numSplits(self, s):
        left_count, right_count = collections.Counter(), collections.Counter(s)
        result = 0
        for c in s:
            left_count[c] += 1
            right_count[c] -= 1
            if not right_count[c]:
                del right_count[c]
            if len(left_count) == len(right_count):
                result += 1
        return result
",n
"
class Solution(object):
    def checkRecord(self, s):
        count_A = 0
        for i in range(len(s)):
            if s[i] == 'A':
                count_A += 1
                if count_A == 2:
                    return False
            if i < len(s) - 2 and s[i] == s[i+1] == s[i+2] == 'L':
                return False
        return True


",n
"

class Solution(object):
    def minBitwiseArray(self, nums):
        return [x-(((x+1)&~x)>>1) if x&1 else -1 for x in nums]

",n
"
class Solution(object):
    def isValid(self, s):
        stack, lookup = [], {""("": "")"", ""{"": ""}"", ""["": ""]""}
        for parenthese in s:
            if parenthese in lookup:
                stack.append(parenthese)
            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:
                return False
        return len(stack) == 0

",n
"
import itertools



class Solution(object):
    def maxTrailingZeros(self, grid):
        def factor(x):
            cnt = [0]*2
            for i, p in enumerate([2, 5]):
                while x and x%p == 0:
                    x //= p
                    cnt[i] += 1
            return cnt

        def add(a, b):
            return [x+y for x, y in zip(a, b)]

        def sub(a, b):
            return [x-y for x, y in zip(a, b)]

        left = [[None for _ in range(len(grid[0]))] for _ in range(len(grid))]
        for i in range(len(grid)):
            left[i][0] = factor(grid[i][0])
            for j in range(1, len(grid[0])):
                left[i][j] = add(left[i][j-1], factor(grid[i][j]))
        result = 0
        for j in range(len(grid[0])):
            total = [0]*2
            for i in range(len(grid)):
                total = add(total, factor(grid[i][j]))
            up = [0]*2
            for i in range(len(grid)):
                right = sub(left[i][-1], left[i][j-1] if j else [0]*2)
                result = max(result, min(add(left[i][j], up)), min(add(right, up)))
                up = add(up, factor(grid[i][j]))
                down = sub(total, up)
                result = max(result, min(add(left[i][j], down)), min(add(right, down)))
        return result
",m * n
"

class Solution(object):
    def addSpaces(self, s, spaces):
        prev = len(s)
        s = list(s)
        s.extend([None]*len(spaces))
        for i in reversed(range(len(spaces))):
            for j in reversed(range(spaces[i], prev)):
                s[j+1+i] = s[j]
            s[spaces[i]+i] = ' '
            prev = spaces[i]
        return """".join(s)
",n
"

class Solution(object):
    def numberOfWays(self, startPos, endPos, k):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        r = k-abs(endPos-startPos)
        return nCr(k, r//2) if r >= 0 and r%2 == 0 else 0  
",k
"
class Solution(object):
    def waysToBuildRooms(self, prevRoom):
        MOD = 10**9+7
        fact = [1, 1]
        inv = [0, 1]
        inv_fact = [1, 1]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def dfs(adj, curr):
            total_ways, total_cnt = 1, 0
            for child in adj[curr]:
                ways, cnt = dfs(adj, child)
                total_cnt += cnt
                total_ways = (((total_ways*ways) % MOD)*nCr(total_cnt, cnt)) % MOD
            return total_ways, total_cnt+1

        adj = [[] for _ in range(len(prevRoom))]
        for i in range(1, len(prevRoom)):
            adj[prevRoom[i]].append(i)
        return dfs(adj, 0)[0]
",n
"

class Solution(object):
    def longestCycle(self, edges):
        result = -1
        lookup = [-1]*len(edges)
        idx = 0
        for i in range(len(edges)):
            if lookup[i] != -1:
                continue
            start = idx
            while i != -1:
                if lookup[i] != -1:
                    break
                lookup[i] = idx
                idx += 1
                i = edges[i]
            if i != -1 and lookup[i] >= start:
                result = max(result, idx-lookup[i])
        return result
",n
"
import collections



class Solution(object):
    def countPrefixSuffixPairs(self, words):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result = 0
        for w in words:
            curr = trie
            for i in range(len(w)):
                curr = curr[w[i], w[~i]]
                result += curr[""_cnt""] if ""_cnt"" in curr else 0
            curr[""_cnt""] = curr[""_cnt""]+1 if ""_cnt"" in curr else 1
        return result


",n * l
"
class Solution2(object):
    def countPrefixSuffixPairs(self, words):
        def check(i, j):
            return words[j].startswith(words[i]) and words[j].endswith(words[i])
    
        return sum(check(i, j) for i in range(len(words)) for j in range(i+1, len(words)))
",n^2 * l
"
class Solution(object):
    def validMountainArray(self, A):
        i = 0
        while i+1 < len(A) and A[i] < A[i+1]:
            i += 1
        j = len(A)-1
        while j-1 >= 0 and A[j-1] > A[j]:
            j -= 1
        return 0 < i == j < len(A)-1
",n
"

class Solution(object):
    def findProductsOfElements(self, queries):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + ((right-left)>>1)
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left
    
        def f(x):
            def count1(x):
                result = i = 0
                while 1<<i <= x:
                    mask = (1<<(i+1))-1
                    result += ((x&~mask)>>1)+max((x&mask)-(1<<i)+1, 0)
                    i += 1
                return result
 
            def count2(x):
                result = i = 0
                while 1<<i <= x:
                    mask = (1<<(i+1))-1
                    result += (((x&~mask)>>1)+max((x&mask)-(1<<i)+1, 0))*i
                    i += 1
                return result
            
            y = binary_search(1, x-1, lambda i: count1(i) >= x)
            result = count2(y-1)
            x -= count1(y-1)
            i = 0
            while 1<<i <= y:
                if y&(1<<i):
                    result += i
                    x -= 1
                    if x == 0:
                        break
                i += 1
            return result
        
        return [pow(2, f(right+1)-f(left), mod) for left, right, mod in queries]
",q * (logr)^2
"
class Solution(object):
    def minHeightShelves(self, books, shelf_width):
        dp = [float(""inf"") for _ in range(len(books)+1)]
        dp[0] = 0
        for i in range(1, len(books)+1):
            max_width = shelf_width
            max_height = 0
            for j in reversed(range(i)):
                if max_width-books[j][0] < 0:
                    break
                max_width -= books[j][0]
                max_height = max(max_height, books[j][1])
                dp[i] = min(dp[i], dp[j]+max_height)
        return dp[len(books)]
",n^2
"

class Solution(object):
    def unmarkedSumArray(self, nums, queries):
        total = sum(nums)
        lookup = [False]*len(nums)
        min_heap = [(x, i) for i, x in enumerate(nums)]
        heapq.heapify(min_heap)
        result = []
        for i, k in queries:
            if not lookup[i]:
                lookup[i] = True
                total -= nums[i]
            for _ in range(k):
                while min_heap:
                    x, i = heapq.heappop(min_heap)
                    if lookup[i]:
                        continue
                    lookup[i] = True
                    total -= x
                    break
                if not min_heap:
                    break
            result.append(total)
        return result
",q + nlogn
"

class Solution(object):
    def minCostToEqualizeArray(self, nums, cost1, cost2):
        MOD = 10**9+7

        n = len(nums)
        mx = max(nums)
        total = mx*n-sum(nums)

        if n <= 2 or cost1*2 <= cost2:
            return total*cost1%MOD
    
        result = float(""inf"")
        mn = min(nums)
        cnt1 = max((mx-mn)-(total-(mx-mn)), 0)
        cnt2 = total-cnt1
        result = min(result, (cnt1+cnt2%2)*cost1 + cnt2//2*cost2)

        x, cnt1 = divmod(cnt1, (n-2))
        total += n*x
        cnt2 = total-cnt1
        result = min(result, (cnt1+cnt2%2)*cost1 + (cnt2//2)*cost2)

        for _ in range(2): 
            total += n
            result = min(result, total%2*cost1 + total//2*cost2)
        return result%MOD
",n
"
class Solution(object):
    def maskPII(self, S):
        if '@' in S:
            first, after = S.split('@')
            return ""{}*****{}@{}"".format(first[0], first[-1], after).lower()

        digits = [x for x in S if x.isdigit()]
        local = ""***-***-{}"".format(digits[-4:])
        if len(digits) == 10:
            return local
        return ""+{}-{}"".format('*' * (len(digits) - 10), local)

",1
"

class Solution(object):
    def longestSubsequence(self, s, k):
        result, base = 0, 1
        for i in reversed(range(len(s))):
            if s[i] == '0':
                result += 1
            elif base <= k:
                k -= base
                result += 1
            if base <= k:
                base <<= 1
        return result
",n
"
import bisect


class Solution(object):
    def findSpecialInteger(self, arr):
        for x in [arr[len(arr)//4], arr[len(arr)//2], arr[len(arr)*3//4]]:
            if (bisect.bisect_right(arr, x) - bisect.bisect_left(arr, x)) * 4 > len(arr):
                return x
        return -1
",logn
"
class Solution(object):
    def stoneGameV(self, stoneValue):
        n = len(stoneValue)
        prefix = [0]
        for v in stoneValue:
            prefix.append(prefix[-1] + v)

        mid = list(range(n))

        dp = [[0]*n for _ in range(n)]
        for i in range(n):
            dp[i][i] = stoneValue[i]

        max_score = 0
        for l in range(2, n+1):
            for i in range(n-l+1):
                j = i+l-1
                while prefix[mid[i]]-prefix[i] < prefix[j+1]-prefix[mid[i]]:
                    mid[i] += 1 
                p = mid[i]
                max_score = 0
                if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]:
                    max_score = max(dp[i][p-1], dp[j][p])
                else:
                    if i <= p-2:
                        max_score = max(max_score, dp[i][p-2])
                    if p <= j:
                        max_score = max(max_score, dp[j][p])
                dp[i][j] = max(dp[i][j-1], (prefix[j+1]-prefix[i]) + max_score)
                dp[j][i] = max(dp[j][i+1], (prefix[j+1]-prefix[i]) + max_score)
        return max_score


",n^2
"class Solution2(object):
    def stoneGameV(self, stoneValue):
        n = len(stoneValue)
        prefix = [0]
        for v in stoneValue:
            prefix.append(prefix[-1] + v)

        mid = [[0]*n for _ in range(n)]
        for l in range(1, n+1):
            for i in range(n-l+1):
                j = i+l-1
                p = i if l == 1 else mid[i][j-1]
                while prefix[p]-prefix[i] < prefix[j+1]-prefix[p]:
                    p += 1 
                mid[i][j] = p
        
        rmq = [[0]*n for _ in range(n)]
        for i in range(n):
            rmq[i][i] = stoneValue[i]

        dp = [[0]*n for _ in range(n)]
        for l in range(2, n+1):
            for i in range(n-l+1):
                j = i+l-1
                p = mid[i][j]
                max_score = 0
                if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]:
                    max_score = max(rmq[i][p-1], rmq[j][p])
                else:
                    if i <= p-2:
                        max_score = max(max_score, rmq[i][p-2])
                    if p <= j:
                        max_score = max(max_score, rmq[j][p])
                dp[i][j] = max_score
                rmq[i][j] = max(rmq[i][j-1], (prefix[j+1]-prefix[i]) + max_score)
                rmq[j][i] = max(rmq[j][i+1], (prefix[j+1]-prefix[i]) + max_score)
        return dp[0][n-1]
",n^2
"

class Solution(object):
    def canChange(self, start, target):
        i = j = 0
        while True:
            while i < len(start) and start[i] == '_':
                i += 1
            while j < len(target) and target[j] == '_':
                j += 1
            if i == len(start) and j == len(target):
                break
            if i == len(start) or j == len(target) or start[i] != target[j] or \
               (start[i] == 'L' and i < j) or (start[i] == 'R' and i > j):
                    return False
            i += 1
            j += 1
        return True
",n
"

class Solution(object):
    def separateDigits(self, nums):
        result = []
        for x in reversed(nums):
            while x:
                result.append(x%10)
                x //= 10
        result.reverse()
        return result


",n * logr
"
class Solution2(object):
    def separateDigits(self, nums):
        return [int(c) for x in nums for c in str(x)]
",n * logr
"

class Solution(object):
    def maxCoins(self, nums):
        coins = [1] + [i for i in nums if i > 0] + [1]
        n = len(coins)
        max_coins = [[0 for _ in range(n)] for _ in range(n)]

        for k in range(2, n):
            for left in range(n - k):
                right = left + k
                for i in range(left + 1, right):
                    max_coins[left][right] = \
                        max(max_coins[left][right],
                            coins[left] * coins[i] * coins[right] +
                            max_coins[left][i] +
                            max_coins[i][right])

        return max_coins[0][-1]

",n^3
"
import operator


class Solution(object):
    def calculate(self, s):
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(ops[operators.pop()](left, right))

        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
        precedence = {'+':0, '-':0, '*':1, '/':1}
        operands, operators, operand = [], [], 0
        for i in range(len(s)):
            if s[i].isdigit():
                operand = operand*10 + int(s[i])
                if i == len(s)-1 or not s[i+1].isdigit():
                    operands.append(operand)
                    operand = 0
            elif s[i] == '(':
                operators.append(s[i])
            elif s[i] == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif s[i] in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] >= precedence[s[i]]:
                    compute(operands, operators)
                operators.append(s[i])
        while operators:
            compute(operands, operators)
        return operands[-1]


",n
"class Solution2(object):
    def calculate(self, s):
        operands, operators = [], []
        operand = """"
        for i in reversed(range(len(s))):
            if s[i].isdigit():
                operand += s[i]
                if i == 0 or not s[i-1].isdigit():
                    operands.append(int(operand[::-1]))
                    operand = """"
            elif s[i] == ')' or s[i] == '+' or s[i] == '-':
                operators.append(s[i])
            elif s[i] == '(':
                while operators[-1] != ')':
                    self.compute(operands, operators)
                operators.pop()

        while operators:
            self.compute(operands, operators)

        return operands[-1]

    def compute(self, operands, operators):
        left, right = operands.pop(), operands.pop()
        op = operators.pop()
        if op == '+':
            operands.append(left + right)
        elif op == '-':
            operands.append(left - right)

",n
"

class Solution(object):
    def findSubtreeSizes(self, parent, s):
        def iter_dfs():
            lookup = [[] for _ in range(26)]
            result = [1]*len(parent)
            stk = [(1, 0)]
            while stk:
                step, u = stk.pop()
                if step == 1:
                    lookup[ord(s[u])-ord('a')].append(u)
                    stk.append((2, u))
                    for v in reversed(adj[u]):
                        stk.append((1, v))
                elif step == 2:
                    for v in adj[u]:
                        result[lookup[ord(s[v])-ord('a')][-1] if lookup[ord(s[v])-ord('a')] else u] += result[v]
                    lookup[ord(s[u])-ord('a')].pop()
            return result
        
        adj = [[] for _ in range(len(parent))]
        for v, u in enumerate(parent):
            if u != -1:
                adj[u].append(v)
        return iter_dfs()


",n
"
class Solution2(object):
    def findSubtreeSizes(self, parent, s):
        def dfs(u):
            lookup[ord(s[u])-ord('a')].append(u)
            for v in adj[u]:
                dfs(v)
                result[lookup[ord(s[v])-ord('a')][-1] if lookup[ord(s[v])-ord('a')] else u] += result[v]
            lookup[ord(s[u])-ord('a')].pop()
        
        adj = [[] for _ in range(len(parent))]
        for v, u in enumerate(parent):
            if u != -1:
                adj[u].append(v)
        lookup = [[] for _ in range(26)]
        result = [1]*len(parent)
        dfs(0)
        return result
",n
"
class Solution(object):
    def findBestValue(self, arr, target):
        arr.sort(reverse=True)
        max_arr = arr[0]
        while arr and arr[-1]*len(arr) <= target:
            target -= arr.pop()
        return max_arr if not arr else (2*target+len(arr)-1)//(2*len(arr))


",nlogn
"class Solution2(object):
    def findBestValue(self, arr, target):
        arr.sort(reverse=True)
        max_arr = arr[0]
        while arr and arr[-1]*len(arr) <= target:
            target -= arr.pop()
        if not arr:
            return max_arr
        x = (target-1)//len(arr)
        return x if target-x*len(arr) <= (x+1)*len(arr)-target else x+1


",nlogn
"class Solution3(object):
    def findBestValue(self, arr, target):
        def total(arr, v):
            result = 0
            for x in arr:
                result += min(v, x)
            return result

        def check(arr, v, target):
            return total(arr, v) >= target
        
        left, right = 1, max(arr)
        while left <= right:
            mid = left + (right-left)//2
            if check(arr, mid, target):
                right = mid-1
            else:
                left = mid+1
        return left-1 if target-total(arr, left-1) <= total(arr, left)-target else left
",nlogm
"
class Solution(object):
    def minSteps(self, n):
        result = 0
        p = 2
        while p**2 <= n:
            while n % p == 0:
                result += p
                n //= p
            p += 1
        if n > 1:
            result += n
        return result

",sqrt(n)
"
class Solution(object):
    def findFarmland(self, land):
        result = []
        for i in range(len(land)):
            for j in range(len(land[0])):
                if land[i][j] != 1:
                    continue
                ni, nj = i, j
                while ni+1 < len(land) and land[ni+1][j] == 1:
                    ni += 1
                while nj+1 < len(land[0]) and land[i][nj+1] == 1:
                    nj += 1
                for r in range(i, ni+1):
                    for c in range(j, nj+1):
                        land[r][c] = -1
                result.append([i, j, ni, nj])
        return result
",m * n
"
class Solution(object):
    def finalPrices(self, prices):
        stk = []
        for i, p in enumerate(prices):
            while stk and prices[stk[-1]] >= p:
                prices[stk.pop()] -= p
            stk.append(i)
        return prices
",n
"
import itertools


class Solution(object):
    def countVowelPermutation(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) % MOD \
                     for col in ZB] for row in A]
        
        MOD = 10**9 + 7
        T = [[0, 1, 1, 0, 1],
             [1, 0, 1, 0, 0],
             [0, 1, 0, 1, 0],
             [0, 0, 1, 0, 0],
             [0, 0, 1, 1, 0]]
        return sum(map(sum, matrix_expo(T, n-1))) % MOD


",logn
"class Solution2(object):
    def countVowelPermutation(self, n):
        MOD = 10**9 + 7
        a, e, i, o, u = 1, 1, 1, 1, 1
        for _ in range(1, n):
            a, e, i, o, u = (e+i+u) % MOD, (a+i) % MOD, (e+o) % MOD, i, (i+o) % MOD
        return (a+e+i+o+u) % MOD
",n
"
import collections


class Solution(object):
    def countNicePairs(self, nums):
        MOD = 10**9 + 7

        def rev(x):
            result = 0
            while x:
                x, r = divmod(x, 10)
                result = result*10+r
            return result
        
        result = 0
        lookup = collections.defaultdict(int)
        for num in nums:
            result = (result + lookup[num-rev(num)])%MOD
            lookup[num-rev(num)] += 1
        return result
",nlogm
"
import collections



class Solution(object):
    def isReflected(self, points):
        if not points:
            return True
        groups_by_y = collections.defaultdict(set)
        left, right = float(""inf""), float(""-inf"")
        for p in points:
            groups_by_y[p[1]].add(p[0])
            left, right = min(left, p[0]), max(right, p[0])
        mid = left + right
        for group in list(groups_by_y.values()):
            for x in group:
                if mid - x not in group:
                    return False
        return True


",n
"
class Solution2(object):
    def isReflected(self, points):
        if not points:
            return True
        points.sort()
        points[len(points)/2:] = sorted(points[len(points)/2:], \
                                        lambda x, y: y[1] - x[1] if x[0] == y[0] else \
                                                     x[0] - y[0])
        mid = points[0][0] + points[-1][0]
        left, right = 0, len(points) - 1
        while left <= right:
            if (mid != points[left][0] + points[right][0]) or \
               (points[left][0] != points[right][0] and \
                points[left][1] != points[right][1]):
                return False
            left += 1
            right -= 1
        return True

",nlogn
"
from sortedcontainers import SortedList



class Solution(object):
    def minOperations(self, nums, k):
        def rebalance(total_left, total_right):
            if len(left)+1 < len(right):
                x, i = right.pop(0)
                total_right -= x
                left.add((-x, -i))
                total_left += x
            elif len(left) > len(right):
                x, i = left.pop(0)
                total_left -= -x
                right.add((-x, -i))
                total_right += -x
            return total_left, total_right

        result = float(""inf"")
        left = SortedList()
        right = SortedList()
        total_left = total_right = 0
        for i, x in enumerate(nums):
            if left and -left[0][0] > x:
                left.add((-x, -i))
                total_left += x
            else:
                right.add((x, i))
                total_right += x                
            total_left, total_right = rebalance(total_left, total_right)
            if i-(k-1) >= 0:
                result = min(result, (total_right-(right[0][0] if k%2 else 0))-total_left)
                j, y = i-(k-1), nums[i-(k-1)]
                if (-y, -j) in left:
                    left.remove((-y, -j))
                    total_left -= y
                else:
                    right.remove((y, j))
                    total_right -= y
                total_left, total_right = rebalance(total_left, total_right)
        return result
",nlogk
"
import heapq


class Solution(object):
    def eatenApples(self, apples, days):
        min_heap = []
        result = i = 0
        while i < len(apples) or min_heap:
            if i < len(apples) and apples[i] > 0:
                heapq.heappush(min_heap, [i+days[i], i])
            while min_heap and (min_heap[0][0] <= i or apples[min_heap[0][1]] == 0):
                heapq.heappop(min_heap)
            if min_heap:
                apples[min_heap[0][1]] -= 1
                result += 1
            i += 1
        return result
",nlogn
"
from sortedcontainers import SortedList



class Solution(object):
    def minAbsoluteDifference(self, nums, x):
        result = float(""inf"")
        sl = SortedList()
        for i in range(x, len(nums)):
            sl.add(nums[i-x])
            j = sl.bisect_left(nums[i])
            if j-1 >= 0:
                result = min(result, nums[i]-sl[j-1])
            if j < len(sl):
                result = min(result, sl[j]-nums[i])
        return result
",nlogn
"

class Solution(object):
    def compressedString(self, word):
        result = []
        cnt = 0
        for i in range(len(word)):
            cnt += 1
            if cnt == 9 or (i+1 == len(word) or word[i+1] != word[i]):
                result.append(""%s%s"" % (cnt, word[i]))
                cnt = 0
        return """".join(result)
",n
"

class Solution(object):
    def validSubarraySize(self, nums, threshold):
        stk = [-1]
        for i in range(len(nums)+1):
            while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] >= nums[i]):
                if nums[stk.pop()]*((i-1)-stk[-1]) > threshold:
                    return (i-1)-stk[-1]
            stk.append(i)
        return -1
",n
"
class Solution(object):
    def wordCount(self, startWords, targetWords):
        def bitmask(w):
            return reduce(lambda x, y: x|y, (1 << (ord(c)-ord('a')) for i, c in enumerate(w)))

        lookup = set(bitmask(w) for w in startWords)
        result = 0 
        for w in targetWords: 
            mask = bitmask(w)
            result += any(mask ^ (1 << ord(c)-ord('a')) in lookup for c in w)
        return result 
",n
"
class Solution(object):
    def longestCommomSubsequence(self, arrays):
        result = min(arrays, key=lambda x: len(x))
        for arr in arrays:
            new_result = []
            i, j = 0, 0
            while i != len(result) and j != len(arr):
                if result[i] < arr[j]:
                    i += 1
                elif result[i] > arr[j]:
                    j += 1
                else:
                    new_result.append(result[i])
                    i += 1
                    j += 1
            result = new_result
        return result


",m * n
"import collections


class Solution2(object):
    def longestCommomSubsequence(self, arrays):
        return [num for num, cnt in collections.Counter(x for arr in arrays for x in arr).items() if cnt == len(arrays)]
",m * n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def __init__(self, root):
        self.__stk = []
        self.__traversalLeft(root)

    def hasNext(self):
        return self.__stk

    def __next__(self):
        node = self.__stk.pop()
        self.__traversalLeft(node.right)
        return node.val
    
    def __traversalLeft(self, node):
        while node is not None:
            self.__stk.append(node)
            node = node.left

",1
"
class Solution(object):
    def containsDuplicate(self, nums):
        return len(nums) > len(set(nums))

",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def minDepth(self, root):
        if root is None:
            return 0

        if root.left and root.right:
            return min(self.minDepth(root.left), self.minDepth(root.right)) + 1
        else:
            return max(self.minDepth(root.left), self.minDepth(root.right)) + 1

",n
"
class Solution(object):
    def findDuplicate(self, nums):
        slow = nums[0]
        fast = nums[nums[0]]
        while slow != fast:
            slow = nums[slow]
            fast = nums[nums[fast]]

        fast = 0
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]
        return slow


",n
"
class Solution2(object):
    def findDuplicate(self, nums):
        left, right = 1, len(nums) - 1

        while left <= right:
            mid = left + (right - left) / 2
            count = 0
            for num in nums:
                if num <= mid:
                    count += 1
            if count > mid:
                right = mid - 1
            else:
                left = mid + 1
        return left

",nlogn
"class Solution3(object):
    def findDuplicate(self, nums):
        duplicate = 0
        for num in nums:
            if nums[abs(num) - 1] > 0:
                nums[abs(num) - 1] *= -1
            else:
                duplicate = abs(num)
                break
        for num in nums:
            if nums[abs(num) - 1] < 0:
                nums[abs(num) - 1] *= -1
            else:
                break
        return duplicate

",n
"

class Solution(object):
    def maxScore(self, nums):
        result = mx = 0
        for i in reversed(range(1, len(nums))):
            mx = max(mx, nums[i])
            result += mx
        return result
",n
"
class Solution(object):
    def merge(self, intervals):
        intervals.sort()
        result = []
        for interval in intervals:
            if not result or interval[0] > result[-1][1]:
                result.append(interval)
            else:
                result[-1][1] = max(result[-1][1], interval[1])
        return result
",nlogn
"

class Solution(object):
    def minimumBoxes(self, apple, capacity):
        capacity.sort(reverse=True)
        total = sum(apple)
        for i in range(len(capacity)):
            total -= capacity[i]
            if total <= 0:
                return i+1
        return -1
",nlogn
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

    def __repr__(self):
        if self:
            serial = []
            queue = [self]

            while queue:
                cur = queue[0]

                if cur:
                    serial.append(cur.val)
                    queue.append(cur.left)
                    queue.append(cur.right)
                else:
                    serial.append(

                queue = queue[1:]

            while serial[-1] == 
                serial.pop()

            return repr(serial)

        else:
            return None

class Solution(object):
    def recoverTree(self, root):
        return self.MorrisTraversal(root)

    def MorrisTraversal(self, root):
        if root is None:
            return
        broken = [None, None]
        pre, cur = None, root

        while cur:
            if cur.left is None:
                self.detectBroken(broken, pre, cur)
                pre = cur
                cur = cur.right
            else:
                node = cur.left
                while node.right and node.right != cur:
                    node = node.right

                if node.right is None:
                    node.right =cur
                    cur = cur.left
                else:
                    self.detectBroken(broken, pre, cur)
                    node.right = None
                    pre = cur
                    cur = cur.right

        broken[0].val, broken[1].val = broken[1].val, broken[0].val

        return root

    def detectBroken(self, broken, pre, cur):
        if pre and pre.val > cur.val:
            if broken[0] is None:
                broken[0] = pre
            broken[1] = cur

",n
"
import collections


class Solution(object):
    def largestValsFromLabels(self, values, labels, num_wanted, use_limit):
        counts = collections.defaultdict(int)
        val_labs = list(zip(values,labels))
        val_labs.sort(reverse=True)
        result = 0
        for val, lab in val_labs:
            if counts[lab] >= use_limit:
                continue
            result += val
            counts[lab] += 1
            num_wanted -= 1
            if num_wanted == 0:
                break
        return result
",nlogn
"
class Solution(object):
    def secondHighest(self, s):
        first = second = -1
        for c in s:
            if not c.isdigit():
                continue
            d = int(c)
            if d > first:
                first, second = d, first
            elif first > d > second:
                second = d
        return second
",n
"
class Solution(object):
    def threeSumClosest(self, nums, target):
        result, min_diff = 0, float(""inf"")
        nums.sort()
        for i in reversed(range(2, len(nums))):
            if i+1 < len(nums) and nums[i] == nums[i+1]:
                continue
            left, right = 0, i-1
            while left < right:
                total = nums[left]+nums[right]+nums[i]
                if total < target:
                    left += 1
                elif total > target:
                    right -= 1
                else:
                    return target
                if abs(total-target) < min_diff:
                    min_diff = abs(total-target)
                    result = total
        return result

",n^2
"
class Solution(object):
    def numWays(self, n, k):
        if n == 0:
            return 0
        elif n == 1:
            return k
        ways = [0] * 3
        ways[0] = k
        ways[1] = (k - 1) * ways[0] + k
        for i in range(2, n):
            ways[i % 3] = (k - 1) * (ways[(i - 1) % 3] + ways[(i - 2) % 3])
        return ways[(n - 1) % 3]

",n
"
class Solution2(object):
    def numWays(self, n, k):
        if n == 0:
            return 0
        elif n == 1:
            return k
        ways = [0] * n
        ways[0] = k
        ways[1] = (k - 1) * ways[0] + k
        for i in range(2, n):
            ways[i] = (k - 1) * (ways[i - 1] + ways[i - 2])
        return ways[n - 1]

",n
"

class Solution(object):
    def resultsArray(self, nums, k):
        result = [-1]*(len(nums)-k+1)
        left = 0
        for right in range(len(nums)):
            if nums[right]-nums[left] != right-left:
                left = right
            if right-left+1 == k:
                result[left] = nums[right]
                left += 1
        return result
",n
"

class Solution(object):
    def wordBreak(self, s, wordDict):
        n = len(s)

        max_len = 0
        for string in wordDict:
            max_len = max(max_len, len(string))

        can_break = [False for _ in range(n + 1)]
        valid = [[False] * n for _ in range(n)]
        can_break[0] = True
        for i in range(1, n + 1):
            for l in range(1, min(i, max_len) + 1):
                if can_break[i-l] and s[i-l:i] in wordDict:
                    valid[i-l][i-1] = True
                    can_break[i] = True

        result = []
        if can_break[-1]:
            self.wordBreakHelper(s, valid, 0, [], result)
        return result

    def wordBreakHelper(self, s, valid, start, path, result):
        if start == len(s):
            result.append("" "".join(path))
            return
        for i in range(start, len(s)):
            if valid[start][i]:
                path += [s[start:i+1]]
                self.wordBreakHelper(s, valid, i + 1, path, result)
                path.pop()


",n * l^2 + n * r
"
class Solution(object):
    def minCostToMoveChips(self, chips):
        count = [0]*2
        for p in chips:
            count[p%2] += 1
        return min(count)
",n
"

class Solution(object):
    def minCost(self, n, cost):
        l = len(cost[0])
        dp = [[0]*l for i in range(l)]
        for k in range(n//2):
            new_dp = [[float(""inf"")]*l for i in range(l)]
            for i in range(l):
                for j in range(l):
                    if j == i:
                        continue
                    for ni in range(l):
                        if ni == i:
                            continue
                        for nj in range(l):
                            if nj == j or ni == nj:
                                continue
                            new_dp[ni][nj] = min(new_dp[ni][nj], dp[i][j]+cost[k][ni]+cost[~k][nj])
            dp = new_dp
        return min(dp[i][j] for i in range(l) for j in range(l) if i != j)
",n * l^4
"
class Solution(object):
    def splitListToParts(self, root, k):
        n = 0
        curr = root
        while curr:
            curr = curr.__next__
            n += 1
        width, remainder = divmod(n, k)

        result = []
        curr = root
        for i in range(k):
            head = curr
            for j in range(width-1+int(i < remainder)):
                if curr:
                    curr = curr.__next__
            if curr:
                curr.next, curr = None, curr.next
            result.append(head)
        return result

",n + k
"
class Solution(object):
    def minimumRefill(self, plants, capacityA, capacityB):
        result = 0 
        left, right = 0, len(plants)-1
        canA, canB = capacityA, capacityB
        while left < right: 
            if canA < plants[left]:
                result += 1
                canA = capacityA
            canA -= plants[left]
            if canB < plants[right]:
                result += 1
                canB = capacityB
            canB -= plants[right]
            left, right = left+1, right-1
        if left == right:
            if max(canA, canB) < plants[left]:
                result += 1
        return result
",n
"
import re


class Solution(object):
    def solveEquation(self, equation):
        a, b, side = 0, 0, 1
        for eq, sign, num, isx in re.findall('(=)|([-+]?)(\d*)(x?)', equation):
            if eq:
                side = -1
            elif isx:
                a += side * int(sign + '1') * int(num or 1)
            elif num:
                b -= side * int(sign + num)
        return 'x=%d' % (b / a) if a else 'No solution' if b else 'Infinite solutions'

",n
"
class Solution(object):
    def numDistinctIslands(self, grid):
        directions = {'l':[-1,  0], 'r':[ 1,  0], \
                      'u':[ 0,  1], 'd':[ 0, -1]}

        def dfs(i, j, grid, island):
            if not (0 <= i < len(grid) and \
                    0 <= j < len(grid[0]) and \
                    grid[i][j] > 0):
                return False
            grid[i][j] *= -1
            for k, v in directions.items():
                island.append(k)
                dfs(i+v[0], j+v[1], grid, island)
            return True

        islands = set()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                island = []
                if dfs(i, j, grid, island):
                    islands.add("""".join(island))
        return len(islands)

",m * n
"

class Solution(object):
    def minIncrements(self, n, cost):
        result = 0
        for i in reversed(range(n//2)):
            result += abs(cost[2*i+1]-cost[2*i+2])
            cost[i] += max(cost[2*i+1], cost[2*i+2])
        return result
",n
"
class Solution(object):
    def canBeIncreasing(self, nums):
        deleted = False
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                continue
            if deleted:
                return False
            deleted = True
            if i >= 2 and nums[i-2] > nums[i]: 
                nums[i] = nums[i-1]
        return True
",n
"

class Solution(object):
    def maxDifference(self, s, k):
        def diff(x, y):
            prefix1, prefix2, prefix = [0]*(len(s)+1), [0]*(len(s)+1), [0]*(len(s)+1)
            for i in range(len(s)):
                prefix1[i+1] = prefix1[i]+int(s[i] == x)
                prefix2[i+1] = prefix2[i]+int(s[i] == y)
                prefix[i+1] = prefix[i]+(int(s[i] == x)-int(s[i] == y))
            result = float(""-inf"")
            mn = [[float(""inf"")]*2 for _ in range(2)]
            left = 0
            for right in range(k-1, len(s)):
                while k <= right-left+1 and prefix1[right+1]-prefix1[left] and prefix2[right+1]-prefix2[left]:
                    i, j = prefix1[left]%2, prefix2[left]%2
                    mn[i][j] = min(mn[i][j], prefix[left])
                    left += 1
                i, j = prefix1[right+1]%2, prefix2[right+1]%2
                result = max(result, prefix[right+1]-mn[i^1][j])
            return result
        
        lookup = set(s)
        return max(diff(x, y) for x in lookup for y in lookup if x != y)
",d^2 * n
"

class Solution(object):
    def maxIncreasingSubarrays(self, nums):
        result = 0
        curr, prev = 1, 0
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                curr += 1
            else:
                prev = curr
                curr = 1
            result = max(result, curr//2, min(prev, curr))
        return result
",n
"
import collections


class Solution(object):
    def findMinHeightTrees(self, n, edges):
        if n == 1:
            return [0]

        neighbors = collections.defaultdict(set)
        for u, v in edges:
            neighbors[u].add(v)
            neighbors[v].add(u)

        pre_level, unvisited = [], set()
        for i in range(n):
            if len(neighbors[i]) == 1: 
                pre_level.append(i)
            unvisited.add(i)

        while len(unvisited) > 2:
            cur_level = []
            for u in pre_level:
                unvisited.remove(u)
                for v in neighbors[u]:
                    if v in unvisited:
                        neighbors[v].remove(u)
                        if len(neighbors[v]) == 1:
                            cur_level.append(v)
            pre_level = cur_level

        return list(unvisited)

",n
"
class Solution(object):
    def isPrefixString(self, s, words):
        i = j = 0
        for c in s:
            if i == len(words) or words[i][j] != c:
                return False 
            j += 1
            if j == len(words[i]):
                i += 1
                j = 0
        return j == 0


",n
"class Solution2(object):
    def isPrefixString(self, s, words):
        i = 0
        for word in words:
            for c in word:
                if i == len(s) or s[i] != c:
                    return False
                i += 1
            if i == len(s):
                return True
        return False
",n
"

class Solution(object):
    def addedInteger(self, nums1, nums2):
        return max(nums2)-max(nums1)
",n
"
import itertools



class Solution(object):
    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):
        result = 0
        for hp, ex in zip(energy, experience):
            inc1 = max((hp+1)-initialEnergy, 0)
            inc2 = max((ex+1)-initialExperience, 0)
            result += inc1+inc2
            initialEnergy += inc1-hp
            initialExperience += inc2+ex
        return result
",n
"
class Solution(object):
    def __init__(self):
        def dayOfMonth(M):
            return (28 if (M == 2) else 31-(M-1)%7%2)

        self.__lookup = [0]*12
        for M in range(1, len(self.__lookup)):
            self.__lookup[M] += self.__lookup[M-1]+dayOfMonth(M)

    def daysBetweenDates(self, date1, date2):
        def num_days(date):
            Y, M, D = list(map(int, date.split(""-"")))
            leap = 1 if M > 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0)) else 0
            return (Y-1)*365 + ((Y-1)//4 - (Y-1)//100 + (Y-1)//400) + self.__lookup[M-1]+D+leap
     
        return abs(num_days(date1) - num_days(date2))


",1
"import datetime


class Solution2(object):
    def daysBetweenDates(self, date1, date2):        
        delta = datetime.datetime.strptime(date1, ""%Y-%m-%d"")
        delta -= datetime.datetime.strptime(date2, ""%Y-%m-%d"")
        return abs(delta.days)
",1
"
import random


class Solution(object):
    dp = {}

    def getKth(self, lo, hi, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def partition_around_pivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == n:
                    return
                elif new_pivot_idx > n:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
                    
        def power_value(x):
            y, result = x, 0
            while x > 1 and x not in Solution.dp:
                result += 1
                if x%2:
                    x = 3*x + 1
                else:
                    x //= 2
            Solution.dp[y] = result + (Solution.dp[x] if x > 1 else 0)
            return Solution.dp[y], y
        
        arr = list(map(power_value, list(range(lo, hi+1))))
        nth_element(arr, k-1)
        return arr[k-1][1]


",n
"class Solution2(object):
    dp = {}

    def getKth(self, lo, hi, k):
        def power_value(x):
            y, result = x, 0
            while x > 1 and x not in Solution2.dp:
                result += 1
                if x%2:
                    x = 3*x + 1
                else:
                    x //= 2
            Solution2.dp[y] = result + (Solution2.dp[x] if x > 1 else 0)
            return Solution2.dp[y], y
        
        return sorted(list(range(lo, hi+1)), key=power_value)[k-1]
",nlogn
"
class ListNode(object):
    def __init__(self, val=0, next=None):
        pass



class Solution(object):
    def mergeNodes(self, head):
        curr, zero = head.__next__, head
        while curr:
            if curr.val:
                zero.val += curr.val
            else:
                zero.next = curr if curr.__next__ else None
                zero = curr
            curr = curr.__next__
        return head
",n
"
import collections



class Solution(object):
    def numberOfNodes(self, n, queries):
        def bfs():
            result = 0
            q = [(1, 0)]
            while q:
                new_q = []
                for u, curr in q:
                    curr ^= cnt[u]%2
                    result += curr
                    for v in range(2*u, min(2*u+1, n)+1):
                        q.append((v, curr))
                q = new_q
            return result

        cnt = collections.Counter(queries)
        return bfs()


",q + n
"import collections



class Solution2(object):
    def numberOfNodes(self, n, queries):
        def iter_dfs():
            result = 0
            stk = [(1, 0)]
            while stk:
                u, curr = stk.pop()
                curr ^= cnt[u]%2
                result += curr
                for v in reversed(range(2*u, min(2*u+1, n)+1)):
                    stk.append((v, curr))
            return result

        cnt = collections.Counter(queries)
        return iter_dfs()


",q + n
"import collections



class Solution3(object):
    def numberOfNodes(self, n, queries):
        def dfs(u, curr):
            curr ^= cnt[u]%2
            return curr+sum(dfs(v, curr) for v in range(2*u, min(2*u+1, n)+1))
    
        cnt = collections.Counter(queries)
        return dfs(1, 0)
",q + n
"

class Solution(object):
    def convertDateToBinary(self, date):
        return ""-"".join([bin(int(x))[2:] for x in date.split('-')])
",1
"
class Solution(object):
    def minSwaps(self, s):
        def cost(s, x): 
            diff = 0 
            for c in s:
                diff += int(c) != x
                x ^= 1
            return diff//2
    
        ones = s.count('1')
        zeros = len(s)-ones 
        if abs(ones-zeros) > 1:
            return -1
        if ones > zeros:
            return cost(s, 1)
        if ones < zeros:
            return cost(s, 0)
        return min(cost(s, 1), cost(s, 0))
",n
"

class Solution(object):
    def longestSquareStreak(self, nums):
        sorted_nums = sorted(set(nums))
        squares = {x for x in sorted_nums if x%2 < 2} 
        result = 0
        for x in sorted_nums:
            square, cnt = x**2, 1
            while square in squares:
                squares.remove(square)
                cnt += 1
                square *= square
            result = max(result, cnt)
        return result if result != 1 else -1


",nlogn
"
class Solution2(object):
    def longestSquareStreak(self, nums):
        dp = collections.defaultdict(int)
        nums.sort()
        result = -1
        for x in nums:
            sqrt_x = int(x**0.5)
            if sqrt_x**2 == x:
                dp[x] = dp[sqrt_x]+1
            else:
                dp[x] = 1
            result = max(result, dp[x])
        return result if result != 1 else -1
",nlogn
"

class Solution(object):
    def totalSteps(self, nums):
        dp = [0]*len(nums) 
        stk = []
        for i in reversed(range(len(nums))):
            while stk and nums[stk[-1]] < nums[i]:
                dp[i] = max(dp[i]+1, dp[stk.pop()])
            stk.append(i)
        return max(dp)


",n
"
class Solution2(object):
    def totalSteps(self, nums):
        dp = [0]*len(nums) 
        stk = []
        for i in range(len(nums)):
            curr = 0
            while stk and nums[stk[-1]] <= nums[i]:
                curr = max(curr, dp[stk.pop()])
            if stk:
                dp[i] = curr+1
            stk.append(i)
        return max(dp)
",n
"
import collections


class Solution(object):
    def constrainedSubsetSum(self, nums, k):
        result, dq = float(""-inf""), collections.deque()
        for i in range(len(nums)):
            if dq and i-dq[0][0] == k+1:
                dq.popleft()
            curr = nums[i] + (dq[0][1] if dq else 0)
            while dq and dq[-1][1] <= curr:
                dq.pop()
            if curr > 0:
                dq.append((i, curr))
            result = max(result, curr)
        return result
",n
"
import random



class Solution(object):
    def largestEvenSum(self, nums, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        nth_element(nums, k-1, compare=lambda a, b: a > b)
        total = sum(nums[i] for i in range(k))
        if total%2 == 0:
            return total
        min_k = [float(""inf"")]*2
        for i in range(k):
            min_k[nums[i]%2] = min(min_k[nums[i]%2], nums[i])
        result = -1
        for i in range(k, len(nums)):
            result = max(result, total-min_k[not (nums[i]%2)]+nums[i])
        return result
",n
"

class Solution(object):
    def finalPositionOfSnake(self, n, commands):
        lookup = {""UP"":(-1, 0), ""RIGHT"":(0, 1), ""DOWN"":(1, 0), ""LEFT"":(0, -1)}
        r = c = 0
        for x in commands:
            dr, dc = lookup[x]
            r, c = r+dr, c+dc
        return r*n+c
",c
"
import collections


class Solution(object):
    def customSortString(self, S, T):
        counter, s = collections.Counter(T), set(S)
        result = [c*counter[c] for c in S]
        result.extend([c*counter for c, counter in counter.items() if c not in s])
        return """".join(result)

",n
"
class Solution(object):
    def search(self, nums, target):
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right-left)//2
            if nums[mid] > target:
                right = mid-1
            elif nums[mid] < target:
                left = mid+1
            else:
                return mid
        return -1

",logn
"
class Solution(object):
    def checkSubarraySum(self, nums, k):
        count = 0
        lookup = {0: -1}
        for i, num in enumerate(nums):
            count += num
            if k:
                count %= k
            if count in lookup:
                if i - lookup[count] > 1:
                    return True
            else:
                lookup[count] = i

        return False

",n
"
class Solution(object):
    def countDistinct(self, s):
        count = 0
        trie = {}
        for i in range(len(s)):
            curr = trie
            for j in range(i, len(s)):
                if s[j] not in curr:
                    count += 1
                    curr[s[j]] = {}
                curr = curr[s[j]]
        return count
",n^2
"

class Solution(object):
    def maxScore(self, points, m):
        def ceil_divide(a, b):
            return (a+b-1)//b

        def binary_search_right(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right
        
        def check(x):
            cnt = prev = 0
            for i in range(len(points)):
                remain = ceil_divide(x, points[i])-prev
                if remain >= 1:
                    prev = remain-1
                    cnt += 2*remain-1
                elif i != len(points)-1:
                    prev = 0
                    cnt += 1
                if cnt > m:
                    return False
            return True

        return binary_search_right(1, max(points)*m, check)
",n * log(m * r)
"

class Solution(object):
    def countOfSubstrings(self, word, k):
        VOWELS = set(""aeiou"")
        def update(i, d):
            if word[i] not in VOWELS:
                curr2[0] += d
                return
            x = ord(word[i])-ord('a')
            if cnt1[x] == 0:
                curr1[0] += 1
            cnt1[x] += d
            if cnt1[x] == 0:
                curr1[0] -= 1

        result = 0
        cnt1, cnt2 = [0]*26, [0]*26
        curr1, curr2 = [0], [0]
        mid = left = 0
        for right in range(len(word)):
            update(right, +1)
            while curr2[0] > k:
                update(left, -1)
                if left < mid:
                    assert(word[left] in VOWELS)
                    cnt2[ord(word[left])-ord('a')] -= 1
                left += 1
                mid = max(mid, left)
            if not (curr1[0] == len(VOWELS) and curr2[0] == k):
                continue
            while word[mid] in VOWELS and cnt1[ord(word[mid])-ord('a')]-(cnt2[ord(word[mid])-ord('a')]+1) >= 1:
                cnt2[ord(word[mid])-ord('a')] += 1
                mid += 1
            result += mid-left+1
        return result


",n
"
class Solution2(object):
    def countOfSubstrings(self, word, k):
        VOWELS = set(""aeiou"")
        def count(k):
            def update(i, d):
                if word[i] not in VOWELS:
                    curr2[0] += d
                    return
                x = ord(word[i])-ord('a')
                if cnt[x] == 0:
                    curr1[0] += 1
                cnt[x] += d
                if cnt[x] == 0:
                    curr1[0] -= 1

            result = 0
            cnt = [0]*26
            curr1, curr2 = [0], [0]
            left = 0
            for right in range(len(word)):
                update(right, +1)
                while curr1[0] == len(VOWELS) and curr2[0] >= k:
                    result += len(word)-right
                    update(left, -1)
                    left += 1
            return result

        return count(k)-count(k+1)
",n
"
class Solution(object):
    def runningSum(self, nums):
        for i in range(len(nums)-1):
            nums[i+1] += nums[i]
        return nums
",n
"
class Solution(object):
    def sortByBits(self, arr):
        def popcount(n): 
            result = 0
            while n:
                n &= n - 1
                result += 1
            return result
        
        arr.sort(key=lambda x: (popcount(x), x))
        return arr
",nlogn
"

class Solution(object):
    def countSpecialNumbers(self, n):
        def P(m, n):
            result = 1
            for _ in range(n):
                result *= m
                m -= 1
            return result

        digits = list(map(int, str(n+1)))
        result = sum(P(9, 1)*P(9, i-1) for i in range(1, len(digits)))
        lookup = set()
        for i, x in enumerate(digits):
            for y in range(int(i == 0), x):
                if y in lookup:
                    continue
                result += P(9-i, len(digits)-i-1)
            if x in lookup:
                break
            lookup.add(x)
        return result
",logn
"
import collections


class Solution(object):
    def leastBricks(self, wall):
        widths = collections.defaultdict(int)
        result = len(wall)
        for row in wall:
            width = 0
            for i in range(len(row)-1):
                width += row[i]
                widths[width] += 1
                result = min(result, len(wall) - widths[width])
        return result

",n
"
import collections


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def treeQueries(self, root, queries):
        def iter_dfs(root):
            top = collections.defaultdict(lambda: [0]*2)
            depth, height = {}, {}
            stk = [(1, (root, 0))]
            while stk:
                step, (curr, d) = stk.pop()
                if step == 1:
                    if not curr:
                        continue
                    stk.append((2, (curr, d)))
                    stk.append((1, (curr.right, d+1)))
                    stk.append((1, (curr.left, d+1)))
                elif step == 2:
                    h = 1+max((height[curr.left.val] if curr.left else 0), 
                              (height[curr.right.val] if curr.right else 0))
                    if h > top[d][0]:
                        top[d][0], top[d][1] = h, top[d][0]
                    elif h > top[d][1]:
                        top[d][1] = h
                    depth[curr.val], height[curr.val] = d, h
            return top, depth, height

        top, depth, height = iter_dfs(root)
        return [(depth[q]-1)+(top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]


",n
"import collections



class Solution2(object):
    def treeQueries(self, root, queries):
        def dfs(curr, d):
            if not curr:
                return 0
            h = 1+max(dfs(curr.left, d+1), dfs(curr.right, d+1))
            if h > top[d][0]:
                top[d][0], top[d][1] = h, top[d][0]
            elif h > top[d][1]:
                top[d][1] = h
            depth[curr.val], height[curr.val] = d, h
            return h
        
        top = collections.defaultdict(lambda: [0]*2)
        depth, height = {}, {}
        dfs(root, 0)
        return [(depth[q]-1)+(top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]
",n
"
import collections
import itertools


class Solution(object):
    def countBalls(self, lowLimit, highLimit):
        count = collections.Counter()
        for i in range(lowLimit, highLimit+1):
            count[sum(map(int, str(i)))] += 1
        return max(count.values())
",nlogm
"
class Solution(object):
    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):
        def left(curr):
            return curr[-1] if len(curr)%n else 0

        def up(curr):
            return curr[-n] if len(curr) >= n else 0 

        def count_total(curr, t, total):
            return (total
                    - 30*((left(curr) == 1)+(up(curr) == 1))
                    + 20*((left(curr) == 2)+(up(curr) == 2))
                    + (120 - 30*((left(curr) != 0)+(up(curr) != 0)))*(t == 1)
                    + ( 40 + 20*((left(curr) != 0)+(up(curr) != 0)))*(t == 2))
        
        def iter_backtracking(i, e):
            result = 0
            curr = []
            stk = [(2, (i, e, 0))]
            while stk:
                step, params = stk.pop()
                if step == 2:
                    i, e, total = params             
                    if len(curr) == m*n or (i == 0 and e == 0):
                        result = max(result, total)                
                        continue
                    if total + (i+e)*120 < result: 
                        continue
                    if e > 0:
                        stk.append((3, tuple()))
                        stk.append((2, (i, e-1, count_total(curr, 2, total))))
                        stk.append((1, (2,)))
                    if i > 0:
                        stk.append((3, tuple()))
                        stk.append((2, (i-1, e, count_total(curr, 1, total))))
                        stk.append((1, (1,)))
                    if left(curr) or up(curr): 
                        stk.append((3, tuple()))
                        stk.append((2, (i, e, total)))
                        stk.append((1, (0,)))
                elif step == 1:
                    x = params[0]
                    curr.append(x)
                elif step == 3:
                    curr.pop()
            return result
          
        return iter_backtracking(introvertsCount, extrovertsCount)


","C(m * n, i) * C(m * n - i, e)"
"class Solution2(object):
    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):
        def left(curr):
            return curr[-1] if len(curr)%n else 0

        def up(curr):
            return curr[-n] if len(curr) >= n else 0 

        def count_total(curr, t, total):
            return (total
                    - 30*((left(curr) == 1)+(up(curr) == 1))
                    + 20*((left(curr) == 2)+(up(curr) == 2))
                    + (120 - 30*((left(curr) != 0)+(up(curr) != 0)))*(t == 1)
                    + ( 40 + 20*((left(curr) != 0)+(up(curr) != 0)))*(t == 2))
        
        def backtracking(i, e, total, curr, result):              
            if len(curr) == m*n or (i == 0 and e == 0):
                result[0] = max(result[0], total)                
                return
            if total + (i+e)*120 < result[0]: 
                return
            if left(curr) or up(curr): 
                curr.append(0)
                backtracking(i, e, total, curr, result)
                curr.pop()
            if i > 0:
                new_total = count_total(curr, 1, total)
                curr.append(1)
                backtracking(i-1, e, new_total, curr, result)
                curr.pop()
            if e > 0:
                new_total = count_total(curr, 2, total)
                curr.append(2)
                backtracking(i, e-1, new_total, curr, result)
                curr.pop()

        result = [0]
        backtracking(introvertsCount, extrovertsCount, 0, [], result)
        return result[0]
","C(m * n, i) * C(m * n - i, e)"
"
import itertools



class Solution(object):
    def minCost(self, nums, cost):
        def f(x):
            return sum(abs(y-x)*c for y, c in zip(nums, cost))

        def check(x, t):
            return sum(c for y, c in zip(nums, cost) if y <= x) >= t
    
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        left, right = 0, len(idxs)-1
        total = sum(cost)
        median = (total+1)//2
        while left <= right:
            mid = left+(right-left)//2
            if check(nums[idxs[mid]], median):
                right = mid-1
            else:
                left = mid+1
        return f(nums[idxs[left]])


",nlogn
"import itertools



class Solution2(object):
    def minCost(self, nums, cost):
        def f(x):
            return sum(abs(y-x)*c for y, c in zip(nums, cost))
    
        def check(x):
            return x+1 == len(idxs) or f(nums[idxs[x]]) < f(nums[idxs[x+1]])

        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        left, right = 0, len(idxs)-1
        while left <= right:
            mid = left+(right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return f(nums[idxs[left]])


",nlogn
"
class Solution3(object):
    def minCost(self, nums, cost):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        prefix = [0]*(len(cost)+1)
        left = 0
        for i in range(len(cost)):
            if i-1 >= 0:
                left += prefix[i]*(nums[idxs[i]]-nums[idxs[i-1]])
            prefix[i+1] = prefix[i]+cost[idxs[i]]
        result = float(""inf"")
        suffix = right = 0
        for i in reversed(range(len(cost))):
            if i+1 < len(idxs):
                right += suffix*(nums[idxs[i+1]]-nums[idxs[i]])
            result = min(result, left+right)
            if i-1 >= 0:
                left -= prefix[i]*(nums[idxs[i]]-nums[idxs[i-1]])
            suffix += cost[idxs[i]]
        return result
",nlogn
"
import collections


class Solution(object):
    def longestSubsequenceRepeatedK(self, s, k):
        def check(s, k, curr):
            if not curr:
                return True
            i = 0
            for c in s:
                if c != curr[i]:
                    continue
                i += 1
                if i != len(curr):
                    continue
                i = 0
                k -= 1
                if not k:
                    return True
            return False

        def backtracking(s, k, curr, cnts, result):
            if not check(s, k, curr):
                return
            if len(curr) > len(result):
                result[:] = curr
            for c in reversed(string.ascii_lowercase):
                if cnts[c] < k:
                    continue
                cnts[c] -= k
                curr.append(c)
                backtracking(s, k, curr, cnts, result)
                curr.pop()
                cnts[c] += k
                    
        cnts = collections.Counter(s)
        new_s = []
        for c in s:
            if cnts[c] < k:
                continue
            new_s.append(c)
        result =[]
        backtracking(new_s, k, [], cnts, result)
        return """".join(result)
",n * (n/k)!
"

class Solution(object):
    def countOperations(self, num1, num2):
        result = 0
        while num2:
            result += num1//num2
            num1, num2 = num2, num1%num2
        return result
","log(min(m, n))"
"

class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteMiddle(self, head):
        dummy = ListNode()
        dummy.next = head
        slow = fast = dummy
        while fast.__next__ and fast.next.__next__:
            slow, fast = slow.__next__, fast.next.__next__
        slow.next = slow.next.__next__
        return dummy.__next__
",n
"
class Solution(object):
    def minimumLength(self, s):
        left, right = 0, len(s)-1
        while left < right:
            if s[left] != s[right]:
                break
            c = s[left]
            while left <= right:
                if s[left] != c:
                    break
                left += 1
            while left <= right:
                if s[right] != c:
                    break
                right -= 1
        return right-left+1
",n
"
class Solution(object):
    def sortTransformedArray(self, nums, a, b, c):
        f = lambda x, a, b, c : a * x * x + b * x + c

        result = []
        if not nums:
            return result

        left, right = 0, len(nums) - 1
        d = -1 if a > 0 else 1
        while left <= right:
            if d * f(nums[left], a, b, c) < d * f(nums[right], a, b, c):
                result.append(f(nums[left], a, b, c))
                left += 1
            else:
                result.append(f(nums[right], a, b, c))
                right -= 1

        return result[::d]

",n
"

class Solution(object):
    def findMaximumNumber(self, k, x):
        def floor_log2(x):
            return x.bit_length()-1

        def binary_search_right(left, right, check):
            while left <= right:
                mid = left+(right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right
    
        def count(l):
            return (prefix_cnt<<(x*l))+lookup[l]

        result = prefix_cnt = 0
        lookup = [0]
        i = 0
        while (lookup[-1]<<x)+(1<<(i+x-1)) <= k:
            lookup.append((lookup[-1]<<x)+(1<<(i+x-1)))
            i += x
        while k >= prefix_cnt:
            l = binary_search_right(1, len(lookup)-1, lambda l: count(l) <= k)
            cnt, i = count(l), x*l
            c = min(floor_log2(k//cnt) if cnt else float(""inf""), x-1)
            cnt <<= c
            i += c
            k -= cnt
            result += 1<<i
            prefix_cnt += int((i+1)%x == 0)
        return result-1


","max(logk, x) * log((logk) / x)"
"
class Solution2(object):
    def findMaximumNumber(self, k, x):
        def floor_log2(x):
            return x.bit_length()-1

        result = prefix_cnt = 0
        while k >= prefix_cnt:
            cnt, i = prefix_cnt, 0
            while (cnt<<x)+(1<<(i+x-1)) <= k:
                cnt = (cnt<<x)+(1<<(i+x-1))
                i += x
            c = min(floor_log2(k//cnt) if cnt else float(""inf""), x-1)
            cnt <<= c
            i += c
            k -= cnt
            result += 1<<i
            prefix_cnt += int((i+1)%x == 0)
        return result-1


","max(logk, x) * (max(logk, x) / x)"
"
class Solution3(object):
    def findMaximumNumber(self, k, x):
        def floor_log2(x):
            return x.bit_length()-1

        result = prefix_cnt = 0
        while k >= prefix_cnt:
            cnt, i = prefix_cnt, 0
            while (cnt<<1)+(1<<i if (i+1)%x == 0 else 0) <= k:
                cnt = (cnt<<1)+(1<<i if (i+1)%x == 0 else 0)
                i += 1
            k -= cnt
            result += 1<<i
            prefix_cnt += int((i+1)%x == 0)
        return result-1


","max(logk, x)^2"
"
class Solution4(object):
    def findMaximumNumber(self, k, x):
        def binary_search_right(left, right, check):
            while left <= right:
                mid = left+(right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right

        def count(v):
            cnt = i = 0
            while 1<<(i+x-1) <= v:
                q, r = divmod(v+1, 1<<((i+x-1)+1))
                cnt += q*1*(1<<(i+x-1))+max(r-1*(1<<(i+x-1)), 0)
                i += x
            return cnt

        return binary_search_right(1, max(k<<2, 1<<x), lambda v: count(v) <= k) 
","max(logk, x) * (max(logk, x) / x)"
"
class Solution(object):
    def oddEvenList(self, head):
        if head:
            odd_tail, cur = head, head.__next__
            while cur and cur.__next__:
                even_head = odd_tail.__next__
                odd_tail.next = cur.__next__
                odd_tail = odd_tail.__next__
                cur.next = odd_tail.__next__
                odd_tail.next = even_head
                cur = cur.__next__
        return head

",n
"
import operator


class Solution(object):
    def calculate(self, s):
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(ops[operators.pop()](left, right))

        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
        precedence = {'+':0, '-':0, '*':1, '/':1}
        operands, operators, operand = [], [], 0
        for i in range(len(s)):
            if s[i].isdigit():
                operand = operand*10 + int(s[i])
                if i == len(s)-1 or not s[i+1].isdigit():
                    operands.append(operand)
                    operand = 0
            elif s[i] == '(':
                operators.append(s[i])
            elif s[i] == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif s[i] in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] >= precedence[s[i]]:
                    compute(operands, operators)
                operators.append(s[i])
        while operators:
            compute(operands, operators)
        return operands[-1]


",n
"class Solution2(object):
    def calculate(self, s):
        operands, operators = [], []
        operand = """"
        for i in reversed(range(len(s))):
            if s[i].isdigit():
                operand += s[i]
                if i == 0 or not s[i-1].isdigit():
                    operands.append(int(operand[::-1]))
                    operand = """"
            elif s[i] == ')' or s[i] == '*' or s[i] == '/':
                operators.append(s[i])
            elif s[i] == '+' or s[i] == '-':
                while operators and \
                      (operators[-1] == '*' or operators[-1] == '/'):
                    self.compute(operands, operators)
                operators.append(s[i])
            elif s[i] == '(':
                while operators[-1] != ')':
                    self.compute(operands, operators)
                operators.pop()

        while operators:
            self.compute(operands, operators)

        return operands[-1]

    def compute(self, operands, operators):
        left, right = operands.pop(), operands.pop()
        op = operators.pop()
        if op == '+':
            operands.append(left + right)
        elif op == '-':
            operands.append(left - right)
        elif op == '*':
            operands.append(left * right)
        elif op == '/':
            operands.append(left / right)

",n
"

class Solution(object):
    def sumOfEncryptedInt(self, nums):
        def f(x):
            mx = base = 0
            while x:
                mx = max(mx, x%10)
                x //= 10
                base = 10*base+1
            return mx*base

        return sum(f(x) for x in nums)
",nlogr
"
class Solution(object):
    def asteroidsDestroyed(self, mass, asteroids):
        asteroids.sort()
        for x in asteroids:
            if x > mass:
                return False
            mass += min(x, asteroids[-1]-mass)
        return True
",nlogn
"

class Solution(object):
    def componentValue(self, nums, edges):
        def bfs(target):
            total = nums[:]
            lookup = [len(adj[u]) for u in range(len(adj))]
            q = [u for u in range(len(adj)) if lookup[u] == 1]
            while q:
                new_q = []
                for u in q:
                    if total[u] > target:
                        return False
                    if total[u] == target:
                        total[u] = 0
                    for v in adj[u]:
                        total[v] += total[u]
                        lookup[v] -= 1
                        if lookup[v] == 1:
                            new_q.append(v)
                q = new_q
            return True

        result = 0
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        total = sum(nums)
        for cnt in reversed(range(2, len(nums)+1)):
            if total%cnt == 0 and bfs(total//cnt):
                return cnt-1
        return 0


",n * sqrt(n)
"
class Solution2(object):
    def componentValue(self, nums, edges):
        def iter_dfs(target):
            total = nums[:]
            stk = [(1, (0, -1))]
            while stk:
                step, (u, p) = stk.pop()
                if step == 1:
                    stk.append((2, (u, p)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, (v, u)))
                elif step == 2:
                    for v in adj[u]:
                        if v == p:
                            continue
                        total[u] += total[v]
                    if total[u] == target:
                        total[u] = 0
            return total[0]

        result = 0
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        total = sum(nums)
        for cnt in reversed(range(2, len(nums)+1)):
            if total%cnt == 0 and iter_dfs(total//cnt) == 0:
                return cnt-1
        return 0


",n * sqrt(n)
"
class Solution3(object):
    def componentValue(self, nums, edges):
        def dfs(u, p, target):
            total = nums[u]
            for v in adj[u]:
                if v == p:
                    continue
                total += dfs(v, u, target)
            return total if total != target else 0

        result = 0
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        total = sum(nums)
        for cnt in reversed(range(2, len(nums)+1)):
            if total%cnt == 0 and dfs(0, -1, total//cnt) == 0:
                return cnt-1
        return 0
",n * sqrt(n)
"
import fractions

class Solution(object):
    def simplifiedFractions(self, n):
        lookup = set()
        for b in range(1, n+1):
            for a in range(1, b):
                g = fractions.gcd(a, b)
                lookup.add((a//g, b//g))
        return [""{}/{}"".format(*x) for x in lookup]
",n^2 * logn
"
import itertools
import heapq



class Solution(object):
    def minCost(self, n, roads, appleCost, k):
        def dijkstra(start):
            best = [float(""inf"")]*len(adj)
            best[start] = 0
            min_heap = [(0, start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if best[u] < curr:
                    continue
                for v, w in adj[u]:                
                    if best[v] <= curr+w:
                        continue
                    best[v] = curr+w
                    heapq.heappush(min_heap, (curr+w, v))
            return best

        adj = [[] for _ in range(n)]
        for a, b, c in roads:
            adj[a-1].append((b-1, c))
            adj[b-1].append((a-1, c))
        return [min(a+d*(k+1) for a, d in zip(appleCost, dijkstra(u))) for u in range(n)]
",n * rlogn
"
import collections



class Solution(object):
    def maximumTotalDamage(self, power):
        DIST = 2
        power.sort()
        dp = collections.deque()
        mx = 0
        for x in power:
            if dp and dp[-1][0] == x:
                dp[-1][1] += x
                continue
            while dp and dp[0][0]+DIST < x:
                mx = max(mx, dp.popleft()[1])
            dp.append([x, mx+x])
        return max(x for _, x in dp)
",nlogn
"
class Solution(object):
    def numberOfRounds(self, startTime, finishTime):
        h1, m1 = list(map(int, startTime.split("":"")))
        h2, m2 = list(map(int, finishTime.split("":"")))
        start = h1*60+m1
        finish = h2*60+m2
        if start > finish:
            finish += 1440
        return max(finish//15-(start+15-1)//15, 0)


",1
"class Solution2(object):
    def numberOfRounds(self, startTime, finishTime):
        h1, m1 = list(map(int, startTime.split("":"")))
        h2, m2 = list(map(int, finishTime.split("":"")))
        if m1 > m2:
            h2 -= 1
            m2 += 60
        return max((h2-h1)%24*4 + m2//15 - (m1+15-1)//15, 0)
",1
"

class Solution(object):
    def maximumTripletValue(self, nums):
        NEG_INF = float(""-inf"")
        result = 0
        mx_diff = mx = NEG_INF
        for x in nums:
            if mx_diff != NEG_INF:
                result = max(result, mx_diff*x)
            if mx != NEG_INF:
                mx_diff = max(mx_diff, mx-x)
            mx = max(mx, x)
        return result
",n
"
class Solution(object):
    def findKthPositive(self, arr, k):
        def check(arr, k, x):
            return arr[x]-(x+1) < k

        left, right = 0, len(arr)-1
        while left <= right:
            mid = left + (right-left)//2
            if not check(arr, k, mid):
                right = mid-1
            else:
                left = mid+1
        return right+1+k 
",logn
"
class Solution(object):
    def findRotation(self, mat, target):
        checks = [lambda i, j: mat[i][j] == target[i][j],
                  lambda i, j: mat[i][j] == target[j][-1-i],
                  lambda i, j: mat[i][j] == target[-1-i][-1-j],
                  lambda i, j: mat[i][j] == target[-1-j][i]]
        traverse = lambda check: all(check(i, j) for i in range(len(mat)) for j in range(len(mat[0])))
        return any(traverse(check) for check in checks)
",m * n
"
class Solution(object):
    def boundaryOfBinaryTree(self, root):
        def leftBoundary(root, nodes):
            if not root or (not root.left and not root.right):
                return
            nodes.append(root.val)
            if not root.left:
                leftBoundary(root.right, nodes)
            else:
                leftBoundary(root.left, nodes)

        def rightBoundary(root, nodes):
            if not root or (not root.left and not root.right):
                return
            if not root.right:
                rightBoundary(root.left, nodes)
            else:
                rightBoundary(root.right, nodes)
            nodes.append(root.val)

        def leaves(root, nodes):
            if not root:
                return
            if not root.left and not root.right:
                nodes.append(root.val)
                return
            leaves(root.left, nodes)
            leaves(root.right, nodes)

        if not root:
            return []

        nodes = [root.val]
        leftBoundary(root.left, nodes)
        leaves(root.left, nodes)
        leaves(root.right, nodes)
        rightBoundary(root.right, nodes)
        return nodes

",n
"
import random



class TreapNode(object):
    def __init__(self, value):
        self.value = value
        self.prior = random.randint(1, 1 << 30)
        self.cnt = 1
        self.xor_sum = value
        self.rev = False
        self.l = None
        self.r = None

def cnt(t):
    return t.cnt if t else 0

def xor_sum(t):
    return t.xor_sum if t else 0

def upd_cnt(t):
    if t:
        t.cnt = 1 + cnt(t.l) + cnt(t.r)
        t.xor_sum = t.value ^ xor_sum(t.l) ^ xor_sum(t.r)

def push(t):
    if t and t.rev:
        t.rev = False
        t.l, t.r = t.r, t.l
        if t.l:
            t.l.rev ^= True
        if t.r:
            t.r.rev ^= True

def merge(l, r):
    push(l)
    push(r)
    if not l or not r:
        return l or r
    if l.prior > r.prior:
        l.r = merge(l.r, r)
        upd_cnt(l)
        return l
    else:
        r.l = merge(l, r.l)
        upd_cnt(r)
        return r

def split(t, key, add=0):
    if not t:
        return (None, None)
    push(t)
    cur_key = add + cnt(t.l)
    if key <= cur_key:
        l, t.l = split(t.l, key, add)
        upd_cnt(t)
        return (l, t)
    else:
        t.r, r = split(t.r, key, add + 1 + cnt(t.l))
        upd_cnt(t)
        return (t, r)

def reverse(t, l, r):
    t1, t2 = split(t, l)
    t2, t3 = split(t2, r - l + 1)
    if t2:
        t2.rev ^= True
    return merge(merge(t1, t2), t3)

def heapify(t):
    if not t:
        return
    mx = t
    if t.l and t.l.prior > mx.prior:
        mx = t.l
    if t.r and t.r.prior > mx.prior:
        mx = t.r
    if mx != t:
        t.prior, mx.prior = mx.prior, t.prior
        heapify(mx)

def build(a, i, n):
    if not n:
        return None
    mid = n // 2
    t = TreapNode(a[i + mid])
    t.l = build(a, i, mid)
    t.r = build(a, i + mid + 1, n - mid - 1)
    heapify(t)
    upd_cnt(t)
    return t


class Solution_TLE(object):
    def getResults(self, nums, queries):
        def update(root, index, value):
            left, mid = split(root, index)
            mid, right = split(mid, 1)
            mid.value = value
            upd_cnt(mid)
            return merge(merge(left, mid), right)

        def query(root, left, right):
            t1, t2 = split(root, left)
            t2, t3 = split(t2, right - left + 1)
            result = xor_sum(t2)
            return merge(merge(t1, t2), t3), result

        result = []
        root = build(nums, 0, len(nums))
        for q in queries:
            if q[0] == 1:
                root = update(root, q[1], q[2])
            elif q[0] == 2:
                root, x = query(root, q[1], q[2])
                result.append(x)
            elif q[0] == 3:
                root = reverse(root, q[1], q[2])
        return result
",n + qlogn
"
class Solution(object):
    def findDerangement(self, n):
        M = 1000000007
        mul, total = 1, 0
        for i in reversed(range(n+1)):
            total = (total + M + (1 if i % 2 == 0 else -1) * mul) % M
            mul = (mul * i) % M
        return total

",n
"

class Solution(object):
    def minSum(self, nums1, nums2):
        total1 = sum(max(x, 1) for x in nums1)
        total2 = sum(max(x, 1) for x in nums2)
        if total1 < total2:
            return total2 if 0 in nums1 else -1
        if total1 > total2:
            return total1 if 0 in nums2 else -1
        return total1
",n + m
"

class Solution(object):
    def minValidStrings(self, words, target):
        MOD, P = 10**9+7, 131
        power = [1]
        for _ in range(len(target)):
            power.append(power[-1]*P%MOD)
        lookup = set()
        for w in words:
            h = 0
            for x in w:
                h = (h*P+(ord(x)-ord('a')+1))%MOD
                lookup.add(h)
        dp = [0]*(len(target)+1)
        left = h = 0
        for right in range(len(target)):
            h = (h*P+(ord(target[right])-ord('a')+1))%MOD
            while right-left+1 >= 1 and h not in lookup:
                h = (h-(ord(target[left])-ord('a')+1)*power[(right-left+1)-1])%MOD
                left += 1
            if right-left+1 == 0:
                return -1
            dp[right+1] = dp[(right-(right-left+1))+1]+1
        return dp[-1]


",n + w * l
"import collections


class AhoNode(object):
    def __init__(self):
        self.children = collections.defaultdict(AhoNode)
        self.suffix = None
        self.length = 0 


class AhoTrie(object):

    def step(self, letter):
        while self.__node and letter not in self.__node.children:
            self.__node = self.__node.suffix
        self.__node = self.__node.children[letter] if self.__node else self.__root
        return self.__get_ac_node_outputs(self.__node)
    
    def __init__(self, patterns):
        self.__root = self.__create_ac_trie(patterns)
        self.__node = self.__create_ac_suffix_and_output_links(self.__root)
    
    def __create_ac_trie(self, patterns): 
        root = AhoNode()
        for i, pattern in enumerate(patterns):
            node = root
            for l, c in enumerate(pattern, 1): 
                node = node.children[c]
                node.length = l 
        return root

    def __create_ac_suffix_and_output_links(self, root): 
        queue = collections.deque()
        for node in root.children.values():
            queue.append(node)
            node.suffix = root

        while queue:
            node = queue.popleft()
            for c, child in node.children.items():
                queue.append(child)
                suffix = node.suffix
                while suffix and c not in suffix.children:
                    suffix = suffix.suffix
                child.suffix = suffix.children[c] if suffix else root
                
        return root

    def __get_ac_node_outputs(self, node): 
        return node.length 



class Solution2(object):
    def minValidStrings(self, words, target):
        trie = AhoTrie(words)
        dp = [0]*(len(target)+1)
        for i in range(len(target)):
            l = trie.step(target[i])
            if not l:
                return -1
            dp[i+1] = dp[(i-l)+1]+1
        return dp[-1]


",n + w * l
"
class Solution3(object):
    def minValidStrings(self, words, target):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern, callback):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                callback(i, j)
                if j+1 == len(pattern):
                    j = prefix[j]

        def update(i, j):
            lookup[i] = max(lookup[i], j+1)

        lookup = [0]*len(target)
        for w in words:
            KMP(target, w, update)
        dp = [0]*(len(target)+1)
        for i in range(len(target)):
            if not lookup[i]:
                return -1
            dp[i+1] = dp[(i-lookup[i])+1]+1
        return dp[-1]


",w * (l + n)
"
class Solution4(object):
    def minValidStrings(self, words, target):
        class Trie(object):
            def __init__(self):
                self.__nodes = []
                self.__new_node()
            
            def __new_node(self):
                self.__nodes.append([-1]*26)
                return len(self.__nodes)-1

            def add(self, w):
                curr = 0
                for c in w:
                    x = ord(c)-ord('a')
                    if self.__nodes[curr][x] == -1:
                        self.__nodes[curr][x] = self.__new_node()
                    curr = self.__nodes[curr][x]
            
            def query(self, target, i):
                curr = 0
                for l in range(len(target)-i):
                    x = ord(target[i+l])-ord('a')
                    if self.__nodes[curr][x] == -1:
                        return l
                    curr = self.__nodes[curr][x]
                return len(target)-i

        trie = Trie()
        for w in words:
            trie.add(w)
        lookup = [0]*len(target)
        for i in range(len(target)):
            l = trie.query(target, i)
            for nl in range(1, l+1):
                lookup[i+nl-1] = max(lookup[i+nl-1], nl)
        dp = [0]*(len(target)+1)
        for i in range(len(target)):
            if not lookup[i]:
                return -1
            dp[i+1] = dp[(i-lookup[i])+1]+1
        return dp[-1]
",w * l + n * l
"

class Solution(object):
    def createBinaryTree(self, descriptions):
        nodes = {}
        children = set()
        for p, c, l in descriptions:
            parent = nodes.setdefault(p, TreeNode(p))
            child = nodes.setdefault(c, TreeNode(c))
            if l:
                parent.left = child
            else:
                parent.right = child
            children.add(c)
        return nodes[next(p for p in nodes.keys() if p not in children)]
",n
"

class Solution(object):
    def mostExpensiveItem(self, primeOne, primeTwo):
        return primeOne*primeTwo-primeOne-primeTwo


",1
"
class Solution2(object):
    def mostExpensiveItem(self, primeOne, primeTwo):
        dp = [False]*max(primeOne, primeTwo)
        dp[0] = True
        result = 1
        for i in range(2, primeOne*primeTwo):
            dp[i%len(dp)] = dp[(i-primeOne)%len(dp)] or dp[(i-primeTwo)%len(dp)]
            if not dp[i%len(dp)]:
                result = i
        return result
",p1 * p2
"

class Solution(object):
    def satisfiesConditions(self, grid):
        return (all(grid[i][j] == grid[i+1][j] for j in range(len(grid[0])) for i in range(len(grid)-1)) and 
                all(grid[0][j] != grid[0][j+1] for j in range(len(grid[0])-1)))
",m * n
"
import itertools


class Solution(object):
    def numTilings(self, N):
        M = int(1e9+7)

        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) % M \
                     for col in ZB] for row in A]

        T = [[1, 0, 0, 1], 
             [1, 0, 1, 0], 
             [1, 1, 0, 0], 
             [1, 1, 1, 0]] 

        return matrix_mult([[1, 0, 0, 0]], matrix_expo(T, N))[0][0]


",logn
"class Solution2(object):
    def numTilings(self, N):
        M = int(1e9+7)
        dp = [1, 1, 2]
        for i in range(3, N+1):
            dp[i%3] = (2*dp[(i-1)%3]%M + dp[(i-3)%3])%M
        return dp[N%3]
",n
"

class Solution(object):
    def isValid(self, word):
        VOWELS = ""aeiou""

        if len(word) < 3:
            return False
        vowel = consonant = False
        for x in word:
            if x.isalpha():
                if x.lower() in VOWELS:
                    vowel = True
                else:
                    consonant = True
            elif not x.isdigit():
                return False
        return vowel and consonant
",n
"
import collections



class Solution(object):
    def maximumSubarraySum(self, nums, k):
        prefix = collections.defaultdict(lambda: float(""inf""))
        curr = 0
        result = float(""-inf"")
        for x in nums:
            prefix[x] = min(prefix[x], curr)
            curr += x
            result = max(result, curr-prefix[x-k], curr-prefix[x+k])
        return result if result != float(""-inf"") else 0
",n
"

class Solution(object):
    def nearestExit(self, maze, entrance):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        visited = ' '
        entrance = tuple(entrance)
        left = set([entrance])
        right = set([(r, 0) for r in range(len(maze)-1) if maze[r][0] == '.' and (r, 0) != entrance] +
                    [(len(maze)-1, c) for c in range(len(maze[0])-1) if maze[len(maze)-1][c] == '.' and (len(maze)-1, c) != entrance] +
                    [(r, len(maze[0])-1) for r in reversed(range(1, len(maze))) if maze[r][len(maze[0])-1] == '.' and (r, len(maze[0])-1) != entrance] +
                    [(0, c) for c in reversed(range(1, len(maze[0]))) if maze[0][c] == '.' and (0, c) != entrance])
        steps = 0
        while left:
            for (r, c) in left:
                maze[r][c] = visited
            new_left = set()
            for (r, c) in left:
                if (r, c) in right: 
                    return steps
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 <= nr < len(maze) and
                            0 <= nc < len(maze[0]) and
                            maze[nr][nc] == '.'):
                        continue
                    new_left.add((nr, nc))
            left = new_left
            steps += 1
            if len(left) > len(right): 
                left, right = right, left
        return -1


",m * n
"
class Solution2(object):
    def nearestExit(self, maze, entrance):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        visited = ' '
        entrance = tuple(entrance)
        maze[entrance[0]][entrance[1]] = visited
        q = [(entrance, 0)]
        while q:
            new_q = []
            for (r, c), step in q:
                if (r, c) != entrance and \
                   (r in (0, len(maze)-1) or c in (0, len(maze[0])-1)):
                    return step
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 <= nr < len(maze) and
                            0 <= nc < len(maze[0]) and
                            maze[nr][nc] == '.'):
                        continue
                    maze[nr][nc] = visited
                    q.append(((nr, nc), step+1))
            q = new_q
        return -1
",m * n
"
class Solution(object):
    def getMinSwaps(self, num, k):
        def next_permutation(nums, begin, end):
            def reverse(nums, begin, end):
                left, right = begin, end-1
                while left < right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 1
                    right -= 1

            k, l = begin-1, begin
            for i in reversed(range(begin, end-1)):
                if nums[i] < nums[i+1]:
                    k = i
                    break
            else:
                reverse(nums, begin, end)
                return False
            for i in reversed(range(k+1, end)):
                if nums[i] > nums[k]:
                    l = i
                    break
            nums[k], nums[l] = nums[l], nums[k]
            reverse(nums, k+1, end)
            return True
        
        new_num = list(num)
        while k:
            next_permutation(new_num, 0, len(new_num))
            k -= 1
        result = 0
        for i in range(len(new_num)):
            if new_num[i] == num[i]:
                continue
            for j in range(i+1, len(new_num)):
                if new_num[j] == num[i]:
                    break
            result += j-i
            for j in reversed(range(i+1, j+1)):
                new_num[j], new_num[j-1] = new_num[j-1], new_num[j]
        return result
",(k + n) * n
"
class Solution(object):
    def findLUSlength(self, strs):
        def isSubsequence(a, b):
            i = 0
            for j in range(len(b)):
                if i >= len(a):
                    break
                if a[i] == b[j]:
                    i += 1
            return i == len(a)

        strs.sort(key=len, reverse=True)
        for i in range(len(strs)):
            all_of = True
            for j in range(len(strs)):
                if len(strs[j]) < len(strs[i]):
                    break
                if i != j and isSubsequence(strs[i], strs[j]):
                    all_of = False
                    break
            if all_of:
                return len(strs[i])
        return -1

",l * n^2
"
class Solution(object):
    def smallestMissingValueSubtree(self, parents, nums):
        def iter_dfs(adj, nums, i, lookup):
            stk = [i]
            while stk:
                i = stk.pop()
                if nums[i] in lookup:
                    continue
                lookup.add(nums[i])
                for j in adj[i]:
                    stk.append(j)

        result = [1]*len(parents)
        i = next((i for i in range(len(nums)) if nums[i] == 1), -1)
        if i == -1:
            return result
        adj = [[] for _ in range(len(parents))]
        for j in range(1, len(parents)):
            adj[parents[j]].append(j)
        lookup = set()
        miss = 1
        while i >= 0:
            iter_dfs(adj, nums, i, lookup)
            while miss in lookup:
                miss += 1
            result[i] = miss
            i = parents[i]
        return result
",n
"

class Solution(object):
    def minimumSplits(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result, g = 1, 0
        for x in nums:
            g = gcd(g, x)
            if g == 1:
                g = x
                result += 1
        return result
",nlogr
"
class Solution(object):
    def mergeAlternately(self, word1, word2):
        result = []
        i = 0
        while i < len(word1) or i < len(word2):
            if i < len(word1):
                result.append(word1[i])
            if i < len(word2):
                result.append(word2[i])
            i += 1
        return """".join(result)
",m + n
"
class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n
        self.size = [1]*n
        self.total = n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        self.size[y] += self.size[x]
        self.total -= 1
        return True



class Solution(object):
    def groupStrings(self, words):
        uf = UnionFind(len(words))
        lookup = {}
        for i, x in enumerate(words):
            mask = reduce(lambda x, y: x|(1<<(ord(y)-ord('a'))), x, 0)
            if mask not in lookup:
                lookup[mask] = i
            uf.union_set(i, lookup[mask])
            bit = 1
            while bit <= mask:
                if mask&bit:
                    if mask^bit not in lookup:
                        lookup[mask^bit] = i
                    uf.union_set(i, lookup[mask^bit])
                bit <<= 1
        return [uf.total, max(uf.size)]
",26 * n
"
import collections


class Solution(object):
    def numSquarefulPerms(self, A):
        def dfs(candidate, x, left, count, result):
            count[x] -= 1
            if left == 0:
                result[0] += 1
            for y in candidate[x]:
                if count[y]:
                    dfs(candidate, y, left-1, count, result)
            count[x] += 1

        count = collections.Counter(A)
        candidate = {i: {j for j in count if int((i+j)**0.5) ** 2 == i+j} 
                           for i in count}

        result = [0]
        for x in count:
            dfs(candidate, x, len(A)-1, count, result)
        return result[0]
",n!
"
import bisect



class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda _: 0,
                 query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                 update_fn=lambda x: x):
        self.tree = [None]*(2*2**((N-1).bit_length()))
        self.base = len(self.tree)//2
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

    def update(self, i, h):
        x = self.base+i
        self.tree[x] = self.update_fn(h)
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

    def query(self, L, R):
        if L > R:
            return 0
        L += self.base
        R += self.base
        left = right = None
        while L <= R:
            if L & 1:
                left = self.query_fn(left, self.tree[L])
                L += 1
            if R & 1 == 0:
                right = self.query_fn(self.tree[R], right)
                R -= 1
            L //= 2
            R //= 2
        return self.query_fn(left, right)



class Solution(object):
    def lengthOfLIS(self, nums, k):
        sorted_nums = sorted({x-1 for x in nums})
        num_to_idx = {x:i for i, x in enumerate(sorted_nums)}
        st = SegmentTree(len(num_to_idx))
        for x in nums:
            x -= 1
            st.update(num_to_idx[x], st.query(bisect.bisect_left(sorted_nums, x-k), num_to_idx[x]-1)+1)
        return st.tree[1] 
",nlogn
"
class Solution(object):
    def reverseVowels(self, s):
        vowels = ""aeiou""
        string = list(s)
        i, j = 0, len(s) - 1
        while i < j:
            if string[i].lower() not in vowels:
                i += 1
            elif string[j].lower() not in vowels:
                j -= 1
            else:
                string[i], string[j] = string[j], string[i]
                i += 1
                j -= 1
        return """".join(string)

",n
"
import pandas as pd



def Solution(players: pd.DataFrame) -> List[int]:
    return list(players.shape)
",1
"

class Solution(object):
    def maximumMinimumPath(self, A):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        def check(A, val, r, c, lookup):
            if r == len(A)-1 and c == len(A[0])-1:
                return True
            lookup.add((r, c))
            for d in directions:
                nr, nc = r + d[0], c + d[1]
                if 0 <= nr < len(A) and \
                   0 <= nc < len(A[0]) and \
                   (nr, nc) not in lookup and \
                   A[nr][nc] >= val and \
                   check(A, val, nr, nc, lookup):
                    return True
            return False
        
        vals, ceil = [], min(A[0][0], A[-1][-1])
        for i in range(len(A)):
            for j in range(len(A[0])):
                if A[i][j] <= ceil:
                    vals.append(A[i][j])
        vals = list(set(vals))
        vals.sort()
        left, right = 0, len(vals)-1
        while left <= right:
            mid = left + (right-left)//2
            if not check(A, vals[mid], 0, 0, set()):
                right = mid-1
            else:
                left = mid+1
        return vals[right]


",m * n * log(m * n)
"import heapq



class Solution2(object):
    def maximumMinimumPath(self, A):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        max_heap = [(-A[0][0], 0, 0)]
        lookup = set([(0, 0)])
        while max_heap:
            i, r, c = heapq.heappop(max_heap)
            if r == len(A)-1 and c == len(A[0])-1:
                return -i
            for d in directions:
                nr, nc = r+d[0], c+d[1]
                if 0 <= nr < len(A) and \
                   0 <= nc < len(A[0]) and \
                   (nr, nc) not in lookup:
                    heapq.heappush(max_heap, (-min(-i, A[nr][nc]), nr, nc))
                    lookup.add((nr, nc))    
        return -1
",m * n * log(m * n)
"
class Solution(object):
    def maxTotalFruits(self, fruits, startPos, k):
        max_pos = max(startPos, fruits[-1][0])
        cnt = [0]*(1+max_pos)
        for p, a in fruits:
            cnt[p] = a
        prefix = [0]
        for x in cnt:
            prefix.append(prefix[-1]+x)
        result = 0
        for left_dist in range(min(startPos, k)+1):
            right_dist = max(k-2*left_dist, 0)            
            left, right = startPos-left_dist, min(startPos+right_dist, max_pos)
            result = max(result, prefix[right+1]-prefix[left])
        for right_dist in range(min(max_pos-startPos, k)+1):
            left_dist = max(k-2*right_dist, 0) 
            left, right = max(startPos-left_dist, 0), startPos+right_dist
            result = max(result, prefix[right+1]-prefix[left])
        return result
",n
"

class Solution(object):
    def subStrHash(self, s, power, modulo, k, hashValue):
        h, idx = 0, -1
        pw = pow(power, k-1, modulo)
        for i in reversed(range(len(s))):
            if i+k < len(s):
                h = (h-(ord(s[i+k])-ord('a')+1)*pw)%modulo
            h = (h*power+(ord(s[i])-ord('a')+1))%modulo
            if h == hashValue:
                idx = i
        return s[idx:idx+k]
",n
"
class Solution(object):
    def minOperations(self, s):
        cnt = sum(int(c) == i%2 for i, c in enumerate(s))
        return min(cnt, len(s)-cnt)
",n
"
class Solution(object):
    def thirdMax(self, nums):
        count = 0
        top = [float(""-inf"")] * 3
        for num in nums:
            if num > top[0]:
                top[0], top[1], top[2] = num, top[0], top[1]
                count += 1
            elif num != top[0] and num > top[1]:
                top[1], top[2] = num, top[1]
                count += 1
            elif num != top[0] and num != top[1] and num >= top[2]:
                top[2] = num
                count += 1

        if count < 3:
            return top[0]

        return top[2]

",n
"

class Solution(object):
    def checkArray(self, nums, k):
        curr = 0
        for i, x in enumerate(nums):
            if x-curr < 0:
                return False
            nums[i] -= curr
            curr += nums[i]
            if i-(k-1) >= 0:
                curr -= nums[i-(k-1)]
        return curr == 0
",n
"
import collections


class Solution(object):
    def getFolderNames(self, names):
        count = collections.Counter()
        result, lookup = [], set()
        for name in names:
            while True:
                name_with_suffix = ""{}({})"".format(name, count[name]) if count[name] else name
                count[name] += 1
                if name_with_suffix not in lookup:
                    break
            result.append(name_with_suffix)
            lookup.add(name_with_suffix)
        return result
",n
"
import collections



class Solution(object):
    def findMinStep(self, board, hand):
        def shrink(s): 
            while True:
                i = 0
                for start in range(len(s)):
                    while i < len(s) and s[start] == s[i]:
                        i += 1
                    if i-start >= 3:
                        s = s[0:start]+s[i:]
                        break
                else:
                    break
            return s

        def findMinStepHelper(board, hand, lookup):
            if not board: return 0
            if not hand: return float(""inf"")
            if tuple(hand) in lookup[tuple(board)]: return lookup[tuple(board)][tuple(hand)]

            result = float(""inf"")
            for i in range(len(hand)):
                for j in range(len(board)+1):
                    next_board = shrink(board[0:j] + hand[i:i+1] + board[j:])
                    next_hand = hand[0:i] + hand[i+1:]
                    result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1)
            lookup[tuple(board)][tuple(hand)] = result
            return result

        lookup = collections.defaultdict(dict)
        board, hand = list(board), list(hand)
        result = findMinStepHelper(board, hand, lookup)
        return -1 if result == float(""inf"") else result


",(b+h)^2 * h!*(b+h-1)!/(b-1)!
"import collections



class Solution_TLE(object):
    def findMinStep(self, board, hand):
        def shrink(s): 
            stack = []
            start = 0
            for i in range(len(s)+1):
                if i == len(s) or s[i] != s[start]:
                    if stack and stack[-1][0] == s[start]:
                        stack[-1][1] += i - start
                        if stack[-1][1] >= 3:
                            stack.pop()
                    elif s and i - start < 3:
                        stack += [s[start], i - start],
                    start = i
            result = []
            for p in stack:
                result += [p[0]] * p[1]
            return result

        def findMinStepHelper(board, hand, lookup):
            if not board: return 0
            if not hand: return float(""inf"")
            if tuple(hand) in lookup[tuple(board)]: return lookup[tuple(board)][tuple(hand)]

            result = float(""inf"")
            for i in range(len(hand)):
                for j in range(len(board)+1):
                    next_board = shrink(board[0:j] + hand[i:i+1] + board[j:])
                    next_hand = hand[0:i] + hand[i+1:]
                    result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1)
            lookup[tuple(board)][tuple(hand)] = result
            return result

        lookup = collections.defaultdict(dict)
        board, hand = list(board), list(hand)
        result = findMinStepHelper(board, hand, lookup)
        return -1 if result == float(""inf"") else result


",(b+h) * h!*(b+h-1)!/(b-1)!
"import collections



class Solution_GREEDY_ACCEPT_BUT_NOT_PROVED(object):
    def findMinStep(self, board, hand):
        def shrink(s): 
            stack = []
            start = 0
            for i in range(len(s)+1):
                if i == len(s) or s[i] != s[start]:
                    if stack and stack[-1][0] == s[start]:
                        stack[-1][1] += i - start
                        if stack[-1][1] >= 3:
                            stack.pop()
                    elif s and i - start < 3:
                        stack += [s[start], i - start],
                    start = i
            result = []
            for p in stack:
                result += [p[0]] * p[1]
            return result

        def findMinStepHelper2(board, hand, lookup):
            result = float(""inf"")
            for i in range(len(hand)):
                for j in range(len(board)+1):
                    next_board = shrink(board[0:j] + hand[i:i+1] + board[j:])
                    next_hand = hand[0:i] + hand[i+1:]
                    result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1)
            return result

        def find(board, c, j):
            for i in range(j, len(board)):
                if board[i] == c:
                    return i
            return -1

        def findMinStepHelper(board, hand, lookup):
            if not board: return 0
            if not hand: return float(""inf"")
            if tuple(hand) in lookup[tuple(board)]: return lookup[tuple(board)][tuple(hand)]

            result = float(""inf"")
            for i in range(len(hand)):
                j = 0
                while j < len(board):
                    k = find(board, hand[i], j)
                    if k == -1:
                        break

                    if k < len(board) - 1 and board[k] == board[k+1]:
                        next_board = shrink(board[0:k] + board[k+2:])
                        next_hand = hand[0:i] + hand[i+1:]
                        result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1)
                        k += 1
                    elif i > 0 and hand[i] == hand[i-1]:
                        next_board = shrink(board[0:k] + board[k+1:])
                        next_hand = hand[0:i-1] + hand[i+1:]
                        result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 2)
                    j = k+1

            lookup[tuple(board)][tuple(hand)] = result
            return result
        
        board, hand = list(board), list(hand)
        hand.sort()
        result = findMinStepHelper(board, hand, collections.defaultdict(dict))
        if result == float(""inf""):
            result = findMinStepHelper2(board, hand, collections.defaultdict(dict))
        return -1 if result == float(""inf"") else result


",(b * h) * b * b! * h!
"

class Solution_WRONG_GREEDY_AND_NOT_ACCEPT_NOW(object):
    def findMinStep(self, board, hand):
        def shrink(s): 
            stack = []
            start = 0
            for i in range(len(s)+1):
                if i == len(s) or s[i] != s[start]:
                    if stack and stack[-1][0] == s[start]:
                        stack[-1][1] += i - start
                        if stack[-1][1] >= 3:
                            stack.pop()
                    elif s and i - start < 3:
                        stack += [s[start], i - start],
                    start = i
            result = []
            for p in stack:
                result += [p[0]] * p[1]
            return result

        def find(board, c, j):
            for i in range(j, len(board)):
                if board[i] == c:
                    return i
            return -1

        def findMinStepHelper(board, hand, lookup):
            if not board: return 0
            if not hand: return float(""inf"")
            if tuple(hand) in lookup[tuple(board)]: return lookup[tuple(board)][tuple(hand)]

            result = float(""inf"")
            for i in range(len(hand)):
                j = 0
                while j < len(board):
                    k = find(board, hand[i], j)
                    if k == -1:
                        break

                    if k < len(board) - 1 and board[k] == board[k+1]:
                        next_board = shrink(board[0:k] + board[k+2:])
                        next_hand = hand[0:i] + hand[i+1:]
                        result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1)
                        k += 1
                    elif i > 0 and hand[i] == hand[i-1]:
                        next_board = shrink(board[0:k] + board[k+1:])
                        next_hand = hand[0:i-1] + hand[i+1:]
                        result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 2)
                    j = k+1

            lookup[tuple(board)][tuple(hand)] = result
            return result

        lookup = collections.defaultdict(dict)
        board, hand = list(board), list(hand)
        hand.sort()
        result = findMinStepHelper(board, hand, lookup)
        return -1 if result == float(""inf"") else result
",b * b! * h!
"
class Solution(object):
    def countDigitOne(self, n):
        DIGIT = 1
        is_zero = int(DIGIT == 0)
        result = is_zero
        base = 1
        while n >= base:
            result += (n//(10*base)-is_zero)*base + \
                      min(base, max(n%(10*base) - DIGIT*base + 1, 0))
            base *= 10
        return result

",logn
"
import collections


class Solution(object):
    def minimumSemesters(self, N, relations):
        g = collections.defaultdict(list)
        in_degree = [0]*N
        for x, y in relations:
            g[x-1].append(y-1)
            in_degree[y-1] += 1
        q = collections.deque([(1, i) for i in range(N) if not in_degree[i]])

        result = 0
        count = N
        while q:
            level, u = q.popleft()
            count -= 1
            result = level
            for v in g[u]:
                in_degree[v] -= 1
                if not in_degree[v]:
                    q.append((level+1, v))
        return result if count == 0 else -1
",|V| + |E|
"
import collections


class Solution(object):
    def stoneGameIX(self, stones):
        count = collections.Counter(x%3 for x in stones)
        if count[0]%2 == 0:
            return count[1] and count[2]
        return abs(count[1]-count[2]) >= 3  
",n
"
class Solution(object):
    def hammingDistance(self, x, y):
        distance = 0
        z = x ^ y
        while z:
            distance += 1
            z &= z - 1
        return distance

    def hammingDistance2(self, x, y):
        return bin(x ^ y).count('1')

",1
"

class Solution(object):
    def isOneBitCharacter(self, bits):
        parity = 0
        for i in reversed(range(len(bits)-1)):
            if bits[i] == 0:
                break
            parity ^= bits[i]
        return parity == 0

",n
"
import itertools


class Solution(object):
    def sortSentence(self, s):
        words = s.split()
        for i in range(len(words)):
            while int(words[i][-1])-1 != i:
                words[int(words[i][-1])-1], words[i] = words[i], words[int(words[i][-1])-1]
        return "" "".join(map(lambda x: x[:-1], words))
",n
"
import collections



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def verticalTraversal(self, root):
        def dfs(node, lookup, x, y):
            if not node:
                return
            lookup[x][y].append(node)
            dfs(node.left, lookup, x-1, y+1)
            dfs(node.right, lookup, x+1, y+1)
                
        lookup = collections.defaultdict(lambda: collections.defaultdict(list))
        dfs(root, lookup, 0, 0)

        result = []
        for x in sorted(lookup):
            report = []
            for y in sorted(lookup[x]):
                report.extend(sorted(node.val for node in lookup[x][y]))
            result.append(report)
        return result
",nlogn
"

class Solution(object):
    def fixedRatio(self, s, num1, num2):
        lookup = collections.Counter()
        lookup[0] = 1
        result = curr = 0
        for c in s:
            curr += -num2 if c == '0' else +num1
            result += lookup[curr]
            lookup[curr] += 1
        return result
",n
"

class Solution(object):
    def maximumANDSum(self, nums, numSlots):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 
    
        return -hungarian([[-((nums[i] if i < len(nums) else 0) & (1+x//2)) for x in range(2*numSlots)] for i in range(2*numSlots)])[0]


",n^3
"from scipy.optimize import linear_sum_assignment as hungarian
import itertools



class Solution2(object):
    def maximumANDSum(self, nums, numSlots):
        adj = [[-((nums[i] if i < len(nums) else 0) & (1+x//2)) for x in range(2*numSlots)] for i in range(2*numSlots)]
        return -sum(adj[i][j] for i, j in zip(*hungarian(adj)))    


",n^3
"
class Solution3(object):
    def maximumANDSum(self, nums, numSlots):
        def count(x):
            result = 0
            while x:
                result += x%3
                x //= 3
            return result

        dp = [0]*(3**numSlots)
        for mask in range(1, len(dp)):
            i = count(mask)-1
            x = nums[i] if i < len(nums) else 0
            base = 1
            for slot in range(1, numSlots+1):
                if mask//base%3:
                    dp[mask] = max(dp[mask], (x&slot)+dp[mask-base])
                base *= 3
        return dp[-1]


",n * 3^n
"
class Solution4(object):
    def maximumANDSum(self, nums, numSlots):
        def memoiztion(i, mask): 
            if lookup[mask] != -1:
                return lookup[mask]
            x = nums[i] if i < len(nums) else 0
            base = 1
            for slot in range(1, numSlots+1):
                if mask//base%3:
                     lookup[mask] = max(lookup[mask], (x&slot)+memoiztion(i-1, mask-base))
                base *= 3
            return lookup[mask]
        
        lookup = [-1]*(3**numSlots)
        lookup[0] = 0
        return memoiztion(2*numSlots-1, 3**numSlots-1)
",n * 3^n
"
class Solution(object):
    def canFormArray(self, arr, pieces):
        lookup = {x[0]: i for i, x in enumerate(pieces)}
        i = 0
        while i < len(arr): 
            if arr[i] not in lookup:
                return False
            for c in pieces[lookup[arr[i]]]:
                if i == len(arr) or arr[i] != c:
                    return False
                i += 1
        return True 
",n
"
class ListNode(object):
    def __init__(self, val=0, next=None):
        pass



class Solution(object):
    def removeNodes(self, head):
        stk = []
        while head:
            while stk and stk[-1].val < head.val:
                stk.pop()
            if stk:
                stk[-1].next = head
            stk.append(head)
            head = head.__next__
        return stk[0]
",n
"
class Solution(object):
    def countLetters(self, S):
        result = len(S)
        left = 0
        for right in range(1, len(S)):
            if S[right] == S[left]:
                result += right-left
            else:
                left = right
        return result
",n
"

class Solution(object):
    def resultArray(self, nums, k):
        result = [0]*k
        dp = [0]*k
        for x in nums:
            new_dp = [0]*k
            new_dp[x%k] += 1
            for i, c in enumerate(dp):
                new_dp[i*x%k] += c
            for i, c in enumerate(new_dp):
                result[i] += c 
            dp = new_dp
        return result
",n * k
"
import operator
from functools import reduce


class Solution(object):
    def nimGame(self, piles):
        return reduce(operator.xor, piles, 0)
",n
"

class Solution(object):
    def maxValue(self, nums, k):
        INF = float(""inf"")
        MAX_MASK = 127
        def is_submask(a, b):
            return (a|b) == b

        def dp(direction, npos):
            result = [npos]*(MAX_MASK+1)
            dp = [INF]*(MAX_MASK+1)
            cnt = [0]*(MAX_MASK+1)
            for i in direction(range(len(nums))):
                dp[nums[i]] = 1
                for mask in range(MAX_MASK+1):
                    if is_submask(nums[i], mask):
                        cnt[mask] += 1
                    dp[mask|nums[i]] = min(dp[mask|nums[i]], dp[mask]+1)
                for mask in range(MAX_MASK+1):
                    if cnt[mask] >= k and dp[mask] <= k and result[mask] == npos:
                        result[mask] = i
            return result

        left = dp(lambda x: x, len(nums))
        right = dp(reversed, -1)
        return next(result for result in reversed(range(MAX_MASK+1)) for l in range(1, MAX_MASK+1) if left[l] < right[result^l])


",n * r + r^2
"
class Solution(object):
    def maxValue(self, nums, k):
        left = [[set() if j else {0} for j in range(k+1)] for i in range(len(nums)+1)]
        for i in range(len(nums)):
            for j in range(1, len(left[i+1])):
                left[i+1][j] = set(left[i][j])
                for x in left[i][j-1]:
                    left[i+1][j].add(x|nums[i])
        right = [[set() if j else {0} for j in range(k+1)] for i in range(len(nums)+1)]
        for i in reversed(range(len(nums))):
            for j in range(1, len(right[i])):
                right[i][j] = set(right[i+1][j])
                for x in right[i+1][j-1]:
                    right[i][j].add(x|nums[i])
        return max(l^r for i in range(k, (len(nums)-k)+1) for l in left[i][k] for r in right[i][k])
",n * k * r + n * r^2
"
import operator


class Solution(object):
    def calculate(self, s):
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(ops[operators.pop()](left, right))

        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
        precedence = {'+':0, '-':0, '*':1, '/':1}
        operands, operators, operand = [], [], 0
        for i in range(len(s)):
            if s[i].isdigit():
                operand = operand*10 + int(s[i])
                if i == len(s)-1 or not s[i+1].isdigit():
                    operands.append(operand)
                    operand = 0
            elif s[i] == '(':
                operators.append(s[i])
            elif s[i] == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif s[i] in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] >= precedence[s[i]]:
                    compute(operands, operators)
                operators.append(s[i])
        while operators:
            compute(operands, operators)
        return operands[-1]


",n
"class Solution2(object):
    def calculate(self, s):
        operands, operators = [], []
        operand = """"
        for i in reversed(range(len(s))):
            if s[i].isdigit():
                operand += s[i]
                if i == 0 or not s[i-1].isdigit():
                    operands.append(int(operand[::-1]))
                    operand = """"
            elif s[i] == ')' or s[i] == '*' or s[i] == '/':
                operators.append(s[i])
            elif s[i] == '+' or s[i] == '-':
                while operators and \
                      (operators[-1] == '*' or operators[-1] == '/'):
                    self.compute(operands, operators)
                operators.append(s[i])
            elif s[i] == '(':
                while operators[-1] != ')':
                    self.compute(operands, operators)
                operators.pop()

        while operators:
            self.compute(operands, operators)

        return operands[-1]

    def compute(self, operands, operators):
        left, right = operands.pop(), operands.pop()
        op = operators.pop()
        if op == '+':
            operands.append(left + right)
        elif op == '-':
            operands.append(left - right)
        elif op == '*':
            operands.append(left * right)
        elif op == '/':
            operands.append(left / right)

",n
"
class Solution(object):
    def findJudge(self, N, trust):
        degrees = [0]*N
        for i, j in trust:
            degrees[i-1] -= 1
            degrees[j-1] += 1
        for i in range(len(degrees)):
            if degrees[i] == N-1:
                return i+1
        return -1
",t + n
"

class Solution(object):
    def findWinningPlayer(self, skills, k):
        result = cnt = 0
        for i in range(1, len(skills)):
            if skills[result] < skills[i]:
                result = i
                cnt = 0
            cnt += 1
            if cnt == k:
                return result
        return result
",n
"
import collections


class Solution(object):
    def minSteps(self, s, t):
        diff = collections.Counter(s) - collections.Counter(t)
        return sum(diff.values())
",n
"

class Solution(object):
    def wordPattern(self, pattern, str):
        if len(pattern) != self.wordCount(str):
            return False

        w2p, p2w = {}, {}
        for p, w in zip(pattern, self.wordGenerator(str)):
            if w not in w2p and p not in p2w:
                w2p[w] = p
                p2w[p] = w
            elif w not in w2p or w2p[w] != p:
                return False
        return True

    def wordCount(self, str):
        cnt = 1 if str else 0
        for c in str:
            if c == ' ':
                cnt += 1
        return cnt

    def wordGenerator(self, str):
        w = """"
        for c in str:
            if c == ' ':
                yield w
                w = """"
            else:
                w += c
        yield w


",n
"class Solution2(object):
    def wordPattern(self, pattern, str):
        words = str.split() 
        if len(pattern) != len(words):
            return False

        w2p, p2w = {}, {}
        for p, w in zip(pattern, words):
            if w not in w2p and p not in p2w:
                w2p[w] = p
                p2w[p] = w
            elif w not in w2p or w2p[w] != p:
                return False
        return True

",n
"
import itertools
from functools import reduce



class Solution(object):
    def maximumCost(self, n, highways, k):
        if k+1 > n: 
            return -1
        adj = [[] for _ in range(n)]
        for c1, c2, t in highways:
            adj[c1].append((c2, t))
            adj[c2].append((c1, t))
        result = -1 if k != 1 else 0
        dp = [[0, []] for _ in range((1<<n))]
        for i in range(n):
            dp[1<<i][1].append(i)
        for cnt in range(1, n+1):
            for choice in itertools.combinations(range(n), cnt):
                mask = reduce(lambda x, y:x|(1<<y), choice, 0)
                total, lasts = dp[mask]
                for u in lasts:
                    for v, t in adj[u]:
                        if mask&(1<<v):
                            continue
                        new_mask = mask|(1<<v)
                        if total+t < dp[new_mask][0]:
                            continue
                        if total+t == dp[new_mask][0]:
                            dp[new_mask][1].append(v)
                            continue
                        dp[new_mask][0] = total+t
                        dp[new_mask][1] = [v]
                        if bin(mask).count('1') == k:
                            result = max(result, dp[new_mask][0])
        return result


",n^2 * 2^n
"
class Solution2(object):
    def maximumCost(self, n, highways, k):
        if k+1 > n: 
            return -1
        adj = [[] for _ in range(n)]
        for c1, c2, t in highways:
            adj[c1].append((c2, t))
            adj[c2].append((c1, t))
        result = -1
        dp = [(u, 1<<u, 0) for u in range(n)]
        while dp:
            new_dp = []
            for u, mask, total in dp:
                if bin(mask).count('1') == k+1:
                    result = max(result, total)
                for v, t in adj[u]:
                    if mask&(1<<v) == 0:
                        new_dp.append((v, mask|(1<<v), total+t))
            dp = new_dp
        return result
",n^2 * 2^n
"

class Solution(object):
    def numOfUnplacedFruits(self, fruits, baskets):
        class SegmentTree(object):
            def __init__(self, N,
                        build_fn=lambda _: 0,
                        query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                        update_fn=lambda x: x):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def binary_search(self, x):
                if self.tree[1] < x:
                    return -1
                i = 1
                while not i >= self.base:
                    if self.tree[2*i] >= x:
                        i = 2*i
                    else:
                        i = 2*i+1
                return i-self.base

        def build(i):
            return baskets[i]

        st = SegmentTree(len(baskets), build_fn=build)
        result = 0
        for x in fruits:
            i = st.binary_search(x)
            if i == -1:
                result += 1
            else:
                st.update(i, 0)
        return result


",nlogn
"
class Solution2(object):
    def numOfUnplacedFruits(self, fruits, baskets):
        result = 0
        for x in fruits:
            i = next((i for i in range(len(baskets)) if baskets[i] >= x), -1)
            if i ==-1:
                result += 1
            else:
                baskets[i] = 0
        return result
",n^2
"
class Solution(object):
    lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}

    def isStrobogrammatic(self, num):
        n = len(num)
        for i in range((n+1) / 2):
            if num[n-1-i] not in self.lookup or \
               num[i] != self.lookup[num[n-1-i]]:
                return False
        return True

",n
"
class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def minimumCost(self, N, connections):
        connections.sort(key = lambda x: x[2])
        union_find = UnionFind(N)
        result = 0
        for u, v, val in connections:
            if union_find.union_set(u-1, v-1):
                result += val
        return result if union_find.count == 1 else -1
",nlogn
"
class Solution(object):
    def countOdds(self, low, high):
        return (high+1)//2 - ((low-1)+1)//2
",n
"

class Node(object):
    def __init__(self, val=0, left=None, right=None, next=None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next


class Solution(object):
    def connect(self, root):
        head = root
        pre = Node(0)
        cur = pre
        while root:
            while root:
                if root.left:
                    cur.next = root.left
                    cur = cur.__next__
                if root.right:
                    cur.next = root.right
                    cur = cur.__next__
                root = root.__next__
            root, cur = pre.__next__, pre
            cur.next = None
        return head
",n
"
import collections


class Solution(object):
    def makeEqual(self, words):
        cnt = collections.defaultdict(int)
        for w in words:
            for c in w:
                cnt[c] += 1
        return all(v%len(words) == 0 for v in cnt.values())
",n
"
class Solution(object):
    def reconstructMatrix(self, upper, lower, colsum):
        upper_matrix, lower_matrix = [0]*len(colsum), [0]*len(colsum)
        for i in range(len(colsum)):
            upper_matrix[i] = int(upper > 0 and colsum[i] != 0)
            lower_matrix[i] = colsum[i]-upper_matrix[i]
            upper -= upper_matrix[i]
            lower -= lower_matrix[i]
        return [upper_matrix, lower_matrix] if upper == lower == 0 else []
",n
"
class Solution(object):
    def maxArea(self, h, w, horizontalCuts, verticalCuts):
        def max_len(l, cuts):
            cuts.sort()
            l = max(cuts[0]-0, l-cuts[-1])
            for i in range(1, len(cuts)):
                l = max(l, cuts[i]-cuts[i-1])
            return l

        MOD = 10**9+7
        return max_len(h, horizontalCuts) * max_len(w, verticalCuts) % MOD
",hlogh + wlogw
"
import collections


class Solution(object):
    def subarraysWithKDistinct(self, A, K):
        def atMostK(A, K):
            count = collections.defaultdict(int)
            result, left = 0, 0
            for right in range(len(A)):
                count[A[right]] += 1
                while len(count) > K:
                    count[A[left]] -= 1
                    if count[A[left]] == 0:
                        count.pop(A[left])
                    left += 1
                result += right-left+1
            return result
        
        return atMostK(A, K) - atMostK(A, K-1)


",n
"class Window(object):
    def __init__(self):
        self.__count = collections.defaultdict(int)

    def add(self, x):
        self.__count[x] += 1

    def remove(self, x):
        self.__count[x] -= 1
        if self.__count[x] == 0:
            self.__count.pop(x)
            
    def size(self):
        return len(self.__count)


class Solution2(object):
    def subarraysWithKDistinct(self, A, K):
        window1, window2 = Window(), Window()
        result, left1, left2 = 0, 0, 0
        for i in A:
            window1.add(i)
            while window1.size() > K:
                window1.remove(A[left1])
                left1 += 1
            window2.add(i)
            while window2.size() >= K:
                window2.remove(A[left2])
                left2 += 1
            result += left2-left1
        return result
",n
"
import collections



class Solution(object):
    def destroyTargets(self, nums, space):
        cnt = collections.Counter(x%space for x in nums)
        mx = max(cnt.values())
        return min(x for x in nums if cnt[x%space] == mx)
",n
"
import itertools



class Solution(object):
    def sumSubarrayMins(self, A):
        M = 10**9 + 7

        left, s1 = [0]*len(A), []
        for i in range(len(A)):
            count = 1
            while s1 and s1[-1][0] > A[i]:
                count += s1.pop()[1]
            left[i] = count
            s1.append([A[i], count])

        right, s2 = [0]*len(A), []
        for i in reversed(range(len(A))):
            count = 1
            while s2 and s2[-1][0] >= A[i]:
                count += s2.pop()[1]
            right[i] = count
            s2.append([A[i], count])

        return sum(a*l*r for a, l, r in zip(A, left, right)) % M

",n
"

class Solution(object):
    def isGood(self, nums):
        cnt = [0]*len(nums)
        for x in nums:
            if x < len(cnt):
                cnt[x] += 1
            else:
                return False
        return all(cnt[x] == 1 for x in range(1, len(nums)-1))
",n
"

class Solution(object):
    def calculateScore(self, instructions, values):
        result = 0
        lookup = [False]*len(instructions)
        i = 0
        while 0 <= i < len(instructions):
            if lookup[i]:
                break
            lookup[i] = True
            if instructions[i] == ""add"":
                result += values[i]
                i += 1
            else:
                i += values[i]
        return result
",n
"
class Solution(object):
    def findKthNumber(self, n, k):
        result = 0

        cnts = [0] * 10
        for i in range(1, 10):
            cnts[i] = cnts[i - 1] * 10 + 1

        nums = []
        i = n
        while i:
            nums.append(i % 10)
            i /= 10

        total, target = n, 0
        i = len(nums) - 1
        while i >= 0 and k > 0:
            target = target*10 + nums[i]
            start = int(i == len(nums)-1)
            for j in range(start, 10):
                candidate = result*10 + j
                if candidate < target:
                    num = cnts[i+1]
                elif candidate > target:
                    num = cnts[i]
                else:
                    num = total - cnts[i + 1]*(j-start) - cnts[i]*(9-j)
                if k > num:
                    k -= num
                else:
                    result = candidate
                    k -= 1
                    total = num-1
                    break
            i -= 1

        return result


",logn
"class Solution2(object):
    def findKthNumber(self, n, k):
        def count(n, prefix):
            result, number = 0, 1
            while prefix <= n:
                result += number
                prefix *= 10
                number *= 10
            result -= max(number/10 - (n - prefix/10 + 1), 0)
            return result

        def findKthNumberHelper(n, k, cur, index):
            if cur:
                index += 1
                if index == k:
                    return (cur, index)

            i = int(cur == 0)
            while i <= 9:
                cur = cur * 10 + i
                cnt = count(n, cur)
                if k > cnt + index:
                    index += cnt
                elif cur <= n:
                    result = findKthNumberHelper(n, k, cur, index)
                    if result[0]:
                        return result
                i += 1
                cur /= 10
            return (0, index)

        return findKthNumberHelper(n, k, 0, 0)[0]

",logn * logn
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def getAllElements(self, root1, root2):
        def inorder_gen(root):
            result, stack = [], [(root, False)]
            while stack:
                root, is_visited = stack.pop()
                if root is None:
                    continue
                if is_visited:
                    yield root.val
                else:
                    stack.append((root.right, False))
                    stack.append((root, True))
                    stack.append((root.left, False))
            yield None
        
        result = []
        left_gen, right_gen = inorder_gen(root1), inorder_gen(root2)
        left, right = next(left_gen), next(right_gen)
        while left is not None or right is not None:
            if right is None or (left is not None and left < right):
                result.append(left)
                left = next(left_gen)
            else:
                result.append(right)
                right = next(right_gen)
        return result
  
",n
"
class Solution(object):
    def totalNQueens(self, n):
        def dfs(row):
            if row == n:
                return 1
            result = 0
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                result += dfs(row+1)
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False
            return result

        result = []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        return dfs(0)

",n!
"
import itertools


class Solution(object):
    def busyStudent(self, startTime, endTime, queryTime):
        return sum(s <= queryTime <= e for s, e in zip(startTime, endTime))
",n
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def checkTree(self, root):
        return root.val == root.left.val+root.right.val
",1
"

class Solution(object):
    def punishmentNumber(self, n):
        def backtracking(curr, target):
            if target == 0:
                return curr == 0
            base = 10
            while curr >= base//10:
                q, r = divmod(curr, base)
                if target-r < 0:
                    break
                if backtracking(q, target-r):
                    return True
                base *= 10
            return False
    
        return sum(i**2 for i in range(1, n+1) if backtracking(i**2, i))
",n * (logn)^(2*logn)
"

class Solution(object):
    def numberOfWays(self, corridor):
        MOD = 10**9+7
        result, cnt, j = 1, 0, -1
        for i, x in enumerate(corridor):
            if x != 'S':
                continue
            cnt += 1
            if cnt >= 3 and cnt%2:
                result = result*(i-j)%MOD
            j = i
        return result if cnt and cnt%2 == 0 else 0
",n
"
import collections



class Solution(object):
    def minimumPushes(self, word):
        return sum(x*(i//(9-2+1)+1) for i, x in enumerate(sorted(iter(collections.Counter(word).values()), reverse=True)))
",n
"

class Solution(object):
    def lastMarkedNodes(self, edges):
        def bfs(root):
            new_root = -1
            dist = [-1]*len(adj)
            dist[root] = 0
            q = [root]
            while q:
                new_root = q[0]
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[v] != -1:
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                q = new_q
            return dist, new_root
            
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        _, u = bfs(0)
        dist1, v = bfs(u)
        dist2, _ = bfs(v)
        return [u if dist1[w] > dist2[w] else v for w in range(len(adj))]


",n
"
class Solution2(object):
    def lastMarkedNodes(self, edges):
        def increase(x):
            return (x[0]+1, x[1])

        def bfs():
            dp = [[(0, u)]*2 for u in range(len(adj))]
            new_root = -1
            degree = list(map(len, adj))
            q = [u for u in range(len(degree)) if degree[u] == 1]
            while q:
                new_q = []
                for u in q:
                    if degree[u] == 0:
                        new_root = u
                        continue
                    degree[u] -= 1
                    for v in adj[u]:
                        if degree[v] == 0:
                            continue
                        curr = increase(dp[u][0])
                        for i in range(len(dp[v])):
                            if curr > dp[v][i]:
                                curr, dp[v][i] = dp[v][i], curr
                        degree[v] -= 1
                        if degree[v] == 1:
                            new_q.append(v)
                q = new_q
            return dp, new_root

        def bfs2(root):
            result = [-1]*len(adj)
            q = [(root, -1, (0, -1))]
            while q:
                new_q = []
                for u, p, curr in q:
                    result[u] = max(dp[u][0], curr)[1]
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u, increase(max(dp[u][dp[u][0][1] == dp[v][0][1]], curr))))
                q = new_q
            return result

        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp, u = bfs()
        return bfs2(u)


",n
"
class Solution3(object):
    def lastMarkedNodes(self, edges):
        def increase(x):
            return (x[0]+1, x[1])

        def topological_traversal():
            p = [-2]*len(adj)
            p[0] = -1
            topological_order = [0]
            for u in topological_order:
                for v in reversed(adj[u]):
                    if p[v] != -2:
                        continue
                    p[v] = u
                    topological_order.append(v)
            dp = [[(0, u)]*2 for u in range(len(adj))]
            for u in reversed(topological_order):
                for v in adj[u]:
                    if v == p[u]:
                        continue
                    curr = increase(dp[v][0])
                    for i in range(len(dp[u])):
                        if curr > dp[u][i]:
                            curr, dp[u][i] = dp[u][i], curr
            return dp

        def bfs():
            result = [-1]*len(adj)
            q = [(0, -1, (0, -1))]
            while q:
                new_q = []
                for u, p, curr in q:
                    result[u] = max(dp[u][0], curr)[1]
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u, increase(max(dp[u][dp[u][0][1] == dp[v][0][1]], curr))))
                q = new_q
            return result

        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = topological_traversal()
        return bfs()


",n
"
class Solution4(object):
    def lastMarkedNodes(self, edges):
        def increase(x):
            return (x[0]+1, x[1])

        def iter_dfs1():
            dp = [[(0, u)]*2 for u in range(len(adj))]
            stk = [(1, (0, -1))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p = args
                    stk.append((2, (u, p, 0)))
                elif step == 2:
                    u, p, i = args
                    if i == len(adj[u]):
                        continue
                    stk.append((2, (u, p, i+1)))
                    v = adj[u][i]
                    if v == p:
                        continue
                    stk.append((3, (v, u)))
                    stk.append((1, (v, u)))
                elif step == 3:
                    v, u = args
                    curr = increase(dp[v][0])
                    for i in range(len(dp[u])):
                        if curr > dp[u][i]:
                            curr, dp[u][i] = dp[u][i], curr
            return dp

        def iter_dfs2():
            result = [-1]*len(adj)
            stk = [(0, -1, (0, -1))]
            while stk:
                u, p, curr = stk.pop()
                result[u] = max(dp[u][0], curr)[1]
                for v in reversed(adj[u]):
                    if v == p:
                        continue
                    stk.append((v, u, increase(max(dp[u][dp[u][0][1] == dp[v][0][1]], curr))))
            return result
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = iter_dfs1()
        return iter_dfs2()


",n
"
class Solution5(object):
    def lastMarkedNodes(self, edges):
        def increase(x):
            return (x[0]+1, x[1])

        def dfs1(u, p):
            for v in adj[u]:
                if v == p:
                    continue
                dfs1(v, u)
                curr = increase(dp[v][0])
                for i in range(len(dp[u])):
                    if curr > dp[u][i]:
                        curr, dp[u][i] = dp[u][i], curr

        def dfs2(u, p, curr):
            for v in adj[u]:
                if v == p:
                    continue
                dfs2(v, u, increase(max(dp[u][dp[u][0][1] == dp[v][0][1]], curr)))
            result[u] = max(dp[u][0], curr)[1]
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = [[(0, u)]*2 for u in range(len(adj))]
        dfs1(0, -1)
        result = [-1]*len(adj)
        dfs2(0, -1, (0, -1))
        return result
",n
"
class Solution(object):
    def numberOfCombinations(self, num):
        MOD = 10**9+7
        def find_longest_common_prefix(num):
            lcp = [[0]*(len(num)+1) for _ in range(len(num)+1)] 
            for i in reversed(range(len(lcp)-1)):
                for j in reversed(range(len(lcp[0])-1)):
                    if num[i] == num[j]:
                        lcp[i][j] = lcp[i+1][j+1]+1
            return lcp

        def is_less_or_equal_to_with_same_length(num, lcp, i, j, l):
            return lcp[i][j] >= l or num[i+lcp[i][j]] < num[j+lcp[i][j]]

        lcp = find_longest_common_prefix(num)
        dp = [[0]*len(num) for _ in range(len(num))] 
        dp[0][0] = int(num[0] != '0')
        for i in range(1, len(num)):
            dp[i][i] = dp[i-1][i-1]
            if num[i] == '0':
                continue
            accu = 0
            for l in range(len(num)-i+1):
                ni = i+l-1
                dp[ni][l-1] = accu 
                if i-l < 0:
                    continue
                if num[i-l] != '0' and is_less_or_equal_to_with_same_length(num, lcp, i-l, i, l):
                    dp[ni][l-1] = (dp[ni][l-1] + dp[i-1][l-1]) % MOD
                accu = (accu + dp[i-1][l-1]) % MOD
        return reduce(lambda total, x: (total+x)%MOD, dp[-1], 0)
",n^2
"
from collections import Counter


class Solution(object):
    def removeDuplicateLetters(self, s):
        remaining = Counter(s)

        in_stack, stk = set(), []
        for c in s:
            if c not in in_stack:
                while stk and stk[-1] > c and remaining[stk[-1]]:
                    in_stack.remove(stk.pop())
                stk += c
                in_stack.add(c)
            remaining[c] -= 1
        return """".join(stk)
",n
"
import bisect


class Solution(object):
    def findRadius(self, houses, heaters):
        heaters.sort()
        min_radius = 0
        for house in houses:
        	equal_or_larger = bisect.bisect_left(heaters, house)
        	curr_radius = float(""inf"")
        	if equal_or_larger != len(heaters):
        	    curr_radius = heaters[equal_or_larger] - house
        	if equal_or_larger != 0:
        	    smaller = equal_or_larger-1
        	    curr_radius = min(curr_radius, house - heaters[smaller])
        	min_radius = max(min_radius, curr_radius)
        return min_radius

",(m + n) * logn
"

class Solution(object):
    def generateKey(self, num1, num2, num3):
        L = 4
        result = 0
        base = pow(10, L-1)
        for _ in range(L):
            result = result*10+min(num1//base%10, num2//base%10, num3//base%10)
            base //= 10
        return result
",d
"
class Solution(object):
    def minimumBuckets(self, street):
        result = 0
        street = list(street)
        for i, c in enumerate(street):
            if c != 'H' or (i and street[i-1] == 'B'):
                continue
            if i+1 < len(street) and street[i+1] == '.':
                street[i+1] = 'B'
                result += 1
            elif i and street[i-1] == '.':
                street[i-1] = 'B'
                result += 1
            else:
                return -1
        return result
",n
"
class Solution(object):
    def searchMatrix(self, matrix, target):
        if not matrix:
            return False

        m, n = len(matrix), len(matrix[0])
        left, right = 0, m * n
        while left < right:
            mid = left + (right - left) / 2
            if matrix[mid / n][mid % n] >= target:
                right = mid
            else:
                left = mid + 1

        return left < m * n and matrix[left / n][left % n] == target


",logm + logn
"
import collections
import itertools


class Solution(object):
    def movesToChessboard(self, board):
        N = len(board)
        result = 0
        for count in (collections.Counter(list(map(tuple, board))), \
                      collections.Counter(zip(*board))):
            if len(count) != 2 or \
               sorted(count.values()) != [N/2, (N+1)/2]:
                return -1

            seq1, seq2 = count
            if any(x == y for x, y in zip(seq1, seq2)):
                return -1
            begins = [int(seq1.count(1) * 2 > N)] if N%2 else [0, 1]
            result += min(sum(int(i%2 != v) for i, v in enumerate(seq1, begin)) \
                          for begin in begins) / 2
        return result

",n^2
"
import collections



class Solution(object):
    def getMaxFunctionValue(self, receiver, k):
        def find_cycles(adj):
            result = []
            lookup = [0]*len(adj)
            idx = 0
            for u in range(len(adj)):
                prev = idx
                while not lookup[u]:
                    idx += 1
                    lookup[u] = idx
                    u = adj[u]
                if lookup[u] > prev:
                    result.append((u, idx-lookup[u]+1))
            return result

        def find_prefixes():
            lookup = [(-1, -1)]*len(receiver)
            prefixes = [[0] for _ in range(len(cycles))]
            for idx, (u, l) in enumerate(cycles):
                for i in range(l):
                    lookup[u] = (idx, i)
                    prefixes[idx].append(prefixes[idx][i]+u)
                    u = receiver[u]
            return lookup, prefixes
        
        def get_sum(prefix, i, cnt):
            l = len(prefix)-1
            q, r = divmod(cnt, l)
            return (q*prefix[-1]+
                    (prefix[min(i+r, l)]-prefix[i])+
                    (prefix[max(((i+r)-l, 0))]-prefix[0]))
        
        def start_inside_cycle():
            result = 0
            for u, l in cycles:
                for _ in range(l):
                    idx, i = lookup[u]
                    result = max(result, get_sum(prefixes[idx], i, k+1))
                    u = receiver[u]
            return result
    
        def start_outside_cycle():
            result = 0
            degree = [0]*len(receiver)
            for x in receiver:
                degree[x] += 1
            for u in range(len(receiver)):
                if degree[u]:
                    continue
                curr = 0
                dq = collections.deque()
                while lookup[u][0] == -1:
                    curr += u
                    dq.append(u)
                    if len(dq) == k+1:
                        result = max(result, curr)
                        curr -= dq.popleft()
                    u = receiver[u]
                idx, i = lookup[u]
                while dq:
                    result = max(result, curr+get_sum(prefixes[idx], i, (k+1)-len(dq)))
                    curr -= dq.popleft()
            return result
            
        cycles = find_cycles(receiver)
        lookup, prefixes = find_prefixes()
        return max(start_inside_cycle(), start_outside_cycle())


",n
"
class Solution2(object):
    def getMaxFunctionValue(self, receiver, k):
        l = (k+1).bit_length()
        P = [receiver[:] for _ in range(l)]
        S = [list(range(len(receiver))) for _ in range(l)]
        for i in range(1, len(P)):
            for u in range(len(receiver)):
                P[i][u] = P[i-1][P[i-1][u]]
                S[i][u] = S[i-1][u]+S[i-1][P[i-1][u]]
        result = 0
        for u in range(len(receiver)):
            curr = 0
            for i in range(l):
                if (k+1)&(1<<i):
                    curr += S[i][u]
                    u = P[i][u]
            result = max(result, curr)
        return result
",nlogk
"

class Solution(object):
    def minCost(self, nums, costs):
        stk1, stk2 = [], []
        dp = [float(""inf"")]*len(nums)
        dp[0] = 0
        for i in range(len(nums)):
            while stk1 and nums[stk1[-1]] <= nums[i]:
                dp[i] = min(dp[i], dp[stk1.pop()]+costs[i])
            stk1.append(i)
            while stk2 and nums[stk2[-1]] > nums[i]:
                dp[i] = min(dp[i], dp[stk2.pop()]+costs[i])
            stk2.append(i)
        return dp[-1]
",n
"
import collections
import itertools


class Solution(object):
    def singleDivisorTriplet(self, nums):
        def check(a, b, c):
            return sum((a+b+c)%x == 0 for x in (a, b, c)) == 1

        cnt = collections.Counter(nums)
        return 6*(sum(cnt[a]*cnt[b]*cnt[c] for a, b, c in itertools.combinations(list(cnt.keys()), 3) if check(a, b, c)) +
                  sum(cnt[a]*(cnt[a]-1)//2*cnt[b] for a, b in itertools.permutations(list(cnt.keys()), 2) if check(a, a, b)))
",d^3
"
class Solution(object):
    def deleteNode(self, node):
        if node and node.__next__:
            node_to_delete = node.__next__
            node.val = node_to_delete.val
            node.next = node_to_delete.__next__
            del node_to_delete

",1
"
class Solution(object):
    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):
        x1 -= x_center
        y1 -= y_center
        x2 -= x_center
        y2 -= y_center
        x = x1 if x1 > 0 else x2 if x2 < 0 else 0
        y = y1 if y1 > 0 else y2 if y2 < 0 else 0
        return x**2 + y**2 <= radius**2


",1
"class Solution2(object):
    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):
        x1 -= x_center
        y1 -= y_center
        x2 -= x_center
        y2 -= y_center        
        x = min(abs(x1), abs(x2)) if x1*x2 > 0 else 0
        y = min(abs(y1), abs(y2)) if y1*y2 > 0 else 0
        return x**2 + y**2 <= radius**2
",1
"

class Solution(object):
    def maximumCoins(self, heroes, monsters, coins):
        idxs1 = list(range(len(heroes)))
        idxs1.sort(key=lambda x: heroes[x])
        idxs2 = list(range(len(monsters)))
        idxs2.sort(key=lambda x: monsters[x])
        result = [0]*len(idxs1)
        i = curr = 0
        for idx in idxs1:
            for i in range(i, len(idxs2)):
                if monsters[idxs2[i]] > heroes[idx]:
                    break
                curr += coins[idxs2[i]]
            else:
                i = len(idxs2)
            result[idx] = curr
        return result
",nlogn + mlogm
"
class Solution(object):
    def getMaxRepetitions(self, s1, n1, s2, n2):
        repeat_count = [0] * (len(s2)+1)
        lookup = {}
        j, count = 0, 0
        for k in range(1, n1+1):
            for i in range(len(s1)):
                if s1[i] == s2[j]:
                    j = (j + 1) % len(s2)
                    count += (j == 0)

            if j in lookup:  
                i = lookup[j]
                prefix_count = repeat_count[i]
                pattern_count = (count - repeat_count[i]) * ((n1 - i) // (k - i))
                suffix_count = repeat_count[i + (n1 - i) % (k - i)] - repeat_count[i]
                return (prefix_count + pattern_count + suffix_count) / n2
            lookup[j] = k
            repeat_count[k] = count

        return repeat_count[n1] / n2 

","s1 * min(s2, n1)"
"
class Solution(object):
    def getMaxLen(self, nums):
        result, neg_cnt, last_zero_pos, first_valid_neg_pos = 0, 0, -1, -1
        for i in range(len(nums)):
            if nums[i] == 0:
                neg_cnt = 0
                last_zero_pos = i
                first_valid_neg_pos = -1
                continue
            if nums[i] < 0:
                if first_valid_neg_pos == -1:
                    first_valid_neg_pos = i
                neg_cnt += 1
            result = max(result, i-(last_zero_pos if neg_cnt%2 == 0 else first_valid_neg_pos))
        return result
",n
"
import collections



class Solution(object):
    def countSubarrays(self, nums, k):
        result = 0
        dp = collections.defaultdict(int)
        for x in nums:
            new_dp = collections.defaultdict(int)
            if x&k == k:
                new_dp[x] += 1
                for y, c in dp.items():
                    new_dp[y&x] += c
                if k in new_dp:
                    result += new_dp[k]                
            dp = new_dp
        return result
",nlogr
"
import collections
from functools import reduce


class Solution(object):
    def hasGroupsSizeX(self, deck):
        def gcd(a, b): 
            while b:
                a, b = b, a % b
            return a

        vals = list(collections.Counter(deck).values())
        return reduce(gcd, vals) >= 2

",n * (logn)^2
"
class Solution(object):
    def findAnagrams(self, s, p):
        result = []

        cnts = [0] * 26
        for c in p:
            cnts[ord(c) - ord('a')] += 1

        left, right = 0, 0
        while right < len(s):
            cnts[ord(s[right]) - ord('a')] -= 1
            while left <= right and cnts[ord(s[right]) - ord('a')] < 0:
                cnts[ord(s[left]) - ord('a')] += 1
                left += 1
            if right - left + 1 == len(p):
                result.append(left)
            right += 1

        return result

",n
"

class Solution(object):
    def maxOperations(self, nums):
        def memoization(left, right, target, lookup):
            if not right-left+1 >= 2:
                return 0
            if lookup[left][right] == -1:
                lookup[left][right] = max(1+memoization(left+2, right-0, target, lookup) if nums[left]+nums[left+1]   == target else 0,
                                          1+memoization(left+1, right-1, target, lookup) if nums[left]+nums[right]    == target else 0,
                                          1+memoization(left+0, right-2, target, lookup) if nums[right-1]+nums[right] == target else 0)
            return lookup[left][right] 

        return max(memoization(0, len(nums)-1, target, [[-1]*(len(nums)) for _ in range(len(nums))]) for target in {nums[0]+nums[1], nums[0]+nums[-1], nums[-2]+nums[-1]})
",n^2
"
class Solution(object):
    def soupServings(self, N):
        def dp(a, b, lookup):
            if (a, b) in lookup:
                return lookup[a, b]
            if a <= 0 and b <= 0:
                return 0.5
            if a <= 0:
                return 1.0
            if b <= 0:
                return 0.0
            lookup[a, b] = 0.25 * (dp(a-4, b, lookup) +
                                   dp(a-3, b-1, lookup) +
                                   dp(a-2, b-2, lookup) +
                                   dp(a-1, b-3, lookup))
            return lookup[a, b]

        if N >= 4800:
            return 1.0
        lookup = {}
        N = (N+24)//25
        return dp(N, N, lookup)

",1
"
import threading


class Solution(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = 0
        self.__cv = threading.Condition()

    def fizz(self, printFizz):
        for i in range(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 0:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 == 0 and i % 5 != 0:
                    printFizz()
                self.__cv.notify_all()

    def buzz(self, printBuzz):
        for i in range(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 1:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 != 0 and i % 5 == 0:
                    printBuzz()
                self.__cv.notify_all()

    def fizzbuzz(self, printFizzBuzz):
        for i in range(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 2:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 == 0 and i % 5 == 0:
                    printFizzBuzz()
                self.__cv.notify_all()

    def number(self, printNumber):
        for i in range(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 3:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 != 0 and i % 5 != 0:
                    printNumber(i)
                self.__cv.notify_all()
",n
"
from collections import deque

class Solution(object):
    def minMutation(self, start, end, bank):
        lookup = {}
        for b in bank:
            lookup[b] = False

        q = deque([(start, 0)])
        while q:
            cur, level = q.popleft()
            if cur == end:
                return level

            for i in range(len(cur)):
                for c in ['A', 'T', 'C', 'G']:
                    if cur[i] == c:
                        continue

                    next_str = cur[:i] + c + cur[i+1:]
                    if next_str in lookup and lookup[next_str] == False:
                        q.append((next_str, level+1))
                        lookup[next_str] = True

        return -1

",n * b
"
class Solution(object):
    def minimumDifference(self, nums, k):
        nums.sort()
        return min(nums[i]-nums[i-k+1] for i in range(k-1, len(nums)))
",nlogn
"

class Solution(object):
    def shortestDistanceAfterQueries(self, n, queries):
        def bfs(u, v):
            adj[u].append(v)
            q = [u]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[u]+1 >= dist[v]:
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                q = new_q
            return dist[-1]

        adj = [[] for _ in range(n)]
        for u in range(n-1):
            adj[u].append(u+1)
        dist = list(range(n))
        return [bfs(u, v) for u, v in queries]


",n^2
"import heapq



class Solution2(object):
    def shortestDistanceAfterQueries(self, n, queries):
        def dijkstra(u, v):
            adj[u].append((v, 1))
            min_heap = [(dist[u], u)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if curr > dist[u]:
                    continue
                for v, w in adj[u]:
                    if curr+w >= dist[v]:
                        continue
                    dist[v] = curr+w
                    heapq.heappush(min_heap, (dist[v], v))
            return dist[-1]

        adj = [[] for _ in range(n)]
        for u in range(n-1):
            adj[u].append((u+1, 1))
        dist = list(range(n))
        return [dijkstra(u, v) for u, v in queries]
",n^2 * logn
"
class Solution(object):
    def balancedStringSplit(self, s):
        result, count = 0, 0      
        for c in s:
            count += 1 if c == 'L' else -1            
            if count == 0:
                result += 1
        return result
",n
"
import collections



class Solution(object):
    def meetRequirement(self, n, lights, requirement):
        cnt = collections.defaultdict(int)
        for p, r in lights:
            cnt[max(p-r, 0)] += 1
            cnt[min(p+r, n-1)+1] -= 1
        result = curr = 0
        for i, r in enumerate(requirement):
            curr += cnt.get(i, 0)
            if curr >= r:
                result += 1
        return result
",n + l
"
class Solution(object):
    def alphabetBoardPath(self, target):
        x, y = 0, 0
        result = []
        for c in target:
            y1, x1 = divmod(ord(c)-ord('a'), 5)
            result.append('U' * max(y-y1, 0))
            result.append('L' * max(x-x1, 0))
            result.append('R' * max(x1-x, 0))
            result.append('D' * max(y1-y, 0))
            result.append('!')
            x, y = x1, y1
        return """".join(result)
",n
"
import collections
import itertools



class Solution(object):
    def minimumCost(self, source, target, original, changed, cost):
        INF = float(""inf"")
        lookups = collections.defaultdict(dict)
        for x in itertools.chain(original, changed):
            l = len(x)
            lookup = lookups[l]
            if x not in lookup:
                lookup[x] = len(lookup)
        def dijkstra(dist, start):
            best = [INF]*len(dist)
            best[start] = 0
            min_heap = [(0, start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if curr > best[u]:
                    continue
                for v, w in enumerate(dist[u]):     
                    if best[v] <= curr+w:
                        continue
                    best[v] = curr+w
                    heapq.heappush(min_heap, (best[v], v))
            return best

        memo = {}
        def memoization(l, dist, u, v):
            if l not in memo:
                memo[l] = {}
            if u not in memo[l]:
                memo[l][u] = dijkstra(dist, u)
            return memo[l][u][v]

        dists = {l:[[0 if u == v else INF for v in range(len(lookup))] for u in range(len(lookup))] for l, lookup in lookups.items()}
        for i in range(len(original)):
            l = len(original[i])
            lookup, dist = lookups[l], dists[l]
            u, v = lookup[original[i]], lookup[changed[i]]
            dist[u][v] = min(dist[u][v], cost[i])
        candidates = {len(x) for x in original}
        dp = [INF]*(max(len(x) for x in original)+1)
        dp[0] = 0
        for i in range(len(source)):
            if dp[i%len(dp)] == INF:
                continue
            if source[i] == target[i]:
                dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)])
            for l in candidates:
                if i+l > len(source):
                    continue
                lookup, dist = lookups[l], dists[l]
                u, v = source[i:i+l], target[i:i+l]
                if u in lookup and v in lookup:
                    dp[(i+l)%len(dp)] = min(dp[(i+l)%len(dp)], dp[i%len(dp)]+memoization(l, dist, lookup[u], lookup[v]))
            dp[i%len(dp)] = INF
        return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1


",o * l + k * eloge + n * c * l
"import collections
import itertools



class Solution2(object):
    def minimumCost(self, source, target, original, changed, cost):
        INF = float(""inf"")
        def floydWarshall(dist):
            for k in range(len(dist)):
                for i in range(len(dist)):
                    if dist[i][k] == INF:
                        continue
                    for j in range(len(dist[i])):
                        if dist[k][j] == INF:
                            continue
                        dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])
        
        lookups = collections.defaultdict(dict)
        for x in itertools.chain(original, changed):
            l = len(x)
            lookup = lookups[l]
            if x not in lookup:
                lookup[x] = len(lookup)
        dists = {l:[[0 if u == v else INF for v in range(len(lookup))] for u in range(len(lookup))] for l, lookup in lookups.items()}
        for i in range(len(original)):
            l = len(original[i])
            lookup, dist = lookups[l], dists[l]
            u, v = lookup[original[i]], lookup[changed[i]]
            dist[u][v] = min(dist[u][v], cost[i])
        for dist in dists.values():
            floydWarshall(dist)
        candidates = {len(x) for x in original}
        dp = [INF]*(max(len(x) for x in original)+1)
        dp[0] = 0
        for i in range(len(source)):
            if dp[i%len(dp)] == INF:
                continue
            if source[i] == target[i]:
                dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)])
            for l in candidates:
                if i+l > len(source):
                    continue
                lookup, dist = lookups[l], dists[l]
                u, v = source[i:i+l], target[i:i+l]
                if u in lookup and v in lookup:
                    dp[(i+l)%len(dp)] = min(dp[(i+l)%len(dp)], dp[i%len(dp)]+dist[lookup[u]][lookup[v]])
            dp[i%len(dp)] = INF
        return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1


",o * l + k^3 + n * c * l
"import collections
import itertools



class Solution3(object):
    def minimumCost(self, source, target, original, changed, cost):
        INF = float(""inf"")

        lookup = {}
        for x in itertools.chain(original, changed):
            if x in lookup:
                continue
            lookup[x] = len(lookup)
        def dijkstra(start):
            best = {start:0}
            min_heap = [(0, start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if curr > best[u]:
                    continue
                if u not in dist:
                    continue
                for v, w in dist[u].items():     
                    if v in best and best[v] <= curr+w:
                        continue
                    best[v] = curr+w
                    heapq.heappush(min_heap, (best[v], v))
            return best

        memo = {}
        def memoization(u, v):
            if u not in lookup:
                memo[u] = dijkstra(u)
            return memo[u][v] if v in memo[u] else INF

        dist = {}
        for i in range(len(original)):
            u, v = lookup[original[i]], lookup[changed[i]]
            if u not in dist:
                dist[u] = {v:INF}
            if v not in dist[u]:
                dist[u][v] = INF
            dist[u][v] = min(dist[u][v], cost[i])
        candidates = {len(x) for x in original}
        dp = [INF]*(max(len(x) for x in original)+1)
        dp[0] = 0
        for i in range(len(source)):
            if dp[i%len(dp)] == INF:
                continue
            if source[i] == target[i]:
                dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)])
            for l in candidates:
                if i+l > len(source):
                    continue
                u, v = source[i:i+l], target[i:i+l]
                if u in lookup and v in lookup:
                    dp[(i+l)%len(dp)] = min(dp[(i+l)%len(dp)], dp[i%len(dp)]+memoization(lookup[u], lookup[v]))
            dp[i%len(dp)] = INF
        return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1


",o * l + k * eloge + n * c * l
"import collections
import itertools



class Solution4(object):
    def minimumCost(self, source, target, original, changed, cost):
        INF = float(""inf"")
        def floydWarshall(dist):
            for k in dist.keys():
                for i in dist.keys():
                    if dist[i][k] == INF:
                        continue
                    for j in dist.keys():
                        if dist[k][j] == INF:
                            continue
                        dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])
        
        lookup = {}
        buckets = collections.defaultdict(list)
        for x in itertools.chain(original, changed):
            l = len(x)
            if x in lookup:
                continue
            lookup[x] = len(lookup)
            buckets[len(x)].append(lookup[x])            
        dists = {l:{u:{v:0 if u == v else INF for v in lookup} for u in lookup} for l, lookup in buckets.items()}
        for i in range(len(original)):
            l = len(original[i])
            dist = dists[l]
            u, v = lookup[original[i]], lookup[changed[i]]
            dist[u][v] = min(dist[u][v], cost[i])
        for dist in dists.values():
            floydWarshall(dist)
        candidates = {len(x) for x in original}
        dp = [INF]*(max(len(x) for x in original)+1)
        dp[0] = 0
        for i in range(len(source)):
            if dp[i%len(dp)] == INF:
                continue
            if source[i] == target[i]:
                dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)])
            for l in candidates:
                if i+l > len(source):
                    continue
                dist = dists[l]
                u, v = source[i:i+l], target[i:i+l]
                if u in lookup and v in lookup:
                    dp[(i+l)%len(dp)] = min(dp[(i+l)%len(dp)], dp[i%len(dp)]+dist[lookup[u]][lookup[v]])
            dp[i%len(dp)] = INF
        return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1


",o * l + k^3 + n * c * l
"import itertools
import heapq



class Solution5(object):
    def minimumCost(self, source, target, original, changed, cost):
        INF = float(""inf"")
        class Trie(object):
            def __init__(self):
                self.__nodes = []
                self.__idxs = []
                self.k = 0
                self.__new_node()
            
            def __new_node(self):
                self.__nodes.append([-1]*26)
                self.__idxs.append(-1)
                return len(self.__nodes)-1

            def add(self, s):
                curr = 0
                for c in s:
                    x = ord(c)-ord('a')
                    if self.__nodes[curr][x] == -1:
                        self.__nodes[curr][x] = self.__new_node()
                    curr = self.__nodes[curr][x]
                if self.__idxs[curr] == -1:
                    self.__idxs[curr] = self.k
                    self.k += 1
                    return True, self.__idxs[curr]
                return False, self.__idxs[curr]
            
            def query(self, s):
                curr = 0
                for c in s:
                    curr = self.__nodes[curr][ord(c)-ord('a')]
                return self.__idxs[curr]
    
            def next(self, curr, c):
                return self.__nodes[curr][ord(c)-ord('a')]

            def id(self, curr):
                return self.__idxs[curr]

        trie = Trie()
        for x in itertools.chain(original, changed):
            trie.add(x)
        def dijkstra(start):
            best = {start:0}
            min_heap = [(0, start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if curr > best[u]:
                    continue
                if u not in dist:
                    continue
                for v, w in dist[u].items():     
                    if v in best and best[v] <= curr+w:
                        continue
                    best[v] = curr+w
                    heapq.heappush(min_heap, (best[v], v))
            return best

        memo = {}
        def memoization(u, v):
            if u not in memo:
                memo[u] = dijkstra(u)
            return memo[u][v] if v in memo[u] else INF

        dist = {}
        for i in range(len(original)):
            u, v = trie.query(original[i]), trie.query(changed[i])
            if u not in dist:
                dist[u] = {v:INF}
            if v not in dist[u]:
                dist[u][v] = INF
            dist[u][v] = min(dist[u][v], cost[i])
        dp = [INF]*(max(len(x) for x in original)+1)
        dp[0] = 0
        for i in range(len(source)):
            if dp[i%len(dp)] == INF:
                continue
            if source[i] == target[i]:
                dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)])
            u = v = 0
            for j in range(i, len(source)):
                u = trie.next(u, source[j])
                v = trie.next(v, target[j])
                if u == -1 or v == -1:
                    break
                if trie.id(u) != -1 and trie.id(v) != -1:
                    dp[(j+1)%len(dp)] = min(dp[(j+1)%len(dp)], dp[i%len(dp)]+memoization(trie.id(u), trie.id(v)))
            dp[i%len(dp)] = INF
        return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1


",o * l + k * eloge + n * l
"import itertools



class Solution6(object):
    def minimumCost(self, source, target, original, changed, cost):
        INF = float(""inf"")
        class Trie(object):
            def __init__(self):
                self.__nodes = []
                self.__idxs = []
                self.k = 0
                self.__new_node()
            
            def __new_node(self):
                self.__nodes.append([-1]*26)
                self.__idxs.append(-1)
                return len(self.__nodes)-1

            def add(self, s):
                curr = 0
                for c in s:
                    x = ord(c)-ord('a')
                    if self.__nodes[curr][x] == -1:
                        self.__nodes[curr][x] = self.__new_node()
                    curr = self.__nodes[curr][x]
                if self.__idxs[curr] == -1:
                    self.__idxs[curr] = self.k
                    self.k += 1
                    return True, self.__idxs[curr]
                return False, self.__idxs[curr]
            
            def query(self, s):
                curr = 0
                for c in s:
                    curr = self.__nodes[curr][ord(c)-ord('a')]
                return self.__idxs[curr]
    
            def next(self, curr, c):
                return self.__nodes[curr][ord(c)-ord('a')]

            def id(self, curr):
                return self.__idxs[curr]

        def floydWarshall(dist):
            for k in dist.keys():
                for i in dist.keys():
                    if dist[i][k] == INF:
                        continue
                    for j in dist.keys():
                        if dist[k][j] == INF:
                            continue
                        dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])
        
        trie = Trie()
        buckets = collections.defaultdict(list)
        for x in itertools.chain(original, changed):
            not_duplicated, i = trie.add(x)
            if not_duplicated:
                buckets[len(x)].append(i)
        dists = {l:{u:{v:0 if u == v else INF for v in lookup} for u in lookup} for l, lookup in buckets.items()}
        for i in range(len(original)):
            l = len(original[i])
            dist = dists[l]
            u, v = trie.query(original[i]), trie.query(changed[i])
            dist[u][v] = min(dist[u][v], cost[i])
        for dist in dists.values():
            floydWarshall(dist)
        dp = [INF]*(max(len(x) for x in original)+1)
        dp[0] = 0
        for i in range(len(source)):
            if dp[i%len(dp)] == INF:
                continue
            if source[i] == target[i]:
                dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)])
            u = v = 0
            for j in range(i, len(source)):
                u = trie.next(u, source[j])
                v = trie.next(v, target[j])
                if u == -1 or v == -1:
                    break
                if trie.id(u) != -1 and trie.id(v) != -1:
                    dp[(j+1)%len(dp)] = min(dp[(j+1)%len(dp)], dp[i%len(dp)]+dists[j-i+1][trie.id(u)][trie.id(v)])
            dp[i%len(dp)] = INF
        return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1
",o * l + k^3 + n * l
"
class Solution(object):
    def numberOfPaths(self, n, corridors):
        adj = [set() for _ in range(n)]
        for u, v in corridors:
            adj[min(u, v)-1].add(max(u, v)-1)
        return sum(k in adj[i] for i in range(n) for j in adj[i] for k in adj[j])
",|V|^3
"
import collections
from functools import reduce


class Solution(object):
    def longestRepeatingSubstring(self, S):
        M = 10**9+7
        D = 26

        def check(S, L):
            p = pow(D, L, M)
            curr = reduce(lambda x, y: (D*x+ord(y)-ord('a')) % M, S[:L], 0)
            lookup = collections.defaultdict(list)
            lookup[curr].append(L-1)
            result = 0
            for i in range(L, len(S)):
                curr = ((D*curr) % M + ord(S[i])-ord('a') -
                        ((ord(S[i-L])-ord('a'))*p) % M) % M
                if curr in lookup:
                    for j in lookup[curr]:
                        if S[j-L+1:j+1] == S[i-L+1:i+1]:
                            if result == 0:
                                result = i
                            return result-L+1
                lookup[curr].append(i)
            return result

        left, right = 0, len(S)-1
        while left <= right:
            mid = left + (right-left)//2
            if not check(S, mid):
                right = mid-1
            else:
                left = mid+1
        return right
        
",nlogn
"
class Solution(object):
    def replaceElements(self, arr):
        curr_max = -1
        for i in reversed(range(len(arr))):
            arr[i], curr_max = curr_max, max(curr_max, arr[i])
        return arr
",n
"

class Solution(object):
    def maxPrice(self, items, capacity):
        result = 0
        items.sort(key=lambda x: float(x[0])/x[1], reverse=True)
        for p, c in items:
            cnt = min(c, capacity)
            capacity -= cnt
            result += (float(p)/c)*cnt
        return result if capacity == 0 else -1
",nlogn
"
import collections


class Solution(object):
    def minStickers(self, stickers, target):
        def minStickersHelper(sticker_counts, target, dp):
            if """".join(target) in dp:
                return dp["""".join(target)]
            target_count = collections.Counter(target)
            result = float(""inf"")
            for sticker_count in sticker_counts:
                if sticker_count[target[0]] == 0:
                    continue
                new_target = []
                for k in list(target_count.keys()):
                    if target_count[k] > sticker_count[k]:
                       new_target += [k]*(target_count[k] - sticker_count[k])
                if len(new_target) != len(target):
                    num = minStickersHelper(sticker_counts, new_target, dp)
                    if num != -1:
                        result = min(result, 1+num)
            dp["""".join(target)] = -1 if result == float(""inf"") else result
            return dp["""".join(target)]

        sticker_counts = list(map(collections.Counter, stickers))
        dp = { """":0 }
        return minStickersHelper(sticker_counts, target, dp)

",T * S^T
"
class Solution(object):
    def candyCrush(self, board):
        R, C = len(board), len(board[0])
        changed = True

        while changed:
            changed = False

            for r in range(R):
                for c in range(C-2):
                    if abs(board[r][c]) == abs(board[r][c+1]) == abs(board[r][c+2]) != 0:
                        board[r][c] = board[r][c+1] = board[r][c+2] = -abs(board[r][c])
                        changed = True

            for r in range(R-2):
                for c in range(C):
                    if abs(board[r][c]) == abs(board[r+1][c]) == abs(board[r+2][c]) != 0:
                        board[r][c] = board[r+1][c] = board[r+2][c] = -abs(board[r][c])
                        changed = True

            for c in range(C):
                i = R-1
                for r in reversed(range(R)):
                    if board[r][c] > 0:
                        board[i][c] = board[r][c]
                        i -= 1
                for r in reversed(range(i+1)):
                    board[r][c] = 0

        return board

",(R * C)^2
"
class Solution(object):
    def numOfSubarrays(self, arr):
        MOD = 10**9+7
        result, accu = 0, 0
        dp = [1, 0]
        for x in arr:
            accu ^= x&1
            dp[accu] += 1
            result = (result + dp[accu^1]) % MOD
        return result
",n
"
import heapq



class Solution(object):
    def convertArray(self, nums):
        def f(nums):
            result = 0
            max_heap = []
            for x in nums:
                if max_heap and x < -max_heap[0]:
                    result += -heapq.heappop(max_heap)-x
                    heapq.heappush(max_heap, -x)
                heapq.heappush(max_heap, -x)
            return result
        
        return min(f(nums), f((x for x in reversed(nums))))


",nlogn
"import collections



class Solution2(object):
    def convertArray(self, nums):
        vals = sorted(set(nums))
        def f(nums):
            dp = collections.defaultdict(int) 
            for x in nums:
                prev = -1
                for i in vals:
                    dp[i] = min(dp[i]+abs(i-x), dp[prev]) if prev != -1 else dp[i]+abs(i-x)
                    prev = i
            return dp[vals[-1]]

        return min(f(nums), f((x for x in reversed(nums))))
",n^2
"
class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children


class Solution(object):
    def levelOrder(self, root):
        if not root:
            return []
        result, q = [], [root]
        while q:
            result.append([node.val for node in q])
            q = [child for node in q for child in node.children if child]
        return result

",n
"
import collections


class Solution(object):
    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):
        result = 0
        q = collections.deque(initialBoxes)
        while q:
            changed = False
            for _ in range(len(q)):
                box = q.popleft()
                if not status[box]:
                    q.append(box)
                    continue
                changed = True
                result += candies[box]
                for contained_key in keys[box]:
                    status[contained_key] = 1
                for contained_box in containedBoxes[box]:
                    q.append(contained_box)
            if not changed:
                break
        return result
",n^2
"

class Solution(object):
    def smallestNumber(self, n):
        result = []
        for d in reversed(range(2, 9+1)):
            while n%d == 0:
                result.append(d)
                n //= d
        return """".join(map(str, reversed(result))) or ""1"" if n == 1 else ""-1""
",logn
"

class Solution(object):
    def subarraySum(self, nums):
        diff = [0]*(len(nums)+1)
        for i, x in enumerate(nums):
            diff[max(i-x, 0)] += 1
            diff[i+1] -= 1
        for i in range(len(nums)):
            diff[i+1] += diff[i]
        return sum(nums[i]*diff[i] for i in range(len(nums)))
",n
"
class Solution(object):
    def canVisitAllRooms(self, rooms):
        lookup = set([0])
        stack = [0]
        while stack:
            node = stack.pop()
            for nei in rooms[node]:
                if nei not in lookup:
                    lookup.add(nei)
                    if len(lookup) == len(rooms):
                        return True
                    stack.append(nei)
        return len(lookup) == len(rooms)

",n!
"
class Node(object):
    def __init__(self, value, keys):
        self.value = value
        self.keys = keys
        self.prev = None
        self.next = None


class LinkedList(object):
    def __init__(self):
        self.head, self.tail = Node(0, set()), Node(0, set())
        self.head.next, self.tail.prev = self.tail, self.head

    def insert(self, pos, node):
        node.prev, node.next = pos.prev, pos
        pos.prev.next, pos.prev = node, node
        return node

    def erase(self, node):
        node.prev.next, node.next.prev = node.__next__, node.prev
        del node

    def empty(self):
        return self.head.__next__ is self.tail

    def begin(self):
        return self.head.__next__

    def end(self):
        return self.tail

    def front(self):
        return self.head.__next__

    def back(self):
        return self.tail.prev


class Solution(object):

    def __init__(self):
        self.bucket_of_key = {}
        self.buckets = LinkedList()

    def inc(self, key):
        if key not in self.bucket_of_key:
            self.bucket_of_key[key] = self.buckets.insert(self.buckets.begin(), Node(0, set([key])))

        bucket, next_bucket = self.bucket_of_key[key], self.bucket_of_key[key].__next__
        if next_bucket is self.buckets.end() or next_bucket.value > bucket.value+1:
            next_bucket = self.buckets.insert(next_bucket, Node(bucket.value+1, set()))
        next_bucket.keys.add(key)
        self.bucket_of_key[key] = next_bucket

        bucket.keys.remove(key)
        if not bucket.keys:
            self.buckets.erase(bucket)

    def dec(self, key):
        if key not in self.bucket_of_key:
            return

        bucket, prev_bucket = self.bucket_of_key[key], self.bucket_of_key[key].prev
        self.bucket_of_key.pop(key, None)
        if bucket.value > 1:
            if bucket is self.buckets.begin() or prev_bucket.value < bucket.value-1:
                prev_bucket = self.buckets.insert(bucket, Node(bucket.value-1, set()))
            prev_bucket.keys.add(key)
            self.bucket_of_key[key] = prev_bucket

        bucket.keys.remove(key)
        if not bucket.keys:
            self.buckets.erase(bucket)

    def getMaxKey(self):
        if self.buckets.empty():
            return """"
        return next(iter(self.buckets.back().keys))

    def getMinKey(self):
        if self.buckets.empty():
            return """"
        return next(iter(self.buckets.front().keys))

",1
"

class Solution(object):
    def survivedRobotsHealths(self, positions, healths, directions):
        stk = []
        for i in sorted(range(len(positions)), key=lambda x:positions[x]):
            if directions[i] == 'R':
                stk.append(i)
                continue
            while stk:
                if healths[stk[-1]] == healths[i]:
                    healths[stk.pop()] = healths[i] = 0
                    break
                if healths[stk[-1]] > healths[i]:
                    healths[i] = 0
                    healths[stk[-1]] -= 1
                    break                
                healths[stk.pop()] = 0
                healths[i] -= 1
        return [x for x in healths if x]
",nlogn
"
class Solution(object):
    def minNonZeroProduct(self, p):
        MOD = 10**9+7

        max_num_mod = (pow(2, p, MOD)-1)%MOD 

        pair_product_mod = (max_num_mod-1)%MOD 

        pair_cnt_mod_m_1 = (pow(2, p-1, MOD-1)-1) % (MOD-1) 

        return (max_num_mod*pow(pair_product_mod, pair_cnt_mod_m_1, MOD)) % MOD
","min(p, logM)"
"
class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1) 

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret


class Solution(object):
    def pancakeSort(self, arr):
        bit = BIT(len(arr))
        result = []
        for i in range(len(arr)):
            n = bit.query((arr[i]-1)-1)
            bit.add(arr[i]-1, 1)
            if n == i: 
                continue
            if n == 0:               
                if i > 1:
                    result.append(i) 
                result.append(i+1)   
            else:                    
                if n > 1:
                    result.append(n) 
                result.append(i)     
                result.append(i+1)   
                result.append(n+1)   
        return result


",nlogn
"
class Solution2(object):
    def pancakeSort(self, arr):
        def smallerMergeSort(idxs, start, end, counts):
            if end - start <= 0: 
                return 0

            mid = start + (end - start) // 2
            smallerMergeSort(idxs, start, mid, counts)
            smallerMergeSort(idxs, mid + 1, end, counts)
            r = start
            tmp = []
            for i in range(mid+1, end + 1):
                while r <= mid and idxs[r][0] < idxs[i][0]:
                    tmp.append(idxs[r])
                    r += 1
                if r <= mid:
                    tmp.append(idxs[i])
                counts[idxs[i][1]] += r - start
            while r <= mid:
                tmp.append(idxs[r])
                r += 1
            idxs[start:start+len(tmp)] = tmp
            
        idxs = []
        smaller_counts = [0]*len(arr)
        for i, x in enumerate(arr):
            idxs.append((x, i))
        smallerMergeSort(idxs, 0, len(idxs)-1, smaller_counts)
        result = []
        for i, n in enumerate(smaller_counts):
            if n == i: 
                continue
            if n == 0:               
                if i > 1:
                    result.append(i) 
                result.append(i+1)   
            else:                    
                if n > 1:
                    result.append(n) 
                result.append(i)     
                result.append(i+1)   
                result.append(n+1)   
        return result


",nlogn
"class Solution3(object):
    def pancakeSort(self, A):
        def reverse(l, begin, end):
            for i in range((end-begin) // 2):
                l[begin+i], l[end-1-i] = l[end-1-i], l[begin+i]

        result = []
        for n in reversed(range(1, len(A)+1)):
            i = A.index(n)
            reverse(A, 0, i+1)
            result.append(i+1)
            reverse(A, 0, n)
            result.append(n)
        return result
",n^2
"

class Solution(object):
    def distanceToCycle(self, n, edges):
        def cycle(parent, v, u):
            result = [parent[v], v]
            while u != parent[v]:
                result.append(u)
                u = parent[u]
            return result
    
        def iter_dfs(adj):
            stk = [0]
            parent = [-2]*len(adj)
            parent[0] = -1
            while stk:
                u = stk.pop()
                for v in reversed(adj[u]):
                    if parent[v] != -2:
                        if v == parent[u]:
                            continue
                        return cycle(parent, v, u)
                    parent[v] = u
                    stk.append(v)

        def bfs(adj, q):
            result = [-1]*n
            for x in q:
                result[x] = 0
            d = 1
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if result[v] != -1:
                            continue
                        result[v] = d
                        new_q.append(v)
                q = new_q
                d += 1
            return result
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return bfs(adj, iter_dfs(adj))
",|V| + |E|
"
import collections



class Solution(object):
    def findHighAccessEmployees(self, access_times):
        LIMIT_COUNT = 2
        LIMIT_MINUTE = 60
        def to_minute(x):
            return int(x[:2])*60+int(x[2:])
    
        lookup = collections.defaultdict(list)
        for x, t in access_times:
            lookup[x].append(to_minute(t))
        result = []
        for x, ts in lookup.items():
            ts.sort()
            if not all(ts[i]+LIMIT_MINUTE <= ts[i+LIMIT_COUNT] for i in range(len(ts)-LIMIT_COUNT)):
                result.append(x)
        return result
",nlogn
"
class Solution(object):
    def maximumAlternatingSubarraySum(self, nums):
        def kadane(nums, start):
            result = float(""-inf"")
            curr = odd = 0
            for i in range(start, len(nums)):
                curr = (curr+nums[i]) if not odd else max(curr-nums[i], 0)
                result = max(result, curr)
                odd ^= 1
            return result

        return max(kadane(nums, 0), kadane(nums, 1))
",n
"

class Solution(object):
    def updateMatrix(self, matrix):
        for i in range(len(matrix)):
            for j in range(len(matrix[i])):
                if not matrix[i][j]:
                    continue
                matrix[i][j] = float(""inf"")
                if i > 0:
                    matrix[i][j] = min(matrix[i][j], matrix[i-1][j]+1)
                if j > 0:
                    matrix[i][j] = min(matrix[i][j], matrix[i][j-1]+1)
        for i in reversed(range(len(matrix))):
            for j in reversed(range(len(matrix[i]))):
                if not matrix[i][j]:
                    continue
                if i < len(matrix)-1:
                    matrix[i][j] = min(matrix[i][j], matrix[i+1][j]+1)
                if j < len(matrix[i])-1:
                    matrix[i][j] = min(matrix[i][j], matrix[i][j+1]+1)
        return matrix


",m * n
"
class Solution2(object):
    def updateMatrix(self, matrix):
        dp = [[float(""inf"")]*len(matrix[0]) for _ in range(len(matrix))]
        for i in range(len(matrix)):
            for j in range(len(matrix[i])):
                if matrix[i][j] == 0:
                    dp[i][j] = 0
                else:
                    if i > 0:
                        dp[i][j] = min(dp[i][j], dp[i-1][j]+1)
                    if j > 0:
                        dp[i][j] = min(dp[i][j], dp[i][j-1]+1)
        for i in reversed(range(len(matrix))):
            for j in reversed(range(len(matrix[i]))):
                if matrix[i][j] == 0:
                    dp[i][j] = 0
                else:
                    if i < len(matrix)-1:
                        dp[i][j] = min(dp[i][j], dp[i+1][j]+1)
                    if j < len(matrix[i])-1:
                        dp[i][j] = min(dp[i][j], dp[i][j+1]+1)
        return dp


",m * n
"import collections


class Solution3(object):
    def updateMatrix(self, matrix):
        queue = collections.deque()
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == 0:
                    queue.append((i, j))
                else:
                    matrix[i][j] = float(""inf"")

        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        while queue:
            cell = queue.popleft()
            for dir in dirs:
                i, j = cell[0]+dir[0], cell[1]+dir[1]
                if not (0 <= i < len(matrix) and
                        0 <= j < len(matrix[0]) and
                        matrix[i][j] > matrix[cell[0]][cell[1]]+1):
                    continue
                queue.append((i, j))
                matrix[i][j] = matrix[cell[0]][cell[1]]+1

        return matrix
",m * n
"

class Solution(object):
    def validSubstringCount(self, word1, word2):
        cnt = [0]*26
        curr = 0
        for x in word2:
            curr += int(cnt[ord(x)-ord('a')] == 0)
            cnt[ord(x)-ord('a')] += 1
        result = left = 0
        for right in range(len(word1)):
            cnt[ord(word1[right])-ord('a')] -= 1
            curr -= int(cnt[ord(word1[right])-ord('a')] == 0)
            while not curr:
                result += len(word1)-right
                curr += int(cnt[ord(word1[left])-ord('a')] == 0)
                cnt[ord(word1[left])-ord('a')] += 1
                left += 1
        return result
",n + 26
"
import collections
import itertools


class Solution(object):
    def mostVisitedPattern(self, username, timestamp, website):
        lookup = collections.defaultdict(list)
        A = list(zip(timestamp, username, website))
        A.sort()
        for t, u, w in A:
            lookup[u].append(w)
        count = sum([collections.Counter(set(itertools.combinations(lookup[u], 3))) for u in lookup], collections.Counter())
        return list(min(count, key=lambda x: (-count[x], x)))
",n^3
"


class Solution(object):
    def shortestWay(self, source, target):
        lookup = [[None for _ in range(26)] for _ in range(len(source)+1)]
        find_char_next_pos = [None]*26
        for i in reversed(range(len(source))):
            find_char_next_pos[ord(source[i])-ord('a')] = i+1
            lookup[i] = list(find_char_next_pos)

        result, start = 1, 0
        for c in target:
            start = lookup[start][ord(c)-ord('a')]
            if start != None:
                continue
            result += 1
            start = lookup[0][ord(c)-ord('a')]
            if start == None:
                return -1
        return result
",m + n
"

class Solution(object):
    def canAliceWin(self, nums):
        total1 = total2 = 0
        for x in nums:
            if x < 10:
                total1 += x
            else:
                total2 += x
        return total1 != total2


",n
"
class Solution2(object):
    def canAliceWin(self, nums):
        return sum(x for x in nums if x < 10) != sum(x for x in nums if x >= 10)
",n
"
class Solution(object):
    def findSmallestRegion(self, regions, region1, region2):
        parents = {region[i] : region[0]
                   for region in regions
                   for i in range(1, len(region))}
        lookup = {region1}
        while region1 in parents:
            region1 = parents[region1]
            lookup.add(region1)
        while region2 not in lookup:
            region2 = parents[region2]
        return region2
",m * n
"

class Solution(object):
    def assignElements(self, groups, elements):
        mx = max(groups)
        lookup = [-1]*mx
        for i, x in enumerate(elements):
            if x > mx or lookup[x-1] != -1:
                continue
            for y in range(x, mx+1, x):
                if lookup[y-1] == -1:
                    lookup[y-1] = i
        return [lookup[x-1] for x in groups]   
",m + r * logn
"

class Solution(object):
    def minimumTime(self, power):
        def ceil_divide(a, b):
            return (a+b-1)//b

        INF = float(""inf"")
        dp = {0:0}
        for gain in range(1, len(power)+1):
            new_dp = collections.defaultdict(lambda:INF)
            for mask in dp.keys():
                for i in range(len(power)):
                    if mask&(1<<i) == 0:
                        new_dp[mask|(1<<i)] = min(new_dp[mask|(1<<i)], dp[mask]+ceil_divide(power[i], gain))
            dp = new_dp
        return dp[(1<<len(power))-1]
",n * 2^n
"

class Solution(object):
    def maximumTotalSum(self, maximumHeight):
        maximumHeight.sort()
        result, prev = 0, maximumHeight[-1]+1
        for x in reversed(maximumHeight):
            prev = min(x, prev-1)
            if prev == 0:
                return -1
            result += prev
        return result
",nlogn
"

class Solution(object):
    def minimumCost(self, n, edges, query):
        class UnionFind(object): 
            def __init__(self, n):
                self.set = list(range(n))
                self.rank = [0]*n
                self.w = [-1]*n 

            def find_set(self, x):
                stk = []
                while self.set[x] != x: 
                    stk.append(x)
                    x = self.set[x]
                while stk:
                    self.set[stk.pop()] = x
                return x

            def union_set(self, x, y, w): 
                x, y = self.find_set(x), self.find_set(y)
                if x == y:
                    self.w[x] &= w 
                    return False
                if self.rank[x] > self.rank[y]: 
                    x, y = y, x
                self.set[x] = self.set[y]
                if self.rank[x] == self.rank[y]:
                    self.rank[y] += 1
                self.w[y] &= self.w[x]&w 
                return True
            
            def cost(self, x): 
                return self.w[self.find_set(x)]

        uf = UnionFind(n)
        for u, v, w in edges:
            uf.union_set(u, v, w)
        result = [-1]*(len(query))
        for i, (s, t) in enumerate(query):
            if uf.find_set(s) != uf.find_set(t):
                continue
            result[i] = uf.cost(s) if s != t else 0
        return result
",n + e + q
"
class Solution(object):
    def reversePrefix(self, word, ch):
        i = word.find(ch)
        return word[:i+1][::-1]+word[i+1:]
",n
"
class Solution(object):
    def truncateSentence(self, s, k):
        for i in range(len(s)):
            if s[i] == ' ':
                k -= 1
                if not k:
                    return s[:i]
        return s
",n
"
class Solution(object):
    def trap(self, height):
        result, left, right, level = 0, 0, len(height)-1, 0
        while left < right:
            if height[left] < height[right]:
                lower = height[left]
                left += 1
            else:
                lower = height[right]
                right -= 1
            level = max(level, lower)
            result += level-lower
        return result


",n
"class Solution2(object):
    def trap(self, A):
        result = 0
        top = 0
        for i in range(len(A)):
            if A[top] < A[i]:
                top = i

        second_top = 0
        for i in range(top):
            if A[second_top] < A[i]:
                second_top = i
            result += A[second_top] - A[i]

        second_top = len(A) - 1
        for i in reversed(range(top, len(A))):
            if A[second_top] < A[i]:
                second_top = i
            result += A[second_top] - A[i]

        return result


",n
"class Solution3(object):
    def trap(self, height):
        right = [0]*len(height)
        mx = 0
        for i in reversed(range(len(height))):
            right[i] = mx
            mx = max(mx, height[i])
        result = left = 0
        for i in range(len(height)):
            left = max(left, height[i])
            result += max(min(left, right[i])-height[i], 0)
        return result


",n
"class Solution4(object):
    def trap(self, height):
        result = 0
        stk = []
        for i in range(len(height)):
            prev = 0
            while stk and height[stk[-1]] <= height[i]:
                j = stk.pop()
                result += (height[j] - prev) * (i - j - 1)
                prev = height[j]
            if stk:
                result += (height[i] - prev) * (i - stk[-1] - 1)
            stk.append(i)
        return result
",n
"

class Solution(object):
    def canReach(self, s, minJump, maxJump):
        dp = [False]*len(s)
        dp[0] = True
        cnt = 0
        for i in range(1, len(s)):
            if i >= minJump:
                cnt += dp[i-minJump]
            if i > maxJump:
                cnt -= dp[i-maxJump-1]
            dp[i] = cnt > 0 and s[i] == '0'
        return dp[-1]


",n
"import collections



class Solution2(object):
    def canReach(self, s, minJump, maxJump):
        q = collections.deque([0])
        reachable = 0
        while q:
            i = q.popleft()
            for j in range(max(i+minJump, reachable+1), min(i+maxJump+1, len(s))):
                if s[j] != '0':
                    continue
                q.append(j)
            reachable = i+maxJump
        return i == len(s)-1
",n
"
class Solution(object):
    def validSubarrays(self, nums):
        result = 0
        s = []
        for num in nums:
            while s and s[-1] > num:
                s.pop()
            s.append(num)
            result += len(s)
        return result
",n
"import collections



class Solution(object):
    def minimumOperations(self, nums):
        even_top = collections.Counter(nums[i] for i in range(0, len(nums), 2)).most_common(2) 
        odd_top = collections.Counter(nums[i] for i in range(1, len(nums), 2)).most_common(2) 
        if not odd_top or even_top[0][0] != odd_top[0][0]:
            return len(nums)-even_top[0][1]-(odd_top[0][1] if odd_top else 0)
        return min(len(nums)-even_top[0][1]-(odd_top[1][1] if len(odd_top) == 2 else 0),
                   len(nums)-odd_top[0][1]-(even_top[1][1] if len(even_top) == 2 else 0))
",n
"
import collections
from sortedcontainers import SortedList



class Solution(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = (self.__bit[i]+val) % MOD
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret = (ret+self.__bit[i]) % MOD
                    i -= (i & -i)
                return ret

        def update(accu, d):
            i = sl.bisect_left(idxs[x][-1])
            accu = (accu + d*(len(nums)*(2*len(sl)-1) - (2*i+1)*idxs[x][-1] - 2*(bit.query(len(nums)-1)-bit.query(idxs[x][-1])))) % MOD
            bit.add(idxs[x][-1], d*idxs[x][-1])
            return accu

        idxs = collections.defaultdict(list)
        for i in reversed(range(len(nums))):
            idxs[nums[i]].append(i)
        result = 0
        sl = SortedList(idxs[x][-1] for x in idxs)
        accu = (len(nums)*len(sl)**2) % MOD
        for i, x in enumerate(sl):
            accu = (accu-(2*i+1)*x) % MOD
        bit = BIT(len(nums))
        for x in sl:
            bit.add(x, x)
        for x in nums:
            result = (result+accu) % MOD 
            accu = update(accu, -1)
            del sl[0]
            idxs[x].pop()
            if not idxs[x]:
                continue
            sl.add(idxs[x][-1])
            accu = update(accu, +1)
        assert(accu == 0)
        return result


",nlogn
"
class Solution2(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=None,
                         query_fn=lambda x, y: y if x is None else x if y is None else (x+y)%MOD,
                         update_fn=lambda x, y: y if x is None else (x+y)%MOD):
                self.tree = [None]*(1<<((N-1).bit_length()+1))
                self.base = len(self.tree)>>1
                self.lazy = [None]*self.base
                self.query_fn = query_fn
                self.update_fn = update_fn
                if build_fn is not None:
                    for i in range(self.base, self.base+N):
                        self.tree[i] = build_fn(i-self.base)
                    for i in reversed(range(1, self.base)):
                        self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])
                self.count = [1]*len(self.tree) 
                for i in reversed(range(1, self.base)): 
                    self.count[i] = self.count[i<<1] + self.count[(i<<1)+1]

            def __apply(self, x, val):
                self.tree[x] = self.update_fn(self.tree[x], val*self.count[x]) 
                if x < self.base:
                    self.lazy[x] = self.update_fn(self.lazy[x], val)

            def __push(self, x):
                for h in reversed(range(1, x.bit_length())):
                    y = x>>h
                    if self.lazy[y] is not None:
                        self.__apply(y<<1, self.lazy[y])
                        self.__apply((y<<1)+1, self.lazy[y])
                        self.lazy[y] = None

            def update(self, L, R, h): 
                def pull(x):
                    while x > 1:
                        x >>= 1
                        self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])
                        if self.lazy[x] is not None:
                            self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x]) 

                L += self.base
                R += self.base
                L0, R0 = L, R
                while L <= R:
                    if L & 1: 
                        self.__apply(L, h)
                        L += 1
                    if R & 1 == 0: 
                        self.__apply(R, h)
                        R -= 1
                    L >>= 1
                    R >>= 1
                pull(L0)
                pull(R0)

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                self.__push(L)
                self.__push(R)
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L >>= 1
                    R >>= 1
                return self.query_fn(left, right)

        result = accu = 0
        sl = {}
        st = SegmentTree(len(nums))
        for i in range(len(nums)):
            j = sl[nums[i]] if nums[i] in sl else -1
            accu = (accu+((i-j)+2*max(st.query(j+1, i), 0)))%MOD
            result = (result+accu)%MOD
            st.update(j+1, i, 1) 
            sl[nums[i]] = i
        return result
",nlogn
"

class Solution(object):
    def findSubarrays(self, nums):
        lookup = set()
        for i in range(len(nums)-1):
            if nums[i]+nums[i+1] in lookup:
                return True
            lookup.add(nums[i]+nums[i+1])
        return False
",n
"

class Solution(object):
    def numSubarraysWithSum(self, A, S):
        result = 0
        left, right, sum_left, sum_right = 0, 0, 0, 0
        for i, a in enumerate(A):
            sum_left += a
            while left < i and sum_left > S:
                sum_left -= A[left]
                left += 1
            sum_right += a
            while right < i and \
                  (sum_right > S or (sum_right == S and not A[right])):
                sum_right -= A[right]
                right += 1
            if sum_left == S:
                result += right-left+1
        return result
",n
"
class Solution(object):
    def deleteNode(self, root, key):
        if not root:
            return root

        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        elif root.val < key:
            root.right = self.deleteNode(root.right, key)
        else:
            if not root.left:
                right = root.right
                del root
                return right
            elif not root.right:
                left = root.left
                del root
                return left
            else:
                successor = root.right
                while successor.left:
                    successor = successor.left

                root.val = successor.val
                root.right = self.deleteNode(root.right, successor.val)

        return root

",h
"

class Solution(object):
    def canSortArray(self, nums):
        def popcount(x):
            return bin(x).count(""1"")
    
        left = mx = 0
        for right in range(len(nums)):
            if right+1 != len(nums) and popcount(nums[right+1]) == popcount(nums[right]):
                continue
            if mx > min(nums[i] for i in range(left, right+1)):
                return False
            mx = max(nums[i] for i in range(left, right+1))
            left = right+1
        return True


",n
"import itertools



class Solution2(object):
    def canSortArray(self, nums):
        def popcount(x):
            return bin(x).count(""1"")
        
        def pairwise(it):
            a, b = tee(it)
            next(b, None)
            return zip(a, b)

        return all(max(a) <= min(b) for a, b in pairwise(list(it) for key, it in groupby(nums, popcount)))


",n
"
class Solution3(object):
    def canSortArray(self, nums):
        def popcount(x):
            return bin(x).count(""1"")
    
        left = 0
        for right in range(len(nums)):
            if right+1 != len(nums) and popcount(nums[right+1]) == popcount(nums[right]):
                continue
            nums[left:right+1] = sorted(nums[left:right+1])
            left = right+1
        return all(nums[i] <= nums[i+1] for i in range(len(nums)-1))
",nlogn
"
class Solution(object):
    def wordBreak(self, s, wordDict):
        n = len(s)

        max_len = 0
        for string in wordDict:
            max_len = max(max_len, len(string))

        can_break = [False for _ in range(n + 1)]
        can_break[0] = True
        for i in range(1, n + 1):
            for l in range(1, min(i, max_len) + 1):
                if can_break[i-l] and s[i-l:i] in wordDict:
                    can_break[i] = True
                    break

        return can_break[-1]


",n * l^2
"
import collections


class Solution(object):
    def longestSubarray(self, nums, limit):
        max_dq, min_dq = collections.deque(), collections.deque()
        left = 0
        for right, num in enumerate(nums):
            while max_dq and nums[max_dq[-1]] <= num:
                max_dq.pop()
            max_dq.append(right)
            while min_dq and nums[min_dq[-1]] >= num:
                min_dq.pop()
            min_dq.append(right)
            if nums[max_dq[0]]-nums[min_dq[0]] > limit:
                if max_dq[0] == left:
                    max_dq.popleft()
                if min_dq[0] == left:
                    min_dq.popleft()
                left += 1 
        return len(nums)-left


",n
"import collections


class Solution2(object):
    def longestSubarray(self, nums, limit):
        max_dq, min_dq = collections.deque(), collections.deque()
        result, left = 0, 0
        for right, num in enumerate(nums):
            while max_dq and nums[max_dq[-1]] <= num:
                max_dq.pop()
            max_dq.append(right)
            while min_dq and nums[min_dq[-1]] >= num:
                min_dq.pop()
            min_dq.append(right)
            while nums[max_dq[0]]-nums[min_dq[0]] > limit: 
                if max_dq[0] == left:
                    max_dq.popleft()
                if min_dq[0] == left:
                    min_dq.popleft()
                left += 1
            result = max(result, right-left+1)
        return result
",n
"
class Solution(object):
    def waysToSplit(self, nums):
        MOD = 10**9+7

        prefix = [0]
        for x in nums:
            prefix.append(prefix[-1]+x)

        result = left = right = 0 
        for i in range(len(nums)): 
            left = max(left, i+1)
            while left+1 < len(nums) and prefix[i+1] > prefix[left+1]-prefix[i+1]:
                left += 1
            right = max(right, left)
            while right+1 < len(nums) and prefix[right+1]-prefix[i+1] <= prefix[-1]-prefix[right+1]:
                right += 1
            result = (result + (right-left))%MOD
        return result
",n
"
class Solution(object):
    def checkValid(self, matrix):
        return all(len(set(row)) == len(matrix) for row in matrix) and all(len(set(matrix[i][j] for i in range(len(matrix)))) == len(matrix) for j in range(len(matrix[0])))


",n^2
"
class Solution_Wrong(object):
    def checkValid(self, matrix):
        return all(reduce(lambda x, y: x^y, (matrix[i][j]^(j+1) for j in range(len(matrix[0])))) == 0 for i in range(len(matrix))) and \
               all(reduce(lambda x, y: x^y, (matrix[i][j]^(i+1) for i in range(len(matrix)))) == 0 for j in range(len(matrix[0])))
",n^2
"
class Solution(object):
    def countSegments(self, s):
        result = int(len(s) and s[-1] != ' ')
        for i in range(1, len(s)):
            if s[i] == ' ' and s[i-1] != ' ':
                result += 1
        return result

    def countSegments2(self, s):
        return len([i for i in s.strip().split(' ') if i])

",n
"
class Solution(object):
    def videoStitching(self, clips, T):
        if T == 0:
            return 0
        result = 1
        curr_reachable, reachable = 0, 0
        clips.sort()
        for left, right in clips:
            if left > reachable:
                break
            elif left > curr_reachable:
                curr_reachable = reachable
                result += 1
            reachable = max(reachable, right)
            if reachable >= T:
                return result
        return -1
",nlogn
"

class Solution(object):
    def maximumGood(self, statements):
        def check(mask):
            return all(((mask>>j)&1) == statements[i][j]
                       for i in range(len(statements)) if (mask>>i)&1 
                       for j in range(len(statements[i])) if statements[i][j] != 2)

        def popcount(x):
            result = 0
            while x:
                x &= x-1
                result += 1
            return result

        result = 0
        for mask in range(1<<len(statements)):
            if check(mask):
                result = max(result, popcount(mask))
        return result
",n^2 * 2^n
"
class Solution(object):
    def calculateTime(self, keyboard, word):
        lookup = {c:i for i, c in enumerate(keyboard)}
        result, prev = 0, 0
        for c in word:
            result += abs(lookup[c]-prev)
            prev = lookup[c]
        return result
",n
"
class Solution(object):
    def removeDuplicates(self, A):
        if not A:
            return 0

        last = 0
        for i in range(len(A)):
            if A[last] != A[i]:
                last += 1
                A[last] = A[i]
        return last + 1

",n
"
class Solution(object):
    def validWordAbbreviation(self, word, abbr):
        i , digit = 0, 0
        for c in abbr:
            if c.isdigit():
                if digit == 0 and c == '0':
                    return False
                digit *= 10
                digit += int(c)
            else:
                if digit:
                    i += digit
                    digit = 0
                if i >= len(word) or word[i] != c:
                    return False
                i += 1
        if digit:
            i += digit

        return i == len(word)

",n
"

class Solution(object):
    def removeOccurrences(self, s, part):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
        
        prefix = getPrefix(part)
        result, lookup = [], []
        i = -1
        for c in s:
            while i != -1 and part[i+1] != c:
                i = prefix[i]
            if part[i+1] == c:
                i += 1
            result.append(c)
            lookup.append(i)
            if i == len(part)-1:
                result[len(result)-len(part):] = []
                lookup[len(lookup)-len(part):] = []
                i = lookup[-1] if lookup else -1
        return """".join(result)
",n + m
"

class Solution(object):
    def minimumOperationsToMakeEqual(self, x, y):
        def memoization(x):
            if y >= x:
                return y-x
            if x not in lookup:
                lookup[x] = min(x-y, min(min(x%d, d-x%d)+memoization(x//d+int(d-x%d < x%d))+1 for d in (5, 11)))
            return lookup[x]
    
        lookup = {}
        return memoization(x)


",x
"
class Solution2(object):
    def minimumOperationsToMakeEqual(self, x, y):
        if y >= x:
            return y-x
        upper_bound = x+(x-y)
        result = 0
        lookup = {x}
        q = [x]
        while q:
            new_q = []
            for x in q:
                if x == y:
                    return result
                candidates = [x+1, x-1]
                for d in (5, 11):
                    if x%d == 0:
                        candidates.append(x//d)
                for new_x in candidates:
                    if not (0 <= new_x <= upper_bound and new_x not in lookup):
                        continue
                    lookup.add(new_x)
                    new_q.append(new_x)
            q = new_q
            result += 1
        return -1
",x
"
import collections


class Solution(object):
    def maxConsecutiveAnswers(self, answerKey, k):
        result = max_count = 0
        count = collections.Counter()
        for i in range(len(answerKey)):
            count[answerKey[i]] += 1
            max_count = max(max_count, count[answerKey[i]])
            if result-max_count >= k:
                count[answerKey[i-result]] -= 1
            else:
                result += 1
        return result
",n
"
import collections


class Solution(object):
    def shortestAlternatingPaths(self, n, red_edges, blue_edges):
        neighbors = [[set() for _ in range(2)] for _ in range(n)]
        for i, j in red_edges:
            neighbors[i][0].add(j)
        for i, j in blue_edges:
            neighbors[i][1].add(j)
        INF = max(2*n-3, 0)+1
        dist = [[INF, INF] for i in range(n)]
        dist[0] = [0, 0]
        q = collections.deque([(0, 0), (0, 1)])
        while q:
            i, c = q.popleft()
            for j in neighbors[i][c]:
                if dist[j][c] != INF:
                    continue
                dist[j][c] = dist[i][1^c]+1
                q.append((j, 1^c))
        return [x if x != INF else -1 for x in map(min, dist)]
",n + e
"

class Solution(object):
    def largestPerimeter(self, nums):
        nums.sort()
        prefix = sum(nums)
        for i in reversed(range(2, len(nums))):
            prefix -= nums[i]
            if prefix > nums[i]:
                return prefix+nums[i]
        return -1
",nlogn
"
import collections



class Solution(object):
    def countBadPairs(self, nums):
        result = len(nums)*(len(nums)-1)//2
        cnt = collections.Counter()
        for i, x in enumerate(nums):
            result -= cnt[x-i]
            cnt[x-i] += 1
        return result
",n
"
class Solution(object):
    def maxWidthRamp(self, A):
        result = 0
        s = []
        for i in A:
            if not s or A[s[-1]] > A[i]:
                s.append(i)
        for j in reversed(range(len(A))):
            while s and A[s[-1]] <= A[j]:
                result = max(result, j-s.pop())
        return result
",n
"
import collections


class Solution(object):
    def isSolvable(self, words, result):
        def backtracking(words, result, i, j, carry, lookup, used):
            if j == len(result):
                return carry == 0

            if i != len(words):
                if j >= len(words[i]) or words[i][j] in lookup:
                    return backtracking(words, result, i+1, j, carry, lookup, used)     
                for val in range(10):
                    if val in used or (val == 0 and j == len(words[i])-1):
                        continue
                    lookup[words[i][j]] = val
                    used.add(val)
                    if backtracking(words, result, i+1, j, carry, lookup, used):
                        return True
                    used.remove(val)
                    del lookup[words[i][j]]
                return False

            carry, val = divmod(carry + sum(lookup[w[j]] for w in words if j < len(w)), 10)
            if result[j] in lookup:
                return val == lookup[result[j]] and \
                       backtracking(words, result, 0, j+1, carry, lookup, used)
            if val in used or (val == 0 and j == len(result)-1):
                return False
            lookup[result[j]] = val
            used.add(val)
            if backtracking(words, result, 0, j+1, carry, lookup, used):
                return True
            used.remove(val)
            del lookup[result[j]]
            return False
        
        return backtracking([w[::-1] for w in words], result[::-1], 0, 0, 0, {}, set())
",10! * n * l
"
from sortedcontainers import SortedList



class Solution(object):
    def getResults(self, queries):
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [default]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret
            
        sl = SortedList(q[1] for q in queries if q[0] == 1)
        val_to_idx = {x:i for i, x in enumerate(sl)}
        bit = BIT(len(val_to_idx), fn=max)
        for i in range(len(sl)):
            bit.update(val_to_idx[sl[i]], sl[i]-(sl[i-1] if i-1 >= 0 else 0))
        result = []
        for q in reversed(queries):
            i = sl.bisect_left(q[1])
            if q[0] == 1:
                if i+1 < len(sl):
                    bit.update(val_to_idx[sl[i+1]], sl[i+1]-(sl[i-1] if i-1 >= 0 else 0))
                del sl[i]
            else:
                result.append(q[1]-(sl[i-1] if i-1 >= 0 else 0) >= q[2] or (i-1 >= 0 and bit.query(val_to_idx[sl[i-1]]) >= q[2]))
        result.reverse()
        return result


",qlogq
"from sortedcontainers import SortedList



class Solution2(object):
    def getResults(self, queries):
        class SegmentTree(object):
            def __init__(self, N,
                        build_fn=lambda _: None,
                        query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                        update_fn=lambda x: x):
                self.tree = [None]*(1<<((N-1).bit_length()+1))
                self.base = len(self.tree)>>1
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x >>= 1
                    self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])

            def query(self, L, R):
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L >>= 1
                    R >>= 1
                return self.query_fn(left, right)

        def update(x):
            sl.add(x)
            i = sl.bisect_left(x)
            st.update(val_to_idx[x], x-(sl[i-1] if i-1 >= 0 else 0))
            if i+1 < len(sl):
                st.update(val_to_idx[sl[i+1]], sl[i+1]-x)
            
        val_to_idx = {x:i for i, x in enumerate(sorted(q[1] for q in queries if q[0] == 1))}
        st = SegmentTree(len(val_to_idx))
        sl = SortedList()
        result = []
        for q in queries:
            if q[0] == 1:
                update(q[1])
            else:
                i = sl.bisect_left(q[1])
                result.append(q[1]-(sl[i-1] if i-1 >= 0 else 0) >= q[2] or (i-1 >= 0 and st.query(0, val_to_idx[sl[i-1]]) >= q[2]))
        return result
",qlogq
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def maxSumBST(self, root):
        result = 0
        stk = [[root, None, []]]
        while stk:
            node, tmp, ret = stk.pop()
            if tmp:
                lvalid, lsum, lmin, lmax = tmp[0]
                rvalid, rsum, rmin, rmax = tmp[1]
                if lvalid and rvalid and lmax < node.val < rmin:
                    total = lsum + node.val + rsum
                    result = max(result, total)
                    ret[:] = [True, total, min(lmin, node.val), max(node.val, rmax)]
                    continue
                ret[:] = [False, 0, 0, 0]
                continue
            if not node:
                ret[:] = [True, 0, float(""inf""), float(""-inf"")]
                continue
            new_tmp = [[], []]
            stk.append([node, new_tmp, ret])
            stk.append([node.right, None, new_tmp[1]])
            stk.append([node.left, None, new_tmp[0]])
        return result


",n
"
class Solution2(object):
    def maxSumBST(self, root):
        def dfs(node, result):
            if not node:
                return True, 0, float(""inf""), float(""-inf"")
            lvalid, lsum, lmin, lmax = dfs(node.left, result)
            rvalid, rsum, rmin, rmax = dfs(node.right, result)
            if lvalid and rvalid and lmax < node.val < rmin:
                total = lsum + node.val + rsum
                result[0] = max(result[0], total)
                return True, total, min(lmin, node.val), max(node.val, rmax)
            return False, 0, 0, 0

        result = [0]
        dfs(root, result)
        return result[0]
",n
"
class Solution(object):
    def numPermsDISequence(self, S):
        dp = [1]*(len(S)+1)
        for c in S:
            if c == ""I"":
                dp = dp[:-1]
                for i in range(1, len(dp)):
                    dp[i] += dp[i-1]
            else:
                dp = dp[1:]
                for i in reversed(range(len(dp)-1)):
                    dp[i] += dp[i+1]
        return dp[0] % (10**9+7)

",n^2
"
import math





class Solution(object):
    def numPoints(self, points, r):
        def count_points(points, r, i):
            angles = []
            for j in range(len(points)):
                if i == j:
                    continue
                dx, dy = points[i][0]-points[j][0], points[i][1]-points[j][1]
                d = math.sqrt(dx**2 + dy**2)
                if d > 2*r:
                    continue
                delta, angle = math.acos(d/(2*r)), math.atan2(dy, dx)
                angles.append((angle-delta, 0)), angles.append((angle+delta, 1))
            angles.sort()
            result, count = 1, 1
            for _, is_closed in angles: 
                if not is_closed:
                    count += 1
                else:
                    count -= 1
                result = max(result, count)
            return result

        return max(count_points(points, r, i) for i in range(len(points)))
",n^2 * logn
"

class Solution(object):
    def minimumOperations(self, nums):
        result = 0
        left, right = 0, len(nums)-1
        l, r = nums[left], nums[right]
        while left < right:
            if l == r:
                left += 1
                right -= 1
                l, r = nums[left], nums[right]
                continue
            if l < r:
                left += 1
                l += nums[left]
            else:
                right -= 1
                r += nums[right]
            result += 1
        return result
            
",n
"    
class Solution(object):
    def maxHeight(self, cuboids):
        for cuboid in cuboids:
            cuboid.sort()
        cuboids.append([0, 0, 0])
        cuboids.sort()
        dp = [0]*len(cuboids)
        for i in range(1, len(cuboids)):
            for j in range(i):
                if all(cuboids[j][k] <= cuboids[i][k] for k in range(3)):
                    dp[i] = max(dp[i], dp[j]+cuboids[i][2])
        return max(dp)
",n^2
"
class Solution(object):
    def maximumNumber(self, num, change):
        mutated = False
        result = list(map(int, list(num)))
        for i, d in enumerate(result):
            if change[d] < d:
                if mutated:
                    break
            elif change[d] > d:
                result[i] = str(change[d])
                mutated = True
        return """".join(map(str, result))
",n
"
import heapq


class Solution(object):
    def minInterval(self, intervals, queries):
        intervals.sort()
        queries = [(q, i) for i, q in enumerate(queries)]
        queries.sort()
        min_heap = []
        i = 0
        result =[-1]*len(queries)
        for q, idx in queries:
            while i != len(intervals) and intervals[i][0] <= q:
                heapq.heappush(min_heap, [intervals[i][1]-intervals[i][0]+1, i])
                i += 1
            while min_heap and intervals[min_heap[0][1]][1] < q:
                heapq.heappop(min_heap)
            result[idx] = min_heap[0][0] if min_heap else -1
        return result
",nlogn + klogk + klogn
"
import itertools


class Solution(object):
    def areSentencesSimilar(self, words1, words2, pairs):
        if len(words1) != len(words2): return False
        lookup = set(map(tuple, pairs))
        return all(w1 == w2 or (w1, w2) in lookup or (w2, w1) in lookup \
                   for w1, w2 in zip(words1, words2))

",n + p
"

class Solution(object):
    def findTheWinner(self, n, k):
        return reduce(lambda idx, n:(idx+k)%(n+1), range(1, n), 0)+1


",n
"
class Solution2(object):
    def findTheWinner(self, n, k):
        def f(idx, n, k):
            if n == 1:
                return 0
            return (k+f((idx+k)%n, n-1, k))%n
        
        return f(0, n, k)+1
",n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def bstToGst(self, root):
        def bstToGstHelper(root, prev):
            if not root:
                return root
            bstToGstHelper(root.right, prev)
            root.val += prev[0]
            prev[0] = root.val
            bstToGstHelper(root.left, prev)
            return root
        
        prev = [0]
        return bstToGstHelper(root, prev)
",n
"
class Solution(object):
    def bestRotation(self, A):
        N = len(A)
        change = [1] * N
        for i in range(N):
            change[(i-A[i]+1)%N] -= 1
        for i in range(1, N):
            change[i] += change[i-1]
        return change.index(max(change))


",n
"



class Solution(object):
    def toGoatLatin(self, S):
        def convert(S):
            vowel = set('aeiouAEIOU')
            for i, word in enumerate(S.split(), 1):
                if word[0] not in vowel:
                    word = word[1:] + word[:1]
                yield word + 'ma' + 'a'*i
        return "" "".join(convert(S))

",n + w^2
"


class Solution(object):
    def numberOfPatterns(self, m, n):
        def merge(used, i):
            return used | (1 << i)

        def number_of_keys(i):
            number = 0
            while i > 0:
                i &= i - 1
                number += 1
            return number

        def contain(used, i):
            return bool(used & (1 << i))

        def convert(i, j):
            return 3 * i + j

        dp = [[0] * 9 for _ in range(1 << 9)]
        for i in range(9):
            dp[merge(0, i)][i] = 1

        res = 0
        for used in range(len(dp)):
            number = number_of_keys(used)
            if number > n:
                continue

            for i in range(9):
                if not contain(used, i):
                    continue

                if m <= number <= n:
                    res += dp[used][i]

                x1, y1 = divmod(i, 3)
                for j in range(9):
                    if contain(used, j):
                        continue

                    x2, y2 = divmod(j, 3)
                    if ((x1 == x2 and abs(y1 - y2) == 2) or
                        (y1 == y2 and abs(x1 - x2) == 2) or
                        (abs(x1 - x2) == 2 and abs(y1 - y2) == 2)) and \
                       not contain(used,
                                   convert((x1 + x2) // 2, (y1 + y2) // 2)):
                            continue

                    dp[merge(used, j)][j] += dp[used][i]

        return res


",9^2 * 2^9
"
class Solution2(object):
    def numberOfPatterns(self, m, n):
        def merge(used, i):
            return used | (1 << i)

        def number_of_keys(i):
            number = 0
            while i > 0:
                i &= i - 1
                number += 1
            return number

        def exclude(used, i):
            return used & ~(1 << i)

        def contain(used, i):
            return bool(used & (1 << i))

        def convert(i, j):
            return 3 * i + j

        dp = [[0] * 9 for _ in range(1 << 9)]
        for i in range(9):
            dp[merge(0, i)][i] = 1

        res = 0
        for used in range(len(dp)):
            number = number_of_keys(used)
            if number > n:
                continue

            for i in range(9):
                if not contain(used, i):
                    continue

                x1, y1 = divmod(i, 3)
                for j in range(9):
                    if i == j or not contain(used, j):
                        continue

                    x2, y2 = divmod(j, 3)
                    if ((x1 == x2 and abs(y1 - y2) == 2) or
                        (y1 == y2 and abs(x1 - x2) == 2) or
                        (abs(x1 - x2) == 2 and abs(y1 - y2) == 2)) and \
                       not contain(used,
                                   convert((x1 + x2) // 2, (y1 + y2) // 2)):
                            continue

                    dp[used][i] += dp[exclude(used, i)][j]

                if m <= number <= n:
                    res += dp[used][i]

        return res


",9^2 * 2^9
"
class Solution_TLE(object):
    def numberOfPatterns(self, m, n):
        def merge(used, i):
            return used | (1 << i)

        def contain(used, i):
            return bool(used & (1 << i))

        def convert(i, j):
            return 3 * i + j

        def numberOfPatternsHelper(m, n, level, used, i):
            number = 0
            if level > n:
                return number

            if m <= level <= n:
                number += 1

            x1, y1 = divmod(i, 3)
            for j in range(9):
                if contain(used, j):
                    continue

                x2, y2 = divmod(j, 3)
                if ((x1 == x2 and abs(y1 - y2) == 2) or
                    (y1 == y2 and abs(x1 - x2) == 2) or
                    (abs(x1 - x2) == 2 and abs(y1 - y2) == 2)) and \
                   not contain(used,
                               convert((x1 + x2) // 2, (y1 + y2) // 2)):
                        continue

                number += numberOfPatternsHelper(m, n, level + 1, merge(used, j), j)

            return number

        number = 0
        number += 4 * numberOfPatternsHelper(m, n, 1, merge(0, 0), 0)
        number += 4 * numberOfPatternsHelper(m, n, 1, merge(0, 1), 1)
        number += numberOfPatternsHelper(m, n, 1, merge(0, 4), 4)
        return number

",9!
"

class Solution(object):
    def distributeCandies(self, n, limit):
        def nCr(n, r): 
            if not 0 <= r <= n:
                return 0
            if n-r < r:
                r = n-r
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
        
        def nHr(n, r):
            return nCr(n+(r-1), r-1)
    
        R = 3
        return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R)for r in range(R+1))


",1
"
class Solution2(object):
    def distributeCandies(self, n, limit):
        return sum(min(limit, n-i)-max((n-i)-limit, 0)+1 for i in range(max(n-2*limit, 0), min(limit, n)+1))


",n
"
class Solution3(object):
    def distributeCandies(self, n, limit):
        return sum(n-i-j <= limit for i in range(min(limit, n)+1) for j in range(min(limit, n-i)+1))
",n^2
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maxPathSum(self, root):
        def iter_dfs(node):
            result = float(""-inf"")
            max_sum = [0]
            stk = [(1, [node, max_sum])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    result = max(result, node.val+max(ret1[0], 0)+max(ret2[0], 0))
                    ret[0] = node.val+max(ret1[0], ret2[0], 0)
            return result
        
        return iter_dfs(root)


",n
"class Solution2(object):
    def maxPathSum(self, root):
        def dfs(node):
            if not node:
                return (float(""-inf""), 0)
            max_left, curr_left = dfs(node.left)
            max_right, curr_right = dfs(node.right)
            return (max(max_left, max_right, node.val+max(curr_left, 0)+max(curr_right, 0)),
                    node.val+max(curr_left, curr_right, 0))
        
        return dfs(root)[0]
",n
"
class Solution(object):
    def findNthDigit(self, n):
        digit_len = 1
        while n > digit_len * 9 * (10 ** (digit_len-1)):
            n -= digit_len  * 9 * (10 ** (digit_len-1))
            digit_len += 1

        num = 10 ** (digit_len-1) + (n-1)/digit_len

        nth_digit = num / (10 ** ((digit_len-1) - ((n-1)%digit_len)))
        nth_digit %= 10

        return nth_digit

",logn
"
class Solution(object):
    def lastRemaining(self, n):
        start, step, direction = 1, 2, 1
        while n > 1:
            start += direction * (step * (n//2) - step//2)
            n //= 2
            step *= 2
            direction *= -1
        return start
",logn
"

class Solution(object):
    def minimumRightShifts(self, nums):
        i = next((i for i in range(len(nums)) if not nums[i] < nums[(i+1)%len(nums)]), len(nums))
        j = next((j for j in range(i+1, len(nums)) if not nums[j%len(nums)] < nums[(j+1)%len(nums)]), len(nums))
        return len(nums)-(i+1) if j == len(nums) else -1
",n
"

class Solution(object):
    def maximumSubarraySum(self, nums, k):
        result = left = total = 0
        lookup = set()
        for right in range(len(nums)):
            while nums[right] in lookup or len(lookup) == k:
                lookup.remove(nums[left])
                total -= nums[left]
                left += 1
            lookup.add(nums[right])
            total += nums[right]
            if len(lookup) == k:
                result = max(result, total)
        return result
",n
"

class Solution(object):
    def maximumHappinessSum(self, happiness, k):
        happiness.sort(reverse=True)
        return sum(max(happiness[i]-i, 0) for i in range(k))
",nlogn
"

class Solution(object):
    def maxScore(self, nums):
        result = mx = 0
        for i in reversed(range(1, len(nums))):
            mx = max(mx, nums[i])
            result += mx
        return result


",n
"
class Solution2(object):
    def maxScore(self, nums):
        dp = [0]*len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                dp[i] = max(dp[i], dp[j]+(i-j)*nums[i])
        return dp[-1]
",n^2
"

class Solution(object):
    def numberOfGoodPartitions(self, nums):
        MOD = 10**9+7
        lookup = {x:i for i, x in enumerate(nums)}
        result = 1
        right = cnt = 0
        for left, x in enumerate(nums):
            if left == right+1:
                cnt += 1
            right = max(right, lookup[x])
        return pow(2, cnt, MOD)
",n
"
class Solution(object):
    def maxPower(self, s):
        result, count = 1, 1
        for i in range(1, len(s)):
            if s[i] == s[i-1]:
                count += 1
            else:
                count = 1
            result = max(result, count)
        return result


",n
"import itertools


class Solution2(object):
    def maxPower(self, s):
        return max(len(list(v)) for _, v in itertools.groupby(s))
",n
"

class Solution(object):
    def subsequenceCount(self, nums):
        MOD = 10**9+7
        return pow(2, len(nums)-1, MOD) if any(x%2 for x in nums) else 0


",n
"
class Solution2(object):
    def subsequenceCount(self, nums):
        MOD = 10**9+7
        dp = [0]*2
        for x in nums:
            dp = [(dp[i]+dp[i^(x%2)]+int(x%2 == i))%MOD for i in range(2)]
        return dp[1]
",n
"
class Solution(object):
    def isValidPalindrome(self, s, k):
        if s == s[::-1]: 
            return True

        dp = [[1] * len(s) for _ in range(2)]
        for i in reversed(range(len(s))):
            for j in range(i+1, len(s)):
                if s[i] == s[j]:
                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2
                else:
                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])
        return len(s) <= k + dp[0][-1]
",n^2
"
import heapq



class Solution(object):
    def maxSpending(self, values):
        m, n = len(values), len(values[0])
        min_heap = [(values[i].pop(), i) for i in range(m)]
        heapq.heapify(min_heap)
        result = 0
        for d in range(1, m*n+1):
            x, i = heapq.heappop(min_heap)
            result += x*d
            if values[i]:
                heapq.heappush(min_heap, (values[i].pop(), i))
        return result
",m * n * logm
"
class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children


class Solution(object):

    def serialize(self, root):
        def dfs(node, vals):
            if not node:
                return
            vals.append(str(node.val))
            for child in node.children:
                dfs(child, vals)
            vals.append(
        
        vals = []
        dfs(root, vals)
        return "" "".join(vals)


    def deserialize(self, data):
        def isplit(source, sep):
            sepsize = len(sep)
            start = 0
            while True:
                idx = source.find(sep, start)
                if idx == -1:
                    yield source[start:]
                    return
                yield source[start:idx]
                start = idx + sepsize
                
        def dfs(vals):
            val = next(vals)
            if val == 
                return None
            root = Node(int(val), [])
            child = dfs(vals)
            while child:
                root.children.append(child)
                child = dfs(vals)
            return root

        if not data:
            return None
    
        return dfs(iter(isplit(data, ' ')))
        


",n
"

class Solution(object):
    def convertTime(self, current, correct):
        OPS = (60, 15, 5, 1)
        diff = (int(correct[:2])*60+int(correct[3:]))-(int(current[:2])*60+int(current[3:]))
        result = 0
        for x in OPS:
            q, diff = divmod(diff, x)
            result += q
        return result
",1
"
class Solution(object):
    def buildArray(self, target, n):
        result, curr = [], 1
        for t in target:
            result.extend([""Push"", ""Pop""]*(t-curr))
            result.append(""Push"")
            curr = t+1
        return result
",n
"

class Solution(object):
    def houseOfCards(self, n):
        dp = [0]*(n+1) 
        dp[0] = 1
        for t in range(1, (n+1)//3+1):
            for i in reversed(range(3*t-1, n+1)):
                dp[i] += dp[i-(3*t-1)]
        return dp[n]


",n^2
"
class Solution_TLE(object):
    def houseOfCards(self, n):
        dp = [[0]*(n+1) for _ in range((n+1)//3+1)] 
        dp[0][0] = 1
        for t in range(1, (n+1)//3+1):
            for i in range(3*t-1, n+1):
                dp[t][i] = sum(dp[j][i-(3*t-1)] for j in range(t))
        return sum(dp[t][n] for t in range((n+1)//3+1))
",n^3
"
class Solution(object):
    def findMissingRanges(self, nums, lower, upper):
        def getRange(lower, upper):
            if lower == upper:
                return ""{}"".format(lower)
            else:
                return ""{}->{}"".format(lower, upper)
        ranges = []
        pre = lower - 1

        for i in range(len(nums) + 1):
            if i == len(nums):
                cur = upper + 1
            else:
                cur = nums[i]
            if cur - pre >= 2:
                ranges.append(getRange(pre + 1, cur - 1))

            pre = cur

        return ranges


",n
"
class Solution(object):
    def maxSum(self, nums1, nums2):
        MOD = 10**9+7
        i, j = 0, 0
        result, sum1, sum2 = 0, 0, 0,
        while i != len(nums1) or j != len(nums2):
            if i != len(nums1) and (j == len(nums2) or nums1[i] < nums2[j]):
                sum1 += nums1[i]
                i += 1
            elif j != len(nums2) and (i == len(nums1) or nums1[i] > nums2[j]):
                sum2 += nums2[j]
                j += 1
            else:
                result = (result + (max(sum1, sum2) + nums1[i])) % MOD
                sum1, sum2 = 0, 0
                i += 1
                j += 1
        return (result + max(sum1, sum2)) % MOD
",m + n
"

class Solution(object):
    def removeDigit(self, number, digit):
        i = next((i for i in range(len(number)-1) if digit == number[i] < number[i+1]), len(number)-1)
        if i+1 == len(number):
            i = next((i for i in reversed(range(len(number))) if digit == number[i]))
        return number[:i]+number[i+1:]
",n
"
import collections


class Solution(object):

    def __init__(self):
        self.__left, self.__right = collections.deque(), collections.deque()   

    def pushFront(self, val):
        self.__left.appendleft(val)
        self.__balance()        

    def pushMiddle(self, val):
        if len(self.__left) > len(self.__right):
            self.__right.appendleft(self.__left.pop())
        self.__left.append(val)

    def pushBack(self, val):
        self.__right.append(val)
        self.__balance()

    def popFront(self):
        val = (self.__left or collections.deque([-1])).popleft()
        self.__balance()
        return val

    def popMiddle(self):
        val = (self.__left or [-1]).pop()
        self.__balance()
        return val

    def popBack(self):
        val = (self.__right or self.__left or [-1]).pop()
        self.__balance()
        return val

    def __balance(self):
        if len(self.__left) > len(self.__right)+1:
            self.__right.appendleft(self.__left.pop())
        elif len(self.__left) < len(self.__right):
            self.__left.append(self.__right.popleft())
",1
"
import itertools


class Solution(object):
    def canMakePaliQueries(self, s, queries):
        CHARSET_SIZE = 26
        curr, count = [0]*CHARSET_SIZE, [[0]*CHARSET_SIZE]
        for c in s:
            curr[ord(c)-ord('a')] += 1
            count.append(curr[:])
        return [sum((b-a)%2 for a, b in zip(count[left], count[right+1]))//2 <= k
                for left, right, k in queries]
",m + n
"
class Solution(object):
    def minCostClimbingStairs(self, cost):
        dp = [0] * 3
        for i in reversed(range(len(cost))):
            dp[i%3] = cost[i] + min(dp[(i+1)%3], dp[(i+2)%3])
        return min(dp[0], dp[1])

",n
"
class Solution(object):
    def maxValueAfterReverse(self, nums):
        result, add, max_pair, min_pair = 0, 0, float(""-inf""), float(""inf"")
        for i in range(1, len(nums)):
            result += abs(nums[i-1]-nums[i])
            add = max(add,
                      abs(nums[0]-nums[i]) - abs(nums[i-1]-nums[i]),
                      abs(nums[-1]-nums[i-1]) - abs(nums[i-1]-nums[i]))
            min_pair = min(min_pair, max(nums[i-1], nums[i]))
            max_pair = max(max_pair, min(nums[i-1], nums[i]))
        return result + max(add, (max_pair-min_pair)*2)
",n
"

class Solution(object):
    def largestPalindrome(self, n, k):
        def inv(x, p):
            return pow(x, p-2, p)

        def f(l):
            p = 7
            result = ['9']*l
            if l:                
                curr = reduce(lambda accu, x: (accu*10+(ord(x)-ord('0')))%p, result, 0)
                i = 9-(curr*inv(11 if l%2 == 0 else 1, p)*inv(pow(10, l//2-int(l%2 == 0), p), p))%p
                if i <= 2:
                    i += p
                result[l//2] = result[l//2-int(l%2 == 0)] = str(i)
            return """".join(result)

        if k in (1, 3, 9):
            return '9'*n
        if k in (2, 4, 8):
            k = min(k, 6)
            if n <= k:
                return '8'*n
            l = k//2
            return '8'*l+'9'*(n-k)+'8'*l
        if k == 5:
            if n <= 2:
                return '5'*n
            return '5'+'9'*(n-2)+'5'
        if k == 6:
            if n <= 2:
                return '6'*n
            if n%2:
                l = n//2-1
                return '8'+'9'*l+'8'+'9'*l+'8'
            l = n//2-2
            return '8'+'9'*l+""77""+'9'*l+'8'
        l, r = divmod(n, 12)
        return ""999999""*l+f(r)+""999999""*l 
",n
"

class Solution(object):
    def validSubarraySplit(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        dp = [float(""inf"")]*(len(nums)+1) 
        dp[0] = 0
        for i in range(1, len(nums)+1):
            for j in range(i):
                 if gcd(nums[j], nums[i-1]) != 1:
                     dp[i] = min(dp[i], dp[j]+1)
        return dp[-1] if dp[-1] != float(""inf"") else -1
",n^2 * logr
"
import itertools


class Solution(object):
    def maxIncreaseKeepingSkyline(self, grid):
        row_maxes = [max(row) for row in grid]
        col_maxes = [max(col) for col in zip(*grid)]

        return sum(min(row_maxes[r], col_maxes[c])-val \
                   for r, row in enumerate(grid) \
                   for c, val in enumerate(row))

",n^2
"
import collections



class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def countPairs(self, root, distance):
        def iter_dfs(distance, root):
            result = 0
            stk = [(1, (root, [collections.Counter()]))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    if not node.left and not node.right:
                        ret[0][0] = 1
                        continue
                    left, right = [collections.Counter()], [collections.Counter()]
                    stk.append((2, (left, right, ret)))
                    stk.append((1, (node.right, right)))
                    stk.append((1, (node.left, left)))
                else:
                    left, right, ret = params
                    for left_d, left_c in left[0].items():
                        for right_d,right_c in right[0].items():
                            if left_d+right_d+2 <= distance:
                                result += left_c*right_c
                    ret[0] = collections.Counter({k+1:v for k,v in (left[0]+right[0]).items()})
            return result
        
        return iter_dfs(distance, root)


",n
"import collections


class Solution2(object):
    def countPairs(self, root, distance):
        def dfs(distance, node):
            if not node:
                return 0, collections.Counter()
            if not node.left and not node.right:
                return 0, collections.Counter([0])
            left, right = dfs(distance, node.left), dfs(distance, node.right)
            result = left[0]+right[0]
            for left_d, left_c in left[1].items():
                for right_d,right_c in right[1].items():
                    if left_d+right_d+2 <= distance:
                        result += left_c*right_c
            return result, collections.Counter({k+1:v for k,v in (left[1]+right[1]).items()})
        
        return dfs(distance, root)[0]
",n
"


import collections
import heapq
import random


class Solution(object):

    def __init__(self):
        self.__number_of_most_recent_tweets = 10
        self.__followings = collections.defaultdict(set)
        self.__messages = collections.defaultdict(list)
        self.__time = 0

    def postTweet(self, userId, tweetId):
        self.__time += 1
        self.__messages[userId].append((self.__time, tweetId))

    def getNewsFeed(self, userId):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        candidates = []
        if self.__messages[userId]:
            candidates.append((-self.__messages[userId][-1][0], userId, 0))
        for uid in self.__followings[userId]:
            if self.__messages[uid]:
                candidates.append((-self.__messages[uid][-1][0], uid, 0))
        nth_element(candidates, self.__number_of_most_recent_tweets-1)
        max_heap = candidates[:self.__number_of_most_recent_tweets]
        heapq.heapify(max_heap)
        result = []
        while max_heap and len(result) < self.__number_of_most_recent_tweets:
            t, uid, curr = heapq.heappop(max_heap)
            nxt = curr + 1
            if nxt != len(self.__messages[uid]):
                heapq.heappush(max_heap, (-self.__messages[uid][-(nxt+1)][0], uid, nxt))
            result.append(self.__messages[uid][-(curr+1)][1])
        return result

    def follow(self, followerId, followeeId):
        if followerId != followeeId:
            self.__followings[followerId].add(followeeId)

    def unfollow(self, followerId, followeeId):
        self.__followings[followerId].discard(followeeId)
",u + klogk
"

class Solution(object):
    def distributeCandies(self, n, limit):
        def nCr(n, r): 
            if not 0 <= r <= n:
                return 0
            if n-r < r:
                r = n-r
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
        
        def nHr(n, r):
            return nCr(n+(r-1), r-1)
    
        R = 3
        return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R)for r in range(R+1))


",1
"
class Solution2(object):
    def distributeCandies(self, n, limit):
        return sum(min(limit, n-i)-max((n-i)-limit, 0)+1 for i in range(max(n-2*limit, 0), min(limit, n)+1))
",n
"

class Solution(object):
    def maxScore(self, n, k, stayScore, travelScore):
        dp = [0]*n
        for i in range(k):
            dp = [max(dp[u]+stayScore[i][u], max(dp[v]+travelScore[v][u] for v in range(n))) for u in range(n)]
        return max(dp)
",k * n^2
"

class Solution(object):
    def countPaths(self, grid):
        MOD = 10**9+7
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        in_degree = [[0]*len(grid[0]) for _ in range(len(grid))]
        q = []
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                for di, dj in directions:
                    ni, nj = i+di, j+dj
                    if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[i][j] > grid[ni][nj]:
                        in_degree[i][j] += 1
                if not in_degree[i][j]:
                    q.append((i, j))
        dp = [[1]*len(grid[0]) for _ in range(len(grid))]
        result = 0
        while q:
            new_q = []
            for i, j in q:
                result = (result+dp[i][j])%MOD
                for di, dj in directions:
                    ni, nj = i+di, j+dj
                    if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[i][j] < grid[ni][nj]):
                        continue
                    dp[ni][nj] = (dp[ni][nj]+dp[i][j])%MOD
                    in_degree[ni][nj] -= 1
                    if not in_degree[ni][nj]:
                        new_q.append((ni, nj))
            q = new_q
        return result


",m * n
"
class Solution2(object):
    def countPaths(self, grid):
        MOD = 10**9+7
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def memoization(grid, i, j, lookup):
            if not lookup[i][j]:
                lookup[i][j] = 1
                for di, dj in directions:
                    ni, nj = i+di, j+dj
                    if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[i][j] < grid[ni][nj]:
                        lookup[i][j] = (lookup[i][j]+memoization(grid, ni, nj, lookup)) % MOD
            return lookup[i][j]

        lookup = [[0]*len(grid[0]) for _ in range(len(grid))]
        return sum(memoization(grid, i, j, lookup) for i in range(len(grid)) for j in range(len(grid[0]))) % MOD
",m * n
"
import itertools



class Solution(object):
    def paintWalls(self, cost, time):
        dp = [float(""inf"")]*(len(cost)+1)
        dp[0] = 0
        for c, t in zip(cost, time):
            for j in reversed(range(1, len(cost)+1)):
                dp[j] = min(dp[j], dp[max(j-(t+1), 0)]+c)
        return dp[-1]
",n^2
"
class Solution(object):
    def maximumProduct(self, nums):
        min1, min2 = float(""inf""), float(""inf"")
        max1, max2, max3 = float(""-inf""), float(""-inf""), float(""-inf"")

        for n in nums:
            if n <= min1:
                min2 = min1
                min1 = n
            elif n <= min2:
                min2 = n

            if n >= max1:
                max3 = max2
                max2 = max1
                max1 = n
            elif n >= max2:
                max3 = max2
                max2 = n
            elif n >= max3:
                max3 = n

        return max(min1 * min2 * max1, max1 * max2 * max3)

",n
"
class Solution(object):
    def findMaxAverage(self, nums, k):
        def getDelta(avg, nums, k):
            accu = [0.0] * (len(nums) + 1)
            minval_pos = None
            delta = 0.0
            for i in range(len(nums)):
                accu[i+1] = nums[i] + accu[i] - avg
                if i >= (k-1):
                    if minval_pos == None or accu[i-k+1] < accu[minval_pos]:
                        minval_pos = i-k+1
                    if accu[i+1] - accu[minval_pos] >= 0:
                        delta = max(delta, (accu[i+1] - accu[minval_pos]) / (i+1 - minval_pos))
            return delta

        left, delta = min(nums), float(""inf"")
        while delta > 1e-5:
            delta = getDelta(left, nums, k)
            left += delta
        return left

",n
"
class Solution(object):
    def minDistance(self, word1, word2):
        if len(word1) < len(word2):
            return self.minDistance(word2, word1)

        distance = [i for i in range(len(word2) + 1)]

        for i in range(1, len(word1) + 1):
            pre_distance_i_j = distance[0]
            distance[0] = i
            for j in range(1, len(word2) + 1):
                insert = distance[j - 1] + 1
                delete = distance[j] + 1
                replace = pre_distance_i_j
                if word1[i - 1] != word2[j - 1]:
                    replace += 1
                pre_distance_i_j = distance[j]
                distance[j] = min(insert, delete, replace)

        return distance[-1]

",n * m
"class Solution2(object):
    def minDistance(self, word1, word2):
        distance = [[i] for i in range(len(word1) + 1)]
        distance[0] = [j for j in range(len(word2) + 1)]

        for i in range(1, len(word1) + 1):
            for j in range(1, len(word2) + 1):
                insert = distance[i][j - 1] + 1
                delete = distance[i - 1][j] + 1
                replace = distance[i - 1][j - 1]
                if word1[i - 1] != word2[j - 1]:
                    replace += 1
                distance[i].append(min(insert, delete, replace))

        return distance[-1][-1]

",n * m
"
import bisect


class Solution(object):
    def maxValue(self, events, k):
        events.sort(key=lambda x: x[1])
        sorted_ends = [x[1] for x in events]
        dp = [[0]*(k+1) for _ in range(len(events)+1)]
        for i in range(1, len(events)+1):
            prev_i_m_1 = bisect.bisect_left(sorted_ends, events[i-1][0])-1
            for j in range(1, k+1):
                dp[i][j] = max(dp[i-1][j], dp[prev_i_m_1+1][j-1]+events[i-1][2])
        return dp[-1][-1]


",nlogn + n * k
"import bisect


class Solution2(object):
    def maxValue(self, events, k):
        events.sort()
        sorted_starts = [x[0] for x in events]
        dp = [[0]*(k+1) for _ in range(len(events)+1)]
        for i in reversed(range(len(events))):
            next_i = bisect.bisect_right(sorted_starts, events[i][1])-1
            for j in range(1, k+1):
                dp[i][j] = max(dp[i+1][j], dp[next_i+1][j-1]+events[i][2])
        return dp[0][-1]
",nlogn + n * k
"
import collections


class Solution(object):
    def containsNearbyAlmostDuplicate(self, nums, k, t):
        if k < 0 or t < 0:
            return False
        window = collections.OrderedDict()
        for n in nums:
            if len(window) > k:
                window.popitem(False)

            bucket = n if not t else n // t
            for m in (window.get(bucket - 1), window.get(bucket), window.get(bucket + 1)):
                if m is not None and abs(n - m) <= t:
                    return True
            window[bucket] = n
        return False

",n * t
"

class Solution(object):
    def splitWordsBySeparator(self, words, separator):
        return [w for word in words for w in word.split(separator) if w]
",n * l
"
class Solution(object):
    def partition(self, s):
        is_palindrome = [[False] * len(s) for i in range(len(s))]
        for i in reversed(range(len(s))):
            for j in range(i, len(s)):
                is_palindrome[i][j] = s[i] == s[j] and ((j - i < 2) or is_palindrome[i + 1][j - 1])

        sub_partition = [[] for _ in range(len(s))]
        for i in reversed(range(len(s))):
            for j in range(i, len(s)):
                if is_palindrome[i][j]:
                    if j + 1 < len(s):
                        for p in sub_partition[j + 1]:
                            sub_partition[i].append([s[i:j + 1]] + p)
                    else:
                        sub_partition[i].append([s[i:j + 1]])

        return sub_partition[0]


",n^2 ~ 2^n
"
class Solution2(object):
    def partition(self, s):
        result = []
        self.partitionRecu(result, [], s, 0)
        return result

    def partitionRecu(self, result, cur, s, i):
        if i == len(s):
            result.append(list(cur))
        else:
            for j in range(i, len(s)):
                if self.isPalindrome(s[i: j + 1]):
                    cur.append(s[i: j + 1])
                    self.partitionRecu(result, cur, s, j + 1)
                    cur.pop()

    def isPalindrome(self, s):
        for i in range(len(s) / 2):
            if s[i] != s[-(i + 1)]:
                return False
        return True

",2^n
"
class Solution(object):
    def capitalizeTitle(self, title):
        title = list(title)
        j = 0
        for i in range(len(title)+1):
            if i < len(title) and title[i] != ' ':
                title[i] = title[i].lower()
                continue
            if i-j > 2:
                title[j] = title[j].upper()
            j = i+1
        return """".join(title)
",n
"
class Solution(object):
    def kthSmallestPrimeFraction(self, A, K):
        def check(mid, A, K, result):
            tmp = [0]*2
            count = 0
            j = 0
            for i in range(len(A)):
                while j < len(A):
                    if i < j and A[i] < A[j]*mid:
                        if tmp[0] == 0 or \
                           tmp[0]*A[j] < tmp[1]*A[i]:
                            tmp[0] = A[i]
                            tmp[1] = A[j]
                        break
                    j += 1
                count += len(A)-j
            if count == K:
                result[:] = tmp
            return count >= K

        result = []
        left, right = 0.0, 1.0
        while right-left > 1e-8:
            mid = left + (right-left) / 2.0
            if check(mid, A, K, result):
                right = mid
            else:
                left = mid
            if result:
                break
        return result

",nlogr
"

class Solution(object):
    def matrixSum(self, nums):
        for row in nums:
            row.sort()
        return sum(max(nums[r][c] for r in range(len(nums))) for c in range(len(nums[0])))
",m * nlogn
"

class Solution(object):
    def divideArray(self, nums, k):
        nums.sort()
        return [nums[i:i+3] for i in range(0, len(nums), 3)] if all(nums[i+2]-nums[i] <= k for i in range(0, len(nums), 3)) else []
",nlogn
"

class Solution(object):
    def countHillValley(self, nums):
        result, inc = 0, -1
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                result += int(inc == 0)
                inc = 1
            elif nums[i] > nums[i+1]:
                result += int(inc == 1)
                inc = 0
        return result
",n
"
import collections
import heapq


class Solution(object):
    def avoidFlood(self, rains):
        lookup = collections.defaultdict(list)
        i = len(rains)-1
        for lake in reversed(rains):
            lookup[lake].append(i)
            i -= 1
        result, min_heap = [], []
        for i, lake in enumerate(rains):
            if lake:
                if len(lookup[lake]) >= 2:
                    lookup[lake].pop()
                    heapq.heappush(min_heap, lookup[lake][-1])
                result.append(-1)
            elif min_heap:
                j = heapq.heappop(min_heap)
                if j < i:
                    return []
                result.append(rains[j])
            else:
                result.append(1)
        return result if not min_heap else []
",nlogn
"
import collections


class Solution(object):
    def majorityElement(self, nums):
        def boyer_moore_majority_vote():
            result, cnt = None, 0
            for x in nums:
                if not cnt:
                    result = x
                if x == result:
                    cnt += 1
                else:
                    cnt -= 1
            return result

        return boyer_moore_majority_vote()


",n
"import collections


class Solution2(object):
    def majorityElement(self, nums):
        return collections.Counter(nums).most_common(1)[0][0]


",n
"import collections


class Solution3(object):
    def majorityElement(self, nums):
        return sorted(list(collections.Counter(nums).items()), key=lambda a: a[1], reverse=True)[0][0]
",nlogn
"
class Solution(object):
    def subArrayRanges(self, nums):
        result = 0
        stk = []
        for i in range(len(nums)+1):
            x = nums[i] if i < len(nums) else float(""inf"")
            while stk and nums[stk[-1]] <= x:
                j = stk.pop()
                k = stk[-1] if stk else -1
                result += nums[j]*(j-k)*(i-j)
            stk.append(i)
        stk = []
        for i in range(len(nums)+1):
            x = nums[i] if i < len(nums) else float(""-inf"")
            while stk and nums[stk[-1]] >= x:
                j = stk.pop()
                k = stk[-1] if stk else -1
                result -= nums[j]*(j-k)*(i-j)
            stk.append(i)
        return result
",n
"
import itertools


class Solution(object):
    def minSwaps(self, grid):
        result = 0
        for target in reversed(range(1, len(grid))):
            row_idx = len(grid)-1-target
            while row_idx < len(grid):
                row = grid[row_idx]
                if not sum(itertools.islice(row, len(row)-target, len(row))):
                    break
                row_idx += 1
            else:
                return -1
            while row_idx != len(grid)-1-target:
                grid[row_idx], grid[row_idx-1] = grid[row_idx-1], grid[row_idx]
                result += 1
                row_idx -= 1
        return result
",n^2
"
class Solution(object):
    def computeArea(self, A, B, C, D, E, F, G, H):
        return (D - B) * (C - A) + \
               (G - E) * (H - F) - \
               max(0, (min(C, G) - max(A, E))) * \
               max(0, (min(D, H) - max(B, F)))

",1
"
class Solution(object):
    def largestAltitude(self, gain):
        result = curr = 0
        for g in gain:
            curr += g
            result = max(result, curr)
        return result
",n
"
class Solution(object):
    def oddCells(self, n, m, indices):
        row, col = [0]*n, [0]*m
        for r, c in indices:
            row[r] ^= 1
            col[c] ^= 1
        row_sum, col_sum = sum(row), sum(col)
        return row_sum*m+col_sum*n-2*row_sum*col_sum


",n + m
"import collections
import itertools


class Solution2(object):
    def oddCells(self, n, m, indices):
        fn = lambda x: sum(count&1 for count in collections.Counter(x).values())
        row_sum, col_sum = list(map(fn, zip(*indices)))
        return row_sum*m+col_sum*n-2*row_sum*col_sum
",n + m
"
class Solution(object):
    def minSpaceWastedKResizing(self, nums, k):
        INF = float(""inf"")
        k += 1
        dp = [[INF]*(k+1) for _ in range(len(nums)+1)]
        dp[0][0] = 0
        for i in range(1, len(nums)+1):
            total = max_num = 0
            for j in reversed(range(1, i+1)):
                total += nums[j-1]
                max_num = max(max_num, nums[j-1])
                for m in range(1, k+1):
                    if dp[j-1][m-1] != INF:
                        dp[i][m] = min(dp[i][m], dp[j-1][m-1] + (max_num*(i-j+1)-total))
        return dp[-1][-1]
",k * n^2
"

class Solution(object):
    def canAliceWin(self, n):
        c = 10
        l = int(((2*c+1)-((2*c+1)**2-8*n)**0.5)/2)
        return l%2 == 1
    
",1
"

class Solution(object):
    def validSubstringCount(self, word1, word2):
        cnt = [0]*26
        curr = 0
        for x in word2:
            curr += int(cnt[ord(x)-ord('a')] == 0)
            cnt[ord(x)-ord('a')] += 1
        result = left = 0
        for right in range(len(word1)):
            cnt[ord(word1[right])-ord('a')] -= 1
            curr -= int(cnt[ord(word1[right])-ord('a')] == 0)
            while not curr:
                result += len(word1)-right
                curr += int(cnt[ord(word1[left])-ord('a')] == 0)
                cnt[ord(word1[left])-ord('a')] += 1
                left += 1
        return result
",n + 26
"
import collections


class Solution(object):
    def findShortestSubArray(self, nums):
        counts = collections.Counter(nums)
        left, right = {}, {}
        for i, num in enumerate(nums):
            left.setdefault(num, i)
            right[num] = i
        degree = max(counts.values())
        return min(right[num]-left[num]+1 \
                   for num in list(counts.keys()) \
                   if counts[num] == degree)

",n
"
import pandas as pd



def Solution(student_data: List[List[int]]) -> pd.DataFrame:
    return pd.DataFrame(
        data=student_data,
        columns=[""student_id"", ""age""],
    )


",n
"import pandas as pd



def Solution2(student_data: List[List[int]]) -> pd.DataFrame:
    return pd.DataFrame({k:[x[i] for x in student_data] for i, k in enumerate([""student_id"", ""age""])})
",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def rightSideView(self, root):
        result = []
        self.rightSideViewDFS(root, 1, result)
        return result

    def rightSideViewDFS(self, node, depth, result):
        if not node:
            return

        if depth > len(result):
            result.append(node.val)

        self.rightSideViewDFS(node.right, depth+1, result)
        self.rightSideViewDFS(node.left, depth+1, result)



",n
"class Solution2(object):
    def rightSideView(self, root):
        if root is None:
            return []

        result, current = [], [root]
        while current:
            next_level = []
            for node in current:
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)                
            result.append(node.val)
            current = next_level

        return result

",n
"
class Solution(object):
    def carPooling(self, trips, capacity):
        line = [x for num, start, end in trips for x in [[start, num], [end, -num]]]
        line.sort()
        for _, num in line:
            capacity -= num
            if capacity < 0:
                return False
        return True
",nlogn
"
import heapq



class Solution(object):
    def maximumScore(self, scores, edges):
        def find_top3(scores, x, top3):
            heapq.heappush(top3, (scores[x], x))
            if len(top3) > 3:
                heapq.heappop(top3)

        top3 = [[] for _ in range(len(scores))]
        for a, b in edges:
            find_top3(scores, b, top3[a])
            find_top3(scores, a, top3[b])
        result = -1
        for a, b in edges:
            for _, c in top3[a]:
                if c == b:
                    continue
                for _, d in top3[b]:
                    if d == a or d == c:
                        continue
                    result = max(result, sum(scores[x] for x in (a, b, c, d)))
        return result

",|V| + |E|
"

class Solution(object):
    def minimumTime(self, s):
        left = 0
        result = left+(len(s)-0)
        for i in range(1, len(s)+1):
            left = min(left+2*(s[i-1] == '1'), i)
            result = min(result, left+(len(s)-i))
        return result


",n
"
class Solution2(object):
    def minimumTime(self, s):
        result, right = len(s), [0]*(len(s)+1)
        for i in reversed(range(len(s))):
            right[i] = min(right[i+1]+2*(s[i] == '1'), len(s)-i)
        left = 0
        result = left+right[0]
        for i in range(1, len(s)+1):
            left = min(left+2*(s[i-1] == '1'), i)     
            result = min(result, left+right[i])
        return result
",n
"


class Solution(object):
    def outerTrees(self, points):
        points = sorted(set(tuple(x) for x in points))

        if len(points) <= 1:
            return points

        def cross(o, a, b):
            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

        lower = []
        for p in points:
            while len(lower) >= 2 and cross(lower[-2], lower[-1], p) < 0: 
                lower.pop()
            lower.append(p)

        upper = []
        for p in reversed(points):
            while len(upper) >= 2 and cross(upper[-2], upper[-1], p) < 0: 
                upper.pop()
            upper.append(p)

        result = lower[:-1] + upper[:-1]
        return result if result[1] != result[-1] else result[:len(result)//2+1] 
",nlogn
"
import collections



class Solution(object):
    def minGroups(self, intervals):
        events = collections.Counter()
        for l, r in intervals:
            events[l] += 1
            events[r+1] -= 1
        result = curr = 0
        for t in sorted(events.keys()):
            curr += events[t]
            result = max(result, curr)
        return result
",nlogn
"
class Solution(object):
    def pivotIndex(self, nums):
        total = sum(nums)
        left_sum = 0
        for i, num in enumerate(nums):
            if left_sum == (total-left_sum-num):
                return i
            left_sum += num
        return -1


",n
"

class Solution(object):
    def insertGreatestCommonDivisors(self, head):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        curr = head
        while curr.__next__:
            curr.next = ListNode(gcd(curr.val, curr.next.val), curr.next)
            curr = curr.next.__next__
        return head
",n
"
class Solution(object):
    def maxAscendingSum(self, nums):
        result = curr = 0
        for i in range(len(nums)): 
            if not (i and nums[i-1] < nums[i]):
                curr = 0
            curr += nums[i]
            result = max(result, curr)
        return result
",n
"
import collections


class Solution(object):
    def shortestSubarray(self, A, K):
        accumulated_sum = [0]*(len(A)+1)
        for i in range(len(A)):
            accumulated_sum[i+1] = accumulated_sum[i]+A[i]

        result = float(""inf"")
        mono_increasing_q = collections.deque()
        for i, curr in enumerate(accumulated_sum):
            while mono_increasing_q and curr <= \
                    accumulated_sum[mono_increasing_q[-1]]:
                mono_increasing_q.pop()
            while mono_increasing_q and \
                    curr-accumulated_sum[mono_increasing_q[0]] >= K:
                result = min(result, i-mono_increasing_q.popleft())
            mono_increasing_q.append(i)
        return result if result != float(""inf"") else -1

",n
"

class Solution(object):
    def countPairsOfConnectableServers(self, edges, signalSpeed):
        def iter_dfs(u, p, dist):
            result = 0
            stk = [(u, p, dist)]
            while stk:
                u, p, dist = stk.pop()
                if dist%signalSpeed == 0:
                    result += 1
                for v, w in reversed(adj[u]):
                    if v == p:
                        continue
                    stk.append((v, u, dist+w))
            return result
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        result = [0]*(len(edges)+1)
        for u in range(len(result)):
            curr = 0
            for v, w in adj[u]:
                cnt = iter_dfs(v, u, w)
                result[u] += curr*cnt
                curr += cnt
        return result


",n^2
"
class Solution2(object):
    def countPairsOfConnectableServers(self, edges, signalSpeed):
        def dfs(u, p, dist):
            cnt = 1 if dist%signalSpeed == 0 else 0
            for v, w in adj[u]:
                if v == p:
                    continue
                cnt += dfs(v, u, dist+w)
            return cnt
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        result = [0]*(len(edges)+1)
        for u in range(len(result)):
            curr = 0
            for v, w in adj[u]:
                cnt = dfs(v, u, w)
                result[u] += curr*cnt
                curr += cnt
        return result


",n^2
"
class Solution3(object):
    def countPairsOfConnectableServers(self, edges, signalSpeed):
        def bfs(u, p, dist):
            result = 0
            q = [(u, p, dist)]
            while q:
                new_q = []
                for u, p, dist in q:
                    if dist%signalSpeed == 0:
                        result += 1
                    for v, w in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u, dist+w))
                q = new_q
            return result
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        result = [0]*(len(edges)+1)
        for u in range(len(result)):
            curr = 0
            for v, w in adj[u]:
                cnt = bfs(v, u, w)
                result[u] += curr*cnt
                curr += cnt
        return result
",n^2
"
from sortedcontainers import SortedList


class Solution(object):
    def medianSlidingWindow(self, nums, k):
        sl = SortedList(float(nums[i])for i in range(k))
        result = [(sl[k//2]+sl[k//2-(1-k%2)])/2]
        for i in range(k, len(nums)):
            sl.add(float(nums[i]))
            sl.remove(nums[i-k])
            result.append((sl[k//2]+sl[k//2-(1-k%2)])/2)
        return result


",nlogk
"import collections
import heapq


class Solution2(object):
    def medianSlidingWindow(self, nums, k):
        def lazy_delete(heap, to_remove, sign):
            while heap and sign*heap[0] in to_remove:
                to_remove[sign*heap[0]] -= 1
                if not to_remove[sign*heap[0]]:
                    del to_remove[sign*heap[0]]
                heapq.heappop(heap)

        def full_delete(heap, to_remove, sign): 
            result = []
            for x in heap:
                if sign*x not in to_remove:
                    result.append(x)
                    continue
                to_remove[sign*x] -= 1
                if not to_remove[sign*x]:
                    del to_remove[sign*x]
            heap[:] = result
            heapq.heapify(heap)

        min_heap, max_heap = [], []
        for i in range(k):
            if i%2 == 0:
                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))
            else:
                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))
        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]
        to_remove = collections.defaultdict(int)
        for i in range(k, len(nums)):
            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))
            if nums[i-k] > -max_heap[0]:
                heapq.heappush(min_heap, -heapq.heappop(max_heap))
            to_remove[nums[i-k]] += 1
            lazy_delete(max_heap, to_remove, -1)
            lazy_delete(min_heap, to_remove, 1)
            if len(min_heap)+len(max_heap) > 2*k:
                full_delete(max_heap, to_remove, -1)
                full_delete(min_heap, to_remove, 1)
            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)
        return result


",nlogk
"import collections
import heapq


class Solution3(object):
    def medianSlidingWindow(self, nums, k):
        def lazy_delete(heap, to_remove, sign):
            while heap and sign*heap[0] in to_remove:
                to_remove[sign*heap[0]] -= 1
                if not to_remove[sign*heap[0]]:
                    del to_remove[sign*heap[0]]
                heapq.heappop(heap)

        min_heap, max_heap = [], []
        for i in range(k):
            if i%2 == 0:
                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))
            else:
                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))
        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]
        to_remove = collections.defaultdict(int)
        for i in range(k, len(nums)):
            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))
            if nums[i-k] > -max_heap[0]:
                heapq.heappush(min_heap, -heapq.heappop(max_heap))
            to_remove[nums[i-k]] += 1
            lazy_delete(max_heap, to_remove, -1)
            lazy_delete(min_heap, to_remove, 1)
            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)
        return result
",nlogn
"
import itertools



class Solution(object):
    def minSumSquareDiff(self, nums1, nums2, k1, k2):
        def check(diffs, k, x):
            return sum(max(d-x, 0) for d in diffs) <= k

        diffs = sorted((abs(i-j) for i, j in zip(nums1, nums2)), reverse=True)
        k = min(k1+k2, sum(diffs))
        left, right = 0, diffs[0]
        while left <= right:
            mid = left + (right-left)//2
            if check(diffs, k, mid):
                right = mid-1
            else:
                left = mid+1
        k -= sum(max(d-left, 0) for d in diffs)
        for i in range(len(diffs)):
            diffs[i] = min(diffs[i], left)-int(i < k)
        return sum(d**2 for d in diffs)
",nlogn + nlogr
"
import threading
import collections


class Solution(object):
    def __init__(self, capacity):
        self.__cv = threading.Condition()
        self.__q = collections.deque()
        self.__cap = capacity

    def enqueue(self, element):
        with self.__cv:
            while len(self.__q) == self.__cap:
                self.__cv.wait()
            self.__q.append(element)
            self.__cv.notifyAll()

    def dequeue(self):
        with self.__cv:
            while not self.__q:
                self.__cv.wait()
            self.__cv.notifyAll()
            return self.__q.popleft()

    def size(self):
        with self.__cv:
            return len(self.__q)
",n
"
import math
from functools import reduce


class Solution(object):
    def abbreviateProduct(self, left, right):
        PREFIX_LEN = SUFFIX_LEN = 5
        MOD = 10**(PREFIX_LEN+SUFFIX_LEN)
        curr, zeros = 1, 0
        abbr = False
        for i in range(left, right+1):
            curr *= i
            while not curr%10:
                curr //= 10
                zeros += 1
            q, curr = divmod(curr, MOD)
            if q:
                abbr = True
        if not abbr:
            return ""%se%s"" % (curr, zeros)
        decimal = reduce(lambda x, y: (x+y)%1, (math.log10(i) for i in range(left, right+1)))
        prefix = str(int(10**(decimal+(PREFIX_LEN-1))))
        suffix = str(curr % 10**SUFFIX_LEN).zfill(SUFFIX_LEN)
        return ""%s...%se%s"" % (prefix, suffix, zeros)
",r - l
"

class Solution(object):
    def maximumBooks(self, books):
        def count(right, l):
            left = max(right-l+1, 0)
            return (left+right)*(right-left+1)//2
        
        result = curr = 0
        stk = [-1]
        for i in range(len(books)):
            while stk[-1] != -1 and books[stk[-1]] >= books[i]-(i-stk[-1]):
                j = stk.pop()
                curr -= count(books[j], j-stk[-1])
            curr += count(books[i], i-stk[-1])
            stk.append(i)
            result = max(result, curr)
        return result
",n
"
import collections



class Solution(object):
    def digitCount(self, num):
        cnt = collections.Counter(num)
        return all(cnt[str(i)] == int(x) for i, x in enumerate(num))
",n
"

class Solution(object):
    def minimumSteps(self, s):
        result = left = 0
        for right in range(len(s)):
            if s[right] != '0':
                continue
            result += right-left
            left += 1
        return result


",n
"
class Solution2(object):
    def minimumSteps(self, s):
        result = 0
        left, right = 0, len(s)-1
        while left < right:
            if left < len(s) and s[left] != '1':
                left += 1
                continue
            if right >= 0 and s[right] != '0':
                right -= 1
                continue
            result += right-left
            left += 1
            right -= 1
        return result
",n
"

class Solution(object):
    def arrayPairSum(self, nums):
        LEFT, RIGHT = -10000, 10000
        lookup = [0] * (RIGHT-LEFT+1)
        for num in nums:
            lookup[num-LEFT] += 1
        r, result = 0, 0
        for i in range(LEFT, RIGHT+1):
            result += (lookup[i-LEFT] + 1 - r) / 2 * i
            r = (lookup[i-LEFT] + r) % 2
        return result


",r
"class Solution2(object):
    def arrayPairSum(self, nums):
        nums.sort()
        result = 0
        for i in range(0, len(nums), 2):
            result += nums[i]
        return result


",nlogn
"class Solution3(object):
    def arrayPairSum(self, nums):
        nums = sorted(nums)
        return sum([nums[i] for i in range(0, len(nums), 2)])

",nlogn
"
import threading


class Solution(object):
    
    def __init__(self):
        self.__l = threading.Lock()
        self.__light = 1

    def carArrived(self, carId, roadId, direction, turnGreen, crossCar):
        with self.__l:
            if self.__light != roadId:
                self.__light = roadId
                turnGreen()
            crossCar()
",n
"
class Solution(object):
    def findTheCity(self, n, edges, distanceThreshold):
        dist = [[float(""inf"")]*n for _ in range(n)]
        for i, j, w in edges:
            dist[i][j] = dist[j][i] = w
        for i in range(n):
            dist[i][i] = 0
        for k in range(n): 
            for i in range(n): 
                for j in range(n): 
                    dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) 
        result = {sum(d <= distanceThreshold for d in dist[i]): i for i in range(n)}
        return result[min(result.keys())]
",n^3
"

class Solution(object):
    def maximumLength(self, s):
        lookup = [[0]*3 for _ in range(26)]
        result = cnt = 0
        for i, c in enumerate(s):
            cnt += 1
            if i+1 != len(s) and s[i+1] == s[i]:
                continue
            curr = lookup[ord(c)-ord('a')]
            for j in range(len(curr)):
                if curr[j] < cnt:
                    cnt, curr[j] = curr[j], cnt
            cnt = 0
            result = max(result, max(curr[0]-2, min(curr[0]-1, curr[1]), curr[2]))
        return result if result else -1
",26 * 3 + n * 3
"
class Solution(object):
    def reversePairs(self, nums):
        def merge(nums, start, mid, end):
            r = mid + 1
            tmp = []
            for i in range(start, mid + 1):
                while r <= end and nums[i] > nums[r]:
                    tmp.append(nums[r])
                    r += 1
                tmp.append(nums[i])
            nums[start:start+len(tmp)] = tmp

        def countAndMergeSort(nums, start, end):
            if end - start <= 0:
                return 0

            mid = start + (end - start) / 2
            count = countAndMergeSort(nums, start, mid) + countAndMergeSort(nums, mid + 1, end)
            r = mid + 1
            for i in range(start, mid + 1):
                while r <= end and nums[i] > nums[r] * 2:
                    r += 1
                count += r - (mid + 1)
            merge(nums, start, mid, end)
            return count

        return countAndMergeSort(nums, 0, len(nums) - 1)

",nlogn
"
class Solution(object):
    def shortestWordDistance(self, words, word1, word2):
        dist = float(""inf"")
        is_same = (word1 == word2)
        i, index1, index2 = 0, None, None
        while i < len(words):
            if words[i] == word1:
                if is_same and index1 is not None:
                    dist = min(dist, abs(index1 - i))
                index1 = i
            elif words[i] == word2:
                index2 = i

            if index1 is not None and index2 is not None:
                dist = min(dist, abs(index1 - index2))
            i += 1

        return dist

",n
"
import heapq


class Solution(object):
    def smallestRange(self, nums):
        left, right = float(""inf""), float(""-inf"")
        min_heap = []
        for row in nums:
            left = min(left, row[0])
            right = max(right, row[0])
            it = iter(row)
            heapq.heappush(min_heap, (next(it, None), it))

        result = (left, right)
        while min_heap:
            (val, it) = heapq.heappop(min_heap)
            val = next(it, None)
            if val is None:
                break
            heapq.heappush(min_heap, (val, it))
            left, right = min_heap[0][0], max(right, val)
            if right - left < result[1] - result[0]:
                result = (left, right)
        return result

",nlogk
"
class Solution(object):
    def maxDepthAfterSplit(self, seq):
        return [(i & 1) ^ (seq[i] == '(') for i, c in enumerate(seq)]


",n
"class Solution2(object):
    def maxDepthAfterSplit(self, seq):
        A, B = 0, 0
        result = [0]*len(seq)
        for i, c in enumerate(seq):
            point = 1 if c == '(' else -1
            if (point == 1 and A <= B) or \
               (point == -1 and A >= B):
                A += point
            else:
                B += point
                result[i] = 1
        return result
",n
"
import random



class Solution(object):
    def maxSubsequence(self, nums, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        partition = nums[:]
        nth_element(partition, k-1, compare=lambda a, b: a > b)
        cnt = sum(partition[i] == partition[k-1] for i in range(k))
        result = []
        for x in nums:
            if x > partition[k-1]:
                result.append(x)
            elif x == partition[k-1] and cnt > 0:
                cnt -= 1
                result.append(x)
        return result
",n
"

class Solution(object):
    def occurrencesOfElement(self, nums, queries, x):
        lookup = [i for i, y in enumerate(nums) if y == x]
        return [lookup[q-1] if q-1 < len(lookup) else -1 for q in queries]
",n + q
"
class Solution(object):
    def largestPathValue(self, colors, edges):
        adj = [[] for _ in range(len(colors))]
        in_degree = [0]*len(colors)
        for u, v in edges:
            adj[u].append(v)
            in_degree[v] += 1
        q = []
        for u in range(len(colors)):
            if not in_degree[u]:
                q.append(u)
        dp = [[0]*26 for _ in range(len(colors))]
        result, cnt = -1, 0
        while q:
            new_q = []
            for u in q:
                cnt += 1
                dp[u][ord(colors[u])-ord('a')] += 1
                result = max(result, dp[u][ord(colors[u])-ord('a')])
                for v in adj[u]:
                    for c in range(26):
                        dp[v][c] = max(dp[v][c], dp[u][c])
                    in_degree[v] -= 1
                    if not in_degree[v]:
                        new_q.append(v)
            q = new_q
        return result if cnt == len(colors) else -1
",n + m
"
import collections



class Solution(object):
    def maxFrequencyScore(self, nums, k):
        MOD = 10**9+7
        lookup = {}
        def powmod(n, p):
            if (n, p) not in lookup:
                lookup[n, p] = (lookup[n, p-1]*n)%MOD if p >= 2 else n%MOD 
            return lookup[n, p]

        result = curr = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            if i >= k:
                curr = (curr-powmod(nums[i-k], cnt[nums[i-k]]))%MOD
                cnt[nums[i-k]] -= 1
                if cnt[nums[i-k]]:
                    curr = (curr+powmod(nums[i-k], cnt[nums[i-k]]))%MOD
            if cnt[nums[i]]:
               curr = (curr-powmod(nums[i], cnt[nums[i]]))%MOD
            cnt[nums[i]] += 1
            curr = (curr+powmod(nums[i], cnt[nums[i]]))%MOD
            if i >= k-1:
                result = max(result, curr)
        return result


",n
"import collections



class Solution2(object):
    def maxFrequencyScore(self, nums, k):
        MOD = 10**9+7
        result = curr = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            if i >= k:
                curr = (curr-pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD
                cnt[nums[i-k]] -= 1
                if cnt[nums[i-k]]:
                    curr = (curr+pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD
            if cnt[nums[i]]:
               curr = (curr-pow(nums[i], cnt[nums[i]], MOD))%MOD
            cnt[nums[i]] += 1
            curr = (curr+pow(nums[i], cnt[nums[i]], MOD))%MOD
            if i >= k-1:
                result = max(result, curr)
        return result
",nlogn
"
import collections


class Solution(object):

    def __init__(self, v1, v2):
        self.q = collections.deque([(len(v), iter(v)) for v in (v1, v2) if v])

    def __next__(self):
        len, iter = self.q.popleft()
        if len > 1:
            self.q.append((len-1, iter))
        return next(iter)

    def hasNext(self):
        return bool(self.q)


",n
"
class Solution(object):
    def minSubarray(self, nums, p):
        residue = sum(nums) % p
        if not residue:
            return 0
        result = len(nums)
        curr, lookup = 0, {0: -1}
        for i, num in enumerate(nums):
            curr = (curr+num) % p
            lookup[curr] = i
            if (curr-residue) % p in lookup:
                result = min(result, i-lookup[(curr-residue)%p])
        return result if result < len(nums) else -1
",n
"
import pandas as pd



def Solution(customers: pd.DataFrame) -> pd.DataFrame:
    customers.drop_duplicates(subset=[""email""], keep=""first"", inplace=True)
    return customers
",n
"
import pandas as pd



def Solution(df1: pd.DataFrame, df2: pd.DataFrame) -> pd.DataFrame:
    return pd.concat([df1, df2])
",n + m
"
class Solution(object):
    def minElements(self, nums, limit, goal):
        return (abs(sum(nums)-goal) + (limit-1))//limit
",n
"
import heapq



class Solution(object):
    def pickGifts(self, gifts, k):
        for i, x in enumerate(gifts):
            gifts[i] = -x
        heapq.heapify(gifts)
        for _ in range(k):
            x = heapq.heappop(gifts)
            heapq.heappush(gifts, -int((-x)**0.5))
        return -sum(gifts)
",n + klogn
"
class Solution(object):
    def areSentencesSimilar(self, sentence1, sentence2):
        if len(sentence1) > len(sentence2):
            sentence1, sentence2 = sentence2, sentence1
        count = 0
        for idx in (lambda x:x, lambda x:-1-x):
            for i in range(len(sentence1)+1):
                c1 = sentence1[idx(i)] if i != len(sentence1) else ' '
                c2 = sentence2[idx(i)] if i != len(sentence2) else ' '
                if c1 != c2:
                    break
                if c1 == ' ':
                    count += 1
        return count >= sentence1.count(' ')+1
",n
"
import random



class Solution(object):
    def miceAndCheese(self, reward1, reward2, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        for i in range(len(reward1)):
            reward1[i] -= reward2[i]
        nth_element(reward1, k-1, compare=lambda a, b: a > b)
        return sum(reward2)+sum(reward1[i] for i in range(k))
",n
"
class Solution(object):
    def combinationSum(self, candidates, target):
        result = []
        self.combinationSumRecu(sorted(candidates), result, 0, [], target)
        return result

    def combinationSumRecu(self, candidates, result, start, intermediate, target):
        if target == 0:
            result.append(list(intermediate))
        while start < len(candidates) and candidates[start] <= target:
            intermediate.append(candidates[start])
            self.combinationSumRecu(candidates, result, start, intermediate, target - candidates[start])
            intermediate.pop()
            start += 1

",k * n^k
"

class Solution(object):
    def countPartitions(self, nums):
        result = left = 0
        right = sum(nums)
        for i in range(len(nums)-1):
            left += nums[i]
            right -= nums[i]
            if left%2 == right%2:
                result += 1
        return result
",n
"
import collections



class Solution(object):
    def applySubstitutions(self, replacements, text):
        def find_adj(s):
            result = set()
            i = 0
            while i < len(s):
                if s[i] != '%':
                    i += 1
                    continue
                j = next(j for j in range(i+1, len(s)) if s[j] == '%')
                result.add(s[i+1:j])
                i = j+1
            return result
        
        def replace(s):
            result = []
            i = 0
            while i < len(s):
                if s[i] != '%':
                    result.append(s[i])
                    i += 1
                    continue
                j = next(j for j in range(i+1, len(s)) if s[j] == '%')
                result.append(lookup[s[i+1:j]])
                i = j+1
            return """".join(result)
        
        def topological_sort():
            adj = collections.defaultdict(set)
            in_degree = collections.defaultdict(int)
            for u, s in replacements:
                for v in find_adj(s):
                    adj[v].add(u)
                    in_degree[u] += 1
            result = []
            q = [u for u, _ in replacements if not in_degree[u]]
            while q:
                new_q = []
                for u in q:
                    lookup[u] = replace(lookup[u])
                    for v in adj[u]:
                        in_degree[v] -= 1
                        if in_degree[v]:
                            continue
                        new_q.append(v)
                q = new_q
            return result

        lookup = {k:v for k, v in replacements}
        topological_sort()
        return replace(text)


",r * 2^r
"
class Solution2(object):
    def applySubstitutions(self, replacements, text):
        lookup = {k:v for k, v in replacements}
        memo = {}
        def replace(s):
            if s not in memo:
                result = []
                i = 0
                while i < len(s):
                    if s[i] != '%':
                        result.append(s[i])
                        i += 1
                        continue
                    j = next(j for j in range(i+1, len(s)) if s[j] == '%')
                    result.append(replace(lookup[s[i+1:j]]))
                    i = j+1
                memo[s] = """".join(result)
            return memo[s]

        return replace(text)",r * 2^r
"
import itertools



class Solution(object):
    def minCost(self, arr, brr, k):
        def cost():
            return sum(abs(x-y) for x, y in zip(arr, brr))

        result = cost()
        arr.sort()
        brr.sort()
        result = min(result, k+cost())
        return result
",nlogn
"
import heapq


class Solution(object):
    def findShortestWay(self, maze, ball, hole):
        ball, hole = tuple(ball), tuple(hole)
        dirs = {'u' : (-1, 0), 'r' : (0, 1), 'l' : (0, -1), 'd': (1, 0)}

        def neighbors(maze, node):
            for dir, vec in dirs.items():
                cur_node, dist = list(node), 0
                while 0 <= cur_node[0]+vec[0] < len(maze) and \
                      0 <= cur_node[1]+vec[1] < len(maze[0]) and \
                      not maze[cur_node[0]+vec[0]][cur_node[1]+vec[1]]:
                    cur_node[0] += vec[0]
                    cur_node[1] += vec[1]
                    dist += 1
                    if tuple(cur_node) == hole:
                        break
                yield tuple(cur_node), dir, dist

        heap = [(0, '', ball)]
        visited = set()
        while heap:
            dist, path, node = heapq.heappop(heap)
            if node in visited: continue
            if node == hole: return path
            visited.add(node)
            for neighbor, dir, neighbor_dist in neighbors(maze, node):
                heapq.heappush(heap, (dist+neighbor_dist, path+dir, neighbor))

        return ""impossible""

","max(r, c) * wlogw"
"

class Solution(object):
    def getSum(self, nums):
        MOD = 10**9+7
        def count(d):
            result = total = l = 0
            for i in range(len(nums)):
                l += 1
                total = (total+nums[i]*l)%MOD
                result = (result+total)%MOD
                if i+1 < len(nums) and nums[i+1]-nums[i] == d:
                    continue
                total = l = 0
            return result
    
        return (count(1)+count(-1)-reduce(lambda accu, x: (accu+x)%MOD, nums, 0))%MOD
",n
"

class Solution(object):
    def isArraySpecial(self, nums):
        return all(nums[i]&1 != nums[i+1]&1 for i in range(len(nums)-1))
",n
"

class Solution(object):

    def __init__(self, value, k):
        self.__value = value
        self.__k = k
        self.__cnt = 0

    def consec(self, num):
        if num == self.__value:
            self.__cnt += 1
        else:
            self.__cnt = 0
        return self.__cnt >= self.__k
",1
"
class Solution(object):
    def findMinMoves(self, machines):
        total = sum(machines)
        if total % len(machines): return -1

        result, target, curr = 0, total / len(machines), 0
        for n in machines:
            curr += n - target
            result = max(result, max(n - target, abs(curr)))
        return result

",n
"
import collections



class Solution(object):
    def minimumTotalDistance(self, robot, factory):
        robot.sort(), factory.sort()
        dp = [float(""inf"")]*(len(robot)+1) 
        dp[0] = 0
        for i in range(len(factory)):
            prefix = 0
            dq = collections.deque([(dp[0]-prefix, 0)]) 
            for j in range(1, len(robot)+1):
                prefix += abs(robot[j-1]-factory[i][0])
                if j-dq[0][1] == factory[i][1]+1:
                    dq.popleft()
                while dq and dq[-1][0] >= dp[j]-prefix:
                    dq.pop()
                dq.append((dp[j]-prefix, j))
                dp[j] = dq[0][0]+prefix
        return dp[-1]


",mlogm + nlogn + m * n
"import collections



class Solution2(object):
    def minimumTotalDistance(self, robot, factory):
        robot.sort(), factory.sort()
        dp = [float(""inf"")]*(len(robot)+1) 
        dp[0] = 0
        for i in range(len(factory)):
            for j in reversed(range(1, len(robot)+1)):
                curr = 0
                for k in range(min(factory[i][1], j)+1):
                    dp[j] = min(dp[j], dp[j-k]+curr)
                    if (j-1)-k >= 0:
                        curr += abs(robot[(j-1)-k]-factory[i][0])
        return dp[-1]
",mlogm + nlogn + m * n * l
"

class Solution(object):
    def smallestBeautifulString(self, s, k):
        def check(i):
            return (i-1 < 0 or arr[i-1] != arr[i]) and (i-2 < 0 or arr[i-2] != arr[i])

        arr = [ord(x)-ord('a') for x in s]
        for i in reversed(range(len(arr))):
            arr[i] += 1
            while not check(i):
                arr[i] += 1
            if arr[i] < k:
                break
        else:
            return """"
        for j in range(i+1, len(arr)):
            arr[j] = 0
            while not check(j):
                arr[j] += 1
        return """".join([chr(ord('a')+x) for x in arr])
",n
"

class Solution(object):
    def countCompleteSubstrings(self, word, k):
        result = valid = 0
        cnt = [0]*26
        for c in range(1, len(set(word))+1):
            left = 0
            for right in range(len(word)):
                cnt[ord(word[right])-ord('a')] += 1
                curr = cnt[ord(word[right])-ord('a')]
                valid += 1 if curr == k else -1 if curr == k+1 else 0
                if right-left+1 == c*k+1:
                    curr = cnt[ord(word[left])-ord('a')]
                    valid -= 1 if curr == k else -1 if curr == k+1 else 0
                    cnt[ord(word[left])-ord('a')] -= 1
                    left += 1
                if valid == c:
                    result += 1
                if right+1 == len(word) or abs(ord(word[right+1])-ord(word[right])) > 2:
                    while left < right+1:
                        curr = cnt[ord(word[left])-ord('a')]
                        valid -= 1 if curr == k else -1 if curr == k+1 else 0
                        cnt[ord(word[left])-ord('a')] -= 1
                        left += 1
        return result
",26 + d * n
"
class Solution(object):
    def stoneGameVI(self, aliceValues, bobValues):
        sorted_vals = sorted(((a, b) for a, b in zip(aliceValues, bobValues)), key=sum, reverse=True)
        return cmp(sum(a for a, _ in sorted_vals[::2]), sum(b for _, b in sorted_vals[1::2]))
",nlogn
"
class Solution(object):
    def minFlipsMonoIncr(self, S):
        flip0, flip1 = 0, 0
        for c in S:
            flip0 += int(c == '1')
            flip1 = min(flip0, flip1 + int(c == '0'))
        return flip1
",n
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def heightOfTree(self, root):
        result = -1
        stk = [(root, 0)]
        while stk:
            u, d = stk.pop()
            result = max(result, d)
            if u.right and u.right.left != u:
                stk.append((u.right, d+1))
            if u.left and u.left.right != u:
                stk.append((u.left, d+1))
        return result


",n
"
class Solution2(object):
    def heightOfTree(self, root):
        result = -1
        q = [root]
        while q:
            new_q = []
            for u in q:
                if u.left and u.left.right != u:
                    new_q.append(u.left)
                if u.right and u.right.left != u:
                    new_q.append(u.right)
            q = new_q
            result += 1
        return result
",n
"
class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        result, local_max = 0, 0
        for n in nums:
            local_max = (local_max + 1 if n else 0)
            result = max(result, local_max)
        return result

",n
"

class Solution(object):
    def numberOfSubstrings(self, s, k):
        cnt = [0]*26
        result = left = 0
        for right in range(len(s)):
            cnt[ord(s[right])-ord('a')] += 1
            while cnt[ord(s[right])-ord('a')] == k:
                result += (len(s)-1)-right+1
                cnt[ord(s[left])-ord('a')] -= 1
                left += 1
        return result
",n + 26
"
import math


class Solution(object):
    def minimumBoxes(self, n):
        h = int((6*n)**(1.0/3))  
        if h*(h+1)*(h+2) > 6*n:
            h -= 1
        n -= h*(h+1)*(h+2)//6
        d = int(math.ceil((-1+(1+8*n)**0.5)/2)) 
        return h*(h+1)//2 + d
",1
"
import collections


class Solution(object):
    def countTriplets(self, arr):
        count_sum = collections.defaultdict(lambda: [0, 0])
        count_sum[0] = [1, 0]
        result, prefix = 0, 0
        for i, x in enumerate(arr):
            prefix ^= x
            c, t = count_sum[prefix]
            result += c*i - t
            count_sum[prefix] = [c+1, t+i+1]
        return result
",n
"
class Solution(object):
    def maxAlternatingSum(self, nums):
        result = nums[0]
        for i in range(len(nums)-1):
            result += max(nums[i+1]-nums[i], 0)
        return result
",n
"

class Solution(object):
    def numberOfEmployeesWhoMetTarget(self, hours, target):
        return sum(x >= target for x in hours)
",n
"

class Solution(object):
    def maxSum(self, nums):
        def max_digit(x):
            result = 0
            while x:
                x, r = divmod(x, 10)
                result = max(result, r)
            return result
    
        result = -1
        lookup = {}
        for x in nums:
            mx = max_digit(x)
            if mx not in lookup:
                lookup[mx] = x
                continue
            result = max(result, lookup[mx]+x)
            lookup[mx] = max(lookup[mx], x)
        return result
",nlogr
"
class Solution(object):
    def maxSatisfied(self, customers, grumpy, X):
        result, max_extra, extra = 0, 0, 0
        for i in range(len(customers)):
            result += 0 if grumpy[i] else customers[i]
            extra += customers[i] if grumpy[i] else 0
            if i >= X:
                extra -= customers[i-X] if grumpy[i-X] else 0
            max_extra = max(max_extra, extra)
        return result + max_extra
",n
"

class Solution(object):
    def countOfPairs(self, n, x, y):
        x, y = x-1, y-1
        if x > y:
            x, y = y, x
        diff = [0]*n
        for i in range(n):
            diff[0] += 1+1                                        
            diff[min(abs(i-x), abs(i-y)+1)] += 1                  
            diff[min(abs(i-y), abs(i-x)+1)] += 1                  
            diff[min(abs(i-0), abs(i-y)+1+abs(x-0))] -= 1         
            diff[min(abs(i-(n-1)), abs(i-x)+1+abs(y-(n-1)))] -= 1 
            diff[max(x-i, 0)+max(i-y, 0)+((y-x)+0)//2] -= 1       
            diff[max(x-i, 0)+max(i-y, 0)+((y-x)+1)//2] -= 1       
        for i in range(n-1):
            diff[i+1] += diff[i]
        return diff


",n
"
class Solution2(object):
    def countOfPairs(self, n, x, y):
        x, y = x-1, y-1
        result = [0]*n
        for i in range(n):
            for j in range(i+1, n):
                result[min(abs(i-j), abs(i-x)+1+abs(y-j), abs(i-y)+1+abs(x-j))-1] += 2
        return result
",n^2
"

class Solution(object):
    def findKDistantIndices(self, nums, key, k):
        result = []
        prev = -1
        for i, x in enumerate(nums):
            if x != key:
                continue
            for j in range(max(i-k, prev+1), min(i+k+1, len(nums))):
                result.append(j)
            prev = min(i+k, len(nums)-1)
        return result
",n
"

class Solution(object):
    def countSeniors(self, details):
        return sum(x[-4:-2] > ""60"" for x in details)
",n
"
class Solution(object):
    def twoSum(self, nums, target):
        lookup = {}
        for i, num in enumerate(nums):
            if target - num in lookup:
                return [lookup[target - num], i]
            lookup[num] = i

    def twoSum2(self, nums, target):
        for i in nums:
            j = target - i
            tmp_nums_start_index = nums.index(i) + 1
            tmp_nums = nums[tmp_nums_start_index:]
            if j in tmp_nums:
                return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)]


",n
"
class Solution(object):
    def maximumInvitations(self, favorite):
        def find_cycles(adj):
            result = []
            lookup = [False]*len(adj)
            for u in range(len(adj)):
                cnt = {}
                while not lookup[u]:
                    lookup[u] = True
                    cnt[u] = len(cnt)
                    u = adj[u]
                if u in cnt:
                    result.append((u, len(cnt)-cnt[u]))
            return result

        def bfs(adj, u, exclude):
            result = 0
            q = [u]
            while q:
                result += 1
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if v == exclude:
                            continue
                        new_q.append(v)
                q = new_q
            return result
            
        inv_adj = [[] for _ in range(len(favorite))]  
        for u, v in enumerate(favorite):
            inv_adj[v].append(u)
        cycles = find_cycles(favorite)
        return max(max([l for _, l in cycles if l > 2] or [0]),
                   sum(bfs(inv_adj, u, favorite[u]) + bfs(inv_adj, favorite[u], u) for u, l in cycles if l == 2))
",n
"
import collections


class Solution(object):
    def maxProduct(self, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        P = manacher(s)
        q = collections.deque()
        left = [0]
        for i in range(len(s)):
            while q and q[0][1] < i:
                q.popleft()
            left.append(max(left[-1], 1+2*(i-q[0][0]) if q else 1))
            q.append((i, i+P[2*i+2]//2))
        q = collections.deque()
        result = right = 0
        for i in reversed(range(len(s))):
            while q and q[0][1] > i:
                q.popleft()
            right = max(right, 1+2*(q[0][0]-i) if q else 1)
            q.append((i, i-P[2*i+2]//2))
            result = max(result, left[i]*right)
        return result


",n
"class Solution2(object):
    def maxProduct(self, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        import operator
        def accumulate(iterable, func=operator.add, initial=None):
            it = iter(iterable)
            total = initial
            if initial is None:
                try:
                    total = next(it)
                except StopIteration:
                    return
            yield total
            for element in it:
                total = func(total, element)
                yield total

        def fin_max_len(s):
            P = manacher(s)
            intervals = [[(i-2)//2-P[i]//2, (i-2)//2+P[i]//2] for i in range(2,len(P)-2, 2)]
            dp = [0]*len(s)
            for l, r in reversed(intervals): 
                dp[r] = r-l+1
            for i in reversed(range(len(s)-1)):
                dp[i] = max(dp[i], dp[i+1]-2)
            return list(accumulate(dp, max, 0))
        
        l1, l2 = fin_max_len(s), fin_max_len(s[::-1])[::-1]
        return max(x*y for x, y in zip(l1, l2))
",n
"
class Solution(object):
    def missingRolls(self, rolls, mean, n):
        MAX_V = 6
        MIN_V = 1
        total = sum(rolls)
        missing = mean*(n+len(rolls))-total
        if missing < MIN_V*n or missing > MAX_V*n:
            return []
        q, r = divmod(missing, n)
        return [q+int(i < r) for i in range(n)]


",n
"class Solution2(object):
    def missingRolls(self, rolls, mean, n):
        MAX_V = 6
        MIN_V = 1
        total = sum(rolls)
        missing = mean*(n+len(rolls))-total
        if missing < MIN_V*n or missing > MAX_V*n:
            return []
        q, r = divmod(missing-MIN_V*n, (MAX_V-MIN_V))
        return [MAX_V if i < q else MIN_V+r if i == q else MIN_V  for i in range(n)]
",n
"
import heapq


class Solution(object):
    def minStoneSum(self, piles, k):
        for i, x in enumerate(piles):
            piles[i] = -x
        heapq.heapify(piles)
        for i in range(k):
            heapq.heappush(piles, heapq.heappop(piles)//2)
        return -sum(piles)
",n + klogn
"
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        if root in (None, p, q):
            return root

        left, right = [self.lowestCommonAncestor(child, p, q) \
                         for child in (root.left, root.right)]
        return root if left and right else left or right

",n
"
class Solution(object):
    def spiralMatrixIII(self, R, C, r0, c0):
        r, c = r0, c0
        result = [[r, c]]
        x, y, n, i = 0, 1, 0, 0
        while len(result) < R*C:
            r, c, i = r+x, c+y, i+1
            if 0 <= r < R and 0 <= c < C:
                result.append([r, c])
            if i == n//2+1:
                x, y, n, i = y, -x, n+1, 0
        return result

","max(m, n)^2"
"
class Solution(object):
    def isMonotonic(self, A):
        inc, dec = False, False
        for i in range(len(A)-1):
            if A[i] < A[i+1]:
                inc = True
            elif A[i] > A[i+1]:
                dec = True
        return not inc or not dec

",n
"
class Solution(object):
    def lengthOfLastWord(self, s):
        length = 0
        for i in reversed(s):
            if i == ' ':
                if length:
                    break
            else:
                length += 1
        return length

",n
"class Solution2(object):
    def lengthOfLastWord(self, s):
        return len(s.strip().split("" "")[-1])

",n
"
class Solution(object):
    def concatenatedBinary(self, n):
        MOD = 10**9+7
        result = l = 0
        for i in range(1, n+1):
            if i&(i-1) == 0:
                l += 1
            result = ((result<<l)%MOD+i)%MOD
        return result
",n
"
import bisect


class Solution(object):
    def minimumMountainRemovals(self, nums):
        left_lis_len = [0]*len(nums)
        lis = []
        for i in range(len(nums)-1):
            j = bisect.bisect_left(lis, nums[i])
            if j == len(lis):
                lis.append(nums[i])
            else:
                lis[j] = nums[i]
            left_lis_len[i] = j
        max_len = 0
        lis = []
        for i in reversed(range(1, len(nums))):
            j = bisect.bisect_left(lis, nums[i])
            if j == len(lis):
                lis.append(nums[i])
            else:
                lis[j] = nums[i]
            if i < len(nums)-1:
                max_len = max(max_len, left_lis_len[i]+j)
        return len(nums) - (1+max_len)
",nlogn
"
import itertools
import re


class Solution(object):
    def summaryRanges(self, nums):
        ranges = []
        if not nums:
            return ranges

        start, end = nums[0], nums[0]
        for i in range(1, len(nums) + 1):
            if i < len(nums) and nums[i] == end + 1:
                end = nums[i]
            else:
                interval = str(start)
                if start != end:
                    interval += ""->"" + str(end)
                ranges.append(interval)
                if i < len(nums):
                    start = end = nums[i]

        return ranges

",n
"class Solution2(object):
    def summaryRanges(self, nums):
        return [re.sub('->.*>', '->', '->'.join(repr(n) for _, n in g))
            for _, g in itertools.groupby(enumerate(nums), lambda i_n: i_n[1]-i_n[0])]

",n
"
class ArrayReader(object):
    def query(self, a, b, c, d):
        pass

    def length(self):
        pass
    

class Solution(object):
    def guessMajority(self, reader):
        count_a, count_b, idx_b = 1, 0, None
        value_0_1_2_3 = reader.query(0, 1, 2, 3)
        for i in reversed(range(4, reader.length())):
            value_0_1_2_i = reader.query(0, 1, 2, i)
            if value_0_1_2_i == value_0_1_2_3: 
                count_a = count_a+1
            else:
                count_b, idx_b = count_b+1, i
        value_0_1_2_4 = value_0_1_2_i
        for i in range(3):
            value_a_b_3_4 = reader.query(*[v for v in [0, 1, 2, 3, 4] if v != i])
            if value_a_b_3_4 == value_0_1_2_4: 
                count_a = count_a+1
            else:
                count_b, idx_b = count_b+1, i
        if count_a == count_b:
            return -1
        return 3 if count_a > count_b else idx_b
",n
"
class Solution(object):
    def platesBetweenCandles(self, s, queries):
        left, prefix = [0]*len(s), {}
        curr, cnt = -1, 0
        for i in range(len(s)):
            if s[i] == '|':
                curr = i
                cnt += 1
                prefix[i] = cnt
            left[i] = curr
        right = [0]*len(s)
        curr = len(s)
        for i in reversed(range(len(s))):
            if s[i] == '|':
                curr = i
            right[i] = curr
        return [max((left[r]-right[l]+1) - (prefix[left[r]]-prefix[right[l]]+1), 0) for l, r in queries]
",n + q
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def middleNode(self, head):
        slow, fast = head, head
        while fast and fast.__next__:
            slow, fast = slow.__next__, fast.next.__next__
        return slow

",n
"
class Solution(object):
    def isRobotBounded(self, instructions):
        directions = [[ 1, 0], [0, -1], [-1, 0], [0, 1]]
        x, y, i = 0, 0, 0
        for instruction in instructions:
            if instruction == 'R':
                i = (i+1) % 4
            elif instruction == 'L':
                i = (i-1) % 4
            else:
                x += directions[i][0]
                y += directions[i][1]
        return (x == 0 and y == 0) or i > 0
",n
"

class Solution(object):
    def waysToSplitArray(self, nums):
        total = sum(nums)
        result = curr = 0
        for i in range(len(nums)-1):
            curr += nums[i]
            result += int(curr >= total-curr)
        return result
",n
"

class Solution(object):
    def countCoveredBuildings(self, n, buildings):
        left = [n]*n
        right = [-1]*n
        up = [-1]*n
        down = [n]*n
        for x, y in buildings:
            x -= 1
            y -= 1
            left[y] = min(left[y], x)
            right[y] = max(right[y], x)
            up[x] = max(up[x], y)
            down[x] = min(down[x], y) 
        return sum(left[y-1] < x-1 < right[y-1] and down[x-1] < y-1 < up[x-1] for x, y in buildings)
",n
"

class Solution(object):
    def minCosts(self, cost):
        for i in range(1, len(cost)):
            cost[i] = min(cost[i], cost[i-1])
        return cost
",n
"
class Solution(object):
    def dailyTemperatures(self, temperatures):
        result = [0] * len(temperatures)
        stk = []
        for i in range(len(temperatures)):
            while stk and \
                  temperatures[stk[-1]] < temperatures[i]:
                idx = stk.pop()
                result[idx] = i-idx
            stk.append(i)
        return result

",n
"

class Solution(object):
    def clearDigits(self, s):
        s = list(s)
        j = 0
        for i, x in enumerate(s):
            if x.isdigit():
                j -= 1
                continue
            s[j] = x
            j += 1
        while len(s) > j:
            s.pop()
        return """".join(s)


",n
"
class Solution2(object):
    def clearDigits(self, s):
        result = []
        for x in s:
            if x.isdigit():
                result.pop()
                continue
            result.append(x)
        return """".join(result)
",n
"
class Solution(object):
    def minInsertions(self, s):
        add, bal = 0, 0
        for c in s:
            if c == '(':
                if bal > 0 and bal%2:
                    add += 1
                    bal -= 1
                bal += 2
            else:
                bal -= 1
                if bal < 0:
                    add += 1
                    bal += 2
        return add + bal
",n
"
import collections
from functools import reduce


class Solution(object):
    def numberOfGoodSubsets(self, nums):
        def sieve_of_eratosthenes(n): 
            if n < 2:
                return []
            primes = [2]
            is_prime = [True]*((n+1)//2)
            for i in range(1, len(is_prime)):
                if not is_prime[i]:
                    continue
                primes.append(2*i+1)
                for j in range(2*i*(i+1), len(is_prime), (2*i+1)):
                    is_prime[j] = False
            return primes

        def to_mask(primes, x):
            mask, basis = 0, 1
            for p in primes:
                if x%p == 0:
                    mask |= basis
                basis <<= 1
            return mask

        MOD = 10**9+7
        primes = sieve_of_eratosthenes(max(nums))
        dp = [0]*(1<<len(primes)) 
        dp[0] = 1
        cnts = collections.Counter(nums)
        for x, cnt in cnts.items():
            if x == 1 or any(x%(p*p) == 0 for p in primes if p*p <= x):
                continue
            mask = to_mask(primes, x)
            for i in range(len(dp)-1):
                if i&mask:
                    continue
                dp[i|mask] = (dp[i|mask]+cnt*dp[i])%MOD
        return (pow(2, cnts[1], MOD))*(reduce(lambda total, x: (total+x)%MOD, dp, 0)-1)%MOD
",n * 2^p
"





import collections
from functools import reduce


class Solution(object):
    def longestDupSubstring(self, S):
        M = 10**9+7
        D = 26

        def check(S, L):
            p = pow(D, L, M)
            curr = reduce(lambda x, y: (D*x+ord(y)-ord('a')) % M, S[:L], 0)
            lookup = collections.defaultdict(list)
            lookup[curr].append(L-1)
            for i in range(L, len(S)):
                curr = ((D*curr) % M + ord(S[i])-ord('a') -
                        ((ord(S[i-L])-ord('a'))*p) % M) % M
                if curr in lookup:
                    for j in lookup[curr]: 
                        if S[j-L+1:j+1] == S[i-L+1:i+1]:
                            return i-L+1
                lookup[curr].append(i)
            return 0

        left, right = 1, len(S)-1
        while left <= right:
            mid = left + (right-left)//2
            if not check(S, mid):
                right = mid-1
            else:
                left = mid+1
        result = check(S, right)
        return S[result:result + right]
",nlogn
"
class Solution(object):
    def escapeGhosts(self, ghosts, target):
        total = abs(target[0])+abs(target[1])
        return all(total < abs(target[0]-i)+abs(target[1]-j) for i, j in ghosts)

",n
"

class Solution(object):
    def sortVowels(self, s):
        def inplace_counting_sort(nums, reverse=False): 
            if not nums:
                return
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()
    
        VOWELS = ""AEIOUaeiou""
        LOOKUP = {x:i for i, x in enumerate(VOWELS)}
        vowels = [LOOKUP[x] for x in s if x in LOOKUP]
        inplace_counting_sort(vowels, reverse=True)
        return """".join(VOWELS[vowels.pop()] if x in LOOKUP else x for x in s)


",n
"
class Solution2(object):
    def sortVowels(self, s):
        VOWELS = ""AEIOUaeiou""
        LOOKUP = set(VOWELS)
        vowels = [x for x in s if x in LOOKUP]
        vowels.sort(reverse=True)
        return """".join(vowels.pop() if x in LOOKUP else x for x in s)
",nlogn
"

class Solution(object):
    def latestTimeCatchTheBus(self, buses, passengers, capacity):
        buses.sort()
        passengers.sort()
        cnt = j = 0
        for i in range(len(buses)-1):
            while j < len(passengers) and passengers[j] <= buses[i]:
                cnt += 1
                j += 1
            cnt = max(cnt-capacity, 0)
        j -= max(cnt-capacity, 0)
        cnt = min(cnt, capacity)
        while j < len(passengers) and passengers[j] <= buses[-1] and cnt+1 <= capacity:
            cnt += 1
            j += 1
        return buses[-1] if cnt < capacity and (j-1 < 0 or passengers[j-1] != buses[-1]) else next(passengers[i]-1 for i in reversed(range(j)) if i-1 < 0 or passengers[i]-1 != passengers[i-1])
",nlogn + mlogm
"
class Solution(object):
    def repeatedSubstringPattern(self, str):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j + 1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        prefix = getPrefix(str)
        return prefix[-1] != -1 and \
               (prefix[-1] + 1) % (len(str) - prefix[-1] - 1) == 0

    def repeatedSubstringPattern2(self, str):
        if not str:
            return False

        ss = (str + str)[1:-1]
        return ss.find(str) != -1

",n
"

class Solution(object):
    def lenOfVDiagonal(self, grid):
        n, m = len(grid), len(grid[0])
        result = 0
        down_right = [[1]*m for _ in range(n)]
        down_left = [[1]*m for _ in range(n)]
        for i in range(n):
            for j in range(m):
                x = grid[i][j]
                if x == 1:
                    result = 1
                    continue
                if i-1 >= 0 and j-1 >= 0 and grid[i-1][j-1] == 2-x:
                    down_right[i][j] = down_right[i-1][j-1]+1
                if i-1 >= 0 and j+1 < m and grid[i-1][j+1] == 2-x:
                    down_left[i][j] = down_left[i-1][j+1]+1
        up_right = [[1]*m for _ in range(n)]
        up_left = [[1]*m for _ in range(n)]
        for i in reversed(range(n)):
            for j in range(m):
                x = grid[i][j]
                if x == 1:
                    continue
                if i+1 < n and j-1 >= 0 and grid[i+1][j-1] == 2-x:
                    up_right[i][j] = up_right[i+1][j-1]+1
                if i+1 < n and j+1 < m and grid[i+1][j+1] == 2-x:
                    up_left[i][j] = up_left[i+1][j+1]+1
        for i in range(n):
            for j in range(m):
                x = grid[i][j]
                if x == 1:
                    continue
                if (down_right[i][j]%2*2 == 0 and x == 0) or (down_right[i][j]%2 == 1 and x == 2):
                    ni = i-down_right[i][j]
                    nj = j-down_right[i][j]
                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 1:
                        result = max(result, down_right[i][j]+up_right[i][j]) 
                if (down_left[i][j]%2 == 0 and x == 0) or (down_left[i][j]%2 == 1 and x == 2):
                    ni = i-down_left[i][j]
                    nj = j+down_left[i][j]
                    if 0 <= ni< n and 0 <= nj < m and grid[ni][nj] == 1:
                        result = max(result, down_left[i][j]+down_right[i][j]) 
                if (up_left[i][j]%2 == 0 and x == 0) or (up_left[i][j]%2 == 1 and x == 2):
                    ni = i+up_left[i][j]
                    nj = j+up_left[i][j]
                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 1:
                        result = max(result, up_left[i][j]+down_left[i][j]) 
                if (up_right[i][j]%2 == 0 and x == 0) or (up_right[i][j]%2 == 1 and x == 2):
                    ni = i+up_right[i][j]
                    nj = j-up_right[i][j]
                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 1:
                        result = max(result, up_right[i][j]+up_left[i][j]) 
        return result


",n * m
"
class Solution2(object):
    def lenOfVDiagonal(self, grid):
        def memoization(i, j, x, d, k):
            if not (0 <= i < n and 0 <= j < m):
                return 0
            if grid[i][j] != x:
                return 0
            if lookup[k][x][d][i][j] == 0:
                ni, nj = i+directions[d][0], j+directions[d][1]
                nx = 0 if x == 2 else 2
                result = memoization(ni, nj, nx, d, k)+1
                if k != 1:
                    nd = (d+1)%4
                    result = max(result, memoization(ni, nj, nx, nd, k+1)+1)
                lookup[k][x][d][i][j] = result
            return lookup[k][x][d][i][j]

        n, m = len(grid), len(grid[0])
        directions = ((1, 1), (1, -1), (-1, -1), (-1, 1))
        lookup = [[[[[0]*m for _ in range(n)] for _ in range(4)] for _ in range(3)] for _ in range(2)] 
        result = 0
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    for d in range(4):
                        result = max(result, memoization(i, j, 1, d, 0))
        return result
",n * m
"
class Solution(object):
    def integerReplacement(self, n):
        result = 0
        while n != 1:
            b = n & 3
            if n == 3:
                n -= 1
            elif b == 3:
                n += 1
            elif b == 1:
                n -= 1
            else:
                n /= 2
            result += 1

        return result


",logn
"
class Solution2(object):
    def integerReplacement(self, n):
        if n < 4:
            return [0, 0, 1, 2][n]
        if n % 4 in (0, 2):
            return self.integerReplacement(n / 2) + 1
        elif n % 4 == 1:
            return self.integerReplacement((n - 1) / 4) + 3
        else:
            return self.integerReplacement((n + 1) / 4) + 3


",logn
"

class Solution(object):
    def kthLuckyNumber(self, k):
        result = []
        k += 1
        while k != 1:
            result.append('7' if k&1 else '4')
            k >>= 1
        result.reverse()
        return """".join(result)


",logn
"
class Solution2(object):
    def kthLuckyNumber(self, k):
        return bin(k+1)[3:].replace('1', '7').replace('0', '4')
",logn
"
class Solution(object):
    def mostVisited(self, n, rounds):
        return list(range(rounds[0], rounds[-1]+1)) or \
               list(range(1, rounds[-1]+1)) + list(range(rounds[0], n+1))
",n
"
class Solution(object):
    def superPow(self, a, b):
        def myPow(a, n, b):
            result = 1
            x = a % b
            while n:
                if n & 1:
                    result = result * x % b
                n >>= 1
                x = x * x % b
            return result % b

        result = 1
        for digit in b:
            result = myPow(result, 10, 1337) * myPow(a, digit, 1337) % 1337
        return result

",n
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def averageOfSubtree(self, root):
        def iter_dfs(root):
            result = 0
            stk = [(1, (root, [0]*2))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node:
                        continue
                    ret1, ret2 = [0]*2, [0]*2
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    ret[0] = ret1[0]+ret2[0]+node.val
                    ret[1] = ret1[1]+ret2[1]+1
                    result += int(ret[0]//ret[1] == node.val)
            return result
        
        return iter_dfs(root)


",n
"
class Solution2(object):
    def averageOfSubtree(self, root):
        def dfs(node):
            if not node:
                return [0]*3
            left = dfs(node.left)
            right = dfs(node.right)
            return [left[0]+right[0]+node.val,
                    left[1]+right[1]+1,
                    left[2]+right[2]+int((left[0]+right[0]+node.val)//(left[1]+right[1]+1) == node.val)]
        
        return dfs(root)[2]
",n
"

class Solution(object):
    def numberOfWays(self, s, t, k):
        MOD = 10**9+7
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    yield i-j
                    j = prefix[j]

        n = len(s)
        dp = [0]*2
        dp[1] = ((pow(n-1, k, MOD)-(-1)**k)*pow(n, MOD-2, MOD))%MOD
        dp[0] = (dp[1]+(-1)**k)%MOD
        return reduce(lambda a, b: (a+b)%MOD, (dp[int(i != 0)] for i in KMP(s+s[:-1], t)), 0)


",n + logk
"
class Solution2(object):
    def numberOfWays(self, s, t, k):
        MOD = 10**9+7
        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    yield i-j
                    j = prefix[j]

        n = len(s)
        T = [[0, 1],
             [n-1, (n-1)-1]]
        dp = [1, 0]
        dp = matrix_mult([dp], matrix_expo(T, k))[0] 
        return reduce(lambda a, b: (a+b)%MOD, (dp[int(i != 0)] for i in KMP(s+s[:-1], t)), 0)


",n + logk
"
class Solution3(object):
    def numberOfWays(self, s, t, k):
        MOD = 10**9+7
        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        n = len(s)
        T = [[0, 1],
             [n-1, (n-1)-1]]
        dp = [1, 0]
        dp = matrix_mult([dp], matrix_expo(T, k))[0] 
        z = z_function(t+s+s[:-1])
        return reduce(lambda a, b: (a+b)%MOD, (dp[int(i != 0)] for i in range(n) if z[i+len(t)] >= len(t)), 0)
",n + logk
"
import collections



class Solution(object):
    def validPath(self, n, edges, start, end):
        def bi_bfs(adj, start, target):
            left, right = {start}, {target}
            lookup = set()
            steps = 0
            while left:
                for pos in left:
                    lookup.add(pos)
                new_left = set()
                for pos in left:
                    if pos in right: 
                        return steps
                    for nei in adj[pos]:
                        if nei in lookup:
                            continue
                        new_left.add(nei)
                left = new_left
                steps += 1
                if len(left) > len(right): 
                    left, right = right, left
            return -1

        adj = collections.defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return bi_bfs(adj, start, end) >= 0


",|V| + |E|
"
class Solution2(object):
    def validPath(self, n, edges, start, end):
        def bfs(adj, start, target):
            q = [start]
            lookup = set(q)
            steps = 0
            while q:
                new_q = []
                for pos in q:
                    if pos == target:
                        return steps
                    for nei in adj[pos]:
                        if nei in lookup:
                            continue
                        lookup.add(nei)
                        new_q.append(nei)
                q = new_q
                steps += 1
            return -1  

        adj = collections.defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return bfs(adj, start, end) >= 0


",|V| + |E|
"
class Solution3(object):
    def validPath(self, n, edges, start, end):
        def dfs(adj, start, target):
            stk = [start]
            lookup = set(stk)
            while stk:
                pos = stk.pop()
                if pos == target:
                    return True
                for nei in reversed(adj[pos]):
                    if nei in lookup:
                        continue
                    lookup.add(nei)
                    stk.append(nei)
            return False 

        adj = collections.defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return dfs(adj, start, end)
",|V| + |E|
"

class Solution(object):
    def permute(self, n, k):
        result = []
        cnt = [1]*n
        for i in range(len(cnt)-1):
            cnt[i+1] = min(cnt[i]*((i+2)//2), k)
        lookup = [False]*n
        for i in range(n):
            for j in range(n):
                if not (not lookup[j] and ((i == 0 and n%2 == 0) or (j+1)%2 == (1 if not result else (result[-1]%2)^1))):
                    continue
                if k <= cnt[n-1-i]:
                    break
                k -= cnt[n-1-i]
            else:
                return []
            lookup[j] = True
            result.append(j+1)
        return result


",n^2
"
class Solution2(object):
    def permute(self, n, k):
        result = []
        fact = [1]*(((n-1)+1)//2+1)
        for i in range(len(fact)-1):
            fact[i+1] = fact[i]*(i+1)
        lookup = [False]*n
        for i in range(n):
            cnt = fact[(n-1-i)//2]*fact[((n-1-i)+1)//2]
            for j in range(n):
                if not (not lookup[j] and ((i == 0 and n%2 == 0) or (j+1)%2 == (1 if not result else (result[-1]%2)^1))):
                    continue
                if k <= cnt:
                    break
                k -= cnt
            else:
                return []
            lookup[j] = True
            result.append(j+1)
        return result
",n^2
"
class Solution(object):
    def bestCoordinate(self, towers, radius):
        min_x = min(towers, key=lambda x:x[0])[0]
        max_x = max(towers, key=lambda x:x[0])[0]
        min_y = min(towers, key=lambda x:x[1])[1]
        max_y = max(towers, key=lambda x:x[1])[1]
        max_quality = 0
        for x in range(min_x, max_x+1):
            for y in range(min_y, max_y+1):
                q = 0
                for nx, ny, nq in towers:
                    d = ((nx-x)**2+(ny-y)**2)**0.5
                    if d <= radius:
                        q += int(nq/(1+d))
                if q > max_quality:
                    max_quality = q
                    result = x, y
        return result
",n^2
"
import math


class Solution(object):
    def minmaxGasDist(self, stations, K):
        def check(x):
            return sum(int(math.ceil((stations[i+1]-stations[i])/x))-1 for i in range(len(stations)-1)) <= K

        left, right = 0, stations[-1]-stations[0]
        while right-left > 1e-6:
            mid = left + (right-left)/2.0
            if check(mid):
                right = mid
            else:
                left = mid
        return left

",nlogr
"
class Solution(object):
    def check(self, nums):
        count = 0
        for i in range(len(nums)):
            if nums[i] > nums[(i+1)%len(nums)]:
                count += 1
                if count > 1:
                    return False
        return True
",n
"
import collections


class Solution(object):
    def smallerNumbersThanCurrent(self, nums):
        count = collections.Counter(nums)
        for i in range(max(nums)+1):
            count[i] += count[i-1]
        return [count[i-1] for i in nums]


",n + m
"import bisect


class Solution2(object):
    def smallerNumbersThanCurrent(self, nums):
        sorted_nums = sorted(nums)
        return [bisect.bisect_left(sorted_nums, i) for i in nums]
",nlogn
"
import collections



class Solution(object):
    def maximumMinutes(self, grid):
        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        GRASS, FIRE, WALL, PERSON = list(range(4))
        INF = 10**9
        def bfs(grid):
            time = collections.defaultdict(int)
            d = 0
            q = [(r, c, FIRE) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c] == FIRE]
            q.append((0, 0, PERSON))
            while q:
                new_q = []
                for r, c, t in q:
                    for dr, dc in DIRECTIONS:
                        nr, nc = r+dr, c+dc
                        if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and
                                grid[nr][nc] != WALL and
                                ((t == FIRE and grid[nr][nc] != FIRE) or
                                 (t == PERSON and (grid[nr][nc] == GRASS or (grid[nr][nc] == FIRE and (nr, nc) == (len(grid)-1, len(grid[0])-1) and d+1 == time[FIRE, nr, nc]))))):
                            continue
                        if grid[nr][nc] != FIRE:
                            grid[nr][nc] = t
                        if (nr, nc) in ((len(grid)-1, len(grid[0])-1), (len(grid)-1, len(grid[0])-2), (len(grid)-2, len(grid[0])-1)):
                            time[t, nr, nc] = d+1
                        new_q.append((nr, nc, t))
                q = new_q
                d += 1
            return time

        time = bfs(grid)
        if not time[PERSON, len(grid)-1, len(grid[0])-1]:
            return -1
        if not time[FIRE, len(grid)-1, len(grid[0])-1]:
            return INF
        diff = time[FIRE, len(grid)-1, len(grid[0])-1]-time[PERSON, len(grid)-1, len(grid[0])-1]
        return diff if diff+2 in (time[FIRE, len(grid)-1, len(grid[0])-2]-time[PERSON, len(grid)-1, len(grid[0])-2],
                                  time[FIRE, len(grid)-2, len(grid[0])-1]-time[PERSON, len(grid)-2, len(grid[0])-1]) else diff-1


",m * n
"
class Solution2(object):
    def maximumMinutes(self, grid):
        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        FIRE, WALL, PERSON = list(range(1, 4))
        INF = 10**9
        def bfs(grid):
            time = {FIRE:[[INF]*len(grid[0]) for _ in range(len(grid))],
                    PERSON:[[INF]*len(grid[0]) for _ in range(len(grid))]}
            d = 0
            q = [(r, c, FIRE) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c] == FIRE]
            q.append((0, 0, PERSON))
            for r, c, t in q:
                time[t][r][c] = d
            while q:
                new_q = []
                for r, c, t in q:
                    for dr, dc in DIRECTIONS:
                        nr, nc = r+dr, c+dc
                        if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and
                                grid[nr][nc] != WALL and time[t][nr][nc] == INF and
                                (t == FIRE or
                                 d+1 < time[FIRE][nr][nc] or (d+1 == time[FIRE][nr][nc] and (nr, nc) == (len(grid)-1, len(grid[0])-1)))):
                            continue
                        time[t][nr][nc] = d+1
                        new_q.append((nr, nc, t))
                q = new_q
                d += 1
            return time

        time = bfs(grid)
        if time[PERSON][-1][-1] == INF:
            return -1
        if time[FIRE][-1][-1] == INF:
            return INF
        diff = time[FIRE][-1][-1]-time[PERSON][-1][-1]
        return diff if diff+2 in (time[FIRE][-1][-2]-time[PERSON][-1][-2], time[FIRE][-2][-1]-time[PERSON][-2][-1]) else diff-1
",m * n
"

class Solution(object):
    def longestContinuousSubstring(self, s):
        result = l = 0
        for i in range(len(s)):
            l += 1
            if i+1 == len(s) or ord(s[i])+1 != ord(s[i+1]):
                result = max(result, l)
                l = 0
        return result
",n
"
import random



class Solution(object):
    def putMarbles(self, weights, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        for i in range(len(weights)-1):
            weights[i] += weights[i+1]
        weights.pop()
        result = 0
        nth_element(weights, (k-1)-1, compare=lambda a, b: a > b)
        result += sum(weights[i] for i in range(k-1))
        nth_element(weights, (k-1)-1)
        result -= sum(weights[i] for i in range(k-1))
        return result
",n
"

class Solution(object):
    def mergeArrays(self, nums1, nums2):
        result = []
        i = j = 0
        while i < len(nums1) or j < len(nums2):
            if j == len(nums2) or (i < len(nums1) and nums1[i][0] < nums2[j][0]):
                if result and result[-1][0] == nums1[i][0]:
                    result[-1][1] += nums1[i][1]
                else:
                    result.append(nums1[i])
                i += 1
            else:
                if result and result[-1][0] == nums2[j][0]:
                    result[-1][1] += nums2[j][1]
                else:
                    result.append(nums2[j])
                j += 1
        return result
",n
"
from random import randint

class Solution(object):

    def __init__(self):
        self.__set = []
        self.__used = {}


    def insert(self, val):
        if val in self.__used:
            return False

        self.__set += val,
        self.__used[val] = len(self.__set)-1

        return True


    def remove(self, val):
        if val not in self.__used:
            return False

        self.__used[self.__set[-1]] = self.__used[val]
        self.__set[self.__used[val]], self.__set[-1] = self.__set[-1], self.__set[self.__used[val]]

        self.__used.pop(val)
        self.__set.pop()

        return True

    def getRandom(self):
        return self.__set[randint(0, len(self.__set)-1)]



",1
"

class Solution(object):
    def minPathCost(self, grid, moveCost):
        dp = [[0]*len(grid[0]) for _ in range(2)]
        dp[0] = [grid[0][j] for j in range(len(grid[0]))]
        for i in range(len(grid)-1):
            for j in range(len(grid[0])):
                dp[(i+1)%2][j] = min(dp[i%2][k]+moveCost[x][j] for k, x in enumerate(grid[i]))+grid[i+1][j]
        return min(dp[(len(grid)-1)%2])
",m * n^2
"
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        s, b = sorted([p.val, q.val])
        while not s <= root.val <= b:
            root = root.left if s <= root.val else root.right
        return root

",n
"
import bisect


MAX_HIGH = int(2e9)
result = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for i in range(1, MAX_HIGH):
    if result[-1] >= MAX_HIGH:
        break
    d1 = result[i]%10 - 1
    if d1 >= 0:
        result.append(result[i]*10 + d1)
    d2 = result[i]%10 + 1
    if d2 <= 9:
        result.append(result[i]*10 + d2)
result.append(float(""inf""))


class Solution(object):
    def countSteppingNumbers(self, low, high):
        lit = bisect.bisect_left(result, low)
        rit = bisect.bisect_right(result, high)
        return result[lit:rit]


",logk + r
"class Solution2(object):
    def countSteppingNumbers(self, low, high):
        result = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        for i in range(1, high):
            if result[-1] >= high:
                break
            d1 = result[i]%10 - 1
            if d1 >= 0:
                result.append(result[i]*10 + d1)
            d2 = result[i]%10 + 1
            if d2 <= 9:
                result.append(result[i]*10 + d2)
        result.append(float(""inf""))
        lit = bisect.bisect_left(result, low)
        rit = bisect.bisect_right(result, high)
        return result[lit:rit]
",k + r
"
class Solution(object):
    def highestPeak(self, isWater):
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        q = []
        for r, row in enumerate(isWater):
            for c, cell in enumerate(row):
                row[c] -= 1
                if not cell:
                    continue
                q.append((r, c))
        while q:
            new_q = []
            for r, c in q:
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc 
                    if not (0 <= nr < len(isWater) and
                            0 <= nc < len(isWater[0]) and
                            isWater[nr][nc] == -1):
                        continue
                    isWater[nr][nc] = isWater[r][c]+1
                    q.append((nr, nc))
            q = new_q
        return isWater


",m * n
"class Solution2(object):
    def highestPeak(self, isWater):
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        q, heights = [], [[-1]*len(isWater[0]) for _ in range(len(isWater))]
        for r, row in enumerate(isWater):
            for c, cell in enumerate(row):
                if not cell:
                    continue
                heights[r][c] = 0
                q.append((r, c))
        while q:
            new_q = []
            for r, c in q:
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc 
                    if not (0 <= nr < len(isWater) and
                            0 <= nc < len(isWater[0]) and
                            heights[nr][nc] == -1):
                        continue
                    heights[nr][nc] = heights[r][c]+1
                    q.append((nr, nc))
            q = new_q
        return heights
",m * n
"
start, end, height = 0, 1, 2
class Solution(object):
    def getSkyline(self, buildings):
        intervals = self.ComputeSkylineInInterval(buildings, 0, len(buildings))

        res = []
        last_end = -1
        for interval in intervals:
            if last_end != -1 and last_end < interval[start]:
                res.append([last_end, 0])
            res.append([interval[start], interval[height]])
            last_end = interval[end]
        if last_end != -1:
            res.append([last_end, 0])

        return res

    def ComputeSkylineInInterval(self, buildings, left_endpoint, right_endpoint):
        if right_endpoint - left_endpoint <= 1:
            return buildings[left_endpoint:right_endpoint]
        mid = left_endpoint + ((right_endpoint - left_endpoint) / 2)
        left_skyline = self.ComputeSkylineInInterval(buildings, left_endpoint, mid)
        right_skyline = self.ComputeSkylineInInterval(buildings, mid, right_endpoint)
        return self.MergeSkylines(left_skyline, right_skyline)

    def MergeSkylines(self, left_skyline, right_skyline):
        i, j = 0, 0
        merged = []

        while i < len(left_skyline) and j < len(right_skyline):
            if left_skyline[i][end] < right_skyline[j][start]:
                merged.append(left_skyline[i])
                i += 1
            elif right_skyline[j][end] < left_skyline[i][start]:
                merged.append(right_skyline[j])
                j += 1
            elif left_skyline[i][start] <= right_skyline[j][start]:
                i, j = self.MergeIntersectSkylines(merged, left_skyline[i], i,\
                                                   right_skyline[j], j)
            else:
                j, i = self.MergeIntersectSkylines(merged, right_skyline[j], j, \
                                                   left_skyline[i], i)

        merged += left_skyline[i:]
        merged += right_skyline[j:]
        return merged

    def MergeIntersectSkylines(self, merged, a, a_idx, b, b_idx):
        if a[end] <= b[end]:
            if a[height] > b[height]:  
                if b[end] != a[end]:   
                    b[start] = a[end]
                    merged.append(a)
                    a_idx += 1
                else:            
                    b_idx += 1   
            elif a[height] == b[height]: 
                b[start] = a[start]      
                a_idx += 1
            else: 
                if a[start] != b[start]:                           
                    merged.append([a[start], b[start], a[height]]) 
                a_idx += 1
        else: 
            if a[height] >= b[height]: 
                b_idx += 1             
            else:
                if a[start] != b[start]:
                    merged.append([a[start], b[start], a[height]])
                a[start] = b[end]
                merged.append(b)
                b_idx += 1
        return a_idx, b_idx

",nlogn
"

class Solution(object):
    def triangleType(self, nums):
        nums.sort()
        a, b, c = nums
        if a+b <= c:
            return ""none""
        if a == b == c:
            return ""equilateral""
        if a == b or b == c:
            return ""isosceles""
        return ""scalene""
",1
"

class Solution(object):
    def shiftingLetters(self, s, shifts):
        events = [0]*(len(s)+1)
        for b, e, d in shifts:
            events[b] += 1 if d else -1
            events[e+1] -= 1 if d else -1
        result = []
        curr = 0
        for i in range(len(s)):
            curr += events[i]
            result.append(chr(ord('a')+(ord(s[i])-ord('a')+curr)%26))
        return """".join(result)
",n
"
import collections


class Solution(object):
    def findDuplicateSubtrees(self, root):
        def getid(root, lookup, trees):
            if not root:
                return -1
            node_id = lookup[root.val,
                             getid(root.left, lookup, trees),
                             getid(root.right, lookup, trees)]
            trees[node_id].append(root)
            return node_id

        trees = collections.defaultdict(list)
        lookup = collections.defaultdict()
        lookup.default_factory = lookup.__len__
        getid(root, lookup, trees)
        return [roots[0] for roots in trees.values() if len(roots) > 1]


",n
"class Solution2(object):
    def findDuplicateSubtrees(self, root):
        def postOrderTraversal(node, lookup, result):
            if not node:
                return """"
            s = ""("" + postOrderTraversal(node.left, lookup, result) + \
                str(node.val) + \
                postOrderTraversal(node.right, lookup, result) + \
                "")""
            if lookup[s] == 1:
                result.append(node)
            lookup[s] += 1
            return s

        lookup = collections.defaultdict(int)
        result = []
        postOrderTraversal(root, lookup, result)
        return result

",n * h
"

class Solution(object):
    def maximumLengthSubstring(self, s):
        COUNT = 2
        result = 0
        cnt = [0]*26
        left = invalid_cnt = 0
        for right, x in enumerate(s):
            if cnt[ord(x)-ord('a')] == COUNT:
                invalid_cnt += 1
            cnt[ord(x)-ord('a')] += 1
            if invalid_cnt:
                cnt[ord(s[left])-ord('a')] -= 1
                if cnt[ord(s[left])-ord('a')] == COUNT:
                    invalid_cnt -= 1
                left += 1
        return right-left+1


",n + 26
"
class Solution2(object):
    def maximumLengthSubstring(self, s):
        COUNT = 2
        result = 0
        cnt = [0]*26
        left = 0
        for right, x in enumerate(s):
            cnt[ord(x)-ord('a')] += 1
            while cnt[ord(x)-ord('a')] > COUNT:
                cnt[ord(s[left])-ord('a')] -= 1
                left += 1
            result = max(result, right-left+1)
        return result
",n + 26
"

class Solution(object):
    def countPaths(self, n, edges):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf
        
        def is_prime(u):
            return spf[u] == u

        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [0]*2))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    ret[:] = [1-is_prime(u+1), is_prime(u+1)]
                    stk.append((2, (u, p, ret, 0)))
                elif step == 2:
                    u, p, ret, i = args
                    if i == len(adj[u]):
                        continue
                    v = adj[u][i]
                    stk.append((2, (u, p, ret, i+1)))
                    if v == p:
                        continue
                    new_ret = [0]*2
                    stk.append((3, (u, p, new_ret, ret, i)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    u, p, new_ret, ret, i = args
                    result += ret[0]*new_ret[1]+ret[1]*new_ret[0]
                    if is_prime(u+1):
                        ret[1] += new_ret[0]
                    else:
                        ret[0] += new_ret[0]
                        ret[1] += new_ret[1]
            return result

        spf = linear_sieve_of_eratosthenes(n)
        adj = [[] for _ in range(n)]
        for u, v in edges:
            u, v = u-1, v-1
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()


",n
"
class Solution2(object):
    def countPaths(self, n, edges):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf
        
        def is_prime(u):
            return spf[u] == u

        def dfs(u, p):
            cnt = [1-is_prime(u+1), is_prime(u+1)]
            for v in adj[u]:
                if v == p:
                    continue
                new_cnt = dfs(v, u)
                result[0] += cnt[0]*new_cnt[1]+cnt[1]*new_cnt[0]
                if is_prime(u+1):
                    cnt[1] += new_cnt[0]
                else:
                    cnt[0] += new_cnt[0]
                    cnt[1] += new_cnt[1]
            return cnt

        spf = linear_sieve_of_eratosthenes(n)
        adj = [[] for _ in range(n)]
        for u, v in edges:
            u, v = u-1, v-1
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1)
        return result[0]


",n
"
class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n
        self.size = [1]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        self.size[y] += self.size[x]
        return True

    def total(self, x):
        return self.size[self.find_set(x)]


class Solution3(object):
    def countPaths(self, n, edges):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf
        
        def is_prime(u):
            return spf[u] == u

        spf = linear_sieve_of_eratosthenes(n)
        uf = UnionFind(n)
        for u, v in edges:
            u, v = u-1, v-1
            if is_prime(u+1) == is_prime(v+1) == False:
                uf.union_set(u, v) 
        result = 0
        cnt = [1]*n
        for u, v in edges:
            u, v = u-1, v-1
            if is_prime(u+1) == is_prime(v+1):
                continue
            if not is_prime(u+1):
                u, v = v, u
            result += cnt[u]*uf.total(v)
            cnt[u] += uf.total(v)
        return result
",n
"
import itertools


class Solution(object):
    def numOfWays(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))]
                       for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD
                     for col in ZB] for row in A]
        
        MOD = 10**9 + 7
        T = [[3, 2],
             [2, 2]]
        return sum(matrix_mult([[6, 6]], matrix_expo(T, n-1))[0]) % MOD 


",logn
"class Solution2(object):
    def numOfWays(self, n):
        MOD = 10**9 + 7
        aba, abc = 6, 6
        for _ in range(n-1):
            aba, abc = (3*aba%MOD + 2*abc%MOD)%MOD, \
                       (2*abc%MOD + 2*aba%MOD)%MOD
        return (aba+abc)%MOD
",n
"

class Node:
    def __init__(self, val):
        pass


class Solution(object):
    def flipBinaryTree(self, root, leaf):
        curr, parent = leaf, None
        while True:
            child = curr.parent
            curr.parent = parent
            if curr.left == parent:
                curr.left = None
            else:
                curr.right = None
            if curr == root:
                break
            if curr.left:
                curr.right = curr.left
            curr.left = child
            curr, parent = child, curr
        return leaf
",h
"
from sortedcontainers import SortedList



class Solution(object):
    def numberOfAlternatingGroups(self, colors, queries):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1)

            def add(self, i, val):
                i += 1
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret

        def update(i, d):
            if d == +1:
                sl.add(i)
                if len(sl) == 1:
                    bit1.add(n, +1)
                    bit2.add(n, +n)
            curr = sl.index(i)
            prv, nxt = (curr-1)%len(sl), (curr+1)%len(sl)
            if len(sl) != 1:
                l = (sl[nxt]-sl[prv]-1)%n+1
                bit1.add(l, d*(-1))
                bit2.add(l, d*(-l))
                l = (sl[curr]-sl[prv])%n
                bit1.add(l, d*(+1))
                bit2.add(l, d*(+l))
                l = (sl[nxt]-sl[curr])%n
                bit1.add(l, d*(+1))
                bit2.add(l, d*(+l))
            if d == -1:
                if len(sl) == 1:
                    bit1.add(n, -1)
                    bit2.add(n, -n)
                sl.pop(curr)

        n = len(colors)
        sl = SortedList()
        bit1, bit2 = BIT(n+1), BIT(n+1)
        for i in range(n):
            if colors[i] == colors[(i+1)%n]:
                update(i, +1)
        result = []
        for q in queries:
            if q[0] == 1:
                l = q[1]
                result.append((bit2.query(n)-bit2.query(l-1))-
                              (l-1)*(bit1.query(n)-bit1.query(l-1)) if sl else n)
                continue
            _, i, c = q
            if colors[i] == c:
                continue      
            colors[i] = c          
            update((i-1)%n, +1 if colors[i] == colors[(i-1)%n] else -1) 
            update(i, +1 if colors[i] == colors[(i+1)%n] else -1)
        return result
",nlogn + qlogn
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))
        else:
            return ""Nil""

class Solution(object):
    def insertionSortList(self, head):
        if head is None or self.isSorted(head):
            return head

        dummy = ListNode(-2147483648)
        dummy.next = head
        cur, sorted_tail = head.__next__, head
        while cur:
            prev = dummy
            while prev.next.val < cur.val:
                prev = prev.__next__
            if prev == sorted_tail:
                cur, sorted_tail = cur.__next__, cur
            else:
                cur.next, prev.next, sorted_tail.next = prev.next, cur, cur.next
                cur = sorted_tail.__next__

        return dummy.__next__

    def isSorted(self, head):
        while head and head.__next__:
            if head.val > head.next.val:
                return False
            head = head.__next__
        return True

",n ^ 2
"
from collections import deque

class Solution(object):

    def __init__(self, width,height,food):
        self.__width = width
        self.__height = height
        self.__score = 0
        self.__f = 0
        self.__food = food
        self.__snake = deque([(0, 0)])
        self.__direction = {""U"": (-1, 0), ""L"": (0, -1), ""R"": (0, 1), ""D"": (1, 0)}
        self.__lookup = {(0, 0)}

    def move(self, direction):
        def valid(x, y):
            return 0 <= x < self.__height and \
                   0 <= y < self.__width and \
                   (x, y) not in self.__lookup
        d = self.__direction[direction]
        x, y = self.__snake[-1][0] + d[0], self.__snake[-1][1] + d[1]
        self.__lookup.remove(self.__snake[0])
        tail = self.__snake.popleft()
        if not valid(x, y):
            return -1
        elif self.__f != len(self.__food) and (self.__food[self.__f][0], self.__food[self.__f][1]) == (x, y):
            self.__score += 1
            self.__f += 1
            self.__snake.appendleft(tail)
            self.__lookup.add(tail)
        self.__snake.append((x, y))
        self.__lookup.add((x, y))
        return self.__score

",1
"
class Solution(object):
    def minDistance(self, houses, k):
        def cost(prefix, i, j):
            return (prefix[j+1]-prefix[(i+j+1)//2])-(prefix[(i+j)//2+1]-prefix[i])

        houses.sort()
        prefix = [0]*(len(houses)+1)
        for i, h in enumerate(houses):
            prefix[i+1] = prefix[i]+h
        dp = [cost(prefix, 0, j) for j in range(len(houses))]
        for m in range(1, k):
            for j in reversed(range(m, len(houses))):
                for i in range(m, j+1):
                    dp[j] = min(dp[j], dp[i-1]+cost(prefix, i, j))
        return dp[-1]
",m * n^2
"
class Solution(object):
    def numberOfMatches(self, n):
        return n-1
",1
"

class Solution(object):
    def maxNumber(self, n):
        return (1<<(n.bit_length()-1))-1
",1
"
class Solution(object):
    def mostWordsFound(self, sentences):
        return 1+max(s.count(' ') for s in sentences)
",n
"
class Solution(object):
    def mergeStones(self, stones, K):
        if (len(stones)-1) % (K-1):
            return -1
        prefix = [0]
        for x in stones:
            prefix.append(prefix[-1]+x)
        dp = [[0]*len(stones) for _ in range(len(stones))]
        for l in range(K-1, len(stones)):
            for i in range(len(stones)-l):
                dp[i][i+l] = min(dp[i][j]+dp[j+1][i+l] for j in range(i, i+l, K-1))
                if l % (K-1) == 0:
                    dp[i][i+l] += prefix[i+l+1] - prefix[i]
        return dp[0][len(stones)-1]
",n^3 / k
"
class Solution(object):
    def circularPermutation(self, n, start):
        return [start ^ (i>>1) ^ i for i in range(1<<n)]
",2^n
"

class Solution(object):
    def maxProfit(self, prices, fee):
        cash, hold = 0, -prices[0]
        for i in range(1, len(prices)):
            cash = max(cash, hold+prices[i]-fee)
            hold = max(hold, cash-prices[i])
        return cash

",n
"
class Solution(object):
    def decrypt(self, code, k):
        result = [0]*len(code)
        if k == 0:
            return result
        left, right = 1, k
        if k < 0:
            k = -k
            left, right = len(code)-k, len(code)-1
        total = sum(code[i] for i in range(left, right+1))
        for i in range(len(code)):
            result[i] = total
            total -= code[left%len(code)]
            total += code[(right+1)%len(code)]
            left += 1
            right += 1
        return result
",n
"
import collections



class Solution(object):
    def matchReplacement(self, s, sub, mappings):
        def transform(x):
            return ord(x)-ord('0') if x.isdigit() else ord(x)-ord('a')+10 if x.islower() else ord(x)-ord('A')+36

        def check(i):
            return all(sub[j] == s[i+j] or lookup[sub[j]][s[i+j]] for j in range(len(sub)))
            
        lookup = [[0]*62 for _ in range(62)]
        for a, b in mappings:
            lookup[transform(a)][transform(b)] = 1
        s = list(map(transform, s))
        sub = list(map(transform, sub))
        return any(check(i) for i in range(len(s)-len(sub)+1))


",n * k
"import collections



class Solution2(object):
    def matchReplacement(self, s, sub, mappings):
        def check(i):
            return all(sub[j] == s[i+j] or (sub[j], s[i+j]) in lookup for j in range(len(sub)))
            
        lookup = set()
        for a, b in mappings:
            lookup.add((a, b))
        return any(check(i) for i in range(len(s)-len(sub)+1))
",n * k
"

class Solution(object):
    def loudAndRich(self, richer, quiet):
        def dfs(graph, quiet, node, result):
            if result[node] is None:
                result[node] = node
                for nei in graph[node]:
                    smallest_person = dfs(graph, quiet, nei, result)
                    if quiet[smallest_person] < quiet[result[node]]:
                        result[node] = smallest_person
            return result[node]

        graph = [[] for _ in range(len(quiet))]
        for u, v in richer:
            graph[v].append(u)
        result = [None]*len(quiet)
        return [dfs(graph, quiet, x, result) for x in range(len(quiet))]

",q + r
"
class Solution(object):
    def maxValue(self, n, x):
        check = (lambda i: str(x) > n[i]) if n[0] != '-' else (lambda i: str(x) < n[i])
        for i in range(len(n)):
            if check(i):
                break
        else:
            i = len(n)
        return n[:i] + str(x) + n[i:]
",n
"

class Solution(object):
    def removeOnes(self, grid):
        rows = [0]*len(grid)
        mask, bit = 0, 1
        for _ in range(len(grid[0])):
            mask += bit
            bit <<= 1
        for i in range(len(grid)):
            rows[i] = mask
            mask <<= len(grid[0])

        cols = [0]*len(grid[0])
        mask, bit = 0, 1
        for _ in range(len(grid)):
            mask += bit
            bit <<= len(grid[0])
        for j in range(len(grid[0])):
            cols[j] = mask
            mask <<= 1

        full_mask = (1<<(len(grid)*len(grid[0])))-1
        masks = [[full_mask for _ in range(len(grid[0]))] for _ in range(len(grid))]
        target, bit = 0, 1
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                target += bit*grid[i][j]
                masks[i][j] -= (rows[i]+cols[j]-bit)
                bit <<= 1

        dp = [float(""inf"") for _ in range(target+1)]
        dp[0] = 0
        for mask in range(1, target+1):
            for i in range(len(grid)):
                for j in range(len(grid[0])):
                    if grid[i][j]:
                        dp[mask] = min(dp[mask], dp[mask&masks[i][j]]+1)
        return dp[target]
",m * n * 2^(m * n)
"

class Solution(object):
    def minimumCost(self, s):
        return sum(min(i+1, len(s)-(i+1)) for i in range(len(s)-1) if s[i] != s[i+1])
",n
"
class Solution(object):
    def reformatDate(self, date):
        lookup = {""Jan"":1, ""Feb"":2, ""Mar"":3, ""Apr"":4,
                  ""May"":5, ""Jun"":6, ""Jul"":7, ""Aug"":8,
                  ""Sep"":9, ""Oct"":10, ""Nov"":11, ""Dec"":12}
        return ""{:04d}-{:02d}-{:02d}"".format(int(date[-4:]), lookup[date[-8:-5]], int(date[:date.index(' ')-2]))
",n
"
class Solution(object):
    def isSumEqual(self, firstWord, secondWord, targetWord):
        def stoi(s):
            result = 0
            for c in s:
                result = result*10 + ord(c)-ord('a')
            return result
        
        return stoi(firstWord) + stoi(secondWord) == stoi(targetWord)
",n
"

class Solution(object):
    def partitionArray(self, nums, k):
        nums.sort()
        result, prev = 1, 0
        for i in range(len(nums)):
            if nums[i]-nums[prev] <= k:
                continue
            prev = i
            result += 1
        return result
",nlogn
"
class Solution(object):
    def gardenNoAdj(self, N, paths):
        result = [0]*N
        G = [[] for i in range(N)]
        for x, y in paths:
            G[x-1].append(y-1)
            G[y-1].append(x-1)
        for i in range(N):
            result[i] = ({1, 2, 3, 4} - {result[j] for j in G[i]}).pop()
        return result
",n
"

class Solution(object):
    def distinctIntegers(self, n):
        return n-1 if n >= 2 else 1
",1
"
class Solution(object):
    def minFlips(self, target):
        result, curr = 0, '0'
        for c in target:
            if c == curr:
                continue
            curr = c
            result += 1
        return result
",n
"
class Solution(object):
    def similarRGB(self, color):
        def rounding(color):
            q, r = divmod(int(color, 16), 17)
            if r > 8: q += 1
            return '{:02x}'.format(17*q)

        return 
                rounding(color[1:3]) + \
                rounding(color[3:5]) + \
                rounding(color[5:7])

",1
"
import itertools


class Solution(object):
    def canConvertString(self, s, t, k):
        if len(s) != len(t):
            return False
        cnt = [0]*26
        for a, b in zip(s, t):
            diff = (ord(b)-ord(a)) % len(cnt)
            if diff != 0 and cnt[diff]*len(cnt) + diff > k:
                return False
            cnt[diff] += 1
        return True
",n
"
class Solution(object):
    def removeDuplicates(self, S):
        result = []
        for c in S:
            if result and result[-1] == c:
                result.pop()
            else:
                result.append(c)
        return """".join(result)
",n
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))
class Solution(object):
    def reverseBetween(self, head, m, n):
        diff, dummy, cur = n - m + 1, ListNode(-1), head
        dummy.next = head

        last_unswapped = dummy
        while cur and m > 1:
            cur, last_unswapped, m = cur.__next__, cur, m - 1

        prev, first_swapped = last_unswapped,  cur
        while cur and diff > 0:
            cur.next, prev, cur, diff = prev, cur, cur.next, diff - 1

        last_unswapped.next, first_swapped.next = prev, cur

        return dummy.__next__

",n
"
class Solution(object):
    def numberOfWeeks(self, milestones):
        total, max_num = sum(milestones), max(milestones)
        other_total = (total-max_num)
        return other_total+min(other_total+1, max_num)
",n
"

class Solution(object):
    def validSequence(self, word1, word2):
        j = len(word2)-1
        lookup = [-1]*len(word2)
        for i in reversed(range(len(word1))):
            if word1[i] != word2[j]:
                continue
            lookup[j] = i
            j -= 1
            if j == -1:
                break
        result = []
        cnt = 0
        for i in range(len(word1)):
            if not (word1[i] == word2[len(result)] or
                    (cnt == 0 and (len(result)+1 == len(word2) or i < lookup[len(result)+1]))):
                continue
            if word1[i] != word2[len(result)]:
                cnt += 1
            result.append(i)
            if len(result) == len(word2):
                return result
        return []
",n + m
"
class Solution(object):
    def uniqueMorseRepresentations(self, words):
        MORSE = ["".-"", ""-..."", ""-.-."", ""-.."", ""."", ""..-."", ""--."",
                 ""...."", "".."", "".---"", ""-.-"", "".-.."", ""--"", ""-."",
                 ""---"", "".--."", ""--.-"", "".-."", ""..."", ""-"", ""..-"",
                 ""...-"", "".--"", ""-..-"", ""-.--"", ""--..""]

        lookup = {"""".join(MORSE[ord(c) - ord('a')] for c in word) \
                  for word in words}
        return len(lookup)

",n
"
class Solution(object):
    def validateBinaryTreeNodes(self, n, leftChild, rightChild):
        roots = set(range(n)) - set(leftChild) - set(rightChild)
        if len(roots) != 1:
            return False
        root, = roots
        stk = [root]
        lookup = set([root])
        while stk:
            node = stk.pop()
            for c in (leftChild[node], rightChild[node]):
                if c < 0:
                    continue
                if c in lookup:
                    return False
                lookup.add(c)
                stk.append(c)
        return len(lookup) == n
",n
"

class Solution(object):
    def maxHappyGroups(self, batchSize, groups):
        def memoization(batchSize, count, mask, remain, lookup):
            if lookup[mask] == 0:
                a_remain = 0
                if remain in count:
                    curr, basis = mask, 1
                    for i, c in count.items():
                        if i == remain:
                            break
                        basis *= c+1
                        curr //= c+1
                    a_remain = curr%(count[remain]+1)
                result = 0
                if a_remain:
                    result = max(result, int(remain == 0) + memoization(batchSize, count, mask-basis, 0, lookup))
                else:
                    curr, basis = mask, 1
                    for i, c in count.items():
                        if curr%(c+1):
                            result = max(result, int(remain == 0) + memoization(batchSize, count, mask-basis, (remain-i)%batchSize, lookup))
                        basis *= c+1
                        curr //= c+1
                lookup[mask] = result
            return lookup[mask]
    
        count = [0]*batchSize
        for i in groups:
            count[i%len(count)] += 1
        result = count[0]
        count[0] = 0
        for i in range(1, len(count)//2+1): 
            pair_count = min(count[i], count[len(count)-i]) if 2*i != len(count) else count[i]//2
            result += pair_count
            count[i] -= pair_count
            count[len(count)-i] -= pair_count
        new_count = {i:c for i, c in enumerate(count) if c}
        max_mask = reduce(lambda total, c: total*(c+1), iter(new_count.values()), 1)
        lookup = [0]*max_mask
        return result+memoization(batchSize, new_count, max_mask-1, 0, lookup)


",(b/2) * (n/(b/2)+1)^(b/2)
"
class Solution2(object):
    def maxHappyGroups(self, batchSize, groups):
        count = [0]*batchSize
        for i in groups:
            count[i%len(count)] += 1
        result = count[0]
        count[0] = 0
        for i in range(1, len(count)//2+1): 
            pair_count = min(count[i], count[len(count)-i]) if 2*i != len(count) else count[i]//2
            result += pair_count
            count[i] -= pair_count
            count[len(count)-i] -= pair_count
        new_count = {i:c for i, c in enumerate(count) if c}
        max_mask = reduce(lambda total, c: total*(c+1), iter(new_count.values()), 1)
        dp = [0]*max_mask
        for mask in range(len(dp)):
            remain = 0
            curr, basis = mask, 1
            for i, c in new_count.items():
                ai = curr%(c+1)
                if ai:
                    dp[mask] = max(dp[mask], dp[mask-basis])
                remain = (remain+ai*i)%batchSize
                basis *= c+1
                curr //= c+1
            if mask != len(dp)-1 and remain == 0:
                dp[mask] += 1
        return result+dp[-1]
",(b/2) * (n/(b/2)+1)^(b/2)
"
class Solution(object):
    def uniquePathsWithObstacles(self, obstacleGrid):
        m, n = len(obstacleGrid), len(obstacleGrid[0])

        ways = [0]*n
        ways[0] = 1
        for i in range(m):
            if obstacleGrid[i][0] == 1:
                ways[0] = 0
            for j in range(n):
                if obstacleGrid[i][j] == 1:
                    ways[j] = 0
                elif j>0:
                    ways[j] += ways[j-1]
        return ways[-1]

",m * n
"
class Solution(object):
    def maximumUniqueSubarray(self, nums):
        lookup = {}
        prefix = [0]*(len(nums)+1)
        result, left = 0, 0
        for right, num in enumerate(nums):
            prefix[right+1] = prefix[right]+num
            if num in lookup:
                left = max(left, lookup[num]+1)
            lookup[num] = right
            result = max(result, prefix[right+1]-prefix[left])
        return result
",n
"

class Solution(object):
    def commonFactors(self, a, b):
        def gcd(a, b): 
            while b:
                a, b = b, a%b
            return a
        
        g = gcd(a, b)
        result = 0
        x = 1
        while x*x <= g:
            if g%x == 0:
                result += 1 if g//x == x else 2
            x += 1
        return result
","log(min(a, b)) + sqrt(gcd)"
"
import collections



class Solution(object):
    def distance(self, nums):
        result = [0]*len(nums)
        cnt1, left = collections.Counter(), collections.Counter()
        for i in range(len(nums)):
            result[i] += cnt1[nums[i]]*i-left[nums[i]]
            cnt1[nums[i]] += 1
            left[nums[i]] += i
        cnt2, right = collections.Counter(), collections.Counter()
        for i in reversed(range(len(nums))):
            result[i] += right[nums[i]]-cnt2[nums[i]]*i
            cnt2[nums[i]] += 1
            right[nums[i]] += i
        return result
",n
"

class Solution(object):
    def minOperations(self, nums):
        return sum(nums[i] != nums[i+1] for i in range(len(nums)-1))
",n
"
class Solution(object):
    def lengthLongestPath(self, input):
        def split_iter(s, tok):
            start = 0
            for i in range(len(s)):
                if s[i] == tok:
                    yield s[start:i]
                    start = i + 1
            yield s[start:]


        max_len = 0
        path_len = {0: 0}
        for line in split_iter(input, '\n'):
            name = line.lstrip('\t')
            depth = len(line) - len(name)
            if '.' in name:
                max_len = max(max_len, path_len[depth] + len(name))
            else:
                path_len[depth + 1] = path_len[depth] + len(name) + 1
        return max_len

",n
"
class Solution(object):
    def spellchecker(self, wordlist, queries):
        vowels = set(['a', 'e', 'i', 'o', 'u'])
        def todev(word):
            return """".join('*' if c.lower() in vowels else c.lower()
                           for c in word)

        words = set(wordlist)
        caps = {}
        vows = {}

        for word in wordlist:
            caps.setdefault(word.lower(), word)
            vows.setdefault(todev(word), word)

        def check(query):
            if query in words:
                return query
            lower = query.lower()
            if lower in caps:
                return caps[lower]
            devow = todev(lower)
            if devow in vows:
                return vows[devow]
            return """"
        return list(map(check, queries))
",n
"

class Solution(object):
    def isCircularSentence(self, sentence):
        return sentence[0] == sentence[-1] and all(sentence[i-1] == sentence[i+1]for i in range(len(sentence)) if sentence[i] == ' ')
",n
"
class Solution(object):
    def removeComments(self, source):
        in_block = False
        result, newline = [], []
        for line in source:
            i = 0
            while i < len(line):
                if not in_block and i+1 < len(line) and line[i:i+2] == '/*':
                    in_block = True
                    i += 1
                elif in_block and i+1 < len(line) and line[i:i+2] == '*/':
                    in_block = False
                    i += 1
                elif not in_block and i+1 < len(line) and line[i:i+2] == '//':
                    break
                elif not in_block:
                    newline.append(line[i])
                i += 1
            if newline and not in_block:
                result.append("""".join(newline))
                newline = []
        return result

",n
"

class Solution(object):
    def minimumOperations(self, grid):
        result = 0
        for i in range(len(grid)-1):
            for j in range(len(grid[0])):
                if grid[i][j]+1 <= grid[i+1][j]:
                    continue
                result += (grid[i][j]+1)-grid[i+1][j]
                grid[i+1][j] = grid[i][j]+1
        return result
",m * n
"


def strongly_connected_components(adj): 
    def strongconnect(v):
        index[v] = index_counter[0]
        lowlinks[v] = index_counter[0]
        index_counter[0] += 1
        stack_set[v] = True
        stack.append(v)
        for w in adj[v]:
            if index[w] == -1:
                strongconnect(w)
                lowlinks[v] = min(lowlinks[v], lowlinks[w])
            elif stack_set[w]:
                lowlinks[v] = min(lowlinks[v], index[w])
        if lowlinks[v] == index[v]:
            connected_component = []
            w = None
            while w != v:
                w = stack.pop()
                stack_set[w] = False
                connected_component.append(w)
            result.append(connected_component)

    index_counter, index, lowlinks = [0], [-1]*len(adj), [-1]*len(adj)
    stack, stack_set = [], [False]*len(adj)
    result = []
    for v in range(len(adj)):
        if index[v] == -1:
            strongconnect(v)
    return result


class Solution(object):
    def minRunesToAdd(self, n, crystals, flowFrom, flowTo):
        adj = [[] for _ in range(n)]
        for i in range(len(flowFrom)):
            adj[flowFrom[i]].append(flowTo[i])
        lookup = [-1]*n
        sccs = strongly_connected_components(adj)
        for i, scc in enumerate(sccs):
            for x in scc:
                lookup[x] = i
        result = [False]*len(sccs)
        for u in range(n):
            for v in adj[u]:
                if lookup[v] != lookup[u]:
                    result[lookup[v]] = True
        for x in crystals:
            result[lookup[x]] = True
        return sum(not x for x in result)
",n
"
import random


class Solution(object):

    def __init__(self, nums):
        self.__nums = nums


    def reset(self):
        return self.__nums


    def shuffle(self):
        nums = list(self.__nums)
        for i in range(len(nums)):
            j = random.randint(i, len(nums)-1)
            nums[i], nums[j] = nums[j], nums[i]
        return nums



",n
"

class Solution(object):
    def maxPotholes(self, road, budget):
        def inplace_counting_sort(nums, reverse=False): 
            if not nums:
                return
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()
    
        ls = []
        l = 0
        for i in range(len(road)):
            l += 1
            if i+1 == len(road) or road[i+1] != road[i]:
                if road[i] == 'x':
                    ls.append(l)
                l = 0
        inplace_counting_sort(ls)
        result = 0
        for l in reversed(ls):
            c = min(l+1, budget)
            if c-1 <= 0:
                break
            result += c-1
            budget -= c
        return result


",n
"
class Solution2(object):
    def maxPotholes(self, road, budget):
        ls = []
        l = 0
        for i in range(len(road)):
            l += 1
            if i+1 == len(road) or road[i+1] != road[i]:
                if road[i] == 'x':
                    ls.append(l)
                l = 0
        ls.sort()
        result = 0
        for l in reversed(ls):
            c = min(l+1, budget)
            if c-1 <= 0:
                break
            result += c-1
            budget -= c
        return result
",nlogn
"
import heapq
import itertools



class Solution(object):
    def slidingPuzzle(self, board):
        def dot(p1, p2):
            return p1[0]*p2[0]+p1[1]*p2[1]

        def heuristic_estimate(board, R, C, expected):
            result = 0
            for i in range(R):
                for j in range(C):
                    val = board[C*i + j]
                    if val == 0: continue
                    r, c = expected[val]
                    result += abs(r-i) + abs(c-j)
            return result

        R, C = len(board), len(board[0])
        begin = tuple(itertools.chain(*board))
        end = tuple(list(range(1, R*C)) + [0])
        expected = {(C*i+j+1) % (R*C) : (i, j)
                    for i in range(R) for j in range(C)}

        min_steps = heuristic_estimate(begin, R, C, expected)
        closer, detour = [(begin.index(0), begin)], []
        lookup = set()
        while True:
            if not closer:
                if not detour:
                    return -1
                min_steps += 2
                closer, detour = detour, closer
            zero, board = closer.pop()
            if board == end:
                return min_steps
            if board not in lookup:
                lookup.add(board)
                r, c = divmod(zero, C)
                for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):
                    i, j = r+direction[0], c+direction[1]
                    if 0 <= i < R and 0 <= j < C:
                        new_zero = i*C+j
                        tmp = list(board)
                        tmp[zero], tmp[new_zero] = tmp[new_zero], tmp[zero]
                        new_board = tuple(tmp)
                        r2, c2 = expected[board[new_zero]]
                        r1, c1 = divmod(zero, C)
                        r0, c0 = divmod(new_zero, C)
                        is_closer = dot((r1-r0, c1-c0), (r2-r0, c2-c0)) > 0
                        (closer if is_closer else detour).append((new_zero, new_board))
        return min_steps


",(m * n) * (m * n)!
"
class Solution2(object):
    def slidingPuzzle(self, board):
        def heuristic_estimate(board, R, C, expected):
            result = 0
            for i in range(R):
                for j in range(C):
                    val = board[C*i + j]
                    if val == 0: continue
                    r, c = expected[val]
                    result += abs(r-i) + abs(c-j)
            return result

        R, C = len(board), len(board[0])
        begin = tuple(itertools.chain(*board))
        end = tuple(list(range(1, R*C)) + [0])
        end_wrong = tuple(list(range(1, R*C-2)) + [R*C-1, R*C-2, 0])
        expected = {(C*i+j+1) % (R*C) : (i, j)
                    for i in range(R) for j in range(C)}

        min_heap = [(0, 0, begin.index(0), begin)]
        lookup = {begin: 0}
        while min_heap:
            f, g, zero, board = heapq.heappop(min_heap)
            if board == end: return g
            if board == end_wrong: return -1
            if f > lookup[board]: continue

            r, c = divmod(zero, C)
            for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):
                i, j = r+direction[0], c+direction[1]
                if 0 <= i < R and 0 <= j < C:
                    new_zero = C*i+j
                    tmp = list(board)
                    tmp[zero], tmp[new_zero] = tmp[new_zero], tmp[zero]
                    new_board = tuple(tmp)
                    f = g+1+heuristic_estimate(new_board, R, C, expected)
                    if f < lookup.get(new_board, float(""inf"")):
                        lookup[new_board] = f
                        heapq.heappush(min_heap, (f, g+1, new_zero, new_board))
        return -1

",(m * n) * (m * n)! * log((m * n)!)
"
import collections
import functools



class Node(object):
    def __init__(self, val="" "", left=None, right=None):
        pass



class Solution(object):
    def checkEquivalence(self, root1, root2):
        def add_counter(counter, prev, d, val):
            if val.isalpha():
                counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d
            prev[0] = val
    
        def morris_inorder_traversal(root, cb):
            curr = root
            while curr:
                if curr.left is None:
                    cb(curr.val)
                    curr = curr.right
                else:
                    node = curr.left
                    while node.right and node.right != curr:
                        node = node.right
                    if node.right is None:
                        node.right = curr
                        curr = curr.left
                    else:
                        cb(curr.val)
                        node.right = None
                        curr = curr.right

        counter = collections.defaultdict(int)
        morris_inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1))
        morris_inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1))
        return all(v == 0 for v in counter.values())


",n
"import collections
import functools


class Solution2(object):
    def checkEquivalence(self, root1, root2):
        def add_counter(counter, prev, d, val):
            if val.isalpha():
                counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d
            prev[0] = val

        def inorder_traversal(root, cb):
            def traverseLeft(node, stk):
                while node:
                    stk.append(node)
                    node = node.left 

            stk = []
            traverseLeft(root, stk)
            while stk:
                curr = stk.pop()
                cb(curr.val)
                traverseLeft(curr.right, stk)
                
        counter = collections.defaultdict(int)
        inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1))
        inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1))
        return all(v == 0 for v in counter.values())
",n
"

class Solution(object):
    def minimumIncrements(self, nums, target):
        INF = float(""inf"")
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def lcm(a, b):
            return a//gcd(a, b)*b

        n = len(nums)
        m = len(target)
        lcms = [0]*(1<<m)
        for mask in range(1<<m):
            l = 1
            for i in range(m):
                if mask&(1<<i):
                    l = lcm(l, target[i])
            lcms[mask] = l
        dp = [INF]*(1<<m)
        dp[0] = 0
        for x in nums:
            for mask in reversed(range(1<<m)):
                if dp[mask] == INF:
                    continue
                submask = new_mask = (((1<<m)-1)-mask)
                while submask:
                    dp[mask|submask] = min(dp[mask|submask], dp[mask]+(lcms[submask]-x%lcms[submask] if x%lcms[submask] else 0))
                    submask = (submask-1)&new_mask
        return dp[-1]
",logr * m * 2^m + n * 3^m
"

class Solution(object):
    def isIsomorphic(self, s, t):
        if len(s) != len(t):
            return False

        s2t, t2s = {}, {}
        for p, w in zip(s, t):
            if w not in s2t and p not in t2s:
                s2t[w] = p
                t2s[p] = w
            elif w not in s2t or s2t[w] != p:
                return False
        return True


",n
"class Solution2(object):
    def isIsomorphic(self, s, t):
        if len(s) != len(t):
            return False

        return self.halfIsom(s, t) and self.halfIsom(t, s)

    def halfIsom(self, s, t):
        lookup = {}
        for i in range(len(s)):
            if s[i] not in lookup:
                lookup[s[i]] = t[i]
            elif lookup[s[i]] != t[i]:
                return False
        return True

",n
"

class Solution(object):
    def numFactoredBinaryTrees(self, A):
        M = 10**9 + 7
        A.sort()
        dp = {}
        for i in range(len(A)):
            dp[A[i]] = 1
            for j in range(i):
                if A[i] % A[j] == 0 and A[i] // A[j] in dp:
                    dp[A[i]] += dp[A[j]] * dp[A[i] // A[j]]
                    dp[A[i]] %= M
        return sum(dp.values()) % M

",n^2
"

class Solution(object):
    def permute(self, n):
        def backtracking(lookup):
            if len(curr) == n:
                result.append(curr[:])
                return
            for i in range(1, n+1):
                if lookup&(1<<(i-1)) or (curr and curr[-1]%2 == i%2):
                    continue
                curr.append(i)
                backtracking(lookup^(1<<(i-1)))
                curr.pop()
    
        result, curr = [], []
        backtracking(0)
        return result
",n * n!
"

class Solution(object):
    def shortestSubstrings(self, arr):
        class Trie(object):
            def __init__(self):
                self.__nodes = []
                self.__cnts = []
                self.__new_node()
            
            def __new_node(self):
                self.__nodes.append([-1]*26)
                self.__cnts.append(0)
                return len(self.__nodes)-1

            def add(self, s, d):
                for i in range(len(s)):
                    curr = 0
                    for j in range(i, len(s)):
                        x = ord(s[j])-ord('a')
                        if self.__nodes[curr][x] == -1:
                            self.__nodes[curr][x] = self.__new_node()
                        curr = self.__nodes[curr][x]
                        self.__cnts[curr] += d
    
            def query(self, s):
                result = (float(""inf""), """")
                for i in range(len(s)):
                    curr = 0
                    for j in range(i, len(s)):
                        curr = self.__nodes[curr][ord(s[j])-ord('a')]
                        if self.__cnts[curr] == 0:
                            result = min(result, (j-i+1, s[i:j+1]))
                            break
                return result[1]
    
        trie = Trie()
        for x in arr:
            trie.add(x, +1)
        result = []
        for x in arr:
            trie.add(x, -1)
            result.append(trie.query(x))
            trie.add(x, +1)
        return result
",n * l^2
"
class Solution(object):
    def countSubstrings(self, s, t):
        def count(i, j): 
            result = left_cnt = right_cnt = 0 
            for k in range(min(len(s)-i, len(t)-j)):
                right_cnt += 1
                if s[i+k] != t[j+k]:
                    left_cnt, right_cnt = right_cnt, 0
                result += left_cnt 
            return result

        return sum(count(i, 0) for i in range(len(s))) + \
               sum(count(0, j) for j in range(1, len(t)))
",m * n
"
class Solution(object):
    def isPalindrome(self, head):
        reverse, fast = None, head
        while fast and fast.__next__:
            fast = fast.next.__next__
            head.next, reverse, head = reverse, head, head.next

        tail = head.__next__ if fast else head

        is_palindrome = True
        while reverse:
            is_palindrome = is_palindrome and reverse.val == tail.val
            reverse.next, head, reverse = head, reverse, reverse.next
            tail = tail.__next__

        return is_palindrome

",n
"
class Solution(object):
    def containsNearbyDuplicate(self, nums, k):
        lookup = {}
        for i, num in enumerate(nums):
            if num not in lookup:
                lookup[num] = i
            else:
                if i - lookup[num] <= k:
                    return True
                lookup[num] = i
        return False

",n
"

class Solution(object):
    def maxGoodNumber(self, nums):
        return int("""".join(sorted([bin(x)[2:] for x in nums], cmp=lambda x, y: (x+y > y+x)-(x+y < y+x), reverse=True)), 2)


",n * logr * logn
"import itertools



class Solution2(object):
    def maxGoodNumber(self, nums):
        return max(int("""".join(x), 2) for x in itertools.permutations([bin(x)[2:] for x in nums]))
",n! * nlogr
"
class Solution(object):
    def minFallingPathSum(self, A):
        for i in range(1, len(A)):
            for j in range(len(A[i])):
                A[i][j] += min(A[i-1][max(j-1, 0):j+2])
        return min(A[-1])
",n^2
"
from sortedcontainers import SortedList



class Solution(object):
    def maximumTripletValue(self, nums):
        left = SortedList()
        right = [0]*len(nums)
        for i in reversed(range(1, len(nums)-1)):
            right[i] = max(right[i+1], nums[i+1])
        result = 0
        for i in range(1, len(nums)-1):
            left.add(nums[i-1])
            j = left.bisect_left(nums[i])
            if j-1 >= 0 and right[i] > nums[i]:
                result = max(result, left[j-1]-nums[i]+right[i])
        return result


",nlogn
"from sortedcontainers import SortedList



class Solution2(object):
    def maximumTripletValue(self, nums):
        left = SortedList()
        right = SortedList(nums[i] for i in range(1, len(nums)))
        result = 0
        for i in range(1, len(nums)-1):
            left.add(nums[i-1])
            right.remove(nums[i])
            j = left.bisect_left(nums[i])
            if j-1 >= 0 and right[-1] > nums[i]:
                result = max(result, left[j-1]-nums[i]+right[-1])
        return result
",nlogn
"
class Solution(object):
    def numRescueBoats(self, people, limit):
        people.sort()
        result = 0
        left, right = 0, len(people)-1
        while left <= right:
            result += 1
            if people[left] + people[right] <= limit:
                left += 1
            right -= 1
        return result

",nlogn
"

class Solution(object):
    def minOperations(self, s1, s2, x):
        parity = curr = prev = 0
        j = -1
        for i in range(len(s1)):
            if s1[i] == s2[i]:
                continue
            curr, prev = min(curr+x, prev+(i-j)*2 if j != -1 else float(""inf"")), curr
            j = i
            parity ^= 1
        return curr//2 if parity == 0 else -1
",n
"
class Solution(object):
    def arraySign(self, nums):
        flag = 0
        for x in nums:
            if not x:
                return 0
            if x < 0:
                flag ^= 1
        return -1 if flag else 1
",n
"
class Solution(object):
    def rob(self, nums):
        last, now = 0, 0
        for i in nums:
            last, now = now, max(last + i, now)
        return now


",n
"
class Solution(object):
    def minimizedMaximum(self, n, quantities):
        def ceil_divide(a, b):
            return (a+(b-1))//b

        def check(n, quantities, x):
            return sum(ceil_divide(q, x) for q in quantities) <= n
         
        left, right = 1, max(quantities)
        while left <= right:
            mid = left+(right-left)//2
            if check(n, quantities, mid):
                right = mid-1
            else:
                left = mid+1
        return left
",nlogm
"
import itertools



class Solution(object):
    def makeSimilar(self, nums, target):
        nums.sort(key=lambda x: (x%2, x))
        target.sort(key=lambda x: (x%2, x))
        return sum(abs(x-y)//2 for x, y in zip(nums, target))//2
",nlogn
"
import collections


class Topo(object):
    def __init__(self):
        self.__nodes = set()
        self.__in_degree = collections.defaultdict(set)
        self.__out_degree = collections.defaultdict(set)
        
    def add_node(self, node):
        self.__nodes.add(node)
    
    def add_edge(self, src, dst):
        self.add_node(src), self.add_node(dst)
        self.__in_degree[dst].add(src)
        self.__out_degree[src].add(dst)
    
    def sort(self):
        q = collections.deque()
        result = []
        for node in self.__nodes:
            if node not in self.__in_degree:
                q.append(node)
        while q:
            node = q.popleft()
            result.append(node)
            for nei in self.__out_degree[node]:
                self.__in_degree[nei].remove(node)
                if not self.__in_degree[nei]:
                    self.__in_degree.pop(nei)
                    q.append(nei)
        if len(result) < len(self.__nodes):
            return
        return result


class Solution(object):
    def sortItems(self, n, m, group, beforeItems):
        for i in range(n):
            if group[i] == -1:
                group[i] = m
                m += 1    
        global_group = Topo()
        for i in range(m):
            global_group.add_node(i)
        local_groups = collections.defaultdict(Topo)
        for i in range(n):
            local_groups[group[i]].add_node(i)
        for i in range(n):
            for j in beforeItems[i]:
                if group[i] == group[j]:
                    local_groups[group[i]].add_edge(j, i)
                else:
                    global_group.add_edge(group[j], group[i])
        result = []
        global_order = global_group.sort()
        if global_order is None:
            return []
        for i in global_order:
            local_order = local_groups[i].sort()
            if local_order is None:
                return []
            for x in local_order:
                result.append(x)
        return result
",n + e
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def sumNumbers(self, root):
        return self.sumNumbersRecu(root, 0)

    def sumNumbersRecu(self, root, num):
        if root is None:
            return 0

        if root.left is None and root.right is None:
            return num * 10 + root.val

        return self.sumNumbersRecu(root.left, num * 10 + root.val) + self.sumNumbersRecu(root.right, num * 10 + root.val)

",n
"
class Solution(object):
    def deleteAndEarn(self, nums):
        vals = [0] * 10001
        for num in nums:
            vals[num] += num
        val_i, val_i_1 = vals[0], 0
        for i in range(1, len(vals)):
            val_i_1, val_i_2 = val_i, val_i_1
            val_i = max(vals[i] + val_i_2, val_i_1)
        return val_i

",n
"
import itertools



class Solution(object):
    def numberOfSpecialChars(self, word):
        lookup1 = [len(word)]*26
        lookup2 = [-1]*26
        for i, x in enumerate(word):
            if x.islower():
                lookup1[ord(x)-ord('a')] = i
            elif lookup2[ord(x)-ord('A')] == -1:
                lookup2[ord(x)-ord('A')] = i
        return sum(x < y for x, y in zip(lookup1, lookup2))
",n + 26
"
class Solution(object):
    def firstMissingPositive(self, A):
        i = 0
        while i < len(A):
            if A[i] > 0 and A[i] - 1 < len(A) and A[i] != A[A[i]-1]:
                A[A[i]-1], A[i] = A[i], A[A[i]-1]
            else:
                i += 1

        for i, integer in enumerate(A):
            if integer != i + 1:
                return i + 1
        return len(A) + 1

",n
"
class Solution(object):
    def splitArray(self, nums):
        if len(nums) < 7:
            return False

        accumulated_sum = [0] * len(nums)
        accumulated_sum[0] = nums[0]
        for i in range(1, len(nums)):
            accumulated_sum[i] = accumulated_sum[i-1] + nums[i]
        for j in range(3, len(nums)-3):
            lookup = set()
            for i in range(1, j-1):
                if accumulated_sum[i-1] == accumulated_sum[j-1] - accumulated_sum[i]:
                    lookup.add(accumulated_sum[i-1])
            for k in range(j+2, len(nums)-1):
                if accumulated_sum[-1] - accumulated_sum[k] == accumulated_sum[k-1] - accumulated_sum[j] and \
                   accumulated_sum[k - 1] - accumulated_sum[j] in lookup:
                    return True
        return False

",n^2
"


class Solution(object):
    def minimumAddedCoins(self, coins, target):
        coins.sort()
        result = reachable = 0
        for x in coins:
            while not reachable >= x-1:
                result += 1
                reachable += reachable+1
            reachable += x
        while not reachable >= target:
            result += 1
            reachable += reachable+1
        return result


",nlogn + logt
"

class Solution2(object):
    def minimumAddedCoins(self, coins, target):
        coins.sort()
        result = reachable = 0
        for x in coins:
            while not reachable >= x-1:
                result += 1
                reachable += reachable+1
                if reachable >= target:
                    return result
            reachable += x
            if reachable >= target:
                return result
        while not reachable >= target:
            result += 1
            reachable += reachable+1
        return result
",nlogn + logt
"
import collections


class Solution(object):
    def maxDistance(self, grid):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        q = collections.deque([(i, j) for i in range(len(grid))
                                      for j in range(len(grid[0])) if grid[i][j] == 1])    
        if len(q) == len(grid)*len(grid[0]):
            return -1
        level = -1
        while q:
            next_q = collections.deque()
            while q:
                x, y = q.popleft()
                for dx, dy in directions:
                    nx, ny = x+dx, y+dy
                    if not (0 <= nx < len(grid) and 
                            0 <= ny < len(grid[0]) and 
                            grid[nx][ny] == 0):
                        continue
                    next_q.append((nx, ny))
                    grid[nx][ny] = 1
            q = next_q
            level += 1
        return level
",m * n
"
import collections
import heapq


class Solution(object):
    def cutOffTree(self, forest):
        def dot(p1, p2):
            return p1[0]*p2[0]+p1[1]*p2[1]

        def minStep(p1, p2):
            min_steps = abs(p1[0]-p2[0])+abs(p1[1]-p2[1])
            closer, detour = [p1], []
            lookup = set()
            while True:
                if not closer: 
                    if not detour: 
                        return -1
                    min_steps += 2
                    closer, detour = detour, closer
                i, j = closer.pop()
                if (i, j) == p2:
                    return min_steps
                if (i, j) not in lookup:
                    lookup.add((i, j))
                    for I, J in (i+1, j), (i-1, j), (i, j+1), (i, j-1):
                        if 0 <= I < m and 0 <= J < n and forest[I][J] and (I, J) not in lookup:
                            is_closer = dot((I-i, J-j), (p2[0]-i, p2[1]-j)) > 0
                            (closer if is_closer else detour).append((I, J))
            return min_steps

        m, n = len(forest), len(forest[0])
        min_heap = []
        for i in range(m):
            for j in range(n):
                if forest[i][j] > 1:
                    heapq.heappush(min_heap, (forest[i][j], (i, j)))

        start = (0, 0)
        result = 0
        while min_heap:
            tree = heapq.heappop(min_heap)
            step = minStep(start, tree[1])
            if step < 0:
                return -1
            result += step
            start = tree[1]
        return result


",t * (logt + m * n)
"class Solution_TLE(object):
    def cutOffTree(self, forest):
        def minStep(p1, p2):
            min_steps = 0
            lookup = {p1}
            q = collections.deque([p1])
            while q:
                size = len(q)
                for _ in range(size):
                    (i, j) = q.popleft()
                    if (i, j) == p2:
                        return min_steps
                    for i, j in (i+1, j), (i-1, j), (i, j+1), (i, j-1):
                        if not (0 <= i < m and 0 <= j < n and forest[i][j] and (i, j) not in lookup):
                            continue
                        q.append((i, j))
                        lookup.add((i, j))
                min_steps += 1
            return -1

        m, n = len(forest), len(forest[0])
        min_heap = []
        for i in range(m):
            for j in range(n):
                if forest[i][j] > 1:
                    heapq.heappush(min_heap, (forest[i][j], (i, j)))

        start = (0, 0)
        result = 0
        while min_heap:
            tree = heapq.heappop(min_heap)
            step = minStep(start, tree[1])
            if step < 0:
                return -1
            result += step
            start = tree[1]
        return result

",t * (logt + m * n)
"
class Solution(object):
    def checkPerfectNumber(self, num):
        if num <= 0:
            return False

        sqrt_num = int(num ** 0.5)
        total = sum(i+num//i for i in range(1, sqrt_num+1) if num%i == 0)
        if sqrt_num ** 2 == num:
            total -= sqrt_num
        return total - num == num

",sqrt(n)
"
class Solution(object):
    def brokenCalc(self, X, Y):
        result = 0
        while X < Y:
            if Y%2:
                Y += 1
            else:
                Y /= 2
            result += 1
        return result + X-Y
",logn
"

class Solution(object):
    def countSubmatrices(self, grid, k):
        def count(heights):
            result = curr = 0
            stk = []
            for i in range(len(heights)):
                while stk and heights[stk[-1]] >= heights[i]:
                    j = stk.pop()
                    curr -= (heights[j]-heights[i])*(j-(stk[-1] if stk else -1))
                stk.append(i)
                curr += heights[i]
                result += curr
            return result

        result = 0
        heights = [0]*len(grid)
        for j in reversed(list(range(len(grid[0])))):
            for i in range(len(grid)):
                heights[i] = 0 if grid[i][j] > k else heights[i]+1 if j+1 < len(grid[0]) and grid[i][j] >= grid[i][j+1] else 1
            result += count(heights)
        return result


",m * n
"
class Solution2(object):
    def countSubmatrices(self, grid, k):
        def count(heights):
            dp, stk = [0]*len(heights), []
            for i in range(len(heights)):
                while stk and heights[stk[-1]] >= heights[i]:
                    stk.pop()
                dp[i] = dp[stk[-1]] + heights[i]*(i-stk[-1]) if stk else heights[i]*(i-(-1))
                stk.append(i)
            return sum(dp)

        result = 0
        heights = [0]*len(grid)
        for j in reversed(list(range(len(grid[0])))):
            for i in range(len(grid)):
                heights[i] = 0 if grid[i][j] > k else heights[i]+1 if j+1 < len(grid[0]) and grid[i][j] >= grid[i][j+1] else 1
            result += count(heights)
        return result
",m * n
"
class Solution(object):
    def minCost(self, houses, cost, m, n, target):
        dp = [[[float(""inf"") for _ in range(n)] for _ in range(target)] for _ in range(2)]
        for i in range(m):
            dp[i%2] = [[float(""inf"") for _ in range(n)] for _ in range(target)]
            for j in range(min(target, i+1)):
                for k in range(n):
                    if houses[i] and houses[i]-1 != k:
                        continue
                    same = dp[(i-1)%2][j][k] if i-1 >= 0 else 0
                    diff = (min([dp[(i-1)%2][j-1][nk] for nk in range(n) if nk != k] or [float(""inf"")]) if j-1 >= 0 else float(""inf"")) if i-1 >= 0 else 0
                    paint = cost[i][k] if not houses[i] else 0
                    dp[i%2][j][k] = min(same, diff)+paint
        result = min(dp[(m-1)%2][-1])
        return result if result != float(""inf"") else -1


",m * t * n^2
"class Solution2(object):
    def minCost(self, houses, cost, m, n, target):
        dp = {(0, 0): 0}
        for i, p in enumerate(houses):
            new_dp = {}
            for nk in (range(1, n+1) if not p else [p]):
                for j, k in dp:
                    nj = j + (k != nk)
                    if nj > target:
                        continue
                    new_dp[nj, nk] = min(new_dp.get((nj, nk), float(""inf"")), dp[j, k] + (cost[i][nk-1] if nk != p else 0))
            dp = new_dp
        return min([dp[j, k] for j, k in dp if j == target] or [-1])
",m * t * n^2
"
class Solution(object):
    def nearestPalindromic(self, n):
        l = len(n)
        candidates = set((str(10**l + 1), str(10**(l - 1) - 1)))
        prefix = int(n[:(l + 1)/2])
        for i in map(str, (prefix-1, prefix, prefix+1)):
            candidates.add(i + [i, i[:-1]][l%2][::-1])
        candidates.discard(n)
        return min(candidates, key=lambda x: (abs(int(x) - int(n)), int(x)))

",l
"

class Solution(object):
    def maximumValueSum(self, nums, k, edges):
        result = parity = 0
        diff = float(""inf"")
        for x in nums:
            y = x^k
            result += max(x, y)
            parity ^= int(x < y)
            diff = min(diff, abs(x-y))
        return result-parity*diff
",n
"

class Solution(object):
    def findIndices(self, nums, indexDifference, valueDifference):
        mx_i = mn_i = 0
        for i in range(len(nums)-indexDifference):
            if nums[i] > nums[mx_i]:
                mx_i = i
            elif nums[i] < nums[mn_i]:
                mn_i = i
            if nums[mx_i]-nums[i+indexDifference] >= valueDifference:
                return [mx_i, i+indexDifference]
            if nums[i+indexDifference]-nums[mn_i] >= valueDifference:
                return [mn_i, i+indexDifference]
        return [-1]*2
",n
"

class Solution(object):
    def countDigits(self, num):
        result = 0
        curr = num
        while curr:
            result += int(num%(curr%10) == 0)
            curr //= 10
        return result
",logn
"
class Solution(object):
    def numberOfDays(self, Y, M):
        leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0
        return (28+leap if (M == 2) else 31-(M-1)%7%2)
        
",1
"

class Solution(object):
    def isReachableAtTime(self, sx, sy, fx, fy, t):
        diff1, diff2 = abs(sx-fx), abs(sy-fy)
        mn = min(diff1, diff2)+abs(diff1-diff2)
        return t >= mn if mn else t != 1
",1
"

class Solution(object):
    def maximumBeauty(self, nums, k):
        nums.sort()
        left = 0
        for right in range(len(nums)):
            if nums[right]-nums[left] > k*2:
                left += 1
        return right-left+1
",nlogn
"
import collections


class Solution(object):
    def anagramMappings(self, A, B):
        lookup = collections.defaultdict(collections.deque)
        for i, n in enumerate(B):
            lookup[n].append(i)
        result = []
        for n in A:
            result.append(lookup[n].popleft())
        return result

",n
"
import collections


class FontInfo(object):
    def getWidth(self, fontSize, ch):
        pass
    
    def getHeight(self, fontSize):
        pass


class Solution(object):
    def maxFont(self, text, w, h, fonts, fontInfo):
        def check(count, w, h, fonts, fontInfo, x): 
            return (fontInfo.getHeight(fonts[x]) <= h and
                    sum(cnt * fontInfo.getWidth(fonts[x], c) for c, cnt in count.items()) <= w)

        count = collections.Counter(text)
        left, right = 0, len(fonts)-1
        while left <= right:
            mid = left + (right-left)//2
            if not check(count, w, h, fonts, fontInfo, mid):
                right = mid-1
            else:
                left = mid+1
        return fonts[right] if right >= 0 else -1
",n + logm
"

class Solution(object):
    def maximumOr(self, nums, k):
        right = [0]*(len(nums)+1)
        for i in reversed(range(len(nums))):
            right[i] = right[i+1]|nums[i]
        result = left = 0
        for i in range(len(nums)):
            result = max(result, left|(nums[i]<<k)|right[i+1])
            left |= nums[i]
        return result
",n
"
class Solution(object):
    def longestPalindrome(self, s):
        def preProcess(s):
            if not s:
                return ['^', '$']
            T = ['^']
            for c in s:
                T +=  [
            T += [
            return T

        T = preProcess(s)
        P = [0] * len(T)
        center, right = 0, 0
        for i in range(1, len(T) - 1):
            i_mirror = 2 * center - i
            if right > i:
                P[i] = min(right - i, P[i_mirror])
            else:
                P[i] = 0

            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:
                P[i] += 1

            if i + P[i] > right:
                center, right = i, i + P[i]

        max_i = 0
        for i in range(1, len(T) - 1):
            if P[i] > P[max_i]:
                max_i = i
        start = (max_i - 1 - P[max_i]) // 2
        return s[start : start + P[max_i]]


",n
"class Solution2(object):
    def longestPalindrome(self, s):
        def expand(s, left, right):
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1
            return (right-left+1)-2
        
        left, right = -1, -2
        for i in range(len(s)):
            l = max(expand(s, i, i), expand(s, i, i+1))
            if l > right-left+1:
                right = i+l//2
                left = right-l+1
        return s[left:right+1] if left >= 0 else """"
",n^2
"
import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    return students.rename(columns={
        ""id"" : ""student_id"",
        ""first"" : ""first_name"",
        ""last"" : ""last_name"",
        ""age"" : ""age_in_years"",
    })
",n
"
class Solution(object):
    def subtractProductAndSum(self, n):
        product, total = 1, 0
        while n:
            n, r = divmod(n, 10)
            product *= r
            total += r
        return product-total


",logn
"import operator
from functools import reduce


class Solution2(object):
    def subtractProductAndSum(self, n):
        A = list(map(int, str(n)))
        return reduce(operator.mul, A) - sum(A)
",logn
"
class Solution(object):
    def countHighestScoreNodes(self, parents):
        def iter_dfs(adj):
            result = [0]*2
            stk = [(1, (0, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    i, ret = args
                    cnts = [[0] for _ in range(len(adj[i]))]
                    stk.append((2, (cnts, ret)))
                    for j, child in enumerate(adj[i]):
                        stk.append((1, (child, cnts[j])))
                elif step == 2:
                    cnts, ret = args
                    ret[0] = sum(cnt[0] for cnt in cnts)+1
                    score = max((len(adj)-ret[0]), 1)*reduce(lambda x, y: x*y[0], cnts, 1)
                    if score > result[0]:
                        result[:] = [score, 1]
                    elif score == result[0]:
                        result[1] += 1
            return result[1]

        adj = [[] for _ in range(len(parents))] 
        for i in range(1, len(parents)):
            adj[parents[i]].append(i)
        return iter_dfs(adj)


",n
"class Solution2(object):
    def countHighestScoreNodes(self, parents):
        def dfs(adj, i, result):
            cnts = [dfs(adj, child, result) for child in adj[i]]
            total = sum(cnts)+1
            score = max((len(adj)-total), 1)*reduce(lambda x, y: x*y, cnts, 1)
            if score > result[0]:
                result[:] = [score, 1]
            elif score == result[0]:
                result[1] += 1
            return total

        adj = [[] for _ in range(len(parents))] 
        for i in range(1, len(parents)):
            adj[parents[i]].append(i)
        result = [0]*2
        dfs(adj, 0, result)
        return result[1]
",n
"

class Solution(object):
    def minimumAverage(self, nums):
        nums.sort()
        return min((nums[i]+nums[~i])/2.0 for i in range(len(nums)//2))
",nlogn
"
import collections


class Solution(object):
    def replaceWords(self, dictionary, sentence):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for word in dictionary:
            reduce(dict.__getitem__, word, trie).setdefault(""_end"")

        def replace(word):
            curr = trie
            for i, c in enumerate(word):
                if c not in curr:
                    break
                curr = curr[c]
                if ""_end"" in curr:
                    return word[:i+1]
            return word

        return "" "".join(map(replace, sentence.split()))

",n
"
class Solution(object):
    def kConcatenationMaxSum(self, arr, k):
        def max_sub_k_array(arr, k):
            result, curr = float(""-inf""), float(""-inf"")
            for _ in range(k):
                for x in arr:
                    curr = max(curr+x, x)
                    result = max(result, curr)
            return result
        
        MOD = 10**9+7
        if k == 1:
            return max(max_sub_k_array(arr, 1), 0) % MOD
        return (max(max_sub_k_array(arr, 2), 0) + (k-2)*max(sum(arr), 0)) % MOD
",n
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def equalToDescendants(self, root):
        def iter_dfs(node):
            result = 0
            stk = [(1, [node, [0]])]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    if node.val == ret1[0]+ret2[0]:
                        result += 1
                    ret[0] = ret1[0]+ret2[0]+node.val
            return result

        return iter_dfs(root)


",n
"class Solution2(object):
    def equalToDescendants(self, root):
        def dfs(node, result):
            if not node:
                return 0
            total = dfs(node.left, result) + dfs(node.right, result)
            if node.val == total:
                result[0] += 1
            return total+node.val

        result = [0]
        dfs(root, result)
        return result[0]
",n
"
class Solution(object):
    def trimBST(self, root, L, R):
        if not root:
            return None
        if root.val < L:
            return self.trimBST(root.right, L, R)
        if root.val > R:
            return self.trimBST(root.left, L, R)
        root.left, root.right = self.trimBST(root.left, L, R), self.trimBST(root.right, L, R)
        return root


",n
"

class Solution(object):
    def maximumJumps(self, nums, target):
        dp = [-1]*len(nums)
        dp[0] = 0
        for i in range(1, len(nums)):
            for j in range(i):
                if abs(nums[i]-nums[j]) <= target:
                    if dp[j] != -1:
                        dp[i] = max(dp[i], dp[j]+1)
        return dp[-1]
",n^2
"
import collections


class Solution(object):
    def balancedString(self, s):
        count = collections.Counter(s)
        result = len(s) 
        left = 0
        for right in range(len(s)):
            count[s[right]] -= 1
            while left < len(s) and \
                  all(v <= len(s)//4 for v in count.values()):
                result = min(result, right-left+1)
                count[s[left]] += 1
                left += 1
        return result
",n
"

class Solution(object):
    def minimumLength(self, s):
        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        return sum(2-x%2 for x in cnt if x)


",n + 26
"import collections



class Solution2(object):
    def minimumLength(self, s):
        return sum(2-x%2 for x in collections.Counter(s).values())
",n
"
class PolyNode:
    def __init__(self, x=0, y=0, next=None):
        pass


class Solution:
    def addPoly(self, poly1, poly2):
        curr = dummy = PolyNode()
        while poly1 and poly2:
            if poly1.power > poly2.power:
                curr.next = poly1
                curr = curr.__next__
                poly1 = poly1.__next__
            elif poly1.power < poly2.power:
                curr.next = poly2
                curr = curr.__next__
                poly2 = poly2.__next__
            else:
                coef = poly1.coefficient+poly2.coefficient
                if coef:
                    curr.next = PolyNode(coef, poly1.power)
                    curr = curr.__next__
                poly1, poly2 = poly1.__next__, poly2.__next__
        curr.next = poly1 or poly2
        return dummy.__next__
",m + n
"
class Solution(object):
    def findMaxForm(self, strs, m, n):
        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
        for s in strs:
            zero_count, one_count = 0, 0
            for c in s:
                if c == '0':
                    zero_count += 1
                elif c == '1':
                    one_count += 1

            for i in reversed(range(zero_count, m+1)):
            	for j in reversed(range(one_count, n+1)):
                    dp[i][j] = max(dp[i][j], dp[i-zero_count][j-one_count]+1)
        return dp[m][n]

",s * m * n
"
import collections



class Solution(object):
    def beautifulSubarrays(self, nums):
        cnt = collections.Counter()
        cnt[0] = 1
        result = curr = 0
        for x in nums:
            curr ^= x
            result += cnt[curr]
            cnt[curr] += 1
        return result
",n
"
class Solution(object):
    def minSumOfLengths(self, arr, target):
        prefix, dp = {0: -1}, [0]*len(arr) 
        result = min_len = float(""inf"")
        accu = 0
        for right in range(len(arr)):
            accu += arr[right]
            prefix[accu] = right
            if accu-target in prefix:
                left = prefix[accu-target]
                min_len = min(min_len, right-left)
                if left != -1:
                    result = min(result, dp[left] + (right-left))
            dp[right] = min_len
        return result if result != float(""inf"") else -1
",n
"
import itertools


class Solution(object):
    def backspaceCompare(self, S, T):
        def findNextChar(S):
            skip = 0
            for i in reversed(range(len(S))):
                if S[i] == 
                    skip += 1
                elif skip:
                    skip -= 1
                else:
                    yield S[i]

        return all(x == y for x, y in
                   itertools.zip_longest(findNextChar(S), findNextChar(T)))

",m + n
"
class Solution(object):
    def kidsWithCandies(self, candies, extraCandies):
        max_num = max(candies)
        return [x + extraCandies >= max_num for x in candies]
",n
"

class Solution(object):
    def countSubarrays(self, nums):
        return sum((nums[i-1]+nums[i+1])*2 == nums[i] for i in range(1, len(nums)-1))
",n
"

class Solution(object):
    def minOperations(self, initial, target):
        def binary_search_right(left, right, check):
            while left <= right:
                mid = left+(right-left)//2
                if not check( mid):
                    right = mid-1
                else:
                    left = mid+1
            return right
        
        def rolling_hash(s, l, lookup, check):
            MOD, P = 10**9+7, 113
            h = 0
            pw = pow(P, l-1, MOD)
            for i in range(len(s)):
                h = (h*P+(ord(s[i])-ord('a')))%MOD
                if i < l-1:
                    continue
                if not check:
                    lookup.add(h)
                elif h in lookup:
                    return True
                h = (h-(ord(s[i-(l-1)])-ord('a'))*pw)%MOD
            return False
                    
        def check(l):
            lookup = set()
            rolling_hash(target, l, lookup, False)
            return rolling_hash(initial, l, lookup, True)

        if len(initial) < len(target):
            initial, target = target, initial
        return len(initial)+len(target)-2*binary_search_right(1, min(len(initial), min(target)), check)


","(n + m) * log(min(n, m))"
"
class Solution2(object):
    def minOperations(self, initial, target):
        result = 0
        for k in range(2):
            for i in range(k, len(initial)):
                curr = 0
                for j in range(min(len(initial)-i, len(target))):
                    curr = curr+1 if initial[i+j] == target[j] else 0
                    result = max(result, curr)
            initial, target = target, initial
        return len(initial)+len(target)-2*result


",n * m
"
class Solution3(object):
    def minOperations(self, initial, target):
        if len(initial) < len(target):
            initial, target = target, initial
        result = 0
        dp = [0]*(len(target)+1)
        for i in range(len(initial)):
            for j in reversed(range(len(target))):
                dp[j+1] = dp[j]+1 if initial[i] == target[j] else 0
            result = max(result, max(dp))
        return len(initial)+len(target)-2*result
",n * m
"
class Solution(object):
    def winnerSquareGame(self, n):
        dp = [False]*(n+1)
        for i in range(1, n+1):
            j = 1
            while j*j <= i:
                if not dp[i-j*j]:
                    dp[i] = True
                    break
                j += 1
        return dp[-1]
",n * sqrt(n)
"

class Solution(object):
    def countDistinctIntegers(self, nums):
        def reverse(n):
            result = 0
            while n:
                result = result*10 + n%10
                n //= 10
            return result

        return len({y for x in nums for y in (x, reverse(x))})


",nlogr
"
class Solution2(object):
    def countDistinctIntegers(self, nums):
        return len({y for x in nums for y in (x, int(str(x)[::-1]))})
",nlogr
"
class Solution(object):
    def smallestCommonElement(self, mat):
        intersections = set(mat[0])
        for i in range(1, len(mat)):
            intersections &= set(mat[i])
            if not intersections:
                return -1
        return min(intersections)


",m * n
"import collections


class Solution2(object):
    def smallestCommonElement(self, mat):
        counter = collections.Counter()
        for row in mat:
            for c in row:
                counter[c] += 1
                if counter[c] == len(mat):
                    return c
        return -1
",m * n
"

class Solution(object):
    def getAncestors(self, n, edges):
        def iter_dfs(adj, i, result):
            lookup = [False]*len(adj)
            stk = [i]
            while stk:
                u = stk.pop()
                for v in reversed(adj[u]):
                    if lookup[v]:
                        continue
                    lookup[v] = True
                    stk.append(v)
                    result[v].append(i)
                    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
        result = [[] for _ in range(n)]
        for u in range(n):
            iter_dfs(adj, u, result)
        return result


",|V| * |E|
"
class Solution2(object):
    def getAncestors(self, n, edges):
        def bfs(adj, i, result):
            lookup = [False]*len(adj)
            q = [i]
            lookup[i] = True
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                        result[i].append(v)
                q = new_q
            result[i].sort()

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[v].append(u)
        result = [[] for _ in range(n)]
        for u in range(n):
            bfs(adj, u, result) 
        return result


",|V| * |E| * log(|V| * |E|)
"
class Solution3(object):
    def getAncestors(self, n, edges):
        result = [set() for _ in range(n)]
        in_degree = [0]*n
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            in_degree[v] += 1
            result[v].add(u)
        q = [u for u, d in enumerate(in_degree) if not d]
        while q:
            new_q = []
            for u in q:
                for v in adj[u]:
                    result[v].update(result[u])
                    in_degree[v] -= 1
                    if not in_degree[v]:
                        new_q.append(v)
            q = new_q
        return [sorted(s) for s in result]
",|V| * |E| * log(|V| * |E|)
"
import itertools
import collections


class Solution(object):
    def findDiagonalOrder(self, nums):
        result, dq, col = [], collections.deque(), 0
        for i in range(len(nums)+max(map(len, nums))-1):
            new_dq = collections.deque()
            if i < len(nums):
                dq.appendleft((i, 0))
            for r, c in dq:
                result.append(nums[r][c])
                if c+1 < len(nums[r]):
                    new_dq.append((r, c+1))
            dq = new_dq
        return result


",m * n
"class Solution2(object):
    def findDiagonalOrder(self, nums):
        result = []
        for r, row in enumerate(nums):
            for c, num in enumerate(row):
                if len(result) <= r+c:
                    result.append([])
                result[r+c].append(num)
        return [num for row in result for num in reversed(row)]
",m * n
"

class Solution(object):
    def sumOfGoodNumbers(self, nums, k):
        return sum(nums[i] for i in range(len(nums)) if (i-k < 0 or nums[i-k] < nums[i]) and (i+k >= len(nums) or nums[i+k] < nums[i]))
",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isValidBST(self, root):
        prev, cur = None, root
        while cur:
            if cur.left is None:
                if prev and prev.val >= cur.val:
                    return False
                prev = cur
                cur = cur.right
            else:
                node = cur.left
                while node.right and node.right != cur:
                    node = node.right

                if node.right is None:
                    node.right = cur
                    cur = cur.left
                else:
                    if prev and prev.val >= cur.val:
                        return False
                    node.right = None
                    prev = cur
                    cur = cur.right

        return True


",n
"class Solution2(object):
    def isValidBST(self, root):
        return self.isValidBSTRecu(root, float(""-inf""), float(""inf""))

    def isValidBSTRecu(self, root, low, high):
        if root is None:
            return True

        return low < root.val and root.val < high \
            and self.isValidBSTRecu(root.left, low, root.val) \
            and self.isValidBSTRecu(root.right, root.val, high)


",n
"

class Solution(object):
    def maximumProcessableQueries(self, nums, queries):
        dp = [[float(""-inf"")]*len(nums) for _ in range(len(nums))]
        dp[0][-1] = 0
        for l in reversed(range(1, len(nums))):
            for i in range(len(nums)-(l-1)):
                j = i+(l-1)
                if i-1 >= 0:
                    dp[i][j] = max(dp[i][j], dp[i-1][j]+(1 if nums[i-1] >= queries[dp[i-1][j]] else 0))
                if j+1 < len(nums):
                    dp[i][j] = max(dp[i][j], dp[i][j+1]+(1 if nums[j+1] >= queries[dp[i][j+1]] else 0))
                if dp[i][j] == len(queries):
                    return len(queries)
        return max(dp[i][i]+(1 if nums[i] >= queries[dp[i][i]] else 0) for i in range(len(nums)))
",n^2
"
class Solution(object):
    def baseNeg2(self, N):
        result = []
        while N:
            result.append(str(-N & 1)) 
            N = -(N >> 1) 
        result.reverse()
        return """".join(result) if result else ""0""


",logn
"class Solution2(object):
    def baseNeg2(self, N):
        BASE = -2
        result = []
        while N:
            N, r = divmod(N, BASE)
            if r < 0:
                r -= BASE
                N += 1
            result.append(str(r))
        result.reverse()
        return """".join(result) if result else ""0""
",logn
"
import collections



class Solution(object):
    def mostFrequent(self, nums, key):
        return collections.Counter(nums[i+1] for i in range(len(nums)-1) if nums[i] == key).most_common(1)[0][0]
",n
"

class Solution(object):
    def maxHammingDistances(self, nums, m):
        dp = [float(""-inf"")]*(1<<m)
        for x in nums:
            dp[x] = 0
        for i in range(m):
            new_dp = dp[:]
            for mask in range(1<<m):
                new_dp[mask] = max(new_dp[mask], dp[mask^(1<<i)]+1)
            dp = new_dp
        return [dp[x] for x in nums]


",m * 2^m
"
class Solution2(object):
    def maxHammingDistances(self, nums, m):
        q = []
        dist = [-1]*(1<<m)
        for x in nums:
            if dist[x] != -1:
                continue
            dist[x] = 0
            q.append(x)
        d = 0
        while q:
            d += 1
            new_q = []
            for u in q:
                for i in range(m):
                    if dist[u^(1<<i)] != -1:
                        continue
                    dist[u^(1<<i)] = d
                    new_q.append(u^(1<<i))
            q = new_q
        return [m-dist[((1<<m)-1)^x] for x in nums]
",m * 2^m
"
import bisect


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def closestNodes(self, root, queries):
        def iter_dfs():
            inorder = []
            stk = [(1, root)]
            while stk:
                step, node = stk.pop()
                if step == 1:
                    if not node:
                        continue
                    stk.append((1, node.right))
                    stk.append((2, node))
                    stk.append((1, node.left))
                elif step == 2:
                    inorder.append(node.val)
            return inorder

        inorder = iter_dfs()
        result = []
        for q in queries:
            i = bisect.bisect_left(inorder, q)
            if i == len(inorder):
                result.append([inorder[i-1], -1])
            elif inorder[i] == q:
                result.append([inorder[i], inorder[i]])
            elif i-1 >= 0:
                result.append([inorder[i-1], inorder[i]])
            else:
                result.append([-1, inorder[i]])
        return result


",n + qlogn
"import bisect



class Solution2(object):
    def closestNodes(self, root, queries):
        def dfs(node):
            if not node:
                return
            dfs(node.left)
            inorder.append(node.val)
            dfs(node.right)

        inorder = []
        dfs(root)
        result = []
        for q in queries:
            i = bisect.bisect_left(inorder, q)
            if i == len(inorder):
                result.append([inorder[i-1], -1])
            elif inorder[i] == q:
                result.append([inorder[i], inorder[i]])
            elif i-1 >= 0:
                result.append([inorder[i-1], inorder[i]])
            else:
                result.append([-1, inorder[i]])
        return result
",n + qlogn
"
import collections


class Solution(object):
    def countVowelSubstrings(self, word):
        VOWELS = set(""aeiou"")
        k = 5
        def atLeastK(word, k):
            cnt = collections.Counter()
            result = left = right = 0
            for i, c in enumerate(word):
                if c not in VOWELS:
                    cnt = collections.Counter()
                    left = right = i+1
                    continue
                cnt[c] += 1
                while len(cnt) > k-1:
                    cnt[word[right]] -= 1
                    if not cnt[word[right]]:
                        del cnt[word[right]]
                    right += 1
                result += right-left
            return result

        return atLeastK(word, k)


",n
"import collections


class Solution2(object):
    def countVowelSubstrings(self, word):
        VOWELS = set(""aeiou"")
        k = 5
        def atMostK(word, k):
            cnt = collections.Counter()
            result = left = 0
            for right, c in enumerate(word):
                if c not in VOWELS:
                    cnt = collections.Counter()
                    left = right+1
                    continue
                cnt[c] += 1
                while len(cnt) > k:
                    cnt[word[left]] -=1
                    if not cnt[word[left]]:
                        del cnt[word[left]]
                    left += 1
                result += right-left+1
            return result

        return atMostK(word, k) - atMostK(word, k-1)
",n
"
import collections


class Solution(object):
    def snakesAndLadders(self, board):
        def coordinate(n, s):
            a, b = divmod(s-1, n)
            r = n-1-a
            c = b if r%2 != n%2 else n-1-b
            return r, c

        n = len(board)
        lookup = {1: 0}
        q = collections.deque([1])
        while q:
            s = q.popleft()
            if s == n*n:
                return lookup[s]
            for s2 in range(s+1, min(s+6, n*n)+1):
                r, c = coordinate(n, s2)
                if board[r][c] != -1:
                    s2 = board[r][c]
                if s2 not in lookup:
                    lookup[s2] = lookup[s]+1
                    q.append(s2)
        return -1

",n^2
"
class Solution(object):
    def minStartValue(self, nums):
        min_prefix, prefix = 0, 0
        for num in nums:
            prefix += num
            min_prefix = min(min_prefix, prefix)
        return 1-min_prefix
",n
"
class Solution(object):
    def decodeAtIndex(self, S, K):
        i = 0
        for c in S:
            if c.isdigit():
                i *= int(c)
            else:
                i += 1

        for c in reversed(S):
            K %= i
            if K == 0 and c.isalpha():
                return c

            if c.isdigit():
                i /= int(c)
            else:
                i -= 1

",n
"

class Solution(object):
    def maximumOddBinaryNumber(self, s):
        a = list(s)
        left = 0
        for i in range(len(a)):
            if a[i] != '1':
                continue
            a[i], a[left] = a[left], a[i]
            left += 1
        if a[-1] != '1':
            a[-1], a[left-1] = a[left-1], a[-1]
        return """".join(a)


",n
"
class Solution2(object):
    def maximumOddBinaryNumber(self, s):
        n = s.count('1')
        return """".join(['1']*(n-1)+['0']*(len(s)-n)+['1'])
",n
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def rotateRight(self, head, k):
        if not head or not head.__next__:
            return head

        n, cur = 1, head
        while cur.__next__:
            cur = cur.__next__
            n += 1
        cur.next = head

        cur, tail = head, cur
        for _ in range(n - k % n):
            tail = cur
            cur = cur.__next__
        tail.next = None

        return cur


",n
"

class Solution(object):
    def hasSameDigits(self, s):
        def check(mod):
            def decompose(x, mod): 
                cnt = 0
                while x > 1 and x%mod == 0:
                    x //= mod
                    cnt += 1
                return x, cnt

            result = cnt = 0
            curr = 1
            for i in range(len(s)-1):
                if cnt == 0:
                    result = (result+curr*(ord(s[i])-ord(s[i+1])))%mod
                x, c = decompose(len(s)-2-i, mod)
                curr = (curr*x)%mod
                cnt += c
                x, c = decompose(i+1, mod)
                curr = (curr*pow(x, mod-2, mod))%mod
                cnt -= c
            return result == 0

        return check(2) and check(5)


",nlogn
"LOOKUP = [[-1]*(5+1) for _ in range(5+1)]



class Solution2(object):
    def hasSameDigits(self, s):
        def nCr(n, r):
            if n-r < r:
                r = n-r
            if LOOKUP[n][r] == -1:
                c = 1
                for k in range(1, r+1):
                    c *= n-k+1
                    c //= k
                LOOKUP[n][r] = c
            return LOOKUP[n][r]

        def nCr_mod(n, r, mod):
            result = 1
            while n > 0 or r > 0:
                n, ni = divmod(n, mod)
                r, ri = divmod(r, mod)
                if ni < ri:
                    return 0
                result = (result*nCr(ni, ri))%mod
            return result

        def nC10(n, k):
            return lookup[nCr_mod(n, k, 2)][nCr_mod(n, k, 5)]

        lookup = [[0]*5 for _ in range(2)]
        for i in range(10):
            lookup[i%2][i%5] = i
        total = 0
        for i in range(len(s)-1):
            total = (total+nC10(len(s)-2, i)*(ord(s[i])-ord(s[i+1])))%10
        return total == 0


",nlogn
"class Solution3(object):
    def hasSameDigits(self, s):
        s = list(map(int, s))
        for l in reversed(range(3, len(s)+1)):
            for i in range(l-1):
                s[i] = (s[i]+s[i+1])%10
        return s[0] == s[1]
",n^2
"

class Solution(object):
    def successfulPairs(self, spells, potions, success):
        def ceil_divide(a, b):
            return (a+(b-1))//b
            
        potions.sort()
        return [len(potions)-bisect.bisect_left(potions, ceil_divide(success, s)) for s in spells]
",mlogm + nlogm
"
import collections


class Solution(object):
    def mostCommonWord(self, paragraph, banned):
        lookup = set(banned)
        counts = collections.Counter(word.strip(""!?',."")
                                     for word in paragraph.lower().split())

        result = ''
        for word in counts:
            if (not result or counts[word] > counts[result]) and \
               word not in lookup:
                result = word
        return result

",m + n
"
class Solution(object):
    def minPathSum(self, grid):
        sum = list(grid[0])
        for j in range(1, len(grid[0])):
            sum[j] = sum[j - 1] + grid[0][j]

        for i in range(1, len(grid)):
            sum[0] += grid[i][0]
            for j in range(1, len(grid[0])):
                sum[j] = min(sum[j - 1], sum[j]) + grid[i][j]

        return sum[-1]

",m * n
"
class Solution(object):
    def minInsertions(self, s):
        def longestCommonSubsequence(text1, text2):
            if len(text1) < len(text2):
                return self.longestCommonSubsequence(text2, text1)
            dp = [[0 for _ in range(len(text2)+1)] for _ in range(2)]
            for i in range(1, len(text1)+1):
                for j in range(1, len(text2)+1):
                    dp[i%2][j] = dp[(i-1)%2][j-1]+1 if text1[i-1] == text2[j-1] \
                                 else max(dp[(i-1)%2][j], dp[i%2][j-1])
            return dp[len(text1)%2][len(text2)]

        return len(s)-longestCommonSubsequence(s, s[::-1])
",n^2
"

class Solution(object):
    def freqAlphabets(self, s):
        def alpha(num):
            return chr(ord('a') + int(num)-1)

        i = 0
        result = []
        while i < len(s):
            if i+2 < len(s) and s[i+2] == 
                result.append(alpha(s[i:i+2]))
                i += 3
            else:
                result.append(alpha(s[i]))
                i += 1
        return """".join(result)


",n
"
class Solution2(object):
    def freqAlphabets(self, s):
        def alpha(num):
            return chr(ord('a') + int(num)-1)

        i = len(s)-1
        result = []
        while i >= 0:
            if s[i] == 
                result.append(alpha(s[i-2:i]))
                i -= 3
            else:
                result.append(alpha(s[i]))
                i -= 1
        return """".join(reversed(result))

",n
"import re



class Solution3(object):
    def freqAlphabets(self, s):
        def alpha(num):
            return chr(ord('a') + int(num)-1)

        return """".join(alpha(i[:2]) for i in re.findall(r""\d\
",n
"
import random



class Solution(object):
    def makeSubKSumEqual(self, arr, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        l = gcd(k, len(arr))
        result = 0
        for i in range(l):
            vals = [arr[j] for j in range(i, len(arr), l)]
            nth_element(vals, len(vals)//2)
            result += sum(abs(v-vals[len(vals)//2]) for v in vals)
        return result
",n
"
class Solution(object):
    def maxProductDifference(self, nums):
        largest, smallest = [0]*2, [float(""inf"")]*2
        for x in nums:
            if x >= largest[0]:
                largest[:] = [x, largest[0]]
            elif x > largest[1]:
                largest[1] =x
            if x <= smallest[0]:
                smallest[:] = [x, smallest[0]]
            elif x < smallest[1]:
                smallest[1] = x
        return largest[0]*largest[1] - smallest[0]*smallest[1]
",n
"

class Solution(object):
    def maximizeTheProfit(self, n, offers):
        lookup = [[] for _ in range(n)]
        for s, e, g in offers:
            lookup[e].append([s, g])
        dp = [0]*(n+1)
        for e in range(n):
            dp[e+1] = dp[(e-1)+1]
            for s, g in lookup[e]:
                dp[e+1] = max(dp[e+1], dp[(s-1)+1]+g)
        return dp[-1]
",n + m
"

class Solution(object):
    def countDistinctStrings(self, s, k):
        MOD = 10**9+7
        return pow(2, len(s)-k+1, MOD)
",logn
"

class Solution(object):
    def countSubarrays(self, nums):
        result = l = 1
        for i in range(1, len(nums)):
            if nums[i-1] >= nums[i]:
                l = 0
            l += 1
            result += l
        return result


",n
"
class Solution2(object):
    def countSubarrays(self, nums):
        result = left = 0
        for right in range(len(nums)):
            if not (right-1 >= 0 and nums[right-1] < nums[right]):
                left = right
            result += right-left+1
        return result
",n
"
class Solution(object):
    def numSubarrayBoundedMax(self, A, L, R):
        def count(A, bound):
            result, curr = 0, 0
            for i in A :
                curr = curr + 1 if i <= bound else 0
                result += curr
            return result

        return count(A, R) - count(A, L-1)

",n
"
class Solution(object):
    def generateMatrix(self, n):
        matrix = [[0 for _ in range(n)] for _ in range(n)]

        left, right, top, bottom, num = 0, n - 1, 0, n - 1, 1

        while left <= right and top <= bottom:
            for j in range(left, right + 1):
                matrix[top][j] = num
                num += 1
            for i in range(top + 1, bottom):
                matrix[i][right] = num
                num += 1
            for j in reversed(range(left, right + 1)):
                if top < bottom:
                    matrix[bottom][j] = num
                    num += 1
            for i in reversed(range(top + 1, bottom)):
                if left < right:
                    matrix[i][left] = num
                    num += 1
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1

        return matrix


",n^2
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def isSameTree(self, p, q):
        if p is None and q is None:
            return True

        if p is not None and q is not None:
            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

        return False

",n
"
import itertools



class Solution(object):
    def maxTastiness(self, price, tastiness, maxAmount, maxCoupons):
        dp = [[0]*(maxCoupons+1) for _ in range(maxAmount+1)]
        for p, t in zip(price, tastiness):
            for i in reversed(range(p//2, maxAmount+1)):
                for j in reversed(range(maxCoupons+1)):
                    if i-p >= 0:
                        dp[i][j] = max(dp[i][j], t+dp[i-p][j])
                    if j-1 >= 0:
                        dp[i][j] = max(dp[i][j], t+dp[i-p//2][j-1])
        return dp[maxAmount][maxCoupons]
",n * a * c
"

class Solution(object):
    def modifiedMatrix(self, matrix):
        for j in range(len(matrix[0])):
            mx = max(matrix[i][j] for i in range(len(matrix)))
            for i in range(len(matrix)):
                if matrix[i][j] == -1:
                    matrix[i][j] = mx
        return matrix
",m * n
"

class Solution(object):
    def isPossibleToCutPath(self, grid):
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if (i, j) == (0, 0) or grid[i][j] == 0:
                    continue
                if (i-1 < 0 or grid[i-1][j] == 0) and (j-1 < 0 or grid[i][j-1] == 0):
                    grid[i][j] = 0
        for i in reversed(range(len(grid))):
            for j in reversed(range(len(grid[0]))):
                if (i, j) == (len(grid)-1, len(grid[0])-1) or grid[i][j] == 0:
                    continue
                if (i+1 >= len(grid) or grid[i+1][j] == 0) and (j+1 >= len(grid[0]) or grid[i][j+1] == 0):
                    grid[i][j] = 0
        cnt = [0]*(len(grid)+len(grid[0])-1)
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                cnt[i+j] += grid[i][j]
        return any(cnt[i] <= 1 for i in range(1, len(grid)+len(grid[0])-2))


",m * n
"
class Solution2(object):
    def isPossibleToCutPath(self, grid):
        def iter_dfs():
            stk = [(0, 0)]
            while stk:
                i, j = stk.pop()
                if not (i < len(grid) and j < len(grid[0]) and grid[i][j]):
                    continue
                if (i, j) == (len(grid)-1, len(grid[0])-1):
                    return True
                if (i, j) != (0, 0):
                    grid[i][j] = 0
                stk.append((i, j+1))
                stk.append((i+1, j))  
            return False

        return not iter_dfs() or not iter_dfs()


",m * n
"
class Solution3(object):
    def isPossibleToCutPath(self, grid):
        def dfs(i, j):
            if not (i < len(grid) and j < len(grid[0]) and grid[i][j]):
                return False
            if (i, j) == (len(grid)-1, len(grid[0])-1):
                return True
            if (i, j) != (0, 0):
                grid[i][j] = 0
            return dfs(i+1, j) or dfs(i, j+1)

        return not dfs(0, 0) or not dfs(0, 0)
",m * n
"
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def evaluateTree(self, root):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y
        }
        
        def iter_dfs(root):
            ret = [0]
            stk = [(1, (root, ret))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if node.left == node.right:
                        ret[0] = node.val
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    ret[0] = OP[node.val](ret1[0], ret2[0])
            return ret[0]

        return iter_dfs(root)


",n
"
class Solution2(object):
    def evaluateTree(self, root):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
        }
        
        def dfs(node):
            if node.left == node.right:
                return node.val
            return OP[node.val](dfs(node.left), dfs(node.right))

        return dfs(root)
",n
"
class Solution(object):
    def evaluate(self, expression):
        def getval(lookup, x):
            return lookup.get(x, x)

        def evaluate(tokens, lookup):
            if tokens[0] in ('add', 'mult'):
                a, b = list(map(int, [getval(lookup, x) for x in tokens[1:]]))
                return str(a+b if tokens[0] == 'add' else a*b)
            for i in range(1, len(tokens)-1, 2):
                if tokens[i+1]:
                    lookup[tokens[i]] = getval(lookup, tokens[i+1])
            return getval(lookup, tokens[-1])

        tokens, lookup, stk = [''], {}, []
        for c in expression:
            if c == '(':
                if tokens[0] == 'let':
                    evaluate(tokens, lookup)
                stk.append((tokens, dict(lookup)))
                tokens =  ['']
            elif c == ' ':
                tokens.append('')
            elif c == ')':
                val = evaluate(tokens, lookup)
                tokens, lookup = stk.pop()
                tokens[-1] += val
            else:
                tokens[-1] += c
        return int(tokens[0])

",n^2
"
class Solution(object):
    def countSubstrings(self, s):
        def manacher(s):
            s = '
            P = [0] * len(s)
            C, R = 0, 0
            for i in range(1, len(s) - 1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P
        return sum((max_len+1)//2 for max_len in manacher(s))

",n
"
class Solution(object):
    def numsSameConsecDiff(self, N, K):
        curr = list(range(10))
        for i in range(N-1):
            curr = [x*10 + y for x in curr for y in set([x%10 + K, x%10 - K]) 
                    if x and 0 <= y < 10]
        return curr
",2^n
"
import collections



class Solution(object):
    def longestSpecialPath(self, edges, nums):
        def iter_dfs():
            result = [float(""inf"")]*2
            lookup = collections.defaultdict(lambda: -1)
            prefix = [0]
            stk = [(1, (0, -1, 0, [-1]*2))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, d, left = args
                    prev_d, lookup[nums[u]-1] = lookup[nums[u]-1], d
                    new_left = left[:]
                    curr = prev_d
                    for i in range(len(new_left)):
                        if curr > new_left[i]:
                            curr, new_left[i] = new_left[i], curr
                    result = min(result, [-(prefix[(d-1)+1]-prefix[new_left[1]+1]), d-new_left[1]])
                    stk.append((4, (u, prev_d)))
                    stk.append((2, (u, p, d, new_left, 0)))
                elif step == 2:
                    u, p, d, left, i = args
                    if i == len(adj[u]):
                        continue
                    stk.append((2, (u, p, d, left, i+1)))
                    v, l = adj[u][i]
                    if v == p:
                        continue
                    prefix.append(prefix[-1]+l)
                    stk.append((3, None))
                    stk.append((1, (v, u, d+1, left)))
                elif step == 3:
                    prefix.pop()
                elif step == 4:
                    u, prev_d = args
                    lookup[nums[u]-1] = prev_d
            return [-result[0], result[1]]
    
        adj = [[] for _ in range(len(nums))]
        for u, v, l in edges:
            adj[u].append((v, l))
            adj[v].append((u, l))        
        return iter_dfs()


",n + e
"import collections



class Solution2(object):
    def longestSpecialPath(self, edges, nums):
        def dfs(u, p, d, left):
            prev_d, lookup[nums[u]-1] = lookup[nums[u]-1], d
            new_left = left[:]
            curr = prev_d
            for i in range(len(new_left)):
                if curr > new_left[i]:
                    curr, new_left[i] = new_left[i], curr
            result[0] = min(result[0], [-(prefix[(d-1)+1]-prefix[new_left[1]+1]), d-new_left[1]])
            for v, l in adj[u]:
                if v == p:
                    continue
                prefix.append(prefix[-1]+l)
                dfs(v, u, d+1, new_left)
                prefix.pop()
            lookup[nums[u]-1] = prev_d
    
        adj = [[] for _ in range(len(nums))]
        for u, v, l in edges:
            adj[u].append((v, l))
            adj[v].append((u, l))
        lookup = collections.defaultdict(lambda: -1)
        prefix = [0]
        result = [[float(""inf""), float(""inf"")]]
        dfs(0, -1, 0, [-1]*2)
        return [-result[0][0], result[0][1]]
",n + e
"
import heapq


class Interval(object):
    def __init__(self, s=0, e=0):
        self.start = s
        self.end = e


class Solution(object):
    def employeeFreeTime(self, schedule):
        result = []
        min_heap = [(emp[0].start, eid, 0) for eid, emp in enumerate(schedule)]
        heapq.heapify(min_heap)
        last_end = -1
        while min_heap:
            t, eid, i = heapq.heappop(min_heap)
            if 0 <= last_end < t:
                result.append(Interval(last_end, t))
            last_end = max(last_end, schedule[eid][i].end)
            if i+1 < len(schedule[eid]):
                heapq.heappush(min_heap, (schedule[eid][i+1].start, eid, i+1))
        return result

",m * logn
"

class Solution(object):
    def sumOfPower(self, nums):
        MOD = 10**9+7
        nums.sort()
        result = dp = 0
        for x in nums:
            result = (result+(x**2)*(dp+x))%MOD
            dp = (dp+(dp+x))%MOD
        return result
",nlogn
"
class Solution(object):
    def minOperations(self, n):
        return (n//2)*((n+1)//2)
",1
"

class Solution(object):
    def collectTheCoins(self, coins, edges):
        DISTANCE = 2

        adj = [set() for _ in range(len(coins))]
        for u, v in edges:
            adj[u].add(v)
            adj[v].add(u)
        n = len(coins)
        q = []
        for u in range(len(coins)):
            while len(adj[u]) == 1 and not coins[u]:
                v = adj[u].pop()
                adj[v].remove(u)
                n -= 1
                u = v
        q = [u for u in range(len(coins)) if len(adj[u]) == 1]
        for _ in range(DISTANCE):
            new_q = []
            for u in q:
                if not adj[u]:
                    assert(n == 1)
                    break
                v = adj[u].pop()
                adj[v].remove(u)
                n -= 1
                if len(adj[v]) == 1:
                    new_q.append(v)
            q = new_q
        return (n-1)*2
",n
"
import collections



class Solution(object):
    def minMaxSubarraySum(self, nums, k):
        def count(check):
            result = total = 0
            dq = collections.deque()
            for right in range(len(nums)):
                while dq and not check(nums[dq[-1]], nums[right]):
                    i = dq.pop()
                    cnt = i-(dq[-1]+1 if dq else max(right-k+1, 0))+1
                    total -= cnt*nums[i]
                cnt = right-(dq[-1]+1 if dq else max(right-k+1, 0))+1
                dq.append(right)
                total += cnt*nums[right]
                result += total
                if right-(k-1) >= 0:
                    total -= nums[dq[0]]
                    if dq[0] == right-(k-1):
                        dq.popleft()
            return result
    
        return count(lambda a, b: a < b)+count(lambda a, b: a > b)


",n
"import collections



class Solution2(object):
    def minMaxSubarraySum(self, nums, k):
        def count(check):
            result = total = 0
            dq = collections.deque()
            for right in range(len(nums)):
                left = right
                while dq and not check(nums[dq[-1][0]], nums[right]):
                    i, left = dq.pop()
                    total -= (i-left+1)*nums[i]
                dq.append([right, left])
                total += (right-left+1)*nums[right]
                result += total
                if right-(k-1) >= 0:
                    total -= nums[dq[0][0]]
                    if dq[0][0] == right-(k-1):
                        dq.popleft()
                    else:
                        assert(dq[0][1] == right-(k-1))
                        dq[0][1] += 1
            return result
    
        return count(lambda a, b: a < b)+count(lambda a, b: a > b)
",n
"

class Solution(object):
    def minimumOperations(self, num):
        lookup = [0]*10
        for i in reversed(range(len(num))):
            if ((num[i] in ""05"" and lookup[0]) or
                (num[i] in ""27"" and lookup[5])):
                return (len(num)-i)-2
            lookup[ord(num[i])-ord('0')] = 1
        return len(num)-lookup[0]
",n
"
import collections


class BIT(object): 
    def __init__(self, n):
        self.__bit = [0] * n

    def add(self, i, val):
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def sum(self, i):
        result = 0
        while i > 0:
            result += self.__bit[i]
            i -= (i & -i)
        return result


class Solution(object):
    def minInteger(self, num, k):
        lookup = collections.defaultdict(list)
        bit = BIT(len(num)+1)
        for i in reversed(range(len(num))):
            bit.add(i+1, 1)
            lookup[int(num[i])].append(i+1)
        result = []
        for _ in range(len(num)):
            for d in range(10):
                if lookup[d] and bit.sum(lookup[d][-1]-1) <= k:
                    k -= bit.sum(lookup[d][-1]-1)
                    bit.add(lookup[d].pop(), -1)
                    result.append(d)
                    break
        return """".join(map(str, result))
",nlogn
"
import random
import math

class Solution(object):

    def __init__(self, radius, x_center, y_center):
        self.__radius = radius
        self.__x_center = x_center
        self.__y_center = y_center
        

    def randPoint(self):
        r = (self.__radius) * math.sqrt(random.uniform(0, 1))
        theta = (2*math.pi) * random.uniform(0, 1)
        return (r*math.cos(theta) + self.__x_center,
                r*math.sin(theta) + self.__y_center)



",1
"
class Solution(object):
    def longestWPI(self, hours):
        result, accu = 0, 0
        lookup = {}
        for i, h in enumerate(hours):
            accu = accu+1 if h > 8 else accu-1
            if accu > 0:
                result = i+1
            elif accu-1 in lookup:
                result = max(result, i-lookup[accu-1])
            lookup.setdefault(accu, i)
        return result
",n
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def addTwoNumbers(self, l1, l2):
        stk1, stk2 = [], []
        while l1:
            stk1.append(l1.val)
            l1 = l1.__next__
        while l2:
            stk2.append(l2.val)
            l2 = l2.__next__

        prev, head = None, None
        sum = 0
        while stk1 or stk2:
            sum /= 10
            if stk1:
                sum += stk1.pop()
            if stk2:
                sum += stk2.pop()

            head = ListNode(sum % 10)
            head.next = prev
            prev = head

        if sum >= 10:
            head = ListNode(sum / 10)
            head.next = prev

        return head

",m + n
"

class BitCount(object):
    def __init__(self, n):
        self.__l = 0
        self.__n = n
        self.__count = [0]*n
    
    def __iadd__(self, num):
        self.__l += 1
        base = 1
        for i in range(self.__n):
            if num&base:
                self.__count[i] += 1
            base <<= 1
        return self

    def __isub__(self, num):
        self.__l -= 1
        base = 1
        for i in range(self.__n):
            if num&base:
                self.__count[i] -= 1
            base <<= 1
        return self

    def bit_or(self):
        num, base = 0, 1
        for i in range(self.__n):
            if self.__count[i]:
                num |= base
            base <<= 1
        return num

                    
class Solution(object):
    def minimumDifference(self, nums, k):
        count = BitCount(max(nums).bit_length())
        result, left = float(""inf""), 0
        for right in range(len(nums)):
            count += nums[right]
            while left <= right:
                f = count.bit_or()
                result = min(result, abs(f-k))
                if f <= k:
                    break
                count -= nums[left]
                left += 1
        return result


",nlogr
"
class Solution2(object):
    def minimumDifference(self, nums, k):
        result, dp = float(""inf""), set() 
        for x in nums:
            dp = {x}|{f|x for f in dp}
            for f in dp:
                result = min(result, abs(f-k))
        return result
    
",nlogr
"
import random



class Solution(object):
    def maxStarSum(self, vals, edges, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        adj = [[] for _ in range(len(vals))]
        for u, v in edges:
            if vals[v] > 0:
                adj[u].append(v)
            if vals[u] > 0:
                adj[v].append(u)
        result = float(""-inf"")
        for u in range(len(vals)):
            if 1 <= k <= len(adj[u]):
                nth_element(adj[u], k-1, lambda a, b: vals[a] > vals[b])
            result = max(result, vals[u]+sum(vals[adj[u][i]] for i in range(min(k, len(adj[u])))))
        return result
",n
"

class Solution(object):
    def scoreOfString(self, s):
        return sum(abs(ord(s[i+1])-ord(s[i])) for i in range(len(s)-1))
",n
"

class Solution(object):
    def rangeAddQueries(self, n, queries):
        result = [[0]*n for _ in range(n)]
        for r1, c1, r2, c2 in queries:
            result[r1][c1] += 1
            if c2+1 < len(result[0]):
                result[r1][c2+1] -= 1
            if r2+1 < len(result):
                result[r2+1][c1] -= 1
            if r2+1 < len(result) and c2+1 < len(result[0]):
                result[r2+1][c2+1] += 1
        for r in range(len(result)):
            for c in range(len(result[0])-1):
                result[r][c+1] += result[r][c]
        for r in range(len(result)-1):
            for c in range(len(result[0])):
                result[r+1][c] += result[r][c]
        return result
",q + n^2
"


class Solution(object):
    def minArraySum(self, nums, k, op1, op2):
        nums.sort()

        left = next((i for i in range(len(nums)) if nums[i] >= k), len(nums))
        right = next((i for i in range(len(nums)) if nums[i] >= 2*k-1), len(nums))

        lookup, cnt = [False]*len(nums), 0
        for j in reversed(range(right, len(nums))):
            if not op1:
                break
            op1 -= 1
            nums[j] = (nums[j]+1)//2
            if op2:
                op2 -= 1
                nums[j] -= k
        else:
            j = right-1

        for i in range(left, j+1):
            if not op2:
                break
            op2 -= 1
            if k%2 == 1 and nums[i]%2 == 0:
                lookup[i] = True
            nums[i] -= k
        else:
            i = j+1
    
        for j in reversed(range(i, j+1)):
            if not op1:
                break
            op1 -= 1
            if k%2 == 1 and nums[j]%2 == 1:
                cnt += 1
            nums[j] = (nums[j]+1)//2
        else:
            j = i-1

        arr = sorted((nums[idx], idx) for idx in range(i))
        for _ in range(op1):
            x, idx = arr.pop()
            nums[idx] = (x+1)//2
            if cnt and lookup[idx]:
                cnt -= 1
                nums[idx] -= 1
        return sum(nums)


",nlogn
"
class Solution2(object):
    def minArraySum(self, nums, k, op1, op2):
        dp = [[sum(nums)]*(op2+1) for _ in range(op1+1)]
        for x in nums:
            for i in reversed(range(op1+1)):
                for j in reversed(range(op2+1)):
                    if i-1 >= 0:
                        dp[i][j] = min(dp[i][j], dp[i-1][j]-x+(x+1)//2)
                    if j-1 >= 0:
                        if x-k >= 0:
                            dp[i][j] = min(dp[i][j], dp[i][j-1]-x+(x-k))
                    if i-1 >= 0 and j-1 >= 0:
                        if x-k >= 0:
                            dp[i][j] = min(dp[i][j], dp[i-1][j-1]-x+((x-k)+1)//2)
                        if (x+1)//2-k >= 0:
                            dp[i][j] = min(dp[i][j], dp[i-1][j-1]-x+((x+1)//2-k))
        return dp[op1][op2]
",n * op1 * op2
"
class Solution(object):
    def findTilt(self, root):
        def postOrderTraverse(root, tilt):
            if not root:
                return 0, tilt
            left, tilt = postOrderTraverse(root.left, tilt)
            right, tilt = postOrderTraverse(root.right, tilt)
            tilt += abs(left-right)
            return left+right+root.val, tilt

        return postOrderTraverse(root, 0)[1]

",n
"
class Solution(object):
    def minMeetingRooms(self, intervals):
        result, curr = 0, 0
        line = [x for i, j in intervals for x in [[i, 1], [j, -1]]]
        line.sort()
        for _, num in line:
            curr += num
            result = max(result, curr)
        return result


",nlogn
"class Solution2(object):
    def minMeetingRooms(self, intervals):
        starts, ends = [], []
        for start, end in intervals:
            starts.append(start)
            ends.append(end)

        starts.sort()
        ends.sort()

        s, e = 0, 0
        min_rooms, cnt_rooms = 0, 0
        while s < len(starts):
            if starts[s] < ends[e]:
                cnt_rooms += 1 
                min_rooms = max(min_rooms, cnt_rooms)
                s += 1
            else:
                cnt_rooms -= 1 
                e += 1

        return min_rooms


",nlogn
"from heapq import heappush, heappop


class Solution3(object):
    def minMeetingRooms(self, intervals):
        if not intervals:
            return 0
        
        intervals.sort(key=lambda x: x[0])
        free_rooms = []
        
        heappush(free_rooms, intervals[0][1])
        for interval in intervals[1:]:
            if free_rooms[0] <= interval[0]:
                heappop(free_rooms)
            
            heappush(free_rooms, interval[1])
        
        return len(free_rooms)
",nlogn
"
import itertools



class Solution(object):
    def isAcronym(self, words, s):
        return len(words) == len(s) and all(w[0] == c for w, c in zip(words, s))
",n
"

class Solution(object):
    def findIndices(self, nums, indexDifference, valueDifference):
        mx_i = mn_i = 0
        for i in range(len(nums)-indexDifference):
            if nums[i] > nums[mx_i]:
                mx_i = i
            elif nums[i] < nums[mn_i]:
                mn_i = i
            if nums[mx_i]-nums[i+indexDifference] >= valueDifference:
                return [mx_i, i+indexDifference]
            if nums[i+indexDifference]-nums[mn_i] >= valueDifference:
                return [mn_i, i+indexDifference]
        return [-1]*2
",n
"
















class Solution(object):
    def clumsy(self, N):
        if N <= 2:
            return N
        if N <= 4:
            return N+3
        
        if N % 4 == 0:
            return N+1
        elif N % 4 <= 2:
            return N+2
        return N-1
",1
"
class Solution(object):
    def findOcurrences(self, text, first, second):
        result = []
        first += ' '
        second += ' '
        third = []
        i, j, k = 0, 0, 0
        while k < len(text):
            c = text[k]
            k += 1
            if i != len(first):
                if c == first[i]:
                    i += 1
                else:
                    i = 0
                continue
            if j != len(second):
                if c == second[j]:
                    j += 1
                else:
                    k -= j+1
                    i, j = 0, 0
                continue
            if c != ' ':
                third.append(c)
                continue
            k -= len(second) + len(third) + 1
            i, j = 0, 0
            result.append("""".join(third))
            third = []
        if third:
            result.append("""".join(third))
        return result
",n
"

class Solution(object):
    def countGoodNodes(self, edges):
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    l, valid = [0], [True]
                    stk.append((4, (ret, valid)))
                    stk.append((2, (u, p, 0, ret, l, valid)))
                elif step == 2:
                    u, p, i, ret, l, valid = args
                    if i == len(adj[u]):
                        continue
                    stk.append((2, (u, p, i+1, ret, l, valid)))
                    v = adj[u][i]
                    if v == p:
                        continue
                    new_ret = [0]
                    stk.append((3, (new_ret, ret, l, valid)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    new_ret, ret, l, valid = args
                    ret[0] += new_ret[0]
                    l[0] += 1
                    if new_ret[0]*l[0] != ret[0]:
                        valid[0] = False
                elif step == 4:
                    ret, valid = args
                    if valid[0]:
                        result += 1
                    ret[0] += 1
            return result

        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()


",n
"
class Solution2(object):
    def countGoodNodes(self, edges):
        def dfs(u, p):
            total = l = 0
            valid = True
            for v in adj[u]:
                if v == p:
                    continue
                cnt = dfs(v, u)
                total += cnt
                l += 1
                if l*cnt != total:
                    valid = False
            if valid:
                result[0] += 1
            return total+1
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1)
        return result[0]
",n
"

class Solution(object):
    def minOperations(self, nums, queries):
        nums.sort()
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        result = [0]*len(queries)
        for i, q in enumerate(queries):
            j = bisect.bisect_left(nums, q)
            result[i] = (q*j-prefix[j])+((prefix[-1]-prefix[j])-q*(len(nums)-j))
        return result
",nlogn + qlogn
"

class Solution(object):
    def uniqueXorTriplets(self, nums):
        def fst(a, inverse):
            n = len(a)
            step = 1
            while step < n:
                for i in range(0, n, step<<1):
                    for j in range(i, i+step):
                        u, v = a[j], a[j+step]
                        a[j], a[j+step] = u+v, u-v
                step <<= 1
            if inverse:
                for i in range(n):
                    a[i] //= n
        
        a = [0]*(1<<max(nums).bit_length())
        for x in nums:
            a[x] += 1
        fst(a, False)
        for i in range(len(a)):
            a[i] = a[i]**3
        fst(a, True)
        return sum(x != 0 for x in a)


",nlogn
"
class Solution2(object):
    def uniqueXorTriplets(self, nums):
        cnt2, cnt3 = set([0]), set(),  
        max_cnt = 1<<max(nums).bit_length()
        for x in nums:
            for y in cnt2:
                cnt3.add(x^y)
            for y in nums:
                cnt2.add(x^y)
            if len(cnt3) == max_cnt:
                break
        return len(cnt3)
",n^2
"
import collections


class Solution(object):
    def minWindow(self, s, t):
        count, remain = collections.Counter(t), len(t)
        i, left, right = 0, -1, -1
        for j, c in enumerate(s):
            remain -= count[c] > 0
            count[c] -= 1
            if remain:
                continue
            while count[s[i]] < 0: 
                count[s[i]] += 1
                i += 1
            if right == -1 or j-i+1 < right-left+1:
                left, right = i, j
        return s[left:right+1]


",n
"class Solution2(object):
    def minWindow(self, s, t):
        current_count = [0 for i in range(52)]
        expected_count = [0 for i in range(52)]

        for char in t:
            expected_count[ord(char) - ord('a')] += 1

        i, count, start, min_width, min_start = 0, 0, 0, float(""inf""), 0
        while i < len(s):
            current_count[ord(s[i]) - ord('a')] += 1
            if current_count[ord(s[i]) - ord('a')] <= expected_count[ord(s[i]) - ord('a')]:
                count += 1

            if count == len(t):
                while expected_count[ord(s[start]) - ord('a')] == 0 or \
                      current_count[ord(s[start]) - ord('a')] > expected_count[ord(s[start]) - ord('a')]:
                    current_count[ord(s[start]) - ord('a')] -= 1
                    start += 1

                if min_width > i - start + 1:
                    min_width = i - start + 1
                    min_start = start
            i += 1

        if min_width == float(""inf""):
            return """"

        return s[min_start:min_start + min_width]


",n
"
import collections


class Solution(object):
    def executeInstructions(self, n, startPos, s):
        directions = {'U':(-1, 0), 'R':(0, 1), 'D':(1, 0), 'L':(0, -1)}
        (x0, y0), (x, y) = startPos, (0, 0)
        result = list(range(len(s), 0, -1))
        lookup_x = collections.defaultdict(list)
        lookup_y = collections.defaultdict(list)
        lookup_x[x0-x].append(0)
        lookup_y[y0-y].append(0)
        for i, d in enumerate(s):
            dx, dy = directions[d]
            x, y = x+dx, y+dy
            for k in n-x, -x-1:
                if k not in lookup_x:
                    continue
                for j in lookup_x[k]:
                    result[j] = min(result[j], i-j)
                lookup_x[k] = []
            for k in n-y, -y-1:
                if k not in lookup_y:
                    continue
                for j in lookup_y[k]:
                    result[j] = min(result[j], i-j)
                lookup_y[k] = []
            lookup_x[x0-x].append(i+1)
            lookup_y[y0-y].append(i+1)
        return result
",m
"
class Solution(object):
    def depthSumInverse(self, nestedList):
        def depthSumInverseHelper(list, depth, result):
            if len(result) < depth + 1:
                result.append(0)
            if list.isInteger():
                result[depth] += list.getInteger()
            else:
                for l in list.getList():
                    depthSumInverseHelper(l, depth + 1, result)

        result = []
        for list in nestedList:
            depthSumInverseHelper(list, 0, result)

        sum = 0
        for i in reversed(range(len(result))):
            sum += result[i] * (len(result) - i)
        return sum

",n
"
class Solution(object):
    def calPoints(self, ops):
        history = []
        for op in ops:
            if op == '+':
                history.append(history[-1] + history[-2])
            elif op == 'D':
                history.append(history[-1] * 2)
            elif op == 'C':
                history.pop()
            else:
                history.append(int(op))
        return sum(history)

",n
"
class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None


class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

    def find(self, key):
        curr = self.head
        while curr:
            if curr.key == key:
                break
            curr = curr.__next__
        return curr


class Solution(object):

    def __init__(self):
        self.__data = [LinkedList() for _ in range(10000)]

    def add(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if not node:
            l.insert(ListNode(key, 0))

    def remove(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        if node:
            l.delete(node)

    def contains(self, key):
        l = self.__data[key % len(self.__data)]
        node = l.find(key)
        return node is not None



",1
"
import collections
import itertools



class Solution(object):
    def minimumTotalCost(self, nums1, nums2):
        cnt = collections.Counter()
        result = 0
        for i, (x, y) in enumerate(zip(nums1, nums2)):
            if x != y:
                continue
            cnt[x] += 1
            result += i
        if not cnt:
            return 0
        majority = max(iter(cnt.keys()), key=lambda x: cnt[x])
        remain = cnt[majority]-(sum(cnt.values())-cnt[majority])
        if remain <= 0:
            return result
        for i, (x, y) in enumerate(zip(nums1, nums2)):
            if x == y or majority in (x, y):
                continue
            result += i
            remain -= 1
            if not remain:
                return result
        return -1
",n
"
class Solution(object):
    def countOrders(self, n):
        MOD = 10**9+7
        result = 1
        for i in reversed(range(2, 2*n+1, 2)):
            result = result * i*(i-1)//2 % MOD
        return result
",n
"
class Solution(object):
    def permute(self, num):
        result = []
        used = [False] * len(num)
        self.permuteRecu(result, used, [], num)
        return result

    def permuteRecu(self, result, used, cur, num):
        if len(cur) == len(num):
            result.append(cur[:])
            return
        for i in range(len(num)):
            if not used[i]:
                used[i] = True
                cur.append(num[i])
                self.permuteRecu(result, used, cur, num)
                cur.pop()
                used[i] = False


",n * n!
"class Solution2(object):
    def permute(self, nums):
        res = []
        self.dfs(nums, [], res)
        return res

    def dfs(self, nums, path, res):
        if not nums:
            res.append(path)

        for i in range(len(nums)):
            self.dfs(nums[:i] + nums[i+1:], path + [nums[i]], res)
",n^2 * n!
"
from sortedcontainers import SortedList
import collections



class Solution(object):
    def findXSum(self, nums, k, x):
        def update(v, d, curr):
            if d == 1:
                sl.add((-cnt[v], -v))
            if sl.index((-cnt[v], -v)) < x:
                curr += d*cnt[v]*v
                if x < len(sl):
                    nc, nv = sl[x]
                    curr -= d*nc*nv
            if d != 1:
                sl.remove((-cnt[v], -v))
            return curr

        sl = SortedList()
        cnt = collections.defaultdict(int)
        result = []
        curr = 0
        for i, v in enumerate(nums):
            if v in cnt:
                curr = update(v, -1, curr)
            cnt[v] += 1
            curr = update(v, +1, curr)
            if i < k-1:
                continue
            result.append(curr)
            curr = update(nums[i-(k-1)], -1, curr)
            cnt[nums[i-(k-1)]] -= 1
            if cnt[nums[i-(k-1)]]:
                curr = update(nums[i-(k-1)], +1, curr)
            else:
                del cnt[nums[i-(k-1)]]
        return result
",nlogn
"
class Solution(object):
    def arrangeWords(self, text):
        result = text.split()
        result[0] = result[0].lower()
        result.sort(key=len) 
        result[0] = result[0].title()
        return "" "".join(result)
",nlogn
"
import itertools



class Solution(object):
    def findMinimumOperations(self, s1, s2, s3):
        for i, (a, b, c) in enumerate(zip(s1, s2, s3)):
            if not a == b == c:
                break
        else:
            i += 1
        return len(s1)+len(s2)+len(s3)-3*i if i else -1
",n
"

class Solution(object):
    def maxMoves(self, grid):
        dp = [True]*len(grid)
        result = 0
        for c in range(len(grid[0])-1):
            new_dp = [False]*len(grid)
            for r in range(len(grid)):
                if not dp[r]:
                    continue
                if grid[r][c] < grid[r][c+1]:
                    new_dp[r] = True
                if r-1 >= 0 and grid[r][c] < grid[r-1][c+1]:
                    new_dp[r-1] = True
                if r+1 < len(grid) and grid[r][c] < grid[r+1][c+1]:
                    new_dp[r+1] = True
            dp = new_dp
            if not sum(dp):
                break
        else:
            c = len(grid[0])-1
        return c


",m * n
"
class Solution2(object):
    def maxMoves(self, grid):
        dp = [0]*len(grid)
        for c in reversed(range(len(grid[0])-1)):
            new_dp = [0]*len(grid)
            for r in range(len(grid)):
                if grid[r][c] < grid[r][c+1]:
                    new_dp[r] = max(new_dp[r], dp[r]+1)
                if r-1 >= 0 and grid[r][c] < grid[r-1][c+1]:
                    new_dp[r] = max(new_dp[r], dp[r-1]+1)
                if r+1 < len(grid) and grid[r][c] < grid[r+1][c+1]:
                    new_dp[r] = max(new_dp[r], dp[r+1]+1)
            dp = new_dp
        return max(dp)


",m * n
"
class Solution3(object):
    def maxMoves(self, grid):
        q = set(range(len(grid)))
        for c in range(len(grid[0])-1):
            new_q = set()
            for r in q:
                if grid[r][c] < grid[r][c+1]:
                    new_q.add(r)
                if r-1 >= 0 and grid[r][c] < grid[r-1][c+1]:
                    new_q.add(r-1)
                if r+1 < len(grid) and grid[r][c] < grid[r+1][c+1]:
                    new_q.add(r+1)
            q = new_q
            if not q:
                break
        else:
            c = len(grid[0])-1
        return c
",m * n
"
import string


class Solution(object):
    def uniqueLetterString(self, S):
        M = 10**9 + 7
        index = {c: [-1, -1] for c in string.ascii_uppercase}
        result = 0
        for i, c in enumerate(S):
            k, j = index[c]
            result = (result + (i-j) * (j-k)) % M
            index[c] = [j, i]
        for c in index:
            k, j = index[c]
            result = (result + (len(S)-j) * (j-k)) % M
        return result

",n
"
class Solution(object):
    def findNumberOfLIS(self, nums):
        result, max_len = 0, 0
        dp = [[1, 1] for _ in range(len(nums))] 
        for i in range(len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    if dp[i][0] == dp[j][0]+1:
                        dp[i][1] += dp[j][1]
                    elif dp[i][0] < dp[j][0]+1:
                        dp[i] = [dp[j][0]+1, dp[j][1]]
            if max_len == dp[i][0]:
                result += dp[i][1]
            elif max_len < dp[i][0]:
                max_len = dp[i][0]
                result = dp[i][1]
        return result

",n^2
"
class Solution(object):
    def numOfArrays(self, n, m, k):
        MOD = 10**9 + 7
        dp = [[[0]*(k+1) for _ in range(m+1)] for _ in range(2)]
        prefix_dp = [[[0]*(k+1) for _ in range(m+1)] for _ in range(2)]
        for i in range(1, m+1):
            dp[1][i][1] = 1
            prefix_dp[1][i][1] = (prefix_dp[1][i-1][1] + dp[1][i][1])%MOD
        for l in range(2, n+1):
            for i in range(1, m+1):
                for j in range(1, k+1):
                    dp[l%2][i][j] = (i*dp[(l-1)%2][i][j]%MOD + prefix_dp[(l-1)%2][i-1][j-1])%MOD
                    prefix_dp[l%2][i][j] = (prefix_dp[l%2][i-1][j] + dp[l%2][i][j])%MOD
        return prefix_dp[n%2][m][k]
",n * m * k
"
class Solution(object):
    def maximizeSweetness(self, sweetness, K):
        def check(sweetness, K, x):
            curr, cuts = 0, 0
            for s in sweetness:
                curr += s
                if curr >= x:
                    cuts += 1
                    curr = 0
            return cuts >= K+1

        left, right = min(sweetness), sum(sweetness)//(K+1)
        while left <= right:
            mid = left + (right-left)//2
            if not check(sweetness, K, mid):
                right = mid-1
            else:
                left = mid+1
        return right
",nlogn
"

class Solution(object):
    def findKOr(self, nums, k):
        return sum(1<<i for i in range(max(nums).bit_length()) if sum((x&(1<<i)) != 0 for x in nums) >= k)
",nlogr
"
class Solution(object):
    def interpret(self, command):
        result, i = [], 0
        while i < len(command):
            if command[i] == 'G':
                result += [""G""]
                i += 1
            elif command[i] == '(' and command[i+1] == ')':
                result += [""o""]
                i += 2
            else:
                result += [""al""]
                i += 4
        return """".join(result)
",n
"
import operator
from functools import reduce


class Solution(object):
    def getXORSum(self, arr1, arr2):
        return reduce(operator.xor, arr1) & reduce(operator.xor, arr2)
",n
"
class Solution(object):
    def allCellsDistOrder(self, R, C, r0, c0):
        def append(R, C, r, c, result):
            if 0 <= r < R and 0 <= c < C:
                result.append([r, c])
            
        result = [[r0, c0]]
        for d in range(1, R+C):
            append(R, C, r0-d, c0, result)
            for x in range(-d+1, d):
                append(R, C, r0+x, c0+abs(x)-d, result)
                append(R, C, r0+x, c0+d-abs(x), result)
            append(R, C, r0+d, c0, result)
        return result
",m * n
"

class Solution(object):
    def maximumSubtreeSize(self, edges, colors):
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [1]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    stk.append((4, (ret,)))
                    stk.append((2, (u, p, ret, 0)))
                elif step == 2:
                    u, p, ret, i = args
                    if i == len(adj[u]):
                        continue
                    v = adj[u][i]
                    stk.append((2, (u, p, ret, i+1)))
                    if v == p:
                        continue
                    new_ret = [1]
                    stk.append((3, (v, u, new_ret, ret)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    v, u, new_ret, ret = args
                    if ret[0] == -1:
                        continue 
                    if new_ret[0] == 0 or colors[v] != colors[u]:
                        ret[0] = -1
                        continue
                    ret[0] += new_ret[0]
                elif step == 4:
                    ret = args[0]
                    result = max(result, ret[0])
            return result

        adj = [[] for _ in range(len(colors))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()


",n
"
class Solution2(object):
    def maximumSubtreeSize(self, edges, colors):
        def dfs(u, p):
            cnt = 1
            for v in adj[u]:
                if v == p:
                    continue
                c = dfs(v, u)
                if cnt == -1:
                    continue
                if c == -1 or colors[v] != colors[u]:
                    cnt = -1
                    continue
                cnt += c
            result[0] = max(result[0], cnt)
            return cnt

        adj = [[] for _ in range(len(colors))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1)
        return result[0]
",n
"




class Solution(object):
    def getMinDistSum(self, positions):
        EPS = 1e-6
        def norm(p1, p2):
            return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)**0.5
        
        def geometry_median(positions, median):
            numerator, denominator = [0.0, 0.0], 0.0
            for p in positions:
                l = norm(median, p)
                if not l:
                    continue                       
                numerator[0] += p[0]/l
                numerator[1] += p[1]/l
                denominator += 1/l
            if denominator == 0.0:
                return True, None
            return False, [numerator[0]/denominator, numerator[1]/denominator]

        median = [float(sum(p[0] for p in positions))/len(positions),
                  float(sum(p[1] for p in positions))/len(positions)]
        prev_median = [float(""-inf""), float(""-inf"")]
        while norm(median, prev_median)*len(positions) > EPS:
            stopped, new_median = geometry_median(positions, median)
            if stopped:
                break
            median, prev_median = new_median, median
        return sum(norm(median, p) for p in positions)


",n * iter
"class Solution2(object):
    def getMinDistSum(self, positions):
        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        EPS = 1e-6
        def dist(positions, p):
            return sum(((p[0]-x)**2 + (p[1]-y)**2)**0.5 for x, y in positions)
        
        median = [0.0, 0.0]
        median[0] = float(sum(x for x, _ in positions))/len(positions)
        median[1] = float(sum(y for _, y in positions))/len(positions)
        result = dist(positions, median)
        delta = float(max(max(positions, key=lambda x: x[0])[0],
                          max(positions, key=lambda x: x[1])[1])) - \
                float(min(min(positions, key=lambda x: x[0])[0],
                          min(positions, key=lambda x: x[1])[1]))
        while delta > EPS:
            for dx, dy in DIRECTIONS:
                new_median = [median[0] + delta*dx, median[1] + delta*dy]
                nd = dist(positions, new_median)
                if nd < result: 
                    result = nd 
                    median = new_median
                    break 
            else:
                delta /= 2.0
        return result 
",n * iter
"
class Solution(object):
    def minimumDeleteSum(self, s1, s2):
        dp = [[0] * (len(s2)+1) for _ in range(2)]
        for j in range(len(s2)):
            dp[0][j+1] = dp[0][j] + ord(s2[j])

        for i in range(len(s1)):
            dp[(i+1)%2][0] = dp[i%2][0] + ord(s1[i])
            for j in range(len(s2)):
                if s1[i] == s2[j]:
                    dp[(i+1)%2][j+1] = dp[i%2][j]
                else:
                    dp[(i+1)%2][j+1] = min(dp[i%2][j+1] + ord(s1[i]), \
                                           dp[(i+1)%2][j] + ord(s2[j]))

        return dp[len(s1)%2][-1]


",m * n
"class Solution2(object):
    def minimumDeleteSum(self, s1, s2):
        dp = [[0] * (len(s2)+1) for _ in range(len(s1)+1)]
        for i in range(len(s1)):
            dp[i+1][0] = dp[i][0] + ord(s1[i])
        for j in range(len(s2)):
            dp[0][j+1] = dp[0][j] + ord(s2[j])

        for i in range(len(s1)):
            for j in range(len(s2)):
                if s1[i] == s2[j]:
                    dp[i+1][j+1] = dp[i][j]
                else:
                    dp[i+1][j+1] = min(dp[i][j+1] + ord(s1[i]), \
                                       dp[i+1][j] + ord(s2[j]))

        return dp[-1][-1]

",m * n
"
import collections


class Solution(object):
    def shortestBridge(self, A):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        def get_islands(A):
            islands = []
            done = set()
            for r, row in enumerate(A):
                for c, val in enumerate(row):
                    if val == 0 or (r, c) in done:
                        continue
                    s = [(r, c)]
                    lookup = set(s)
                    while s:
                        node = s.pop()
                        for d in directions:
                            nei = node[0]+d[0], node[1]+d[1]
                            if not (0 <= nei[0] < len(A) and 0 <= nei[1] < len(A[0])) or \
                               nei in lookup or A[nei[0]][nei[1]] == 0:
                                continue
                            s.append(nei)
                            lookup.add(nei)
                    done |= lookup
                    islands.append(lookup)
                    if len(islands) == 2:
                        break
            return islands

        lookup, target = get_islands(A)
        q = collections.deque([(node, 0) for node in lookup])
        while q:
            node, dis = q.popleft()
            if node in target:
                return dis-1
            for d in directions:
                nei = node[0]+d[0], node[1]+d[1]
                if not (0 <= nei[0] < len(A) and 0 <= nei[1] < len(A[0])) or \
                   nei in lookup:
                    continue
                q.append((nei, dis+1))
                lookup.add(nei)
",n^2
"
import collections


class Solution(object):
    def areOccurrencesEqual(self, s):
        return len(set(collections.Counter(s).values())) == 1
",n
"
class Solution(object):
    def largestPerimeter(self, A):
        A.sort()
        for i in reversed(range(len(A) - 2)):
            if A[i] + A[i+1] > A[i+2]:
                return A[i] + A[i+1] + A[i+2]
        return 0
",nlogn
"

class Solution(object):
    def minOperations(self, queries):
        result = 0
        for l, r in queries:
            total = 0
            base = i = 1
            while base <= r:
                nl, nr = max(l, base), min(r, 4*base-1)
                if nl <= nr:
                    total += i*(nr-nl+1)
                i += 1
                base *= 4
            result += (total+1)//2
        return result
",qlogr
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def __init__(self):
        self.__memo = {1: [TreeNode(0)]}
    
    def allPossibleFBT(self, N):
        if N % 2 == 0:
            return []

        if N not in self.__memo:
            result = []
            for i in range(N):
                for left in self.allPossibleFBT(i):
                    for right in self.allPossibleFBT(N-1-i):
                        node = TreeNode(0)
                        node.left = left
                        node.right = right
                        result.append(node)
            self.__memo[N] = result

        return self.__memo[N]
 

",n * 4^n / n^(3/2)
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def __init__(self, root):
        def dfs(node, v, lookup):
            if not node:
                return
            node.val = v    
            lookup.add(v)
            dfs(node.left, 2*v+1, lookup)
            dfs(node.right, 2*v+2, lookup)

        self.__lookup = set()
        dfs(root, 0, self.__lookup)

    def find(self, target):
        return target in self.__lookup 
",n
"
class Solution(object):
    def removeOuterParentheses(self, S):
        deep = 1
        result, cnt = [], 0
        for c in S:
            if c == '(' and cnt >= deep:
                result.append(c)
            if c == ')' and cnt > deep:
                result.append(c)
            cnt += 1 if c == '(' else -1
        return """".join(result)
",n
"
class Solution(object):
    def complexNumberMultiply(self, a, b):
        ra, ia = list(map(int, a[:-1].split('+')))
        rb, ib = list(map(int, b[:-1].split('+')))
        return '%d+%di' % (ra * rb - ia * ib, ra * ib + ia * rb)

",1
"
class Solution(object):
    def nthMagicalNumber(self, N, A, B):
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        def check(A, B, N, lcm, target):
            return target//A + target//B - target//lcm >= N

        lcm = A*B // gcd(A, B)
        left, right = min(A, B), max(A, B)*N
        while left <= right:
            mid = left + (right-left)//2
            if check(A, B, N, lcm, mid):
                right = mid-1
            else:
                left = mid+1
        return left % (10**9 + 7)

",logn
"

class Solution(object):
    def rearrangeArray(self, nums):
        pos, neg = 0, 1
        result = [0]*len(nums)
        for x in nums:
            if x > 0:
                result[pos] = x
                pos += 2
            else:
                result[neg] = x
                neg += 2
        return result


",n
"
class Solution2(object):
    def rearrangeArray(self, nums):
        def pos():
            for x in nums:
                if x > 0:
                    yield x
        
        def neg():
            for x in nums:
                if x < 0:
                    yield x
        
        gen_pos = pos()
        gen_neg = neg()
        return [next(gen_pos) if i%2 == 0 else next(gen_neg)  for i in range(len(nums))]


",n
"
class Solution3(object):
    def rearrangeArray(self, nums):
        pos, neg = [], []
        for i in reversed(range(len(nums))):
            if nums[i] > 0:
                pos.append(nums[i])
            else:
                neg.append(nums[i])
        result = []
        for i in range(len(nums)):
            if i%2 == 0:
                result.append(pos.pop())
            else:
                result.append(neg.pop())
        return result
",n
"
class Solution(object):
    def isThree(self, n):
        cnt = 0
        i = 1
        while i*i <= n and cnt <= 3:
            if n%i == 0:
                cnt += 1 if i*i == n else 2
            i += 1
        return cnt == 3
",sqrt(n)
"
class Solution(object):
    def maxArea(self, height):
        max_area, i, j = 0, 0, len(height) - 1
        while i < j:
            max_area = max(max_area, min(height[i], height[j]) * (j - i))
            if height[i] < height[j]:
                i += 1
            else:
                j -= 1
        return max_area

",n
"
import collections



class Solution(object):
    def maximumLength(self, nums, k):
        lookup = {x:i for i, x in enumerate(set(nums))}
        dp = [[0]*len(lookup) for _ in range(k+1)]
        result = [0]*(k+1)
        for x in nums:
            x = lookup[x]
            for i in reversed(range(k+1)):
                dp[i][x] = max(dp[i][x], result[i-1] if i-1 >= 0 else 0)+1
                result[i] = max(result[i], dp[i][x])
        return result[k]


",n * k
"import collections



class Solution2(object):
    def maximumLength(self, nums, k):
        dp = [collections.defaultdict(int) for _ in range(k+1)]
        result = [0]*(k+1)
        for x in nums:
            for i in reversed(range(k+1)):
                dp[i][x] = max(dp[i][x], result[i-1] if i-1 >= 0 else 0)+1
                result[i] = max(result[i], dp[i][x])
        return result[k]
",n * k
"
class Solution(object):
    def fizzBuzz(self, n):
        result = []

        for i in range(1, n+1):
            if i % 15 == 0:
                result.append(""FizzBuzz"")
            elif i % 5 == 0:
                result.append(""Buzz"")
            elif i % 3 == 0:
                result.append(""Fizz"")
            else:
                result.append(str(i))

        return result

    def fizzBuzz2(self, n):
        l = [str(x) for x in range(n + 1)]
        l3 = list(range(0, n + 1, 3))
        l5 = list(range(0, n + 1, 5))
        for i in l3:
            l[i] = 'Fizz'
        for i in l5:
            if l[i] == 'Fizz':
                l[i] += 'Buzz'
            else:
                l[i] = 'Buzz'
        return l[1:]

    def fizzBuzz3(self, n):
        return ['Fizz' * (not i % 3) + 'Buzz' * (not i % 5) or str(i) for i in range(1, n + 1)]

    def fizzBuzz4(self, n):
        return ['FizzBuzz'[i % -3 & -4:i % -5 & 8 ^ 12] or repr(i) for i in range(1, n + 1)]

",n
"
import collections


class Solution(object):
    def findDuplicate(self, paths):
        files = collections.defaultdict(list)
        for path in paths:
           s = path.split("" "")
           for i in range(1,len(s)):
               file_name = s[0] + ""/"" + s[i][0:s[i].find(""("")]
               file_content = s[i][s[i].find(""("")+1:s[i].find("")"")]
               files[file_content].append(file_name)

        result = []
        for file_content, file_names in files.items():
            if len(file_names)>1:
                result.append(file_names)
        return result

",n * l
"
import itertools



class Solution(object):
    def maximumProfit(self, present, future, budget):
        dp = [0]*(budget+1)
        for i, (p, f) in enumerate(zip(present, future)):
            if f-p < 0:
                continue
            for b in reversed(range(p, budget+1)):
                dp[b] = max(dp[b], dp[b-p]+(f-p))
        return dp[-1]


",n * b
"import itertools



class Solution2(object):
    def maximumProfit(self, present, future, budget):
        dp = [[0]*(budget+1) for _ in range(2)]
        for i, (p, f) in enumerate(zip(present, future)):
            for b in range(budget+1):
                dp[(i+1)%2][b] = max(dp[i%2][b], (dp[i%2][b-p]+(f-p) if b-p >= 0 else 0))
        return dp[len(present)%2][-1]
",n * b
"

class Solution(object):
    def maxDifference(self, s):
        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        mn, mx = float(""inf""), 0
        for x in cnt:
            if not x:
                continue
            if x%2 == 0:
                mn = min(mn, x)
            else:
                mx = max(mx, x)
        return mx-mn
",n + 26
"
class Solution(object):
    def squareIsWhite(self, coordinates):
        return (ord(coordinates[0])-ord('a'))%2 != (ord(coordinates[1])-ord('1'))%2
",1
"

class Solution(object):
    def findPeaks(self, mountain):
        return [i for i in range(1, len(mountain)-1) if mountain[i-1] < mountain[i] > mountain[i+1]]
",n
"
class Solution(object):
    def fractionToDecimal(self, numerator, denominator):
        result = """"
        if (numerator > 0 and denominator < 0) or (numerator < 0 and denominator > 0):
            result = ""-""

        dvd, dvs = abs(numerator), abs(denominator)
        result += str(dvd / dvs)
        dvd %= dvs

        if dvd > 0:
            result += "".""

        lookup = {}
        while dvd and dvd not in lookup:
            lookup[dvd] = len(result)
            dvd *= 10
            result += str(dvd / dvs)
            dvd %= dvs

        if dvd in lookup:
            result = result[:lookup[dvd]] + ""("" + result[lookup[dvd]:] + "")""

        return result


",logn
"

class Solution(object):
    def isConsecutive(self, nums):
        return max(nums)-min(nums)+1 == len(nums) == len(set(nums))


",n
"
class Solution2(object):
    def isConsecutive(self, nums):
        nums.sort()
        return all(nums[i]+1 == nums[i+1] for i in range(len(nums)-1))
",nlogn
"
import itertools
from fractions import gcd


class Solution(object):
    def maxScore(self, nums):
        def popcount(n):
            count = 0
            while n:
                n &= n-1
                count += 1
            return count

        def bits(mask):
            result = []
            i = 0
            while mask:
                if mask&1:
                    result.append(i)
                i += 1
                mask >>= 1
            return result
            
        dp = [0]*(2**len(nums))
        for mask in range(3, len(dp)):
            cnt = popcount(mask)
            if cnt%2:
                continue
            for i, j in itertools.combinations(bits(mask), 2): 
                dp[mask] = max(dp[mask], cnt//2*gcd(nums[i], nums[j]) + dp[mask^(1<<i)^(1<<j)])
        return dp[-1]
",n^2 * 2^n
"
class Solution(object):
    def shortestSuperstring(self, A):
        n = len(A)
        overlaps = [[0]*n for _ in range(n)]
        for i, x in enumerate(A):
            for j, y in enumerate(A):
                for l in reversed(range(min(len(x), len(y)))):
                    if y[:l].startswith(x[len(x)-l:]):
                        overlaps[i][j] = l
                        break

        dp = [[0]*n for _ in range(1<<n)]
        prev = [[None]*n for _ in range(1<<n)]
        for mask in range(1, 1<<n):
            for bit in range(n):
                if ((mask>>bit) & 1) == 0:
                    continue
                prev_mask = mask^(1<<bit)
                for i in range(n):
                    if ((prev_mask>>i) & 1) == 0:
                        continue
                    value = dp[prev_mask][i] + overlaps[i][bit]
                    if value > dp[mask][bit]:
                        dp[mask][bit] = value
                        prev[mask][bit] = i
        
        bit = max(range(n), key = dp[-1].__getitem__)
        words = []
        mask = (1<<n)-1
        while bit is not None:
            words.append(bit)
            mask, bit = mask^(1<<bit), prev[mask][bit]
        words.reverse()
        lookup = set(words)
        words.extend([i for i in range(n) if i not in lookup])

        result = [A[words[0]]]
        for i in range(1, len(words)):
            overlap = overlaps[words[i-1]][words[i]]
            result.append(A[words[i]][overlap:])
        return """".join(result)
",n^2 * (l^2 + 2^n)
"
class Solution(object):
    def findLengthOfLCIS(self, nums):
        result, count = 0, 0
        for i in range(len(nums)):
            if i == 0 or nums[i-1] < nums[i]:
                count += 1
                result = max(result, count)
            else:
                count = 1
        return result

",n
"
class Solution(object):
    def rob(self, root):
        def robHelper(root):
            if not root:
                return (0, 0)
            left, right = robHelper(root.left), robHelper(root.right)
            return (root.val + left[1] + right[1], max(left) + max(right))

        return max(robHelper(root))

",n
"
import collections


class Solution(object):
    def numTilePossibilities(self, tiles):
        fact = [0.0]*(len(tiles)+1)
        fact[0] = 1.0
        for i in range(1, len(tiles)+1):
            fact[i] = fact[i-1]*i
        count = collections.Counter(tiles)

        
        coeff = [0.0]*(len(tiles)+1)
        coeff[0] = 1.0
        for i in count.values():
            new_coeff = [0.0]*(len(tiles)+1)
            for j in range(len(coeff)):
                for k in range(i+1):
                    if k+j >= len(new_coeff):
                        break
                    new_coeff[j+k] += coeff[j]*1.0/fact[k]
            coeff = new_coeff

        result = 0
        for i in range(1, len(coeff)):
            result += int(round(coeff[i]*fact[i]))
        return result


",n^2
"class Solution2(object):
    def numTilePossibilities(self, tiles):
        def backtracking(counter):
            total = 0
            for k, v in counter.items():
                if not v:
                    continue
                counter[k] -= 1
                total += 1+backtracking(counter)
                counter[k] += 1
            return total

        return backtracking(collections.Counter(tiles))
",r
"
class Solution(object):
    def repeatedNTimes(self, A):
        for i in range(2, len(A)):
            if A[i-1] == A[i] or A[i-2] == A[i]:
                return A[i]
        return A[0]
",n
"
import collections


class Solution(object):
    def gridIllumination(self, N, lamps, queries):
        lookup = set()
        row = collections.defaultdict(int)
        col = collections.defaultdict(int)
        diag = collections.defaultdict(int)
        anti = collections.defaultdict(int)
        
        for r, c in lamps:
            if (r, c) in lookup:
                continue
            lookup.add((r, c))
            row[r] += 1
            col[c] += 1
            diag[r-c] += 1
            anti[r+c] += 1
        
        result = []
        for r, c in queries:
            if not (row[r] or col[c] or diag[r-c] or anti[r+c]):
                result.append(0)
                continue
            result.append(1)                
            for nr in range(max(r-1, 0), min(r+1, N-1)+1):
                for nc in range(max(c-1, 0), min(c+1, N-1)+1):
                    if (nr, nc) not in lookup:
                        continue
                    lookup.remove((nr, nc))
                    row[nr] -= 1
                    col[nc] -= 1
                    diag[nr-nc] -= 1
                    anti[nr+nc] -= 1
        return result
",l + q
"
import collections



class Solution(object):
    def distinctSubarraysWithAtMostKOddIntegers(self, A, K):
        def countDistinct(A, left, right, trie): 
            result = 0
            for i in reversed(range(left, right+1)):
                if A[i] not in trie:
                    result += 1
                trie = trie[A[i]]
            return result

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result, left, count = 0, 0, 0
        for right in range(len(A)):
            count += A[right]%2
            while count > K:
                count -= A[left]%2
                left += 1
            result += countDistinct(A, left, right, trie)
        return result


",n^2
"
class Solution2(object):
    def distinctSubarraysWithAtMostKOddIntegers(self, A, K):
        def countDistinct(A, left, right, trie): 
            result = 0
            for i in range(left, right+1):
                if A[i] not in trie:
                    result += 1
                trie = trie[A[i]]
            return result

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result = 0
        for left in range(len(A)):
            count = 0
            for right in range(left, len(A)):
                count += A[right]%2
                if count > K:
                    right -= 1
                    break
            result += countDistinct(A, left, right, trie)
        return result
",n^2
"

class Solution(object):
    def longestMountain(self, A):
        result, up_len, down_len = 0, 0, 0
        for i in range(1, len(A)):
            if (down_len and A[i-1] < A[i]) or A[i-1] == A[i]:
                up_len, down_len = 0, 0
            up_len += A[i-1] < A[i]
            down_len += A[i-1] > A[i]
            if up_len and down_len:
                result = max(result, up_len+down_len+1)
        return result

",n
"

class Solution(object):
    def sortArray(self, nums):
        def mergeSort(left, right, nums):
            if left == right:
                return
            mid = left + (right-left)//2
            mergeSort(left, mid, nums)
            mergeSort(mid+1, right,  nums)
            r = mid+1
            tmp = []
            for l in range(left, mid+1):
                while r <= right and nums[r] < nums[l]:
                    tmp.append(nums[r])
                    r += 1
                tmp.append(nums[l])
            nums[left:left+len(tmp)] = tmp

        mergeSort(0, len(nums)-1, nums)
        return nums


",nlogn
"import random

class Solution2(object):
    def sortArray(self, nums):
        def nth_element(nums, left, n, right, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def quickSort(left, right, nums):
            if left > right:
                return
            mid = left + (right-left)//2
            nth_element(nums, left, mid, right)
            quickSort(left, mid-1, nums)
            quickSort(mid+1, right, nums)

        quickSort(0, len(nums)-1, nums)
        return nums
",nlogn
"
import collections


class Solution(object):
    def isPossibleDivide(self, nums, k):
        count = collections.Counter(nums)
        for num in sorted(count.keys()):
            c = count[num]
            if not c:
                continue
            for i in range(num, num+k):
                if count[i] < c:
                    return False
                count[i] -= c
        return True
",nlogn
"
from operator import xor
from functools import reduce


class Solution(object):
    def xorGame(self, nums):
        return reduce(xor, nums) == 0 or \
            len(nums) % 2 == 0

",n
"
class Solution(object):
    def findTarget(self, root, k):
        class BSTIterator(object):
            def __init__(self, root, forward):
                self.__node = root
                self.__forward = forward
                self.__s = []
                self.__cur = None
                next(self)

            def val(self):
                return self.__cur

            def __next__(self):
                while self.__node or self.__s:
                    if self.__node:
                        self.__s.append(self.__node)
                        self.__node = self.__node.left if self.__forward else self.__node.right
                    else:
                        self.__node = self.__s.pop()
                        self.__cur = self.__node.val
                        self.__node = self.__node.right if self.__forward else self.__node.left
                        break


        if not root:
            return False
        left, right = BSTIterator(root, True), BSTIterator(root, False)
        while left.val() < right.val():
            if left.val() + right.val() == k:
                return True
            elif left.val() + right.val() < k:
                next(left)
            else:
                next(right)
        return False

",n
"
import itertools


class Solution(object):
    def minNumberOfSemesters(self, n, dependencies, k):
        reqs = [0]*n
        for u, v in dependencies:
            reqs[v-1] |= 1 << (u-1)
        dp = [n]*(1<<n)
        dp[0] = 0
        for mask in range(1<<n):
            candidates = []
            for v in range(n):
                if (mask&(1<<v)) == 0 and (mask&reqs[v]) == reqs[v]:
                    candidates.append(v)
            for choice in itertools.combinations(candidates, min(len(candidates), k)):
                new_mask = mask
                for v in choice:
                    new_mask |= 1<<v
                dp[new_mask] = min(dp[new_mask], dp[mask]+1)
        return dp[-1]


","(n * C(c, min(c, k))) * 2^n"
"import collections
import heapq







class Solution_WA(object):
    def minNumberOfSemesters(self, n, dependencies, k):
        def dfs(graph, i, depths):
            if depths[i] == -1:
                depths[i] = max(dfs(graph, child, depths) for child in graph[i])+1 if i in graph else 1
            return depths[i]
            
        degrees = [0]*n
        graph = collections.defaultdict(list)
        for u, v in dependencies:
            graph[u-1].append(v-1)
            degrees[v-1] += 1
        depths = [-1]*n
        for i in range(n):
            dfs(graph, i, depths)
        max_heap = []
        for i in range(n):
            if not degrees[i]:
                heapq.heappush(max_heap, (-depths[i], i))
        result = 0
        while max_heap:
            new_q = []
            for _ in range(min(len(max_heap), k)):
                _, node = heapq.heappop(max_heap)
                if node not in graph:
                    continue
                for child in graph[node]:
                    degrees[child] -= 1
                    if not degrees[child]:
                        new_q.append(child)
            result += 1
            for node in new_q:
                heapq.heappush(max_heap, (-depths[node], node))
        return result
",nlogn + e
"

class Solution(object):
    def canMakePalindromeQueries(self, s, queries):
        def check(left1, right1, left2, right2):
            def same(left, right):
                return all(prefixs1[right+1][i]-prefixs1[left][i] == prefixs2[right+1][i]-prefixs2[left][i] for i in range(d))

            min_left, max_left = min(left1, left2), max(left1, left2)
            min_right, max_right = min(right1, right2), max(right1, right2)
            if not (prefix[min_left]-prefix[0] == prefix[-1]-prefix[max_right+1] == 0):
                return False
            if min_right < max_left: 
                return prefix[max_left]-prefix[min_right+1] == 0 and same(min_left, min_right) and same(max_left, max_right)
            if (left1 == min_left) == (right1 == max_right): 
                return same(min_left, max_right)
            p1, p2 = (prefixs1, prefixs2) if min_left == left1 else (prefixs2, prefixs1)
            diff1 = [(p1[min_right+1][i]-p1[min_left][i])-(p2[max_left][i]-p2[min_left][i]) for i in range(d)]
            diff2 = [(p2[max_right+1][i]-p2[max_left][i])-(p1[max_right+1][i]-p1[min_right+1][i]) for i in range(d)]
            return diff1 == diff2 and all(x >= 0 for x in diff1) 

        lookup = [-1]*26
        d = 0
        for x in s:
            if lookup[ord(x)-ord('a')] != -1:
                continue
            lookup[ord(x)-ord('a')] = d
            d += 1
        prefix = [0]*(len(s)//2+1)
        prefixs1 = [[0]*d for _ in range(len(s)//2+1)]
        prefixs2 = [[0]*d for _ in range(len(s)//2+1)]
        for i in range(len(s)//2):
            x, y = lookup[ord(s[i])-ord('a')], lookup[ord(s[~i])-ord('a')]
            prefix[i+1] = prefix[i]+int(x != y)
            for j in range(d):
                prefixs1[i+1][j] = prefixs1[i][j]+int(j == x)
                prefixs2[i+1][j] = prefixs2[i][j]+int(j == y)
        return [check(q[0], q[1], (len(s)-1)-q[3], (len(s)-1)-q[2]) for q in queries]


",26 + d * n + d * q
"
class Solution2(object):
    def canMakePalindromeQueries(self, s, queries):
        def check(left1, right1, left2, right2):
            def same(left, right):
                return all(prefixs1[right+1][i]-prefixs1[left][i] == prefixs2[right+1][i]-prefixs2[left][i] for i in range(26))

            min_left, max_left = min(left1, left2), max(left1, left2)
            min_right, max_right = min(right1, right2), max(right1, right2)
            if not (prefix[min_left]-prefix[0] == prefix[-1]-prefix[max_right+1] == 0):
                return False
            if min_right < max_left: 
                return prefix[max_left]-prefix[min_right+1] == 0 and same(min_left, min_right) and same(max_left, max_right)
            if (left1 == min_left) == (right1 == max_right): 
                return same(min_left, max_right)
            p1, p2 = (prefixs1, prefixs2) if min_left == left1 else (prefixs2, prefixs1)
            diff1 = [(p1[min_right+1][i]-p1[min_left][i])-(p2[max_left][i]-p2[min_left][i]) for i in range(26)]
            diff2 = [(p2[max_right+1][i]-p2[max_left][i])-(p1[max_right+1][i]-p1[min_right+1][i]) for i in range(26)]
            return diff1 == diff2 and all(x >= 0 for x in diff1) 

        prefix = [0]*(len(s)//2+1)
        prefixs1 = [[0]*26 for _ in range(len(s)//2+1)]
        prefixs2 = [[0]*26 for _ in range(len(s)//2+1)]
        for i in range(len(s)//2):
            x, y = ord(s[i])-ord('a'), ord(s[~i])-ord('a')
            prefix[i+1] = prefix[i]+int(x != y)
            for j in range(26):
                prefixs1[i+1][j] = prefixs1[i][j]+int(j == x)
                prefixs2[i+1][j] = prefixs2[i][j]+int(j == y)
        return [check(q[0], q[1], (len(s)-1)-q[3], (len(s)-1)-q[2]) for q in queries]
",26 * n + 26 * q
"

class Solution(object):
    def minimumRelativeLosses(self, prices, queries):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        prices.sort()
        prefix = [0]*(len(prices)+1)
        for i in range(len(prices)):
            prefix[i+1] = prefix[i]+prices[i]
        result = []
        for k, m in queries:
            cnt = binary_search(0, m-1, lambda x: k-(prices[-(m-x)]-k) <= prices[(x+1)-1]-0)
            a = prefix[-1]-prefix[-1-(m-cnt)]-(m-cnt)*k
            b = prefix[cnt]+(m-cnt)*k
            result.append(b-a)
        return result
",(n + q) * logn
"

class Solution(object):
    def flowerGame(self, n, m):
        return (n*m)//2
",1
"
class Solution(object):
    def isOneEditDistance(self, s, t):
        m, n = len(s), len(t)
        if m > n:
            return self.isOneEditDistance(t, s)
        if n - m > 1:
            return False

        i, shift = 0, n - m
        while i < m and s[i] == t[i]:
            i += 1
        if shift == 0:
            i += 1
        while i < m and s[i] == t[i + shift]:
            i += 1

        return i == m


",m + n
"
import threading


class Solution(object):
    def __init__(self):
        self._l = [threading.Lock() for _ in range(5)]

    def wantsToEat(self, philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork):
        left, right = philosopher, (philosopher+4)%5
        first, second = left, right
        if  philosopher%2 == 0:
            first, second = left, right
        else:
            first, second = right, left

        with self._l[first]:
            with self._l[second]:
                pickLeftFork()
                pickRightFork()
                eat()
                putLeftFork()
                putRightFork()
",n
"
class Solution(object):
    def getMinimumDifference(self, root):
        def inorderTraversal(root, prev, result):
            if not root:
                return (result, prev)

            result, prev = inorderTraversal(root.left, prev, result)
            if prev: result = min(result, root.val - prev.val)
            return inorderTraversal(root.right, root, result)

        return inorderTraversal(root, None, float(""inf""))[0]

",n
"

class Solution(object):
    def isReachable(self, targetX, targetY):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a
    
        g = gcd(targetX, targetY)
        return g == (g&~(g-1)) 
","log(min(a, b))"
"
class Solution(object):
    def smallestDistancePair(self, nums, k):
        def possible(guess, nums, k):
            count, left = 0, 0
            for right, num in enumerate(nums):
                while num-nums[left] > guess:
                    left += 1
                count += right-left
            return count >= k

        nums.sort()
        left, right = 0, nums[-1]-nums[0]+1
        while left < right:
            mid = left + (right-left)/2
            if possible(mid, nums, k):
                right = mid
            else:
                left = mid+1
        return left

",nlogn + nlogw
"

class Solution(object):
    def zigzagTraversal(self, grid):
        result = []
        for i in range(len(grid)):
            if i%2 == 0:
                result.extend(grid[i][j] for j in range(0, len(grid[0]), 2))
            else:
                result.extend(grid[i][j] for j in reversed(range(1, len(grid[0]), 2)))
        return result
",n * m
"
class Solution(object):
    def titleToNumber(self, s):
        result = 0
        for i in range(len(s)):
            result *= 26
            result += ord(s[i]) - ord('A') + 1
        return result


",n
"

class Solution(object):
    def maxSum(self, nums):
        mx = max(nums)
        return mx if mx < 0 else sum(x for x in set(nums) if x >= 0)
",n
"
import heapq


class Solution(object):
    def shortestDistance(self, maze, start, destination):
        start, destination = tuple(start), tuple(destination)

        def neighbors(maze, node):
            for dir in [(-1, 0), (0, 1), (0, -1), (1, 0)]:
                cur_node, dist = list(node), 0
                while 0 <= cur_node[0]+dir[0] < len(maze) and \
                      0 <= cur_node[1]+dir[1] < len(maze[0]) and \
                      not maze[cur_node[0]+dir[0]][cur_node[1]+dir[1]]:
                    cur_node[0] += dir[0]
                    cur_node[1] += dir[1]
                    dist += 1
                yield dist, tuple(cur_node)

        heap = [(0, start)]
        visited = set()
        while heap:
            dist, node = heapq.heappop(heap)
            if node in visited: continue
            if node == destination:
                return dist
            visited.add(node)
            for neighbor_dist, neighbor in neighbors(maze, node):
                heapq.heappush(heap, (dist+neighbor_dist, neighbor))

        return -1

","max(r, c) * wlogw"
"

class Solution(object):
    def numberOfStableArrays(self, zero, one, limit):
        MOD = 10**9+7
        dp = [[[0]*2 for _ in range(one+1)] for _ in range(zero+1)]
        for i in range(zero+1):
            dp[i][0][0] = 1 if i <= limit else 0
        for j in range(one+1):
            dp[0][j][1] = 1 if j <= limit else 0
        for i in range(1, zero+1):
            for j in range(1, one+1):
                dp[i][j][0] = (dp[i-1][j][0]+dp[i-1][j][1])%MOD
                dp[i][j][1] = (dp[i][j-1][0]+dp[i][j-1][1])%MOD
                if i-limit-1 >= 0:
                    dp[i][j][0] = (dp[i][j][0]-dp[i-limit-1][j][1])%MOD
                if j-limit-1 >= 0:
                    dp[i][j][1] = (dp[i][j][1]-dp[i][j-limit-1][0])%MOD
        return (dp[-1][-1][0]+dp[-1][-1][1])%MOD
",n * m
"
import collections


class Solution(object):
    def majorityElement(self, nums):
        k, n, cnts = 3, len(nums), collections.defaultdict(int)

        for i in nums:
            cnts[i] += 1
            if len(cnts) == k:
                for j in list(cnts.keys()):
                    cnts[j] -= 1
                    if cnts[j] == 0:
                        del cnts[j]

        for i in list(cnts.keys()):
            cnts[i] = 0

        for i in nums:
            if i in cnts:
                cnts[i] += 1

        result = []
        for i in list(cnts.keys()):
            if cnts[i] > n / k:
                result.append(i)

        return result

    def majorityElement2(self, nums):
        return [i[0] for i in list(collections.Counter(nums).items()) if i[1] > len(nums) / 3]

",n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def removeLeafNodes(self, root, target):
        if not root:
            return None
        root.left = self.removeLeafNodes(root.left, target)
        root.right = self.removeLeafNodes(root.right, target)
        return None if root.left == root.right and root.val == target else root
",n
"
class Solution(object):
    def checkRecord(self, n):
        M = 1000000007
        a0l0, a0l1, a0l2, a1l0, a1l1, a1l2 = 1, 0, 0, 0, 0, 0
        for i in range(n+1):
            a0l2, a0l1, a0l0 = a0l1, a0l0, (a0l0 + a0l1 + a0l2) % M
            a1l2, a1l1, a1l0 = a1l1, a1l0, (a0l0 + a1l0 + a1l1 + a1l2) % M
        return a1l0

",n
"
class Solution(object):
    def construct2DArray(self, original, m, n):
        return [original[i:i+n] for i in range(0, len(original), n)] if len(original) == m*n else []
",m * n
"
from sortedcontainers import SortedList



class Solution(object):
    def minimumPairRemoval(self, nums):
        def add(i):
            if 0 <= i < right[i] < len(nums):
                sl.add([nums[i]+nums[right[i]], i])
                if nums[i] > nums[right[i]]:
                    cnt[0] += 1

        def remove(i):
            if 0 <= i < right[i] < len(nums):
                sl.remove([nums[i]+nums[right[i]], i])
                if nums[i] > nums[right[i]]:
                    cnt[0] -= 1

        left = list(range(-1, (len(nums)+1)-1))
        right = list(range(1, len(nums)+1))
        cnt = [sum(nums[i] > nums[i+1] for i in range(len(nums)-1))]
        sl = SortedList([nums[i]+nums[i+1], i] for i in range(len(nums)-1))
        result = 0
        while cnt[0]:
            _, i = sl[0]
            remove(left[i])
            remove(i)
            remove(right[i])
            nums[i] += nums[right[i]]
            left[right[right[i]]] = i
            right[i] = right[right[i]]
            add(left[i])
            add(i)
            result += 1
        return result
",nlogn
"
class Solution(object):
    def findBall(self, grid):
        result = []
        for c in range(len(grid[0])):
            for r in range(len(grid)):
                nc = c+grid[r][c]
                if not (0 <= nc < len(grid[0]) and grid[r][nc] == grid[r][c]):
                    c = -1
                    break
                c = nc
            result.append(c)
        return result
",m * n
"
import itertools


class Solution(object):
    def shortestToChar(self, S, C):
        result = [len(S)] * len(S)
        prev = -len(S)
        for i in itertools.chain(range(len(S)),
                                 reversed(range(len(S)))):
            if S[i] == C:
                prev = i
            result[i] = min(result[i], abs(i-prev))
        return result

",n
"
class Solution(object):
    def findRestaurant(self, list1, list2):
        lookup = {}
        for i, s in enumerate(list1):
            lookup[s] = i

        result = []
        min_sum = float(""inf"")
        for j, s in enumerate(list2):
            if j > min_sum:
                break
            if s in lookup:
                if j + lookup[s] < min_sum:
                    result = [s]
                    min_sum = j + lookup[s]
                elif j + lookup[s] == min_sum:
                    result.append(s)
        return result

",(m + n) * l
"
class Solution(object):
    def maxAreaOfIsland(self, grid):
        directions = [[-1,  0], [ 1,  0], [ 0,  1], [ 0, -1]]

        def dfs(i, j, grid, area):
            if not (0 <= i < len(grid) and \
                    0 <= j < len(grid[0]) and \
                    grid[i][j] > 0):
                return False
            grid[i][j] *= -1
            area[0] += 1
            for d in directions:
                dfs(i+d[0], j+d[1], grid, area)
            return True

        result = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                area = [0]
                if dfs(i, j, grid, area):
                    result = max(result, area[0])
        return result

",m * n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def smallestFromLeaf(self, root):
        def dfs(node, candidate, result):
            if not node:
                return

            candidate.append(chr(ord('a') + node.val))
            if not node.left and not node.right:
                result[0] = min(result[0], """".join(reversed(candidate)))
            dfs(node.left, candidate, result)
            dfs(node.right, candidate, result)
            candidate.pop()

        result = [""~""]
        dfs(root, [], result)
        return result[0]
",n + l * h
"
import heapq
import collections



class Solution(object):
    def minimumAddedInteger(self, nums1, nums2):
        def check(cnt2, cnt1):
            return all(cnt1.get(k, 0)-v >= 0 for k, v in cnt2.items()) 
            
        mx = max(nums2)
        cnt2 = collections.Counter(nums2)
        return next(d for d in [mx-x for x in heapq.nlargest(3, nums1)] if check(cnt2, collections.Counter(x+d for x in nums1)))


",n
"import collections



class Solution2(object):
    def minimumAddedInteger(self, nums1, nums2):
        def check(cnt2, cnt1):
            return all(cnt1.get(k, 0)-v >= 0 for k, v in cnt2.items()) 
        
        def topk(a, k): 
            result = [float(""-inf"")]*k
            for x in a:
                for i in range(len(result)):
                    if x > result[i]:
                        result[i], x = x, result[i]
            return result
    
        mx = max(nums2)
        cnt2 = collections.Counter(nums2)
        return next(d for d in [mx-x for x in topk(nums1, 3)] if check(cnt2, collections.Counter(x+d for x in nums1)))


",n
"
class Solution3(object):
    def minimumAddedInteger(self, nums1, nums2):
        nums1.sort()
        nums2.sort()
        for i in range(3):
            d = nums2[-1]-nums1[~i]
            cnt = 0
            for j in range(len(nums2)):
                while j+cnt < len(nums1) and nums1[j+cnt]+d != nums2[j]:
                    cnt += 1
            if cnt <= 2:
                return d
        return -1
",nlogn
"

class TreeNode(object):
    def __init__(self, x):
        pass


class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        def iter_dfs(node, p, q):
            result = None
            stk = [(1, (node, [0]))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    curr = int(node == p or node == q)
                    if curr+ret1[0]+ret2[0] == 2 and not result:
                        result = node
                    ret[0] = curr+ret1[0]+ret2[0]
            return result

        return iter_dfs(root, p, q)


",n
"class Solution2(object):
    def lowestCommonAncestor(self, root, p, q):
        def dfs(node, p, q, result):
            if not node:
                return 0
            left = dfs(node.left, p, q, result)
            right = dfs(node.right, p, q, result)
            curr = int(node == p or node == q)
            if curr+left+right == 2 and not result[0]:
                result[0] = node
            return curr+left+right

        result = [0]
        dfs(root, p, q, result)
        return result[0]

",n
"
class Solution(object):
    def numDistinctIslands2(self, grid):
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def dfs(i, j, grid, island):
            if not (0 <= i < len(grid) and \
                    0 <= j < len(grid[0]) and \
                    grid[i][j] > 0):
                return False
            grid[i][j] *= -1
            island.append((i, j))
            for d in directions:
                dfs(i+d[0], j+d[1], grid, island)
            return True

        def normalize(island):
            shapes = [[] for _ in range(8)]
            for x, y in island:
                rotations_and_reflections = [[ x,  y], [ x, -y], [-x, y], [-x, -y],
                                             [ y,  x], [ y, -x], [-y, x], [-y, -x]]
                for i in range(len(rotations_and_reflections)):
                    shapes[i].append(rotations_and_reflections[i])
            for shape in shapes:
                shape.sort() 
                origin = list(shape[0])
                for p in shape:
                    p[0] -= origin[0]
                    p[1] -= origin[1]
            return min(shapes)

        islands = set()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                island = []
                if dfs(i, j, grid, island):
                    islands.add(str(normalize(island)))
        return len(islands)

",(m * n) * log(m * n)
"

class Solution(object):
    def visibleMountains(self, peaks):
        peaks.sort(key=lambda x: (x[0]-x[1], -(x[0]+x[1]))) 
        result = mx = 0
        for i in range(len(peaks)):
            if peaks[i][0]+peaks[i][1] <= mx:
                continue
            mx = peaks[i][0]+peaks[i][1]
            if i+1 == len(peaks) or peaks[i+1] != peaks[i]:
                result += 1
        return result


",nlogn
"
class Solution2(object):
    def visibleMountains(self, peaks):
        def is_covered(a, b):
            x1, y1 = a
            x2, y2 = b
            return x2-y2 <= x1-y1 and x1+y1 <= x2+y2

        peaks.sort()
        stk = []
        for i in range(len(peaks)):
            while stk and is_covered(peaks[stk[-1]], peaks[i]):
                stk.pop()
            if (i-1 == -1 or peaks[i-1] != peaks[i]) and (not stk or not is_covered(peaks[i], peaks[stk[-1]])): 
                stk.append(i)
        return len(stk)
            
",nlogn
"
import itertools


class Solution(object):
    def profitableSchemes(self, G, P, group, profit):
        dp = [[0 for _ in range(G+1)] for _ in range(P+1)]
        dp[0][0] = 1
        for p, g in zip(profit, group):
            for i in reversed(range(P+1)):
                for j in reversed(range(G-g+1)):
                    dp[min(i+p, P)][j+g] += dp[i][j]
        return sum(dp[P]) % (10**9 + 7)

",n * p * g
"

class Solution(object):
    def maximumRows(self, matrix, numSelect):
        def next_popcount(n): 
            lowest_bit = n&-n
            left_bits = n+lowest_bit
            changed_bits = n^left_bits
            right_bits = (changed_bits//lowest_bit)>>2
            return left_bits|right_bits

        masks = [reduce(lambda m, c: m|(matrix[r][-1-c]<<c), range(len(matrix[0])), 0) for r in range(len(matrix))]
        result = 0
        mask = (1<<numSelect)-1
        while mask < 1<<len(matrix[0]):
            result = max(result, sum((m&mask) == m for m in masks))
            mask = next_popcount(mask)
        return result
","m * n + m * C(n, k)"
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def delNodes(self, root, to_delete):
        def delNodesHelper(to_delete_set, root, is_root, result):
            if not root:
                return None
            is_deleted = root.val in to_delete_set
            if is_root and not is_deleted:
                result.append(root)
            root.left = delNodesHelper(to_delete_set, root.left, is_deleted, result)
            root.right = delNodesHelper(to_delete_set, root.right, is_deleted, result)
            return None if is_deleted else root
        
        result = []
        to_delete_set = set(to_delete)
        delNodesHelper(to_delete_set, root, True, result)
        return result
",n
"
class Solution(object):
    def fixedPoint(self, A):
        left, right = 0, len(A)-1
        while left <= right:
            mid = left + (right-left)//2
            if A[mid] >= mid:
                right = mid-1
            else:
                left = mid+1
        return left if A[left] == left else -1
",logn
"

class Solution(object):
    def maximumXorProduct(self, a, b, n):
        MOD = 10**9+7
        for i in reversed(range(n)):
            base = 1<<i
            if min(a, b)&base == 0:
                a, b = a^base, b^base
        return (a%MOD)*(b%MOD)%MOD
",n
"
class Solution(object):
    def decode(self, encoded):
        curr = 0
        for i in range(1, (len(encoded)+1) + 1):
            curr ^= i
            if i < len(encoded) and i%2 == 1:
                curr ^= encoded[i]
        result = [curr]
        for x in encoded:
            result.append(result[-1]^x)
        return result
",n
"

class Solution(object):
    def largestInteger(self, num):
        def count(num):
            cnt = [0]*10
            while num:
                num, d = divmod(num, 10)
                cnt[d] += 1
            return cnt

        cnt = count(num)
        result = 0
        digit = [0, 1]
        base = 1
        while num:
            num, d = divmod(num, 10)
            while not cnt[digit[d%2]]:
                digit[d%2] += 2
            cnt[digit[d%2]] -= 1
            result += digit[d%2]*base
            base *= 10
        return result
",logn
"
import collections


class Solution(object):
    def maxEqualRowsAfterFlips(self, matrix):
        count = collections.Counter(tuple(x^row[0] for x in row)
                                          for row in matrix)
        return max(count.values())
",m * n
"
class Solution(object):
    def distinctEchoSubstrings(self, text):
        def KMP(text, l, result):
            prefix = [-1]*(len(text)-l)
            j = -1
            for i in range(1, len(prefix)):
                while j > -1 and text[l+j+1] != text[l+i]:
                    j = prefix[j]
                if text[l+j+1] == text[l+i]:
                    j += 1
                prefix[i] = j
                if (j+1) and (i+1) % ((i+1) - (j+1)) == 0 and \
                   (i+1) // ((i+1) - (j+1)) % 2 == 0:
                    result.add(text[l:l+i+1])
            return len(prefix)-(prefix[-1]+1) \
                   if prefix[-1]+1 and len(prefix) % (len(prefix)-(prefix[-1]+1)) == 0 \
                   else float(""inf"")

        result = set()
        i, l = 0, len(text)-1
        while i < l: 
            l = min(l, i + KMP(text, i, result))
            i += 1
        return len(result)


",n^2 + d
"class Solution2(object):
    def distinctEchoSubstrings(self, text):
        result = set()
        for l in range(1, len(text)//2+1):
            count = sum(text[i] == text[i+l] for i in range(l))
            for i in range(len(text)-2*l):
                if count == l:
                    result.add(text[i:i+l])
                count += (text[i+l] == text[i+l+l]) - (text[i] == text[i+l])
            if count == l:
                result.add(text[len(text)-2*l:len(text)-2*l+l])
        return len(result)


",n^2 + d
"class Solution3(object):
    def distinctEchoSubstrings(self, text):
        MOD = 10**9+7
        D = 27 
        result = set()
        for i in range(len(text)-1):
            left, right, pow_D = 0, 0, 1
            for l in range(1, min(i+2, len(text)-i)):
                left = (D*left + (ord(text[i-l+1])-ord('a')+1)) % MOD
                right = (pow_D*(ord(text[i+l])-ord('a')+1) + right) % MOD
                if left == right: 
                    result.add(left)
                pow_D = (pow_D*D) % MOD 
        return len(result)


",n^2 + d
"class Solution_TLE(object):
    def distinctEchoSubstrings(self, text):
        def compare(text, l, s1, s2):
            for i in range(l):
                if text[s1+i] != text[s2+i]:
                    return False
            return True

        MOD = 10**9+7
        D = 27 
        result = set()
        for i in range(len(text)):
            left, right, pow_D = 0, 0, 1
            for l in range(1, min(i+2, len(text)-i)):
                left = (D*left + (ord(text[i-l+1])-ord('a')+1)) % MOD
                right = (pow_D*(ord(text[i+l])-ord('a')+1) + right) % MOD
                if left == right and compare(text, l, i-l+1, i+1):
                    result.add(text[i+1:i+1+l])
                pow_D = (pow_D*D) % MOD 
        return len(result)
",n^3 + d
"

class Solution(object):
    def readBinaryWatch(self, num):
        def bit_count(bits):
            count = 0
            while bits:
                bits &= bits-1
                count += 1
            return count

        return ['%d:%02d' % (h, m) for h in range(12) for m in range(60)
                if bit_count(h) + bit_count(m) == num]

    def readBinaryWatch2(self, num):
        return ['{0}:{1}'.format(str(h), str(m).zfill(2))
                for h in range(12) for m in range(60)
                if (bin(h) + bin(m)).count('1') == num]

",1
"

class Solution(object):
    def longestString(self, x, y, z):
        return ((min(x, y)*2+int(x != y))+z)*2
",1
"

class Solution(object):
    def splitIntoFibonacci(self, S):
        def startswith(S, k, x):
            y = 0
            for i in range(k, len(S)):
                y = 10*y + int(S[i])
                if y == x:
                    return i-k+1
                elif y > x:
                    break
            return 0

        MAX_INT = 2**31-1
        a = 0
        for i in range(len(S)-2):
            a = 10*a + int(S[i])
            b = 0
            for j in range(i+1, len(S)-1):
                b = 10*b + int(S[j])
                fib = [a, b]
                k = j+1
                while k < len(S):
                    if fib[-2] > MAX_INT-fib[-1]:
                        break
                    c = fib[-2]+fib[-1]
                    length = startswith(S, k, c)
                    if length == 0:
                        break
                    fib.append(c)
                    k += length
                else:
                    return fib
                if b == 0:
                    break
            if a == 0:
                break
        return []

",n^3
"
class Solution(object):
    def smallestFactorization(self, a):
        if a < 2:
            return a
        result, mul = 0, 1
        for i in reversed(range(2, 10)):
            while a % i == 0:
                a /= i
                result = mul*i + result
                mul *= 10
        return  result if a == 1 and result < 2**31 else 0


",loga
"
class Solution(object):
    def advantageCount(self, A, B):
        sortedA = sorted(A)
        sortedB = sorted(B)

        candidates = {b: [] for b in B}
        others = []
        j = 0
        for a in sortedA:
            if a > sortedB[j]:
                candidates[sortedB[j]].append(a)
                j += 1
            else:
                others.append(a)
        return [candidates[b].pop() if candidates[b] else others.pop()
                for b in B]

",nlogn
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        curA, curB = headA, headB
        while curA != curB:
            curA = curA.__next__ if curA else headB
            curB = curB.__next__ if curB else headA
        return curA
",m + n
"
class Solution(object):
    def minTrioDegree(self, n, edges):
        adj = [set() for _ in range(n+1)]
        degree = [0]*(n+1)
        for u, v in edges:
            adj[min(u, v)].add(max(u, v))
            degree[u] += 1
            degree[v] += 1
        result = float(""inf"")
        for u in range(1, n+1):
            for v in adj[u]:
                for w in adj[u]:
                    if v < w and w in adj[v]:
                        result = min(result, degree[u]+degree[v]+degree[w] - 6)
        return result if result != float(""inf"") else -1
",n^3
"
class Solution(object):
    def strWithout3a3b(self, A, B):
        result = []
        put_A = None
        while A or B:
            if len(result) >= 2 and result[-1] == result[-2]:
                put_A = result[-1] == 'b'
            else:
                put_A = A >= B

            if put_A:
                A -= 1
                result.append('a')
            else:
                B -= 1
                result.append('b')
        return """".join(result)
",a + b
"

class Solution(object):
    def minimumNumbers(self, num, k):
        return next((i for i in range(1, (min(num//k, 10) if k else 1)+1) if (num-i*k)%10 == 0), -1) if num else 0
",1
"

class Solution(object):
    def losingPlayer(self, x, y):
        return ""Alice"" if min(x, y//4)%2 else ""Bob""
",1
"
import heapq


class Solution(object):
    def minFallingPathSum(self, arr):
        for i in range(1, len(arr)):
            smallest_two = heapq.nsmallest(2, arr[i-1])
            for j in range(len(arr[0])):
                arr[i][j] += smallest_two[1] if arr[i-1][j] == smallest_two[0] else smallest_two[0]
        return min(arr[-1])
",m * n
"
class Solution(object):
    def minKBitFlips(self, A, K):
        result, curr = 0, 0
        for i in range(len(A)):
            if i >= K:
                curr -= A[i-K]//2
            if curr & 1 ^ A[i] == 0:
                if i+K > len(A):
                    return -1
                A[i] += 2
                curr, result = curr+1, result+1
        return result
",n
"
class Solution(object):
    def rearrangeSticks(self, n, k):
        MOD = 10**9+7
        dp = [[0 for _ in range(k+1)] for _ in range(2)]
        dp[1][1] = 1
        for i in range(2, n+1):
            for j in range(1, min(i, k)+1):
                dp[i%2][j] = (dp[(i-1)%2][j-1]+(i-1)*dp[(i-1)%2][j]) % MOD 
        return dp[n%2][k]
",n * k
"

class Solution(object):
    def duplicateNumbersXOR(self, nums):
        return reduce(lambda x, y: x^y, nums, 0)^reduce(lambda x, y: x^y, set(nums), 0)


",n
"import collections
from functools import reduce



class Solution2(object):
    def duplicateNumbersXOR(self, nums):
        return reduce(lambda x, y: x^y, (x for x, c in collections.Counter(nums).items() if c == 2), 0)

",n
"
import heapq


class Solution(object):
    def maxTwoEvents(self, events):
        events.sort()
        result = best = 0
        min_heap = []
        for left, right, v in events:
            heapq.heappush(min_heap, (right, v))
            while min_heap and min_heap[0][0] < left:
                best = max(best, heapq.heappop(min_heap)[1])
            result = max(result, best+v)
        return result
",nlogn
"

class Solution(object):
    def cycleLengthQueries(self, n, queries):
        result = []
        for x, y in queries:
            cnt = 1
            while x != y:
                if x > y:
                    x, y = y, x
                y //= 2
                cnt += 1
            result.append(cnt)
        return result
",q * n
"
class Solution(object):
    def findMode(self, root):
        def inorder(root, prev, cnt, max_cnt, result):
            if not root:
                return prev, cnt, max_cnt

            prev, cnt, max_cnt = inorder(root.left, prev, cnt, max_cnt, result)
            if prev:
                if root.val == prev.val:
                    cnt += 1
                else:
                    cnt = 1
            if cnt > max_cnt:
                max_cnt = cnt
                del result[:]
                result.append(root.val)
            elif cnt == max_cnt:
                result.append(root.val)
            return inorder(root.right, root, cnt, max_cnt, result)

        if not root:
            return []
        result = []
        inorder(root, None, 1, 0, result)
        return result

",n
"
import collections


class Solution(object):
    def sortFeatures(self, features, responses):
        features_set = set(features)
        order = {word: i for i, word in enumerate(features)}
        freq = collections.defaultdict(int)
        for r in responses:
            for word in set(r.split(' ')):
                if word in features_set:
                    freq[word] += 1
        features.sort(key=lambda x: (-freq[x], order[x]))
        return features
",nlogn
"
class Solution(object):
    def canConstruct(self, ransomNote, magazine):
        counts = [0] * 26
        letters = 0

        for c in ransomNote:
            if counts[ord(c) - ord('a')] == 0:
                letters += 1
            counts[ord(c) - ord('a')] += 1

        for c in magazine:
            counts[ord(c) - ord('a')] -= 1
            if counts[ord(c) - ord('a')] == 0:
                letters -= 1
                if letters == 0:
                    break

        return letters == 0

",n
"import collections

class Solution2(object):
    def canConstruct(self, ransomNote, magazine):
        return not collections.Counter(ransomNote) - collections.Counter(magazine)

",n
"

class Solution(object):
    def sortJumbled(self, mapping, nums):
        def transform(mapping, x):
            if not x:
                return mapping[x]
            result, base = 0, 1
            while x:
                result += mapping[x%10]*base
                x //= 10
                base *= 10
            return result

        return [nums[i] for _, i in sorted((transform(mapping, nums[i]), i) for i in range(len(nums)))]
",nlogm + nlogn
"
import collections


class Solution(object):
    def shortestPathLength(self, graph):
        dp = [[float(""inf"")]*(len(graph))
              for _ in range(1 << len(graph))]
        q = collections.deque()
        for i in range(len(graph)):
            dp[1 << i][i] = 0
            q.append((1 << i, i))
        while q:
            state, node = q.popleft()
            steps = dp[state][node]
            for nei in graph[node]:
                new_state = state | (1 << nei)
                if dp[new_state][nei] == float(""inf""):
                    dp[new_state][nei] = steps+1
                    q.append((new_state, nei))
        return min(dp[-1])

",n * 2^n
"

class Solution(object):
    def beautifulPartitions(self, s, k, minLength):
        MOD = 10**9+7
        PRIMES = {'2', '3', '5', '7'}
        dp = [0]*len(s) 
        for i in range(minLength-1, len(s)):
            if s[0] in PRIMES and s[i] not in PRIMES:
                dp[i] = 1
        for j in range(2, k+1):
            new_dp = [0]*len(s)
            curr = int(j == 1)
            for i in range(j*minLength-1, len(s)):
                if s[i-minLength+1] in PRIMES:
                    curr = (curr+dp[i-minLength])%MOD
                if s[i] not in PRIMES:
                    new_dp[i] = curr
            dp = new_dp
        return dp[-1]
",n * k
"
class Solution(object):
    def minSwapsCouples(self, row):
        N = len(row)//2
        couples = [[] for _ in range(N)]
        for seat, num in enumerate(row):
            couples[num//2].append(seat//2)
        adj = [[] for _ in range(N)]
        for couch1, couch2 in couples:
            adj[couch1].append(couch2)
            adj[couch2].append(couch1)

        result = 0
        for couch in range(N):
            if not adj[couch]: continue
            couch1, couch2 = couch, adj[couch].pop()
            while couch2 != couch:
                result += 1
                adj[couch2].remove(couch1)
                couch1, couch2 = couch2, adj[couch2].pop()
        return result 

",n
"
class Solution(object):
    def xorQueries(self, arr, queries):
        for i in range(1, len(arr)):
            arr[i] ^= arr[i-1]
        return [arr[right] ^ arr[left-1] if left else arr[right] for left, right in queries]
",n
"
class Solution(object):
    def canAttendMeetings(self, intervals):
        intervals.sort(key=lambda x: x[0])

        for i in range(1, len(intervals)):
            if intervals[i][0] < intervals[i-1][1]:
                return False
        return True
",nlogn
"
class Solution(object):
    def splitArraySameAverage(self, A):
        def possible(total, n):
            for i in range(1, n//2+1):
                if total*i%n == 0:
                    return True
            return False
        n, s = len(A), sum(A)
        if not possible(n, s):
            return False

        sums = [set() for _ in range(n//2+1)]
        sums[0].add(0)
        for num in A: 
            for i in reversed(range(1, n//2+1)): 
                for prev in sums[i-1]: 
                    sums[i].add(prev+num)
        for i in range(1, n//2+1):
            if s*i%n == 0 and s*i//n in sums[i]:
                return True
        return False

",n^4
"
class Solution(object):
    def largestSubarray(self, nums, k):
        left, right, l = 0, 1, 0
        while right+k-1 < len(nums) and right+l < len(nums):
            if nums[left+l] == nums[right+l]:
                l += 1
                continue
            if nums[left+l] > nums[right+l]:
                right += l+1
            else:
                left = max(right, min(left+l+1, len(nums)-k))
                right = left+1
            l = 0
        return nums[left:left+k]
",n
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def minimumLevel(self, root):
        q = [root]
        d = 1
        result = ((float(""inf""), float(""inf"")))
        while q:
            new_q = []
            total = 0
            for u in q:
                if u.left:
                    new_q.append(u.left)
                if u.right:
                    new_q.append(u.right)
                total += u.val
            result = min(result, (total, d))
            q = new_q
            d += 1
        return result[-1]
",n
"    
import collections



class Solution(object):
    def sumPrefixScores(self, words):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for w in words:
            curr = trie
            for c in w:
                curr = curr[c]
                curr[""_cnt""] = curr[""_cnt""]+1 if ""_cnt"" in curr else 1
        result = []
        for w in words:
            cnt = 0
            curr = trie
            for c in w:
                curr = curr[c]
                cnt += curr[""_cnt""]
            result.append(cnt)
        return result
",n * l
"
class Solution(object):
    lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}
    cache = {}

    def strobogrammaticInRange(self, low, high):
        count = self.countStrobogrammaticUntil(high, False) - \
                self.countStrobogrammaticUntil(low, False) + \
                self.isStrobogrammatic(low)
        return count if count >= 0 else 0

    def countStrobogrammaticUntil(self, num,  can_start_with_0):
        if can_start_with_0 and num in self.cache:
            return self.cache[num]

        count = 0
        if len(num) == 1:
            for c in ['0', '1', '8']:
                if num[0] >= c:
                    count += 1
            self.cache[num] = count
            return count

        for key, val in self.lookup.items():
            if can_start_with_0 or key != '0':
                if num[0] > key:
                    if len(num) == 2: 
                        count += 1
                    else: 
                        count += self.countStrobogrammaticUntil('9' * (len(num) - 2), True)
                elif num[0] == key:
                    if len(num) == 2: 
                        if num[-1] >= val:
                            count += 1
                    else:
                        if num[-1] >= val: 
                            count += self.countStrobogrammaticUntil(self.getMid(num), True)
                        elif (self.getMid(num) != '0' * (len(num) - 2)): 
                            count += self.countStrobogrammaticUntil(self.getMid(num), True) - \
                                     self.isStrobogrammatic(self.getMid(num))

        if not can_start_with_0:
            for i in range(len(num) - 1, 0, -1):
                count += self.countStrobogrammaticByLength(i)
        else:
            self.cache[num] = count

        return count

    def getMid(self, num):
        return num[1:len(num) - 1]

    def countStrobogrammaticByLength(self, n):
        if n == 1:
            return 3
        elif n == 2:
            return 4
        elif n == 3:
            return 4 * 3
        else:
            return 5 * self.countStrobogrammaticByLength(n - 2)

    def isStrobogrammatic(self, num):
        n = len(num)
        for i in range((n+1) / 2):
            if num[n-1-i] not in self.lookup or \
               num[i] != self.lookup[num[n-1-i]]:
                return False
        return True

",5^(n/2)
"
class Solution(object):
    def numSub(self, s):
        MOD = 10**9+7
        result, count = 0, 0
        for c in s:
            count = count+1 if c == '1' else 0
            result = (result+count)%MOD
        return result
",n
"

class Solution(object):
    def minimumFuelCost(self, roads, seats):
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, 0, [1]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, d, ret = args
                    stk.append((3, (d, ret)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_ret = [1]
                        stk.append((2, (new_ret, ret)))
                        stk.append((1, (v, u, d+1, new_ret)))
                elif step == 2:
                    new_ret, ret = args
                    ret[0] += new_ret[0]
                elif step == 3:
                    d, ret = args
                    if d:
                        result += ceil_divide(ret[0], seats)
            return result
    
        adj = [[] for _ in range(len(roads)+1)]
        for u, v in roads:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()


",n
"
class Solution(object):
    def minimumFuelCost(self, roads, seats):
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        def dfs(u, p, d):
            cnt = 1+sum(dfs(v, u, d+1) for v in adj[u] if v != p)
            if d:
                result[0] += ceil_divide(cnt, seats)
            return cnt
    
        adj = [[] for _ in range(len(roads)+1)]
        for u, v in roads:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1, 0)
        return result[0]
",n
"

class Solution(object):
    def minCapability(self, nums, k):
        def check(x):
            cnt = i = 0
            while i < len(nums):
                if nums[i] <= x:
                    cnt += 1
                    i += 2
                else:
                    i += 1
            return cnt >= k

        sorted_nums = sorted(set(nums))
        left, right = 0, len(sorted_nums)-1
        while left <= right:
            mid = left + (right-left)//2
            if check(sorted_nums[mid]):
                right = mid-1
            else:
                left = mid+1
        return sorted_nums[left]


",nlogn
"
class Solution2(object):
    def minCapability(self, nums, k):
        def check(x):
            cnt = i = 0
            while i < len(nums):
                if nums[i] <= x:
                    cnt += 1
                    i += 2
                else:
                    i += 1
            return cnt >= k
    
        left, right = min(nums), max(nums)
        while left <= right:
            mid = left + (right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return left
",nlogr
"

class Solution(object):
    def sortMatrix(self, grid):
        lookup = [[] for _ in range((len(grid)-1)+(len(grid[0])-1)-(0-(len(grid[0])-1))+1)]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                lookup[i-j].append(grid[i][j])
        for i in range(0-(len(grid[0])-1), (len(grid)-1)+(len(grid[0])-1)+1):
            if i < 0:
                lookup[i].sort(reverse=True)
            else:
                lookup[i].sort()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                grid[i][j] = lookup[i-j].pop()
        return grid
",n^2 * logn
"
import random



class Solution(object):
    def kthLargestPerfectSubtree(self, root, k):
        def nth_element(nums, left, n, right, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def iter_dfs():
            result = []
            stk = [(1, (root, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    curr, ret = args
                    if not curr:
                        ret[0] = 0
                        result.append(ret[0])
                        continue
                    new_ret = [[0] for _ in range(2)]
                    stk.append((2, (curr, new_ret, ret)))
                    stk.append((1, (curr.right, new_ret[1])))
                    stk.append((1, (curr.left, new_ret[0])))
                elif step == 2:
                    curr, new_ret, ret = args
                    ret[0] = new_ret[0][0]+new_ret[1][0]+1 if new_ret[0][0] == new_ret[1][0] != -1 else -1
                    result.append(ret[0])
            return result
                        
        result = iter_dfs()
        nth_element(result, 0, k-1, len(result)-1, lambda a, b: a > b)
        return result[k-1] if k-1 < len(result) and result[k-1] > 0 else -1


",n
"import random



class Solution2(object):
    def kthLargestPerfectSubtree(self, root, k):
        def nth_element(nums, left, n, right, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def dfs(curr):
            if not curr:
                result.append(0)
                return
            dfs(curr.left)
            left = result[-1]
            dfs(curr.right)
            right = result[-1]
            result.append(left+right+1 if left == right != -1 else -1)

        result = []
        dfs(root)
        nth_element(result, 0, k-1, len(result)-1, lambda a, b: a > b)
        return result[k-1] if k-1 < len(result) and result[k-1] > 0 else -1
",n
"
class Solution(object):
    def minOperationsToFlip(self, expression):
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(ops[operators.pop()](left, right))

        ops = {'&':lambda x, y: [min(x[0], y[0]), min(x[1]+y[1], min(x[1], y[1])+1)],
               '|':lambda x, y: [min(x[0]+y[0], min(x[0], y[0])+1), min(x[1], y[1])]}
        precedence = {'&':0, '|':0}
        operands, operators = [], []
        for c in expression:
            if c.isdigit():
                operands.append([int(c != '0'), int(c != '1')])
            elif c == '(':
                operators.append(c)
            elif c == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif c in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] >= precedence[c]:
                    compute(operands, operators)
                operators.append(c)
        while operators:
            compute(operands, operators)
        return max(operands[-1])


",n
"class Solution2(object):
    def minOperationsToFlip(self, expression):
        stk = [[None]*3]
        for c in expression:                                
            if c == '(':                                            
                stk.append([None]*3)
            elif c in {')', '0', '1'}:
                if c == ')':
                    dp0, dp1, _ = stk.pop()
                else:
                    dp0, dp1 = int(c != '0'), int(c != '1')
                if stk[-1][2] == '&':
                    stk[-1] = [min(stk[-1][0], dp0),
                               min(stk[-1][1]+dp1, min(stk[-1][1], dp1)+1),
                               None]
                elif stk[-1][2] == '|':
                    stk[-1] = [min(stk[-1][0]+dp0, min(stk[-1][0], dp0)+1),
                               min(stk[-1][1], dp1),
                               None]
                else: 
                    stk[-1] = [dp0, dp1, None]
            else:
                stk[-1][2] = c
        return max(stk[0][0], stk[0][1])
",n
"

class Solution(object):
    def subarrayGCD(self, nums, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result = 0
        dp = collections.Counter()
        for x in nums:
            new_dp = collections.Counter()
            if x%k == 0:
                dp[x] += 1
                for g, cnt in dp.items():
                    new_dp[gcd(g, x)] += cnt
            dp = new_dp
            result += dp[k]
        return result


",nlogr
"
class Solution2(object):
    def subarrayGCD(self, nums, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result = 0
        for i in range(len(nums)):
            g = 0
            for j in range(i, len(nums)):
                if nums[j]%k:
                    break
                g = gcd(g, nums[j])
                result += int(g == k)
        return result
",n^2
"

class Solution(object):
    def numberOfGoodSubarraySplits(self, nums):
        MOD = 10**9+7
        result, prev = 1, -1
        for i in range(len(nums)):
            if nums[i] != 1:
                continue
            if prev != -1:
                result = (result*(i-prev))%MOD
            prev = i
        return result if prev != -1 else 0
",n
"

class Solution(object):
    def makePalindrome(self, s):
        return sum(s[i] != s[~i] for i in range(len(s)//2)) <= 2


",n
"
class Solution2(object):
    def makePalindrome(self, s):
        cnt = 0
        left, right = 0, len(s)-1
        while left < right:
            if s[left] != s[right]:
                cnt += 1
                if cnt > 2:
                    return False
            left += 1
            right -= 1
        return True
",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        self.next = None

    def __repr__(self):
        if self is None:
            return ""Nil""
        else:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def connect(self, root):
        head = root
        while head:
            cur = head
            while cur and cur.left:
                cur.left.next = cur.right
                if cur.__next__:
                    cur.right.next = cur.next.left
                cur = cur.__next__
            head = head.left

",n
"
class Solution2(object):
    def connect(self, root):
        if root is None:
            return
        if root.left:
            root.left.next = root.right
        if root.right and root.__next__:
            root.right.next = root.next.left
        self.connect(root.left)
        self.connect(root.right)

",n
"

class Solution(object):
    def smallestSufficientTeam(self, req_skills, people):
        lookup = {v: i for i, v in enumerate(req_skills)}
        dp = {0: []}
        for i, p in enumerate(people):
            his_skill_set = 0
            for skill in p:
                if skill in lookup:
                    his_skill_set |= 1 << lookup[skill]
            for skill_set, people in list(dp.items()):
                with_him = skill_set | his_skill_set
                if with_him == skill_set: continue
                if with_him not in dp or \
                   len(dp[with_him]) > len(people)+1:
                    dp[with_him] = people + [i]
        return dp[(1<<len(req_skills))-1]
",m * 2^n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sumEvenGrandparent(self, root):
        def sumEvenGrandparentHelper(root, p, gp):
            return sumEvenGrandparentHelper(root.left, root.val, p) + \
                   sumEvenGrandparentHelper(root.right, root.val, p) + \
                   (root.val if gp is not None and gp % 2 == 0 else 0) if root else 0

        return sumEvenGrandparentHelper(root, None, None)
",n
"

class Solution(object):
    def maxTargetNodes(self, edges1, edges2):
        def bfs(adj):
            result = [0]*len(adj)
            parity = 0
            lookup = [-1]*len(adj)
            lookup[0] = parity
            q = [0]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v] != -1:
                            continue
                        lookup[v] = parity^1
                        new_q.append(v)
                q = new_q
                parity ^= 1
            cnt = sum(lookup)
            return [cnt if lookup[u] else len(adj)-cnt for u in range(len(adj))]
    
        def find_adj(edges):
            adj = [[] for _ in range(len(edges)+1)]
            for u, v in edges:
                adj[u].append(v)
                adj[v].append(u)
            return adj

        adj2 = find_adj(edges2)
        mx = max(bfs(adj2))
        adj1 = find_adj(edges1)
        return [mx+x for x in bfs(adj1)]
",n + m
"

class Solution(object):
    def maxFreeTime(self, eventTime, k, startTime, endTime):
        startTime.append(eventTime)
        endTime.insert(0, 0)
        result = curr = 0
        for i in range(len(startTime)):
            curr += startTime[i]-endTime[i]
            result = max(result, curr)
            if i-k >= 0:
                curr -= startTime[i-k]-endTime[i-k]
        return result
",n
"

class Solution:
    def toArray(self, head):
        result = []
        while head:
            result.append(head.val)
            head = head.__next__
        return result
",n
"
import collections
import itertools



class Solution(object):
    def equalPairs(self, grid):
        cnt1 = collections.Counter(tuple(row) for row in grid)
        cnt2 = collections.Counter(tuple(col) for col in zip(*grid))
        return sum(cnt1[k]*cnt2[k] for k in cnt1.keys() if k in cnt2)
",n^2
"
import threading


class Solution(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = 0
        self.__cv = threading.Condition()
    def zero(self, printNumber):
        for i in range(self.__n):
            with self.__cv:
                while self.__curr % 2 != 0:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(0)
                self.__cv.notifyAll()
        
    def even(self, printNumber):
        for i in range(2, self.__n+1, 2):
            with self.__cv:
                while self.__curr % 4 != 3:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(i)
                self.__cv.notifyAll()
        
    def odd(self, printNumber):
        for i in range(1, self.__n+1, 2):
            with self.__cv:
                while self.__curr % 4 != 1:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(i)
                self.__cv.notifyAll()
",n
"
class Solution(object):
    def minimumOperations(self, nums, start, goal):
        MAX_X = 1000
        nums = [y for y in nums if y and any(0 <= nx <= MAX_X for nx in (y, goal-y, goal+y, goal^y))]
        q = [(start, 0)]
        lookup = {start}
        while q:
            new_q = []
            for x, steps in q:
                for y in nums:
                    for nx in (x+y, x-y, x^y):
                        if nx == goal:
                            return steps+1
                        if not (0 <= nx <= MAX_X) or nx in lookup:
                            continue
                        lookup.add(nx)
                        q.append((nx, steps+1))
            q = new_q
        return -1
",n * m
"

class Solution(object):
    def numberOfPairs(self, points):
        points.sort(key=lambda x: (x[0], -x[1]))
        result = 0
        for i in range(len(points)):
            y = float(""-inf"")
            for j in range(i+1, len(points)):
                if points[i][1] < points[j][1]:
                    continue
                if points[j][1] > y:
                    y = points[j][1]
                    result += 1
        return result


",n^2
"
class Solution2(object):
    def numberOfPairs(self, points):
        points.sort(key=lambda x: (x[0], -x[1]))
        return sum(all(not points[i][1] >= points[k][1] >= points[j][1] for k in range(i+1, j))
                   for i in range(len(points))
                   for j in range(i+1, len(points)) if points[i][1] >= points[j][1])
 
",n^3
"    
class Solution(object):
    def numWays(self, steps, arrLen):
        MOD = int(1e9+7)
        l = min(1+steps//2, arrLen)
        dp = [0]*(l+2)
        dp[1] = 1
        while steps > 0:
            steps -= 1
            new_dp = [0]*(l+2)
            for i in range(1, l+1):
                new_dp[i] = (dp[i] + dp[i-1] + dp[i+1]) % MOD
            dp = new_dp
        return dp[1]
",n^2
"
import collections


class Solution(object):
    def waysToPartition(self, nums, k):
        total = sum(nums)
        right = collections.Counter()
        prefix = 0
        for i in range(len(nums)-1):
            prefix += nums[i]
            right[prefix-(total-prefix)] += 1
        result = right[0]
        left = collections.Counter()
        prefix = 0
        for x in nums:
            result = max(result, left[k-x]+right[-(k-x)])
            prefix += x
            left[prefix-(total-prefix)] += 1
            right[prefix-(total-prefix)] -= 1
        return result
",n
"
class Solution(object):
    def reinitializePermutation(self, n):
        def discrete_log(a, b, m):
            a %= m
            b %= m
            n = int(m**0.5)+1
            an = pow(a, n, m)
            vals = {}
            curr = b
            for q in range(n+1):
                vals[curr] = q
                curr = curr*a % m
            curr = 1
            for p in range(1, n+1):
                curr = curr*an % m
                if curr in vals:
                    return n*p-vals[curr]
            return -1

        return 1+discrete_log(2, n//2, n-1) 


",sqrt(n)
"class Solution2(object):
    def reinitializePermutation(self, n):
        if n == 2:
            return 1
        result, i = 0, 1
        while not result or i != 1:
            i = (i*2)%(n-1)
            result += 1
        return result


",n
"class Solution3(object):
    def reinitializePermutation(self, n):
        result, i = 0, 1
        while not result or i != 1: 
            i = (i//2 if not i%2 else n//2+(i-1)//2)
            result += 1
        return result
",n
"
import collections


class Solution(object):
    def distinctNumbers(self, nums, k):
        result = []
        count = collections.Counter()
        for i, num in enumerate(nums):
            count[num] += 1
            if i >= k:
                count[nums[i-k]] -= 1
                if not count[nums[i-k]]:
                    del count[nums[i-k]]
            if i+1 >= k:
                result.append(len(count))
        return result

",n
"

class Solution(object):
    def doubleIt(self, head):
        if head.val >= 5:
            head = ListNode(0, head)
        curr = head
        while curr:
            curr.val = (curr.val*2)%10
            if curr.__next__ and curr.next.val >= 5:
                curr.val += 1
            curr = curr.__next__
        return head
",n
"
class Solution(object):
    def earliestFullBloom(self, plantTime, growTime):
        order = list(range(len(growTime)))
        order.sort(key=lambda x: growTime[x], reverse=True)
        result = curr = 0
        for i in order:
            curr += plantTime[i]
            result = max(result, curr+growTime[i])
        return result
",nlogn
"
import bisect


class Solution(object):
    def minWastedSpace(self, packages, boxes):
        MOD = 10**9+7
        INF = float(""inf"")

        packages.sort()
        result = INF
        for box in boxes:
            box.sort()
            if box[-1] < packages[-1]:
                continue
            curr = left = 0
            for b in box:
                right = bisect.bisect_right(packages, b, left)
                curr += b * (right-left)
                left = right
            result = min(result, curr)
        return (result-sum(packages))%MOD if result != INF else -1
",mlogm + nlogn + mlogn
"

class Solution(object):
    def countPairs(self, n, edges):
        def bfs(adj, u, lookup):
            q = [u]
            lookup[u] = 1
            result = 1
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = 1
                        result += 1
                        new_q.append(v)
                q = new_q
            return result
        
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        lookup = [0]*n
        result = 0
        for u in range(n):
            if lookup[u]:
                continue
            cnt = bfs(adj, u, lookup)
            result += cnt*(n-cnt)
            n -= cnt
        return result
",n
"
class Solution(object):
    def sortArrayByParityII(self, A):
        j = 1
        for i in range(0, len(A), 2):
            if A[i] % 2:
                while A[j] % 2:
                    j += 2
                A[i], A[j] = A[j], A[i]
        return A
",n
"
from collections import defaultdict
from string import ascii_lowercase


class Solution(object):
    def findLadders(self, beginWord, endWord, wordList):
        def backtracking(tree, beginWord, word): 
            return [[beginWord]] if word == beginWord else [path + [word] for new_word in tree[word] for path in backtracking(tree, beginWord, new_word)]

        words = set(wordList)
        if endWord not in words:
            return []
        tree = defaultdict(set)
        is_found, left, right, is_reversed = False, {beginWord}, {endWord}, False
        while left:
            words -= left
            new_left = set()
            for word in left:
                for new_word in (word[:i]+c+word[i+1:] for i in range(len(beginWord)) for c in ascii_lowercase):
                    if new_word not in words:
                        continue
                    if new_word in right: 
                        is_found = True
                    else: 
                        new_left.add(new_word)
                    tree[new_word].add(word) if not is_reversed else tree[word].add(new_word)
            if is_found:
                break
            left = new_left
            if len(left) > len(right): 
                left, right, is_reversed = right, left, not is_reversed
        return backtracking(tree, beginWord, endWord)


",b^(d/2)
"class Solution2(object):
    def findLadders(self, beginWord, endWord, wordList):
        dictionary = set(wordList)
        result, cur, visited, found, trace = [], [beginWord], set([beginWord]), False, defaultdict(list)

        while cur and not found:
            for word in cur:
                visited.add(word)

            next = set()
            for word in cur:
                for i in range(len(word)):
                    for c in ascii_lowercase:
                        candidate = word[:i] + c + word[i + 1:]
                        if candidate not in visited and candidate in dictionary:
                            if candidate == endWord:
                                found = True
                            next.add(candidate)
                            trace[candidate].append(word)
            cur = next

        if found:
            self.backtrack(result, trace, [], endWord)

        return result

    def backtrack(self, result, trace, path, word):
        if not trace[word]:
            path.append(word)
            result.append(path[::-1])
            path.pop()
        else:
            for prev in trace[word]:
                path.append(word)
                self.backtrack(result, trace, path, prev)
                path.pop()
",b^d
"
class Solution(object):
    def findDisappearedNumbers(self, nums):
        for i in range(len(nums)):
            if nums[abs(nums[i]) - 1] > 0:
                nums[abs(nums[i]) - 1] *= -1

        result = []
        for i in range(len(nums)):
            if nums[i] > 0:
                result.append(i+1)
            else:
                nums[i] *= -1
        return result

    def findDisappearedNumbers2(self, nums):
        return list(set(range(1, len(nums) + 1)) - set(nums))

    def findDisappearedNumbers3(self, nums):
        for i in range(len(nums)):
            index = abs(nums[i]) - 1
            nums[index] = - abs(nums[index])

        return [i + 1 for i in range(len(nums)) if nums[i] > 0]


",n
"
class Solution(object):
    def makesquare(self, nums):
        total_len = sum(nums)
        if total_len % 4:
            return False

        side_len = total_len / 4
        fullset = (1 << len(nums)) - 1

        used_subsets = []
        valid_half_subsets = [0] * (1 << len(nums))

        for subset in range(fullset+1):
            subset_total_len = 0
            for i in range(len(nums)):
                if subset & (1 << i):
                    subset_total_len += nums[i]

            if subset_total_len == side_len:
                for used_subset in used_subsets:
                    if (used_subset & subset) == 0:
                        valid_half_subset = used_subset | subset
                        valid_half_subsets[valid_half_subset] = True
                        if valid_half_subsets[fullset ^ valid_half_subset]:
                            return True
                used_subsets.append(subset)

        return False

",n * s * 2^n
"
class Solution(object):
    def myPow(self, x, n):
        result = 1
        abs_n = abs(n)
        while abs_n:
            if abs_n & 1:
                result *= x
            abs_n >>= 1
            x *= x

        return 1 / result if n < 0 else result


",logn
"
class Solution2(object):
    def myPow(self, x, n):
        if n < 0 and n != -n:
            return 1.0 / self.myPow(x, -n)
        if n == 0:
            return 1
        v = self.myPow(x, n / 2)
        if n % 2 == 0:
            return v * v
        else:
            return v * v * x


",logn
"
class Solution(object):
    def maxUniqueSplit(self, s):
        def popcount(n):
            count = 0
            while n:
                n &= n-1
                count += 1
            return count
    
        result = 1
        total = 2**(len(s)-1)
        mask = 0
        while mask < total:
            if popcount(mask) < result:
                mask += 1
                continue
            lookup, curr, base = set(), [], total//2
            for i in range(len(s)):
                curr.append(s[i])
                if (mask&base) or base == 0:
                    if """".join(curr) in lookup:
                        mask = (mask | (base-1)) + 1 if base else mask+1 
                        break
                    lookup.add("""".join(curr))
                    curr = []
                base >>= 1
            else:
                result = max(result, len(lookup))
                mask += 1
        return result
",n * 2^(n - 1)
"
class Solution(object):
    def replaceDigits(self, s):
        return """".join(chr(ord(s[i-1])+int(s[i])) if i%2 else s[i] for i in range(len(s)))
",n
"

class Solution(object):
    def minMoves(self, rooks):
        def count(arr):
            cnt = [0]*len(arr)
            for x in arr:
                cnt[x] += 1
            return sum(abs(i-x) for i, x in enumerate(x for x, cnt in enumerate(cnt) for _ in range(cnt)))

        return sum(count(arr) for arr in zip(*rooks))


",n
"
class Solution2(object):
    def minMoves(self, rooks):
        def count(arr):
            cnt = [0]*len(arr)
            for x in arr:
                cnt[x] += 1
            result = bal = 0
            for i in range(len(rooks)):
                bal += cnt[i]-1
                result += abs(bal)
            return result

        return sum(count(arr) for arr in zip(*rooks))
    
",n
"
class Solution(object):
    def minOperations(self, nums, x):
        target = sum(nums)-x
        result = -1
        curr = left = 0
        for right in range(len(nums)):
            curr += nums[right]
            while left < len(nums) and curr > target:
                curr -= nums[left]
                left += 1
            if curr == target:
                result = max(result, right-left+1)
        return len(nums)-result if result != -1 else -1
",n
"
import itertools



class Solution(object):
    def decodeMessage(self, key, message):
        f = lambda x: ord(x)-ord('a')
        lookup = [-1]*26
        i = 0
        for x in map(f, key):
            if x < 0 or lookup[x] != -1:
                continue
            lookup[x] = i
            i += 1
        return """".join(map(lambda x: chr(ord('a')+x), (lookup[x] if x >= 0 else x for x in map(f, message))))
    
",n + m
"
class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1) 

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret

class Solution(object):
    def createSortedArray(self, instructions):
        MOD = 10**9 + 7
        bit = BIT(max(instructions))
        result = 0
        for i, inst in enumerate(instructions):
            inst -= 1
            result += min(bit.query(inst-1), i-bit.query(inst))
            bit.add(inst, 1)
        return result % MOD


",nlogm
"import itertools
class Solution_TLE(object):
    def createSortedArray(self, instructions):
        MOD = 10**9 + 7
        def smallerMergeSort(idxs, start, end, counts):
            if end - start <= 0: 
                return 0

            mid = start + (end - start) // 2
            smallerMergeSort(idxs, start, mid, counts)
            smallerMergeSort(idxs, mid + 1, end, counts)
            r = start
            tmp = []
            for i in range(mid+1, end + 1):
                while r <= mid and idxs[r][0] < idxs[i][0]:
                    tmp.append(idxs[r])
                    r += 1
                tmp.append(idxs[i])
                counts[idxs[i][1]] += r - start
            while r <= mid:
                tmp.append(idxs[r])
                r += 1
            idxs[start:start+len(tmp)] = tmp
        
        def largerMergeSort(idxs, start, end, counts):
            if end - start <= 0: 
                return 0

            mid = start + (end - start) // 2
            largerMergeSort(idxs, start, mid, counts)
            largerMergeSort(idxs, mid + 1, end, counts)
            r = start
            tmp = []
            for i in range(mid+1, end + 1):
                while r <= mid and idxs[r][0] <= idxs[i][0]:
                    tmp.append(idxs[r])
                    r += 1
                if r <= mid:
                    tmp.append(idxs[i])
                counts[idxs[i][1]] += mid - r + 1
            while r <= mid:
                tmp.append(idxs[r])
                r += 1
            idxs[start:start+len(tmp)] = tmp

        idxs = []
        smaller_counts, larger_counts = [[0] * len(instructions) for _ in range(2)]
        for i, inst in enumerate(instructions):
            idxs.append((inst, i))
        smallerMergeSort(idxs[:], 0, len(idxs)-1, smaller_counts)
        largerMergeSort(idxs, 0, len(idxs)-1, larger_counts)
        return sum(min(s, l) for s, l in zip(smaller_counts, larger_counts)) % MOD
",nlogn
"
import collections



class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def removeZeroSumSublists(self, head):
        curr = dummy = ListNode(0)
        dummy.next = head
        prefix = 0
        lookup = collections.OrderedDict()
        while curr:
            prefix += curr.val
            node = lookup.get(prefix, curr)
            while prefix in lookup:
                lookup.popitem()
            lookup[prefix] = node
            node.next = curr.__next__
            curr = curr.__next__
        return dummy.__next__
",n
"
class Solution(object):
    def getModifiedArray(self, length, updates):
        result = [0] * length
        for update in updates:
            result[update[0]] += update[2]
            if update[1]+1 < length:
                result[update[1]+1] -= update[2]

        for i in range(1, length):
            result[i] += result[i-1]

        return result

",k + n
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def sortList(self, head):
        if head == None or head.__next__ == None:
            return head

        fast, slow, prev = head, head, None
        while fast != None and fast.__next__ != None:
            prev, fast, slow = slow, fast.next.__next__, slow.__next__
        prev.next = None

        sorted_l1 = self.sortList(head)
        sorted_l2 = self.sortList(slow)

        return self.mergeTwoLists(sorted_l1, sorted_l2)

    def mergeTwoLists(self, l1, l2):
        dummy = ListNode(0)

        cur = dummy
        while l1 != None and l2 != None:
            if l1.val <= l2.val:
                cur.next, cur, l1 = l1, l1, l1.__next__
            else:
                cur.next, cur, l2 = l2, l2, l2.__next__

        if l1 != None:
            cur.next = l1
        if l2 != None:
            cur.next = l2

        return dummy.__next__

",nlogn
"
import collections


class Solution(object):
    def shareCandies(self, candies, k):
        cnt = collections.Counter(candies[i] for i in range(k, len(candies)))
        result = curr = len(cnt)
        for i in range(k, len(candies)):
            cnt[candies[i]] -= 1
            curr += (cnt[candies[i-k]] == 0) - (cnt[candies[i]] == 0)
            cnt[candies[i-k]] += 1
            result = max(result, curr)
        return result
",n
"
import collections



class Solution(object):
    def killProcess(self, pid, ppid, kill):
        def killAll(pid, children, killed):
            killed.append(pid)
            for child in children[pid]:
                killAll(child, children, killed)

        result = []
        children = collections.defaultdict(set)
        for i in range(len(pid)):
            children[ppid[i]].add(pid[i])
        killAll(kill, children, result)
        return result


",n
"
class Solution2(object):
    def killProcess(self, pid, ppid, kill):
        def killAll(pid, children, killed):
            killed.append(pid)
            for child in children[pid]:
                killAll(child, children, killed)

        result = []
        children = collections.defaultdict(set)
        for i in range(len(pid)):
            children[ppid[i]].add(pid[i])
        q = collections.deque()
        q.append(kill)
        while q:
            p = q.popleft()
            result.append(p)
            for child in children[p]:
                q.append(child)
        return result

",n
"
class Solution(object):
    def maxDistance(self, nums1, nums2):
        result = i = j = 0
        while i < len(nums1) and j < len(nums2):
            if nums1[i] > nums2[j]:
                i += 1
            else:
                result = max(result, j-i)
                j += 1
        return result
",n + m
"
class Solution(object):
    def findStrobogrammatic(self, n):
        lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}
        result = ['0', '1', '8'] if n%2 else ['']
        for i in range(n%2, n, 2):
            result = [a + num + b for a, b in lookup.items() if i != n-2 or a != '0' for num in result]
        return result


",n * 5^(n/2)
"class Solution2(object):
    def findStrobogrammatic(self, n):
        lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}
        def findStrobogrammaticRecu(n, k):
            if k == 0:
                return ['']
            elif k == 1:
                return ['0', '1', '8']
            result = []
            for num in findStrobogrammaticRecu(n, k - 2):
                for key, val in lookup.items():
                    if n != k or key != '0':
                        result.append(key + num + val)
            return result

        return findStrobogrammaticRecu(n, n)

",n * 5^(n/2)
"

class Solution(object):
    def makeSmallestPalindrome(self, s):
        return """".join(min(s[i], s[~i]) for i in range(len(s)))
",n
"
class Solution(object):
    def maximumGain(self, s, x, y):
        def score(s, a, x):
            i = result = 0
            for j in range(len(s)):
                s[i] = s[j]
                i += 1
                if i >= 2 and s[i-2:i] == a:
                    i -= 2
                    result += x
            s[:] = s[:i]
            return result
                
        s, a, b = list(s), list(""ab""), list(""ba"")
        if x < y:
            x, y = y, x
            a, b = b, a
        return score(s, a, x) + score(s, b, y)
",n
"

class Solution(object):
    def minimizeXor(self, num1, num2):
        def popcount(x):
            return bin(x)[2:].count('1')
        
        cnt1, cnt2 = popcount(num1), popcount(num2)
        result = num1
        cnt = abs(cnt1-cnt2)
        expect = 1 if cnt1 >= cnt2 else 0
        i = 0
        while cnt:
            if ((num1>>i)&1) == expect:
                cnt -= 1
                result ^= 1<<i
            i += 1
        return result
",logn
"
class Solution(object):
    def winnerOfGame(self, colors):
        cnt1 = cnt2 = 0
        for i in range(1, len(colors)-1):
            if not (colors[i-1] == colors[i] == colors[i+1]):
                continue
            if colors[i] == 'A':
                cnt1 += 1
            else:
                cnt2 += 1
        return cnt1 > cnt2
",n
"
class Solution(object):
    def maxProfit(self, inventory, orders):
        MOD = 10**9+7
        def check(inventory, orders, x):
            return count(inventory, x) > orders
        
        def count(inventory, x):
            return sum(count-x+1 for count in inventory if count >= x)

        left, right = 1, max(inventory)
        while left <= right:
            mid = left + (right-left)//2
            if not check(inventory, orders, mid):
                right = mid-1
            else:
                left = mid+1
        return (sum((left+cnt)*(cnt-left+1)//2 for cnt in inventory if cnt >= left) +
                (left-1)*(orders-count(inventory, left)))% MOD
",nlogm
"class Solution(object):
    def getMoneyAmount(self, n):
        dp = [[0]*(n+1) for _ in range(n+1)] 
        for j in range(n+1):
            for i in reversed(range(j-1)):
                dp[i][j] = min((k+1) + max(dp[i][k], dp[k+1][j]) for k in range(i, j))
        return dp[0][n]


",n^3
"class Solution2(object):
    def getMoneyAmount(self, n):
        dp = [[0]*(n+1) for _ in range(n+1)] 
        for i in reversed(range(n)):
            for j in range(i+2, n+1):
                dp[i][j] = min((k+1) + max(dp[i][k], dp[k+1][j]) for k in range(i, j))
        return dp[0][n]
",n^3
"

class Solution(object):
    def findPattern(self, board, pattern):
        def check(i, j):
            lookup = [-1]*26
            lookup2 = [False]*10
            for r in range(len(pattern)):
                for c in range(len(pattern[0])):
                    y = board[i+r][j+c]
                    if pattern[r][c].isdigit():
                        if int(pattern[r][c]) != y:
                            return False
                        continue
                    x = ord(pattern[r][c])-ord('a')
                    if lookup[x] == -1:
                        if lookup2[y]:
                            return False
                        lookup2[y] = True
                        lookup[x] = y
                        continue
                    if lookup[x] != y:
                        return False
            return True
                    
        return next(([i, j] for i in range(len(board)-len(pattern)+1) for j in range(len(board[0])-len(pattern[0])+1) if check(i, j)), [-1, -1])
    
",n * m * r * c
"
import itertools


class Solution(object):
    def heightChecker(self, heights):
        return sum(i != j for i, j in zip(heights, sorted(heights)))
",nlogn
"
class Solution(object):

    def __init__(self, nestedList):
        self.__depth = [[nestedList, 0]]


    def __next__(self):
        nestedList, i = self.__depth[-1]
        self.__depth[-1][1] += 1
        return nestedList[i].getInteger()


    def hasNext(self):
        while self.__depth:
            nestedList, i = self.__depth[-1]
            if i == len(nestedList):
                self.__depth.pop()
            elif nestedList[i].isInteger():
                    return True
            else:
                self.__depth[-1][1] += 1
                self.__depth.append([nestedList[i].getList(), 0])
        return False



",n
"

class Solution(object):
    def findScore(self, nums):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: (nums[x], x))
        lookup = [False]*len(nums)
        result = 0
        for i in idxs:
            if lookup[i]:
                continue
            lookup[i] = True
            if i-1 >= 0:
                lookup[i-1] = True
            if i+1 < len(lookup):
                lookup[i+1] = True
            result += nums[i]
        return result
",nlogn
"
class Solution(object):
    def hIndex(self, citations):
        n = len(citations)
        left, right = 0, n - 1
        while left <= right:
            mid = (left + right) / 2
            if citations[mid] >= n - mid:
                right = mid - 1
            else:
                left = mid + 1
        return n - left

",logn
"

class Solution(object):
    def longestIncreasingPath(self, matrix):
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        if not matrix:
            return 0
        
        in_degree = [[0]*len(matrix[0]) for _ in range(len(matrix))]
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                for di, dj in directions:
                    ni, nj = i+di, j+dj
                    if not (0 <= ni < len(matrix) and
                            0 <= nj < len(matrix[0]) and
                            matrix[ni][nj] > matrix[i][j]):
                        continue
                    in_degree[i][j] += 1
        q = []
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if not in_degree[i][j]:
                    q.append((i, j))
        result = 0
        while q:
            new_q = []
            for i, j in q:
                for di, dj in directions:
                    ni, nj = i+di, j+dj
                    if not (0 <= ni < len(matrix) and
                            0 <= nj < len(matrix[0]) and
                            matrix[i][j] > matrix[ni][nj]):
                        continue
                    in_degree[ni][nj] -= 1
                    if not in_degree[ni][nj]:
                        new_q.append((ni, nj))
            q = new_q
            result += 1         
        return result


",m * n
"
class Solution2(object):
    def longestIncreasingPath(self, matrix):
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def longestpath(matrix, i, j, max_lengths):
            if max_lengths[i][j]:
                return max_lengths[i][j]
            max_depth = 0
            for di, dj in directions:
                x, y = i+di, j+dj
                if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and \
                   matrix[x][y] < matrix[i][j]:
                    max_depth = max(max_depth, longestpath(matrix, x, y, max_lengths))
            max_lengths[i][j] = max_depth + 1
            return max_lengths[i][j]

        if not matrix:
            return 0
        result = 0
        max_lengths = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                result = max(result, longestpath(matrix, i, j, max_lengths))
        return result
",m * n
"
class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children


class Solution(object):
    def maxDepth(self, root):
        if not root:
            return 0
        depth = 0
        for child in root.children:
            depth = max(depth, self.maxDepth(child))
        return 1+depth

",n
"
class Solution(object):
    def isPathCrossing(self, path):
        x = y = 0
        lookup = {(0, 0)}
        for c in path:
            if c == 'E':
                x += 1
            elif c == 'W':
                x -= 1
            elif c == 'N':
                y += 1
            elif c == 'S':
                y -= 1
            if (x, y) in lookup:
                return True
            lookup.add((x, y))
        return False
",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def insertIntoBST(self, root, val):
        curr, parent = root, None
        while curr:
            parent = curr
            if val <= curr.val:
                curr = curr.left
            else:
                curr = curr.right
        if not parent:
            root = TreeNode(val)
        elif val <= parent.val:
            parent.left = TreeNode(val)
        else:
            parent.right = TreeNode(val)
        return root


",h
"class Solution2(object):
    def insertIntoBST(self, root, val):
        if not root:
            root = TreeNode(val)
        else:
            if val <= root.val:
                root.left = self.insertIntoBST(root.left, val)
            else:
                root.right = self.insertIntoBST(root.right, val)
        return root

",h
"

class Solution(object):
    def average(self, salary):
        total, mi, ma = 0, float(""inf""), float(""-inf"")
        for s in salary:
            total += s
            mi, ma = min(mi, s), max(ma, s)
        return 1.0*(total-mi-ma)/(len(salary)-2)


",n
"
class Solution2(object):
    def average(self, salary):
        return 1.0*(sum(salary)-min(salary)-max(salary))/(len(salary)-2)
",n
"
class Solution(object):
    def kLengthApart(self, nums, k):
        prev = -k-1
        for i in range(len(nums)):
            if not nums[i]:
                continue
            if i-prev <= k:
                return False
            prev = i
        return True
",n
"
class Solution(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):
        boxes.sort(reverse=True)
        result = 0
        for h in boxes:
            if h > warehouse[result]:
                continue
            result += 1
            if result == len(warehouse):
                break
        return result


",nlogn
"class Solution2(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):
        boxes.sort()
        for i in range(1, len(warehouse)):
            warehouse[i] = min(warehouse[i], warehouse[i-1])
        result, curr = 0, 0
        for h in reversed(warehouse):
            if boxes[curr] > h:
                continue
            result += 1
            curr += 1
            if curr == len(boxes):
                break
        return result
",nlogn + m
"

class Solution(object):
    def longestPrefix(self, s):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
        
        return s[:getPrefix(s)[-1]+1]


",n
"
class Solution2(object):
    def longestPrefix(self, s):
        M = 10**9+7
        D = 26
        def check(l, s):
            for i in range(l):
                if s[i] != s[len(s)-l+i]:
                    return False
            return True
    
        result, prefix, suffix, power = 0, 0, 0, 1
        for i in range(len(s)-1):
            prefix = (prefix*D + (ord(s[i])-ord('a'))) % M
            suffix = (suffix + (ord(s[len(s)-(i+1)])-ord('a'))*power) % M
            power = (power*D)%M
            if prefix == suffix:
                result = i+1
        return s[:result]
",n
"

class Solution(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        return [words[i] for i in range(n) if i == 0 or groups[i-1] != groups[i]]
",n
"
import collections


class Solution(object):
    def twoOutOfThree(self, nums1, nums2, nums3):
        K = 2
        cnt = collections.Counter()
        for nums in nums1, nums2, nums3:
            cnt.update(set(nums))
        return [x for x, c in cnt.items() if c >= K]


",n
"import collections


class Solution2(object):
    def twoOutOfThree(self, nums1, nums2, nums3):
        K = 2
        cnt = collections.Counter()
        result = []
        for nums in nums1, nums2, nums3:
            for x in set(nums):
                cnt[x] += 1
                if cnt[x] == K:
                    result.append(x)
        return result
",n
"
class Solution(object):
    def numberOfLines(self, widths, S):
        result = [1, 0]
        for c in S:
            w = widths[ord(c)-ord('a')]
            result[1] += w
            if result[1] > 100:
                result[0] += 1
                result[1] = w
        return result

",n
"
class Solution(object):
    def findKthBit(self, n, k):
        flip, l = 0, 2**n-1
        while k > 1:
            if k == l//2+1:
                flip ^= 1
                break
            if k > l//2:
                k = l+1-k
                flip ^= 1
            l //= 2
        return str(flip)
",n
"
from sortedcontainers import SortedList
import collections



class Solution(object):
    def findXSum(self, nums, k, x):
        def update(v, d, curr):
            if d == 1:
                sl.add((-cnt[v], -v))
            if sl.index((-cnt[v], -v)) < x:
                curr += d*cnt[v]*v
                if x < len(sl):
                    nc, nv = sl[x]
                    curr -= d*nc*nv
            if d != 1:
                sl.remove((-cnt[v], -v))
            return curr

        sl = SortedList()
        cnt = collections.defaultdict(int)
        result = []
        curr = 0
        for i, v in enumerate(nums):
            if v in cnt:
                curr = update(v, -1, curr)
            cnt[v] += 1
            curr = update(v, +1, curr)
            if i < k-1:
                continue
            result.append(curr)
            curr = update(nums[i-(k-1)], -1, curr)
            cnt[nums[i-(k-1)]] -= 1
            if cnt[nums[i-(k-1)]]:
                curr = update(nums[i-(k-1)], +1, curr)
            else:
                del cnt[nums[i-(k-1)]]
        return result
",nlogn
"
import bisect



class Solution(object):
    def answerQueries(self, nums, queries):
        nums.sort()
        for i in range(len(nums)-1):
            nums[i+1] += nums[i]
        return [bisect.bisect_right(nums, q) for q in queries]
",nlogn + qlogn
"

class Solution(object):
    def maximumGroups(self, grades):
        return int(((1+8*len(grades))**0.5-1)/2.0)
",1
"

class Solution(object):
    def getSmallestString(self, s):
        result = list(map(int, s))
        for i in range(len(s)-1):
            if result[i]%2 != result[i+1]%2:
                continue
            if result[i] > result[i+1]:
                result[i], result[i+1] = result[i+1], result[i]
                break
        return """".join(map(str, result))
",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def pathSum(self, root, sum):
        return self.pathSumRecu([], [], root, sum)


    def pathSumRecu(self, result, cur, root, sum):
        if root is None:
            return result

        if root.left is None and root.right is None and root.val == sum:
            result.append(cur + [root.val])
            return result

        cur.append(root.val)
        self.pathSumRecu(result, cur, root.left, sum - root.val)
        self.pathSumRecu(result, cur,root.right, sum - root.val)
        cur.pop()
        return result

",n
"
class Solution(object):
    def parseTernary(self, expression):
        if not expression:
            return """"

        stack = []
        for c in expression[::-1]:
            if stack and stack[-1] == '?':
                stack.pop() 
                first = stack.pop()
                stack.pop() 
                second = stack.pop()

                if c == 'T':
                    stack.append(first)
                else:
                    stack.append(second)
            else:
                stack.append(c)


        return str(stack[-1])

",n
"
import bisect



class Solution(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix, suffix = 0, sum(flowers[i] for i in range(n))
        result = left = 0
        for right in range(n+1):
            if right:
                suffix -= flowers[right-1]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                continue
            while not (left == right or (left and (total+prefix)//left <= flowers[left])):
                prefix += flowers[left]
                left += 1
            mn = min((total+prefix)//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result


",nlogn
"import bisect



class Solution2(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in range(n):
            prefix[i+1] = prefix[i]+flowers[i]
        result = suffix = 0
        left = n
        for right in reversed(range(n+1)):
            if right != n:
                suffix += flowers[right]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                continue
            left = min(left, right)
            while not (left == 0 or (prefix[left]-prefix[left-1])*left-prefix[left] <= total):
                left -= 1
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result


",nlogn
"import bisect



class Solution3(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        def check(prefix, total, x):
            return x and (total+prefix[x])//x <= prefix[x+1]-prefix[x]

        def binary_search(prefix, total, left, right):
            while left <= right:
                mid = left+(right-left)//2
                if check(prefix, total, mid):
                    right = mid-1
                else:
                    left = mid+1
            return left
    
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in range(n):
            prefix[i+1] = prefix[i]+flowers[i]
        suffix = sum(flowers[i] for i in range(n))
        result = left = 0
        for right in range(n+1):
            if right:
                suffix -= flowers[right-1]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                continue
            left = binary_search(prefix, total, 0, right-1)
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result


",nlogn
"import bisect



class Solution4(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        def check(prefix, total, x):
            return (prefix[x]-prefix[x-1])*x-prefix[x] <= total

        def binary_search_right(prefix, total, left, right):
            while left <= right:
                mid = left+(right-left)//2
                if not check(prefix, total, mid):
                    right = mid-1
                else:
                    left = mid+1
            return right
    
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in range(n):
            prefix[i+1] = prefix[i]+flowers[i]
        result = suffix = 0
        left = n
        for right in reversed(range(n+1)):
            if right != n:
                suffix += flowers[right]
            total = newFlowers-((n-right)*target-suffix)
            if total < 0:
                break
            left = binary_search_right(prefix, total, 1, right)
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result
",nlogn
"

class Solution(object):
    def longestAlternatingSubarray(self, nums, threshold):
        result = l = 0
        for x in nums:
            if x > threshold:
                l = 0
                continue
            if l%2 == x%2:
                l += 1
            else:
                l = int(x%2 == 0)
            result = max(result, l)
        return result
",n
"
import collections



class Solution(object):
    def subsequencesWithMiddleMode(self, nums):
        def nC2(x):
            return x*(x-1)//2

        MOD = 10**9+7
        result = 0
        left = collections.defaultdict(int)
        right = collections.defaultdict(int)
        for x in nums:
            right[x] += 1
        left_x_sq = 0 
        right_x_sq = sum(v**2 for v in right.values()) 
        left_x_right_x = 0 
        left_x_sq_right_x = 0 
        left_x_right_x_sq = 0 
        for i, v in enumerate(nums):
            left_x_sq -= left[v]**2
            right_x_sq -= right[v]**2
            left_x_right_x -= left[v]*right[v]
            left_x_sq_right_x -= left[v]**2*right[v]
            left_x_right_x_sq -= left[v]*right[v]**2
            right[v] -= 1

            l, r = i, len(nums)-(i+1)
            result += nC2(l)*nC2(r)
            result -= nC2(l-left[v])*nC2(r-right[v])
            result -= ((left_x_sq-(l-left[v]))*(r-right[v])-(left_x_sq_right_x-left_x_right_x))*right[v]//2
            result -= ((right_x_sq-(r-right[v]))*(l-left[v])-(left_x_right_x_sq-left_x_right_x))*left[v]//2
            result -= left[v]*left_x_right_x*(r-right[v])-left[v]*left_x_right_x_sq
            result -= right[v]*left_x_right_x*(l-left[v])-right[v]*left_x_sq_right_x
            result -= right[v]*(left_x_sq_right_x-left_x_right_x)//2
            result -= left[v]*(left_x_right_x_sq-left_x_right_x)//2

            left[v] += 1
            left_x_sq += left[v]**2
            right_x_sq += right[v]**2
            left_x_right_x += left[v]*right[v]
            left_x_sq_right_x += left[v]**2*right[v]
            left_x_right_x_sq += left[v]*right[v]**2
        return result % MOD
",n
"

   def get(self, index):
       pass

   def length(self):
       pass


class Solution(object):
    def findInMountainArray(self, target, mountain_arr):
        def binarySearch(A, left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left
        
        peak = binarySearch(mountain_arr, 0, mountain_arr.length()-1,
                            lambda x: mountain_arr.get(x) >= mountain_arr.get(x+1))
        left = binarySearch(mountain_arr, 0, peak,
                            lambda x: mountain_arr.get(x) >= target)
        if left <= peak and mountain_arr.get(left) == target:
            return left
        right = binarySearch(mountain_arr, peak, mountain_arr.length()-1,
                             lambda x: mountain_arr.get(x) <= target)
        if right <= mountain_arr.length()-1 and mountain_arr.get(right) == target:
            return right
        return -1
",logn
"
import itertools



class Solution(object):
    def minOperations(self, nums1, nums2):
        cnt = [0]*2
        for x, y in zip(nums1, nums2):
            if not (min(x, y) <= min(nums1[-1], nums2[-1]) and max(x, y) <= max(nums1[-1], nums2[-1])):
                return -1
            if not (x <= nums1[-1] and y <= nums2[-1]):
                cnt[0] += 1
            if not (x <= nums2[-1] and y <= nums1[-1]):
                cnt[1] += 1
        return min(cnt)


",n
"import itertools



class Solution2(object):
    def minOperations(self, nums1, nums2):
        INF = float(""inf"")
        def count(mx1, mx2):
            return sum(1 if y <= mx1 and x <= mx2 else INF for x, y in zip(nums1, nums2) if not (x <= mx1 and y <= mx2))

        result = min(count(nums1[-1], nums2[-1]), count(nums2[-1], nums1[-1]))
        return result if result != INF else -1
",n
"

class Solution(object):
    def countArrangement(self, N):
        def countArrangementHelper(n, arr):
            if n <= 0:
                return 1
            count = 0
            for i in range(n):
                if arr[i] % n == 0 or n % arr[i] == 0:
                    arr[i], arr[n-1] = arr[n-1], arr[i]
                    count += countArrangementHelper(n - 1, arr)
                    arr[i], arr[n-1] = arr[n-1], arr[i]
            return count

        return countArrangementHelper(N, list(range(1, N+1)))

",n!
"
import heapq



class Solution(object):
    def makePrefSumNonNegative(self, nums):
        result = prefix = 0
        min_heap = []
        for x in nums:
            heapq.heappush(min_heap, x)
            prefix += x
            if prefix < 0:
                prefix -= heapq.heappop(min_heap)
                result += 1
        return result
",nlogn
"
import collections


class Solution(object):
    def pathSum(self, nums):
        class Node(object):
            def __init__(self, num):
                self.level = num/100 - 1
                self.i = (num%100)/10 - 1
                self.val = num%10
                self.leaf = True

            def isParent(self, other):
                return self.level == other.level-1 and \
                       self.i == other.i/2

        if not nums:
            return 0
        result = 0
        q = collections.deque()
        dummy = Node(10)
        parent = dummy
        for num in nums:
            child = Node(num)
            while not parent.isParent(child):
                result += parent.val if parent.leaf else 0
                parent = q.popleft()
            parent.leaf = False
            child.val += parent.val
            q.append(child)
        while q:
            result += q.pop().val
        return result

",n
"

class Solution(object):
    def buildArray(self, nums):
        for i in range(len(nums)):
            prev, curr = i, nums[i]
            while curr >= 0 and curr != i:
                nums[prev], nums[curr] = ~nums[curr], ~nums[prev] if prev == i else nums[prev]
                prev, curr = curr, ~nums[prev]
        for i in range(len(nums)):
            if nums[i] < 0:
                nums[i] = ~nums[i]
        return nums


",n
"class Solution2(object):
    def buildArray(self, nums):
        return [nums[x] for x in nums]
",n
"
class Solution(object):
    def maxRotateFunction(self, A):
        s = sum(A)
        fi = 0
        for i in range(len(A)):
            fi += i * A[i]

        result = fi
        for i in range(1, len(A)+1):
            fi += s - len(A) * A[-i]
            result = max(result, fi)
        return result

",n
"
import itertools



class Solution(object):
    def largestVariance(self, s):
        def modified_kadane(a, x, y):
            result = curr = 0
            lookup = [0]*2
            remain = [a.count(x), a.count(y)]
            for c in a:
                if c not in (x, y):
                    continue
                lookup[c != x] = 1
                remain[c != x] -= 1
                curr += 1 if c == x else -1
                if curr < 0 and remain[0] and remain[1]:
                    curr = lookup[0] = lookup[1] = 0 
                if lookup[0] and lookup[1]:
                    result = max(result, curr) 
            return result

        alphabets = set(s)
        return max(modified_kadane(s, x, y) for x, y in itertools.permutations(alphabets, 2)) if len(alphabets) >= 2 else 0
",a^2 * n
"
class Solution(object):
    def maxSumAfterPartitioning(self, A, K):
        W = K+1
        dp = [0]*W
        for i in range(len(A)):
            curr_max = 0
            for k in range(1, min(K, i+1) + 1):
                curr_max = max(curr_max, A[i-k+1])
                dp[i % W] = max(dp[i % W], (dp[(i-k) % W] if i >= k else 0) + curr_max*k)
        return dp[(len(A)-1) % W]
",n * k
"
class Solution(object):
    def shoppingOffers(self, price, special, needs):
        def shoppingOffersHelper(price, special, needs, i):
            if i == len(special):
                return sum(map(lambda x, y: x*y, price, needs))
            result = shoppingOffersHelper(price, special, needs, i+1)
            for j in range(len(needs)):
                needs[j] -= special[i][j]
            if all(need >= 0 for need in needs):
                result = min(result, special[i][-1] + shoppingOffersHelper(price, special, needs, i))
            for j in range(len(needs)):
                needs[j] += special[i][j]
            return result

        return shoppingOffersHelper(price, special, needs, 0)

",n * 2^n
"
import collections
import bisect



class Solution(object):
    def gcdValues(self, nums, queries):
        cnt1 = collections.Counter(nums)
        cnt2 = [0]*(max(nums)+1)
        for g in reversed(range(1, len(cnt2))):
            c = sum(cnt1[ng] for ng in range(g, len(cnt2), g))
            cnt2[g] = c*(c-1)//2-sum(cnt2[ng] for ng in range(g+g, len(cnt2), g))
        prefix = [0]*(len(cnt2)+1)
        for i in range(len(prefix)-1):
            prefix[i+1] = prefix[i]+cnt2[i]
        return [bisect.bisect_right(prefix, q)-1 for q in queries]
",rlogr + qlogr
"
import collections


class UnionFind(object): 
    def __init__(self, vals):
        self.set = list(range(len(vals)))
        self.rank = [0]*len(vals)
        self.cnt = [collections.Counter({v:1}) for v in vals]  

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y, v): 
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return 0 
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        cx, cy = self.cnt[x][v], self.cnt[y][v] 
        self.cnt[y] = collections.Counter({v:cx+cy}) 
        return cx*cy 



class Solution(object):
    def numberOfGoodPaths(self, vals, edges):
        edges.sort(key=lambda x: max(vals[x[0]], vals[x[1]]))
        uf = UnionFind(vals)
        return len(vals)+sum(uf.union_set(i, j, max(vals[i], vals[j])) for i, j in edges)
",nlogn
"
import itertools



class Solution(object):
    def countUnguarded(self, m, n, guards, walls):
        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        GREEN, RED, BLOCK = list(range(3))
        grid = [[GREEN]*n for _ in range(m)]
        for r, c in itertools.chain(guards, walls):
            grid[r][c] = BLOCK
        for r, c in guards:
            for dr, dc in DIRECTIONS:
                nr, nc = r+dr, c+dc
                while 0 <= nr < m and 0 <= nc < n and grid[nr][nc] != BLOCK:
                    grid[nr][nc] = RED
                    nr, nc = nr+dr, nc+dc
        return sum(grid[r][c] == GREEN for r in range(m) for c in range(n))
",m * n
"
class Solution(object):
    def constructDistancedSequence(self, n):
        def backtracking(n, i, result, lookup):
            if i == len(result):
                return True
            if result[i]:
                return backtracking(n, i+1, result, lookup)
            for x in reversed(range(1, n+1)):
                j = i if x == 1 else i+x
                if lookup[x] or j >= len(result) or result[j]:
                    continue
                result[i], result[j], lookup[x] = x, x, True
                if backtracking(n, i+1, result, lookup):
                    return True
                result[i], result[j], lookup[x] = 0, 0, False
            return False

        result, lookup = [0]*(2*n-1), [False]*(n+1)
        backtracking(n, 0, result, lookup)
        return result
",n!
"
import collections


class Solution(object):
    def watchedVideosByFriends(self, watchedVideos, friends, id, level):
        curr_level, lookup = set([id]), set([id])
        for _ in range(level):
            curr_level = set(j for i in curr_level for j in friends[i] if j not in lookup)
            lookup |= curr_level
        count = collections.Counter([v for i in curr_level for v in watchedVideos[i]])
        return sorted(list(count.keys()), key=lambda x: (count[x], x))
",n + vlogv
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def findNeartestRightNode(self, root, u):
        q = [root]
        while q:
            new_q = []
            for i, node in enumerate(q):
                if node == u:
                    return q[i+1] if i+1 < len(q) else None
                if node.left:
                    new_q.append(node.left)
                if node.right:
                    new_q.append(node.right)
            q = new_q
        return None
",n
"
class Solution(object):
    def maxProfit(self, prices):
        max_profit, min_price = 0, float(""inf"")
        for price in prices:
            min_price = min(min_price, price)
            max_profit = max(max_profit, price - min_price)
        return max_profit

",n
"

class Solution(object):
    def shiftDistance(self, s, t, nextCost, previousCost):
        prefix1 = [0]*(len(nextCost)+1)
        for i in range(len(nextCost)):
            prefix1[i+1] = prefix1[i]+nextCost[i]
        prefix2 = [0]*(len(previousCost)+1)
        for i in range(len(previousCost)):
            prefix2[i+1] = prefix2[i]+previousCost[i]
        result = 0
        for i in range(len(s)):
            if s[i] == t[i]:
                continue
            left = ord(s[i])-ord('a')
            right = ord(t[i])-ord('a')
            if left <= right:
                result += min(prefix1[right]-prefix1[left], prefix2[-1]-(prefix2[right+1]-prefix2[left+1]))
            else:
                result += min(prefix2[left+1]-prefix2[right+1], prefix1[-1]-(prefix1[left]-prefix1[right]))
        return result
",n + 26
"

class Solution(object):
    def maxValueOfCoins(self, piles, k):
        dp = [0]
        for pile in piles:
            new_dp = [0]*min(len(dp)+len(pile), k+1)
            for i in range(len(dp)):
                curr = 0
                for j in range(min(k-i, len(pile))+1):
                    new_dp[i+j] = max(new_dp[i+j], dp[i]+curr)
                    curr += pile[j] if j < len(pile) else 0
            dp = new_dp
        return dp[-1]
","min(n * k^2, m * k)"
"

class Solution(object):
    def longestSubarray(self, nums):
        mx = max(nums)
        result, l = 1, 0
        for x in nums:
            if x == mx:
                l += 1
                result = max(result, l)
            else:
                l = 0
        return result
",n
"
import collections


class Solution(object):
    def uniqueOccurrences(self, arr):
        count = collections.Counter(arr)
        lookup = set()
        for v in count.values():
            if v in lookup:
                return False
            lookup.add(v)
        return True


",n
"class Solution2(object):
    def uniqueOccurrences(self, arr):
        count = collections.Counter(arr)
        return len(count) == len(set(count.values()))
",n
"
from collections import defaultdict

class Solution(object):
    def isRectangleCover(self, rectangles):
        left = min(rec[0] for rec in rectangles)
        bottom = min(rec[1] for rec in rectangles)
        right = max(rec[2] for rec in rectangles)
        top = max(rec[3] for rec in rectangles)

        points = defaultdict(int)
        for l, b, r, t in rectangles:
            for p, q in zip(((l, b), (r, b), (l, t), (r, t)), (1, 2, 4, 8)):
                if points[p] & q:
                    return False
                points[p] |= q

        for px, py in points:
            if left < px < right or bottom < py < top:
                if points[(px, py)] not in (3, 5, 10, 12, 15):
                    return False

        return True

",n
"
class Solution(object):
    def findReplaceString(self, S, indexes, sources, targets):
        bucket = [None] * len(S)
        for i in range(len(indexes)):
            if all(indexes[i]+k < len(S) and S[indexes[i]+k] == sources[i][k]
                   for k in range(len(sources[i]))):
                bucket[indexes[i]] = (len(sources[i]), list(targets[i]))
        result = []
        i = 0
        while i < len(S):
            if bucket[i]:
                result.extend(bucket[i][1])
                i += bucket[i][0]
            else:
                result.append(S[i])
                i += 1
        return """".join(result)


",n + m
"class Solution2(object):
    def findReplaceString(self, S, indexes, sources, targets):
        for i, s, t in sorted(zip(indexes, sources, targets), reverse=True):
            if S[i:i+len(s)] == s:
                S = S[:i] + t + S[i+len(s):]

        return S
",mlogm + m * n
"

class Solution(object):
    def minimumSeconds(self, land):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        lookup = [[-1 if land[i][j] == ""*"" else 0 for j in range(len(land[0]))] for i in range(len(land))]
        q = [(i, j, -1) for i in range(len(land)) for j in range(len(land[0])) if land[i][j] == ""*""]
        q.append(next((i, j, 1) for i in range(len(land)) for j in range(len(land[0])) if land[i][j] == ""S""))
        lookup[q[-1][0]][q[-1][1]] = 1
        while q:
            new_q = []
            for i, j, d in q:
                if land[i][j] == ""D"":
                    return d-1
                for di, dj in DIRECTIONS:
                    ni, nj = i+di, j+dj
                    if not (0 <= ni < len(land) and 0 <= nj < len(land[0]) and land[ni][nj] != ""X"" and lookup[ni][nj] != -1):
                        continue
                    if d != -1 and lookup[ni][nj] == 0:
                        lookup[ni][nj] = 1
                        new_q.append((ni, nj, d+1))
                    elif d == -1 and land[ni][nj] != ""D"":
                        lookup[ni][nj] = -1
                        new_q.append((ni, nj, -1))
            q = new_q
        return -1


",m * n
"
class Solution2(object):
    def minimumSeconds(self, land):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        lookup1 = [[0 if land[i][j] == ""*"" else -1 for j in range(len(land[0]))] for i in range(len(land))]
        lookup2 = [[-1]*len(land[0]) for _ in range(len(land))]
        q1 = [(i, j) for i in range(len(land)) for j in range(len(land[0])) if land[i][j] == ""*""]
        q2 = [next((i, j) for i in range(len(land)) for j in range(len(land[0])) if land[i][j] == ""S"")]
        lookup2[q2[0][0]][q2[0][1]] = 0
        while q1 or q2:
            new_q1, new_q2 = [], []
            for i, j in q1:
                for di, dj in DIRECTIONS:
                    ni, nj = i+di, j+dj
                    if not (0 <= ni < len(land) and 0 <= nj < len(land[0]) and land[ni][nj] != ""X"" and land[ni][nj] != ""D"" and lookup1[ni][nj] == -1):
                        continue
                    lookup1[ni][nj] = 0
                    new_q1.append((ni, nj))
            for i, j in q2:
                if land[i][j] == ""D"":
                    return lookup2[i][j]
                for di, dj in DIRECTIONS:
                    ni, nj = i+di, j+dj
                    if not (0 <= ni < len(land) and 0 <= nj < len(land[0]) and land[ni][nj] != ""X"" and lookup2[ni][nj] == lookup1[ni][nj] == -1):
                        continue
                    lookup2[ni][nj] = lookup2[i][j]+1
                    new_q2.append((ni, nj))
            q1, q2 = new_q1, new_q2
        return -1
",m * n
"
class Solution(object):
    def canWinNim(self, n):
        return n % 4 != 0

",1
"

class Solution(object):
    def findNumOfValidWords(self, words, puzzles):
        L = 7
        def search(node, puzzle, start, first, met_first):
            result = 0
            if ""_end"" in node and met_first:
                result += node[""_end""]
            for i in range(start, len(puzzle)):
                if puzzle[i] not in node:
                    continue
                result += search(node[puzzle[i]], puzzle, i+1,
                                 first, met_first or (puzzle[i] == first))
            return result

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for word in words:
            count = set(word)
            if len(count) > L:
                continue
            word = sorted(count)
            end = reduce(dict.__getitem__, word, trie)
            end[""_end""] = end[""_end""]+1 if ""_end"" in end else 1
        result = []
        for puzzle in puzzles:
            first = puzzle[0]
            result.append(search(trie, sorted(puzzle), 0, first, False))
        return result


",n*l + m*L
"
import collections
from functools import reduce


class Solution2(object):
    def findNumOfValidWords(self, words, puzzles):
        L = 7
        lookup = collections.defaultdict(list)
        for i in range(len(puzzles)):
            bits = []
            base = 1 << (ord(puzzles[i][0])-ord('a'))
            for j in range(1, L):
                bits.append(ord(puzzles[i][j])-ord('a'))
            for k in range(2**len(bits)):
                bitset = base
                for j in range(len(bits)):
                    if k & (1<<j):
                        bitset |= 1<<bits[j]
                lookup[bitset].append(i)
        result = [0]*len(puzzles)
        for word in words:
            bitset = 0
            for c in word:
                bitset |= 1<<(ord(c)-ord('a'))
            if bitset not in lookup:
                continue
            for i in lookup[bitset]:
                result[i] += 1
        return result
",m*2^(L-1) + n*(l+m)
"
class Solution(object):
    def numWaterBottles(self, numBottles, numExchange):
        result = numBottles
        while numBottles >= numExchange:
            numBottles, remainder = divmod(numBottles, numExchange)
            result += numBottles
            numBottles += remainder
        return result
",logn/logm
"

class Solution(object):
    def maximumDetonation(self, bombs):
        adj = [[] for _ in range(len(bombs))]
        for i, (xi, yi, ri) in enumerate(bombs):
            for j, (xj, yj, _) in enumerate(bombs):
                if j == i:
                    continue
                if (xi-xj)**2+(yi-yj)**2 <= ri**2:
                    adj[i].append(j)
        result = 0
        for i in range(len(bombs)):
            q = [i]
            lookup = {i}
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if v in lookup:
                            continue
                        lookup.add(v)
                        new_q.append(v)
                q = new_q
            result = max(result, len(lookup))
            if result == len(bombs):
                break
        return result


",|V|^2 + |V| * |E|
"
class Solution2(object):
    def maximumDetonation(self, bombs):
        adj = [[] for _ in range(len(bombs))]
        for i, (xi, yi, ri) in enumerate(bombs):
            for j, (xj, yj, _) in enumerate(bombs):
                if j == i:
                    continue
                if (xi-xj)**2+(yi-yj)**2 <= ri**2:
                    adj[i].append(j)
        result = 0
        for i in range(len(bombs)):
            stk = [i]
            lookup = {i}
            while stk:
                u = stk.pop()
                for v in adj[u]:
                    if v in lookup:
                        continue
                    lookup.add(v)
                    stk.append(v)
            result = max(result, len(lookup))
            if result == len(bombs):
                break
        return result
",|V|^2 + |V| * |E|
"

class Solution(object):
    def longestPalindrome(self, s, t):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        def longest_palindrome(s):
            result = [0]*(len(s)+1)
            P = manacher(s)
            for i in range(1, len(P)-1):
                result[(i-P[i])//2] = P[i]
            return result

        t = t[::-1]
        p1 = longest_palindrome(s)
        p2 = longest_palindrome(t)
        result = 0
        dp = [[0]*(len(t)+1) for _ in range(len(s)+1)]
        for i in range(len(s)):
            for j in range(len(t)):
                dp[i+1][j+1] = dp[i][j]+2 if s[i] == t[j] else 0
                result = max(result, dp[i+1][j+1]+max(p1[i+int(s[i] == t[j])] , p2[j+int(s[i] == t[j])]))
        return result
",n * m
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def buildTree(self, inorder, postorder):
        lookup = {}
        for i, num in enumerate(inorder):
            lookup[num] = i
        return self.buildTreeRecu(lookup, postorder, inorder, len(postorder), 0, len(inorder))

    def buildTreeRecu(self, lookup, postorder, inorder, post_end, in_start, in_end):
        if in_start == in_end:
            return None
        node = TreeNode(postorder[post_end - 1])
        i = lookup[postorder[post_end - 1]]
        node.left = self.buildTreeRecu(lookup, postorder, inorder, post_end - 1 - (in_end - i - 1), in_start, i)
        node.right = self.buildTreeRecu(lookup, postorder, inorder, post_end - 1, i + 1, in_end)
        return node

",n
"
class Solution(object):
    def strangePrinter(self, s):
        def dp(s, i, j, lookup):
            if i > j:
                return 0
            if (i, j) not in lookup:
                lookup[(i, j)]  = dp(s, i, j-1, lookup) + 1
                for k in range(i, j):
                    if s[k] == s[j]:
                        lookup[(i, j)] = min(lookup[(i, j)], \
                                             dp(s, i, k, lookup) + dp(s, k+1, j-1, lookup))
            return lookup[(i, j)]

        lookup = {}
        return dp(s, 0, len(s)-1, lookup)

",n^3
"


def iter_get_articulation_points(graph, v): 
    def iter_dfs(v, p):
        stk = [(1, (v, p))]
        while stk:
            step, args = stk.pop()
            if step == 1:
                v, p = args
                index[v] = index_counter[0]
                lowlinks[v] = index_counter[0]
                index_counter[0] += 1
                children_count = [0]
                is_cut = [False]
                stk.append((4, (v, p, children_count, is_cut)))
                for w in reversed(graph[v]):
                    if w == p:
                        continue
                    stk.append((2, (w, v, children_count, is_cut)))
            elif step == 2:
                w, v, children_count, is_cut = args
                if index[w] == -1:
                    children_count[0] += 1
                    stk.append((3, (w, v, is_cut)))
                    stk.append((1, (w, v)))
                else:
                    lowlinks[v] = min(lowlinks[v], index[w])
            elif step == 3:
                w, v, is_cut = args
                if lowlinks[w] >= index[v]:
                    is_cut[0] = True
                lowlinks[v] = min(lowlinks[v], lowlinks[w])
            elif step == 4:
                v, p, children_count, is_cut = args
                if (p != -1 and is_cut[0]) or (p == -1 and children_count[0] >= 2):
                    cutpoints.append(v)
    index_counter, index, lowlinks = [0], [-1]*len(graph), [0]*len(graph)
    cutpoints = []
    iter_dfs(v, -1) 
    return cutpoints



class Solution(object):
    def minDays(self, grid):
        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
        def floodfill(grid, i, j, lookup):
            stk = [(i, j)]
            lookup[i][j] = 1
            while stk:
                i, j = stk.pop()
                for di, dj in DIRECTIONS:
                    ni, nj = i+di, j+dj
                    if not (0 <= ni < R and 0 <= nj < C and grid[ni][nj] and not lookup[ni][nj]):
                        continue
                    lookup[ni][nj] = 1
                    stk.append((ni, nj))
         
        def count_islands(grid):
            lookup = [[0]*C for _ in range(R)]
            island_cnt = 0
            for i in range(R):
                for j in range(C):
                    if grid[i][j] == 0 or lookup[i][j]:
                        continue
                    island_cnt += 1
                    floodfill(grid, i, j, lookup)
            return island_cnt

        R, C = len(grid), len(grid[0])
        if count_islands(grid) != 1:
            return 0
        adj = [[] for _ in range(R*C)]
        cnt, idx = 0, -1
        for i in range(R):
            for j in range(C):
                if grid[i][j] == 0:
                    continue
                cnt += 1
                if idx == -1:
                    idx = i*C+j
                for di, dj in DIRECTIONS:
                    ni, nj = i+di, j+dj
                    if  0 <= ni < R and 0 <= nj < C and grid[ni][nj] == grid[i][j]:
                        adj[i*C+j].append(ni*C+nj)
        return 1 if cnt == 1 or iter_get_articulation_points(adj, idx) else 2


",m * n
"
class PersistentUnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.size = [1]*n
        self.snapshots = [] 
        self.undos = [] 

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            y = stk.pop()
            self.undos.append((~y, self.set[y])) 
            self.set[y] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.size[x] > self.size[y]: 
            x, y = y, x
        self.undos.append((x, y)) 
        self.set[x] = self.set[y]
        self.size[y] += self.size[x]
        return True

    def total(self, x):
        return self.size[self.find_set(x)]

    def snapshot(self): 
        self.snapshots.append(len(self.undos))

    def rollback(self): 
        for _ in range(len(self.undos)-self.snapshots.pop()):
            x, y = self.undos.pop()
            if x >= 0:
                self.size[y] -= self.size[x]
                self.set[x] = x
            else:
                self.set[~x] = y



class Solution2(object):
    def minDays(self, grid):
        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
        def floodfill(grid, i, j, lookup):
            stk = [(i, j)]
            lookup[i][j] = 1
            while stk:
                i, j = stk.pop()
                for di, dj in DIRECTIONS:
                    ni, nj = i+di, j+dj
                    if not (0 <= ni < R and 0 <= nj < C and grid[ni][nj] and not lookup[ni][nj]):
                        continue
                    lookup[ni][nj] = 1
                    stk.append((ni, nj))
         
        def count_islands(grid):
            lookup = [[0]*C for _ in range(R)]
            island_cnt = 0
            for i in range(R):
                for j in range(C):
                    if grid[i][j] == 0 or lookup[i][j]:
                        continue
                    island_cnt += 1
                    floodfill(grid, i, j, lookup)
            return island_cnt
    
        def merge(i):
            r, c = divmod(i, C)
            for dr, dc in DIRECTIONS:
                nr, nc = r+dr, c+dc
                ni = nr*C+nc
                if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] == grid[r][c] and lookup[ni]:
                    uf.union_set(i, ni)

        def check(i):
            r, c = divmod(i, C)
            if grid[r][c] == 0:
                return False
            lookup = set()
            for dr, dc in DIRECTIONS:
                nr, nc = r+dr, c+dc
                if  0 <= nr < R and 0 <= nc < C and grid[nr][nc] == grid[r][c]:
                    lookup.add(uf.find_set(nr*C+nc))
            return len(lookup) != 1

        def dfs(left, right):
            if left == right:
                return check(left)
            mid = left + (right-left)//2
            l1, r1, l2, r2 = left, mid, mid+1, right
            for _ in range(2):
                uf.snapshot()
                for i in range(l1, r1+1):
                    lookup[i] = True
                    merge(i)
                if dfs(l2, r2):
                    return True
                for i in range(l1, r1+1):
                    lookup[i] = False
                uf.rollback()
                l1, r1, l2, r2 = l2, r2, l1, r1
            return False

        R, C = len(grid), len(grid[0])
        if count_islands(grid) != 1:
            return 0
        uf = PersistentUnionFind(R*C)
        lookup = [False]*(R*C)
        return 1 if dfs(0, R*C-1) else 2


",(m * n) * log(m * n)
"
class Solution3(object):
    def minDays(self, grid):
        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
        def floodfill(grid, i, j, lookup):
            stk = [(i, j)]
            lookup[i][j] = 1
            while stk:
                i, j = stk.pop()
                for di, dj in DIRECTIONS:
                    ni, nj = i+di, j+dj
                    if not (0 <= ni < R and 0 <= nj < C and grid[ni][nj] and not lookup[ni][nj]):
                        continue
                    lookup[ni][nj] = 1
                    stk.append((ni, nj))
         
        def count_islands(grid):
            lookup = [[0]*C for _ in range(R)]
            island_cnt = 0
            for i in range(R):
                for j in range(C):
                    if grid[i][j] == 0 or lookup[i][j]:
                        continue
                    island_cnt += 1
                    floodfill(grid, i, j, lookup)
            return island_cnt

        R, C = len(grid), len(grid[0])
        if count_islands(grid) != 1:
            return 0
        for i in range(R):
            for j in range(C):
                if grid[i][j] == 0:
                    continue
                grid[i][j] = 0
                island_cnt = count_islands(grid)
                grid[i][j] = 1
                if island_cnt != 1:
                    return 1
        return 2
",m^2 * n^2
"

class Solution(object):
    def bestHand(self, ranks, suits):
        LOOKUP = ["""", ""High Card"", ""Pair"", ""Three of a Kind"", ""Three of a Kind"", ""Three of a Kind""]
        if all(suits[i] == suits[0] for i in range(1, len(suits))):
            return ""Flush""
        cnt = [0]*13
        for x in ranks:
            cnt[x-1] += 1
        return LOOKUP[max(cnt)]
",1
"

class Solution(object):
    def getCommon(self, nums1, nums2):
        i = j = 0
        while i < len(nums1) and j < len(nums2):
            if nums1[i] < nums2[j]:
                i += 1
            elif nums1[i] > nums2[j]:
                j += 1
            else:
                return nums1[i]
        return -1
",n
"

class Solution(object):
    def placedCoins(self, edges, cost):
        def iter_dfs():
            result = [0]*len(cost)
            stk = [(1, (0, -1, [cost[0]]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    stk.append((4, (u, ret)))
                    stk.append((2, (u, p, 0, ret)))
                elif step == 2:
                    u, p, i, ret = args
                    if i == len(adj[u]):
                        continue
                    v = adj[u][i]
                    stk.append((2, (u, p, i+1, ret)))
                    if v == p:
                        continue
                    new_ret = [cost[v]]
                    stk.append((3, (new_ret, ret)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    new_ret, ret = args
                    ret.extend(new_ret)
                    ret.sort()
                    if len(ret) > 5:
                        ret = ret[:2]+ret[-3:]
                elif step == 4:
                    u, ret = args
                    result[u] = 1 if len(ret) < 3 else max(ret[0]*ret[1]*ret[-1], ret[-3]*ret[-2]*ret[-1], 0)
            return result
                
        adj = [[] for _ in range(len(cost))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()


",n
"
class Solution2(object):
    def placedCoins(self, edges, cost):
        def dfs(u, p):
            arr = [cost[u]]
            for v in adj[u]:
                if v == p:
                    continue
                arr.extend(dfs(v, u))
                arr.sort()
                if len(arr) > 5:
                    arr = arr[:2]+arr[-3:]
            result[u] = 1 if len(arr) < 3 else max(arr[0]*arr[1]*arr[-1], arr[-3]*arr[-2]*arr[-1], 0)
            return arr
                
        adj = [[] for _ in range(len(cost))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*len(cost)
        dfs(0, -1)
        return result
",n
"
import bisect


class Solution(object):
    def minOperations(self, target, arr):
        lookup = {x:i for i, x in enumerate(target)}
        lis = []
        for x in arr:
            if x not in lookup:
                continue
            i = bisect.bisect_left(lis, lookup[x])
            if i == len(lis):
                lis.append(lookup[x])
            else:
                lis[i] = lookup[x]
        return len(target)-len(lis)
class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y), 
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h) 
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))


",nlogn
"
class Solution2(object):
    def minOperations(self, target, arr):
        lookup = {x:i for i, x in enumerate(target)}
        st = SegmentTree(len(lookup))
        for x in arr:
            if x not in lookup:
                continue
            st.update(lookup[x], lookup[x], st.query(0, lookup[x]-1)+1 if lookup[x] >= 1 else 1)
        return len(target)-(st.query(0, len(lookup)-1) if len(lookup) >= 1 else 0)
",nlogn
"

class Solution(object):
    def isFascinating(self, n):
        lookup = [0]
        def check(x):
            while x:
                x, d = divmod(x, 10)
                if d == 0 or lookup[0]&(1<<d):
                    return False
                lookup[0] |= (1<<d)
            return True
    
        return check(n) and check(2*n) and check(3*n)


",logn
"
class Solution2(object):
    def isFascinating(self, n):
        s = str(n)+str(2*n)+str(3*n)
        return '0' not in s and len(s) == 9 and len(set(s)) == 9
",logn
"
import heapq



class Solution(object):
    def minimumCost(self, source, target, original, changed, cost):
        INF = float(""inf"")
        def dijkstra(start):
            best = {start:0}
            min_heap = [(0, start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if curr > best[u]:
                    continue
                if u not in dist:
                    continue
                for v, w in dist[u].items():     
                    if v in best and best[v] <= curr+w:
                        continue
                    best[v] = curr+w
                    heapq.heappush(min_heap, (best[v], v))
            return best

        memo = {}
        def memoization(u, v):
            if u not in memo:
                memo[u] = dijkstra(u)
            return memo[u][v] if v in memo[u] else INF

        dist = {}
        for i in range(len(original)):
            u, v = ord(original[i])-ord('a'), ord(changed[i])-ord('a')
            if u not in dist:
                dist[u] = {v:INF}
            if v not in dist[u]:
                dist[u][v] = INF
            dist[u][v] = min(dist[u][v], cost[i])
        result = sum(memoization(ord(source[i])-ord('a'), ord(target[i])-ord('a')) for i in range(len(source)))
        return result if result != INF else -1


",o + k * eloge + n
"
class Solution2(object):
    def minimumCost(self, source, target, original, changed, cost):
        INF = float(""inf"")
        def floydWarshall(dist):
            for k in range(len(dist)):
                for i in range(len(dist)):
                    if dist[i][k] == INF:
                        continue
                    for j in range(len(dist[i])):
                        if dist[k][j] == INF:
                            continue
                        dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])

        dist = [[0 if u == v else INF for v in range(26)] for u in range(26)]
        for i in range(len(original)):
            u, v = ord(original[i])-ord('a'), ord(changed[i])-ord('a')
            dist[u][v] = min(dist[u][v], cost[i])
        floydWarshall(dist)
        result = sum(dist[ord(source[i])-ord('a')][ord(target[i])-ord('a')] for i in range(len(source)))
        return result if result != INF else -1
",o + 26^3 + n
"

class Solution(object):
    def countSubstrings(self, s, c):
        n = s.count(c)
        return (n+1)*n//2
",n
"
import random
import itertools
import math




random.seed(0)
class Solution(object):
    def beautifulPair(self, nums1, nums2):
        INF = float(""inf"")
        def dist(a, b):
            if a[2] > b[2]:
                a, b = b, a
            return [abs(a[0]-b[0])+abs(a[1]-b[1]), a[2], b[2]]

        def cell(point, size):
            x, y, _ = point
            return math.floor(x/size), math.floor(y/size)

        def improve():
            lookup = {}
            for p in points:
                i, j = list(map(int, cell(p, result[0]/2.0)))
                for ni in range(i-2, (i+2)+1):
                    for nj in range(j-2, (j+2)+1):
                        if (ni, nj) not in lookup:
                            continue
                        d = dist(p, lookup[ni, nj])
                        if d < result:
                            result[:] = d
                            return True
                lookup[i, j] = p
            return False

        points = [(i, j, idx) for idx, (i, j) in enumerate(zip(nums1, nums2))]
        result = [INF]*3
        lookup = {}
        for i in reversed(range(len(points))):
            if points[i][:2] in lookup:
                result = [0, i, lookup[points[i][:2]]]
            lookup[points[i][:2]] = i
        if result[0] == 0:
            return result[1:]
        random.shuffle(points)
        result = dist(points[0], points[1])
        while improve():
            pass
        return result[1:]


",n
"import itertools




class Solution2(object):
    def beautifulPair(self, nums1, nums2):
        INF = float(""inf"")
        MAX_NEIGHBOR_COUNT = (8+2)//2
        def dist(a, b):
            if a > b:
                a, b = b, a
            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]

        def merge_sort(left, right):
            def update(arr, i): 
                for j in reversed(range(len(arr))):
                    if points[i][1]-points[arr[j]][1] > result[0]:
                        break
                    result[:] = min(result, dist(i, arr[j]))
                else:
                    j = -1
                assert((len(arr)-1)-j <= MAX_NEIGHBOR_COUNT)

            if left == right:
                return
            mid = left+(right-left)//2
            x = points[order[mid]][0] 
            merge_sort(left, mid)
            merge_sort(mid+1, right)
            tmp, tmp_l, tmp_r = [], [], []
            l, r = left, mid+1
            while l <= mid or r <= right:
                if r == right+1 or (l <= mid and points[order[l]][1] <= points[order[r]][1]): 
                    update(tmp_r, order[l])
                    if x-points[order[l]][0] <= result[0]: 
                        tmp_l.append(order[l])
                    tmp.append(order[l])
                    l += 1
                else:
                    update(tmp_l, order[r])
                    if points[order[r]][0]-x <= result[0]: 
                        tmp_r.append(order[r])
                    tmp.append(order[r])
                    r += 1
            order[left:right+1] = tmp

        points = [(i, j) for i, j in zip(nums1, nums2)]
        result = [INF]*3
        lookup = {}
        for i in reversed(range(len(points))):
            if points[i] in lookup:
                result = [0, (i, lookup[points[i]])]
            lookup[points[i]] = i
        if result[0] == 0:
            return result[1]
        order = list(range(len(points)))
        order.sort(key=lambda x: points[x][0])
        merge_sort(0, len(points)-1)
        return result[1:]


",nlogn
"import itertools




class Solution3(object):
    def beautifulPair(self, nums1, nums2):
        INF = float(""inf"")
        MAX_NEIGHBOR_COUNT = 8
        def dist(a, b):
            if a > b:
                a, b = b, a
            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]

        def merge_sort(left, right):
            if left == right:
                return
            mid = left + (right-left)//2
            x = points[order[mid]][0] 
            merge_sort(left, mid)
            merge_sort(mid+1, right)
            r = mid+1
            tmp = []
            for l in range(left, mid+1):
                while r <= right and points[order[r]][1] < points[order[l]][1]: 
                    tmp.append(order[r])
                    r += 1
                tmp.append(order[l])
            order[left:left+len(tmp)] = tmp

            stripe = [order[i] for i in range(left, right+1) if abs(points[order[i]][0]-x) <= result[0]]
            for i in range(len(stripe)-1):
                for j in range(i+1, len(stripe)):
                    x, y = stripe[i], stripe[j]
                    if points[y][1]-points[x][1] > result[0]:
                        break
                    result[:] = min(result, dist(x, y))
                else:
                    j = len(stripe)
                assert(j-(i+1) <= MAX_NEIGHBOR_COUNT)

        points = [(i, j) for i, j in zip(nums1, nums2)]
        result = [INF]*3
        lookup = {}
        for i in reversed(range(len(points))):
            if points[i] in lookup:
                result = [0, (i, lookup[points[i]])]
            lookup[points[i]] = i
        if result[0] == 0:
            return result[1]
        order = list(range(len(points)))
        order.sort(key=lambda x: points[x][0])
        merge_sort(0, len(points)-1)
        return result[1:]


",nlogn
"import itertools



class Solution4(object):
    def beautifulPair(self, nums1, nums2):
        INF = float(""inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: [-INF, -INF], 
                         query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                         update_fn=lambda x: x):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return [-INF, -INF] 
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        def dist(a, b):
            if a > b:
                a, b = b, a
            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]

        points = [(i, j) for i, j in zip(nums1, nums2)]
        result = [INF]*3
        lookup = {}
        for i in reversed(range(len(points))):
            if points[i] in lookup:
                result = [0, (i, lookup[points[i]])]
            lookup[points[i]] = i
        if result[0] == 0:
            return result[1]
        order = list(range(len(points)))
        order.sort(key=lambda x: points[x][0])
        y_set = set(y for _, y in points)
        y_to_idx = {y:i for i, y in enumerate(sorted(y_set))}
        st1, st2 = SegmentTree(len(y_to_idx)), SegmentTree(len(y_to_idx))
        for i in order:
            j = -st1.query(0, y_to_idx[points[i][1]]-1)[1] 
            if j != INF:
                assert(points[j][1] < points[i][1])
                result = min(result, dist(i, j))
            st1.update(y_to_idx[points[i][1]], [points[i][0]+points[i][1], -i])
            j = -st2.query(y_to_idx[points[i][1]], len(y_to_idx)-1)[1] 
            if j != INF:
                assert(points[j][1] >= points[i][1])
                result = min(result, dist(i, j))
            st2.update(y_to_idx[points[i][1]], [points[i][0]-points[i][1], -i])
        return result[1:]
",nlogn
"
class Solution(object):
    def confusingNumber(self, N):
        lookup = {""0"":""0"", ""1"":""1"", ""6"":""9"", ""8"":""8"", ""9"":""6""}
        
        S = str(N)
        result = []
        for i in range(len(S)):
            if S[i] not in lookup:
                return False
        for i in range((len(S)+1)//2):
            if S[i] != lookup[S[-(i+1)]]:
                return True
        return False
",logn
"
class Solution(object):
    def pathsWithMaxScore(self, board):
        MOD = 10**9+7
        directions = [[1, 0], [0, 1], [1, 1]]
        dp = [[[0, 0] for r in range(len(board[0])+1)]
              for r in range(2)]
        dp[(len(board)-1)%2][len(board[0])-1] = [0, 1]
        for r in reversed(range(len(board))):
            for c in reversed(range(len(board[0]))):
                if board[r][c] in ""XS"":
                    continue
                dp[r%2][c] = [0, 0]
                for dr, dc in directions:
                    if dp[r%2][c][0] < dp[(r+dr)%2][c+dc][0]:
                        dp[r%2][c] = dp[(r+dr)%2][c+dc][:]
                    elif dp[r%2][c][0] == dp[(r+dr)%2][c+dc][0]:
                        dp[r%2][c][1] = (dp[r%2][c][1]+dp[(r+dr)%2][c+dc][1]) % MOD
                if dp[r%2][c][1] and board[r][c] != 'E':
                    dp[r%2][c][0] += int(board[r][c])
        return dp[0][0]
",n^2
"
import collections



class Solution(object):
    def countSubarrays(self, nums, k):
        idx = nums.index(k)
        lookup = collections.Counter()
        curr = 0
        for i in reversed(range(idx+1)):
            curr += 0 if nums[i] == k else -1 if nums[i] < k else +1
            lookup[curr] += 1
        result = curr = 0
        for i in range(idx, len(nums)):
            curr += 0 if nums[i] == k else -1 if nums[i] < k else +1
            result += lookup[-curr]+lookup[-(curr-1)]
        return result
",n
"

class Solution(object):
    def racecar(self, target):
        dp = [0] * (target+1)
        for i in range(1, target+1):
            k = i.bit_length()

            if i == 2**k-1:
                dp[i] = k
                continue

            dp[i] = k+1 + dp[2**k-1 - i]

            for j in range(k-1):
                dp[i] = min(dp[i], k+j+1 + dp[i - 2**(k-1) + 2**j])

        return dp[-1]

",nlogn
"
class Solution(object):
    def strStr(self, haystack, needle):
        if not needle:
            return 0

        return self.KMP(haystack, needle)

    def KMP(self, text, pattern):
        prefix = self.getPrefix(pattern)
        j = -1
        for i in range(len(text)):
            while j > -1 and pattern[j + 1] != text[i]:
                j = prefix[j]
            if pattern[j + 1] == text[i]:
                j += 1
            if j == len(pattern) - 1:
                return i - j
        return -1

    def getPrefix(self, pattern):
        prefix = [-1] * len(pattern)
        j = -1
        for i in range(1, len(pattern)):
            while j > -1 and pattern[j + 1] != pattern[i]:
                j = prefix[j]
            if pattern[j + 1] == pattern[i]:
                j += 1
            prefix[i] = j
        return prefix


",n + k
"class Solution2(object):
    def strStr(self, haystack, needle):
        for i in range(len(haystack) - len(needle) + 1):
            if haystack[i : i + len(needle)] == needle:
                return i
        return -1


",n * k
"
class Solution(object):
    def findPoisonedDuration(self, timeSeries, duration):
        result = duration * len(timeSeries)
        for i in range(1, len(timeSeries)):
            result -= max(0, duration - (timeSeries[i] - timeSeries[i-1]))
        return result

",n
"
class Solution(object):
    def findErrorNums(self, nums):
        x_xor_y = 0
        for i in range(len(nums)):
            x_xor_y ^= nums[i] ^ (i+1)
        bit = x_xor_y & ~(x_xor_y-1)
        result = [0] * 2
        for i, num in enumerate(nums):
            result[bool(num & bit)] ^= num
            result[bool((i+1) & bit)] ^= i+1
        if result[0] not in nums:
            result[0], result[1] = result[1], result[0]
        return result


",n
"class Solution2(object):
    def findErrorNums(self, nums):
        result = [0] * 2
        for i in nums:
            if nums[abs(i)-1] < 0:
                result[0] = abs(i)
            else:
                nums[abs(i)-1] *= -1
        for i in range(len(nums)):
            if nums[i] > 0:
                result[1] = i+1
            else:
                nums[i] *= -1
        return result


",n
"class Solution3(object):
    def findErrorNums(self, nums):
        N = len(nums)
        x_minus_y = sum(nums) - N*(N+1)//2
        x_plus_y = (sum(x*x for x in nums) - N*(N+1)*(2*N+1)/6) // x_minus_y
        return (x_plus_y+x_minus_y) // 2, (x_plus_y-x_minus_y) // 2

",n
"

class Solution(object):
    def maxRectangleArea(self, xCoord, yCoord):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret
    
        points = sorted((xCoord[i], yCoord[i]) for i in range(len(xCoord)))
        y_to_idx = {y:idx for idx, y in enumerate(sorted(set(yCoord)))}
        bit = BIT(len(y_to_idx))
        lookup = {}
        result = -1
        for i, (x, y) in enumerate(points):
            y_idx = y_to_idx[y]
            bit.add(y_idx, +1)
            if not (i-1 >= 0 and points[i-1][0] == x):
                continue
            prev_y_idx = y_to_idx[points[i-1][1]]
            curr = bit.query(y_idx)-bit.query(prev_y_idx-1)
            if (prev_y_idx, y_idx) in lookup and lookup[prev_y_idx, y_idx][0] == curr-2:
                result = max(result, (x-lookup[prev_y_idx, y_idx][1])*(y-points[i-1][1]))
            lookup[prev_y_idx, y_idx] = (curr, x)
        return result
",nlogn
"

class Solution(object):
    def largestCombination(self, candidates):
        cnt = []
        base, mx = 1, max(candidates)
        while base <= mx:
            cnt.append(sum(x&base > 0 for x in candidates))
            base <<= 1
        return max(cnt)
",nlogr
"
class Solution(object):
    def minCost(self, n, cuts):
        sorted_cuts = sorted(cuts + [0, n])
        dp = [[0]*len(sorted_cuts) for _ in range(len(sorted_cuts))]
        for l in range(2, len(sorted_cuts)):
            for i in range(len(sorted_cuts)-l):
                dp[i][i+l] = min(dp[i][j]+dp[j][i+l] for j in range(i+1, i+l)) + \
                             sorted_cuts[i+l]-sorted_cuts[i]
        return dp[0][len(sorted_cuts)-1]
",n^3
"

class ListNode(object):
    def __init__(self, val=0, next=None):
        pass


class Solution(object):
    def swapNodes(self, head, k):
        left, right, curr = None, None, head
        while curr:
            k -= 1
            if right:
                right = right.__next__
            if k == 0:
                left = curr
                right = head
            curr = curr.__next__
        left.val, right.val = right.val, left.val
        return head
",n
"
import collections


class Solution(object):
    def countPairs(self, deliciousness):
        def floor_log2_x(x):
            return x.bit_length()-1

        MOD = 10**9+7
        max_pow = floor_log2_x(max(deliciousness))+1
        cnt = collections.Counter()
        result = 0
        for d in deliciousness:
            p = 1
            for i in range(max_pow+1):
                result = (result+cnt[p-d])%MOD
                p <<= 1
            cnt[d] += 1    
        return result
",n
"

class Solution(object):
    def hasSpecialSubstring(self, s, k):
        l = 0
        for i in range(len(s)):
            l += 1
            if i+1 == len(s) or s[i] != s[i+1]:
                if l == k:
                    return True
                l = 0
        return False
",n
"
import collections


class Solution(object):
    def findClosestLeaf(self, root, k):
        def traverse(node, neighbors, leaves):
            if not node:
                return
            if not node.left and not node.right:
                leaves.add(node.val)
                return
            if node.left:
                neighbors[node.val].append(node.left.val)
                neighbors[node.left.val].append(node.val)
                traverse(node.left, neighbors, leaves)
            if node.right:
                neighbors[node.val].append(node.right.val)
                neighbors[node.right.val].append(node.val)
                traverse(node.right, neighbors, leaves)

        neighbors, leaves = collections.defaultdict(list), set()
        traverse(root, neighbors, leaves)
        q, lookup = [k], set([k])
        while q:
            next_q = []
            for u in q:
                if u in leaves:
                    return u
                for v in neighbors[u]:
                    if v in lookup:
                        continue
                    lookup.add(v)
                    next_q.append(v)
            q = next_q
        return 0

",n
"
class Solution(object):
    def largestDivisibleSubset(self, nums):
        if not nums:
            return []

        nums.sort()
        dp = [1] * len(nums)
        prev = [-1] * len(nums)
        largest_idx = 0
        for i in range(len(nums)):
            for j in range(i):
                if nums[i] % nums[j] == 0:
                    if dp[i] < dp[j] + 1:
                        dp[i] = dp[j] + 1
                        prev[i] = j
            if dp[largest_idx] < dp[i]:
                largest_idx = i

        result = []
        i = largest_idx
        while i != -1:
            result.append(nums[i])
            i = prev[i]
        return result[::-1]

",n^2
"
class Solution(object):
    def findTheLongestSubstring(self, s):
        VOWELS = ""aeiou""
        result, mask, lookup = 0, 0, [-2]*(2**len(VOWELS))
        lookup[0] = -1
        for i, c in enumerate(s):
            index = VOWELS.find(c)
            mask ^= (1 << index) if index >= 0 else 0
            if lookup[mask] == -2:
                lookup[mask] = i
            result = max(result, i-lookup[mask])
        return result
",n
"
class Solution(object):
    def minDifference(self, nums, queries):
        INF = float(""inf"")
        prefix = [[0]*(max(nums)+1)]
        for num in nums:
            prefix.append(prefix[-1][:])
            prefix[-1][num] += 1
        result = []
        for l, r in queries:
            min_diff, prev = INF, -1
            for num in range(len(prefix[0])):
                if not (prefix[l][num] < prefix[r+1][num]):
                    continue
                if prev != -1:
                    min_diff = min(min_diff, num-prev)
                prev = num
            result.append(min_diff if min_diff != INF else -1)
        return result


",r * (n + q)
"import bisect


class Solution2(object):
    def minDifference(self, nums, queries):
        INF = float(""inf"")
        idxs = [[] for _ in range(max(nums)+1)]
        for i, num in enumerate(nums):
            idxs[num].append(i)
        result = []
        for l, r in queries:
            min_diff, prev = INF, -1
            for num in range(len(idxs)):
                i = bisect.bisect_left(idxs[num], l)
                if not (i < len(idxs[num]) and idxs[num][i] <= r):
                    continue
                if prev != -1:
                    min_diff = min(min_diff, num-prev)
                prev = num
            result.append(min_diff if min_diff != INF else -1)
        return result
",r + n + q * r * logn
"
import collections


class Solution(object):
    def wordSubsets(self, A, B):
        count = collections.Counter()
        for b in B:
            for c, n in list(collections.Counter(b).items()):
                count[c] = max(count[c], n)
        result = []
        for a in A:
            count = collections.Counter(a)
            if all(count[c] >= count[c] for c in count):
                result.append(a)
        return result

",m + n
"
class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def equationsPossible(self, equations):
        union_find = UnionFind(26)
        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '=':
                union_find.union_set(x, y)
        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '!':
                if union_find.find_set(x) == union_find.find_set(y):
                    return False
        return True


",n
"class Solution2(object):
    def equationsPossible(self, equations):
        graph = [[] for _ in range(26)]

        for eqn in equations:
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if eqn[1] == '!':
                if x == y:
                    return False
            else:
                graph[x].append(y)
                graph[y].append(x)

        color = [None]*26
        c = 0
        for i in range(26):
            if color[i] is not None:
                continue
            c += 1
            stack = [i]
            while stack:
                node = stack.pop()
                for nei in graph[node]:
                    if color[nei] is not None:
                        continue
                    color[nei] = c
                    stack.append(nei)

        for eqn in equations:
            if eqn[1] != '!':
                continue
            x = ord(eqn[0]) - ord('a')
            y = ord(eqn[3]) - ord('a')
            if color[x] is not None and \
               color[x] == color[y]:
                return False
        return True
",n
"

class Solution(object):
    def divisibilityArray(self, word, m):
        result = []
        curr = 0
        for c in word:
            curr = (curr*10+(ord(c)-ord('0')))%m
            result.append(int(curr == 0))
        return result
",n
"
class Solution(object):
    def getMaximumXor(self, nums, maximumBit):
        result = [0]*len(nums)
        mask = 2**maximumBit-1
        for i in range(len(nums)):
            mask ^= nums[i]
            result[-1-i] = mask
        return result
",n
"
import bisect



class Solution(object):
    def maxPathLength(self, coordinates, k):
        def longest_increasing_subsequence(arr):
            result = []
            for x in arr:
                i = bisect.bisect_left(result, x)
                if i == len(result):
                    result.append(x)
                else:
                    result[i] = x
            return len(result)

        target = coordinates[k]
        coordinates.sort(key=lambda x: (x[0], -x[1]))
        left, right = [], []
        for x, y in coordinates:
            if x < target[0] and y < target[1]:
                left.append(y)
            elif x > target[0] and y > target[1]:
                right.append(y)
        return longest_increasing_subsequence(left)+1+longest_increasing_subsequence(right)
",nlogn
"

class Solution(object):
    def minConnectedGroups(self, intervals, k):
        intervals.sort()
        result = 0
        prefix = [0]*(len(intervals)+1)
        mx = float(""-inf"")
        left = 0
        for right in range(len(intervals)):
            prefix[right+1] = prefix[right]+int(mx < intervals[right][0])
            mx = max(mx, intervals[right][1])
            while intervals[right][0]-intervals[left][1] > k:
                left += 1
            result = max(result, prefix[right+1]-prefix[left+1])
        return prefix[-1]-result
",nlogn
"
class Solution(object):
    def validPalindrome(self, s):
        def validPalindrome(s, left, right):
            while left < right:
                if s[left] != s[right]:
                    return False
                left, right = left+1, right-1
            return True

        left, right = 0, len(s)-1
        while left < right:
            if s[left] != s[right]:
                return validPalindrome(s, left, right-1) or validPalindrome(s, left+1, right)
            left, right = left+1, right-1
        return True

",n
"

class Solution(object):
    def maximumSumSubsequence(self, nums, queries):
        MOD = 10**9+7
        L0R0, L1R0, L0R1, L1R1 = list(range(4))
        class SegmentTree(object):
            def __init__(self, N,
                        build_fn=lambda _: None,
                        query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                        update_fn=lambda x: x):
                self.tree = [None]*(1<<((N-1).bit_length()+1))
                self.base = len(self.tree)>>1
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x >>= 1
                    self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])

            def query(self, L, R):
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L >>= 1
                    R >>= 1
                return self.query_fn(left, right)
        
        def build(i):
            return [max(nums[i], 0), 0, 0, 0]
        
        def query(x, y):
            if x is None:
                return y
            if y is None:
                return x
            return [max(x[L0R1]+y[L1R0], x[L0R0]+y[L1R0], x[L0R1]+y[L0R0]),
                    max(x[L1R1]+y[L1R0], x[L1R0]+y[L1R0], x[L1R1]+y[L0R0]),
                    max(x[L0R1]+y[L1R1], x[L0R0]+y[L1R1], x[L0R1]+y[L0R1]),
                    max(x[L1R1]+y[L1R1], x[L1R0]+y[L1R1], x[L1R1]+y[L0R1])]

        st = SegmentTree(len(nums), build_fn=build, query_fn=query)
        result = 0
        for i, x in queries:
            st.update(i, [max(x, 0), 0, 0, 0])
            result = (result+max(st.tree[1]))%MOD
        return result
",n + qlogn
"

class Solution(object):
    def transpose(self, A):
        result = [[None] * len(A) for _ in range(len(A[0]))]
        for r, row in enumerate(A):
            for c, val in enumerate(row):
                result[c][r] = val
        return result


",r * c
"class Solution2(object):
    def transpose(self, A):
        return list(zip(*A))

",r * c
"
class Solution(object):
    def getStrongest(self, arr, k):
        arr.sort()
        m = arr[(len(arr)-1)//2]
        result = []
        left, right = 0, len(arr)-1
        while len(result) < k:
            if m-arr[left] > arr[right]-m:
                result.append(arr[left])
                left += 1
            else:
                result.append(arr[right])
                right -= 1
        return result


",nlogn
"class Solution2(object):
    def getStrongest(self, arr, k):
        arr.sort()
        m = arr[(len(arr)-1)//2]
        arr.sort(key=lambda x: (-abs(x-m), -x))
        return arr[:k]


",nlogn
"import random


class Solution_TLE(object):
    def getStrongest(self, arr, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def partition_around_pivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == n:
                    return
                elif new_pivot_idx > n:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
        
        nth_element(arr, (len(arr)-1)//2)
        m = arr[(len(arr)-1)//2]
        nth_element(arr, k, lambda a, b: abs(a-m) > abs(b-m) if abs(a-m) != abs(b-m) else a > b)
        return arr[:k]
",n
"
import heapq


class Solution(object):
    def assignBikes(self, workers, bikes):
        def manhattan(p1, p2):
            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
        
        distances = [[] for _ in range(len(workers))]
        for i in range(len(workers)):
            for j in range(len(bikes)):
                distances[i].append((manhattan(workers[i], bikes[j]), i, j))
            distances[i].sort(reverse = True)
        
        result = [None] * len(workers)
        lookup = set()
        min_heap = []
        for i in range(len(workers)):
            heapq.heappush(min_heap, distances[i].pop())
        while len(lookup) < len(workers):
            _, worker, bike = heapq.heappop(min_heap)
            if bike not in lookup:
                result[worker] = bike
                lookup.add(bike)
            else:
                heapq.heappush(min_heap, distances[worker].pop())
        return result
",(w * b) * log(w * b)
"
class Solution(object):
    def nextPalindrome(self, num):
        def next_permutation(nums, begin, end):
            def reverse(nums, begin, end):
                left, right = begin, end-1
                while left < right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 1
                    right -= 1

            k, l = begin-1, begin
            for i in reversed(range(begin, end-1)):
                if nums[i] < nums[i+1]:
                    k = i
                    break
            else:
                reverse(nums, begin, end)
                return False
            for i in reversed(range(k+1, end)):
                if nums[i] > nums[k]:
                    l = i
                    break
            nums[k], nums[l] = nums[l], nums[k]
            reverse(nums, k+1, end)
            return True
        
        nums = list(num)
        if not next_permutation(nums, 0, len(nums)//2):
            return """"
        for i in range(len(nums)//2):
            nums[-1-i] = nums[i]
        return """".join(nums)
",n
"

class Solution(object):
    def minimumObstacles(self, grid):
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        def a_star(grid, b, t):
            f, dh = 0, 1
            closer, detour = [b], []
            lookup = set()
            while closer or detour:
                if not closer:
                    f += dh
                    closer, detour = detour, closer
                b = closer.pop()
                if b in lookup:
                    continue
                lookup.add(b)
                if b == t:
                    return f
                for dr, dc in directions:
                    nb = (b[0]+dr, b[1]+dc)
                    if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and nb not in lookup):
                        continue
                    (closer if not grid[nb[0]][nb[1]] else detour).append(nb)
            return -1

        return a_star(grid, (0, 0), (len(grid)-1, len(grid[0])-1))


",m * n
"import collections



class Solution2(object):
    def minimumObstacles(self, grid):
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        b, t = (0, 0), (len(grid)-1, len(grid[0])-1)
        dq = collections.deque([(b, 0)])
        lookup = set()
        while dq:
            b, d = dq.popleft()
            if b in lookup:
                continue
            lookup.add(b)
            if b == t:
                return d
            for dr, dc in directions:
                nb = (b[0]+dr, b[1]+dc)
                if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and nb not in lookup):
                    continue
                if not grid[nb[0]][nb[1]]:
                    dq.appendleft((nb, d))
                else:
                    dq.append((nb, d+1))
        return -1 
",m * n
"
class Solution(object):
    def maxValue(self, n, index, maxSum):
        def check(n, index, maxSum, x):
            y = max(x-index, 0)
            total = (x+y)*(x-y+1)//2
            y = max(x-((n-1)-index), 0)
            total += (x+y)*(x-y+1)//2
            return total-x <= maxSum

        maxSum -= n
        left, right = 0, maxSum
        while left <= right:
            mid = left + (right-left)//2
            if not check(n, index, maxSum, mid):
                right = mid-1
            else:
                left = mid+1
        return 1+right
",logm
"
class Solution(object):
    def rob(self, nums):
        if len(nums) == 0:
            return 0

        if len(nums) == 1:
            return nums[0]

        return max(self.robRange(nums, 0, len(nums) - 1),\
                   self.robRange(nums, 1, len(nums)))

    def robRange(self, nums, start, end):
        num_i, num_i_1 = nums[start], 0
        for i in range(start + 1, end):
            num_i_1, num_i_2 = num_i, num_i_1
            num_i = max(nums[i] + num_i_2, num_i_1)

        return num_i

",n
"
import bisect



class Solution(object):
    def countRectangles(self, rectangles, points):
        max_y = max(y for _, y in rectangles)
        buckets = [[] for _ in range(max_y+1)]
        for x, y in rectangles:
            buckets[y].append(x)
        for bucket in buckets:
            bucket.sort()
        return [sum(len(buckets[y])-bisect.bisect_left(buckets[y], x) for y in range(y, max_y+1))
                for x, y in points]
",nlogn + m * max_y * logn
"
class Solution(object):
    def reverseWords(self, s):
        def reverse(s, begin, end):
            for i in range((end - begin) / 2):
                s[begin + i], s[end - 1 - i] = s[end - 1 - i], s[begin + i]

        reverse(s, 0, len(s))
        i = 0
        for j in range(len(s) + 1):
            if j == len(s) or s[j] == ' ':
                reverse(s, i, j)
                i = j + 1


",n
"
import collections


class Solution(object):
    def maxScoreWords(self, words, letters, score):
        def backtracking(words, word_scores, word_counts, curr, curr_score, letter_count, result):
            result[0] = max(result[0], curr_score) 
            for i in range(curr, len(words)):
                if any(letter_count[c] < word_counts[i][c] for c in word_counts[i]):
                    continue
                backtracking(words, word_scores, word_counts, i+1,
                             curr_score+word_scores[i], letter_count-word_counts[i],
                             result)

        letter_count = collections.Counter(letters)    
        word_counts = list(map(collections.Counter, words))
        word_scores = [sum(score[ord(c)-ord('a')] for c in words[i])
                       for i in range(len(words))]
        result = [0]
        backtracking(words, word_scores, word_counts, 0, 0, letter_count, result)
        return result[0]
",n * 2^n
"

class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteNodes(self, head, m, n):
        head = dummy = ListNode(next=head)
        while head:
            for _ in range(m):
                if not head.__next__:
                    return dummy.__next__
                head = head.__next__
            prev = head
            for _ in range(n):
                if not head.__next__:
                    prev.next = None
                    return dummy.__next__
                head = head.__next__
            prev.next = head.__next__
        return dummy.__next__
",n
"

class Solution(object):
    def beautifulSplits(self, nums):
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        result = 0
        z0 = z_function(nums)
        for i in range(1, len(nums)-1):
            zi = z_function(nums[i:])
            for j in range(i+1, len(nums)):
                if (z0[i] >= i and j-i >= i) or zi[j-i] >= j-i:
                    result += 1
        return result


",n^2
"
class Solution2(object):
    def beautifulSplits(self, nums):
        dp = [[0]*len(nums) for _ in range(len(nums))]
        for i in reversed(range(len(nums))):
            for j in range(i+1, len(dp)):
                dp[i][j] = 1+(dp[i+1][j+1] if j+1 < len(nums) else 0) if nums[i] == nums[j] else 0
        result = 0
        for i in range(1, len(nums)-1):
            for j in range(i+1, len(nums)):
                if (dp[0][i] >= i and j-i >= i) or dp[i][j] >= j-i:
                    result += 1
        return result


",n^2
"
class Solution_TLE(object):
    def beautifulSplits(self, nums):
        def z_function(s, left, right): 
            z = [0]*(right-left+1)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[left+z[i]] == s[left+i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z
        
        result = 0
        z0 = z_function(nums, 0, len(nums)-1)
        for i in range(1, len(nums)-1):
            zi = z_function(nums, i, len(nums)-1)
            for j in range(i+1, len(nums)):
                if (z0[i] >= i and j-i >= i) or zi[j-i] >= j-i:
                    result += 1
        return result
",n^2
"
import collections


class Solution(object):
    def recoverArray(self, nums):
        def check(k, cnt, result):
            for x in nums:
                if cnt[x] == 0:
                    continue
                if cnt[x+2*k] == 0:
                    return False
                cnt[x] -= 1
                cnt[x+2*k] -= 1
                result.append(x+k)
            return True
            
        nums.sort()
        cnt = collections.Counter(nums)
        for i in range(1, len(nums)//2+1):
            k = nums[i]-nums[0]
            if k == 0 or k%2:
                continue
            k //= 2
            result = []
            if check(k, collections.Counter(cnt), result):
                return result
        return []
",n^2
"

class Solution(object):
    def concatenatedDivisibility(self, nums, k):
        def length(x):
            l = 0
            while x:
                l += 1
                x //= 10
            return max(l, 1)

        lookup = [length(x) for x in nums]
        mx = max(lookup)
        pow10 = [0]*(mx+1)
        pow10[0] = 1%k
        for i in range(len(pow10)-1):
            pow10[i+1] = (pow10[i]*10)%k
        dp = [[False]*k for _ in range(1<<len(nums))]
        dp[-1][0] = True
        for mask in reversed(range(len(dp)-1)):
            for r in range(k):
                for i, l in enumerate(lookup):
                    if mask&(1<<i):
                        continue
                    if dp[mask|(1<<i)][(r*pow10[l]+nums[i])%k]:
                        dp[mask][r] = True
                        break
        result = []
        if not dp[0][0]:
            return result
        order = sorted((x, i) for i, x in enumerate(nums))
        mask = r = 0
        for _ in range(len(nums)):
            for _, i in order:
                if mask&(1<<i):
                    continue
                if dp[mask|(1<<i)][(r*pow10[lookup[i]]+nums[i])%k]:
                    result.append(nums[i])
                    mask |= 1<<i
                    r = (r*pow10[lookup[i]]+nums[i])%k
                    break
        return result
",nlogr + k * n * 2^n
"
class Solution(object):
    def possibleToStamp(self, grid, stampHeight, stampWidth):
        prefix = [[0]*(len(grid[0])+1) for _ in range(len(grid)+1)]
        fit = [[0]*len(grid[0]) for _ in range(len(grid))]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                prefix[i+1][j+1] = prefix[i+1][j]+prefix[i][j+1]-prefix[i][j]+(1^grid[i][j])
                if i+1 >= stampHeight and j+1 >= stampWidth:
                    x, y = i+1-stampHeight, j+1-stampWidth
                    fit[i][j] = int(prefix[i+1][j+1]-prefix[x][j+1]-prefix[i+1][y]+prefix[x][y] == stampWidth*stampHeight)
        prefix2 = [[0]*(len(grid[0])+1) for _ in range(len(grid)+1)]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                prefix2[i+1][j+1] = prefix2[i+1][j]+prefix2[i][j+1]-prefix2[i][j]+fit[i][j]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                x, y = min(i+stampHeight, len(grid)), min(j+stampWidth, len(grid[0]))
                if not grid[i][j] and not prefix2[x][y]-prefix2[i][y]-prefix2[x][j]+prefix2[i][j]:
                    return False
        return True
",m * n
"

class Solution(object):
    def makeArrayPositive(self, nums):
        MAX_VAL = 10**18
        result = 0
        prev1 = nums[0]+nums[1]
        prev2 = nums[0]
        max_prev3 = 0
        for i in range(2, len(nums)):
            prefix = prev1+nums[i]
            if prefix-max_prev3 <= 0:
                prefix = prev1+MAX_VAL
                result += 1
            max_prev3 = max(max_prev3, prev2)
            prev1, prev2 = prefix, prev1
        return result
",n
"
class Solution(object):
    def minimumDistance(self, word):
        def distance(a, b):
            return abs(a//6 - b//6) + abs(a%6 - b%6)

        dp = [0]*26
        for i in range(len(word)-1):
            b, c = ord(word[i])-ord('A'), ord(word[i+1])-ord('A')
            dp[b] = max(dp[a] - distance(a, c) + distance(b, c) for a in range(26))
        return sum(distance(ord(word[i])-ord('A'), ord(word[i+1])-ord('A')) for i in range(len(word)-1)) - max(dp)


",26n
"class Solution2(object):
    def minimumDistance(self, word):
        def distance(a, b):
            if -1 in [a, b]:
                return 0
            return abs(a//6 - b//6) + abs(a%6 - b%6)

        dp = {(-1, -1): 0}
        for c in word:
            c = ord(c)-ord('A')
            new_dp = {}
            for a, b in dp:
                new_dp[c, b] = min(new_dp.get((c, b), float(""inf"")), dp[a, b] + distance(a, c))
                new_dp[a, c] = min(new_dp.get((a, c), float(""inf"")), dp[a, b] + distance(b, c))
            dp = new_dp
        return min(dp.values())
",52n
"
import collections



class Solution(object):
    def subsequencesWithMiddleMode(self, nums):
        def nC2(x):
            return x*(x-1)//2

        MOD = 10**9+7
        result = 0
        left = collections.defaultdict(int)
        right = collections.defaultdict(int)
        for x in nums:
            right[x] += 1
        left_x_sq = 0 
        right_x_sq = sum(v**2 for v in right.values()) 
        left_x_right_x = 0 
        left_x_sq_right_x = 0 
        left_x_right_x_sq = 0 
        for i, v in enumerate(nums):
            left_x_sq -= left[v]**2
            right_x_sq -= right[v]**2
            left_x_right_x -= left[v]*right[v]
            left_x_sq_right_x -= left[v]**2*right[v]
            left_x_right_x_sq -= left[v]*right[v]**2
            right[v] -= 1

            l, r = i, len(nums)-(i+1)
            result += nC2(l)*nC2(r)
            result -= nC2(l-left[v])*nC2(r-right[v])
            result -= ((left_x_sq-(l-left[v]))*(r-right[v])-(left_x_sq_right_x-left_x_right_x))*right[v]//2
            result -= ((right_x_sq-(r-right[v]))*(l-left[v])-(left_x_right_x_sq-left_x_right_x))*left[v]//2
            result -= left[v]*left_x_right_x*(r-right[v])-left[v]*left_x_right_x_sq
            result -= right[v]*left_x_right_x*(l-left[v])-right[v]*left_x_sq_right_x
            result -= right[v]*(left_x_sq_right_x-left_x_right_x)//2
            result -= left[v]*(left_x_right_x_sq-left_x_right_x)//2

            left[v] += 1
            left_x_sq += left[v]**2
            right_x_sq += right[v]**2
            left_x_right_x += left[v]*right[v]
            left_x_sq_right_x += left[v]**2*right[v]
            left_x_right_x_sq += left[v]*right[v]**2
        return result % MOD
",n
"
import heapq



class Solution(object):
    def totalCost(self, costs, k, candidates):
        left, right = candidates, max(len(costs)-candidates, candidates)-1
        min_heap1, min_heap2 = costs[:left], costs[right+1:]
        heapq.heapify(min_heap1), heapq.heapify(min_heap2)
        result = 0
        for _ in range(k):
            if not min_heap2 or (min_heap1 and min_heap1[0] <= min_heap2[0]):
                result += heapq.heappop(min_heap1)
                if left <= right:
                    heapq.heappush(min_heap1, costs[left])
                    left += 1
            else:
                result += heapq.heappop(min_heap2)
                if left <= right:
                    heapq.heappush(min_heap2, costs[right])
                    right -= 1
        return result
",c + klogc
"
class Solution(object):
    def isSameAfterReversals(self, num):
        return num == 0 or num%10
",1
"
class Solution(object):
    def minSwaps(self, nums):
        result = cnt = w = nums.count(1)
        for i in range(len(nums)+(w-1)):
            if i >= w:
                cnt += nums[(i-w)%len(nums)]
            cnt -= nums[i%len(nums)]
            result = min(result, cnt)
        return result
",n
"
nums = [0, 1]
dp = [0, 1]
class Solution(object):
    def getMaximumGenerated(self, n):
        if n+1 > len(dp):
            for i in range(len(nums), n+1):
                if i%2 == 0:
                    nums.append(nums[i//2])
                else:
                    nums.append(nums[i//2] + nums[i//2+1])
                dp.append(max(dp[-1], nums[-1]))
        return dp[n]


",n
"class Solution2(object):
    def getMaximumGenerated(self, n):
        if n == 0:
            return 0
        nums = [0]*(n+1)
        nums[1] = 1
        result = 1
        for i in range(2, n+1):
            if i%2 == 0:
                nums[i] = nums[i//2]
            else:
                nums[i] = nums[i//2] + nums[i//2+1]
            result = max(result, nums[i])
        return result
",n
"

class Solution(object):
    def maxKDivisibleComponents(self, n, edges, values, k):
        def bfs():
            result = 0
            dp = [x%k for x in values]
            cnt = [len(adj[u]) for u in range(len(adj))]
            q = [u for u in range(n) if cnt[u] == 1]
            while q:
                new_q = []
                for u in q:
                    if not dp[u]:
                        result += 1
                    for v in adj[u]:
                        dp[v] = (dp[v]+dp[u])%k
                        cnt[v] -= 1
                        if cnt[v] == 1:
                            new_q.append(v)
                q = new_q
            return max(result, 1)

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return bfs()
",n
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def deleteDuplicates(self, head):
        cur = head
        while cur:
            runner = cur.__next__
            while runner and runner.val == cur.val:
                runner = runner.__next__
            cur.next = runner
            cur = runner
        return head

    def deleteDuplicates2(self, head):
        if not head: return head
        if head.__next__:
            if head.val == head.next.val:
                head = self.deleteDuplicates2(head.__next__)
            else:
                head.next = self.deleteDuplicates2(head.next)
        return head


",n
"
class Solution(object):
    def countGoodRectangles(self, rectangles):
        result = mx = 0
        for l, w in rectangles:
            side = min(l, w)
            if side > mx:
                result, mx = 1, side
            elif side == mx:
                result += 1
        return result
",n
"
class Solution(object):
    def findSubstringInWraproundString(self, p):
        letters = [0] * 26
        result, length = 0, 0
        for i in range(len(p)):
            curr = ord(p[i]) - ord('a')
            if i > 0 and ord(p[i-1]) != (curr-1)%26 + ord('a'):
                length = 0
            length += 1
            if length > letters[curr]:
                result += length - letters[curr]
                letters[curr] = length
        return result

",n
"

class Solution(object):
    def restoreString(self, s, indices):
        result = list(s)
        for i, c in enumerate(result):
            if indices[i] == i:
                continue
            move, j = c, indices[i]
            while j != i:
                result[j], move = move, result[j]
                indices[j], j = j, indices[j]
            result[i] = move
        return """".join(result)


",n
"import itertools


class Solution2(object):
    def restoreString(self, s, indices):
        result = ['']*len(s)
        for i, c in zip(indices, s):
            result[i] = c
        return """".join(result)
",n
"
class Solution(object):
    def isScramble(self, s1, s2):
        if not s1 or not s2 or len(s1) != len(s2):
            return False
        if s1 == s2:
            return True
        result = [[[False for j in range(len(s2))] for i in range(len(s1))] for n in range(len(s1) + 1)]
        for i in range(len(s1)):
            for j in range(len(s2)):
                if s1[i] == s2[j]:
                    result[1][i][j] = True

        for n in range(2, len(s1) + 1):
            for i in range(len(s1) - n + 1):
                for j in range(len(s2) - n + 1):
                    for k in range(1, n):
                        if result[k][i][j] and result[n - k][i + k][j + k] or\
                           result[k][i][j + n - k] and result[n - k][i + k][j]:
                            result[n][i][j] = True
                            break

        return result[n][0][0]

",n^4
"
class Solution(object):
    def palindromePartition(self, s, k):
        dp1 = [[0]*len(s) for _ in range(len(s))]
        for l in range(1, len(s)+1):
            for i in range(len(s)-l+1):
                j = i+l-1
                if i == j-1:
                    dp1[i][j] = 0 if s[i] == s[j] else 1
                elif i != j:
                    dp1[i][j] = dp1[i+1][j-1] if s[i] == s[j] else dp1[i+1][j-1]+1

        dp2 = [[float(""inf"")]*len(s) for _ in range(2)]
        dp2[1] = dp1[0][:]
        for d in range(2, k+1):
            dp2[d%2] = [float(""inf"")]*len(s)
            for i in range(d-1, len(s)):  
                for j in range(d-2, i):
                    dp2[d%2][i] = min(dp2[d%2][i], dp2[(d-1)%2][j]+dp1[j+1][i])
        return dp2[k%2][len(s)-1]
",k * n^2
"
class Solution(object):
    def maxLength(self, ribbons, k):
        def check(ribbons, k, s):
            return reduce(lambda total,x: total+x//s, ribbons, 0) >= k

        left, right = 1, sum(ribbons)//k
        while left <= right:
            mid = left + (right-left)//2
            if not check(ribbons, k, mid):
                right = mid-1
            else:
                left = mid+1
        return right
",nlogr
"
class Solution(object):
    def nextGreaterElement(self, findNums, nums):
        stk, lookup = [], {}
        for num in nums:
            while stk and num > stk[-1]:
                lookup[stk.pop()] = num
            stk.append(num)
        while stk:
            lookup[stk.pop()] = -1
        return [lookup[x] for x in findNums]

",m + n
"
class Solution(object):
    def findKthNumber(self, m, n, k):
        def count(target, m, n):
            return sum(min(target//i, n) for i in range(1, m+1))

        left, right = 1, m*n
        while left <= right:
            mid = left + (right-left)/2
            if count(mid, m, n) >= k:
                right = mid-1
            else:
                left = mid+1
        return left

",m * log(m * n)
"

class TreeNode(object):
    def __init__(self, x):
        pass


class Solution(object):
    def lowestCommonAncestor(self, root, nodes):
        def iter_dfs(root, lookup):
            result = [0]
            stk = [(1, (root, result))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node or node in lookup:
                        ret[0] = node
                        continue
                    ret1, ret2 = [None], [None]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    if ret1[0] and ret2[0]:
                        ret[0] = node
                    else:
                        ret[0] = ret1[0] or ret2[0]
            return result[0]
        
        return iter_dfs(root, set(nodes))


",n
"class Solution2(object):
    def lowestCommonAncestor(self, root, nodes):
        def dfs(node, lookup):
            if not node or node in lookup:
                return node
            left, right = dfs(node.left, lookup), dfs(node.right, lookup)
            if left and right:
                return node
            return left or right
        
        return dfs(root, set(nodes))
",n
"
import string
from functools import reduce



class Solution(object):
    def twoEditWords(self, queries, dictionary):
        MOD = (1<<64)-59 
        BASE = 113
        POW = [1]
        def add(a, b):
            return (a+b)%MOD

        def mult(a, b):
            return (a*b)%MOD

        def pow(i):
            while not (i < len(POW)):
                POW.append(mult(POW[-1], BASE))
            return POW[i]
    
        lookup = set()
        for w in dictionary:
            h = reduce(lambda h, i: add(h, mult(ord(w[i])-ord('a'), pow(i))), range(len(w)), 0)
            for i, c in enumerate(w):
                for x in string.ascii_lowercase:
                    if x == c:
                        continue
                    lookup.add(add(h, mult(ord(x)-ord(c), pow(i))))
        result = []
        for w in queries:
            h = reduce(lambda h, i: add(h, mult(ord(w[i])-ord('a'), pow(i))), range(len(w)), 0)
            for i, c in enumerate(w):
                for x in string.ascii_lowercase:
                    if x == c:
                        continue
                    if add(h, mult(ord(x)-ord(c), pow(i))) in lookup:
                        break
                else:
                    continue
                result.append(w)
                break
        return result


",25 * l * (n + q)
"import itertools



class Solution2(object):
    def twoEditWords(self, queries, dictionary):
        return [q for q in queries if any(sum(c1 != c2 for c1, c2 in zip(q, d)) <= 2 for d in dictionary)]
",q * n * l
"
class Solution(object):
    def getSmallestString(self, n, k):
        MAX_DIFF = ord('z')-ord('a')

        k -= n
        result = ['a']*n
        for i in reversed(range(n)):
            tmp = min(k, MAX_DIFF)
            result[i] = chr(ord('a')+tmp)
            k -= tmp
            if k == 0:
                break
        return """".join(result)
",n
"
import collections



class Solution(object):
    def countNonDecreasingSubarrays(self, nums, k):
        result = cnt = 0
        dq = collections.deque()
        right = len(nums)-1
        for left in reversed(range(len(nums))):
            while dq and nums[dq[-1]] < nums[left]:
                l = dq.pop()
                r = dq[-1]-1 if dq else right
                cnt += (r-l+1)*(nums[left]-nums[l])
            dq.append(left)
            while cnt > k:
                cnt -= nums[dq[0]]-nums[right]
                if dq[0] == right:
                    dq.popleft()
                right -= 1
            result += right-left+1
        return result
",n
"

class Solution(object):
    def isArraySpecial(self, nums, queries):
        prefix = [0]*len(nums)
        for i in range(len(nums)-1):
            prefix[i+1] = prefix[i]+int(nums[i+1]&1 != nums[i]&1)
        result = [False]*len(queries)
        for i, (l, r) in enumerate(queries):
            result[i] = prefix[r]-prefix[l] == r-l
        return result
",n + q
"

class Solution(object):
    def countWays(self, ranges):
        MOD = 10**9+7

        ranges.sort()
        cnt = 0
        curr = float(""-inf"")
        for l, r in ranges:
            if l > curr:
                cnt += 1
            curr = max(curr, r)
        return pow(2, cnt, MOD)
",nlogn
"

class Solution(object):
    def minMaxGame(self, nums):
        n = len(nums)
        while n != 1:
            new_q = []
            for i in range(n//2):
                nums[i] = min(nums[2*i], nums[2*i+1]) if i%2 == 0 else max(nums[2*i], nums[2*i+1])
            n //= 2
        return nums[0]


",n
"
class Solution2(object):
    def minMaxGame(self, nums):
        q = nums[:]
        while len(q) != 1:
            new_q = []
            for i in range(len(q)//2):
                new_q.append(min(q[2*i], q[2*i+1]) if i%2 == 0 else max(q[2*i], q[2*i+1]))
            q = new_q
        return q[0]
",n
"

class Solution(object):
    def minCost(self, nums, x):
        def accumulate(a):
            for i in range(len(a)-1):
                a[i+1] += a[i]
            return a

        i = min(range(len(nums)), key=lambda x: nums[x])
        nums = nums[i:]+nums[:i]
        left, right = [-1]*len(nums), [len(nums)]*len(nums)
        stk = []
        for i in range(len(nums)):
            while stk and nums[stk[-1]] > nums[i]:
                right[stk.pop()] = i
            if stk:
                left[i] = stk[-1]
            stk.append(i)
        diff2 = [0]*(len(nums)+1)
        diff2[0] = (+1)*sum(nums)            
        diff2[1] = x                         
        diff2[-1] += (-1)*nums[0]            
        for i in range(1, len(nums)):
            l, r = i-left[i], right[i]-i
            diff2[min(l, r)] += (-1)*nums[i] 
            diff2[max(l, r)] += (-1)*nums[i] 
            diff2[l+r] += (+1)*nums[i]       
        return min(accumulate(accumulate(diff2)))


",n
"import collections



class Solution2(object):
    def minCost(self, nums, x):
        def cost(k):
            w = k+1
            result = x*k
            dq = collections.deque()
            for i in range(len(nums)+w-1):
                if dq and i-dq[0] == w:
                    dq.popleft()
                while dq and nums[dq[-1]%len(nums)] >= nums[i%len(nums)]:
                    dq.pop()
                dq.append(i)
                if i >= w-1:
                    result += nums[dq[0]%len(nums)]
            return result

        def check(x):
            return cost(x) <= cost(x+1)

        left, right = 0, len(nums)
        while left <= right:
            mid = left + (right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return cost(left)


",nlogn
"
class Solution3(object):
    def minCost(self, nums, x):
        result = [x*k for k in range(len(nums)+1)]
        for i in range(len(nums)):
            curr = nums[i]
            for k in range(len(result)):
                curr = min(curr, nums[(i+k)%len(nums)])
                result[k] += curr
        return min(result)
",n^2
"
class Solution(object):
    def maxDistance(self, position, m):
        def check(position, m, x):
            count, prev = 1, position[0]
            for i in range(1, len(position)):
                if position[i]-prev >= x:
                    count += 1
                    prev = position[i]
            return count >= m
        
        position.sort()
        left, right = 1, position[-1]-position[0]
        while left <= right:
            mid = left + (right-left)//2
            if not check(position, m, mid):
                right = mid-1
            else:
                left = mid+1
        return right
",nlogn + nlogr
"

class Solution(object):
    def maximumProduct(self, nums, k):
        MOD = 10**9+7
        nums.sort()
        total = sum(nums)
        for i in reversed(range(len(nums))):
            if nums[i]*(i+1)-total <= k:
                break
            total -= nums[i]
        q, r = divmod(k+total, i+1)
        return (pow(q, (i+1)-r, MOD)*pow(q+1, r, MOD)*
                reduce(lambda x, y: x*y%MOD, (nums[j] for j in range(i+1, len(nums))), 1)) % MOD


",nlogn
"import collections
from functools import reduce



class Solution2(object):
    def maximumProduct(self, nums, k):
        MOD = 10**9+7
        cnt = collections.Counter(nums)
        min_num = min(cnt.keys())
        while k:
            c = min(cnt[min_num], k)
            cnt[min_num] -= c
            cnt[min_num+1] += c 
            if not cnt[min_num]:
                del cnt[min_num]
                min_num += 1
            k -= c
        return reduce(lambda total, x: total*pow(x[0], x[1], MOD)%MOD, iter(cnt.items()), 1)


",n + k
"import heapq



class Solution3(object):
    def maximumProduct(self, nums, k):
        MOD = 10**9+7
        min_heap = nums
        heapq.heapify(min_heap)
        while k:
            heapq.heappush(min_heap, heapq.heappop(min_heap)+1)
            k -= 1
        return reduce(lambda x, y: x*y%MOD, min_heap)
",n + klogn
"
import collections
import random
from functools import reduce



class Solution(object):
    def countKSubsequencesWithMaxBeauty(self, s, k):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            if not (0 <= k <= n):
                return 0
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        cnt = collections.Counter(s)
        if len(cnt) < k:
            return 0
        freqs = list(cnt.values())
        nth_element(freqs, k-1, lambda a, b: a > b)
        n = freqs.count(freqs[k-1])
        r = sum(freqs[i] == freqs[k-1] for i in range(k))
        return reduce(lambda a, b: a*b%MOD, (freqs[i] for i in range(k)), 1)*nCr(n, r)%MOD
",n
"
class Solution(object):
    def exclusiveTime(self, n, logs):
        result = [0] * n
        stk, prev = [], 0
        for log in logs:
            tokens = log.split("":"")
            if tokens[1] == ""start"":
                if stk:
                    result[stk[-1]] += int(tokens[2]) - prev
                stk.append(int(tokens[0]))
                prev = int(tokens[2])
            else:
                result[stk.pop()] += int(tokens[2]) - prev + 1
                prev = int(tokens[2]) + 1
        return result

",n
"

class Solution(object):
    def sumScores(self, s):
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        z = z_function(s)
        z[0] = len(s)
        return sum(z)
",n
"
import math
import random


class Solution(object):
    def minimizeError(self, prices, target):
        def kthElement(nums, k, compare=lambda a, b: a < b):
            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == k:
                    return
                elif new_pivot_idx > k:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
        
        errors = []
        lower, upper = 0, 0
        for i, p in enumerate(map(float, prices)):
            lower += int(math.floor(p))
            upper += int(math.ceil(p))
            if p != math.floor(p):
                errors.append(p-math.floor(p))
        if not lower <= target <= upper:
            return ""-1""

        lower_round_count = upper-target
        kthElement(errors, lower_round_count)
        result = 0.0
        for i in range(len(errors)):
            if i < lower_round_count:
                result += errors[i]
            else:
                result += 1.0-errors[i]
        return ""{:.3f}"".format(result)
",n
"
import collections

class Solution(object):
    def findRepeatedDnaSequences(self, s):
        dict, rolling_hash, res = {}, 0, []

        for i in range(len(s)):
            rolling_hash = ((rolling_hash << 3) & 0x3fffffff) | (ord(s[i]) & 7)
            if rolling_hash not in dict:
                dict[rolling_hash] = True
            elif dict[rolling_hash]:
                res.append(s[i - 9: i + 1])
                dict[rolling_hash] = False
        return res

    def findRepeatedDnaSequences2(self, s):
        l, r = [], []
        if len(s) < 10: return []
        for i in range(len(s) - 9):
            l.extend([s[i:i + 10]])
        return [k for k, v in list(collections.Counter(l).items()) if v > 1]


",n
"
import pandas as pd



def Solution(employees: pd.DataFrame) -> pd.DataFrame:
    return employees.assign(salary=2*employees[""salary""])
",n
"

class InfiniteStream:
    def __next__(self):
        pass



class Solution(object):
    def findPattern(self, stream, pattern):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        prefix = getPrefix(pattern)
        i = j = -1
        while True:
            d = next(stream)
            i += 1
            while j+1 > 0 and pattern[j+1] != d:
                j = prefix[j]
            if pattern[j+1] == d:
                j += 1
            if j+1 == len(pattern):
                return i-j
        return -1
",p + n
"
class Solution(object):
    def preimageSizeFZF(self, K):
        def count_of_factorial_primes(n, p):
            cnt = 0
            while n > 0:
                cnt += n//p
                n //= p
            return cnt

        p = 5
        left, right = 0, p*K
        while left <= right:
            mid = left + (right-left)//2
            if count_of_factorial_primes(mid, p) >= K:
                right = mid-1
            else:
                left = mid+1
        return p if count_of_factorial_primes(left, p) == K else 0

",(logn)^2
"

class Solution(object):
    def minBitwiseArray(self, nums):
        return [x-(((x+1)&~x)>>1) if x&1 else -1 for x in nums]


",n
"
class Solution2(object):
    def minBitwiseArray(self, nums):
        return [next((i for i in range(x) if i|(i+1) == x), -1) for x in nums]
",n * r
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


import collections



class Solution(object):
    def flipEquiv(self, root1, root2):
        dq1, dq2 = collections.deque([root1]), collections.deque([root2])
        while dq1 and dq2:
            node1, node2 = dq1.pop(), dq2.pop()
            if not node1 and not node2:
                continue 
            if not node1 or not node2 or node1.val != node2.val:
                return False
            if (not node1.left and not node2.right) or \
               (node1.left and node2.right and node1.left.val == node2.right.val):
                dq1.extend([node1.right, node1.left])
            else:
                dq1.extend([node1.left, node1.right])
            dq2.extend([node2.left, node2.right])
        return not dq1 and not dq2


",n
"
class Solution2(object):
    def flipEquiv(self, root1, root2):
        stk1, stk2 = [root1], [root2]
        while stk1 and stk2:
            node1, node2 = stk1.pop(), stk2.pop()
            if not node1 and not node2:
                continue 
            if not node1 or not node2 or node1.val != node2.val:
                return False
            if (not node1.left and not node2.right) or \
               (node1.left and node2.right and node1.left.val == node2.right.val):
                stk1.extend([node1.right, node1.left])
            else:
                stk1.extend([node1.left, node1.right])
            stk2.extend([node2.left, node2.right])
        return not stk1 and not stk2


",n
"
class Solution3(object):
    def flipEquiv(self, root1, root2):
        if not root1 and not root2:
            return True
        if not root1 or not root2 or root1.val != root2.val:
            return False

        return (self.flipEquiv(root1.left, root2.left) and
                self.flipEquiv(root1.right, root2.right) or
                self.flipEquiv(root1.left, root2.right) and
                self.flipEquiv(root1.right, root2.left))
",n
"

class Solution(object):
    def minDeletion(self, nums):
        result = 0
        for i in range(len(nums)-1):
            result += int(i%2 == result%2 and nums[i] == nums[i+1])
        return result+(len(nums)-result)%2
",n
"
class Solution(object):
    def firstBadVersion(self, n):
        left, right = 1, n
        while left <= right:
            mid = left + (right - left) / 2
            if isBadVersion(mid):
                right = mid - 1
            else:
                left = mid + 1
        return left

",logn
"

class Solution(object):
    def makeTheIntegerZero(self, num1, num2):
        def popcount(x):
            result = 0
            while x:
                x &= (x-1)
                result += 1
            return result

        for i in range(1, 60+1):
            if num1-i*num2 < 0:
                break
            if popcount(num1-i*num2) <= i <= num1-i*num2:
                return i
        return -1
",1
"
import collections



class Solution(object):
    def divisibleTripletCount(self, nums, d):
        result = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                if (nums[i]+nums[j])%d in cnt:
                    result += cnt[(nums[i]+nums[j])%d]
            cnt[-nums[i]%d] += 1
        return result


",n^2
"import collections



class Solution2(object):
    def divisibleTripletCount(self, nums, d):
        result = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            if nums[i]%d in cnt:
                result += cnt[nums[i]%d]
            for j in range(i):
                cnt[-(nums[i]+nums[j])%d] += 1
        return result


",n^2
"import collections



class Solution3(object):
    def divisibleTripletCount(self, nums, d):
        result = 0
        for i in range(len(nums)):
            cnt = collections.Counter()
            for j in range(i+1, len(nums)):
                result += cnt[nums[j]%d]
                cnt[-(nums[i]+nums[j])%d] += 1
        return result
",n^2
"
import collections


class Solution(object):

    def __init__(self):
        self.__freq = collections.Counter()
        self.__group = collections.defaultdict(list)
        self.__maxfreq = 0

    def push(self, x):
        self.__freq[x] += 1
        if self.__freq[x] > self.__maxfreq:
            self.__maxfreq = self.__freq[x]
        self.__group[self.__freq[x]].append(x)   

    def pop(self):
        x = self.__group[self.__maxfreq].pop()
        if not self.__group[self.__maxfreq]:
            self.__group.pop(self.__maxfreq)
            self.__maxfreq -= 1
        self.__freq[x] -= 1
        if not self.__freq[x]:
            self.__freq.pop(x)
        return x



",1
"

class Solution(object):
    def getPermutationIndex(self, perm):
        MOD = 10**9+7
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = (self.__bit[i]+val) % MOD
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret = (ret+self.__bit[i]) % MOD
                    i -= (i & -i)
                return ret

        fact = [0]*len(perm)
        fact[0] = 1
        for i in range(len(fact)-1):
            fact[i+1] = ((i+1)*fact[i])%MOD
        result = 0
        bit = BIT(len(perm))
        for i, x in enumerate(perm):
            result = (result+(((((x-1)-bit.query((x-1)-1))%MOD)*fact[(len(perm)-1)-i])%MOD))%MOD
            bit.add(x-1, +1)
        return result


",nlogn
"
class Solution2(object):
    def getPermutationIndex(self, perm):
        MOD = 10**9+7
        fact = [1]*2            
        def factorial(n):
            while len(fact) <= n: 
                fact.append(fact[-1]*len(fact) % MOD)
            return fact[n]

        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = (self.__bit[i]+val) % MOD
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret = (ret+self.__bit[i]) % MOD
                    i -= (i & -i)
                return ret

        result = 0
        bit = BIT(len(perm))
        for i, x in enumerate(perm):
            result = (result+(((((x-1)-bit.query((x-1)-1))%MOD)*factorial((len(perm)-1)-i))%MOD))%MOD
            bit.add(x-1, +1)
        return result
",nlogn
"
from collections import deque

class Solution(object):

    def __init__(self, size):
        self.__size = size
        self.__sum = 0
        self.__q = deque()

    def next(self, val):
        if len(self.__q) == self.__size:
            self.__sum -= self.__q.popleft()
        self.__sum += val
        self.__q.append(val)
        return 1.0 * self.__sum / len(self.__q)



",1
"
class Solution(object):
    def threeSumSmaller(self, nums, target):
        nums.sort()
        n = len(nums)

        count, k = 0, 2
        while k < n:
            i, j = 0, k - 1
            while i < j: 
                if nums[i] + nums[j] + nums[k] >= target:
                    j -= 1
                else:
                    count += j - i
                    i += 1
            k += 1

        return count

",n^2
"
import collections



class Solution(object):
    def taskSchedulerII(self, tasks, space):
        lookup = collections.defaultdict(int)
        result = 0
        for t in tasks:
            result = max(lookup[t], result+1)
            lookup[t] = result+space+1
        return result
",n
"
class Solution(object):
    def plusOne(self, digits):
        for i in reversed(range(len(digits))):
            if digits[i] == 9:
                digits[i] = 0
            else:
                digits[i] += 1
                return digits
        digits[0] = 1
        digits.append(0)
        return digits


",n
"class Solution2(object):
    def plusOne(self, digits):
        result = digits[::-1]
        carry = 1
        for i in range(len(result)):
            result[i] += carry
            carry, result[i] = divmod(result[i], 10)
        if carry:
            result.append(carry)
        return result[::-1]


",n
"
import collections


class Solution(object):
    def numBusesToDestination(self, routes, S, T):
        if S == T:
            return 0

        to_route = collections.defaultdict(set)
        for i, route in enumerate(routes):
            for stop in route:
                to_route[stop].add(i)

        result = 1
        q = [S]
        lookup = set([S])
        while q:
            next_q = []
            for stop in q:
                for i in to_route[stop]:
                    for next_stop in routes[i]:
                        if next_stop in lookup:
                            continue
                        if next_stop == T:
                            return result
                        next_q.append(next_stop)
                        to_route[next_stop].remove(i)
                        lookup.add(next_stop)
            q = next_q
            result += 1

        return -1

",|V| + |E|
"
class Solution(object):
    def numOfBurgers(self, tomatoSlices, cheeseSlices):
        return [tomatoSlices//2-cheeseSlices, 2*cheeseSlices - tomatoSlices//2] \
               if tomatoSlices%2 == 0 and 2*cheeseSlices <= tomatoSlices <= 4*cheeseSlices \
               else []
",1
"
class Solution(object):
    def countValidWords(self, sentence):
        result = token = hyphen = 0
        for i in range(len(sentence)+1):
            if i == len(sentence) or sentence[i] == ' ':
                if token == 1:
                    result += 1
                token = hyphen = 0
                continue
            if sentence[i].isdigit() or \
               (sentence[i] in ""!.,"" and not (i == len(sentence)-1 or sentence[i+1] == ' ')) or \
               (sentence[i] == '-' and not (hyphen == 0 and 0 < i < len(sentence)-1 and sentence[i-1].isalpha() and sentence[i+1].isalpha())):
                token = -1
                continue
            if token == 0:
                token = 1
            if sentence[i] == '-':
                hyphen = 1
        return result
",n
"
class Solution(object):
    def isValid(self, code):
        def validText(s, i):
            j = i
            i = s.find(""<"", i)
            return i != j, i

        def validCData(s, i):
            if s.find(""<![CDATA["", i) != i:
                return False, i
            j = s.find(""]]>"", i)
            if j == -1:
                return False, i
            return True, j+3

        def parseTagName(s, i):
            if s[i] != '<':
                return """", i
            j = s.find('>', i)
            if j == -1 or not (1 <= (j-1-i) <= 9):
                return """", i
            tag = s[i+1:j]
            for c in tag:
                if not (ord('A') <= ord(c) <= ord('Z')):
                    return """", i
            return tag, j+1

        def parseContent(s, i):
            while i < len(s):
                result, i = validText(s, i)
                if result:
                    continue
                result, i = validCData(s, i)
                if result:
                    continue
                result, i = validTag(s, i)
                if result:
                    continue
                break
            return i

        def validTag(s, i):
            tag, j = parseTagName(s, i)
            if not tag:
                return False, i
            j = parseContent(s, j)
            k = j + len(tag) + 2
            if k >= len(s) or s[j:k+1] != ""</"" + tag + "">"":
                return False, i
            return True, k+1

        result, i = validTag(code, 0)
        return result and i == len(code)

",n
"
class Solution(object):
    def matrixReshape(self, nums, r, c):
        if not nums or \
           r*c != len(nums) * len(nums[0]):
            return nums

        result = [[0 for _ in range(c)] for _ in range(r)]
        count = 0
        for i in range(len(nums)):
            for j in range(len(nums[0])):
                result[count/c][count%c] = nums[i][j]
                count += 1
        return result

",m * n
"
class UnionFind(object): 
    def __init__(self, nums):
        self.set = list(range(len(nums)))
        self.rank = [0]*len(nums)
        self.size = nums[:]

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        self.size[y] += self.size[x]
        return True

    def total(self, x):
        return self.size[self.find_set(x)]



class Solution(object):
    def maximumSegmentSum(self, nums, removeQueries):
        result = [0]*len(removeQueries)
        lookup = [0]*len(nums)
        uf = UnionFind(nums)
        for i in reversed(range(1, len(removeQueries))): 
            q = removeQueries[i]
            lookup[q] = 1
            if q-1 >= 0 and lookup[q-1]:
                uf.union_set(q-1, q)
            if q+1 < len(nums) and lookup[q+1]:
                uf.union_set(q, q+1)
            result[i-1] = max(result[i], uf.total(q))   
        return result


",n
"from sortedcontainers import SortedList



class Solution2(object):
    def maximumSegmentSum(self, nums, removeQueries):
        removed_idxs = SortedList([-1, len(nums)])
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        segments = SortedList([prefix[-1]])
        result = []
        for q in removeQueries: 
            removed_idxs.add(q)
            i = removed_idxs.bisect_left(q)
            left, right = removed_idxs[i-1], removed_idxs[i+1]
            segments.remove(prefix[right]-prefix[left+1])
            segments.add(prefix[q]-prefix[left+1])
            segments.add(prefix[right]-prefix[q+1])
            result.append(segments[-1])
        return result
",nlogn
"

class Solution(object):
    def minimumPushes(self, word):
        def ceil_divide(a, b):
            return (a+b-1)//b

        return sum((i+1)*min(len(word)-i*(9-2+1), (9-2+1)) for i in range(ceil_divide(len(word), (9-2+1))))


",4
"import collections



class Solution2(object):
    def minimumPushes(self, word):
        return sum(x*(i//(9-2+1)+1) for i, x in enumerate(sorted(iter(collections.Counter(word).values()), reverse=True)))
",26
"

class Solution(object):
    def countSubstrings(self, s):
        result = 0
        for i in range(len(s)):
            if s[i] in ('1', '2', '5'):
                result += i+1
        remain = 0
        cnt = [0]*3
        cnt[0] = 1
        for i in range(len(s)):
            remain = (remain+(ord(s[i])-ord('0')))%3
            if s[i] in ('3', '6'):
                result += cnt[remain]
            cnt[remain] += 1
        remain = 0
        cnt = [0]*9
        cnt[0] = 1
        for i in range(len(s)):
            remain = (remain+(ord(s[i])-ord('0')))%9
            if s[i] == '9':
                result += cnt[remain]
            cnt[remain] += 1
        for i in range(len(s)):
            if s[i] == '4':
                result += 1
                if i-1 >= 0 and int(s[i-1:i+1])%4 == 0:
                    result += i
        for i in range(len(s)):
            if s[i] == '8':
                result += 1
                if i-1 >= 0 and int(s[i-1:i+1])%8 == 0:
                    result += 1
                if i-2 >= 0 and int(s[i-2:i+1])%8 == 0:
                    result += i-1
        base = 1
        remain = 0
        cnt = [0]*7
        for i in range(len(s)):
            remain = (remain+base*(ord(s[~i])-ord('0')))%7
            result += cnt[remain]
            if s[~i] == '7':
                result += 1
                cnt[remain] += 1
            base = (base*10)%7
        return result


",d * n
"
class Solution2(object):
    def countSubstrings(self, s):
        result = 0
        for i in range(len(s)):
            if s[i] == '4':
                result += 1
                if i-1 >= 0 and int(s[i-1:i+1])%4 == 0:
                    result += i
        for i in range(len(s)):
            if s[i] == '8':
                result += 1
                if i-1 >= 0 and int(s[i-1:i+1])%8 == 0:
                    result += 1
                if i-2 >= 0 and int(s[i-2:i+1])%8 == 0:
                    result += i-1
        for d in range(1, 9+1):
            if d in (4, 8):
                continue
            base = 1
            remain = 0
            cnt = [0]*d
            c = 0
            for i in range(len(s)):
                remain = (remain+base*(ord(s[~i])-ord('0')))%d
                c += cnt[remain]
                if s[~i] == str(d):
                    c += d != 8
                    cnt[remain] += 1
                base = (base*10)%d
            result += c
        return result


",d * n
"
class Solution3(object):
    def countSubstrings(self, s):
        result = 0
        dp = [[0]*10 for _ in range(10)]
        for i in range(1, len(s)+1):
            new_dp = [[0]*10 for _ in range(10)]
            x = ord(s[i-1])-ord('0')
            for d in range(1, 9+1):
                new_dp[d][x%d] += 1
                for r in range(d):
                    new_dp[d][(r*10+x)%d] += dp[d][r]
            dp = new_dp
            result += dp[x][0]
        return result
",d^2 * n
"
class Solution(object):
    def pourWater(self, heights, V, K):
        for _ in range(V):
            best = K
            for d in (-1, 1):
                i = K
                while 0 <= i+d < len(heights) and \
                      heights[i+d] <= heights[i]:
                    if heights[i+d] < heights[i]: best = i+d
                    i += d
                if best != K:
                    break
            heights[best] += 1
        return heights

",v * n
"
class Solution(object):
    def minAddToMakeValid(self, S):
        add, bal, = 0, 0
        for c in S:
            bal += 1 if c == '(' else -1
            if bal == -1:
                add += 1
                bal += 1
        return add + bal
",n
"

class Solution(object):
    def minimumDeletions(self, word, k):
        def counting_sort(arr, key=lambda x:x, reverse=False): 
            count = [0]*(max(arr, key=key)+1)
            for x in arr:
                count[key(x)] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            result = [0]*len(arr)
            if not reverse:
                for x in reversed(arr): 
                    count[key(x)] -= 1
                    result[count[key(x)]] = x
            else:
                for x in arr: 
                    count[key(x)] -= 1
                    result[count[key(x)]] = x
                result.reverse()
            return result
    
        cnt = [0]*26
        for x in word:
            cnt[ord(x)-ord('a')] += 1
        arr = counting_sort([x for x in cnt if x])
        result = float(""inf"")
        right = prefix = 0
        suffix = len(word)
        prev = -1
        for left in range(len(arr)):
            if left+1 < len(arr) and arr[left+1] == arr[left]:
                continue
            while right < len(arr) and arr[right] <= arr[left]+k:
                suffix -= arr[right]
                right += 1
            result = min(result, prefix+(suffix-(arr[left]+k)*(len(arr)-right)))
            prefix += arr[left]*(left-prev)
            prev = left
        return result


",n + 26
"
class Solution2(object):
    def minimumDeletions(self, word, k):
        cnt = [0]*26
        for x in word:
            cnt[ord(x)-ord('a')] += 1
        arr = sorted(x for x in cnt if x)
        result = float(""inf"")
        right = prefix = 0
        suffix = len(word)
        prev = -1
        for left in range(len(arr)):
            if left+1 < len(arr) and arr[left+1] == arr[left]:
                continue
            while right < len(arr) and arr[right] <= arr[left]+k:
                suffix -= arr[right]
                right += 1
            result = min(result, prefix+(suffix-(arr[left]+k)*(len(arr)-right)))
            prefix += arr[left]*(left-prev)
            prev = left
        return result


",n + 26 * log(26)
"
class Solution3(object):
    def minimumDeletions(self, word, k):
        cnt = [0]*26
        for x in word:
            cnt[ord(x)-ord('a')] += 1
        return min(sum(y if y < x else max(y-(x+k), 0) for y in cnt if y) for x in cnt if x)
",n + 26^2
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __str__(self):
        if self:
            return ""{}"".format(self.val)
        else:
            return None

class Solution(object):
    def detectCycle(self, head):
        fast, slow = head, head
        while fast and fast.__next__:
            fast, slow = fast.next.__next__, slow.__next__
            if fast is slow:
                fast = head
                while fast is not slow:
                    fast, slow = fast.__next__, slow.__next__
                return fast
        return None

",n
"

class CategoryHandler:
    def haveSameCategory(self, a, b):
        pass



class Solution(object):
    def numberOfCategories(self, n, categoryHandler):
        return sum(all(not categoryHandler.haveSameCategory(j, i) for j in range(i)) for i in range(n))
",n^2
"

class Solution(object):
    def minimumTime(self, nums1, nums2, x):
        dp = [0]*(len(nums1)+1)
        for i, (b, a) in enumerate(sorted(zip(nums2, nums1)), 1):
            for j in reversed(range(1, i+1)):
                dp[j] = max(dp[j], dp[j-1]+(a+j*b))
        total1, total2 = sum(nums1), sum(nums2)
        return next((j for j in range(len(dp)) if (total1+j*total2)-dp[j] <= x), -1)
",n^2
"
import collections



class Solution(object):
    def minOperations(self, nums):
        def ceil_divide(a, b):
            return (a+b-1)//b

        cnt = collections.Counter(nums)
        return sum(ceil_divide(x, 3) for x in cnt.values()) if all(x >= 2 for x in cnt.values()) else -1
",n
"

class Solution(object):
    def hasSameDigits(self, s):
        def check(mod):
            def decompose(x, mod): 
                cnt = 0
                while x > 1 and x%mod == 0:
                    x //= mod
                    cnt += 1
                return x, cnt

            result = cnt = 0
            curr = 1
            for i in range(len(s)-1):
                if cnt == 0:
                    result = (result+curr*(ord(s[i])-ord(s[i+1])))%mod
                x, c = decompose(len(s)-2-i, mod)
                curr = (curr*x)%mod
                cnt += c
                x, c = decompose(i+1, mod)
                curr = (curr*pow(x, mod-2, mod))%mod
                cnt -= c
            return result == 0

        return check(2) and check(5)


",nlogn
"LOOKUP = [[-1]*(5+1) for _ in range(5+1)]



class Solution2(object):
    def hasSameDigits(self, s):
        def nCr(n, r):
            if n-r < r:
                r = n-r
            if LOOKUP[n][r] == -1:
                c = 1
                for k in range(1, r+1):
                    c *= n-k+1
                    c //= k
                LOOKUP[n][r] = c
            return LOOKUP[n][r]

        def nCr_mod(n, r, mod):
            result = 1
            while n > 0 or r > 0:
                n, ni = divmod(n, mod)
                r, ri = divmod(r, mod)
                if ni < ri:
                    return 0
                result = (result*nCr(ni, ri))%mod
            return result

        def nC10(n, k):
            return lookup[nCr_mod(n, k, 2)][nCr_mod(n, k, 5)]

        lookup = [[0]*5 for _ in range(2)]
        for i in range(10):
            lookup[i%2][i%5] = i
        total = 0
        for i in range(len(s)-1):
            total = (total+nC10(len(s)-2, i)*(ord(s[i])-ord(s[i+1])))%10
        return total == 0
",nlogn
"













class Solution(object):
    def maxSizeSlices(self, slices):
        def maxSizeSlicesLinear(slices, start, end):
            dp = [[0]*(len(slices)//3+1) for _ in range(2)]
            for i in range(start, end):
                for j in reversed(range(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1)):
                    dp[i%2][j] = max(dp[(i-1)%2][j], dp[(i-2)%2][j-1] + slices[i])
            return dp[(end-1)%2][len(slices)//3]
        
        return max(maxSizeSlicesLinear(slices, 0, len(slices)-1),
                   maxSizeSlicesLinear(slices, 1, len(slices)))


",n^2
"class Solution2(object):
    def maxSizeSlices(self, slices):
        def maxSizeSlicesLinear(slices, start, end):
            dp = [[0]*(len(slices)//3+1) for _ in range(3)]
            for i in range(start, end):
                for j in range(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1):
                    dp[i%3][j] = max(dp[(i-1)%3][j], dp[(i-2)%3][j-1] + slices[i])
            return dp[(end-1)%3][len(slices)//3]
        
        return max(maxSizeSlicesLinear(slices, 0, len(slices)-1),
                   maxSizeSlicesLinear(slices, 1, len(slices)))
",n^2
"
import itertools


class Solution(object):
    def largestTimeFromDigits(self, A):
        result = """"
        for i in range(len(A)):
            A[i] *= -1
        A.sort()
        for h1, h2, m1, m2 in itertools.permutations(A):
            hours = -(10*h1 + h2)
            mins = -(10*m1 + m2)
            if 0 <= hours < 24 and 0 <= mins < 60:
                result = ""{:02}:{:02}"".format(hours, mins)
                break
        return result
 
",1
"
class Solution(object):
    def orderlyQueue(self, S, K):
        if K == 1:
            return min(S[i:] + S[:i] for i in range(len(S)))
        return """".join(sorted(S))

",n^2
"

class Solution(object):
    def minimumOneBitOperations(self, n):
        def gray_to_binary(n):
            result = 0
            while n:
                result ^= n
                n >>= 1
            return result
        return gray_to_binary(n)


",logn
"class Solution2(object):
    def minimumOneBitOperations(self, n):
        result = 0
        while n:
            result = -result - (n^(n-1)) 
            n &= n-1
        return abs(result)
",logn
"
import collections


class Solution(object):
    def minTransfers(self, transactions):
        accounts = collections.defaultdict(int)
        for src, dst, amount in transactions:
            accounts[src] += amount
            accounts[dst] -= amount

        debts = [account for account in accounts.values() if account]

        dp = [0]*(2**len(debts))
        sums = [0]*(2**len(debts))
        for i in range(len(dp)):
            bit = 1
            for j in range(len(debts)):
                if (i & bit) == 0:
                    nxt = i | bit
                    sums[nxt] = sums[i]+debts[j]
                    if sums[nxt] == 0:
                        dp[nxt] = max(dp[nxt], dp[i]+1)
                    else:
                        dp[nxt] = max(dp[nxt], dp[i])
                bit <<= 1
        return len(debts)-dp[-1]
",n * 2^n
"
import collections


class Solution(object):
    def minReorder(self, n, connections):
        lookup, graph = set(), collections.defaultdict(list)
        for u, v in connections:
            lookup.add(u*n+v)
            graph[v].append(u)
            graph[u].append(v) 
        result = 0
        stk = [(-1, 0)]
        while stk:
            parent, u = stk.pop()
            result += (parent*n+u in lookup)
            for v in reversed(graph[u]):
                if v == parent:
                    continue
                stk.append((u, v))
        return result


",n
"import collections


class Solution2(object):
    def minReorder(self, n, connections):
        def dfs(n, lookup, graph, parent, u):
            result = (parent*n+u in lookup)
            for v in graph[u]:
                if v == parent:
                    continue
                result += dfs(n, lookup, graph, u, v)  
            return result

        lookup, graph = set(), collections.defaultdict(list)
        for u, v in connections:
            lookup.add(u*n+v)
            graph[v].append(u)
            graph[u].append(v) 
        return dfs(n, lookup, graph, -1, 0)
",n
"

class Solution(object):
    def substringXorQueries(self, s, queries):
        mx = max(a^b for a, b in queries)
        lookup = {}
        for i in range(len(s)):
            curr = 0
            for j in range(i, len(s)):
                curr = (curr<<1)+int(s[j])
                if curr > mx:
                    break
                if curr not in lookup:
                    lookup[curr] = [i, j]
                if s[i] == '0':
                    break
        return [lookup[a^b] if a^b in lookup else [-1, -1] for a, b in queries]
",n * logr + q
"
class Solution(object):
    def isConvex(self, points):
        def det(A):
            return A[0][0]*A[1][1] - A[0][1]*A[1][0]

        n, prev, curr = len(points), 0, None
        for i in range(len(points)):
            A = [[points[(i+j) % n][0] - points[i][0], points[(i+j) % n][1] - points[i][1]] for j in (1, 2)]
            curr = det(A)
            if curr:
                if curr * prev < 0:
                    return False
                prev = curr
        return True


",n
"
class Solution(object):
    def sortColors(self, nums):
        def triPartition(nums, target):
            i, left, right = 0, 0, len(nums)-1
            while i <= right:
                if nums[i] > target:
                    nums[i], nums[right] = nums[right], nums[i]
                    right -= 1
                else:
                    if nums[i] < target:
                        nums[left], nums[i] = nums[i], nums[left]
                        left += 1
                    i += 1

        triPartition(nums, 1)
",n
"
class Solution(object):
    def __init__(self, iterator):
        self.iterator = iterator
        self.val_ = None
        self.has_next_ = iterator.hasNext()
        self.has_peeked_ = False


    def peek(self):
        if not self.has_peeked_:
            self.has_peeked_ = True
            self.val_ = next(self.iterator)
        return self.val_

    def __next__(self):
        self.val_ = self.peek()
        self.has_peeked_ = False
        self.has_next_ = self.iterator.hasNext()
        return self.val_

    def hasNext(self):
        return self.has_next_



",1
"
import collections


class Solution(object):
    def numMatchingSubseq(self, S, words):
        waiting = collections.defaultdict(list)
        for word in words:
            it = iter(word)
            waiting[next(it, None)].append(it)
        for c in S:
            for it in waiting.pop(c, ()):
                waiting[next(it, None)].append(it)
        return len(waiting[None])

",n + w
"
import itertools
import heapq



class Solution(object):
    def maxScore(self, nums1, nums2, k):
        result = curr = 0
        min_heap = []
        for a, b in sorted(zip(nums1, nums2), key=lambda x: x[1],  reverse=True):
            curr += a
            heapq.heappush(min_heap, a)
            if len(min_heap) > k:
                curr -= heapq.heappop(min_heap)
            if len(min_heap) == k:
                result = max(result, curr*b)
        return result
",nlogn
"

class Solution(object):
    def memLeak(self, memory1, memory2):
        def s(a, d, n):
            return (2*a + (n-1)*d)*n//2

        def f(a, d, x):
            r = int((-(2*a-d)+((2*a-d)**2+8*d*x)**0.5)/(2*d))
            if s(a, d, r) > x: 
                r -= 1
            return r

        is_swapped = False
        if memory1 < memory2:
            memory1, memory2 = memory2, memory1
            is_swapped = True
        n = f(1, 1, memory1-memory2)
        memory1 -= s(1, 1, n)
        if memory1 == memory2:
            is_swapped = False
        l = f(n+1, 2, memory1)
        r = f(n+2, 2, memory2)
        memory1 -= s(n+1, 2, l)
        memory2 -= s(n+2, 2, r)
        if is_swapped:
            memory1, memory2 = memory2, memory1
        return [n+l+r+1, memory1, memory2]
",1
"

class Solution(object):
    def minTime(self, skill, mana):
        result = 0
        for i in range(1, len(mana)):
            prefix = mx = 0
            for x in skill:
                prefix += x
                mx = max(mx, mana[i-1]*prefix-mana[i]*(prefix-x))
            result += mx
        result += mana[-1]*sum(skill)
        return result
",n * m
"

class Solution(object):
    def evenProduct(self, nums):
        result = (len(nums)+1)*len(nums)//2
        cnt = 0
        for x in nums:
            cnt = cnt+1 if x%2 else 0
            result -= cnt
        return result


",n
"
class Solution2(object):
    def evenProduct(self, nums):
        result = cnt = 0
        for i, x in enumerate(nums):
            if x%2 == 0:
                cnt = i+1
            result += cnt
        return result
",n
"
class Solution(object):
    def makeGood(self, s):
        stk = []
        for ch in s:
            counter_ch = ch.upper() if ch.islower() else ch.lower()
            if stk and stk[-1] == counter_ch:
                stk.pop()
            else:
                stk.append(ch)
        return """".join(stk)
",n
"
class Solution(object):
    def largestValues(self, root):
        def largestValuesHelper(root, depth, result):
            if not root:
                return
            if depth == len(result):
                result.append(root.val)
            else:
                result[depth] = max(result[depth], root.val)
            largestValuesHelper(root.left, depth+1, result)
            largestValuesHelper(root.right, depth+1, result)

        result = []
        largestValuesHelper(root, 0, result)
        return result


",n
"class Solution2(object):
    def largestValues(self, root):
        result = []
        curr = [root]
        while any(curr):
            result.append(max(node.val for node in curr))
            curr = [child for node in curr for child in (node.left, node.right) if child]
        return result


",n
"
import collections



class Solution(object):
    def countInterestingSubarrays(self, nums, modulo, k):
        cnt = collections.Counter([0])
        result = prefix = 0
        for x in nums:
            if x%modulo == k:
                prefix = (prefix+1)%modulo
            result += cnt[(prefix-k)%modulo]
            cnt[prefix] += 1
        return result
",n
"
class Solution(object):
    def hasValidPath(self, grid):
        E, S, W, N = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        directions = [
            [W, E], [N, S],
            [W, S], [S, E],
            [W, N], [N, E]
        ]

        for r, c in directions[grid[0][0]-1]:
            if not (0 <= r < len(grid) and 0 <= c < len(grid[0])):
                continue
            pr, pc = 0, 0
            while r != len(grid)-1 or c != len(grid[0])-1:
                for dx, dy in directions[grid[r][c]-1]:
                    nr, nc = r+dx, c+dy
                    if (nr == pr and nc == pc) or \
                       not(0 <= nr < len(grid) and 0 <= nc < len(grid[0])) or \
                       (-dx, -dy) not in directions[grid[nr][nc]-1]:
                        continue
                    pr, pc, r, c = r, c, nr, nc
                    break
                else:
                    return False
            return True
        return len(grid) == len(grid[0]) == 1 
",m * n
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def isEvenOddTree(self, root):
        q = [root]
        is_odd = False
        while q:
            new_q = []
            prev = None
            for node in q:
                if is_odd:
                    if node.val%2 or (prev and prev.val <= node.val):
                        return False
                else:
                    if not node.val%2 or (prev and prev.val >= node.val):
                        return False
                if node.left:
                    new_q.append(node.left)
                if node.right:
                    new_q.append(node.right)
                prev = node
            q = new_q
            is_odd = not is_odd
        return True
",n
"

class Solution(object):
    def vowelStrings(self, words, left, right):
        VOWELS = {'a', 'e', 'i', 'o', 'u'}
        return sum(words[i][0] in VOWELS and words[i][-1] in VOWELS for i in range(left, right+1))
",n
"
import heapq



class Solution(object):
    def minOperations(self, n, m):
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf
            
        def dijkstra(start, target):
            if spf[start] == start:
                return -1
            lookup = set()
            min_heap = [(start, start)]
            while min_heap:
                curr, i = heapq.heappop(min_heap)
                if i in lookup:
                    continue
                lookup.add(i)
                if i == target:
                    return curr
                base = 1
                while base <= i:
                    x = i//base
                    for d in (-1, 1):
                        if (1 if x <= 9 else 0) <= x%10+d <= 9 and spf[i+d*base] != i+d*base and i+d*base not in lookup:
                            heapq.heappush(min_heap, (curr+(i+d*base), i+d*base))
                    base *= 10
            return -1
        
        base = 1
        while base < max(n, m):
            base *= 10
        spf = linear_sieve_of_eratosthenes(base)
        return dijkstra(n, m)
",nlogn
"
class Solution(object):
    def findLUSlength(self, a, b):
        if a == b:
            return -1
        return max(len(a), len(b))

","min(a, b)"
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):

    def __init__(self, root):
        self.__stk = []
        self.__traversalLeft(root)
        self.__vals = []
        self.__pos = -1

    def hasNext(self):
        return self.__pos+1 != len(self.__vals) or self.__stk

    def __next__(self):
        self.__pos += 1
        if self.__pos == len(self.__vals):
            node = self.__stk.pop()
            self.__traversalLeft(node.right)
            self.__vals.append(node.val)
        return self.__vals[self.__pos]
        
    def hasPrev(self):
        return self.__pos-1 >= 0

    def prev(self):
        self.__pos -= 1
        return self.__vals[self.__pos]
    
    def __traversalLeft(self, node):
        while node is not None:
            self.__stk.append(node)
            node = node.left

",1
"
class Solution(object):
    def countCornerRectangles(self, grid):
        rows = [[c for c, val in enumerate(row) if val]
                for row in grid]
        result = 0
        for i in range(len(rows)):
            lookup = set(rows[i])
            for j in range(i):
                count = sum(1 for c in rows[j] if c in lookup)
                result += count*(count-1)/2
        return result

",n * m^2
"
class Solution(object):
    def findMaxLength(self, nums):
        result, count = 0, 0
        lookup = {0: -1}
        for i, num in enumerate(nums):
            count += 1 if num == 1 else -1
            if count in lookup:
                result = max(result, i - lookup[count])
            else:
                lookup[count] = i

        return result

",n
"
import collections



class Solution(object):
    def mostFrequentEven(self, nums):
        cnt = collections.Counter(x for x in nums if x%2 == 0)
        return max(iter(cnt.keys()), key=lambda x: (cnt[x], -x)) if cnt else -1
",n
"
class Solution(object):
    def maxAbsoluteSum(self, nums):
        curr = mx = mn = 0
        for num in nums:
            curr += num
            mx = max(mx, curr)
            mn = min(mn, curr)
        return mx-mn
",n
"
class Solution(object):
    def countPairs(self, nums1, nums2):
        for i in range(len(nums1)):
            nums1[i] -= nums2[i]
        nums1.sort()
        result = 0
        left, right = 0, len(nums1)-1
        while left < right:
            if nums1[left] > 0 or -nums1[left] < nums1[right]:
                result += right-left
                right -= 1
            else:
                left += 1
        return result
",nlogn
"
import collections


class Solution(object):
    def findMaxValueOfEquation(self, points, k):
        result = float(""-inf"")
        dq = collections.deque()
        for i, (x, y) in enumerate(points):
            while dq and points[dq[0]][0] < x-k:
                dq.popleft()
            if dq:
                result = max(result, (points[dq[0]][1]-points[dq[0]][0])+y+x)
            while dq and points[dq[-1]][1]-points[dq[-1]][0] <= y-x:
                dq.pop()
            dq.append(i)
        return result
",n
"
import collections


class Solution(object):
    def findingUsersActiveMinutes(self, logs, k):
        lookup = collections.defaultdict(set)
        for u, t in logs:
            lookup[u].add(t)
        result = [0]*k
        for _, ts in lookup.items():
            result[len(ts)-1] += 1
        return result
",n
"
class Solution(object):
    def pacificAtlantic(self, matrix):
        PACIFIC, ATLANTIC = 1, 2

        def pacificAtlanticHelper(matrix, x, y, prev_height, prev_val, visited, res):
            if (not 0 <= x < len(matrix)) or \
               (not 0 <= y < len(matrix[0])) or \
               matrix[x][y] < prev_height or \
               (visited[x][y] | prev_val) == visited[x][y]:
                return

            visited[x][y] |= prev_val
            if visited[x][y] == (PACIFIC | ATLANTIC):
                res.append((x, y))

            for d in [(0, -1), (0, 1), (-1, 0), (1, 0)]:
                pacificAtlanticHelper(matrix, x + d[0], y + d[1], matrix[x][y], visited[x][y], visited, res)

        if not matrix:
            return []

        res = []
        m, n = len(matrix),len(matrix[0])
        visited = [[0 for _ in range(n)] for _ in range(m)]

        for i in range(m):
            pacificAtlanticHelper(matrix, i, 0, float(""-inf""), PACIFIC, visited, res)
            pacificAtlanticHelper(matrix, i, n - 1, float(""-inf""), ATLANTIC, visited, res)
        for j in range(n):
            pacificAtlanticHelper(matrix, 0, j, float(""-inf""), PACIFIC, visited, res)
            pacificAtlanticHelper(matrix, m - 1, j, float(""-inf""), ATLANTIC, visited, res)

        return res

",m * n
"
class Solution(object):
    def wonderfulSubstrings(self, word):
        ALPHABET_SIZE = 10
        count = [0]*(2**ALPHABET_SIZE)
        count[0] = 1
        result = curr = 0
        for c in word:
            curr ^= 1<<(ord(c)-ord('a'))
            result += count[curr]
            result += sum(count[curr^(1<<i)] for i in range(ALPHABET_SIZE))
            count[curr] += 1
        return result
",n
"
import collections



class Solution(object):
    def maxSubarraySum(self, nums):
        result = float(""-inf"")
        curr = mn = mn0 = 0
        mn1 = collections.defaultdict(int)
        for x in nums:
            curr += x
            result = max(result, curr-mn)
            mn1[x] = min(mn1[x], mn0)+x
            mn0 = min(mn0, curr)
            mn = min(mn, mn1[x], mn0)
        return result


",n
"import collections



class Solution2(object):
    def maxSubarraySum(self, nums):
        result = float(""-inf"")
        curr = mn = mn0 = 0
        mn1 = collections.defaultdict(int)
        for x in nums:
            curr += x
            result = max(result, curr-mn)
            if x < 0:
                mn1[x] = min(mn1[x], mn0)+x
                mn = min(mn, mn1[x])
            mn0 = min(mn0, curr)
            mn = min(mn, mn0)
        return result


",n
"import collections



class Solution_TLE(object):
    def maxSubarraySum(self, nums):
        MAX, TOTAL, PREFIX, SUFFIX = list(range(4))
        class SegmentTree(object):
            def __init__(self, N,
                        build_fn=lambda _: None,
                        query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                        update_fn=lambda x: x):
                self.tree = [None]*(1<<((N-1).bit_length()+1))
                self.base = len(self.tree)>>1
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x >>= 1
                    self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])

            def query(self, L, R):
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L >>= 1
                    R >>= 1
                return self.query_fn(left, right)
        
        def build(i):
            return [nums[i]]*4
        
        def query(x, y):
            if x is None:
                return y
            if y is None:
                return x
            return [max(x[MAX], y[MAX], x[SUFFIX]+y[PREFIX]),
                    x[TOTAL]+y[TOTAL],
                    max(x[PREFIX], x[TOTAL]+y[PREFIX]),
                    max(y[SUFFIX], x[SUFFIX]+y[TOTAL])]

        mx = max(nums)
        if mx < 0:
            return mx
        mn = min(nums)
        if mn >= 0:
            return sum(nums)
        groups = collections.defaultdict(list)
        for i, x in enumerate(nums):
            groups[x].append(i)
        st = SegmentTree(len(nums), build_fn=build, query_fn=query)
        result = st.tree[1][0] 
        for k, v in groups.items():
            for i in v:
                st.update(i, None)
            result = max(result, st.tree[1][0]) 
            for i in v:
                st.update(i, [k]*4)
        return result
",nlogn
"
class Solution(object):
    def findGameWinner(self, n):
        return n%6 != 1


",n
"class Solution2(object):
    def findGameWinner(self, n):
        grundy = [0, 1] 
        for i in range(2, n):
            grundy[i%2] = (grundy[(i-1)%2]+1)^(grundy[(i-2)%2]+1) 
        return grundy[(n-1)%2] > 0
",n
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def removeElements(self, head, val):
        dummy = ListNode(float(""-inf""))
        dummy.next = head
        prev, curr = dummy, dummy.__next__

        while curr:
            if curr.val == val:
                prev.next = curr.__next__
            else:
                prev = curr

            curr = curr.__next__

        return dummy.__next__



",n
"

class Solution(object):
    def possibleStringCount(self, word, k):
        MOD = 10**9+7
        cnt = [0]
        for i in range(len(word)):
            cnt[-1] += 1
            if i+1 == len(word) or word[i+1] != word[i]:
                cnt.append(0)
        cnt.pop()
        result = reduce(lambda accu, x: accu*x%MOD, cnt, 1)
        if k <= len(cnt):
            return result
        dp = [0]*(k-len(cnt))
        dp[0] = 1
        for l in cnt:
            for i in range(len(dp)-1):
                dp[i+1] = (dp[i+1]+dp[i])%MOD
            for i in reversed(range(l, len(dp))):
                dp[i] = (dp[i]-dp[i-l])%MOD
        return reduce(lambda accu, x: (accu-x)%MOD, dp, result)
",n + k^2
"
import collections
import heapq


class Solution(object):
    def scheduleCourse(self, courses):
        courses.sort(key=lambda t_end: t_end[1])
        max_heap = []
        now = 0
        for t, end in courses:
            now += t
            heapq.heappush(max_heap, -t)
            if now > end:
                now += heapq.heappop(max_heap)
        return len(max_heap)

",nlogn
"

class Solution(object):
    def maxA(self, N):
        if N < 7:
            return N
        if N == 10:
            return 20 

        n = N // 5 + 1 
        n3 = 5*n - N - 1
        n4 = n - n3
        return 3**n3 * 4**n4


",1
"class Solution2(object):
    def maxA(self, N):
        if N < 7:
            return N
        dp = list(range(N+1))
        for i in range(7, N+1):
            dp[i % 6] = max(dp[(i-4) % 6]*3, dp[(i-5) % 6]*4)
        return dp[N % 6]

",n
"
class Solution(object):
    def minDiffInBST(self, root):
        def dfs(node):
            if not node:
                return
            dfs(node.left)
            self.result = min(self.result, node.val-self.prev)
            self.prev = node.val
            dfs(node.right)

        self.prev = float('-inf')
        self.result = float('inf')
        dfs(root)
        return self.result


",n
"

class Solution(object):
    def distanceTraveled(self, mainTank, additionalTank):
        USE, REFILL, DIST = 5, 1, 10
        cnt = min((mainTank-REFILL)//(USE-REFILL), additionalTank)
        return (mainTank+cnt*REFILL)*DIST
",1
"
import itertools


class Solution(object):
    def flipgame(self, fronts, backs):
        same = {n for i, n in enumerate(fronts) if n == backs[i]}
        result = float(""inf"")
        for n in itertools.chain(fronts, backs):
            if n not in same:
                result = min(result, n)
        return result if result < float(""inf"") else 0

",n
"

class Solution(object):
    def reorderSpaces(self, text):
        text = list(text)
        space_count, word_count = 0, 0
        for i, c in enumerate(text):
            if c == ' ':
                space_count += 1
            elif i == 0 or text[i-1] == ' ':
                word_count += 1

        left, i = 0, 0
        while i < len(text):
            has_word = False
            while i < len(text) and text[i] != ' ':
                text[left], text[i] = text[i], text[left]
                left += 1
                i += 1
                has_word = True
            if has_word:
                left += 1 
            i += 1

        equal_count = space_count//(word_count-1) if word_count-1 > 0 else 0
        extra_count = space_count%(word_count-1) if word_count-1 > 0 else space_count
        right, i = len(text)-1-extra_count, len(text)-1
        while i >= 0:
            has_word = False
            while i >= 0 and text[i] != ' ':
                text[right], text[i] = text[i], text[right]
                right -= 1
                i -= 1
                has_word = True
            if has_word:
                right -= equal_count 
            i -= 1
        return """".join(text)
",n
"
class Solution(object):
    def stoneGameIII(self, stoneValue):
        dp = [float(""-inf"")]*3
        dp[len(stoneValue)%3] = 0
        for i in reversed(range(len(stoneValue))):
            max_dp, curr = float(""-inf""), 0
            for j in range(min(3, len(stoneValue)-i)):
                curr += stoneValue[i+j]
                max_dp = max(max_dp, curr-dp[(i+j+1)%3])
            dp[i%3] = max_dp
        return [""Tie"", ""Alice"", ""Bob""][cmp(dp[0], 0)]
",n
"

class Solution(object):
    def gameResult(self, head):
        cnt = 0
        while head:
            cnt += cmp(head.val, head.next.val)
            head = head.next.__next__
        return ""Tie"" if cnt == 0 else ""Odd"" if cnt < 0 else ""Even""
",n
"
class Solution(object):
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        m, n = len(matrix), len(matrix[0])
        size = [[0 for j in range(n)] for i in range(2)]
        max_size = 0

        for j in range(n):
            if matrix[0][j] == '1':
                size[0][j] = 1
            max_size = max(max_size, size[0][j])

        for i in range(1, m):
            if matrix[i][0] == '1':
                size[i % 2][0] = 1
            else:
                size[i % 2][0] = 0
            for j in range(1, n):
                if matrix[i][j] == '1':
                    size[i % 2][j] = min(size[i % 2][j - 1], \
                                         size[(i - 1) % 2][j], \
                                         size[(i - 1) % 2][j - 1]) + 1
                    max_size = max(max_size, size[i % 2][j])
                else:
                    size[i % 2][j] = 0

        return max_size * max_size


",n^2
"
class Solution2(object):
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        m, n = len(matrix), len(matrix[0])
        size = [[0 for j in range(n)] for i in range(m)]
        max_size = 0

        for j in range(n):
            if matrix[0][j] == '1':
                size[0][j] = 1
            max_size = max(max_size, size[0][j])

        for i in range(1, m):
            if matrix[i][0] == '1':
                size[i][0] = 1
            else:
                size[i][0] = 0
            for j in range(1, n):
                if matrix[i][j] == '1':
                    size[i][j] = min(size[i][j - 1],  \
                                     size[i - 1][j],  \
                                     size[i - 1][j - 1]) + 1
                    max_size = max(max_size, size[i][j])
                else:
                    size[i][j] = 0

        return max_size * max_size


",n^2
"
class Solution3(object):
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        H, W = 0, 1
        table = [[[0, 0] for j in range(len(matrix[0]))] \
                         for i in range(len(matrix))]
        for i in reversed(range(len(matrix))):
            for j in reversed(range(len(matrix[i]))):
                if matrix[i][j] == '1':
                    h, w = 1, 1
                    if i + 1 < len(matrix):
                        h = table[i + 1][j][H] + 1
                    if j + 1 < len(matrix[i]):
                        w = table[i][j + 1][W] + 1
                    table[i][j] = [h, w]

        s = [[0 for j in range(len(matrix[0]))] \
                for i in range(len(matrix))]
        max_square_area = 0
        for i in reversed(range(len(matrix))):
            for j in reversed(range(len(matrix[i]))):
                side = min(table[i][j][H], table[i][j][W])
                if matrix[i][j] == '1':
                    if i + 1 < len(matrix) and j + 1 < len(matrix[i + 1]):
                        side = min(s[i + 1][j + 1] + 1, side)
                    s[i][j] = side
                    max_square_area = max(max_square_area, side * side)

        return max_square_area


",n^2
"

class Solution(object):
    def updateBoard(self, board, click):
        if board[click[0]][click[1]] == 'M':
            board[click[0]][click[1]] = 'X'
            return board
        stk = [click]
        while stk:
            r, c = stk.pop()
            cnt = 0
            adj = []
            for dr in range(-1, 2):
                for dc in range(-1, 2):
                    if dr == dc == 0:
                        continue
                    nr, nc = r+dr, c+dc
                    if not (0 <= nr < len(board) and 0 <= nc < len(board[r])):
                        continue
                    if board[nr][nc] == 'M':
                        cnt += 1
                    elif board[nr][nc] == 'E':
                        adj.append((nr, nc))
            if cnt:
                board[r][c] = chr(cnt + ord('0'))
                continue
            board[r][c] = 'B'
            for nr, nc in adj:
                board[nr][nc] = ' '
                stk.append((nr, nc))
        return board


",m * n
"
class Solution2(object):
    def updateBoard(self, board, click):
        if board[click[0]][click[1]] == 'M':
            board[click[0]][click[1]] = 'X'
            return board
        q = [click]
        while q:
            new_q = []
            for r, c in q:
                cnt = 0
                adj = []
                for dr in range(-1, 2):
                    for dc in range(-1, 2):
                        if dr == dc == 0:
                            continue
                        nr, nc = r+dr, c+dc
                        if not (0 <= nr < len(board) and 0 <= nc < len(board[r])):
                            continue
                        if board[nr][nc] == 'M':
                            cnt += 1
                        elif board[nr][nc] == 'E':
                            adj.append((nr, nc))
                if cnt:
                    board[r][c] = chr(cnt + ord('0'))
                    continue
                board[r][c] = 'B'
                for nr, nc in adj:
                    board[nr][nc] = ' '
                    new_q.append((nr, nc))
            q = new_q
        return board
",m * n
"
import collections



class Solution(object):
    def validTree(self, n, edges):
        if len(edges) != n - 1: 
            return False

        neighbors = collections.defaultdict(list)
        for u, v in edges:
            neighbors[u].append(v)
            neighbors[v].append(u)

        q = collections.deque([0])
        visited = set([0])
        while q:
            curr = q.popleft()
            for node in neighbors[curr]:
                if node not in visited:
                    visited.add(node)
                    q.append(node)

        return len(visited) == n


",|V| + |E|
"
class Solution2(object):
    def validTree(self, n, edges):
        visited_from = [-1] * n
        neighbors = collections.defaultdict(list)
        for u, v in edges:
            neighbors[u].append(v)
            neighbors[v].append(u)

        q = collections.deque([0])
        visited = set([0])
        while q:
            i = q.popleft()
            for node in neighbors[i]:
                if node != visited_from[i]:
                    if node in visited:
                        return False
                    else:
                        visited.add(node)
                        visited_from[node] = i
                        q.append(node)
        return len(visited) == n

",|V| + |E|
"
class Solution(object):
    def scoreOfStudents(self, s, answers):
        MAX_ANS = 1000
        n = (len(s)+1)//2
        dp = [[set() for _ in range(n)] for _ in range(n)]
        for i in range(n):
            dp[i][i].add(int(s[i*2]))
        for l in range(1, n):
            for left in range(n-l):
                right = left+l
                for k in range(left, right):
                    if s[2*k+1] == '+':
                        dp[left][right].update((x+y for x in dp[left][k] for y in dp[k+1][right] if x+y <= MAX_ANS))
                    else:
                        dp[left][right].update((x*y for x in dp[left][k] for y in dp[k+1][right] if x*y <= MAX_ANS))
        target = eval(s)
        return sum(5 if ans == target else 2 if ans in dp[0][-1] else 0 for ans in answers)


",n^3 * a^2
"class Solution2(object):
    def scoreOfStudents(self, s, answers):
        MAX_ANS = 1000
        def evaluate(s):
            def compute(operands, operators):
                right, left = operands.pop(), operands.pop()
                operands.append(ops[operators.pop()](left, right))

            ops = {'+':operator.add, '*':operator.mul}
            precedence = {'+':0, '*':1}
            operands, operators, operand = [], [], 0
            for c in s:
                if c.isdigit():
                    operands.append(int(c))
                else:
                    while operators and precedence[operators[-1]] >= precedence[c]:
                        compute(operands, operators)
                    operators.append(c)
            while operators:
                compute(operands, operators)
            return operands[-1]

        n = (len(s)+1)//2
        dp = [[set() for _ in range(n)] for _ in range(n)]
        for i in range(n):
            dp[i][i].add(int(s[i*2]))
        for l in range(1, n):
            for left in range(n-l):
                right = left+l
                for k in range(left, right):
                    if s[2*k+1] == '+':
                        dp[left][right].update((x+y for x in dp[left][k] for y in dp[k+1][right] if x+y <= MAX_ANS))
                    else:
                        dp[left][right].update((x*y for x in dp[left][k] for y in dp[k+1][right] if x*y <= MAX_ANS))
        target = evaluate(s)
        return sum(5 if ans == target else 2 if ans in dp[0][-1] else 0 for ans in answers)
",n^3 * a^2
"
import collections



class Solution(object):
    def maxFreq(self, s, maxLetters, minSize, maxSize):
        M, p = 10**9+7, 113
        power, rolling_hash = pow(p, minSize-1, M), 0

        left = 0
        lookup, count = collections.defaultdict(int), collections.defaultdict(int)
        for right in range(len(s)):
            count[s[right]] += 1
            if right-left+1 > minSize:
                count[s[left]] -= 1
                rolling_hash = (rolling_hash - ord(s[left])*power) % M
                if count[s[left]] == 0:
                    count.pop(s[left])
                left += 1
            rolling_hash = (rolling_hash*p + ord(s[right])) % M
            if right-left+1 == minSize and len(count) <= maxLetters:
                lookup[rolling_hash] += 1
        return max(list(lookup.values()) or [0])


",n
"class Solution2(object):
    def maxFreq(self, s, maxLetters, minSize, maxSize):
        lookup = {}
        for right in range(minSize-1, len(s)):
            word = s[right-minSize+1:right+1]
            if word in lookup:
                lookup[word] += 1
            elif len(collections.Counter(word)) <= maxLetters:
                lookup[word] = 1
        return max(list(lookup.values()) or [0])
",m * n
"
import collections
import itertools



class Solution(object):
    def maxJumps(self, arr, d):
        def dp(arr, d, i, left, right, lookup):
            if lookup[i]:
                return lookup[i]
            lookup[i] = 1
            for j in itertools.chain(left[i], right[i]):
                lookup[i] = max(lookup[i], dp(arr, d, j, left, right, lookup)+1)
            return lookup[i]

        left, decreasing_dq = [[] for _ in range(len(arr))], collections.deque()
        for i in range(len(arr)):
            if decreasing_dq and i - decreasing_dq[0] == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
                if left[i] and arr[left[i][-1]] != arr[decreasing_dq[-1]]:
                    left[i] = []
                left[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)
        right, decreasing_dq = [[] for _ in range(len(arr))], collections.deque()
        for i in reversed(range(len(arr))):
            if decreasing_dq and decreasing_dq[0] - i == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
                if right[i] and arr[right[i][-1]] != arr[decreasing_dq[-1]]:
                    right[i] = []
                right[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)

        lookup = [0]*len(arr)
        return max(map(lambda x: dp(arr, d, x, left, right, lookup), range(len(arr))))


",n
"
class Solution2(object):
    def maxJumps(self, arr, d):
        left, decreasing_stk = [[] for _ in range(len(arr))], []
        for i in range(len(arr)):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if i - decreasing_stk[-1] <= d:
                    if left[i] and arr[left[i][-1]] != arr[decreasing_stk[-1]]:
                        left[i] = []
                    left[i].append(decreasing_stk[-1])
                decreasing_stk.pop()
            decreasing_stk.append(i)
        right, decreasing_stk = [[] for _ in range(len(arr))], []
        for i in reversed(range(len(arr))):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if decreasing_stk[-1] - i <= d:
                    if right[i] and arr[right[i][-1]] != arr[decreasing_stk[-1]]:
                        right[i] = []
                    right[i].append(decreasing_stk[-1])
                decreasing_stk.pop()
            decreasing_stk.append(i)

        dp = [0]*len(arr)
        for a, i in sorted([a, i] for i, a in enumerate(arr)):
            dp[i] = 1
            for j in itertools.chain(left[i], right[i]):
                dp[i] = max(dp[i], dp[j]+1)
        return max(dp)




class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=max,
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])
        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h)
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = self.default_val
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))


",nlogn
"
class Solution3(object):
    def maxJumps(self, arr, d):
        left, decreasing_stk = list(range(len(arr))), []
        for i in range(len(arr)):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if i - decreasing_stk[-1] <= d:
                    left[i] = decreasing_stk[-1]
                decreasing_stk.pop()
            decreasing_stk.append(i)
        right, decreasing_stk = list(range(len(arr))), []
        for i in reversed(range(len(arr))):
            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
                if decreasing_stk[-1] - i <= d:
                    right[i] = decreasing_stk[-1]
                decreasing_stk.pop()
            decreasing_stk.append(i)

        segment_tree = SegmentTree(len(arr))
        for _, i in sorted([x, i] for i, x in enumerate(arr)):
            segment_tree.update(i, i, segment_tree.query(left[i], right[i]) + 1)
        return segment_tree.query(0, len(arr)-1)
",nlogn
"
import collections



class Solution(object):
    def maxProduct(self, nums, k, limit):
        total = sum(nums)
        if k > total or k < -total: 
            return -1
        dp = collections.defaultdict(set)
        for x in nums:
            new_dp = collections.defaultdict(set, {k:set(v) for k, v in dp.items()})
            new_dp[(1, x)].add(min(x, limit+1))
            for (p, total), products in dp.items():
                new_state = (p^1, total+(x if p == 0 else -x))
                for v in products:
                    new_dp[new_state].add(min(v*x, limit+1))
            dp = new_dp
        result = -1
        for (p, total), products in dp.items():
            if total != k:
                continue
            for v in products:
                if v <= limit:
                    result = max(result, v)
        return result
",n * k * l
"

class Solution(object):
    def orArray(self, nums):
        return [nums[i]|nums[i+1] for i in range(len(nums)-1)]
",n
"

class Solution(object):
    def minimumAverageDifference(self, nums):
        total = sum(nums)
        mn, idx = float(""inf""), -1
        prefix = 0
        for i, x in enumerate(nums):
            prefix += x
            a = prefix//(i+1)
            b = (total-prefix)//(len(nums)-(i+1)) if i+1 < len(nums) else 0
            diff = abs(a-b)
            if diff < mn:
                mn, idx = diff, i
        return idx
",n
"

class Solution(object):
    def minimumFinishTime(self, tires, changeTime, numLaps):
        def ceil_log2(x):
            return (x-1).bit_length()

        dp = [float(""inf"")]*ceil_log2(changeTime+1) 
        for f, r in tires:
            total = curr = f
            cnt = 0
            while curr < changeTime+f: 
                dp[cnt] = min(dp[cnt], total)
                curr *= r
                total += curr
                cnt += 1
        dp2 = [float(""inf"")]*numLaps 
        for i in range(numLaps):
            dp2[i] = min((dp2[i-j-1]+changeTime if i-j-1 >= 0 else 0)+dp[j] for j in range(min(i+1, len(dp))))
        return dp2[-1]
",(n + l) * logc
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def hasCycle(self, head):
        fast, slow = head, head
        while fast and fast.__next__:
            fast, slow = fast.next.__next__, slow.__next__
            if fast is slow:
                return True
        return False

",n
"
class Solution(object):
    def countNumbersWithUniqueDigits(self, n):
        if n == 0:
            return 1
        result = cnt = 1
        for i in range(n-1):
            cnt *= 9-i
            result += cnt
        return 1+9*result


",n
"class Solution2(object):
    def countNumbersWithUniqueDigits(self, n):
        fact = [1]*2
        def nPr(n, k):
            while len(fact) <= n: 
                fact.append(fact[-1]*len(fact))
            return fact[n]//fact[n-k]

        return 1+9*sum(nPr(9, i) for i in range(n))
",n
"
class Solution(object):
    def parseBoolExpr(self, expression):
        def parse(expression, i):
            if expression[i[0]] not in ""&|!"":
                result = expression[i[0]] == 't'
                i[0] += 1
                return result
            op = expression[i[0]]
            i[0] += 2
            stk = []
            while expression[i[0]] != ')':
                if expression[i[0]] == ',': 
                    i[0] += 1
                    continue
                stk.append(parse(expression, i))
            i[0] += 1
            if op == '&':
                return all(stk)
            if op == '|':
                return any(stk)
            return not stk[0]

        return parse(expression, [0])
",n
"

cnt = [0]*2
class Solution(object):
    def countKReducibleNumbers(self, s, k):
        MOD = 10**9+7
        def popcount(x):
            return bin(x).count('1')

        while len(s)-1 >= len(cnt): 
            cnt.append(cnt[popcount(len(cnt))]+1)
        dp = [0]*len(s)
        curr = 0
        for i in range(len(s)):
            for j in reversed(list(range(i))):
                dp[j+1] = (dp[j+1]+dp[j])%MOD
            if s[i] != '1':
                continue
            dp[curr] = (dp[curr]+1)%MOD
            curr += 1
        return reduce(lambda accu, x: (accu+x)%MOD, (dp[i] for i in range(1, len(s)) if cnt[i] < k), 0)


",n^2
"
cnt = [0]*2
class Solution2(object):
    def countKReducibleNumbers(self, s, k):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]  
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def popcount(x):
            return bin(x).count('1')
      
        while len(s)-1 >= len(cnt): 
            cnt.append(cnt[popcount(len(cnt))]+1)
        result = curr = 0
        for i in range(len(s)):
            if s[i] != '1':
                continue
            for c in range((len(s)-(i+1))+1):
                if cnt[curr+c] < k:
                    result = (result+nCr(len(s)-(i+1), c))%MOD
            curr += 1
        return (result-1)%MOD

",n^2
"

class Solution(object):
    def shortestSequence(self, rolls, k):
        l = 0
        lookup = set()
        for x in rolls:
            lookup.add(x)
            if len(lookup) != k:
                continue
            lookup.clear()
            l += 1
        return l+1
",n
"

class Solution(object):
    def maxHeightOfTriangle(self, red, blue):
        def f(x, y):
            a, b = int(2*x**0.5)-1, int((4*y+1)**0.5)-1
            return min(a, b)+int(a != b)
        
        return max(f(red, blue), f(blue, red))


",logn
"
class Solution2(object):
    def maxHeightOfTriangle(self, red, blue):
        def f(x, y):
            h = 0
            while x >= h+1:
                h += 1
                x -= h
                x, y = y, x
            return h

        return max(f(red, blue), f(blue, red))
",sqrt(n)
"
class Solution(object):
    def removeElement(self, A, elem):
        i, last = 0, len(A) - 1
        while i <= last:
            if A[i] == elem:
                A[i], A[last] = A[last], A[i]
                last -= 1
            else:
                i += 1
        return last + 1

",n
"

class Solution(object):
    def differenceOfDistinctValues(self, grid):
        def update(i, j):
            lookup = set()
            for k in range(min(len(grid)-i, len(grid[0])-j)):
                result[i+k][j+k] = len(lookup)
                lookup.add(grid[i+k][j+k])
            lookup.clear()
            for k in reversed(range(min(len(grid)-i, len(grid[0])-j))):
                result[i+k][j+k] = abs(result[i+k][j+k]-len(lookup))
                lookup.add(grid[i+k][j+k])

        result = [[0]*len(grid[0]) for _ in range(len(grid))]
        for j in range(len(grid[0])):
            update(0, j)
        for i in range(1, len(grid)):
            update(i, 0)
        return result
",m * n
"

class Solution(object):
    def numberOfSubstrings(self, s, k):
        def count():
            cnt = [0]*26
            result= left = 0
            for right in range(len(s)):
                cnt[ord(s[right])-ord('a')] += 1
                while cnt[ord(s[right])-ord('a')] == k:
                    cnt[ord(s[left])-ord('a')] -= 1
                    left += 1
                result += right-left+1
            return result
                
        return (len(s)+1)*len(s)//2-count()
",n + 26
"
class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def removeStones(self, stones):
        MAX_ROW = 10000
        union_find = UnionFind(2*MAX_ROW)
        for r, c in stones:
            union_find.union_set(r, c+MAX_ROW)
        return len(stones) - len({union_find.find_set(r) for r, _ in stones})
",n
"
import collections



class Queue(object):
    def __init__(self):
        self.data = collections.deque()

    def push(self, x):
        self.data.append(x)

    def peek(self):
        return self.data[0]

    def pop(self):
        return self.data.popleft()

    def size(self):
        return len(self.data)

    def empty(self):
        return len(self.data) == 0








class Solution(object):
    def invertTree(self, root):
        if root is not None:
            nodes = Queue()
            nodes.push(root)
            while not nodes.empty():
                node = nodes.pop()
                node.left, node.right = node.right, node.left
                if node.left is not None:
                    nodes.push(node.left)
                if node.right is not None:
                    nodes.push(node.right)

        return root

",n
"
class Solution2(object):
    def invertTree(self, root):
        if root is not None:
            nodes = []
            nodes.append(root)
            while nodes:
                node = nodes.pop()
                node.left, node.right = node.right, node.left
                if node.left is not None:
                    nodes.append(node.left)
                if node.right is not None:
                    nodes.append(node.right)

        return root

",n
"
class Solution3(object):
    def invertTree(self, root):
        if root is not None:
            root.left, root.right = self.invertTree(root.right), \
                                    self.invertTree(root.left)

        return root

",n
"
class Solution(object):
    def minSubsequence(self, nums):
        result, total, curr = [], sum(nums), 0
        nums.sort(reverse=True)
        for i, x in enumerate(nums):
            curr += x
            if curr > total-curr:
                break
        return nums[:i+1]
",nlogn
"
class Solution(object):
    def maximumScore(self, nums, k):
        result = curr = nums[k]
        left = right = k
        while left-1 >= 0 or right+1 < len(nums):
            if (nums[left-1] if left-1 >= 0 else 0) <= (nums[right+1] if right+1 < len(nums) else 0):
                right += 1
            else:
                left -= 1
            curr = min(curr, nums[left], nums[right])
            result = max(result, curr*(right-left+1))
        return result


",n
"import bisect


class Solution2(object):
    def maximumScore(self, nums, k):
        def score(nums, k):
            prefix = [nums[k]]*(k+1)
            for i in reversed(range(k)):
                prefix[i] = min(prefix[i+1], nums[i])
            result = right = nums[k]
            for j in range(k+1, len(nums)):
                right = min(right, nums[j])
                i = bisect.bisect_left(prefix, right)
                if i >= 0:
                    result = max(result, right*(j-i+1))
            return result

        return max(score(nums, k), score(nums[::-1], len(nums)-1-k))
 
",nlogn
"
class Solution(object):
    def prevPermOpt1(self, A):
        for left in reversed(range(len(A)-1)):
            if A[left] > A[left+1]:
                break
        else:
            return A
        right = len(A)-1
        while A[left] <= A[right]:
            right -= 1
        while A[right-1] == A[right]:
            right -= 1
        A[left], A[right] = A[right], A[left]
        return A
",n
"
class Solution(object):
    def countSquares(self, matrix):
        for i in range(1, len(matrix)):
            for j in range(1, len(matrix[0])):
                if not matrix[i][j]:
                    continue
                l = min(matrix[i-1][j], matrix[i][j-1])
                matrix[i][j] = l+1 if matrix[i-l][j-l] else l
        return sum(x for row in matrix for x in row)
",m * n
"
import collections



class Solution(object):
    def maxFrequency(self, nums, k):
        result = 0
        cnt = collections.defaultdict(int)
        for x in nums:
            cnt[x] = max(cnt[x], cnt[k])+1
            result = max(result+int(x == k), cnt[x])
        return result
",n
"
import random



class Solution(object):
    def minOperationsToMakeMedianK(self, nums, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        nth_element(nums, len(nums)//2)
        return (sum(max(nums[i]-k, 0) for i in range(len(nums)//2+1))+
                sum(max(k-nums[i], 0) for i in range(len(nums)//2, len(nums))))


",n
"
class Solution2(object):
    def minOperationsToMakeMedianK(self, nums, k):
        nums.sort()
        return (sum(max(nums[i]-k, 0) for i in range(len(nums)//2+1))+
                sum(max(k-nums[i], 0) for i in range(len(nums)//2, len(nums))))
",nlogn
"

class ListNode(object):
    def __init__(self, val=0, next=None):
        pass



class Solution(object):
    def spiralMatrix(self, m, n, head):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        result = [[-1]*n for _ in range(m)]
        i = j = d = 0
        while head:
            result[i][j] = head.val
            if not (0 <= i+directions[d][0] < m and 0 <= j+directions[d][1] < n and result[i+directions[d][0]][j+directions[d][1]] == -1):
                d = (d+1)%4
            i, j = i+directions[d][0], j+directions[d][1]
            head = head.__next__
        return result
",m * n
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None



class Solution(object):
    def plusOne(self, head):
        if not head:
            return None

        dummy = ListNode(0)
        dummy.next = head

        left, right = dummy, head
        while right.__next__:
            if right.val != 9:
                left = right
            right = right.__next__

        if right.val != 9:
            right.val += 1
        else:
            left.val += 1
            right = left.__next__
            while right:
                right.val = 0
                right = right.__next__

        return dummy if dummy.val else dummy.__next__


",n
"class Solution2(object):
    def plusOne(self, head):
        def reverseList(head):
            dummy = ListNode(0)
            curr = head
            while curr:
                dummy.next, curr.next, curr = curr, dummy.next, curr.next
            return dummy.__next__

        rev_head = reverseList(head)
        curr, carry = rev_head, 1
        while curr and carry:
            curr.val += carry
            carry = curr.val / 10
            curr.val %= 10
            if carry and curr.__next__ is None:
                curr.next = ListNode(0)
            curr = curr.__next__

        return reverseList(rev_head)

",n
"

class Solution(object):
    def maxScore(self, nums):
        nums.sort(reverse=True)
        curr = 0
        for i, x in enumerate(nums):
            curr += x
            if curr <= 0:
                return i
        return len(nums)
",nlogn
"

class Solution(object):
    def minimumHealth(self, damage, armor):
        return sum(damage)-min(max(damage), armor)+1
",n
"
class Solution(object):
    def minimumMoves(self, arr):
        dp = [[0 for _ in range(len(arr)+1)] for _ in range(len(arr)+1)]
        for l in range(1, len(arr)+1):
            for i in range(len(arr)-l+1):
                j = i+l-1
                if l == 1:
                    dp[i][j] = 1
                else:
                    dp[i][j] = 1+dp[i+1][j]
                    if arr[i] == arr[i+1]:
                        dp[i][j] = min(dp[i][j], 1+dp[i+2][j])
                    for k in range(i+2, j+1):
                        if arr[i] == arr[k]:
                            dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k+1][j])
        return dp[0][len(arr)-1]
",n^3
"
import heapq



class Solution(object):
    def minTimeToReach(self, moveTime):
        def dijkstra(start, target):
            DIRECTIONS = [(1, 0), (0, 1), (-1, 0), (0, -1)]
            dist = [[float(""inf"")]*len(moveTime[0]) for _ in range(len(moveTime))]
            dist[start[0]][start[1]] = 0
            min_heap = [(dist[start[0]][start[1]], start[0], start[1])]
            while min_heap:
                curr, i, j = heapq.heappop(min_heap)
                if curr != dist[i][j]:
                    continue
                if (i, j) == target:
                    break
                for di, dj in DIRECTIONS:
                    ni, nj = i+di, j+dj
                    c = 1
                    if not (0 <= ni < len(moveTime) and 0 <= nj < len(moveTime[0]) and dist[ni][nj] > max(moveTime[ni][nj], curr)+c):
                        continue
                    dist[ni][nj] = max(moveTime[ni][nj], curr)+c
                    heapq.heappush(min_heap, (dist[ni][nj], ni, nj))
            return dist[target[0]][target[1]]
    
        return dijkstra((0, 0), (len(moveTime)-1, len(moveTime[0])-1))
",n * m * logn(n * m)
"
import bisect



def linear_sieve_of_eratosthenes(n):
    primes = []
    spf = [-1]*(n+1) 
    for i in range(2, n+1):
        if spf[i] == -1:
            spf[i] = i
            primes.append(i)
        for p in primes:
            if i*p > n or p > spf[i]:
                break
            spf[i*p] = p
    return primes 


MAX_N = 10**3
PRIMES = linear_sieve_of_eratosthenes(MAX_N-1)  
class Solution(object):
    def primeSubOperation(self, nums):
        for i in range(len(nums)):
            j = bisect.bisect_left(PRIMES, nums[i]-nums[i-1] if i-1 >= 0 else nums[i])
            if j-1 >= 0:
                nums[i] -= PRIMES[j-1]
            if i-1 >= 0 and nums[i-1] >=nums[i]:
                return False
        return True
",p + nlogp
"
def read4(buf):
    global file_content
    i = 0
    while i < len(file_content) and i < 4:
        buf[i] = file_content[i]
        i += 1

    if len(file_content) > 4:
        file_content = file_content[4:]
    else:
        file_content = """"
    return i

class Solution(object):
    def read(self, buf, n):
        read_bytes = 0
        buffer = [''] * 4
        for i in range((n+4-1)//4):
            size = min(read4(buffer), n-read_bytes)
            buf[read_bytes:read_bytes+size] = buffer[:size]
            read_bytes += size
        return read_bytes
",n
"

class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def sortLinkedList(self, head):
        tail, curr, head.next = head, head.next, None
        while curr:
            if curr.val > 0:
                curr.next, tail.next, tail, curr = None, curr, curr, curr.next
            else:
                curr.next, head, curr = head, curr, curr.next
        return head
",n
"
import collections



class Solution(object):
    def numberOfSubsequences(self, nums):
        cnt = collections.defaultdict(int)
        result = 0
        for r in range(4, len(nums)-2):
            q = r-2
            for p in range((q-2)+1):
                cnt[float(nums[p])/nums[q]] += 1
            for s in range(r+2, len(nums)):
                result += cnt[float(nums[s])/nums[r]]
        return result


",n^2
"import collections



class Solution2(object):
    def numberOfSubsequences(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a
    
        cnt = collections.defaultdict(int)
        result = 0
        for r in range(4, len(nums)-2):
            q = r-2
            for p in range((q-2)+1):
                g = gcd(nums[p], nums[q])
                cnt[nums[p]//g, nums[q]//g] += 1
            for s in range(r+2, len(nums)):
                g = gcd(nums[s], nums[r])
                result += cnt[nums[s]//g, nums[r]//g]
        return result
",n^2 * logr
"
class Solution(object):
    def minCost(self, startPos, homePos, rowCosts, colCosts):
        [x0, y0], [x1, y1] = startPos, homePos
        return (sum(rowCosts[i] for i in range(min(x0, x1), max(x0, x1)+1))-rowCosts[x0]) + \
               (sum(colCosts[i] for i in range(min(y0, y1), max(y0, y1)+1))-colCosts[y0])
",m + n
"
class Solution(object):
    def convertBST(self, root):
        def convertBSTHelper(root, cur_sum):
            if not root:
                return cur_sum

            if root.right:
                cur_sum = convertBSTHelper(root.right, cur_sum)
            cur_sum += root.val
            root.val = cur_sum
            if root.left:
                cur_sum = convertBSTHelper(root.left, cur_sum)
            return cur_sum

        convertBSTHelper(root, 0)
        return root

",n
"
class Solution(object):
    def halvesAreAlike(self, s):
        vowels = set(""aeiouAEIOU"")
        cnt1 = cnt2 = 0
        left, right = 0, len(s)-1
        while left < right:
            cnt1 += s[left] in vowels
            cnt2 += s[right] in vowels
            left += 1
            right -= 1
        return cnt1 == cnt2
",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isBalanced(self, root):
        def getHeight(root):
            if root is None:
                return 0
            left_height, right_height = \
                getHeight(root.left), getHeight(root.right)
            if left_height < 0 or right_height < 0 or \
               abs(left_height - right_height) > 1:
                return -1
            return max(left_height, right_height) + 1
        return (getHeight(root) >= 0)

",n
"
class Solution(object):
    def spiralOrder(self, matrix):
        result = []
        if matrix == []:
            return result

        left, right, top, bottom = 0, len(matrix[0]) - 1, 0, len(matrix) - 1

        while left <= right and top <= bottom:
            for j in range(left, right + 1):
                result.append(matrix[top][j])
            for i in range(top + 1, bottom):
                result.append(matrix[i][right])
            for j in reversed(range(left, right + 1)):
                if top < bottom:
                    result.append(matrix[bottom][j])
            for i in reversed(range(top + 1, bottom)):
                if left < right:
                    result.append(matrix[i][left])
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1

        return result


",m * n
"
class Solution(object):
    def isLongPressedName(self, name, typed):
        i = 0
        for j in range(len(typed)):
            if i < len(name) and name[i] == typed[j]:
                i += 1
            elif j == 0 or typed[j] != typed[j-1]:
                return False
        return i == len(name)
",n
"
class Solution(object):
    def addRungs(self, rungs, dist):
        def ceil_divide(a, b):
            return (a+(b-1))//b

        result = prev = 0
        for curr in rungs:
            result += ceil_divide(curr-prev, dist)-1
            prev = curr
        return result
",n
"
class Solution(object):
    def longestUnivaluePath(self, root):
        result = [0]
        def dfs(node):
            if not node:
                return 0
            left, right = dfs(node.left), dfs(node.right)
            left = (left+1) if node.left and node.left.val == node.val else 0
            right = (right+1) if node.right and node.right.val == node.val else 0
            result[0] = max(result[0], left+right)
            return max(left, right)

        dfs(root)
        return result[0]

",n
"
import itertools



class Solution(object):
    def maximumCostSubstring(self, s, chars, vals):
        def kadane(s):
            result = curr = 0
            for c in s:
                curr = max(curr+(lookup[c] if c in lookup else ord(c)-ord('a')+1), 0)
                result = max(result, curr)
            return result

        lookup = {}
        for c, v in zip(chars, vals):
            lookup[c] = v
        return kadane(s)
",n
"

import collections


class Solution:
    def invalidTransactions(self, transactions):
        AMOUNT, MINUTES = 1000, 60
        trans = [(x[0], int(x[1]), int(x[2]), x[3]) for x in (transaction.split(',') for transaction in transactions)]
        trans.sort(key=lambda t: t[1])
        trans_indexes = collections.defaultdict(list)
        for i, t in enumerate(trans):
            trans_indexes[t[0]].append(i)
        result = []
        for name, indexes in trans_indexes.items():
            left, right = 0, 0
            for i, t_index in enumerate(indexes):
                t = trans[t_index]
                if (t[2] > AMOUNT):
                    result.append(""{},{},{},{}"".format(*t))
                    continue
                while left+1 < len(indexes) and trans[indexes[left]][1] < t[1]-MINUTES:
                    left += 1
                while right+1 < len(indexes) and trans[indexes[right+1]][1] <= t[1]+MINUTES:
                    right += 1
                for i in range(left, right+1):
                    if trans[indexes[i]][3] != t[3]:
                        result.append(""{},{},{},{}"".format(*t))
                        break
        return result
",nlogn
"
class Solution(object):
    def encode(self, s):
        def encode_substr(dp, s, i, j):
            temp = s[i:j+1]
            pos = (temp + temp).find(temp, 1) 
            if pos >= len(temp):
                return temp
            return str(len(temp)/pos) + '[' + dp[i][i + pos - 1] + ']'

        dp = [["""" for _ in range(len(s))] for _ in range(len(s))]
        for length in range(1, len(s)+1):
            for i in range(len(s)+1-length):
                j = i+length-1
                dp[i][j] = s[i:i+length]
                for k in range(i, j):
                    if len(dp[i][k]) + len(dp[k+1][j]) < len(dp[i][j]):
                        dp[i][j] = dp[i][k] + dp[k+1][j]
                encoded_string = encode_substr(dp, s, i, j)
                if len(encoded_string) < len(dp[i][j]):
                    dp[i][j] = encoded_string
        return dp[0][len(s) - 1]

",n^3
"
class Solution(object):
    def compress(self, chars):
        anchor, write = 0, 0
        for read, c in enumerate(chars):
            if read+1 == len(chars) or chars[read+1] != c:
                chars[write] = chars[anchor]
                write += 1
                if read > anchor:
                    n, left = read-anchor+1, write
                    while n > 0:
                        chars[write] = chr(n%10+ord('0'))
                        write += 1
                        n /= 10
                    right = write-1
                    while left < right:
                        chars[left], chars[right] = chars[right], chars[left]
                        left += 1
                        right -= 1
                anchor = read+1
        return write

",n
"
import collections



class Solution(object):
    def winningPlayerCount(self, n, pick):
        cnts = collections.defaultdict(lambda: collections.defaultdict(int))
        for x, y in pick:
            cnts[x][y] += 1
        return sum(i < max(cnt.values()) for i, cnt in cnts.items())
",p
"
class Solution(object):
    def countBits(self, num):
        res = [0]
        for i in range(1, num + 1):
            res.append((i & 1) + res[i >> 1])
        return res

    def countBits2(self, num):
        s = [0]
        while len(s) <= num:
            s.extend([x + 1 for x in s])
        return s[:num + 1]


",n
"
class Solution(object):
    def stoneGameII(self, piles):
        def dp(piles, lookup, i, m):
            if i+2*m >= len(piles):
                return piles[i]
            if (i, m) not in lookup:
                lookup[i, m] = piles[i] - \
                               min(dp(piles, lookup, i+x, max(m, x))
                                   for x in range(1, 2*m+1))
            return lookup[i, m]

        for i in reversed(range(len(piles)-1)):
            piles[i] += piles[i+1]
        return dp(piles, {}, 0, 1)
",n*(logn)^2
"

class Solution(object):
    def leftmostBuildingQueries(self, heights, queries):
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.build_fn = build_fn
                self.query_fn = query_fn
                self.build(0, N-1, 1)
            
            def build(self, left, right, idx):
                if left == right:
                    self.tree[idx] = self.build_fn(left)
                    return 
                mid = left + (right-left)//2
                self.build(left, mid, idx*2)
                self.build(mid+1, right, idx*2+1)
                self.tree[idx] = self.query_fn(self.tree[idx*2], self.tree[idx*2+1])

            def binary_search(self, L, R, left, right, idx, h):
                if right < L or left > R:
                    return -1
                if L <= left and right <= R:
                    if not self.tree[idx] > h:
                        return -1
                    if left == right:
                        return left
                mid = left + (right-left)//2
                i = self.binary_search(L, R, left, mid, idx*2, h)
                return i if i != -1 else self.binary_search(L, R, mid+1, right, idx*2+1, h)

        def build(i):
            return heights[i]

        result = [-1]*len(queries)
        st = SegmentTree(len(heights), build_fn=build)
        for i, (a, b) in enumerate(queries):
            if a > b:
                a, b = b, a
            if a == b or heights[a] < heights[b]:
                result[i] = b
                continue
            result[i] = st.binary_search(b+1, len(heights)-1, 0, len(heights)-1, 1, heights[a])
        return result


",n + qlogn
"import heapq



class Solution2(object):
    def leftmostBuildingQueries(self, heights, queries):
        result = [-1]*len(queries)
        qs = [[] for _ in range(len(heights))]
        for i, (a, b) in enumerate(queries):
            if a > b:
                a, b = b, a
            if a == b or heights[a] < heights[b]:
                result[i] = b
            else:
                qs[b].append((heights[a], i))
        min_heap = []
        for i, h in enumerate(heights):
            for q in qs[i]:
                heapq.heappush(min_heap, q)
            while min_heap and min_heap[0][0] < h:
                _, j = heapq.heappop(min_heap)
                result[j] = i
        return result


",n + qlogq
"
class Solution3(object):
    def leftmostBuildingQueries(self, heights, queries):
        def binary_search_right(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right

        result = [-1]*len(queries)
        qs = [[] for _ in range(len(heights))]
        for i, (a, b) in enumerate(queries):
            if a > b:
                a, b = b, a
            if a == b or heights[a] < heights[b]:
                result[i] = b
            else:
                qs[b].append((heights[a], i))
        stk = []
        for b in reversed(range(len(heights))):
            while stk and stk[-1][0] <= heights[b]:
                stk.pop()
            stk.append((heights[b], b))
            for ha, i in qs[b]:
                j = binary_search_right(0, len(stk)-1, lambda x: stk[x][0] > ha)
                if j >= 0:
                    result[i] = stk[j][1]
        return result
",n + qlogn
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, self.__next__)


class Solution(object):
    def mergeTwoLists(self, l1, l2):
        curr = dummy = ListNode(0)
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.__next__
            else:
                curr.next = l2
                l2 = l2.__next__
            curr = curr.__next__
        curr.next = l1 or l2
        return dummy.__next__


",n
"

class Solution(object):
    def maximumSum(self, nums):
        def sum_digits(x):
            result = 0
            while x:
                result += x%10
                x //= 10
            return result

        lookup = {}
        result = -1
        for x in nums:
            k = sum_digits(x)
            if k not in lookup:
                lookup[k] = x
                continue
            result = max(result, lookup[k]+x)
            if x > lookup[k]:
                lookup[k] = x
        return result
",nlogr
"
import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def minMalwareSpread(self, graph, initial):
        union_find = UnionFind(len(graph))
        for i in range(len(graph)):
            for j in range(i+1, len(graph)):
                if graph[i][j] == 1:
                    union_find.union_set(i, j)
        union_size = collections.Counter(union_find.find_set(i) for i in range(len(graph)))
        malware_count = collections.Counter(union_find.find_set(i) for i in initial)
        return min(initial, key=lambda x: [malware_count[union_find.find_set(x)] > 1,
                                           -union_size[union_find.find_set(x)],
                                           x])
",n^2
"
import collections



class Solution(object):
    def __init__(self, capacity):
        self.cache = collections.OrderedDict()
        self.capacity = capacity

    def get(self, key):
        if key not in self.cache:
            return -1
        val = self.cache[key]
        self.__update(key, val)
        return val

    def put(self, key, val):
        if key not in self.cache and len(self.cache) == self.capacity:
            self.cache.popitem(last=False)
        self.__update(key, val)
    
    def __update(self, key, val):
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = val


",1
"

class ListNode(object):
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.next = None
        self.prev = None

class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 

class Solution2(object):

    def __init__(self, capacity):
        self.list = LinkedList()
        self.dict = {}
        self.capacity = capacity

    def get(self, key):
        if key not in self.dict:
            return -1
        val = self.dict[key].val
        self.__update(key, val)
        return val

    def put(self, key, val):
        if key not in self.dict and len(self.dict) == self.capacity:
            del self.dict[self.list.head.key]
            self.list.delete(self.list.head)
        self.__update(key, val)

    def __update(self, key, val):
        if key in self.dict:
            self.list.delete(self.dict[key])
        node = ListNode(key, val)
        self.list.insert(node)
        self.dict[key] = node
",1
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maxProduct(self, root):
        MOD = 10**9 + 7
        def dfs(root, total, result):
            if not root:
                return 0
            subtotal = dfs(root.left, total, result)+dfs(root.right, total, result)+root.val
            result[0] = max(result[0], subtotal*(total-subtotal) )
            return subtotal

        result = [0]
        dfs(root, dfs(root, 0, result), result)
        return result[0] % MOD
",n
"

class Solution(object):
    def betterCompression(self, compressed):
        cnt = [0]*26
        x, curr = -1, 0
        for i in range(len(compressed)):
            if not compressed[i].isdigit():
                x = ord(compressed[i])-ord('a')
                continue
            curr = curr*10+int(compressed[i])
            if i+1 == len(compressed) or not compressed[i+1].isdigit():
                cnt[x] += curr
                curr = 0
        return """".join(""%s%s"" % (chr(ord('a')+i), x) for i, x in enumerate(cnt) if x)
",n + 26
"
import collections



class Solution(object):
    def countOfArrays(self, n, m, k):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def nHr(n, k):
            return nCr(n+k-1, k)

        lookup = collections.defaultdict(list)
        def pow(a, b):
            while len(lookup[a]) <= b:
                lookup[a].append((lookup[a][-1]*a)%MOD if lookup[a] else 1)
            return lookup[a][b]

        MOD = 10**9+7
        even, odd = m//2, (m+1)//2
        result = 0
        if k == 0:
            result = (result+pow(odd, n))%MOD
        for x in range(1, (n+1-k)//2+1): 
            result = (result+(nHr(x, (k+x)-x)*nHr(x+1, (n-(k+x))-((x+1)-2))*pow(even, k+x)*pow(odd, n-(k+x))%MOD))%MOD
        return result


",n
"
class Solution2(object):
    def countOfArrays(self, n, m, k):
        MOD = 10**9+7
        even, odd = m//2, (m+1)//2
        dp = [[0]*(k+1) for _ in range(2)]
        dp[0][0], dp[1][0] = even, odd
        for _ in range(n-1):
            for i in reversed(range(k+1)):
                dp[0][i], dp[1][i] = (((dp[0][i-1] if i-1 >= 0 else 0)+dp[1][i])*even)%MOD, ((dp[0][i]+dp[1][i])*odd)%MOD
        return (dp[0][k]+dp[1][k])%MOD
",n * k
"

class Solution(object):
    def largestTriangleArea(self, points):
        result = 0
        for i in range(len(points)-2):
            for j in range(i+1, len(points)-1):
                for k in range(j+1, len(points)):
                    result = max(result,
                                 0.5 * abs(points[i][0] * points[j][1] +
                                           points[j][0] * points[k][1] +
                                           points[k][0] * points[i][1] -
                                           points[j][0] * points[i][1] -
                                           points[k][0] * points[j][1] -
                                           points[i][0] * points[k][1]))
        return result

",n^3
"

class Solution(object):
    def smallestNumber(self, n, t):
        def check(x):
            result = 1
            while x:
                result = (result*(x%10))%t
                x //= 10
            return result == 0
    
        while not check(n):
            n += 1
        return n
",logn
"
class Solution(object):
    def validTicTacToe(self, board):
        def win(board, player):
            for i in range(3):
                if all(board[i][j] == player for j in range(3)):
                    return True
                if all(board[j][i] == player for j in range(3)):
                    return True

            return (player == board[1][1] == board[0][0] == board[2][2] or \
                    player == board[1][1] == board[0][2] == board[2][0])

        FIRST, SECOND = ('X', 'O')
        x_count = sum(row.count(FIRST) for row in board)
        o_count = sum(row.count(SECOND) for row in board)
        if o_count not in {x_count-1, x_count}: return False
        if win(board, FIRST) and x_count-1 != o_count: return False
        if win(board, SECOND) and x_count != o_count: return False

        return True

",1
"

import collections


class Solution(object):
    def numFriendRequests(self, ages):
        def request(a, b):
            return 0.5*a+7 < b <= a

        c = collections.Counter(ages)
        return sum(int(request(a, b)) * c[a]*(c[b]-int(a == b))
                   for a in c
                   for b in c)

",a^2 + n
"
class Solution(object):
    def nearestValidPoint(self, x, y, points):
        smallest, idx = float(""inf""), -1
        for i, (r, c) in enumerate(points):
            dx, dy = x-r, y-c
            if dx*dy == 0 and abs(dx)+abs(dy) < smallest:
                smallest = abs(dx)+abs(dy)
                idx = i
        return idx
",n
"
class Solution(object):
    def movesToMakeZigzag(self, nums):
        result = [0, 0]
        for i in range(len(nums)):
            left = nums[i-1] if i-1 >= 0 else float(""inf"")
            right = nums[i+1] if i+1 < len(nums) else float(""inf"")
            result[i%2] += max(nums[i] - min(left, right) + 1, 0)
        return min(result)
",n
"
class TrieNode(object):
    def __init__(self):
        self.indices = []
        self.children = [None] * 26

    def insert(self, words, i):
        cur = self
        for c in words[i]:
            if not cur.children[ord(c)-ord('a')]:
                cur.children[ord(c)-ord('a')] = TrieNode()
            cur = cur.children[ord(c)-ord('a')]
            cur.indices.append(i)


class Solution(object):
    def wordSquares(self, words):
        result = []

        trie = TrieNode()
        for i in range(len(words)):
            trie.insert(words, i)

        curr = []
        for s in words:
            curr.append(s)
            self.wordSquaresHelper(words, trie, curr, result)
            curr.pop()

        return result

    def wordSquaresHelper(self, words, trie, curr, result):
        if len(curr) >= len(words[0]):
            return result.append(list(curr))

        node = trie
        for s in curr:
            node = node.children[ord(s[len(curr)]) - ord('a')]
            if not node:
                return

        for i in node.indices:
            curr.append(words[i])
            self.wordSquaresHelper(words, trie, curr, result)
            curr.pop()

",n^2 * n!
"
class Solution(object):
    def getSumAbsoluteDifferences(self, nums):
        prefix, suffix = 0, sum(nums)
        result = []
        for i, num in enumerate(nums):
            suffix -= num
            result.append((i*num-prefix) + (suffix-((len(nums)-1)-i)*num))
            prefix += num
        return result
",n
"
class Solution(object):
    def isBipartite(self, graph):
        color = {}
        for node in range(len(graph)):
            if node in color:
                continue
            stack = [node]
            color[node] = 0
            while stack:
                curr = stack.pop()
                for neighbor in graph[curr]:
                    if neighbor not in color:
                        stack.append(neighbor)
                        color[neighbor] = color[curr] ^ 1
                    elif color[neighbor] == color[curr]:
                        return False
        return True

",|V| + |E|
"

class Solution(object):
    def minNumberOfSeconds(self, mountainHeight, workerTimes):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(target):
            return sum(int((-1+(1+8*target/t)**0.5)/2) for t in workerTimes) >= mountainHeight
    
        mn = min(workerTimes)
        left, right = mn, mn*(mountainHeight+1)*mountainHeight//2
        return binary_search(left, right, check)


",nlogr
"import heapq



class Solution2(object):
    def minNumberOfSeconds(self, mountainHeight, workerTimes):
        min_heap = [(0+1*t, i, 1) for i, t in enumerate(workerTimes)]
        heapq.heapify(min_heap)
        for _ in range(mountainHeight):
            result, i, x = heapq.heappop(min_heap)
            heapq.heappush(min_heap, (result+(x+1)*workerTimes[i], i, x+1))
        return result
",hlogn
"
class Solution(object):
    def findMaximumXOR(self, nums):
        class Trie(object):
            def __init__(self, bit_length):
                self.__nodes = []
                self.__new_node()
                self.__bit_length = bit_length
            
            def __new_node(self):
                self.__nodes.append([-1]*2)
                return len(self.__nodes)-1

            def insert(self, num):
                curr = 0
                for i in reversed(range(self.__bit_length)):
                    x = num>>i
                    if self.__nodes[curr][x&1] == -1:
                        self.__nodes[curr][x&1] = self.__new_node()
                    curr = self.__nodes[curr][x&1]
                        
            def query(self, num):
                result = curr = 0
                for i in reversed(range(self.__bit_length)):
                    result <<= 1
                    x = num>>i
                    if self.__nodes[curr][1^(x&1)] != -1:
                        curr = self.__nodes[curr][1^(x&1)]
                        result |= 1
                    else:
                        curr = self.__nodes[curr][x&1]
                return result

        trie = Trie(max(nums).bit_length())
        result = 0
        for num in nums:
            trie.insert(num)
            result = max(result, trie.query(num))
        return result


",nlogr
"class Solution2(object):
    def findMaximumXOR(self, nums):
        result = 0
        for i in reversed(range(max(nums).bit_length())):
            result <<= 1
            prefixes = set()
            for n in nums:
                prefixes.add(n >> i)
            for p in prefixes:
                if (result | 1) ^ p in prefixes:
                    result |= 1
                    break
        return result
",nlogr
"
import collections


class Solution(object):
    def minChanges(self, nums, k):
        def one_are_not_from_nums(nums, cnts):
            mxs = [cnts[i].most_common(1)[0][1] for i in range(k)]
            return len(nums) - (sum(mxs)-min(mxs))

        def all_are_from_nums(nums, cnts):
            dp = {0:0}
            for cnt in cnts:
                new_dp = collections.defaultdict(int)
                for x in dp.keys():
                    for y in cnt.keys():
                        new_dp[x^y] = max(new_dp[x^y], dp[x]+cnt[y])
                dp = new_dp
            return len(nums)-dp[0]
          
        cnts = [collections.Counter(nums[j] for j in range(i, len(nums), k)) for i in range(k)]
        return min(one_are_not_from_nums(nums, cnts), all_are_from_nums(nums, cnts))
",n + k * m
"

class Solution(object):
    def countElements(self, nums):
        mn = min(nums)
        mx = max(nums)
        return sum(mn < x < mx for x in nums)
",n
"
import collections
import string


class Solution(object):
    def longestWord(self, words):
        def iter_dfs(words, node):
            result = -1
            stk = [node]
            while stk:
                node = stk.pop()
                if result == -1 or len(words[node[""_end""]]) > len(words[result]):
                    result = node[""_end""]
                for c in reversed(string.ascii_lowercase):
                    if c not in node or ""_end"" not in node[c]:
                        continue
                    stk.append(node[c])
            return result       
    
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        trie[""_end""] = -1
        for i, word in enumerate(words):
            reduce(dict.__getitem__, word, trie)[""_end""] = i
        result = iter_dfs(words, trie)
        return words[result] if result != -1 else """" 


",n
"import collections
import string


class Solution2(object):
    def longestWord(self, words):
        def dfs(words, node, result):
            if result[0] == -1 or len(words[node[""_end""]]) > len(words[result[0]]):
                result[0] = node[""_end""]
            for c in string.ascii_lowercase:
                if c not in node or ""_end"" not in node[c]:
                    continue
                dfs(words, node[c], result)
    
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        trie[""_end""] = -1
        for i, word in enumerate(words):
            reduce(dict.__getitem__, word, trie)[""_end""] = i
        result = [-1]
        dfs(words, trie, result)
        return words[result[0]] if result[0] != -1 else """"
",n
"
class Solution(object):
    def shiftGrid(self, grid, k):
        def rotate(grids, k):
            def reverse(grid, start, end):
                while start < end:
                    start_r, start_c = divmod(start, len(grid[0]))
                    end_r, end_c = divmod(end-1, len(grid[0]))
                    grid[start_r][start_c], grid[end_r][end_c] = grid[end_r][end_c], grid[start_r][start_c]
                    start += 1
                    end -= 1

            k %= len(grid)*len(grid[0])
            reverse(grid, 0, len(grid)*len(grid[0]))
            reverse(grid, 0, k)
            reverse(grid, k, len(grid)*len(grid[0]))

        rotate(grid, k)
        return grid
",m * n
"

class Solution(object):
    def stringSequence(self, target):
        return [target[:i]+chr(x) for i in range(len(target)) for x in range(ord('a'), ord(target[i])+1)]
",n^2
"

class Solution(object):
    def minOperations(self, nums, k):
        mn = min(nums)
        return len(set(nums))-int(mn == k) if mn >= k else -1
",n
"

class Solution(object):
    def minOperations(self, nums, numsDivide):
        def gcd(a, b): 
            while b:
                a, b = b, a%b
            return a

        g = reduce(gcd, numsDivide)
        mn = float(""inf"")
        for x in nums:
            if g%x == 0:
                mn = min(mn, x)
        return sum(x < mn for x in nums) if mn != float(""inf"") else -1
",n + m + logr
"
class Solution(object):
    def largestBSTSubtree(self, root):
        if root is None:
            return 0

        max_size = [1]
        def largestBSTSubtreeHelper(root):
            if root.left is None and root.right is None:
                return 1, root.val, root.val

            left_size, left_min, left_max = 0, root.val, root.val
            if root.left is not None:
                left_size, left_min, left_max = largestBSTSubtreeHelper(root.left)

            right_size, right_min, right_max = 0, root.val, root.val
            if root.right is not None:
                right_size, right_min, right_max = largestBSTSubtreeHelper(root.right)

            size = 0
            if (root.left is None or left_size > 0) and \
               (root.right is None or right_size > 0) and \
               left_max <= root.val <= right_min:
                size = 1 + left_size + right_size
                max_size[0] = max(max_size[0], size)

            return size, left_min, right_max

        largestBSTSubtreeHelper(root)
        return max_size[0]

",n
"

class Solution(object):
    def maxSelectedElements(self, nums):
        nums.sort()
        result = 1
        dp = [1]*2 
        for i in range(1, len(nums)):
            if nums[i] == nums[i-1]:
                dp[1] = dp[0]+1
            elif nums[i] == nums[i-1]+1:
                dp[0] += 1
                dp[1] += 1
            elif nums[i] == nums[i-1]+2:
                dp[0] = dp[1]+1
                dp[1] = 1
            else:
                dp[0] = dp[1] = 1
            result = max(result, dp[0], dp[1])
        return result


",nlogn
"import collections



class Solution2(object):
    def maxSelectedElements(self, nums):
        nums.sort()
        dp = collections.defaultdict(int)
        dp[nums[0]] = dp[nums[0]+1] = 1
        for i in range(1, len(nums)):
            if nums[i] == nums[i-1]:
                dp[nums[i]+1] = dp[nums[i]]+1
            elif nums[i] == nums[i-1]+1:
                dp[nums[i]+1] = dp[nums[i]]+1
                dp[nums[i]] = dp[nums[i]-1]+1
            elif nums[i] == nums[i-1]+2:
                dp[nums[i]] = dp[nums[i]-1]+1
                dp[nums[i]+1] = 1
            else:
                dp[nums[i]] = dp[nums[i]+1] = 1
        return max(dp.values())


",nlogn
"import collections



class Solution3(object):
    def maxSelectedElements(self, nums):
        nums.sort()
        dp = collections.defaultdict(int)
        for x in nums:
            dp[x+1] = dp[x]+1
            dp[x] = dp[x-1]+1
        return max(dp.values())
",nlogn
"
from random import randint, seed



class SkipNode(object):
    def __init__(self, level=0, val=None):
        self.val = val
        self.nexts = [None]*level
        self.prevs = [None]*level

class SkipList(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2 
    MAX_LEVEL = 32 

    def __init__(self, end=[float(""inf""), float(""inf""), float(""inf"")], can_duplicated=True):
        seed(0)
        self.__head = SkipNode()
        self.__len = 0
        self.__can_duplicated = can_duplicated
        self.add(end)
        self.__end = self.find(end)

    def begin(self):
        return self.__head.nexts[0]
    
    def end(self):
        return self.__end

    def lower_bound(self, target, cmp=lambda x, y: x < y):
        return self.__lower_bound(target, self.__find_prev_nodes(target, cmp))

    def find(self, target):
        return self.__find(target, self.__find_prev_nodes(target))
        
    def add(self, val):
        if not self.__can_duplicated and self.find(val):
            return self.find(val), False
        node = SkipNode(self.__random_level(), val)
        if len(self.__head.nexts) < len(node.nexts): 
            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))
        prevs = self.__find_prev_nodes(val)
        for i in range(len(node.nexts)):
            node.nexts[i] = prevs[i].nexts[i]
            if prevs[i].nexts[i]:
                prevs[i].nexts[i].prevs[i] = node
            prevs[i].nexts[i] = node
            node.prevs[i] = prevs[i]
        self.__len += 1
        return node if self.__can_duplicated else (node, True)

    def remove(self, it):
        prevs = it.prevs
        curr = self.__find(it.val, prevs)
        if not curr:
            return self.__end
        self.__len -= 1   
        for i in reversed(range(len(curr.nexts))):
            prevs[i].nexts[i] = curr.nexts[i]
            if curr.nexts[i]:
                curr.nexts[i].prevs[i] = prevs[i]
            if not self.__head.nexts[i]:
                self.__head.nexts.pop()
        return curr.nexts[0]
    
    def __lower_bound(self, val, prevs):
        if prevs:
            candidate = prevs[0].nexts[0]
            if candidate:
                return candidate
        return None

    def __find(self, val, prevs):
        candidate = self.__lower_bound(val, prevs)
        if candidate and candidate.val == val:
            return candidate
        return None

    def __find_prev_nodes(self, val, cmp=lambda x, y: x < y):
        prevs = [None]*len(self.__head.nexts)
        curr = self.__head
        for i in reversed(range(len(self.__head.nexts))):
            while curr.nexts[i] and cmp(curr.nexts[i].val, val):
                curr = curr.nexts[i]
            prevs[i] = curr
        return prevs

    def __random_level(self):
        level = 1
        while randint(1, SkipList.P_DENOMINATOR) <= SkipList.P_NUMERATOR and \
              level < SkipList.MAX_LEVEL:
            level += 1
        return level
    
    def __iter__(self):
        it = self.begin()
        while it != self.end():
            yield it.val
            it = it.nexts[0]

    def __len__(self):
        return self.__len-1 

    def __str__(self):
        result = []
        for i in reversed(range(len(self.__head.nexts))):
            result.append([])
            curr = self.__head.nexts[i]
            while curr:
                result[-1].append(str(curr.val))
                curr = curr.nexts[i]
        return ""\n"".join([""->"".join(x) for x in result])



class LineContainer(object):
    def __init__(self):
        self.__skiplist = SkipList()

    def add(self, k, m):
        self.__skiplist.add([k, m, 0])
        z = self.__skiplist.find([k, m, 0])
        x = y = z
        z = z.nexts[0]
        while self.__intersect(y, z):
            z = self.__skiplist.remove(z)
        if x != self.__skiplist.begin():
            x = x.prevs[0]
            if self.__intersect(x, y):
                y = self.__skiplist.remove(y)
                self.__intersect(x, y)
        y = x
        while y != self.__skiplist.begin():
            x = x.prevs[0]
            if x.val[2] < y.val[2]:
                break
            y = self.__skiplist.remove(y)
            self.__intersect(x, y)
            y = x
    
    def query(self, x):
        it = self.__skiplist.lower_bound(x, cmp=lambda x, y: x[2] < y)
        return it.val[0]*x + it.val[1]

    def __intersect(self, x, y):
        if y == self.__skiplist.end():
            x.val[2] = float(""inf"")
            return False
        if x.val[0] == y.val[0]:
            x.val[2] = float(""inf"") if x.val[1] > y.val[1] else float(""-inf"")
        else:
            x.val[2] = (y.val[1]-x.val[1])//(x.val[0]-y.val[0])
        return x.val[2] >= y.val[2]

    def __iter__(self):
        return iter(self.__skiplist)

    def __len__(self):
        return len(self.__skiplist)

    def __str__(self):
        return str(self.__skiplist)



class Solution(object):
    def minimumCost(self, nums, cost, k):
        prefix1 = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix1[i+1] = prefix1[i]+nums[i]
        prefix2 = [0]*(len(cost)+1)
        for i in range(len(nums)):
            prefix2[i+1] = prefix2[i]+cost[i]
        dp = 0
        lc = LineContainer()
        for i in reversed(range(len(nums))):
            lc.add(prefix1[i+1], -(dp+prefix1[i+1]*prefix2[i+1]))
            dp = (-lc.query(prefix2[i]))+(k*(prefix2[-1]-prefix2[i]))
        return dp


",nlogn
"
class Solution2(object):
    def minimumCost(self, nums, cost, k):
        prefix1 = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix1[i+1] = prefix1[i]+nums[i]
        prefix2 = [0]*(len(cost)+1)
        for i in range(len(nums)):
            prefix2[i+1] = prefix2[i]+cost[i]
        dp = [float(""inf"")]*(len(nums)+1)
        dp[-1] = 0
        for i in reversed(range(len(nums))):
            for j in range(i, len(nums)):
                dp[i] = min(dp[i], prefix1[j+1]*(prefix2[j+1]-prefix2[i])+dp[j+1]+(k*(prefix2[-1]-prefix2[i])))
        return dp[0]
",n^2
"

import collections


class UnionFind(object):
    def __init__(self):
        self.set = []

    def get_id(self):
        self.set.append(len(self.set))
        return len(self.set)-1

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root != y_root:
            self.set[min(x_root, y_root)] = max(x_root, y_root)


class Solution(object):
    def accountsMerge(self, accounts):
        union_find = UnionFind()
        email_to_name = {}
        email_to_id = {}
        for account in accounts:
            name = account[0]
            for i in range(1, len(account)):
                if account[i] not in email_to_id:
                    email_to_name[account[i]] = name
                    email_to_id[account[i]] = union_find.get_id()
                union_find.union_set(email_to_id[account[1]],
                                     email_to_id[account[i]])

        result = collections.defaultdict(list)
        for email in list(email_to_name.keys()):
            result[union_find.find_set(email_to_id[email])].append(email)
        for emails in list(result.values()):
            emails.sort()
        return [[email_to_name[emails[0]]] + emails
                for emails in list(result.values())]

",nlogn
"

class Solution(object):
    def closestFair(self, n):
        digits = list(map(int, str(n)))
        result = []
        if len(digits)%2 == 0:            
            left = [0]*2
            for d in digits:
                left[d%2] += 1
            if left[0] == len(digits)//2:
                return n
            for i in reversed(range(len(digits)//2, len(digits))):
                left[digits[i]%2] -= 1
                right = [len(digits)//2-left[0], len(digits)//2-left[1]]
                if any(x < 0 for x in right):
                    continue
                d = digits[i]+1 if right[(digits[i]+1)%2]-1 >= 0 else digits[i]+2
                if d > 9:
                    continue
                right[d%2] -= 1
                result = digits[:i]+[d]+[0]*right[0]+[1]*right[1]
                break
        if not result:
            l = len(digits)//2+1
            result = [1]+[0]*l+[1]*(l-1)
        return int("""".join(map(str, result)))
",logn
"
class Solution(object):

    def __init__(self):
        self.A, self.B = [], []

    def push(self, x):
        self.A.append(x)

    def pop(self):
        self.peek()
        return self.B.pop()

    def peek(self):
        if not self.B:
            while self.A:
                self.B.append(self.A.pop())
        return self.B[-1]

    def empty(self):
        return not self.A and not self.B
",1
"
import collections


class Solution(object):
    def numberOfArithmeticSlices(self, A):
        result = 0
        dp = [collections.defaultdict(int) for i in range(len(A))]
        for i in range(1, len(A)):
            for j in range(i):
                diff = A[i]-A[j]
                dp[i][diff] += 1
                if diff in dp[j]:
                    dp[i][diff] += dp[j][diff]
                    result += dp[j][diff]
        return result

",n^2
"

class Solution(object):
    def countVisitedNodes(self, edges):
        def find_cycles(adj):
            result = [0]*len(adj)
            lookup = [0]*len(adj)
            stk = [] 
            idx = 0
            for u in range(len(adj)):
                prev = idx
                while not lookup[u]:
                    idx += 1
                    lookup[u] = idx
                    stk.append(u) 
                    u = adj[u]
                if lookup[u] > prev:
                    l = idx-lookup[u]+1
                    for _ in range(l): 
                        result[stk.pop()] = l
                while stk: 
                    result[stk[-1]] = result[adj[stk[-1]]]+1
                    stk.pop()
            return result
        
        return find_cycles(edges)
",n
"
class Solution(object):
    def longestCommonSubsequence(self, text1, text2):
        if len(text1) < len(text2):
            return self.longestCommonSubsequence(text2, text1)

        dp = [[0 for _ in range(len(text2)+1)] for _ in range(2)]
        for i in range(1, len(text1)+1):
            for j in range(1, len(text2)+1):
                dp[i%2][j] = dp[(i-1)%2][j-1]+1 if text1[i-1] == text2[j-1] \
                             else max(dp[(i-1)%2][j], dp[i%2][j-1])
        return dp[len(text1)%2][len(text2)]
",m * n
"

class Solution(object):
    def countOperationsToEmptyArray(self, nums):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        return len(idxs)+sum(len(idxs)-(i+1) for i in range(len(idxs)-1) if idxs[i] > idxs[i+1])


",nlogn
"
class Solution2(object):
    def countOperationsToEmptyArray(self, nums):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret
        
        bit = BIT(len(nums))
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x])
        result = len(nums)
        prev = -1
        for i in idxs:
            if prev == -1:
                result += i
            elif prev < i:
                result += (i-prev)-(bit.query(i)-bit.query(prev-1))
            else:
                result += ((len(nums)-1)-bit.query(len(nums)-1))-((prev-i)-(bit.query(prev)-bit.query(i-1)))
            bit.add(i, 1)
            prev = i
        return result
",nlogn
"

class Solution(object):
    def matchPlayersAndTrainers(self, players, trainers):
        players.sort()
        trainers.sort()
        result = 0
        for x in trainers:
            if players[result] > x:
                continue
            result += 1
            if result == len(players):
                break
        return result
",nlogn + mlogm
"
import collections



class Solution(object):
    def isPossibleToRearrange(self, s, t, k):
        cnt = collections.defaultdict(int)
        l = len(s)//k
        for i in range(0, len(s), l):
            cnt[s[i:i+l]] += 1
            cnt[t[i:i+l]] -= 1
        return all(v == 0 for v in cnt.values())
",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def inorderTraversal(self, root):
        result, curr = [], root
        while curr:
            if curr.left is None:
                result.append(curr.val)
                curr = curr.right
            else:
                node = curr.left
                while node.right and node.right != curr:
                    node = node.right

                if node.right is None:
                    node.right = curr
                    curr = curr.left
                else:
                    result.append(curr.val)
                    node.right = None
                    curr = curr.right

        return result


",n
"
class Solution2(object):
    def inorderTraversal(self, root):
        result, stack = [], [(root, False)]
        while stack:
            root, is_visited = stack.pop()
            if root is None:
                continue
            if is_visited:
                result.append(root.val)
            else:
                stack.append((root.right, False))
                stack.append((root, True))
                stack.append((root.left, False))
        return result

",n
"
import collections



class Solution(object):
    def minimumCost(self, start, target, specialRoads):
        start, target = tuple(start), tuple(target)
        adj = collections.defaultdict(list, {target:[]})
        for x1, y1, x2, y2, c in specialRoads:
            adj[x1, y1].append((x2, y2, c))
        dist = {start:0}
        lookup = set()
        while len(lookup) != len(dist):
            d, x1, y1 = min((dist[x1, y1], x1, y1) for x1, y1 in dist.keys() if (x1, y1) not in lookup)
            lookup.add((x1, y1))
            if (x1, y1) == target:
                return d
            for x2, y2, c in adj[x1, y1]:
                if not ((x2, y2) not in dist or dist[x2, y2] > d+c):
                    continue
                dist[x2, y2] = d+c
            for x2, y2 in adj.keys():
                if not ((x2, y2) not in dist or dist[x2, y2] > d+abs(x2-x1)+abs(y2-y1)):
                    continue
                dist[x2, y2] = d+abs(x2-x1)+abs(y2-y1)


",n^2
"import collections
import heapq

class Solution2(object):
    def minimumCost(self, start, target, specialRoads):
        start, target = tuple(start), tuple(target)
        adj = collections.defaultdict(list, {target:[]})
        for x1, y1, x2, y2, c in specialRoads:
            adj[x1, y1].append((x2, y2, c))
        min_heap = [(0, start)]
        dist = {start:0}
        while min_heap:
            d, (x1, y1) = heapq.heappop(min_heap)
            if d > dist[x1, y1]:
                continue
            if (x1, y1) == target:
                return d
            for x2, y2, c in adj[x1, y1]:
                if not ((x2, y2) not in dist or dist[x2, y2] > d+c):
                    continue
                dist[x2, y2] = d+c
                heapq.heappush(min_heap, (dist[x2, y2], (x2, y2)))
            for x2, y2 in adj.keys():
                if not ((x2, y2) not in dist or dist[x2, y2] > d+abs(x2-x1)+abs(y2-y1)):
                    continue
                dist[x2, y2] = d+abs(x2-x1)+abs(y2-y1)
                heapq.heappush(min_heap, (dist[x2, y2], (x2, y2)))
        return -1
",n^2 * logn
"
import itertools


class Solution(object):
    def gridGame(self, grid):
        result = float(""inf"")
        left, right = 0, sum(grid[0])
        for a, b in zip(grid[0], grid[1]):
            right -= a
            result = min(result, max(left, right))
            left += b
        return result
",n
"
class Solution(object):
    def binaryTreePaths(self, root):
        result, path = [], []
        self.binaryTreePathsRecu(root, path, result)
        return result

    def binaryTreePathsRecu(self, node, path, result):
        if node is None:
            return

        if node.left is node.right is None:
            ans = """"
            for n in path:
                ans += str(n.val) + ""->""
            result.append(ans + str(node.val))

        if node.left:
            path.append(node)
            self.binaryTreePathsRecu(node.left, path, result)
            path.pop()

        if node.right:
            path.append(node)
            self.binaryTreePathsRecu(node.right, path, result)
            path.pop()

",n * h
"

class Solution(object):
    def maximumBags(self, capacity, rocks, additionalRocks):
        for i in range(len(capacity)):
            capacity[i] -= rocks[i]
        capacity.sort()
        for i, c in enumerate(capacity):
            if c > additionalRocks:
                return i
            additionalRocks -= c
        return len(capacity)
",nlogn
"
import collections


class Solution(object):
    def deleteTreeNodes(self, nodes, parent, value):
        def dfs(value, children, x):
            total, count = value[x], 1
            for y in children[x]:
                t, c = dfs(value, children, y)
                total += t
                count += c if t else 0
            return total, count if total else 0

        children = collections.defaultdict(list)
        for i, p in enumerate(parent):
            if i:
                children[p].append(i)
        return dfs(value, children, 0)[1]


",n
"class Solution2(object):
    def deleteTreeNodes(self, nodes, parent, value):
        result = [1]*nodes
        for i in reversed(range(1, nodes)):
            value[parent[i]] += value[i]
            result[parent[i]] += result[i] if value[i] else 0
        return result[0]
",n
"
import collections



class Solution(object):
    def maxSum(self, nums, m, k):
        lookup = collections.Counter()
        result = curr = left = 0
        for right in range(len(nums)):
            curr += nums[right]
            lookup[nums[right]] += 1
            if right-left+1 == k+1:
                lookup[nums[left]] -= 1
                if lookup[nums[left]] == 0:
                    del lookup[nums[left]]
                curr -= nums[left]
                left += 1
            if right-left+1 == k and len(lookup) >= m:
                result = max(result, curr)
        return result
",n
"
class Solution(object):
    def closestValue(self, root, target):
        gap = float(""inf"")
        closest = float(""inf"")
        while root:
            if abs(root.val - target) < gap:
                gap = abs(root.val - target)
                closest = root.val
            if target == root.val:
                break
            elif target < root.val:
                root = root.left
            else:
                root = root.right
        return closest
",h
"
class Solution(object):
    def smallestDivisor(self, nums, threshold):
        def check(A, d, threshold):
            return sum((i-1)//d+1 for i in nums) <= threshold

        left, right = 1, max(nums)
        while left <= right:
            mid = left + (right-left)//2
            if check(nums, mid, threshold):
                right = mid-1
            else:
                left = mid+1
        return left
",logn
"
class Solution(object):
    def maxMatrixSum(self, matrix):
        abs_total = sum(abs(x) for row in matrix for x in row)
        min_abs_val = min(abs(x) for row in matrix for x in row)
        neg_cnt = sum(x < 0 for row in matrix for x in row)
        return abs_total if neg_cnt%2 == 0 else abs_total - 2*min_abs_val
",n^2
"
import math


class Solution(object):
    def smallestGoodBase(self, n):
        num = int(n)
        max_len = int(math.log(num,2))
        for l in range(max_len, 1, -1):
            b = int(num ** (l**-1))
            if (b**(l+1)-1) // (b-1) == num:
                return str(b)
        return str(num-1)

",logn * log(logn)
"

class Solution(object):
    def peopleAwareOfSecret(self, n, delay, forget):
        MOD = 10**9+7
        dp = [0]*forget
        dp[0] = 1
        for i in range(1, n):
            dp[i%forget] = ((dp[(i-1)%forget] if i-1 else 0)-dp[i%forget]+dp[(i-delay)%forget]) % MOD
        return sum(dp)%MOD
",n
"

class Solution(object):
    def replaceNonCoprimes(self, nums):
        def gcd(a, b): 
            while b:
                a, b = b, a%b
            return a

        result = []
        for x in nums:
            while True:
                g = gcd(result[-1] if result else 1, x)
                if g == 1:
                    break
                x *= result.pop()//g
            result.append(x)
        return result
",nlogm
"

class Solution(object):
    def answerString(self, word, numFriends):
        if numFriends == 1:
            return word
        idx = l = 0
        for i in range(1, len(word)):
            if word[i] == word[idx+l]:
                l += 1
            elif word[i] < word[idx+l]:
                l = 0
            elif word[i] > word[idx+l]:
                if word[i-l] >= word[i]:
                    idx = i-l
                else:
                    idx = i
                l = 0
        return word[idx:len(word)-max((numFriends-1)-idx, 0)]
",n
"
import collections



class Solution(object):
    def maximumNumberOfStringPairs(self, words):
        result = 0
        cnt = collections.Counter()
        for w in words:
            result += cnt[w[::-1]]
            cnt[w] += 1
        return result
",n
"
class Solution(object):
    def countServers(self, grid):
        rows, cols = [0]*len(grid), [0]*len(grid[0])
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]:
                    rows[i] += 1
                    cols[j] += 1
        result = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] and (rows[i] > 1 or cols[j] > 1):
                    result += 1
        return result

",m * n
"
import collections



class Solution(object):
    def maxStudentsOnBench(self, students):
        lookup = collections.defaultdict(set)
        for s, b in students:
            lookup[b].add(s)
        return max(len(x) for x in lookup.values()) if lookup else 0
",n
"
import collections


class Solution(object):
    def splitPainting(self, segments):
        counts = collections.defaultdict(int)
        for s, e, c in segments:
            counts[s] += c
            counts[e] -= c
        points = sorted(x for x in counts.items())

        result = []
        overlap = prev = 0
        for curr, cnt in points:
            if overlap:
                result.append([prev, curr, overlap])
            overlap += cnt
            prev = curr
        return result
",nlogn
"
class Solution(object):
    def dominantIndex(self, nums):
        m = max(nums)
        if all(m >= 2*x for x in nums if x != m):
            return nums.index(m)
        return -1

",n
"
import itertools


class Solution(object):
    def buddyStrings(self, A, B):
        if len(A) != len(B):
            return False
        diff = []
        for a, b in zip(A, B):
            if a != b:
                diff.append((a, b))
                if len(diff) > 2:
                    return False
        return (not diff and len(set(A)) < len(A)) or \
               (len(diff) == 2 and diff[0] == diff[1][::-1])

",n
"
from random import randint
from collections import defaultdict

class Solution(object):

    def __init__(self):
        self.__list = []
        self.__used = defaultdict(list)


    def insert(self, val):
        has = val in self.__used

        self.__list += (val, len(self.__used[val])),
        self.__used[val] += len(self.__list)-1,

        return not has


    def remove(self, val):
        if val not in self.__used:
            return False

        self.__used[self.__list[-1][0]][self.__list[-1][1]] = self.__used[val][-1]
        self.__list[self.__used[val][-1]], self.__list[-1] = self.__list[-1], self.__list[self.__used[val][-1]]

        self.__used[val].pop()
        if not self.__used[val]:
            self.__used.pop(val)
        self.__list.pop()

        return True

    def getRandom(self):
        return self.__list[randint(0, len(self.__list)-1)][0]
",1
"

class Solution(object):
    def maximumPoints(self, enemyEnergies, currentEnergy):
        mn = min(enemyEnergies)
        return ((currentEnergy-mn)+sum(enemyEnergies))//mn if currentEnergy >= mn else 0
",n
"
import bisect



class Solution(object):
    def longestObstacleCourseAtEachPosition(self, obstacles):
        result, stk = [], []
        for x in obstacles:
            i = bisect.bisect_right(stk, x)
            result.append(i+1)
            if i == len(stk):
                stk.append(0)
            stk[i] = x
        return result
class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y), 
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h) 
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))


",nlogn
"
class Solution2_TLE(object):
    def longestObstacleCourseAtEachPosition(self, obstacles):
        sorted_obstacles = sorted(set(obstacles))
        lookup = {x:i for i, x in enumerate(sorted_obstacles)}
        segment_tree = SegmentTree(len(lookup))
        result = []
        for x in obstacles:
            cnt = segment_tree.query(0, lookup[x])+1
            result.append(cnt)
            segment_tree.update(lookup[x], lookup[x], cnt)
        return result
",nlogn
"
class Solution(object):
    def getHappyString(self, n, k):
        base = 2**(n-1)
        if k > 3*base:
            return """"
        result = [chr(ord('a')+(k-1)//base)]
        while base > 1:
            k -= (k-1)//base*base
            base //= 2
            result.append(('a' if result[-1] != 'a' else 'b') if (k-1)//base == 0 else
                          ('c' if result[-1] != 'c' else 'b'))
        return """".join(result)
",n
"

class Solution(object):
    def mostProfitablePath(self, edges, bob, amount):
        def iter_dfs():
            lookup = [[float(""-inf""), float(""inf"")] for _ in range(len(adj))]
            stk = [(1, (0, -1, 0))]
            while stk:
                step, (u, p, ah) = stk.pop()
                if step == 1:
                    stk.append((2, (u, p, ah)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, (v, u, ah+1)))
                elif step == 2:
                    if len(adj[u])+(u == 0) == 1:
                        lookup[u][0] = 0
                    if u == bob:
                        lookup[u][1] = 0
                    for v in adj[u]:
                        if v == p:
                            continue
                        lookup[u][0] = max(lookup[u][0], lookup[v][0])
                        lookup[u][1] = min(lookup[u][1], lookup[v][1])
                    if ah == lookup[u][1]:
                        lookup[u][0] += amount[u]//2
                    elif ah < lookup[u][1]:
                        lookup[u][0] += amount[u]
                    lookup[u][1] += 1
            return lookup[0][0]

        adj = [[] for _ in range(len(edges)+1)]
        lookup = [False]*len(adj)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()


",n
"
class Solution2(object):
    def mostProfitablePath(self, edges, bob, amount):
        def dfs(u, ah):
            lookup[u] = True
            result = 0 if len(adj[u])+(u == 0) == 1 else float(""-inf"")
            bh = 0 if u == bob else float(""inf"")
            for v in adj[u]:
                if lookup[v]:
                    continue
                r, h = dfs(v, ah+1)
                result = max(result, r)
                bh = min(bh, h)
            if ah == bh:
                result += amount[u]//2
            elif ah < bh:
                result += amount[u]
            return result, bh+1

        adj = [[] for _ in range(len(edges)+1)]
        lookup = [False]*len(adj)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return dfs(0, 0)[0]
",n
"
class Solution(object):
    def dieSimulator(self, n, rollMax):
        MOD = 10**9+7
        def sum_mod(array):
            return reduce(lambda x, y: (x+y)%MOD, array)

        dp = [[1] + [0]*(rollMax[i]-1) for i in range(6)] 
        for _ in range(n-1):
            new_dp = [[0]*rollMax[i] for i in range(6)]
            for i in range(6):
                for k in range(rollMax[i]):
                    for j in range(6):
                        if i == j:
                            if k < rollMax[i]-1: 
                                new_dp[j][k+1] = (new_dp[j][k+1]+dp[i][k])%MOD
                        else:
                            new_dp[j][0] = (new_dp[j][0]+dp[i][k])%MOD
            dp = new_dp
        return sum_mod(sum_mod(row) for row in dp)
",m * n
"

class Solution(object):
    def minStartingIndex(self, s, pattern):
        K = 1
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z
        
        z1 = z_function(pattern+s)
        z2 = z_function(pattern[::-1]+s[::-1])
        return next((i for i in range(len(s)-len(pattern)+1) if z1[len(pattern)+i]+K+z2[len(s)-i] >= len(pattern)), -1)
",n + m
"

class Solution(object):
    def minimumTimeToInitialState(self, word, k):
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        z = z_function(word)
        for i in range(k, len(word), k):
            if z[i] == len(word)-i:
                return i//k
        return ceil_divide(len(word), k)
",n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def flipMatchVoyage(self, root, voyage):
        def dfs(root, voyage, i, result):
            if not root:
                return True
            if root.val != voyage[i[0]]:
                return False
            i[0] += 1
            if root.left and root.left.val != voyage[i[0]]:
                result.append(root.val)
                return dfs(root.right, voyage, i, result) and \
                       dfs(root.left, voyage, i, result)
            return dfs(root.left, voyage, i, result) and \
                   dfs(root.right, voyage, i, result)
        
        result = []
        return result if dfs(root, voyage, [0], result) else [-1]
",n
"

class Solution(object):
    def distinctDifferenceArray(self, nums):
        result = [0]*len(nums)
        lookup = set()
        for i in range(len(nums)):
            lookup.add(nums[i])
            result[i] = len(lookup)
        lookup.clear()
        for i in reversed(range(len(nums))):
            result[i] -= len(lookup)
            lookup.add(nums[i])
        return result
",n
"
class Solution(object):
    def bitwiseComplement(self, N):
        mask = 1
        while N > mask:
            mask = mask*2+1
        return mask-N
",logn
"

class Solution(object):
    def maxSubarrays(self, n, conflictingPairs):
        right = [[] for _ in range(n)]
        for l, r in conflictingPairs:
            l, r = l-1, r-1
            if l > r:
                l, r = r, l
            right[r].append(l)
        result = 0
        top2 = [-1]*2
        cnt = [0]*n
        for r in range(n):
            for l in right[r]:
                for i in range(len(top2)):
                    if l > top2[i]:
                        l, top2[i] = top2[i], l
            result += r-top2[0]
            if top2[0] != -1:
                cnt[top2[0]] += top2[0]-top2[1]
        return result+max(cnt)
",n + m
"
import collections



class Solution(object):
    def equalFrequency(self, word):
        cnt = collections.Counter(iter(collections.Counter(word).values()))
        if len(cnt) > 2:
            return False
        if len(cnt) == 1:
            a = list(cnt.keys())[0]
            return a == 1 or cnt[a] == 1
        a, b = list(cnt.keys())
        if a > b:
            a, b = b, a
        return (a == 1 and cnt[a] == 1) or (a+1 == b and cnt[b] == 1)


",n
"import collections



class Solution2(object):
    def equalFrequency(self, word):
        cnt = collections.Counter(collections.Counter(word))
        for c in word:
            cnt[c] -= 1
            if len(collections.Counter(c for c in cnt.values() if c)) == 1:
                return True
            cnt[c] += 1
        return False
",26 * n
"

class Solution(object):
    def semiOrderedPermutation(self, nums):
        i, j = nums.index(1), nums.index(len(nums))
        return i+((len(nums)-1)-j)-int(i > j)
",n
"
MOD = 10**9+7

class Solution(object):

    def __init__(self):
        self.__arr = []
        self.__ops = [[1, 0]]

    def append(self, val):
        self.__arr.append(val)
        self.__ops.append(self.__ops[-1][:])

    def addAll(self, inc):
        self.__ops[-1][1] = (self.__ops[-1][1]+inc) % MOD

    def multAll(self, m):
        self.__ops[-1] = [(self.__ops[-1][0]*m) % MOD, (self.__ops[-1][1]*m) % MOD]

    def getIndex(self, idx):
        if idx >= len(self.__arr):
            return -1
        a1, b1 = self.__ops[idx]
        a2, b2 = self.__ops[-1]
        a = a2*pow(a1, MOD-2, MOD)%MOD 
        b = (b2 - b1*a) % MOD
        return (self.__arr[idx]*a + b) % MOD


",1
"class Solution2(object):

    def __init__(self):
        self.__arr = []
        self.__op = [1, 0]

    def append(self, val):
        self.__arr.append((val-self.__op[1])*pow(self.__op[0], MOD-2, MOD)%MOD) 

    def addAll(self, inc):
        self.__op[1] = (self.__op[1]+inc) % MOD

    def multAll(self, m):
        self.__op = [(self.__op[0]*m) % MOD, (self.__op[1]*m) % MOD]

    def getIndex(self, idx):
        if idx >= len(self.__arr):
            return -1
        a, b = self.__op
        return (self.__arr[idx]*a + b) % MOD
",1
"

class Solution(object):
    def minOperations(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        cnt = nums.count(1)
        if cnt:
            return len(nums)-cnt
        result = float(""inf"")
        for i in range(len(nums)): 
            g = nums[i]
            for j in range(i+1, len(nums)):
                g = gcd(g, nums[j])
                if g == 1:
                    result = min(result, j-i)
                    break
        return result+(len(nums)-1) if result != float(""inf"") else -1
",n^2
"

class Solution(object):
    def maxSum(self, nums, k, m):
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        dp = [float(""-inf"")]*(len(nums)+1)
        dp[0] = 0
        for i in range(1, k+1):
            new_dp = [float(""-inf"")]*(len(nums)+1)
            mx = float(""-inf"")
            for j in range(i*m-1, len(nums)):
                mx = max(mx, dp[(j+1)-m])
                new_dp[j+1] = (prefix[j+1]-prefix[(j+1)-m])+mx
                if j+1 != i*m:
                    new_dp[j+1] = max(new_dp[j+1], new_dp[j]+nums[j])
            dp = new_dp
        return max(dp)
",k * n
"
import collections
import operator
from functools import reduce



class Solution(object):
    def countTheNumOfKFreeSubsets(self, nums, k):
        def count(x):
            y = x
            while y-k in cnt:
                y -= k
            dp = [1, 0] 
            for i in range(y, x+1, k):
                dp = [dp[0]+dp[1], dp[0]*((1<<cnt[i])-1)]
            return sum(dp)

        cnt = collections.Counter(nums)
        return reduce(operator.mul, (count(i) for i in cnt.keys() if i+k not in cnt))
",n
"
class Solution(object):
    def decodeCiphertext(self, encodedText, rows):
        cols = len(encodedText)//rows
        k = len(encodedText)
        for i in reversed(range(cols)):
            for j in reversed(range(i, len(encodedText), cols+1)):
                if encodedText[j] != ' ':
                    k = j
                    break
            else:
                continue
            break
        result = []
        for i in range(cols):
            for j in range(i, len(encodedText), cols+1):
                result.append(encodedText[j])
                if j == k:
                    break
            else:
                continue
            break
        return """".join(result)


",n
"class Solution2(object):
    def decodeCiphertext(self, encodedText, rows):
        cols = len(encodedText)//rows
        result = []
        for i in range(cols):
            for j in range(i, len(encodedText), cols+1):
                result.append(encodedText[j])
        while result and result[-1] == ' ':
            result.pop()
        return """".join(result)

",n
"

class Solution(object):
    def averageValue(self, nums):
        total = cnt = 0
        for x in nums:
            if x%6:
                continue
            total += x
            cnt += 1
        return total//cnt if cnt else 0
",n
"

class Solution(object):
    def minScore(self, n, roads):
        def bfs():
            lookup = [False]*len(adj)
            q = [0]
            lookup[0] = True
            while q:
                new_q = []
                for u in q:
                    for v, _ in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return lookup

        adj = [[] for _ in range(n)]
        for u, v, w in roads:
            adj[u-1].append((v-1, w))
            adj[v-1].append((u-1, w))
        lookup = bfs()
        return min(w for u, _, w in roads if lookup[u-1])
",n + m
"

class Solution(object):
    def maximumScoreAfterOperations(self, edges, values):
        def iter_dfs():
            dp = [0]*len(values)
            stk = [(1, 0, -1)]
            while stk:
                step, u, p = stk.pop() 
                if step == 1:
                    if len(adj[u]) == (1 if u else 0):
                        dp[u] = values[u]
                        continue
                    stk.append((2, u, p))
                    for v in reversed(adj[u]):
                        if v != p:
                            stk.append((1, v, u))
                elif step == 2:
                    dp[u] = min(sum(dp[v] for v in adj[u] if v != p), values[u]) 
            return dp[0]

        adj = [[] for _ in range(len(values))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return sum(values)-iter_dfs()


",n
"
class Solution2(object):
    def maximumScoreAfterOperations(self, edges, values):
        def dfs(u, p):
            if len(adj[u]) == (1 if u else 0):
                return values[u]
            return min(sum(dfs(v, u) for v in adj[u] if v != p), values[u]) 

        adj = [[] for _ in range(len(values))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return sum(values)-dfs(0, -1)
",n
"

class Solution(object):
    def minOperations(self, nums):
        result = 0
        for i in range(len(nums)-2):
            if nums[i]:
                continue
            nums[i+1] ^= 1
            nums[i+2] ^= 1
            result += 1
        return result if nums[-2] == nums[-1] == 1 else -1
",n
"
class Solution(object):
    def duplicateZeros(self, arr):
        shift, i = 0, 0
        while i+shift < len(arr):
            shift += int(arr[i] == 0)
            i += 1
        i -= 1
        while shift:
            if i+shift < len(arr):
                arr[i+shift] = arr[i]
            if arr[i] == 0:
                shift -= 1
                arr[i+shift] = arr[i]
            i -= 1
",n
"
class Solution(object):
    def maximumPopulation(self, logs):
        MIN_YEAR, MAX_YEAR = 1950, 2050
        years = [0]*(MAX_YEAR-MIN_YEAR+1)
        for s, e in logs:
            years[s-MIN_YEAR] += 1
            years[e-MIN_YEAR] -= 1
        result = 0
        for i in range(len(years)):
            if i:
                years[i] += years[i-1]
            if years[i] > years[result]:
                result = i
        return result+MIN_YEAR
",n
"
import heapq


class Solution(object):

    def __init__(self, k, nums):
        self.__k = k
        self.__min_heap = []
        for n in nums:
            self.add(n)
        

    def add(self, val):
        heapq.heappush(self.__min_heap, val)
        if len(self.__min_heap) > self.__k:
            heapq.heappop(self.__min_heap)
        return self.__min_heap[0]



",nlogk
"

class Solution(object):
    def findClosestNumber(self, nums):
        return max(nums, key=lambda x:(-abs(x), x))
",n
"

class Solution(object):

    def __init__(self, n):
        self.__size = n
        self.__rows = [[0, 0] for _ in range(n)]
        self.__cols = [[0, 0] for _ in range(n)]
        self.__diagonal = [0, 0]
        self.__anti_diagonal = [0, 0]

    def move(self, row, col, player):
        i = player - 1
        self.__rows[row][i] += 1
        self.__cols[col][i] += 1
        if row == col:
            self.__diagonal[i] += 1
        if col == len(self.__rows) - row - 1:
            self.__anti_diagonal[i] += 1
        if any(self.__rows[row][i] == self.__size,
               self.__cols[col][i] == self.__size,
               self.__diagonal[i] == self.__size,
               self.__anti_diagonal[i] == self.__size):
            return player

        return 0



",1
"
class Solution(object):
    def flipLights(self, n, m):
        if m == 0:
            return 1
        if n == 1:
            return 2
        if m == 1 and n == 2:
            return 3
        if m == 1 or n == 2:
            return 4
        if m == 2:
            return 7
        return 8

",1
"

class Solution(object):
    def bestClosingTime(self, customers):
        result = mx = curr = 0
        for i, x in enumerate(customers):
            curr += 1 if x == 'Y' else -1
            if curr > mx:
                mx = curr
                result = i+1
        return result
",n
"
import collections


class Solution(object):
    def getImportance(self, employees, id):
        if employees[id-1] is None:
            return 0
        result = employees[id-1].importance
        for id in employees[id-1].subordinates:
            result += self.getImportance(employees, id)
        return result


",n
"class Solution2(object):
    def getImportance(self, employees, id):
        result, q = 0, collections.deque([id])
        while q:
            curr = q.popleft()
            employee = employees[curr-1]
            result += employee.importance
            for id in employee.subordinates:
                q.append(id)
        return result

",n
"
class Solution(object):
    def reorderLogFiles(self, logs):
        def f(log):
            i, content = log.split("" "", 1)
            return (0, content, i) if content[0].isalpha() else (1,)

        logs.sort(key=f)
        return logs
",nlogn * l
"
class Solution(object):
    def digitsCount(self, d, low, high):
        def digitsCount(n, k):
            pivot, result = 1, 0
            while n >= pivot:
                result += (n//(10*pivot))*pivot + \
                           min(pivot, max(n%(10*pivot) - k*pivot + 1, 0))
                if k == 0:
                    result -= pivot
                pivot *= 10
            return result+1
        
        return digitsCount(high, d) - digitsCount(low-1, d)
",logn
"

class ListNode(object):
    def __init__(self, val=0, next=None):
        pass


class Solution(object):
    def mergeInBetween(self, list1, a, b, list2):
        prev_first, last = None, list1
        for i in range(b):
            if i == a-1:
                prev_first = last
            last = last.__next__
        prev_first.next = list2
        while list2.__next__:
            list2 = list2.__next__
        list2.next = last.__next__
        last.next = None
        return list1
",m + n
"
class Solution(object):
    def numberOfArithmeticSlices(self, A):
        res, i = 0, 0
        while i+2 < len(A):
            start = i
            while i+2 < len(A) and A[i+2] + A[i] == 2*A[i+1]:
                res += i - start + 1
                i += 1
            i += 1

        return res

",n
"
import collections


class Solution(object):
    def minimumTeachings(self, n, languages, friendships):
        language_sets = list(map(set, languages)) 
        candidates = set(i-1 for u, v in friendships if not language_sets[u-1] & language_sets[v-1] for i in [u, v]) 
        count = collections.Counter()
        for i in candidates: 
            count += collections.Counter(languages[i])
        return len(candidates) - max(list(count.values()) + [0])
",n * m^2
"
class Solution(object):
    def mergeTriplets(self, triplets, target):
        result = [0]*3
        for t in triplets:
            if all(t[i] <= target[i] for i in range(3)):
                result = [max(result[i], t[i]) for i in range(3)]
        return result == target
",n
"
class Solution(object):
    def uniquePaths(self, m, n):
        def nCr(n, r): 
            if n-r < r:
                r = n-r
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c

        return nCr((m-1)+(n-1), n-1)


",m + n
"class Solution2(object):
    def uniquePaths(self, m, n):
        if m < n:
            m, n  = n, m

        dp = [1]*n
        for i in range(1, m):
            for j in range(1, n):
                dp[j] += dp[j-1]
        return dp[n-1]
",m * n
"
class Solution(object):
    def searchInsert(self, nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) / 2
            if nums[mid] >= target:
                right = mid - 1
            else:
                left = mid + 1

        return left


",logn
"
class Solution(object):
    def bagOfTokensScore(self, tokens, P):
        tokens.sort()
        result, points = 0, 0
        left, right = 0, len(tokens)-1
        while left <= right:
            if P >= tokens[left]:
                P -= tokens[left]
                left += 1
                points += 1
                result = max(result, points)
            elif points > 0:
                points -= 1
                P += tokens[right]
                right -= 1
            else:
                break
        return result
",nlogn
"
class Solution(object):
    def minDeletionSize(self, A):
        dp = [1] * len(A[0])
        for j in range(1, len(A[0])):
            for i in range(j):
                if all(A[k][i] <= A[k][j] for k in range(len(A))):
                    dp[j] = max(dp[j], dp[i]+1)
        return len(A[0]) - max(dp)
",n * l^2
"
import collections
from functools import reduce



class Solution(object):
    def countGoodSubsequences(self, s):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            if not (0 <= k <= n):
                return 0
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        cnt = collections.Counter(s)
        return reduce(lambda total, k: (total+reduce(lambda total, x: total*(1+nCr(x, k))%MOD, iter(cnt.values()), 1)-1)%MOD, range(1, max(cnt.values())+1), 0)
",26 * n
"
class Solution(object):
    def numDecodings(self, s):
        if len(s) == 0 or s[0] == '0':
            return 0
        prev, prev_prev = 1, 0
        for i in range(len(s)):
            cur = 0
            if s[i] != '0':
                cur = prev
            if i > 0 and (s[i - 1] == '1' or (s[i - 1] == '2' and s[i] <= '6')):
                cur += prev_prev
            prev, prev_prev = cur, prev
        return prev


",n
"
class Solution(object):
    def maxNonOverlapping(self, nums, target):
        lookup = {0:-1}
        result, accu, right = 0, 0, -1
        for i, num in enumerate(nums):
            accu += num
            if accu-target in lookup and lookup[accu-target] >= right:
                right = i
                result += 1 
            lookup[accu] = i
        return result
",n
"
class Solution(object):
    def isArmstrong(self, N):
        n_str = str(N)
        return sum(int(i)**len(n_str) for i in n_str) == N
",klogk
"
import collections



class Solution(object):
    def largestInteger(self, nums, k):
        if k == len(nums):
            return max(nums)
        cnt = collections.defaultdict(int)
        for x in nums:
            cnt[x] += 1
        if k == 1:
            return max(x for x, v in cnt.items() if v == 1) if any(v == 1 for v in cnt.values()) else -1
        result = -1
        if cnt[nums[0]] == 1:
            result = max(result, nums[0])
        if cnt[nums[-1]] == 1:
            result = max(result, nums[-1])
        return result
",n
"
class Solution(object):
    def tilingRectangle(self, n, m):
        def find_next(board):
            for i in range(len(board)):
                for j in range(len(board[0])):
                    if not board[i][j]:
                        return i, j
            return -1, -1

        def find_max_length(board, i, j):
            max_length = 1
            while i+max_length-1 < len(board) and \
                  j+max_length-1 < len(board[0]):
                for r in range(i, i+max_length-1):
                    if board[r][j+max_length-1]:
                        return max_length-1
                for c in range(j, j+max_length):
                    if board[i+max_length-1][c]:
                        return max_length-1
                max_length += 1
            return max_length-1

        def fill(board, i, j, length, val):
            for r in range(i, i+length):
                for c in range(j, j+length):
                    board[r][c] = val

        def backtracking(board, count, result):
            if count >= result[0]: 
                return
            i, j = find_next(board)
            if (i, j) == (-1, -1): 
                result[0] = min(result[0], count)
                return
            max_length = find_max_length(board, i, j)
            for k in reversed(range(1, max_length+1)):
                fill(board, i, j, k, 1)
                backtracking(board, count+1, result)
                fill(board, i, j, k, 0)

        if m > n:
            return self.tilingRectangle(m, n)
        board = [[0]*m for _ in range(n)]
        result = [float(""inf"")]
        backtracking(board, 0, result)
        return result[0]
",n^2 * m^2 * m^(n * m)
"
import bisect


class Solution(object):
    def sampleStats(self, count):
        n = sum(count)
        mi = next(i for i in range(len(count)) if count[i]) * 1.0
        ma = next(i for i in reversed(range(len(count))) if count[i]) * 1.0
        mean = sum(i * v for i, v in enumerate(count)) * 1.0 / n
        mode = count.index(max(count)) * 1.0
        for i in range(1, len(count)):
            count[i] += count[i-1]
        median1 = bisect.bisect_left(count, (n+1) // 2)
        median2 = bisect.bisect_left(count, (n+2) // 2)
        median = (median1+median2) / 2.0
        return [mi, ma, mean, median, mode]
",n
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def goodNodes(self, root):
        result = 0
        stk = [(root, root.val)]
        while stk:
            node, curr_max = stk.pop()
            if not node:
                continue
            curr_max = max(curr_max, node.val)
            result += int(curr_max <= node.val)
            stk.append((node.right, curr_max))
            stk.append((node.left, curr_max))
        return result


",n
"class Solution2(object):
    def goodNodes(self, root):
        def dfs(node, curr_max):
            if not node:
                return 0
            curr_max = max(curr_max, node.val)
            return (int(curr_max <= node.val) +
                    dfs(node.left, curr_max) + dfs(node.right, curr_max))
        
        return dfs(root, root.val)
",n
"
class Solution(object):
    def minSwaps(self, data):
        total_count = sum(data)
        result, count, left = 0, 0, 0
        for i in range(len(data)):
            count += data[i]
            if i-left+1 > total_count: 
                count -= data[left]
                left += 1
            result = max(result, count)
        return total_count-result
",n
"
import random



class Solution(object):
    def outerTrees(self, trees):
        def dist(a, b):
            return ((a[0]-b[0])**2 + (a[1]-b[1])**2)**0.5

        def inside(c, p):
            return dist(c[0], p) < c[1]+EPS

        def circle_center(bx, by, cx, cy):
            B = bx*bx + by*by
            C = cx*cx + cy*cy
            D = bx*cy - by*cx
            return [float(cy*B - by*C)/(2*D),
                    float(bx*C - cx*B)/(2*D)]

        def circle_from_2_points(A, B):
            C = [(A[0]+B[0])/2.0, (A[1]+B[1])/2.0]
            return [C, dist(A, B)/2.0]

        def circle_from_3_points(A, B, C):
            I = circle_center(B[0]-A[0], B[1]-A[1],
                              C[0]-A[0], C[1]-A[1])
            I[0] += A[0]
            I[1] += A[1]
            return [I, dist(I, A)]

        def trivial(boundaries): 
            if not boundaries:
                return None
            if len(boundaries) == 1:
                return [boundaries[0], 0.0]
            if len(boundaries) == 2:
                return circle_from_2_points(boundaries[0], boundaries[1])
            return circle_from_3_points(boundaries[0], boundaries[1], boundaries[2])

        def Welzl(points, boundaries, curr):
            if curr == len(points) or len(boundaries) == 3:
                return trivial(boundaries)
            result = Welzl(points, boundaries, curr+1)
            if result is not None and inside(result, points[curr]):
                return result
            boundaries.append(points[curr])
            result = Welzl(points, boundaries, curr+1)
            boundaries.pop()
            return result

        EPS = 1e-5
        random.seed(0)
        random.shuffle(trees)
        result = Welzl(trees, [], 0)
        return result[0][0], result[0][1], result[1]
",n
"
class Solution(object):
    def removeVowels(self, S):
        lookup = set(""aeiou"")
        return """".join(c for c in S if c not in lookup)
",n
"

class Solution(object):
    def minChanges(self, nums, k):
        diff = [0]*((k+1)+1)
        def update(left, right, d):
            diff[left] += d
            diff[right+1] -= d

        for i in range(len(nums)//2):
            curr = abs(nums[i]-nums[~i])
            mx = max(nums[i]-0, k-nums[i], nums[~i]-0, k-nums[~i])
            update(0, curr-1, 1)
            update(curr+1, mx, 1)
            update(mx+1, k, 2)
        result = len(nums)//2
        curr = 0
        for i in range(k+1):
            curr += diff[i]
            result = min(result, curr)
        return result
",n + k
"
class Solution(object):
    def countConsistentStrings(self, allowed, words):
        lookup = [False]*26
        for c in allowed:
            lookup[ord(c)-ord('a')] = True
        result = len(words)
        for word in words:
            for c in word:
                if not lookup[ord(c)-ord('a')]:
                    result -= 1
                    break
        return result
",n
"
class Solution(object):
    def arrayNesting(self, nums):
        result = 0
        for num in nums:
            if num is not None:
                start, count = num, 0
                while nums[start] is not None:
                    temp = start
                    start = nums[start]
                    nums[temp] = None
                    count += 1
                result = max(result, count)
        return result

",n
"

class Solution(object):
    def numberOfPaths(self, grid, k):
        MOD = 10**9+7
        dp = [[0 for _ in range(k)] for _ in range(len(grid[0]))]
        dp[0][0] = 1
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                dp[j] = [((dp[j-1][(l-grid[i][j])%k] if j-1 >= 0 else 0)+dp[j][(l-grid[i][j])%k])%MOD for l in range(k)]
        return dp[-1][0]
",m * n * k
"
class Solution(object):
    def rotateString(self, A, B):
        def check(index):
            return all(A[(i+index) % len(A)] == c
                       for i, c in enumerate(B))

        if len(A) != len(B):
            return False

        M, p = 10**9+7, 113
        p_inv = pow(p, M-2, M)

        b_hash, power = 0, 1
        for c in B:
            b_hash += power * ord(c)
            b_hash %= M
            power = (power*p) % M

        a_hash, power = 0, 1
        for i in range(len(B)):
            a_hash += power * ord(A[i%len(A)])
            a_hash %= M
            power = (power*p) % M

        if a_hash == b_hash and check(0): return True

        power = (power*p_inv) % M
        for i in range(len(B), 2*len(A)):
            a_hash = (a_hash-ord(A[(i-len(B))%len(A)])) * p_inv
            a_hash += power * ord(A[i%len(A)])
            a_hash %= M
            if a_hash == b_hash and check(i-len(B)+1):
                return True

        return False


",n
"
class Solution2(object):
    def rotateString(self, A, B):
        def strStr(haystack, needle):
            def KMP(text, pattern):
                prefix = getPrefix(pattern)
                j = -1
                for i in range(len(text)):
                    while j > -1 and pattern[j + 1] != text[i]:
                        j = prefix[j]
                    if pattern[j + 1] == text[i]:
                        j += 1
                    if j == len(pattern) - 1:
                        return i - j
                return -1

            def getPrefix(pattern):
                prefix = [-1] * len(pattern)
                j = -1
                for i in range(1, len(pattern)):
                    while j > -1 and pattern[j + 1] != pattern[i]:
                        j = prefix[j]
                    if pattern[j + 1] == pattern[i]:
                        j += 1
                    prefix[i] = j
                return prefix

            if not needle:
                return 0
            return KMP(haystack, needle)

        if len(A) != len(B):
            return False
        return strStr(A*2, B) != -1


",n
"class Solution3(object):
    def rotateString(self, A, B):
        return len(A) == len(B) and B in A*2

",n^2
"
import collections



class Solution(object):
    def beautifulNumbers(self, l, r):
        def count(x):
            s = [ord(x)-ord('0') for x in str(x)]
            dp = [collections.defaultdict(int) for _ in range(2)]
            dp[1][1, 0] = 1
            for c in s:
                new_dp = [collections.defaultdict(int) for _ in range(2)]
                for b in range(2):
                    for (mul, total), cnt in dp[b].items():
                        for x in range((c if b else 9)+1):
                            new_dp[b and x == c][mul*(1 if total == 0 == x else x), total+x] += cnt
                dp = new_dp
            result = 0
            for b in range(2):
                for (mul, total), cnt in dp[b].items():
                    if total and mul%total == 0:
                        result += cnt
            return result

        return count(r)-count(l-1)
",logr * 2 * 10 * s
"
class Solution(object):
    def maxIceCream(self, costs, coins):
        costs.sort()
        for i, c in enumerate(costs):
            coins -= c
            if coins < 0:
                return i
        return len(costs)
",nlogn
"
class Solution(object):
    def coinChange(self, coins, amount):
        INF = 0x7fffffff 
        dp = [INF] * (amount + 1)
        dp[0] = 0
        for i in range(amount + 1):
            if dp[i] != INF:
                for coin in coins:
                    if i + coin <= amount:
                        dp[i + coin] = min(dp[i + coin], dp[i] + 1)
        return dp[amount] if dp[amount] != INF else -1


",n * k
"
class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
       if self.set[x] != x:
           self.set[x] = self.find_set(self.set[x]) 
       return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root != y_root:
            self.set[min(x_root, y_root)] = max(x_root, y_root)
            self.count -= 1


class Solution(object):
    def regionsBySlashes(self, grid):
        def index(n, i, j, k):
            return (i*n + j)*4 + k
    
        union_find = UnionFind(len(grid)**2 * 4)
        N, E, S, W = list(range(4))
        for i in range(len(grid)):
            for j in range(len(grid)):
                if i:
                    union_find.union_set(index(len(grid), i-1, j, S),
                                         index(len(grid),i, j, N))
                if j:
                    union_find.union_set(index(len(grid), i, j-1, E),
                                         index(len(grid), i, j, W))
                if grid[i][j] != ""/"":
                    union_find.union_set(index(len(grid), i, j, N),
                                         index(len(grid), i, j, E))
                    union_find.union_set(index(len(grid), i, j, S),
                                         index(len(grid), i, j, W))
                if grid[i][j] != ""\\"":
                    union_find.union_set(index(len(grid), i, j, W),
                                         index(len(grid), i, j, N))
                    union_find.union_set(index(len(grid), i, j, E),
                                         index(len(grid), i, j, S))
        return union_find.count
",n^2
"
class Solution(object):
    def numMovesStones(self, a, b, c):
        s = [a, b, c]
        s.sort()
        if s[0]+1 == s[1] and s[1]+1 == s[2]:
            return [0, 0]
        return [1 if s[0]+2 >= s[1] or s[1]+2 >= s[2] else 2, s[2]-s[0]-2]


",1
"class Solution2(object):
    def numMovesStones(self, a, b, c):
        stones = [a, b, c]
        stones.sort()
        left, min_moves = 0, float(""inf"")
        max_moves = (stones[-1]-stones[0]) - (len(stones)-1)
        for right in range(len(stones)):
            while stones[right]-stones[left]+1 > len(stones):
                left += 1
            min_moves = min(min_moves, len(stones)-(right-left+1)) 
        return [min_moves, max_moves]
",1
"
class Solution(object):
    def maximumGap(self, nums):
        if len(nums) < 2:
            return 0

        max_val, min_val = max(nums), min(nums)
        gap = max(1, (max_val - min_val) / (len(nums) - 1))
        bucket_size = (max_val - min_val) / gap + 1
        bucket = [{'min':float(""inf""), 'max':float(""-inf"")} \
                    for _ in range(bucket_size)]

        for n in nums:
            if n in (max_val, min_val):
                continue
            i = (n - min_val) / gap
            bucket[i]['min'] = min(bucket[i]['min'], n)
            bucket[i]['max'] = max(bucket[i]['max'], n)

        max_gap, pre_bucket_max = 0, min_val
        for i in range(bucket_size):
            if bucket[i]['min'] == float(""inf"") and \
                bucket[i]['max'] == float(""-inf""):
                continue
            max_gap = max(max_gap, bucket[i]['min'] - pre_bucket_max)
            pre_bucket_max = bucket[i]['max']
        max_gap = max(max_gap, max_val - pre_bucket_max)

        return max_gap


",n
"class Solution2(object):
    def maximumGap(self, nums):
        if len(nums) < 2:
            return 0

        nums.sort()
        pre = nums[0]
        max_gap = float(""-inf"")

        for i in nums:
            max_gap = max(max_gap, i - pre)
            pre = i
        return max_gap


",nlogn
"

class Solution(object):
    def letterCombinations(self, digits):
        if not digits:
            return []

        lookup = ["""", """", ""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""]
        total = 1
        for digit in digits:
            total *= len(lookup[int(digit)])
        result = []
        for i in range(total):
            base, curr = total, []
            for digit in digits:
                choices = lookup[int(digit)]
                base //= len(choices)
                curr.append(choices[(i//base)%len(choices)])
            result.append("""".join(curr))
        return result


",n * 4^n
"
class Solution2(object):
    def letterCombinations(self, digits):
        if not digits:
            return []

        result = [""""]
        lookup = ["""", """", ""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""]
        for digit in reversed(digits):
            choices = lookup[int(digit)]
            m, n = len(choices), len(result)
            result.extend([result[i % n] for i in range(n, m*n)])
            for i in range(m*n):
                result[i] = choices[i//n] + result[i]
        return result


",n * 4^n
"
class Solution3(object):
    def letterCombinations(self, digits):
        lookup = ["""", """", ""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""]

        def letterCombinationsRecu(result, digits, curr, n):
            if n == len(digits):
                result.append("""".join(curr))
                return
            for choice in lookup[int(digits[n])]:
                curr.append(choice)
                letterCombinationsRecu(result, digits, curr, n+1)
                curr.pop()

        if not digits:
            return []
        result = []
        letterCombinationsRecu(result, digits, [], 0)
        return result

",n * 4^n
"
import heapq



class Solution(object):
    def earliestSecondToMarkIndices(self, nums, changeIndices):
        def check(t):
            min_heap = []
            cnt = 0
            for i in reversed(range(t)):
                if i != lookup[changeIndices[i]-1]:
                    cnt += 1
                    continue
                heapq.heappush(min_heap, nums[changeIndices[i]-1])
                if cnt:
                    cnt -= 1
                else:
                    cnt += 1
                    heapq.heappop(min_heap)
            return total-(sum(min_heap)+len(min_heap)) <= cnt

        lookup = [-1]*len(nums)
        for i in reversed(range(len(changeIndices))):
            if nums[changeIndices[i]-1]:
                lookup[changeIndices[i]-1] = i
        total = sum(nums)+len(nums)
        left, right = sum((1 if lookup[i] != -1 else nums[i]) for i in range(len(nums)))+len(nums), len(changeIndices) 
        while left <= right:
            mid = left+(right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return left if left <= len(changeIndices) else -1
",(m + nlogn) * logm
"

class Solution(object):
    def fillCups(self, amount):
        return max(max(amount), (sum(amount)+1)//2)


",1
"
class Solution2(object):
    def fillCups(self, amount):
        mx, total = max(amount), sum(amount)
        return mx if sum(amount)-mx <= mx else (total+1)//2
",1
"
import collections


class Solution(object):
    def characterReplacement(self, s, k):
        result, max_count = 0, 0
        count = collections.Counter()
        for i in range(len(s)):
            count[s[i]] += 1
            max_count = max(max_count, count[s[i]])
            if result - max_count >= k:
                count[s[i-result]] -= 1
            else:
                result += 1
        return result

",n
"
class Solution(object):
    def search(self, nums, target):
        left, right = 0, len(nums) - 1

        while left <= right:
            mid = left + (right - left) / 2

            if nums[mid] == target:
                return mid
            elif (nums[mid] >= nums[left] and nums[left] <= target < nums[mid]) or \
                 (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])):
                right = mid - 1
            else:
                left = mid + 1

        return -1


",logn
"
import collections



class Solution(object):
    def minCost(self, nums):
        dp = collections.defaultdict(lambda: float(""inf""))
        dp[nums[0]] = 0
        for i in range(1, len(nums)-1, 2):
            new_dp = collections.defaultdict(lambda: float(""inf""))
            x, y = nums[i], nums[i+1]
            for z, c in dp.items():
                v = sorted([x, y, z])
                new_dp[v[0]] = min(new_dp[v[0]], c+v[2])
                new_dp[v[2]] = min(new_dp[v[2]], c+v[1])
            dp = new_dp
        last = nums[-1] if len(nums)%2 == 0 else 0
        return min(c+max(x, last) for x, c in dp.items())
",n^2
"
class Solution(object):
    def numberOfSteps (self, num):
        result = 0
        while num:
            result += 2 if num%2 else 1
            num //= 2
        return max(result-1, 0)
",logn
"
import bisect


class Solution(object):
    def increasingTriplet(self, nums):
        min_num, a, b = float(""inf""), float(""inf""), float(""inf"")
        for c in nums:
            if min_num >= c:
                min_num = c
            elif b >= c:
                a, b = min_num, c
            else: 
                return True
        return False

",n
"
class Solution_Generalization(object):
    def increasingTriplet(self, nums):
        def increasingKUplet(nums, k):
            inc = [float('inf')] * (k - 1)
            for num in nums:
                i = bisect.bisect_left(inc, num)
                if i >= k - 1:
                    return True
                inc[i] = num
            return k == 0

        return increasingKUplet(nums, 3)

",n * logk
"
class Solution(object):
    def filterRestaurants(self, restaurants, veganFriendly, maxPrice, maxDistance):
        result, lookup = [], {}
        for j, (i, _, v, p, d) in enumerate(restaurants):
            if v >= veganFriendly and p <= maxPrice and d <= maxDistance:
                lookup[i] = j
                result.append(i)
        result.sort(key=lambda i: (-restaurants[lookup[i]][1], -restaurants[lookup[i]][0]))
        return result
",rlogr
"
class Solution(object):
    def removeInterval(self, intervals, toBeRemoved):
        A, B = toBeRemoved
        return [[x, y] for a, b in intervals
                for x, y in ((a, min(A, b)), (max(a, B), b))
                if x < y]
",n
"

class Solution(object):
    def maximumCoins(self, coins, k):
        def max_amount():
            coins.sort()
            result = curr = left = 0
            for right in range(len(coins)):
                curr += (coins[right][1]-coins[right][0]+1)*coins[right][2]
                while coins[right][1]-coins[left][1]+1 > k:
                    curr -= (coins[left][1]-coins[left][0]+1)*coins[left][2]
                    left += 1
                result = max(result, curr-max((coins[right][1]-coins[left][0]+1)-k, 0)*coins[left][2])
            return result
    
        result = max_amount()
        for i, (l, r, w) in enumerate(coins):
            coins[i][:] = [-r, -l, w]
        result = max(result, max_amount())
        return result
",nlogn
"

class Solution(object):
    def maximumTotalCost(self, nums):
        dp = [nums[0], float(""-inf"")]
        for i in range(1, len(nums)):
            dp[:] = [max(dp)+nums[i], dp[0]-nums[i]]
        return max(dp)
",n
"
import collections


class Solution(object):
    def longestPalindrome(self, s):
        odds = 0
        for k, v in collections.Counter(s).items():
            odds += v & 1
        return len(s) - odds + int(odds > 0)

    def longestPalindrome2(self, s):
        odd = sum([x & 1 for x in list(collections.Counter(s).values())])
        return len(s) - odd + int(odd > 0)

",n
"

class Solution(object):
    def minimumOperationsToWriteY(self, grid):
        cnt = [[0]*3 for _ in range(2)]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                cnt[(i <= (len(grid[0])-1)//2 and (i-j == 0 or i+j == len(grid[0])-1)) or (i > (len(grid[0])-1)//2 == j)][grid[i][j]] += 1
        return len(grid)*len(grid[0])-max(cnt[0][i]+cnt[1][j] for i in range(3) for j in range(3) if i != j)
",n^2
"

class Solution(object):
    def longestMonotonicSubarray(self, nums):
        result = cnt = 1 if len(nums) == 1 or cmp(nums[0], nums[1]) == 0 else 2
        for i in range(2, len(nums)):
            cnt = 1 if cmp(nums[i-1], nums[i]) == 0 else cnt+1 if cmp(nums[i-2], nums[i-1]) == cmp(nums[i-1], nums[i]) else 2
            result = max(result, cnt)
        return result


",n
"
class Solution2(object):
    def longestMonotonicSubarray(self, nums):
        result = cnt1 = cnt2 = 1
        for i in range(1, len(nums)):
            cnt1 = cnt1+1 if nums[i-1] < nums[i] else 1
            cnt2 = cnt2+1 if nums[i-1] > nums[i] else 1
            result = max(result, cnt1, cnt2)
        return result


",n
"
class Solution3(object):
    def longestMonotonicSubarray(self, nums):
        def f(compare):
            result = l = 0
            for i in range(len(nums)):
                l += 1
                if i+1 == len(nums) or not compare(nums[i], nums[i+1]):
                    result = max(result, l)
                    l = 0
            return result

        return max(f(lambda x, y: x < y), f(lambda x, y: x > y))
",n
"
class Solution(object):
    def defangIPaddr(self, address):
        result = []
        for c in address:
            if c == '.':
                result.append(""[.]"")
            else:
                result.append(c)
        return """".join(result)
",n
"

class Solution(object):
    def minElement(self, nums):
        def f(x):
            result = 0
            while x:
                result += x%10
                x //= 10
            return result

        return min(f(x) for x in nums)
",nlogr
"

class Solution(object):
    def minimumCost(self, m, n, horizontalCut, verticalCut):
        horizontalCut.sort()
        verticalCut.sort()
        result = 0
        cnt_h = cnt_v = 1
        while horizontalCut or verticalCut:
            if not verticalCut or (horizontalCut and horizontalCut[-1] > verticalCut[-1]):
                result += horizontalCut.pop()*cnt_h
                cnt_v += 1
            else:
                result += verticalCut.pop()*cnt_v
                cnt_h += 1
        return result


",mlogm + nlogn
"
class Solution2(object):
    def minimumCost(self, m, n, horizontalCut, verticalCut):
        horizontalCut.sort(reverse=True)
        verticalCut.sort(reverse=True)
        result = i = j = 0
        while i < len(horizontalCut) or j < len(verticalCut):
            if j == len(verticalCut) or (i < len(horizontalCut) and horizontalCut[i] > verticalCut[j]):
                result += horizontalCut[i]*(j+1)
                i += 1
            else:
                result += verticalCut[j]*(i+1)
                j += 1
        return result


",mlogm + nlogn
"
class Solution3(object):
    def minimumCost(self, m, n, horizontalCut, verticalCut):
        def memoization(x1, y1, x2, y2):
            if (x1, y1) == (x2, y2):
                return 0
            if lookup[x1][y1][x2][y2] == -1:
                mn = float(""inf"")
                for x in range(x1, x2):
                    mn = min(ret, memoization(x1, y1, x, y2)+memoization(x+1, y1, x2, y2)+horizontalCut[x])
                for y in range(y1, y2):
                    mn = min(ret, memoization(x1, y1, x2, y)+memoization(x1, y+1, x2, y2)+verticalCut[y])
                lookup[x1][y1][x2][y2] = mn
            return lookup[x1][y1][x2][y2]

        lookup = [[[[-1]*n for _ in range(m)]for _ in range(n)] for _ in range(m)]
        return memoization(0, 0, m-1, n-1)

",(m + n) * m^2 * n^2
"
class Solution(object):

    def distributeCandies(self, candies):
        lookup = set(candies)
        return min(len(lookup), len(candies)/2)

",n
"
from sortedcontainers import SortedList



class Solution(object):
    def maxBalancedSubsequenceSum(self, nums):
        NEG_INF = float(""-inf"")
        def query(sl, k):
            j = sl.bisect_left((k,))
            return sl[j-1][1] if j-1 >= 0 else NEG_INF
    
        def update(sl, k, v):
            j = sl.bisect_left((k,))
            if j < len(sl) and sl[j][0] == k:
                if not (sl[j][1] < v):
                    return
                del sl[j]
            elif not (j-1 < 0 or sl[j-1][1] < v):
                return
            sl.add((k, v))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]

        sl = SortedList()
        for i, x in enumerate(nums):
            v = max(query(sl, (x-i)+1), 0)+x
            update(sl, x-i, v)
        return sl[-1][1]


",nlogn
"
class Solution2(object):
    def maxBalancedSubsequenceSum(self, nums):
        NEG_INF = float(""-inf"")
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [NEG_INF]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret

        val_to_idx = {x:i for i, x in enumerate(sorted({x-i for i, x in enumerate(nums)}))}
        bit = BIT(len(val_to_idx), default=NEG_INF, fn=max)
        for i, x in enumerate(nums):
            v = max(bit.query(val_to_idx[x-i]), 0)+x
            bit.update(val_to_idx[x-i], v)
        return bit.query(len(val_to_idx)-1)


",nlogn
"
class Solution3(object):
    def maxBalancedSubsequenceSum(self, nums):
        NEG_INF = float(""-inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y),
                         update_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(self.tree[x], h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        val_to_idx = {x:i for i, x in enumerate(sorted({x-i for i, x in enumerate(nums)}))}
        st = SegmentTree(len(val_to_idx))
        for i, x in enumerate(nums):
            v = max(st.query(0, val_to_idx[x-i]), 0)+x
            st.update(val_to_idx[x-i], v)
        return st.query(0, len(val_to_idx)-1)
",nlogn
"

class Solution(object):
    def minOperations(self, nums, k):
        return sum(nums)%k
",n
"
class Solution(object):
    def sumBase(self, n, k):
        result = 0
        while n:
            n, r = divmod(n, k)
            result += r
        return result
",logn
"

class Solution(object):
    def maximumValue(self, strs):
        return max(int(s) if s.isdigit() else len(s) for s in strs)
",n * l
"

class Solution(object):
    def maxPalindromesAfterOperations(self, words):
        cnt = [0]*26
        for w in words:
            for c in w:
                cnt[ord(c)-ord('a')] += 1
        curr = sum(x//2 for x in cnt)
        for i, l in enumerate(sorted(map(len, words))):
            curr -= l//2
            if curr < 0:
                return i
        return len(words)
",n * l + nlogn
"

class Solution(object):
    def maximumLength(self, nums):
        k = 2
        result = 0
        for i in range(k):
            dp = [0]*k
            for x in nums:
                dp[x%k] = dp[(i-x)%k]+1
            result = max(result, max(dp))
        return result


",n
"
class Solution2(object):
    def maximumLength(self, nums):
        return max(sum(x%2 == 0 for x in nums),
                   sum(x%2 == 1 for x in nums),
                   sum(nums[i]%2 != nums[i+1]%2 for i in range(len(nums)-1))+1)
",n
"

class Solution(object):
    def numberOfWays(self, n):
        MOD = 10**9+7












        return (1+((n//2)+1)*(n//2)//2)%MOD


",1
"
class Solution2(object):
    def numberOfWays(self, n):
        MOD = 10**9+7
        def count_1_2_6(n):
            return (n//2+1)*((n//6)-0+1)-3*((n//6)+0)*((n//6)-0+1)//2

        return reduce(lambda x, y: (x+count_1_2_6(n-4*y))%MOD, (i for i in range(min(n//4, 2)+1)), 0)


",1
"
class Solution3(object):
    def numberOfWays(self, n):
        MOD = 10**9+7
        def count_1_2(n):
            return n//2+1
    
        def count_1_2_6(n):
            return sum(count_1_2(n-6*i) for i in range((n//6)+1))

        return reduce(lambda x, y: (x+count_1_2_6(n-4*y))%MOD, (i for i in range(min(n//4, 2)+1)), 0)


",n
"
class Solution4(object):
    def numberOfWays(self, n):
        MOD = 10**9+7
        dp = [0]*(n+1)
        dp[0] = 1
        for i in (1, 2, 6):
            for j in range(i, n+1):
                dp[j] += dp[j-i]
        return reduce(lambda x, y: (x+dp[n-4*y])%MOD, (i for i in range(min(n//4, 2)+1)), 0)
",n
"
import collections
from functools import partial





class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n
        self.ancestor = list(range(n)) 

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True

    def find_ancestor_of_set(self, x): 
        return self.ancestor[self.find_set(x)]

    def update_ancestor_of_set(self, x): 
        self.ancestor[self.find_set(x)] = x


class TreeInfos(object): 
    def __init__(self, children, pairs):
        def preprocess(curr, parent):
            D[curr] = 1 if parent == -1 else D[parent]+1

        def divide(curr, parent):
            stk.append(partial(postprocess, curr))
            for i in reversed(range(len(children[curr]))):
                child = children[curr][i]
                if child == parent:
                    continue
                stk.append(partial(conquer, child, curr))
                stk.append(partial(divide, child, curr))
            stk.append(partial(preprocess, curr, parent))

        def conquer(curr, parent):
            uf.union_set(curr, parent)
            uf.update_ancestor_of_set(parent)

        def postprocess(u):
            lookup[u] = True
            for v in pairs[u]:
                if not lookup[v]:
                    continue
                lca[min(u, v), max(u, v)] = uf.find_ancestor_of_set(v)

        N = len(children)
        D, uf, lca = [0]*N, UnionFind(N), {}
        stk, lookup = [], [False]*N
        stk.append(partial(divide, 0, -1))
        while stk:
            stk.pop()()
        self.D, self.lca = D, lca



class Solution(object):
    def closestNode(self, n, edges, query):
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v), adj[v].append(u)
        pairs = collections.defaultdict(set)
        for start, end, node in query:
            pairs[start].add(end), pairs[end].add(start)
            pairs[start].add(node), pairs[node].add(start)
            pairs[end].add(node), pairs[node].add(end)
        tree_infos = TreeInfos(adj, pairs)
        return [max((tree_infos.lca[min(x, y), max(x, y)] for x, y in ((start, end), (start, node), (end, node))), key=lambda x: tree_infos.D[x]) for start, end, node in query]


",n + q
"from functools import partial




class TreeInfos2(object): 
    def __init__(self, children): 
        def preprocess(curr, parent):
            D[curr] = 1 if parent == -1 else D[parent]+1
            if parent != -1:
                P[curr].append(parent)
            i = 0
            while i < len(P[curr]) and i < len(P[P[curr][i]]):
                P[curr].append(P[P[curr][i]][i])
                i += 1
            C[0] += 1
            L[curr] = C[0]

        def divide(curr, parent):
            stk.append(partial(postprocess, curr))
            for i in reversed(range(len(children[curr]))):
                child = children[curr][i]
                if child == parent:
                    continue
                stk.append(partial(divide, child, curr))
            stk.append(partial(preprocess, curr, parent))

        def postprocess(curr):
            R[curr] = C[0]

        N = len(children)
        L, R, D, P, C = [0]*N, [0]*N, [0]*N, [[] for _ in range(N)], [-1]
        stk = []
        stk.append(partial(divide, 0, -1))
        while stk:
            stk.pop()()
        assert(C[0] == N-1)
        self.L, self.R, self.D, self.P = L, R, D, P

    def is_ancestor(self, a, b): 
        return self.L[a] <= self.L[b] <= self.R[b] <= self.R[a]

    def lca(self, a, b):
        if self.D[a] > self.D[b]:
            a, b = b, a
        if self.is_ancestor(a, b):
            return a
        for i in reversed(range(len(self.P[a]))): 
            if i < len(self.P[a]) and not self.is_ancestor(self.P[a][i], b):
                a = self.P[a][i]
        return self.P[a][0]



class Solution2(object):
    def closestNode(self, n, edges, query):
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v), adj[v].append(u)
        tree_infos = TreeInfos2(adj)
        return [max((tree_infos.lca(x, y) for x, y in ((start, end), (start, node), (end, node))), key=lambda x: tree_infos.D[x]) for start, end, node in query]


",nlogn + qlogn
"from functools import partial




class TreeInfos3(object): 
    def __init__(self, children): 
        def preprocess(curr, parent):
            D[curr] = 1 if parent == -1 else D[parent]+1
            P[curr] = parent

        def divide(curr, parent):
            for i in reversed(range(len(children[curr]))):
                child = children[curr][i]
                if child == parent:
                    continue
                stk.append(partial(divide, child, curr))
            stk.append(partial(preprocess, curr, parent))

        N = len(children)
        D, P = [0]*N, [0]*N
        stk = []
        stk.append(partial(divide, 0, -1))
        while stk:
            stk.pop()()
        self.D, self.P = D, P

    def lca(self, a, b): 
        while self.D[a] > self.D[b]:
            a = self.P[a]
        while self.D[a] < self.D[b]:
            b = self.P[b]
        while a != b:
            a, b = self.P[a], self.P[b]
        return a



class Solution3(object):
    def closestNode(self, n, edges, query):
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v), adj[v].append(u)
        tree_infos = TreeInfos3(adj)
        return [max((tree_infos.lca(x, y) for x, y in ((start, end), (start, node), (end, node))), key=lambda x: tree_infos.D[x]) for start, end, node in query]


",n + q * h
"
class Solution4(object):
    def closestNode(self, n, edges, query):
        def bfs(adj, root):
            dist = [len(adj)]*len(adj)
            q = [root]
            dist[root] = 0
            d = 0
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if d+1 >= dist[v]:
                            continue
                        dist[v] = d+1
                        new_q.append(v)
                q = new_q
                d += 1
            return dist

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v), adj[v].append(u)
        dist = [bfs(adj, i) for i in range(n)]
        result = []
        for start, end, node in query:
            x = end
            while start != end:
                if dist[node][start] < dist[node][x]:
                    x = start
                start = next(u for u in adj[start] if dist[u][end] < dist[start][end])
            result.append(x)
        return result


",n^2 + q * n
"
class Solution5(object):
    def closestNode(self, n, edges, query):
        def bfs(adj, root):
            dist = [len(adj)]*len(adj)
            q = [root]
            dist[root] = 0
            d = 0
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if d+1 >= dist[v]:
                            continue
                        dist[v] = d+1
                        new_q.append(v)
                q = new_q
                d += 1
            return dist

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v), adj[v].append(u)
        dist = [bfs(adj, i) for i in range(n)]
        return [max((i for i in range(n) if dist[start][node]+dist[node][end]-2*dist[node][i] == dist[start][i]+dist[i][end]), key=lambda x: dist[node][x]) for start, end, node in query]
",n^2 + q * n
"
import itertools
import heapq


class Solution(object):
    def maxPerformance(self, n, speed, efficiency, k):
        MOD = 10**9 + 7
        result, s_sum = 0, 0
        min_heap = []
        for e, s in sorted(zip(efficiency, speed), reverse=True):
            s_sum += s
            heapq.heappush(min_heap, s)
            if len(min_heap) > k:
                s_sum -= heapq.heappop(min_heap)
            result = max(result, s_sum*e)
        return result % MOD
",nlogn
"

class Solution(object):
    def countPartitions(self, nums, k):
        MOD = 10**9+7
        if sum(nums) < 2*k:
            return 0
        dp = [0]*k
        dp[0] = 1
        for x in nums:
            for i in reversed(range(k-x)):
                dp[i+x] = (dp[i+x]+dp[i])%MOD
        return (pow(2, len(nums), MOD)-2*reduce(lambda total, x: (total+x)%MOD, dp, 0))%MOD
",n * k
"

class Solution(object):
    def minOperations(self, k):
        def isqrt(n):
            a, b = n, (n+1)//2
            while b < a:
                a, b = b, (b+n//b)//2
            return a

        def ceil_divide(a, b):
            return (a+b-1)//b
    
        x = isqrt(k)
        return (x-1)+(ceil_divide(k, x)-1)
",logn
"

class Solution(object):
    def minimizedStringLength(self, s):
        return len(set(s))
",n
"

class Solution(object):
    def calculateTax(self, brackets, income):
        result = prev = 0
        for u, p in brackets:
            result += max((min(u, income)-prev)*p/100.0, 0.0)
            prev = u
        return result
",n
"

class Solution(object):
    def lastNonEmptyString(self, s):
        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        mx = max(cnt)
        result = []
        for x in reversed(s):
            if cnt[ord(x)-ord('a')] != mx:
                continue
            cnt[ord(x)-ord('a')] -= 1
            result.append(x)
        return """".join(reversed(result))
",n
"

class Solution(object):
    def maxCount(self, banned, n, maxSum):
        k = min(int((-1+(1+8*maxSum))**0.5/2), n) 
        total = (k+1)*k//2
        result = k
        lookup = set(banned)
        for x in lookup:
            if x <= k:
                total -= x
                result -= 1
        for i in range(k+1, n+1):
            if i in lookup:
                continue
            if total+i > maxSum:
                break
            total += i
            result += 1
        return result


",b
"import bisect



class Solution2(object):
    def maxCount(self, banned, n, maxSum):
        def check(x):
            return (x+1)*x//2-prefix[bisect.bisect_right(sorted_banned, x)] <= maxSum
    
        sorted_banned = sorted(set(banned))
        prefix = [0]*(len(sorted_banned)+1)
        for i in range(len(sorted_banned)):
            prefix[i+1] = prefix[i]+sorted_banned[i]
        left, right = 1, n
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right-bisect.bisect_right(sorted_banned, right)
",blogb + logn * logb
"

class Solution(object):
    def numberOfPoints(self, nums):
        nums.sort()
        result = 0
        curr = nums[0]
        for i in range(1, len(nums)):
            if nums[i][0] <= curr[1]:
                curr[1] = max(curr[1], nums[i][1])
            else:
                result += curr[1]-curr[0]+1
                curr = nums[i]
        result += curr[1]-curr[0]+1
        return result
",nlogn
"
import collections



class Solution(object):
    def findSafeWalk(self, grid, health):
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        b, t = (0, 0), (len(grid)-1, len(grid[0])-1)
        if not 0+grid[0][0] < health:
            return False
        dq = collections.deque([(b, grid[0][0])])
        lookup = set()
        while dq:
            b, d = dq.popleft()
            if b in lookup:
                continue
            lookup.add(b)
            if b == t:
                return True
            for dr, dc in directions:
                nb = (b[0]+dr, b[1]+dc)
                if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and nb not in lookup):
                    continue
                if not grid[nb[0]][nb[1]]:
                    dq.appendleft((nb, d))
                elif d+1 < health:
                    dq.append((nb, d+1))
        return False
",m * n
"
import collections


class Solution(object):
    def numberOfSubstrings(self, s):
        result = 0
        cnt = collections.Counter()
        for c in s:
            cnt[c] += 1
            result += cnt[c]
        return result


",n
"import collections


class Solution(object):
    def numberOfSubstrings(self, s):
        return sum(v*(v+1)//2 for v in collections.Counter(s).values())
",n
"
class Solution(object):
    def detectCapitalUse(self, word):
        return word.isupper() or word.islower() or word.istitle()

",l
"
import random


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def kthLargestLevelSum(self, root, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        arr = []
        q = [root]
        while q:
            new_q = []
            for u in q:
                if u.left:
                    new_q.append(u.left)
                if u.right:
                    new_q.append(u.right)
            arr.append(sum(x.val for x in q))
            q = new_q
        if k-1 >= len(arr):
            return -1
        nth_element(arr, k-1, compare=lambda a, b: a > b)
        return arr[k-1]
",n
"
class Solution(object):
    def minSubArrayLen(self, s, nums):
        start = 0
        sum = 0
        min_size = float(""inf"")
        for i in range(len(nums)):
            sum += nums[i]
            while sum >= s:
                min_size = min(min_size, i - start + 1)
                sum -= nums[start]
                start += 1

        return min_size if min_size != float(""inf"") else 0

",n
"
class Solution2(object):
    def minSubArrayLen(self, s, nums):
        min_size = float(""inf"")
        sum_from_start = [n for n in nums]
        for i in range(len(sum_from_start) - 1):
            sum_from_start[i + 1] += sum_from_start[i]
        for i in range(len(sum_from_start)):
            end = self.binarySearch(lambda x, y: x <= y, sum_from_start, \
                                    i, len(sum_from_start), \
                                    sum_from_start[i] - nums[i] + s)
            if end < len(sum_from_start):
                min_size = min(min_size, end - i + 1)

        return min_size if min_size != float(""inf"") else 0

    def binarySearch(self, compare, A, start, end, target):
        while start < end:
            mid = start + (end - start) / 2
            if compare(target, A[mid]):
                end = mid
            else:
                start = mid + 1
        return start

",nlogn
"
class Solution(object):
    def stoneGameVIII(self, stones):
        for i in range(len(stones)-1):
            stones[i+1] += stones[i]
        return reduce(lambda curr, i: max(curr, stones[i]-curr), reversed(range(1, len(stones)-1)), stones[-1])
",n
"
import itertools
from functools import reduce



class Solution(object):
    def lengthAfterTransformations(self, s, t, nums):
        MOD = 10**9+7
        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        matrix = [[0]*26 for _ in range(26)]
        for i in range(len(nums)):
            for j in range(1, nums[i]+1):
                matrix[i][(i+j)%26] = 1
        matrix_pow_t = matrix_expo(matrix, t)
        return reduce(lambda accu, x: (accu+x)%MOD, matrix_mult([cnt], matrix_pow_t)[0], 0)
",n + 26^3 * logt
"
class Solution(object):
    def kthSmallestSubarraySum(self, nums, k):
        def check(nums, k, x):
            cnt = curr = left = 0
            for right in range(len(nums)):
                curr += nums[right]
                while curr > x:
                    curr -= nums[left]
                    left += 1
                cnt += right-left+1
            return cnt >= k

        left, right = min(nums), sum(nums)
        while left <= right:
            mid = left + (right-left)//2
            if check(nums, k, mid):
                right = mid-1
            else:
                left = mid+1
        return left
",nlogr
"

class Solution(object):
    def minIncrementOperations(self, nums, k):
        W = 3
        dp = [0]*W
        for i, x in enumerate(nums):
            dp[i%W] = min(dp[j%W] for j in range(i-W, i))+max(k-x, 0)
        return min(dp)
",n
"

MOD = 10**9+7
MAX_N = 1000
fact = [0]*(2*MAX_N-1+1)
inv = [0]*(2*MAX_N-1+1)
inv_fact = [0]*(2*MAX_N-1+1)
fact[0] = inv_fact[0] = fact[1] = inv_fact[1] = inv[1] = 1
for i in range(2, len(fact)):
    fact[i] = fact[i-1]*i % MOD
    inv[i] = inv[MOD%i]*(MOD-MOD//i) % MOD 
    inv_fact[i] = inv_fact[i-1]*inv[i] % MOD

class Solution(object):
    def numberOfSets(self, n, k):
        def nCr(n, k, mod):
            return (fact[n]*inv_fact[n-k] % mod) * inv_fact[k] % mod
        return nCr(n+k-1, 2*k, MOD)


",1
"class Solution2(object):
    def numberOfSets(self, n, k):
        MOD = 10**9+7
        def nCr(n, r): 
            if n-r < r:
                return nCr(n, n-r)
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
        return nCr(n+k-1, 2*k) % MOD
","min(k, min(n - k))"
"
import collections



class Solution(object):
    def validArrangement(self, pairs):
        adj = collections.defaultdict(list)
        degree = collections.defaultdict(int)
        for u, v in pairs: 
            adj[u].append(v)
            degree[u] += 1
            degree[v] -= 1       
        result = []
        stk = [next((u for u, c in degree.items() if c == 1), next(iter(degree.keys())))]
        while stk:
            while adj[stk[-1]]: 
                stk.append(adj[stk[-1]].pop())
            result.append(stk.pop())
        result.reverse()
        return [[result[i], result[i+1]] for i in range(len(result)-1)]
",|V| + |E|
"
class Solution(object):
    def minimumMoves(self, s):
        result = i = 0
        while i < len(s):
            if s[i] == 'X':
                result += 1
                i += 3
            else:
                i += 1
        return result
",n
"
class Solution(object):
    def threeEqualParts(self, A):
        total = sum(A)
        if total % 3 != 0:
            return [-1, -1]
        if total == 0:
            return [0, len(A)-1]

        count = total//3
        nums = [0]*3
        c = 0
        for i in range(len(A)):
            if A[i] == 1:
                if c % count == 0:
                    nums[c//count] = i
                c += 1

        while nums[2] != len(A):
            if not A[nums[0]] == A[nums[1]] == A[nums[2]]:
                return [-1, -1]
            nums[0] += 1
            nums[1] += 1
            nums[2] += 1
        return [nums[0]-1, nums[1]]
",n
"
import itertools


class Solution(object):
    def findAndReplacePattern(self, words, pattern):
        def match(word):
            lookup = {}
            for x, y in zip(pattern, word):
                if lookup.setdefault(x, y) != y:
                    return False
            return len(set(lookup.values())) == len(list(lookup.values()))

        return list(filter(match, words))

",n * l
"

class Solution(object):
    def numberOfPairs(self, nums):
        cnt = [0]*(max(nums)+1)
        pair_cnt = 0
        for x in nums:
            cnt[x] ^= 1
            if not cnt[x]:
                pair_cnt += 1
        return [pair_cnt, len(nums)-2*pair_cnt]


",n
"import collections



class Solution2(object):
    def numberOfPairs(self, nums):
        cnt = collections.Counter(nums)
        pair_cnt = sum(x//2 for x in cnt.values())
        return [pair_cnt, len(nums)-2*pair_cnt]
",n
"
class Solution(object):
    def numberOfBeams(self, bank):
        result = prev = 0
        for x in bank:
            cnt = x.count('1')
            if not cnt:
                continue
            result += prev*cnt
            prev = cnt
        return result
",m * n
"
import bisect


class Solution(object):
    def maximumBeauty(self, items, queries):
        items.sort()
        for i in range(len(items)-1):
            items[i+1][1] = max(items[i+1][1], items[i][1])
        result = []
        for q in queries:
            i = bisect.bisect_left(items, [q+1])
            result.append(items[i-1][1] if i else 0)
        return result
",nlogn + qlogn
"
import operator


class Solution(object):
    def islandPerimeter(self, grid):
        count, repeat = 0, 0

        for i in range(len(grid)):
            for j in range(len(grid[i])):
                if grid[i][j] == 1:
                    count += 1
                    if i != 0 and grid[i - 1][j] == 1:
                        repeat += 1
                    if j != 0 and grid[i][j - 1] == 1:
                        repeat += 1

        return 4*count - 2*repeat




    def islandPerimeter2(self, grid):
        return sum(sum(map(operator.ne, [0] + row, row + [0])) for row in grid + list(map(list, list(zip(*grid)))))

",m * n
"

class Solution(object):
    def minimumSum(self, nums):
        INF = float(""inf"")

        right = [INF]*len(nums)
        curr = INF
        for i in reversed(range(len(nums))):
            right[i] = curr
            curr = min(curr, nums[i])
        result = curr = INF
        for i in range(len(nums)):
            if curr < nums[i] > right[i]:
                result = min(result, curr+nums[i]+right[i])
            curr = min(curr, nums[i])
        return result if result != INF else -1


",n
"
class Solution2(object):
    def minimumSum(self, nums):
        INF = float(""inf"")

        left = [INF]*len(nums)
        curr = INF
        for i in range(len(nums)):
            left[i] = curr
            curr = min(curr, nums[i])
        right = [INF]*len(nums)
        curr = INF
        for i in reversed(range(len(nums))):
            right[i] = curr
            curr = min(curr, nums[i])
        result = INF
        for i in range(len(nums)):
            if left[i] < nums[i] > right[i]:
                result = min(result, left[i]+nums[i]+right[i])
        return result if result != INF else -1
",n
"
class Solution(object):
    def candy(self, ratings):
        candies = [1 for _ in range(len(ratings))]
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i - 1]:
                candies[i] = candies[i - 1] + 1

        for i in reversed(range(1, len(ratings))):
            if ratings[i - 1] > ratings[i] and candies[i - 1] <= candies[i]:
                candies[i - 1] = candies[i] + 1

        return sum(candies)
",n
"
import heapq


class Solution(object):
    def countRestrictedPaths(self, n, edges):
        MOD = 10**9+7
        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            adj[u-1].append((v-1, w))
            adj[v-1].append((u-1, w))
        dist = [float(""inf"")]*n
        dp = [0]*n
        dist[n-1] = 0
        dp[n-1] = 1
        min_heap = [(0, n-1)]
        while min_heap:
            w, u = heapq.heappop(min_heap)
            if w > dist[u]:
                continue
            for v, d in adj[u]:
                if w+d < dist[v]:
                    dist[v] = w+d
                    heapq.heappush(min_heap, (dist[v], v))
                elif w > dist[v]:
                    dp[u] = (dp[u]+dp[v])%MOD
            if u == 0: 
                break
        return dp[0]
",|E| * log|V|
"
import collections



class Solution(object):
    def countPalindromePaths(self, parent, s):
        def iter_dfs():
            result = 0
            cnt = collections.defaultdict(int)
            cnt[0] = 1
            stk = [(0, 0)]
            while stk:
                u, mask = stk.pop()
                if u:
                    mask ^= 1<<(ord(s[u])-ord('a'))
                    result += cnt[mask]+sum(cnt[mask^(1<<i)] if mask^(1<<i) in cnt else 0 for i in range(26))
                    cnt[mask] += 1
                for v in reversed(adj[u]):
                    stk.append((v, mask))
            return result

        adj = [[] for _ in range(len(parent))]
        for u, p in enumerate(parent):
            if p != -1:
                adj[p].append(u)
        return iter_dfs()


",n
"import collections



class Solution2(object):
    def countPalindromePaths(self, parent, s):
        def dfs(u, mask):
            result = 0
            if u:
                mask ^= 1<<(ord(s[u])-ord('a'))
                result += cnt[mask]+sum(cnt[mask^(1<<i)] if mask^(1<<i) in cnt else 0 for i in range(26))
                cnt[mask] += 1
            return result+sum(dfs(v, mask) for v in adj[u])

        adj = [[] for _ in range(len(parent))]
        for u, p in enumerate(parent):
            if p != -1:
                adj[p].append(u)
        cnt = collections.defaultdict(int)
        cnt[0] = 1
        return dfs(0, 0)
",n
"

class Solution(object):
    def missingInteger(self, nums):
        total = nums[0]
        for i in range(1, len(nums)):
            if nums[i] != nums[i-1]+1:
                break
            total += nums[i]
        lookup = set(nums)
        while total in lookup:
            total += 1
        return total
",n
"
import collections


class Solution(object):
    def checkAlmostEquivalent(self, word1, word2):
        k = 3
        cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2)
        return all(abs(cnt1[c]-cnt2[c]) <= k for c in set(list(cnt1.keys())+list(cnt2.keys())))

",n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def recoverFromPreorder(self, S):
        i = 0
        stack = []
        while i < len(S):
            level = 0
            while i < len(S) and S[i] == '-':
                level += 1
                i += 1
            while len(stack) > level:
                stack.pop()
            val = []
            while i < len(S) and S[i] != '-':
                val.append(S[i])
                i += 1
            node = TreeNode(int("""".join(val)))
            if stack:
                if stack[-1].left is None:
                    stack[-1].left = node
                else:
                    stack[-1].right = node
            stack.append(node)
        return stack[0]


",n
"
class Solution2(object):
    def recoverFromPreorder(self, S):
        def recoverFromPreorderHelper(S, level, i):
            j = i[0]
            while j < len(S) and S[j] == '-':
                j += 1 
            if level != j - i[0]:
                return None
            i[0] = j
            while j < len(S) and S[j] != '-':
                j += 1
            node = TreeNode(int(S[i[0]:j]))
            i[0] = j
            node.left = recoverFromPreorderHelper(S, level+1, i)
            node.right = recoverFromPreorderHelper(S, level+1, i)
            return node

        return recoverFromPreorderHelper(S, 0, [0])
",n
"
class Solution(object):
    def numMusicPlaylists(self, N, L, K):
        M = 10**9+7
        dp = [[0 for _ in range(1+L)] for _ in range(2)]
        dp[0][0] = dp[1][1] = 1
        for n in range(1, N+1):
            dp[n % 2][n] = (dp[(n-1) % 2][n-1] * n) % M
            for l in range(n+1, L+1):
                dp[n % 2][l] = ((dp[n % 2][l-1] * max(n-K, 0)) % M + \
                                (dp[(n-1) % 2][l-1] * n) % M) % M
        return dp[N % 2][L]

",n * l
"

class Solution(object):
    def maxConsecutive(self, bottom, top, special):
        special.sort()
        result = max(special[0]-bottom, top-special[-1])
        for i in range(1, len(special)):
            result = max(result, special[i]-special[i-1]-1)
        return result
",nlogn
"

class Solution(object):
    def minimumRecolors(self, blocks, k):
        result = k
        curr = 0
        for i, x in enumerate(blocks):
            curr += int(blocks[i] == 'W')
            if i+1-k < 0:
                continue
            result = min(result, curr)
            curr -= int(blocks[i+1-k] == 'W')
        return result
",n
"
class Solution(object):
    def numberOfSubstrings(self, s):
        result, left = 0, [-1]*3
        for right, c in enumerate(s):
            left[ord(c)-ord('a')] = right
            result += min(left)+1
        return result


",n
"class Solution2(object):
    def numberOfSubstrings(self, s):
        result, left, count = 0, 0, [0]*3
        for right, c in enumerate(s):
            count[ord(s[right])-ord('a')] += 1
            while all(count):
                count[ord(s[left])-ord('a')] -= 1
                left += 1
            result += left
        return result


",n
"class Solution3(object):
    def numberOfSubstrings(self, s):
        result, right, count = 0, 0, [0]*3
        for left, c in enumerate(s):
            while right < len(s) and not all(count):
                count[ord(s[right])-ord('a')] += 1
                right += 1
            if all(count):
                result += (len(s)-1) - (right-1) + 1
            count[ord(c)-ord('a')] -= 1
        return result
",n
"
class Node(object):
    def __init__(self, val, left, right):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def treeToDoublyList(self, root):
        if not root:
            return None
        left_head, left_tail, right_head, right_tail = root, root, root, root
        if root.left:
            left_head = self.treeToDoublyList(root.left)
            left_tail = left_head.left
        if root.right:
            right_head = self.treeToDoublyList(root.right)
            right_tail = right_head.left
        left_tail.right, right_head.left = root, root
        root.left, root.right = left_tail, right_head
        left_head.left, right_tail.right = right_tail, left_head
        return left_head

",n
"

class Solution(object):
    def minimumOperations(self, nums):
        def ceil_divide(a, b):
            return (a+b-1)//b

        mx = max(nums)
        cnt = [0]*mx
        for i in reversed(range(len(nums))):
            cnt[nums[i]-1] += 1
            if cnt[nums[i]-1] == 2:
                return ceil_divide(i+1, 3)
        return 0
",n + r
"

class Solution(object):
    def criticalConnections(self, n, connections):
        def dfs(edges, parent, u, idx, lowlinks, lookup, result):
            if lookup[u]:
                return  
            lookup[u] = True
            curr_idx = lowlinks[u] = idx[0]
            idx[0] += 1
            for v in edges[u]:
                if v == parent:
                    continue
                dfs(edges, u, v, idx, lowlinks, lookup, result)
                lowlinks[u] = min(lowlinks[u], lowlinks[v])
                if lowlinks[v] > curr_idx:
                    result.append([u, v])
        
        edges = [[] for _ in range(n)]
        idx, lowlinks, lookup = [0], [0]*n, [False]*n
        result = []
        for u, v in connections:
            edges[u].append(v)
            edges[v].append(u)
        dfs(edges, -1, 0, idx, lowlinks, lookup, result)
        return result
",|V| + |E|
"
import collections


class Solution(object):
    def maxNumberOfFamilies(self, n, reservedSeats):
        lookup = collections.defaultdict(lambda: [False]*3)
        for r, c in reservedSeats:
            if 2 <= c <= 5:
                lookup[r][0] = True
            if 4 <= c <= 7:
                lookup[r][1] = True
            if 6 <= c <= 9:
                lookup[r][2] = True
        result = 2*n
        for a, b, c in lookup.values():
            if not a and not c:
                continue
            if not a or not b or not c:
                result -= 1
                continue
            result -= 2
        return result


",n
"class Solution2(object):
    def maxNumberOfFamilies(self, n, reservedSeats):
        reservedSeats.sort()
        result, i = 2*n, 0
        while i < len(reservedSeats):
            reserved = [False]*3
            curr = reservedSeats[i][0]
            while i < len(reservedSeats) and reservedSeats[i][0] == curr:
                _, c  = reservedSeats[i]
                if 2 <= c <= 5:
                    reserved[0] = True
                if 4 <= c <= 7:
                    reserved[1] = True
                if 6 <= c <= 9:
                    reserved[2] = True
                i += 1
            if not reserved[0] and not reserved[2]:
                continue
            if not all(reserved):
                result -= 1
                continue
            result -= 2
        return result
",nlogn
"

class Solution(object):
    def firstCompleteIndex(self, arr, mat):
        lookup = {mat[i][j]: (i, j) for i in range(len(mat)) for j in range(len(mat[0]))}
        row = [0]*len(mat)
        col = [0]*len(mat[0])
        for idx, x in enumerate(arr):
            i, j = lookup[x]
            row[i] += 1
            col[j] += 1
            if row[i] == len(mat[0]) or col[j] == len(mat):
                return idx
        return -1
",m * n
"
class Solution(object):
    def nthUglyNumber(self, n, a, b, c):
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        def lcm(x, y):
            return x//gcd(x, y)*y

        def count(x, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c):
            return x//a + x//b + x//c - (x//lcm_a_b + x//lcm_b_c + x//lcm_c_a) + x//lcm_a_b_c

        lcm_a_b, lcm_b_c, lcm_c_a = lcm(a, b), lcm(b, c), lcm(c, a)
        lcm_a_b_c = lcm(lcm_a_b, lcm_b_c)

        left, right = 1, 2*10**9
        while left <= right:
            mid = left + (right-left)//2
            if count(mid, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c) >= n:
                right = mid-1
            else:
                left = mid+1
        return left
",logn
"

class Solution(object):
    def maximizeSquareArea(self, m, n, hFences, vFences):
        MOD = 10**9+7
        def diff(arr, x):
            arr.append(1)
            arr.append(x)
            return {abs(arr[i]-arr[j]) for i in range(len(arr)) for j in range(i+1, len(arr))}

        lookup = diff(hFences, m)
        result = -1
        for x in diff(vFences, n):
            if x in lookup:
                result = max(result, x**2)
        return result%MOD if result != -1 else -1


",h^2 + v^2
"
class Solution2(object):
    def maximizeSquareArea(self, m, n, hFences, vFences):
        MOD = 10**9+7
        def diff(arr, x, check):
            arr.append(1)
            arr.append(x)
            for i in range(len(arr)):
                for j in range(i+1, len(arr)):
                    if not check:
                        lookup.add(abs(arr[i]-arr[j]))
                        continue
                    if abs(arr[i]-arr[j]) in lookup:
                        result[0] = max(result[0], (arr[i]-arr[j])**2)

        if len(hFences) > len(vFences):
            hFences, vFences = vFences, hFences
            m, n = n, m
        result = [-1]
        lookup = set()
        diff(hFences, m, False)
        diff(vFences, n, True)
        return result[0]%MOD if result[0] != -1 else -1
",h^2 + v^2
"

class Solution(object):
    def possibleStringCount(self, word):
        return len(word)-sum(word[i] != word[i+1] for i in range(len(word)-1))


",n
"
class Solution2(object):
    def possibleStringCount(self, word):
        result = 1
        curr = 0
        for i in range(len(word)):
            curr += 1
            if i+1 == len(word) or word[i+1] != word[i]:
                result += curr-1
                curr = 0
        return result
",n
"
class Solution(object):
    def validUtf8(self, data):
        count = 0
        for c in data:
            if count == 0:
                if (c >> 5) == 0b110:
                    count = 1
                elif (c >> 4) == 0b1110:
                    count = 2
                elif (c >> 3) == 0b11110:
                    count = 3
                elif (c >> 7):
                    return False
            else:
                if (c >> 6) != 0b10:
                    return False
                count -= 1
        return count == 0

",n
"

class Solution(object):
    def largestSumOfAverages(self, A, K):
        accum_sum = [A[0]]
        for i in range(1, len(A)):
            accum_sum.append(A[i]+accum_sum[-1])

        dp = [[0]*len(A) for _ in range(2)]
        for k in range(1, K+1):
            for i in range(k-1, len(A)):
                if k == 1:
                    dp[k % 2][i] = float(accum_sum[i])/(i+1)
                else:
                    for j in range(k-2, i):
                        dp[k % 2][i] = \
                            max(dp[k % 2][i],
                                dp[(k-1) % 2][j] +
                                float(accum_sum[i]-accum_sum[j])/(i-j))
        return dp[K % 2][-1]

",k * n^2
"
class Solution(object):
    def maxDiff(self, num):
        digits = str(num)
        for b in digits:
            if b < '9':
                break
        if digits[0] != '1':
            a = digits[0]
        else:
            for a in digits:
                if a > '1':
                    break
        return int(digits.replace(b, '9')) - \
               int(digits.replace(a, '1' if digits[0] != '1' else '0'))
",logn
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def searchBST(self, root, val):
        while root and val != root.val:
            if val < root.val:
                root = root.left
            else:
                root = root.right
        return root

",h
"
import bisect


class Solution(object):
    def lengthOfLIS(self, nums):
        LIS = []
        def insert(target):
            left = bisect.bisect_left(LIS, target)
            if left == len(LIS):
                LIS.append(target)
            else:
                LIS[left] = target
    
        for num in nums:
            insert(num)
        return len(LIS)


",nlogn
"class Solution2(object):
    def lengthOfLIS(self, nums):
        LIS = []
        def insert(target):
            left, right = 0, len(LIS) - 1
            while left <= right:
                mid = left + (right - left) // 2
                if LIS[mid] >= target:
                    right = mid - 1
                else:
                    left = mid + 1
            if left == len(LIS):
                LIS.append(target)
            else:
                LIS[left] = target

        for num in nums:
            insert(num)

        return len(LIS)


",nlogn
"
class Solution3(object):
    def lengthOfLIS(self, nums):
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [default]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret
    
        lookup = {x:i for i, x in enumerate(sorted(set(nums)))}
        bit = BIT(len(lookup), fn=max)
        for x in nums:
            bit.update(lookup[x], bit.query(lookup[x]-1)+1)
        return bit.query(len(lookup)-1)



class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y), 
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h) 
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))


",nlogn
"
class Solution4(object):
    def lengthOfLIS(self, nums):
        val_to_idx = {num:i for i, num in enumerate(sorted(set(nums)))}
        st = SegmentTree(len(val_to_idx))
        for x in nums:
            st.update(val_to_idx[x], val_to_idx[x], st.query(0, val_to_idx[x]-1)+1 if val_to_idx[x] >= 1 else 1)
        return st.query(0, len(val_to_idx)-1) if len(val_to_idx) >= 1 else 0


",nlogn
"
class Solution5(object):
    def lengthOfLIS(self, nums):
        dp = [] 
        for i in range(len(nums)):
            dp.append(1)
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp) if dp else 0

",n^2
"
class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True



class Solution(object):
    def maximumSafenessFactor(self, grid):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        def bfs():
            dist = [[0 if grid[r][c] == 1 else -1 for c in range(len(grid[0]))] for r in range(len(grid))]
            q = [(r, c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]]
            d = 0
            while q:
                new_q = []
                for r, c in q:
                    for dr, dc in DIRECTIONS:
                        nr, nc = r+dr, c+dc
                        if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] == -1):
                            continue
                        dist[nr][nc] = d+1
                        new_q.append((nr, nc))
                q = new_q
                d += 1
            return dist

        dist = bfs()
        buckets = [[] for _ in range((len(grid)-1)+(len(grid[0])-1)+1)]
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                buckets[dist[r][c]].append((r, c))
        lookup = [[False]*len(grid[0]) for _ in range(len(grid))]
        uf = UnionFind(len(grid)*len(grid[0]))
        for d in reversed(range(len(buckets))):
            for r, c in buckets[d]:
                for dr, dc in DIRECTIONS:
                    nr, nc = r+dr, c+dc
                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and lookup[nr][nc] == True):
                        continue
                    uf.union_set(nr*len(grid[0])+nc, r*len(grid[0])+c)
                lookup[r][c] = True
            if uf.find_set(0*len(grid[0])+0) == uf.find_set((len(grid)-1)*len(grid[0])+(len(grid[0])-1)):
                break
        return d


",n^2
"import heapq



class Solution2(object):
    def maximumSafenessFactor(self, grid):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        def bfs():
            dist = [[0 if grid[r][c] == 1 else -1 for c in range(len(grid[0]))] for r in range(len(grid))]
            q = [(r, c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]]
            d = 0
            while q:
                new_q = []
                for r, c in q:
                    for dr, dc in DIRECTIONS:
                        nr, nc = r+dr, c+dc
                        if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] == -1):
                            continue
                        dist[nr][nc] = d+1
                        new_q.append((nr, nc))
                q = new_q
                d += 1
            return dist

        def dijkstra(start, target):
            max_heap = [(-dist[start[0]][start[1]], start)]
            dist[start[0]][start[1]] = -1
            while max_heap:
                curr, u = heapq.heappop(max_heap)
                curr = -curr
                if u == target:
                    return curr
                for dr, dc in DIRECTIONS:
                    nr, nc = u[0]+dr, u[1]+dc
                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] != -1):
                        continue
                    heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))
                    dist[nr][nc] = -1
            return -1

        dist = bfs()
        return dijkstra(dist, (0, 0), (len(grid)-1, len(grid[0])-1)) 


",n^2 * logn
"import heapq



class Solution3(object):
    def maximumSafenessFactor(self, grid):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        def bfs():
            dist = [[0 if grid[r][c] == 1 else -1 for c in range(len(grid[0]))] for r in range(len(grid))]
            q = [(r, c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]]
            d = 0
            while q:
                new_q = []
                for r, c in q:
                    for dr, dc in DIRECTIONS:
                        nr, nc = r+dr, c+dc
                        if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] == -1):
                            continue
                        dist[nr][nc] = d+1
                        new_q.append((nr, nc))
                q = new_q
                d += 1
            return dist
    
        def check(x):
            lookup = [[False]*len(dist[0]) for _ in range(len(dist))]
            q = [(0, 0)]
            lookup[0][0] = True
            while q:
                new_q = []
                for r, c in q:
                    for dr, dc in DIRECTIONS:
                        nr, nc = r+dr, c+dc
                        if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] >= x and not lookup[nr][nc]):
                            continue
                        lookup[nr][nc] = True
                        new_q.append((nr, nc))
                q = new_q
            return lookup[-1][-1]
    
        dist = bfs()
        left, right = 0, dist[0][0]
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right
",n^2 * logn
"

class Solution(object):
    def checkXMatrix(self, grid):
        return all((i-j == 0 or i+j == len(grid)-1) == (grid[i][j] != 0) for i in range(len(grid)) for j in range(len(grid[0])))
",n^2
"
class Solution(object):
    def maxSumAfterOperation(self, nums):
        prev_with_square = prev_without_square = 0
        result = 0
        for num in nums:
            without_square = max(num, num+prev_without_square)
            with_square = max(num*num, num*num+prev_without_square, num+prev_with_square)
            result = max(result, with_square)
            prev_with_square, prev_without_square = with_square, without_square
        return result
",n
"

class Solution(object):
    def maxTargetNodes(self, edges1, edges2, k):
        def centroid_decomposition(adj, k):
            def dfs(u):
                def find_subtree_size(u, p):
                    sizes[u] = 1
                    for v in adj[u]:
                        if v == p or lookup[v]:
                            continue
                        sizes[u] += find_subtree_size(v, u)
                    return sizes[u]

                def find_centroid(u, p):
                    for v in adj[u]:
                        if v == p or lookup[v]:
                            continue
                        if sizes[v]*2 > n:
                            return find_centroid(v, u)
                    return u

                def count(u, p, d):
                    if d > k:
                        return
                    if d-1 == len(cnt):
                        cnt.append(0)
                    cnt[d-1] += 1
                    for v in adj[u]:
                        if v == p or lookup[v]:
                            continue
                        count(v, u, d+1)

                def update(u, p, d):
                    if d > k:
                        return
                    result[u] += total[min(k-d, len(total)-1)]-curr[min(k-d, len(curr)-1)]
                    for v in adj[u]:
                        if v == p or lookup[v]:
                            continue
                        update(v, u, d+1)

                find_subtree_size(u, -1)
                n = sizes[u]
                u = find_centroid(u, -1)
                lookup[u] = True
                max_d = 0
                for v in adj[u]:
                    if lookup[v]:
                        continue
                    cnt = []
                    count(v, u, 0+1)
                    prefix[v].append(0)
                    for d in range(len(cnt)):
                        prefix[v].append(prefix[v][-1]+cnt[d])
                    max_d = max(max_d, len(cnt))
                total = [1]*(max_d+1)
                for v in adj[u]:
                    if lookup[v]:
                        continue
                    for d in range(len(total)):
                        total[d] += prefix[v][min(d, len(prefix[v])-1)]
                result[u] += total[min(k, len(total)-1)]
                for v in adj[u]:
                    if lookup[v]:
                        continue
                    curr, prefix[v] = prefix[v], []
                    update(v, u, 0+1)
                for v in adj[u]:
                    if lookup[v]:
                        continue
                    dfs(v)

            result = [0]*len(adj)
            sizes = [0]*len(adj)
            lookup = [False]*len(adj)
            prefix = [[] for _ in range(len(adj))]
            if k >= 0:
                dfs(0)
            return result

        def find_adj(edges):
            adj = [[] for _ in range(len(edges)+1)]
            for u, v in edges:
                adj[u].append(v)
                adj[v].append(u)
            return adj

        adj2 = find_adj(edges2)
        mx = max(centroid_decomposition(adj2, k-1))
        adj1 = find_adj(edges1)
        return [mx+x for x in centroid_decomposition(adj1, k)]


",nlogn + mlogm
"
class Solution2(object):
    def maxTargetNodes(self, edges1, edges2, k):
        def tree_dp(adj, k):
            def dfs1(u, p):
                for v in adj[u]:
                    if v == p:
                        continue
                    dfs1(v, u)
                dp[u][0] += 1
                for v in adj[u]:
                    if v == p:
                        continue
                    for d in range(k):
                        dp[u][d+1] += dp[v][d]
            
            def dfs2(u, p, curr):
                def update(v, u, curr):
                    new_curr = [0]*len(curr)
                    for d in range(len(curr)-1):
                        new_curr[d+1] = curr[d]+(dp[u][d]-(dp[v][d-1] if d-1 >= 0 else 0))
                    return new_curr

                for v in adj[u]:
                    if v == p:
                        continue
                    dfs2(v, u, update(v, u, curr))
                result[u] = sum(dp[u][i]+curr[i] for i in range(len(curr)))

            result = [0]*len(adj)
            k = min(k, len(adj)-1)
            if k == -1:
                return result
            dp = [[0]*(k+1) for _ in range(len(adj))]
            dfs1(0, -1)
            dfs2(0, -1, [0]*(k+1))
            return result

        def find_adj(edges):
            adj = [[] for _ in range(len(edges)+1)]
            for u, v in edges:
                adj[u].append(v)
                adj[v].append(u)
            return adj
        
        adj2 = find_adj(edges2)
        mx = max(tree_dp(adj2, k-1))
        adj1 = find_adj(edges1)
        return [mx+x for x in tree_dp(adj1, k)]


",(n + m) * k
"
class Solution3(object):
    def maxTargetNodes(self, edges1, edges2, k):
        def bfs(u, adj, k):
            result = 0
            q = [(u, -1)]
            while q:
                if k == -1:
                    break
                k -= 1
                new_q = []
                result += len(q)
                for u, p in q:
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_q.append((v, u))
                q = new_q
            return result
    
        def find_adj(edges):
            adj = [[] for _ in range(len(edges)+1)]
            for u, v in edges:
                adj[u].append(v)
                adj[v].append(u)
            return adj

        adj2 = find_adj(edges2)
        mx = max(bfs(u, adj2, k-1) for u in range(len(adj2)))
        adj1 = find_adj(edges1)
        return [mx+bfs(u, adj1, k) for u in range(len(adj1))]
",n^2 + m^2
"
import threading


class Solution(object):
    def __init__(self):
        self.__cv = threading.Condition()
        self.__has_first = False
        self.__has_second = False

    def first(self, printFirst):
        with self.__cv:
            printFirst()            
            self.__has_first = True
            self.__cv.notifyAll()

    def second(self, printSecond):
        with self.__cv:
            while not self.__has_first:
                self.__cv.wait()
            printSecond()
            self.__has_second = True
            self.__cv.notifyAll()
              
    def third(self, printThird):
        with self.__cv:
            while not self.__has_second:
                self.__cv.wait()
            printThird()
            self.__cv.notifyAll()
        
",n
"
class Solution(object):
    def lastStoneWeightII(self, stones):
        dp = {0}
        for stone in stones:
            dp |= {stone+i for i in dp}
        S = sum(stones)
        return min(abs(i-(S-i)) for i in dp)
",2^n
"
class Solution(object):
    def canPartitionKSubsets(self, nums, k):
        def dfs(nums, target, used, todo, lookup):
            if lookup[used] is None:
                targ = (todo-1)%target + 1
                lookup[used] = any(dfs(nums, target, used | (1<<i), todo-num, lookup) \
                                   for i, num in enumerate(nums) \
                                   if ((used>>i) & 1) == 0 and num <= targ)
            return lookup[used]

        total = sum(nums)
        if total%k or max(nums) > total//k:
            return False
        lookup = [None] * (1 << len(nums))
        lookup[-1] = True
        return dfs(nums, total//k, 0, total, lookup)


",n*2^n
"
class Solution2(object):
    def canPartitionKSubsets(self, nums, k):
        def dfs(nums, target, i, subset_sums):
            if i == len(nums):
                return True
            for k in range(len(subset_sums)):
                if subset_sums[k]+nums[i] > target:
                    continue
                subset_sums[k] += nums[i]
                if dfs(nums, target, i+1, subset_sums):
                    return True
                subset_sums[k] -= nums[i]
                if not subset_sums[k]: break
            return False

        total = sum(nums)
        if total%k != 0 or max(nums) > total//k:
            return False
        nums.sort(reverse=True)
        subset_sums = [0] * k
        return dfs(nums, total//k, 0, subset_sums)

",k^(n-k) * k!
"

class Solution(object):
    def maxScore(self, a, b):
        dp = [float(""-inf"")]*(len(a)+1)
        dp[0] = 0
        for x in b:
            for i in reversed(range(1, len(dp))):
                dp[i] = max(dp[i], dp[i-1]+x*a[i-1])
        return dp[-1]
",n
"
class Solution(object):
    def largestNumber(self, num):
        num = [str(x) for x in num]
        num.sort(cmp=lambda x, y: cmp(y + x, x + y))
        largest = ''.join(num)
        return largest.lstrip('0') or '0'

",nlogn
"
import collections
import functools


class Solution(object):
    def boldWords(self, words, S):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for i, word in enumerate(words):
            functools.reduce(dict.__getitem__, word, trie).setdefault(""_end"")

        lookup = [False] * len(S)
        for i in range(len(S)):
            curr = trie
            k = -1
            for j in range(i, len(S)):
                if S[j] not in curr:
                    break
                curr = curr[S[j]]
                if ""_end"" in curr:
                    k = j
            for j in range(i, k+1):
                lookup[j] = True

        result = []
        for i in range(len(S)):
            if lookup[i] and (i == 0 or not lookup[i-1]):
                result.append(""<b>"")
            result.append(S[i])
            if lookup[i] and (i == len(S)-1 or not lookup[i+1]):
                result.append(""</b>"")
        return """".join(result)


",n * l
"class Solution2(object):
    def boldWords(self, words, S):
        lookup = [0] * len(S)
        for d in words:
            pos = S.find(d)
            while pos != -1:
                lookup[pos:pos+len(d)] = [1] * len(d)
                pos = S.find(d, pos+1)

        result = []
        for i in range(len(S)):
            if lookup[i] and (i == 0 or not lookup[i-1]):
                result.append(""<b>"")
            result.append(S[i])
            if lookup[i] and (i == len(S)-1 or not lookup[i+1]):
                result.append(""</b>"")
        return """".join(result)

",n * d * l
"
import collections
from sortedcontainers import SortedList



class Solution(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = (self.__bit[i]+val) % MOD
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret = (ret+self.__bit[i]) % MOD
                    i -= (i & -i)
                return ret

        def update(accu, d):
            i = sl.bisect_left(idxs[x][-1])
            accu = (accu + d*(len(nums)*(2*len(sl)-1) - (2*i+1)*idxs[x][-1] - 2*(bit.query(len(nums)-1)-bit.query(idxs[x][-1])))) % MOD
            bit.add(idxs[x][-1], d*idxs[x][-1])
            return accu

        idxs = collections.defaultdict(list)
        for i in reversed(range(len(nums))):
            idxs[nums[i]].append(i)
        result = 0
        sl = SortedList(idxs[x][-1] for x in idxs)
        accu = (len(nums)*len(sl)**2) % MOD
        for i, x in enumerate(sl):
            accu = (accu-(2*i+1)*x) % MOD
        bit = BIT(len(nums))
        for x in sl:
            bit.add(x, x)
        for x in nums:
            result = (result+accu) % MOD 
            accu = update(accu, -1)
            del sl[0]
            idxs[x].pop()
            if not idxs[x]:
                continue
            sl.add(idxs[x][-1])
            accu = update(accu, +1)
        assert(accu == 0)
        return result


",nlogn
"
class Solution2(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=None,
                         query_fn=lambda x, y: y if x is None else x if y is None else (x+y)%MOD,
                         update_fn=lambda x, y: y if x is None else (x+y)%MOD):
                self.tree = [None]*(1<<((N-1).bit_length()+1))
                self.base = len(self.tree)>>1
                self.lazy = [None]*self.base
                self.query_fn = query_fn
                self.update_fn = update_fn
                if build_fn is not None:
                    for i in range(self.base, self.base+N):
                        self.tree[i] = build_fn(i-self.base)
                    for i in reversed(range(1, self.base)):
                        self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])
                self.count = [1]*len(self.tree) 
                for i in reversed(range(1, self.base)): 
                    self.count[i] = self.count[i<<1] + self.count[(i<<1)+1]

            def __apply(self, x, val):
                self.tree[x] = self.update_fn(self.tree[x], val*self.count[x]) 
                if x < self.base:
                    self.lazy[x] = self.update_fn(self.lazy[x], val)

            def __push(self, x):
                for h in reversed(range(1, x.bit_length())):
                    y = x>>h
                    if self.lazy[y] is not None:
                        self.__apply(y<<1, self.lazy[y])
                        self.__apply((y<<1)+1, self.lazy[y])
                        self.lazy[y] = None

            def update(self, L, R, h): 
                def pull(x):
                    while x > 1:
                        x >>= 1
                        self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])
                        if self.lazy[x] is not None:
                            self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x]) 

                L += self.base
                R += self.base
                L0, R0 = L, R
                while L <= R:
                    if L & 1: 
                        self.__apply(L, h)
                        L += 1
                    if R & 1 == 0: 
                        self.__apply(R, h)
                        R -= 1
                    L >>= 1
                    R >>= 1
                pull(L0)
                pull(R0)

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                self.__push(L)
                self.__push(R)
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L >>= 1
                    R >>= 1
                return self.query_fn(left, right)

        result = accu = 0
        sl = {}
        st = SegmentTree(len(nums))
        for i in range(len(nums)):
            j = sl[nums[i]] if nums[i] in sl else -1
            accu = (accu+((i-j)+2*max(st.query(j+1, i), 0)))%MOD
            result = (result+accu)%MOD
            st.update(j+1, i, 1) 
            sl[nums[i]] = i
        return result


",nlogn
"
class Solution3(object):
    def sumCounts(self, nums):
        MOD = 10**9+7
        result = 0
        for i in range(len(nums)):
            lookup = set()
            for j in reversed(range(i+1)):
                lookup.add(nums[j])
                result = (result+len(lookup)**2) % MOD
        return result
",n^2
"
import collections


class Solution(object):
    def distinctSubseqII(self, S):
        MOD = 10**9+7
        result, dp = 0, [0]*26
        for c in S:
            result, dp[ord(c)-ord('a')] = (result+((result+1)-dp[ord(c)-ord('a')]))%MOD, (result+1)%MOD
        return result
",n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def longestZigZag(self, root):
        def dfs(node, result):
            if not node:
                return [-1, -1]
            left, right = dfs(node.left, result), dfs(node.right, result)
            result[0] = max(result[0], left[1]+1, right[0]+1)
            return [left[1]+1, right[0]+1]

        result = [0]
        dfs(root, result)
        return result[0]
",n
"
class Solution(object):
    def partitionDisjoint(self, A):
        B = A[:]
        for i in reversed(range(len(A)-1)):
            B[i] = min(B[i], B[i+1])
        p_max = 0
        for i in range(1, len(A)):
            p_max = max(p_max, A[i-1])
            if p_max <= B[i]:
                return i

",n
"

class Solution(object):
    def countBeautifulPairs(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result = 0
        cnt = [0]*10
        for x in nums:
            for i in range(1, 10):
                if gcd(i, x%10) == 1:
                    result += cnt[i]
            while x >= 10:
                x //= 10
            cnt[x] += 1
        return result
",nlogr
"
class Solution(object):
    def twoSumLessThanK(self, A, K):
        A.sort()
        result = -1
        left, right = 0, len(A)-1
        while left < right:
            if A[left]+A[right] >= K:
                right -= 1
            else:
                result = max(result, A[left]+A[right])
                left += 1
        return result
",nlogn
"
class Solution(object):
    def maxCount(self, m, n, ops):
        for op in ops:
            m = min(m, op[0])
            n = min(n, op[1])
        return m*n

",p
"

class Solution(object):
    def maxScore(self, grid):
        POS_INF = float(""inf"")
        NEG_INF = float(""-inf"")
        result = NEG_INF
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                mn = POS_INF
                if i-1 >= 0:
                    mn = min(mn, grid[i-1][j])
                if j-1 >= 0:
                    mn = min(mn, grid[i][j-1])
                result = max(result, grid[i][j]-mn)
                grid[i][j] = min(grid[i][j], mn)
        return result
",m * n
"
import collections


class Solution(object):
    def findLHS(self, nums):
        lookup = collections.defaultdict(int)
        result = 0
        for num in nums:
            lookup[num] += 1
            for diff in [-1, 1]:
                if (num + diff) in lookup:
                    result = max(result, lookup[num] + lookup[num + diff])
        return result

",n
"
import collections


class Solution(object):
    def colorBorder(self, grid, r0, c0, color):
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        lookup, q, borders = set([(r0, c0)]), collections.deque([(r0, c0)]), []
        while q:
            r, c = q.popleft()
            is_border = False

            for direction in directions:
                nr, nc = r+direction[0], c+direction[1]
                if not ((0 <= nr < len(grid)) and \
                        (0 <= nc < len(grid[0])) and \
                        grid[nr][nc] == grid[r][c]):
                    is_border = True
                    continue
                if (nr, nc) in lookup:
                    continue
                lookup.add((nr, nc))
                q.append((nr, nc))

            if is_border:
                borders.append((r, c))

        for r, c in borders:
            grid[r][c] = color
        return grid
    
",m * n
"
import collections


class Solution(object):
    def possibleBipartition(self, N, dislikes):
        adj = [[] for _ in range(N)]
        for u, v in dislikes:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)

        color = [0]*N
        color[0] = 1
        q = collections.deque([0])
        while q:
            cur = q.popleft()
            for nei in adj[cur]:
                if color[nei] == color[cur]:
                    return False
                elif color[nei] == -color[cur]:
                    continue
                color[nei] = -color[cur]
                q.append(nei)
        return True
 

",|V| + |E|
"
class Solution(object):
    def validateStackSequences(self, pushed, popped):
        i = 0
        s = []
        for v in pushed:
            s.append(v)
            while s and i < len(popped) and s[-1] == popped[i]:
                s.pop()
                i += 1
        return i == len(popped)
",n
"
class Solution(object):
    def tictactoe(self, moves):
        row, col = [[0]*3 for _ in range(2)], [[0]*3 for _ in range(2)]
        diag, anti_diag = [0]*2, [0]*2
        p = 0
        for r, c in moves:
            row[p][r] += 1
            col[p][c] += 1
            diag[p] += r == c
            anti_diag[p] += r+c == 2
            if 3 in (row[p][r], col[p][c], diag[p], anti_diag[p]):
                return ""AB""[p]
            p ^= 1
        return ""Draw"" if len(moves) == 9 else ""Pending""
",1
"

class Solution(object):
    def specialArray(self, nums):
        MAX_NUM = 1000
        count = [0]*(MAX_NUM+1)
        for num in nums:
            count[num] += 1
        n = len(nums)
        for i in range(len(count)):
            if i == n:
                return i
            n -= count[i]
        return -1


",n
"
class Solution2(object):
    def specialArray(self, nums):
        MAX_NUM = 1000
        def inplace_counting_sort(nums, reverse=False): 
            count = [0]*(MAX_NUM+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()
    
        inplace_counting_sort(nums, reverse=True)
        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if nums[mid] <= mid:
                right = mid-1
            else:
                left = mid+1
        return -1 if left < len(nums) and nums[left] == left else left


",n
"
class Solution3(object):
    def specialArray(self, nums):
        MAX_NUM = 1000
        def counting_sort(nums, reverse=False): 
            count = [0]*(MAX_NUM+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            result = [0]*len(nums)
            if not reverse:
                for num in reversed(nums): 
                    count[num] -= 1
                    result[count[num]] = num
            else:
                for num in nums: 
                    count[num] -= 1
                    result[count[num]] = num
                result.reverse()
            return result
    
        nums = counting_sort(nums, reverse=True) 
        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if nums[mid] <= mid:
                right = mid-1
            else:
                left = mid+1
        return -1 if left < len(nums) and nums[left] == left else left


",n
"
class Solution4(object):
    def specialArray(self, nums):
        nums.sort(reverse=True) 
        for i in range(len(nums)): 
            if nums[i] <= i:
                break
        else:
            i += 1
        return -1 if i < len(nums) and nums[i] == i else i
",nlogn
"
import itertools


class Solution(object):
    def areAlmostEqual(self, s1, s2):
        diff = []
        for a, b in zip(s1, s2):
            if a == b:
                continue
            if len(diff) == 2:
                return False
            diff.append([a, b] if not diff else [b, a])
        return not diff or (len(diff) == 2 and diff[0] == diff[1])
",n
"
class Solution(object):
    def isTransformable(self, s, t):
        idxs = [[] for _ in range(10)]
        for i in reversed(range(len(s))):
            idxs[int(s[i])].append(i)
        for c in t:
            d = int(c)
            if not idxs[d]:
                return False
            for k in range(d): 
                if idxs[k] and idxs[k][-1] < idxs[d][-1]:
                    return False
            idxs[d].pop()
        return True
",n
"
class Solution(object):
    def getFood(self, grid):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        q = []
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == '*':
                    q.append((r, c))
                    break
        
        result = 0
        while q:
            result += 1
            new_q = []
            for r, c in q:
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 <= nr < len(grid) and
                            0 <= nc < len(grid[0]) and
                            grid[nr][nc] != 'X'):
                        continue
                    if grid[nr][nc] == 
                        return result
                    grid[nr][nc] = 'X'
                    new_q.append((nr, nc))
            q = new_q 
        return -1
",m * n
"

class Solution(object):
    def handleQuery(self, nums1, nums2, queries):
        class SegmentTree(object): 
            def __init__(self, N,
                        build_fn=lambda _: 0,
                        query_fn=lambda x, y: y if x is None else max(x, y),
                        update_fn=lambda x, y: y if x is None else x+y):
                self.base = N
                self.H = (N-1).bit_length()
                self.query_fn = query_fn
                self.update_fn = update_fn
                self.tree = [None]*(2*N)
                self.lazy = [None]*N
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def __apply(self, x, val):
                self.tree[x] = self.update_fn(self.tree[x], val)
                if x < self.base:
                    self.lazy[x] = self.update_fn(self.lazy[x], val)

            def update(self, L, R, h): 
                def pull(x):
                    while x > 1:
                        x >>= 1
                        self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])
                        if self.lazy[x] is not None:
                            self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

                if L > R:
                    return
                L += self.base
                R += self.base
                L0, R0 = L, R
                while L <= R:
                    if L & 1: 
                        self.__apply(L, h)
                        L += 1
                    if R & 1 == 0: 
                        self.__apply(R, h)
                        R -= 1
                    L >>= 1
                    R >>= 1
                pull(L0)
                pull(R0)

            def query(self, L, R): 
                def push(x):
                    n = self.H
                    while n:
                        y = x >> n
                        if self.lazy[y] is not None:
                            self.__apply(y<<1, self.lazy[y])
                            self.__apply((y<<1)+1, self.lazy[y])
                            self.lazy[y] = None
                        n -= 1

                result = None
                if L > R:
                    return result

                L += self.base
                R += self.base
                push(L)
                push(R)
                while L <= R:
                    if L & 1: 
                        result = self.query_fn(result, self.tree[L])
                        L += 1
                    if R & 1 == 0: 
                        result = self.query_fn(result, self.tree[R])
                        R -= 1
                    L >>= 1
                    R >>= 1
                return result

        st = SegmentTree(len(nums1),
                         build_fn=lambda i: (nums1[i], nums1[i]^1),
                         query_fn=lambda x, y: y if x is None else (x[0]+y[0], x[1]+y[1]),
                         update_fn=lambda x, y: y if x is None else (x[1], x[0]) if y == (1, 0) else x)
        result = []
        total = sum(nums2)
        for t, a, b in queries:
            if t == 1:
                st.update(a, b, (1, 0))
            elif t == 2:
                total += st.query(0, len(nums1)-1)[0]*a
            elif t == 3:
                result.append(total)
        return result
",nlogn + m + qlogn
"
class Solution(object):
    def maxDistance(self, arrays):
        result, min_val, max_val = 0,  arrays[0][0], arrays[0][-1]
        for i in range(1, len(arrays)):
            result = max(result, \
                         max(max_val - arrays[i][0], \
                             arrays[i][-1] - min_val))
            min_val = min(min_val, arrays[i][0])
            max_val = max(max_val, arrays[i][-1])
        return result

",n
"
class Solution(object):
    def find132pattern(self, nums):
        ak = float(""-inf"")
        stk = []
        for i in reversed(range(len(nums))):
            if nums[i] < ak:
                return True
            while stk and stk[-1] < nums[i]:
                ak = stk.pop()
            stk.append(nums[i])
        return False


",n
"class Solution_TLE(object):
    def find132pattern(self, nums):
        for k in range(len(nums)):
            valid = False
            for j in range(k):
                if nums[j] < nums[k]:
                    valid = True
                elif nums[j] > nums[k]:
                    if valid:
                        return True
        return False
",n^2
"
class Solution(object):
    def checkIfPrerequisite(self, n, prerequisites, queries):
        def floydWarshall(n, graph): 
            reachable = set([x[0]*n+x[1] for x in graph]) 
            for k in range(n): 
                for i in range(n): 
                    for j in range(n): 
                        if i*n+j not in reachable and (i*n+k in reachable and k*n+j in reachable):
                            reachable.add(i*n+j)
            return reachable

        reachable = floydWarshall(n, prerequisites)
        return [i*n+j in reachable for i, j in queries]


",n^3
"import collections


class Solution2(object):
    def checkIfPrerequisite(self, n, prerequisites, queries):
        graph = collections.defaultdict(list)
        for u, v in prerequisites:
            graph[u].append(v)
        result = []
        for i, j in queries:
            stk, lookup = [i], set([i])
            while stk:
                node = stk.pop()
                for nei in graph[node]:
                    if nei in lookup:
                        continue
                    stk.append(nei)
                    lookup.add(nei)
            result.append(j in lookup)
        return result
",n * q
"
import math


class Solution(object):
    def bulbSwitch(self, n):
        return int(math.sqrt(n))

",1
"
class Solution(object):
    def reductionOperations(self, nums):
        nums.sort()
        result = curr = 0
        for i in range(1, len(nums)): 
            if nums[i-1] < nums[i]:
                curr += 1
            result += curr
        return result
",nlogn
"

class Solution(object):
    def minChanges(self, s):
        return sum(s[i] != s[i+1] for i in range(0, len(s), 2))
",n
"

class Solution(object):
    def minOperations(self, nums, k):
        def popcount(x):
            return bin(x).count('1')
    
        return popcount(reduce(lambda x, y: x^y, nums, k))
",n
"

class Solution(object):
    def maximizeWin(self, prizePositions, k):
        dp = [0]*(len(prizePositions)+1)
        result = left = 0
        for right in range(len(prizePositions)):
            while prizePositions[right]-prizePositions[left] > k:
                left += 1
            dp[right+1] = max(dp[right], right-left+1)
            result = max(result, dp[left]+(right-left+1))
        return result
",n
"
class Solution(object):
    def pathInZigZagTree(self, label):
        count = 2**label.bit_length()
        result = []
        while label >= 1:
            result.append(label)
            label = ((count//2) + ((count-1)-label)) // 2
            count //= 2
        result.reverse()
        return result
",logn
"
class Solution(object):
    def breakPalindrome(self, palindrome):
        for i in range(len(palindrome)//2):
            if palindrome[i] != 'a':
                return palindrome[:i] + 'a' + palindrome[i+1:]
        return palindrome[:-1] + 'b' if len(palindrome) >= 2 else """"
",n
"
class Solution(object):
    def numRookCaptures(self, board):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        r, c = None, None
        for i in range(8):
            if r is not None:
                break
            for j in range(8):
                if board[i][j] == 'R':
                    r, c = i, j
                    break

        result = 0
        for d in directions:
            nr, nc = r+d[0], c+d[1]
            while 0 <= nr < 8 and 0 <= nc < 8:
                if board[nr][nc] == 'p':
                    result += 1
                if board[nr][nc] != '.':
                    break
                nr, nc= nr+d[0], nc+d[1]
        return result
",1
"
class Solution(object):
    def maximalRectangle(self, matrix):
        def largestRectangleArea(heights):
            stk, result, i = [-1], 0, 0
            for i in range(len(heights)+1):
                while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):
                    result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))
                stk.append(i) 
            return result

        if not matrix:
            return 0
        result = 0
        heights = [0]*len(matrix[0])
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0
            result = max(result, largestRectangleArea(heights))
        return result


",n^2
"
class Solution2(object):
    def maximalRectangle(self, matrix):
        if not matrix:
            return 0

        result = 0
        m = len(matrix)
        n = len(matrix[0])
        L = [0 for _ in range(n)]
        H = [0 for _ in range(n)]
        R = [n for _ in range(n)]

        for i in range(m):
            left = 0
            for j in range(n):
                if matrix[i][j] == '1':
                    L[j] = max(L[j], left)
                    H[j] += 1
                else:
                    L[j] = 0
                    H[j] = 0
                    R[j] = n
                    left = j + 1

            right = n
            for j in reversed(range(n)):
                if matrix[i][j] == '1':
                    R[j] = min(R[j], right)
                    result = max(result, H[j] * (R[j] - L[j]))
                else:
                    right = j

        return result

",n^2
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def balanceBST(self, root):
        def inorderTraversal(root):
            result, stk = [], [(root, False)]
            while stk:
                node, is_visited = stk.pop()
                if node is None:
                    continue
                if is_visited:
                    result.append(node.val)
                else:
                    stk.append((node.right, False))
                    stk.append((node, True))
                    stk.append((node.left, False))
            return result
    
        def sortedArrayToBst(arr):
            ROOT, LEFT, RIGHT = list(range(3))
            result = [None]
            stk = [(0, len(arr), ROOT, result)]
            while stk:
                i, j, update, ret = stk.pop()
                if i >= j:
                    continue
                mid = i + (j-i)//2
                node = TreeNode(arr[mid])
                if update == ROOT:
                    ret[0] = node
                elif update == LEFT:
                    ret[0].left = node
                else:
                    ret[0].right = node
                stk.append((mid+1, j, RIGHT, [node]))
                stk.append((i, mid, LEFT, [node]))
            return result[0]
        
        return sortedArrayToBst(inorderTraversal(root))


",n
"
class Solution2(object):
    def balanceBST(self, root):
        def inorderTraversalHelper(node, arr):
            if not node:
                return
            inorderTraversalHelper(node.left, arr)
            arr.append(node.val)
            inorderTraversalHelper(node.right, arr)
        
        def sortedArrayToBstHelper(arr, i, j):
            if i >= j:
                return None
            mid = i + (j-i)//2
            node = TreeNode(arr[mid])
            node.left = sortedArrayToBstHelper(arr, i, mid)
            node.right = sortedArrayToBstHelper(arr, mid+1, j)
            return node
        
        arr = []
        inorderTraversalHelper(root, arr)
        return sortedArrayToBstHelper(arr, 0, len(arr))
",n
"

class Solution(object):
    def maxRemovals(self, source, pattern, targetIndices):
        dp = [float(""-inf"")]*(len(pattern)+1)
        dp[0] = 0
        lookup = [False]*len(source)
        for x in targetIndices:
            lookup[x] = True
        for i in range(len(source)):
            for j in reversed(range(len(pattern)+1)):
                dp[j] += lookup[i]
                if j-1 >= 0 and pattern[j-1] == source[i]:
                    dp[j] = max(dp[j], dp[j-1])
        return dp[-1]
",n * m
"
import collections
import bisect


class Solution(object):
    def makeArrayIncreasing(self, arr1, arr2):
        arr2 = sorted(set(arr2))
        dp = {0: -1} 
        for val1 in arr1:
            next_dp = collections.defaultdict(lambda: float(""inf""))
            for cost, val in dp.items():
                if val < val1:
                    next_dp[cost] = min(next_dp[cost], val1)
                k = bisect.bisect_right(arr2, val)
                if k == len(arr2):
                    continue
                next_dp[cost+1] = min(next_dp[cost+1], arr2[k])
            dp = next_dp
            if not dp:
                return -1
        return min(dp.keys())
",n^2 * logn
"
class Node(object):
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child


class Solution(object):
    def flatten(self, head):
        curr = head
        while curr:
            if curr.child:
                curr_next = curr.__next__
                curr.child.prev = curr
                curr.next = curr.child
                last_child = curr
                while last_child.__next__:
                    last_child = last_child.__next__
                if curr_next:
                    last_child.next = curr_next
                    curr_next.prev = last_child
                curr.child = None
            curr = curr.__next__
        return head

",n
"

class Solution(object):
    def minOrAfterOperations(self, nums, k):
        result = 0
        l = max(nums).bit_length()
        mask = (1<<l)-1
        for i in reversed(range(l)):
            result <<= 1
            curr, cnt = mask, 0
            for x in nums:
                curr &= x>>i
                if curr&~result:
                    cnt += 1
                else:
                    curr = mask
            if cnt > k:
                result += 1
        return result
",nlogr
"

class Solution(object):
    def minimumReplacement(self, nums):
        def ceil_divide(a, b):
            return (a+b-1)//b

        result = 0
        curr = nums[-1]
        for x in reversed(nums):
            cnt = ceil_divide(x, curr)
            result += cnt-1
            curr = x//cnt
        return result
",n
"

class Solution(object):
    def minCostSetTime(self, startAt, moveCost, pushCost, targetSeconds):
        def cost(m, s):
            if not (0 <= m <= 99 and s <= 99):
                return float(""inf"")
            result = 0
            curr = startAt
            for x in map(int, list(str(m*100 + s))):
                result += (moveCost if x != curr else 0)+pushCost
                curr = x
            return result

        m, s = divmod(targetSeconds, 60)
        return min(cost(m, s), cost(m-1, s+60))
",1
"
class Solution(object):
    def isValidSerialization(self, preorder):
        def split_iter(s, tok):
            start = 0
            for i in range(len(s)):
                if s[i] == tok:
                    yield s[start:i]
                    start = i + 1
            yield s[start:]

        if not preorder:
            return False

        depth, cnt = 0, preorder.count(',') + 1
        for tok in split_iter(preorder, ','):
            cnt -= 1
            if tok == 
                depth -= 1
                if depth < 0:
                    break
            else:
                depth += 1
        return cnt == 0 and depth < 0

",n
"

class Solution(object):
    def maxJump(self, stones):
        return stones[1]-stones[0] if len(stones) == 2 else max(stones[i+2]-stones[i] for i in range(len(stones)-2))
",n
"
import collections



class Solution(object):
    def countDivisibleSubstrings(self, word):
        result = 0
        for d in range(1, 10):
            prefix = 0
            cnt = collections.Counter([0+d*(-1+1)])
            for i, x in enumerate(word):
                prefix += (ord(x)-ord('a')+1)//3+1
                result += cnt[prefix-d*(i+1)]
                cnt[prefix-d*(i+1)] += 1
        return result
",d * n
"
import collections


class Solution(object):
    def slowestKey(self, releaseTimes, keysPressed):
        result, lookup = 'a', collections.Counter()
        for i, c in enumerate(keysPressed):
            lookup[c] = max(lookup[c], releaseTimes[i]-(releaseTimes[i-1] if i > 0 else 0))
            if lookup[c] > lookup[result] or lookup[c] == lookup[result] and c > result:
                result = c
        return result
",n
"
class Solution(object):
    def triangleNumber(self, nums):
        result = 0
        nums.sort()
        for i in reversed(range(2, len(nums))):
            left, right = 0, i-1
            while left < right:
                if nums[left]+nums[right] > nums[i]:
                    result += right-left
                    right -= 1
                else:
                    left += 1
        return result


",n^2
"class Solution2(object):
    def triangleNumber(self, nums):
        result = 0
        nums.sort()
        for i in range(len(nums)-2):
            if nums[i] == 0:
                continue
            k = i+2
            for j in range(i+1, len(nums)-1):
                while k < len(nums) and nums[i] + nums[j] > nums[k]:
                    k += 1
                result += k-j-1
        return result

",n^2
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def upsideDownBinaryTree(self, root):
        p, parent, parent_right = root, None, None

        while p:
            left = p.left
            p.left = parent_right
            parent_right = p.right
            p.right = parent
            parent = p
            p = left

        return parent


",n
"class Solution2(object):
    def upsideDownBinaryTree(self, root):
        return self.upsideDownBinaryTreeRecu(root, None)

    def upsideDownBinaryTreeRecu(self, p, parent):
        if p is None:
            return parent

        root = self.upsideDownBinaryTreeRecu(p.left, p)
        if parent:
            p.left = parent.right
        else:
            p.left = None
        p.right = parent

        return root

",n
"

class Solution(object):
    def totalNumbers(self, digits):
        cnt = [0]*10
        for x in digits:
            cnt[x] += 1
        even = sum(cnt[i] != 0 for i in range(0, len(cnt), 2))
        odd = sum(cnt[i] != 0 for i in range(1, len(cnt), 2))
        result = 0
        for i in range(2, len(cnt), 2):
            if cnt[i] >= 3:
                result += 1 
        result += even*(odd+even-1)*(odd+even-2) 
        if cnt[0]:
            result -= 1*(even-1)*(odd+even-2) 
        for i in range(len(cnt)):
            if cnt[i] < 2:
                continue
            if i == 0:
                result += (odd+even)-1 
            elif i%2:
                result += even 
            else:
                result += 3*(even-1)-int(cnt[0] != 0) 
                result += 2*odd 
        return result
",n
"

class Solution(object):
    def countKConstraintSubstrings(self, s, k):
        result = cnt = left = 0
        for right in range(len(s)):
            cnt += int(s[right] == '1')
            while not (cnt <= k or (right-left+1)-cnt <= k):
                cnt -= int(s[left] == '1')
                left += 1
            result += right-left+1
        return result
",n
"

class Solution(object):
    def maxAdjacentDistance(self, nums):
        return max(abs(nums[i]-nums[i-1]) for i in range(len(nums)))
",n
"
class Solution(object):
    def createTargetArray(self, nums, index):
        for i in range(len(nums)):
            for j in range(i):
                if index[j] >= index[i]:
                    index[j] += 1
        result = [0]*(len(nums))
        for i in range(len(nums)):
            result[index[i]] = nums[i]
        return result


",n^2
"import itertools


class Solution2(object):
    def createTargetArray(self, nums, index):
        result = []
        for i, x in zip(index, nums):
            result.insert(i, x)
        return result

",n^2
"
import heapq


class Solution(object):
    def findSecondMinimumValue(self, root):
        def findSecondMinimumValueHelper(root, max_heap, lookup):
            if not root:
                return
            if root.val not in lookup:
                heapq.heappush(max_heap, -root.val)
                lookup.add(root.val)
                if len(max_heap) > 2:
                    lookup.remove(-heapq.heappop(max_heap))
            findSecondMinimumValueHelper(root.left, max_heap, lookup)
            findSecondMinimumValueHelper(root.right, max_heap, lookup)

        max_heap, lookup = [], set()
        findSecondMinimumValueHelper(root, max_heap, lookup)
        if len(max_heap) < 2:
            return -1
        return -max_heap[0]

",n
"

class Solution(object):
    def maxScore(self, nums, x):
        dp = [float(""-inf"")]*2
        dp[nums[0]%2] = nums[0]
        for i in range(1, len(nums)):
            dp[nums[i]%2] = max(dp[nums[i]%2], dp[(nums[i]+1)%2]-x)+nums[i]
        return max(dp)
",n
"
import collections



class Solution(object):
    def isItPossible(self, word1, word2):
        cnt1 = collections.Counter(word1)
        cnt2 = collections.Counter(word2)
        for i in cnt1.keys():
            for j in cnt2.keys():
                if i == j:
                    if len(cnt1) == len(cnt2):
                        return True
                else:
                    new_c1, new_c2 = len(cnt1), len(cnt2)
                    if cnt1[i] == 1:
                        new_c1 -= 1
                    if j not in cnt1:
                        new_c1 += 1
                    if cnt2[j] == 1:
                        new_c2 -= 1
                    if i not in cnt2:
                        new_c2 += 1
                    if new_c1 == new_c2:
                        return True
        return False
",m + n + 26^2
"
class Solution(object):
    def change(self, amount, coins):
        dp = [0] * (amount+1)
        dp[0] = 1
        for coin in coins:
            for i in range(coin, amount+1):
                dp[i] += dp[i-coin]
        return dp[amount]

",n * m
"

MAX_R = 10**4
LOOKUP = [-1]*MAX_R
class Solution(object):
    def countSymmetricIntegers(self, low, high):
        def check(x):
            if LOOKUP[x-1] == -1:
                digits = list(map(int, str(x)))
                if len(digits)%2:
                    LOOKUP[x-1] = 0
                else:
                    LOOKUP[x-1] = int(sum(digits[i] for i in range(len(digits)//2)) == sum(digits[i] for i in range(len(digits)//2, len(digits))))
            return LOOKUP[x-1]

        return sum(check(x) for x in range(low, high+1))
",rlogr
"

class Solution(object):
    def countDays(self, days, meetings):
        meetings.sort()
        result = curr = 0
        for s, e in meetings:
            result += max((s-1)-curr, 0)
            curr = max(curr, e)
        result += days-curr
        return result
",nlogn
"
class Solution(object):

    def __init__(self, A):
        self.__A = A
        self.__i = 0
        self.__cnt = 0

    def next(self, n):
        while self.__i < len(self.__A):
            if  n > self.__A[self.__i] - self.__cnt:
                n -= self.__A[self.__i] - self.__cnt
                self.__cnt = 0
                self.__i += 2
            else:
                self.__cnt += n
                return self.__A[self.__i+1]
        return -1



",n
"
class Solution(object):
    def minTimeToType(self, word):
        return (min((ord(word[0])-ord('a'))%26, (ord('a')-ord(word[0]))%26)+1) + \
               sum(min((ord(word[i])-ord(word[i-1]))%26, (ord(word[i-1])-ord(word[i]))%26)+1
                   for i in range(1, len(word)))
",n
"
class Solution(object):
    def minimumEffort(self, tasks):
        tasks.sort(key=lambda x: x[1]-x[0]) 
        result = 0
        for a, m in tasks: 
            result = max(result+a, m)
        return result


",nlogn
"class Solution2(object):
    def minimumEffort(self, tasks):
        tasks.sort(key=lambda x: x[0]-x[1]) 
        result = curr = 0
        for a, m in tasks: 
            result += max(m-curr, 0)
            curr = max(curr, m)-a
        return result
",nlogn
"
import collections


class Solution(object):
    def tupleSameProduct(self, nums):
        result = 0
        count = collections.Counter()
        for i in range(len(nums)):
            for j in range(i+1, len(nums)): 
                result += count[nums[i]*nums[j]]
                count[nums[i]*nums[j]] += 1
        return 8*result
",n^2
"
class Solution(object):
    def subsets(self, nums):
        nums.sort()
        result = [[]]
        for i in range(len(nums)):
            size = len(result)
            for j in range(size):
                result.append(list(result[j]))
                result[-1].append(nums[i])
        return result


",n * 2^n
"class Solution2(object):
    def subsets(self, nums):
        result = []
        i, count = 0, 1 << len(nums)
        nums.sort()

        while i < count:
            cur = []
            for j in range(len(nums)):
                if i & 1 << j:
                    cur.append(nums[j])
            result.append(cur)
            i += 1

        return result


",n * 2^n
"class Solution3(object):
    def subsets(self, nums):
        return self.subsetsRecu([], sorted(nums))

    def subsetsRecu(self, cur, nums):
        if not nums:
            return [cur]

        return self.subsetsRecu(cur, nums[1:]) + self.subsetsRecu(cur + [nums[0]], nums[1:])


",n * 2^n
"

class Solution(object):
    def shortestPath(self, grid, k):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def dot(a, b):
            return a[0]*b[0]+a[1]*b[1]

        def g(a, b):
            return abs(a[0]-b[0])+abs(a[1]-b[1])
        
        def a_star(grid, b, t, k):
            f, dh = g(b, t), 2
            closer, detour = [(b, k)], []
            lookup = {}
            while closer or detour:
                if not closer:
                    f += dh
                    closer, detour = detour, closer
                b, k = closer.pop()
                if b == t:
                    return f
                if b in lookup and lookup[b] >= k:
                    continue
                lookup[b] = k
                for dx, dy in directions:
                    nb = (b[0]+dx, b[1]+dy)
                    if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and
                            (grid[nb[0]][nb[1]] == 0 or k > 0) and
                            (nb not in lookup or lookup[nb] < k)):
                        continue
                    (closer if dot((dx, dy), (t[0]-b[0], t[1]-b[1])) > 0 else detour).append((nb, k-int(grid[nb[0]][nb[1]] == 1)))
            return -1

        return a_star(grid, (0, 0), (len(grid)-1, len(grid[0])-1), k)
",m * n * k
"

class Solution(object):
    def removeTrailingZeros(self, num):
        return num[:next(i for i in reversed(range(len(num))) if num[i] != '0')+1]
",n
"
import collections
import itertools


class Solution(object):
    def findSecretWord(self, wordlist, master):
        possible = list(range(len(wordlist)))
        n = 0
        while n < 6:
            count = [collections.Counter(w[i] for w in wordlist) for i in range(6)]
            guess = max(possible, key=lambda x: sum(count[i][c] for i, c in enumerate(wordlist[x])))
            n = master.guess(wordlist[guess])
            possible = [j for j in possible if sum(a == b for a, b in zip(wordlist[guess], wordlist[j])) == n]


",n
"class Solution2(object):
    def findSecretWord(self, wordlist, master):
        def solve(H, possible):
            min_max_group, best_guess = possible, None
            for guess in possible:
                groups = [[] for _ in range(7)]
                for j in possible:
                    if j != guess:
                        groups[H[guess][j]].append(j)
                max_group = max(groups, key=len)
                if len(max_group) < len(min_max_group):
                    min_max_group, best_guess = max_group, guess
            return best_guess

        H = [[sum(a == b for a, b in zip(wordlist[i], wordlist[j]))
                  for j in range(len(wordlist))]
                  for i in range(len(wordlist))]
        possible = list(range(len(wordlist)))
        n = 0
        while n < 6:
            guess = solve(H, possible)
            n = master.guess(wordlist[guess])
            possible = [j for j in possible if H[guess][j] == n]


",n^2
"class Solution3(object):
    def findSecretWord(self, wordlist, master):
        def solve(H, possible):
            min_max_group, best_guess = possible, None
            for guess in possible:
                groups = [[] for _ in range(7)]
                for j in possible:
                    if j != guess:
                        groups[H[guess][j]].append(j)
                max_group = groups[0]
                if len(max_group) < len(min_max_group):
                    min_max_group, best_guess = max_group, guess
            return best_guess

        H = [[sum(a == b for a, b in zip(wordlist[i], wordlist[j]))
                  for j in range(len(wordlist))]
                  for i in range(len(wordlist))]
        possible = list(range(len(wordlist)))
        n = 0
        while n < 6:
            guess = solve(H, possible)
            n = master.guess(wordlist[guess])
            possible = [j for j in possible if H[guess][j] == n]

",n^2
"
class Solution(object):
    def transformArray(self, arr):
        def is_changable(arr):
            return any(arr[i-1] > arr[i] < arr[i+1] or 
                       arr[i-1] < arr[i] > arr[i+1]
                       for i in range(1, len(arr)-1))
        
        while is_changable(arr):
            new_arr = arr[:]
            for i in range(1, len(arr)-1):
                new_arr[i] += arr[i-1] > arr[i] < arr[i+1]
                new_arr[i] -= arr[i-1] < arr[i] > arr[i+1]
            arr = new_arr
        return arr
",n^2
"
from heapq import heappush, heappop

class Solution(object):
    def kthSmallest(self, matrix, k):
        kth_smallest = 0
        min_heap = []

        def push(i, j):
            if len(matrix) > len(matrix[0]):
                if i < len(matrix[0]) and j < len(matrix):
                    heappush(min_heap, [matrix[j][i], i, j])
            else:
                if i < len(matrix) and j < len(matrix[0]):
                    heappush(min_heap, [matrix[i][j], i, j])

        push(0, 0)
        while min_heap and k > 0:
            kth_smallest, i, j = heappop(min_heap)
            push(i, j + 1)
            if j == 0:
                push(i + 1, 0)
            k -= 1

        return kth_smallest

","k * log(min(n, m, k))"
"
import bisect


class Solution(object):
    def sortedSquares(self, A):
        right = bisect.bisect_left(A, 0)
        left = right-1
        result = []
        while 0 <= left or right < len(A):
            if right == len(A) or \
               (0 <= left and A[left]**2 < A[right]**2):
                result.append(A[left]**2)
                left -= 1
            else:
                result.append(A[right]**2)
                right += 1
        return result
",n
"

class Solution(object):
    def goodBinaryStrings(self, minLength, maxLength, oneGroup, zeroGroup):
        MOD = 10**9+7
        result = 0
        w = max(oneGroup, zeroGroup)+1
        dp = [0]*w
        for i in range(maxLength+1):
            dp[i%w] = 1 if i == 0 else 0
            if i-oneGroup >= 0:
                dp[i%w] = (dp[i%w]+dp[(i-oneGroup)%w])%MOD
            if i-zeroGroup >= 0:
                dp[i%w] = (dp[i%w]+dp[(i-zeroGroup)%w])%MOD
            if i >= minLength:
                result = (result+dp[i%w])%MOD
        return result


",n
"
class Solution(object):
    def goodBinaryStrings(self, minLength, maxLength, oneGroup, zeroGroup):
        MOD = 10**9+7
        result = 0
        w = max(oneGroup, zeroGroup)+1
        dp = [0]*w
        dp[0] = 1
        for i in range(maxLength+1):
            if i >= minLength:
                result = (result+dp[i%w])%MOD
            if i+oneGroup <= maxLength:
                dp[(i+oneGroup)%w] = (dp[(i+oneGroup)%w]+dp[i%w])%MOD
            if i+zeroGroup <= maxLength:
                dp[(i+zeroGroup)%w] = (dp[(i+zeroGroup)%w]+dp[i%w])%MOD
            dp[i%w] = 0
        return result
",n
"

class Solution(object):
    def maxCoins(self, lane1, lane2):
        result = dp1 = dp12 = dp121 = float(""-inf"")
        for i in range(len(lane1)):
            dp1 = max(dp1, 0)+lane1[i]
            dp12 = max(max(dp12, 0)+lane2[i], dp1)
            dp121 = max(max(dp121, 0)+lane1[i], dp12)
            result = max(result, dp1, dp121)
        return result
",n
"
import collections



class Solution(object):
    def checkStrings(self, s1, s2):
        return all(collections.Counter(s1[j] for j in range(i, len(s1), 2)) == collections.Counter(s2[j] for j in range(i, len(s2), 2)) for i in range(2))
",n
"
class Solution(object):
    def waysToMakeFair(self, nums):
        prefix = [0]*2
        suffix = [sum(nums[i] for i in range(k, len(nums), 2)) for k in range(2)]
        result = 0
        for i, num in enumerate(nums):
            suffix[i%2] -= num
            result += int(prefix[0]+suffix[1] == prefix[1]+suffix[0])
            prefix[i%2] += num
        return result
",n
"

class Solution(object):
    def pivotInteger(self, n):
        x = int(((n+1)*n//2)**0.5+0.5)
        return x if x**2 == (n+1)*n//2 else -1
",1
"
from string import ascii_lowercase



class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):
        words = set(wordList)
        if endWord not in words:
            return 0
        left, right = {beginWord}, {endWord}
        ladder = 2
        while left:
            words -= left
            new_left = set()
            for word in left:
                for new_word in (word[:i]+c+word[i+1:] for i in range(len(beginWord)) for c in ascii_lowercase):
                    if new_word not in words:
                        continue
                    if new_word in right: 
                        return ladder
                    new_left.add(new_word)
            left = new_left
            ladder += 1
            if len(left) > len(right): 
                left, right = right, left
        return 0


",b^(d/2)
"class Solution2(object):
    def ladderLength(self, beginWord, endWord, wordList):
        lookup = set(wordList)
        if endWord not in lookup:
            return 0
        ladder = 2
        q = [beginWord]
        while q:
            new_q = []
            for word in q:
                for i in range(len(word)):
                    for j in ascii_lowercase:
                        new_word = word[:i] + j + word[i+1:]
                        if new_word == endWord:
                            return ladder
                        if new_word in lookup:
                            lookup.remove(new_word)
                            new_q.append(new_word)
            q = new_q
            ladder += 1
        return 0
",b^d
"
import collections



class Solution(object):
    def numberOfPairs(self, nums1, nums2, k):
        cnt = [0]*(max(nums1)+1)
        for x, c in collections.Counter(k*x for x in nums2).items():
            for i in range(1, (len(cnt)-1)//x+1):
                cnt[i*x] += c
        return sum(cnt[x] for x in nums1)
",rlogr + n + m
"

class Solution(object):
    def sumOfTheDigitsOfHarshadNumber(self, x):
        result = 0
        y = x
        while y:
            y, r = divmod(y, 10)
            result += r
        return result if x%result == 0 else -1
",logx
"
import fractions


class Solution(object):
    def findGCD(self, nums):
        return fractions.gcd(min(nums), max(nums))
",n
"

class Solution(object):
    def minimumCost(self, cost):
        cost.sort(reverse=True)
        return sum(x for i, x in enumerate(cost) if i%3 != 2)
",nlogn
"
import collections


class Solution(object):
    def canArrange(self, arr, k):
        count = collections.Counter(i%k for i in arr)
        return (0 not in count or not count[0]%2) and \
                all(k-i in count and count[i] == count[k-i] for i in range(1, k) if i in count)
",n
"
class Solution(object):
    def maxProduct(self, nums):
        m1 = m2 = 0
        for num in nums:
            if num > m1:
                m1, m2 = num, m1
            elif num > m2:
                m2 = num
        return (m1-1)*(m2-1)
",n
"

class Solution(object):
    def productQueries(self, n, queries):
        MOD = 10**9+7
        prefix = [0]
        i = 0
        while (1<<i) <= n:
            if n&(1<<i):
                prefix.append(prefix[-1]+i)
            i += 1
        return [pow(2, prefix[r+1]-prefix[l], MOD) for l, r in queries]
",logn + qlogr
"

class Solution(object):
    def stableMountains(self, height, threshold):
        return [i for i in range(1, len(height)) if height[i-1] > threshold]
",n
"

class Solution(object):
    def camelMatch(self, queries, pattern):
        def is_matched(query, pattern):
            i = 0
            for c in query:
                if i < len(pattern) and pattern[i] == c:
                    i += 1
                elif c.isupper():
                    return False
            return i == len(pattern)
        
        result = []
        for query in queries:
            result.append(is_matched(query, pattern))
        return result
",n * l
"

class Solution(object):
    def simulationResult(self, windows, queries):
        lookup = [False]*len(windows)
        result = []
        for x in reversed(queries):
            if lookup[x-1]:
                continue
            lookup[x-1] = True
            result.append(x)
        result.extend(x for x in windows if not lookup[x-1])
        return result
",n
"
import collections



class Solution(object):
    def minimumCoins(self, prices):
        dp = [float(""inf"")]*(len(prices)+1)
        dp[0] = 0
        dq = collections.deque()
        j = 0
        for i in range(len(prices)):
            while dq and dp[dq[-1]]+prices[dq[-1]] >= dp[i]+prices[i]:
                dq.pop()
            dq.append(i)
            while j+(j+1) < i:
                assert(len(dq) != 0)
                if dq[0] == j:
                    dq.popleft()
                j += 1
            dp[i+1] = dp[dq[0]]+prices[dq[0]]
        return dp[-1]


",n
"
from sortedcontainers import SortedList


class Solution2(object):
    def minimumCoins(self, prices):
        dp = [float(""inf"")]*(len(prices)+1)
        dp[0] = 0
        sl = SortedList()
        j = 0
        for i in range(len(prices)):
            sl.add((dp[i]+prices[i], i))
            while j+(j+1) < i:
                sl.remove(((dp[j]+prices[j], j)))
                j += 1
            dp[i+1] = sl[0][0]
        return dp[-1]


",nlogn
"
class Solution3(object):
    def minimumCoins(self, prices):
        dp = [float(""inf"")]*(len(prices)+1)
        dp[0] = 0
        for i in range(len(prices)):
            for j in range(i//2, i+1):
                dp[i+1] = min(dp[i+1], dp[j]+prices[j])
        return dp[-1]
",n^2
"

class Solution(object):
    def isStrictlyPalindromic(self, n):
        return False
",1
"

class Solution(object):
    def deleteString(self, s):
        if all(x == s[0] for x in s):
            return len(s)
        dp2 = [[0]*(len(s)+1) for i in range(2)] 
        dp = [1]*len(s) 
        for i in reversed(range(len(s)-1)):
            for j in range(i+1, len(s)):
                dp2[i%2][j] = dp2[(i+1)%2][j+1]+1 if s[j] == s[i] else 0
                if dp2[i%2][j] >= j-i:
                    dp[i] = max(dp[i], dp[j]+1)
        return dp[0]


",n^2
"
class Solution2(object):
    def deleteString(self, s):
        def getPrefix(pattern, start):
            prefix = [-1]*(len(pattern)-start)
            j = -1
            for i in range(1, len(pattern)-start):
                while j != -1 and pattern[start+j+1] != pattern[start+i]:
                    j = prefix[j]
                if pattern[start+j+1] == pattern[start+i]:
                    j += 1
                prefix[i] = j
            return prefix

        if all(x == s[0] for x in s):
            return len(s)
        dp = [1]*len(s) 
        for i in reversed(range(len(s)-1)):
            prefix = getPrefix(s, i) 
            for j in range(1, len(prefix), 2):
                if 2*(prefix[j]+1) == j+1:
                    dp[i] = max(dp[i], dp[i+(prefix[j]+1)]+1)
        return dp[0]


",n^2
"
class Solution3(object):
    def deleteString(self, s):
        MOD, P = 10**9+7, (113, 109)
        def hash(i, j):
            return [(prefix[idx][j+1]-prefix[idx][i]*power[idx][j-i+1])%MOD for idx in range(len(P))]

        if all(x == s[0] for x in s):
            return len(s)

        power = [[1] for _ in range(len(P))]
        prefix = [[0] for _ in range(len(P))]
        for x in s:
            for idx, p in enumerate(P):
                power[idx].append((power[idx][-1]*p)%MOD)
                prefix[idx].append((prefix[idx][-1]*p+(ord(x)-ord('a')))%MOD)
        dp = [1]*len(s) 
        for i in reversed(range(len(s)-1)):
            for j in range(1, (len(s)-i)//2+1):
                if hash(i, i+j-1) == hash(i+j, i+2*j-1):
                    dp[i] = max(dp[i], dp[i+j]+1)
        return dp[0]
",n^2
"
import collections


class Solution(object):
    def maxOperations(self, nums, k):
        count = collections.Counter()
        result = 0
        for x in nums:
            if k-x in count and count[k-x]:
                count[k-x] -= 1
                result += 1
            else:
                count[x] += 1
        return result
",n
"

class Solution(object):
    def countAlternatingSubarrays(self, nums):
        result = curr = 0
        for i in range(len(nums)):
            if i-1 >= 0 and nums[i-1] == nums[i]:
                curr = 0
            curr += 1
            result += curr
        return result
",n
"

class Solution(object):
    def findDifference(self, nums1, nums2):
        lookup = [set(nums1), set(nums2)]
        return [list(lookup[0]-lookup[1]), list(lookup[1]-lookup[0])]
",n
"

class Solution(object):
    def countCells(self, grid, pattern):
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        def check(is_horizontal):
            n, m = len(grid), len(grid[0])
            if not is_horizontal:
                n, m = m, n
            p = len(pattern)
            s = list(pattern)
            if is_horizontal:
                s.extend(grid[i][j] for i in range(n) for j in range(m))
            else:
                s.extend(grid[j][i] for i in range(n) for j in range(m))
            lookup = [[False]*m for _ in range(n)]
            z = z_function(s)
            curr = 0
            for i in range(p, len(s)):
                if z[i] < p:
                    continue
                curr = max(curr, i-p)
                while curr <= (i-p)+p-1:
                    lookup[curr//m][curr%m] = True
                    curr += 1
            return lookup

        lookup1 = check(True)
        lookup2 = check(False)
        return sum(lookup1[i][j] and lookup2[j][i] for i in range(len(grid)) for j in range(len(grid[0])))
",n * m
"
class Solution(object):
    def arrayStringsAreEqual(self, word1, word2):
        idx1 = idx2 = arr_idx1 = arr_idx2 = 0
        while arr_idx1 < len(word1) and arr_idx2 < len(word2):
            if word1[arr_idx1][idx1] != word2[arr_idx2][idx2]:
                break
            idx1 += 1
            if idx1 == len(word1[arr_idx1]):
                idx1 = 0
                arr_idx1 += 1
            idx2 += 1
            if idx2 == len(word2[arr_idx2]):
                idx2 = 0
                arr_idx2 += 1
        return arr_idx1 == len(word1) and arr_idx2 == len(word2)
",n
"
class Solution(object):
    def minimumTotal(self, triangle):
        if not triangle:
            return 0

        cur = triangle[0] + [float(""inf"")]
        for i in range(1, len(triangle)):
            next = []
            next.append(triangle[i][0] + cur[0])
            for j in range(1, i + 1):
                next.append(triangle[i][j] + min(cur[j - 1], cur[j]))
            cur = next + [float(""inf"")]

        return reduce(min, cur)

",m * n
"

class Solution(object):
    def getEncryptedString(self, s, k):
        return """".join(s[(i+k)%len(s)] for i in range(len(s)))
",n
"
class Solution(object):
    def generate(self, numRows):
        result = []
        for i in range(numRows):
            result.append([])
            for j in range(i + 1):
                if j in (0, i):
                    result[i].append(1)
                else:
                    result[i].append(result[i - 1][j - 1] + result[i - 1][j])
        return result

    def generate2(self, numRows):
        if not numRows: return []
        res = [[1]]
        for i in range(1, numRows):
            res += [list(map(lambda x, y: x + y, res[-1] + [0], [0] + res[-1]))]
        return res[:numRows]

    def generate3(self, numRows):
        if numRows == 0: return []
        if numRows == 1: return [[1]]
        res = [[1], [1, 1]]

        def add(nums):
            res = nums[:1]
            for i, j in enumerate(nums):
                if i < len(nums) - 1:
                    res += [nums[i] + nums[i + 1]]
            res += nums[:1]
            return res

        while len(res) < numRows:
            res.extend([add(res[-1])])
        return res

",n^2
"
class Solution(object):
    def findLatestStep(self, arr, m):
        if m == len(arr):
            return m
        length = [0]*(len(arr)+2)
        result = -1
        for i, x in enumerate(arr):
            left, right = length[x-1], length[x+1]
            if left == m or right == m:
                result = i
            length[x-left] = length[x+right] = left+right+1
        return result
",n
"
class Solution(object):
    def numKLenSubstrNoRepeats(self, S, K):
        result, i = 0, 0
        lookup = set()
        for j in range(len(S)):
            while S[j] in lookup:
                lookup.remove(S[i])
                i += 1
            lookup.add(S[j])
            result += j-i+1 >= K
        return result
",n
"
class Solution(object):
    def equalSubstring(self, s, t, maxCost):
        left = 0
        for right in range(len(s)):
            maxCost -= abs(ord(s[right])-ord(t[right]))
            if maxCost < 0:
                maxCost += abs(ord(s[left])-ord(t[left]))
                left += 1
        return (right+1)-left
",n
"

class Solution(object):
    def matrixScore(self, A):
        R, C = len(A), len(A[0])
        result = 0
        for c in range(C):
            col = 0
            for r in range(R):
                col += A[r][c] ^ A[r][0]
            result += max(col, R-col) * 2**(C-1-c)
        return result

",r * c
"
import pandas as pd



def Solution(weather: pd.DataFrame) -> pd.DataFrame:
    return weather.pivot(index=""month"", columns=""city"", values=""temperature"")
",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def hasPathSum(self, root, sum):
        if root is None:
            return False

        if root.left is None and root.right is None and root.val == sum:
            return True

        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)

",n
"
class Solution(object):
    def minMoves(self, nums, k):
        def moves(i, j):
            return prefix[j+1]-prefix[i]

        idxs = [i for i, x in enumerate(nums) if x]
        prefix = [0]*(len(idxs)+1)
        for i in range(len(idxs)):
            prefix[i+1] = prefix[i]+idxs[i]
        result = float(""inf"")
        for i in range(len(idxs)-k+1):
            result = min(result, -moves(i, i+k//2-1) + moves(i+(k+1)//2, i+k-1)) 
        result -= (k//2)*((k+1)//2) 
        return result
",n
"
class Solution(object):
    def wordsTyping(self, sentence, rows, cols):
        def words_fit(sentence, start, cols):
            if len(sentence[start]) > cols:
                return 0

            s, count = len(sentence[start]), 1
            i = (start + 1) % len(sentence)
            while s + 1 + len(sentence[i]) <= cols:
                s += 1 + len(sentence[i])
                count += 1
                i = (i + 1) % len(sentence)
            return count

        wc = [0] * len(sentence)
        for i in range(len(sentence)):
            wc[i] = words_fit(sentence, i, cols)

        words, start = 0, 0
        for i in range(rows):
            words += wc[start]
            start = (start + wc[start]) % len(sentence)
        return words / len(sentence)

",r + n * c
"

class Solution(object):
    def numMagicSquaresInside(self, grid):
        def magic(grid, r, c):
            expect = k * (k**2+1) // 2
            nums = set()
            min_num = float(""inf"")
            sum_diag, sum_anti = 0, 0
            for i in range(k):
                sum_diag += grid[r+i][c+i]
                sum_anti += grid[r+i][c+k-1-i]
                sum_r, sum_c = 0, 0
                for j in range(k):
                    min_num = min(min_num, grid[r+i][c+j])
                    nums.add(grid[r+i][c+j])
                    sum_r += grid[r+i][c+j]
                    sum_c += grid[r+j][c+i]
                if not (sum_r == sum_c == expect):
                    return False
            return sum_diag == sum_anti == expect and \
                len(nums) == k**2 and \
                min_num == 1

        k = 3
        result = 0
        for r in range(len(grid)-k+1):
            for c in range(len(grid[r])-k+1):
                if magic(grid, r, c):
                    result += 1
        return result

",m * n
"
import operator
from functools import reduce



class Solution(object):
    def xorAllNums(self, nums1, nums2):
        return (reduce(operator.xor, nums1) if len(nums2)%2 else 0) ^ \
               (reduce(operator.xor, nums2) if len(nums1)%2 else 0)
",n
"
import collections


class Solution(object):
    def subarraysDivByK(self, A, K):
        count = collections.defaultdict(int)
        count[0] = 1
        result, prefix = 0, 0
        for a in A:
            prefix = (prefix+a) % K
            result += count[prefix]
            count[prefix] += 1
        return result
",n
"
class Solution(object):
    def findLengthOfShortestSubarray(self, arr):
        j = -1
        for j in reversed(range(1, len(arr))):
            if arr[j-1] > arr[j]:
                break
        else:
            return 0
        result = j
        for i in range(j):
            if i and arr[i] < arr[i-1]:
                break
            while j < len(arr) and arr[i] > arr[j]:
                j += 1
            result = min(result, (j-i+1)-2)
        return result


",n
"class Solution2(object):
    def findLengthOfShortestSubarray(self, arr):
        result = 0
        for i in range(1, len(arr)):
            if arr[i-1] <= arr[i]:
                continue
            j = len(arr)-1
            while j > i and (j == len(arr)-1 or arr[j] <= arr[j+1]) and arr[i-1] <= arr[j]:
                j -= 1
            result = j-i+1
            break
        for j in reversed(range(len(arr)-1)):
            if arr[j] <= arr[j+1]:
                continue
            i = 0
            while i < j and (i == 0 or arr[i-1] <= arr[i]) and arr[i] <= arr[j+1]:
                i += 1
            result = min(result, j-i+1)
            break
        return result
",n
"

class Solution(object):
    def restoreMatrix(self, rowSum, colSum):
        matrix = [[0]*len(colSum) for _ in range(len(rowSum))]
        i = j = 0
        while i < len(matrix) and j < len(matrix[0]):
            matrix[i][j] = min(rowSum[i], colSum[j]) 
            rowSum[i] -= matrix[i][j]
            colSum[j] -= matrix[i][j]
            if not rowSum[i]: 
                i += 1
            if not colSum[j]: 
                j += 1
        return matrix


",m + n
"class Solution2(object):
    def restoreMatrix(self, rowSum, colSum):
        matrix = [[0]*len(colSum) for _ in range(len(rowSum))]
        for i in range(len(matrix)):
            for j in range(len(matrix[i])):
                matrix[i][j] = min(rowSum[i], colSum[j]) 
                rowSum[i] -= matrix[i][j]
                colSum[j] -= matrix[i][j]
        return matrix
",m * n
"
import bisect


class Solution(object):
    def minAbsDifference(self, nums, goal):
        mx, mn = sum(x for x in nums if x > 0), sum(x for x in nums if x < 0)
        if goal > mx:
            return goal-mx
        if goal < mn:
            return mn-goal
        result = abs(goal)
        sums1 = set([0])
        for i in range(len(nums)//2):
            for x in list(sums1):
                if x+nums[i] in sums1:
                    continue
                sums1.add(x+nums[i])
                result = min(result, abs(goal-x-nums[i])) 
        sorted_sums1 = sorted(sums1) 
        sums2 = set([0])
        for i in range(len(nums)//2, len(nums)):
            for x in list(sums2):
                if x+nums[i] in sums2:
                    continue
                sums2.add(x+nums[i])
                ni = bisect.bisect_left(sorted_sums1, goal-x-nums[i]) 
                if ni < len(sorted_sums1):
                    result = min(result, abs(goal-x-nums[i]-sorted_sums1[ni]))
                if ni > 0:
                    result = min(result, abs(goal-x-nums[i]-sorted_sums1[ni-1]))
                if result == 0:
                    return result
        return result
",n * 2^(n/2)
"

class Solution(object):
    def findContentChildren(self, g, s):
        g.sort()
        s.sort()

        result, i = 0, 0
        for j in range(len(s)):
            if i == len(g):
                break
            if s[j] >= g[i]:
                result += 1
                i += 1
        return result

",nlogn
"
class Solution(object):
    def minimumJumps(self, forbidden, a, b, x):
        max_f = max(forbidden)
        max_val = x+b if a >= b else max(x, max_f)+a+(b+a) 
        lookup = set()      
        for pos in forbidden:
            lookup.add((pos, True))
            lookup.add((pos, False))
        result = 0
        q = [(0, True)]
        lookup.add((0, True))
        while q:
            new_q = []
            for pos, can_back in q:
                if pos == x:
                    return result
                if pos+a <= max_val and (pos+a, True) not in lookup:
                    lookup.add((pos+a, True))
                    new_q.append((pos+a, True))
                if not can_back:
                    continue
                if pos-b >= 0 and (pos-b, False) not in lookup:
                    lookup.add((pos-b, False))
                    new_q.append((pos-b, False))
            q = new_q
            result += 1
        return -1
","max(x, max(forbidden)) + a + (b+a)"
"
class Solution(object):
    def rotateTheBox(self, box):
        result = [['.']*len(box) for _ in range(len(box[0]))]
        for i in range(len(box)):
            k = len(box[0])-1
            for j in reversed(range(len(box[0]))):
                if box[i][j] == '.':
                    continue
                if box[i][j] == '*':
                    k = j
                result[k][-1-i] = box[i][j]
                k -= 1
        return result
",m * n
"

class Solution(object):
    def countNumbers(self, l, r, b):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def nHr(n, k):
            return nCr(n+k-1, k)

        def count(x):
            digits_base = []
            while x:
                x, r = divmod(x, b)
                digits_base.append(r)
            digits_base.reverse()
            if not digits_base:
                digits_base.append(0)
            result = 0
            for i in range(len(digits_base)):
                if i-1 >= 0 and digits_base[i-1] > digits_base[i]:
                    break
                for j in range(digits_base[i-1] if i-1 >= 0 else 0, digits_base[i]):
                    result = (result + nHr((b-1)-j+1, len(digits_base)-(i+1))) % MOD
            else:
                result = (result+1)%MOD
            return result

        return (count(int(r)) - count(int(l)-1)) % MOD


",n^2
"
class Solution2(object):
    def countNumbers(self, l, r, b):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def nHr(n, k):
            return nCr(n+k-1, k)

        def decrease(digits):
            for i in reversed(range(len(digits))):
                if digits[i]:
                    digits[i] -= 1
                    break
                digits[i] = 9

        def divide(digits, base):
            result = []
            r = 0
            for d in digits:
                q, r = divmod(r*10+d, base)
                if result or q:
                    result.append(q)
            return result, r

        def to_base(digits, base):
            result = []
            while digits:
                digits, r = divide(digits, base)
                result.append(r)
            result.reverse()
            return result

        def count(digits):
            digits_base = to_base(digits, b)
            result = 0
            for i in range(len(digits_base)):
                if i-1 >= 0 and digits_base[i-1] > digits_base[i]:
                    break
                for j in range(digits_base[i-1] if i-1 >= 0 else 0, digits_base[i]):
                    result = (result + nHr((b-1)-j+1, len(digits_base)-(i+1))) % MOD
            else:
                result = (result+1)%MOD
            return result

        digits_l = list(map(int, l))
        decrease(digits_l)
        digits_r = list(map(int, r))
        return (count(digits_r) - count(digits_l)) % MOD
",n^2
"

class Solution(object):
    def numberGame(self, nums):
        nums.sort()
        for i in range(0, len(nums), 2):
            nums[i], nums[i+1] = nums[i+1], nums[i]
        return nums
",nlogn
"

class Solution(object):
    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):
        dp = [[0]*(numCarpets+1) for _ in range(len(floor)+1)] 
        for i in range(1, len(dp)):
            dp[i][0] = dp[i-1][0] + int(floor[i-1])
            for j in range(1, numCarpets+1):
                dp[i][j] = min(dp[i-1][j] + int(floor[i-1]), dp[max(i-carpetLen, 0)][j-1])
        return dp[-1][-1]
",m * n
"
import random



class Solution(object):
    def maxSum(self, grid, limits, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        candidates = []
        for i in range(len(grid)):
            cnt = min(k, limits[i])
            nth_element(grid[i], cnt-1, lambda a, b: a > b)
            for j in range(cnt):
                candidates.append(grid[i][j])
        nth_element(candidates, k-1, lambda a, b: a > b)
        return sum(candidates[i] for i in range(k))
",n * m
"
import itertools
import bisect



class Solution(object):
    def maximumSumQueries(self, nums1, nums2, queries):
        pairs = sorted(((i, j) for i, j in zip(nums1, nums2)))
        result = [0]*len(queries)
        stk = []
        for x, y, i in sorted(((x, y, i) for i, (x, y) in enumerate(queries)), reverse=True):
            while pairs and pairs[-1][0] >= x:
                a, b = pairs.pop()
                while stk and stk[-1][1] <= a+b:
                    stk.pop()
                if not stk or stk[-1][0] < b:
                    stk.append((b, a+b))
            j = bisect.bisect_left(stk, (y,))
            result[i] = stk[j][1] if j != len(stk) else -1
        return result
",nlogn + mlogm + mlogn
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def lcaDeepestLeaves(self, root):
        def lcaDeepestLeavesHelper(root):
            if not root:
                return 0, None
            d1, lca1 = lcaDeepestLeavesHelper(root.left)
            d2, lca2 = lcaDeepestLeavesHelper(root.right)
            if d1 > d2:
                return d1+1, lca1
            if d1 < d2:
                return d2+1, lca2
            return d1+1, root

        return lcaDeepestLeavesHelper(root)[1]
",n
"
class Solution(object):
    def maxLengthBetweenEqualCharacters(self, s):
        result, lookup = -1, {}
        for i, c in enumerate(s):
            result = max(result, i-lookup.setdefault(c, i)-1)
        return result
",n
"

class Solution(object):
    def findMaximumLength(self, nums):
        dp = prefix = left = 0
        stk = [(0, 0, 0)]
        for right in range(len(nums)):
            prefix += nums[right]
            while left+1 < len(stk) and stk[left+1][0] <= prefix:
                left += 1
            last, dp = prefix-stk[left][1], stk[left][2]+1
            while stk and stk[-1][0] >= last+prefix:
                stk.pop()
            stk.append((last+prefix, prefix, dp))
            left = min(left, len(stk)-1)
        return dp


",n
"import collections



class Solution2(object):
    def findMaximumLength(self, nums):
        dp = prefix = prev_prefix = prev_dp = 0
        dq = collections.deque()
        for right in range(len(nums)):
            prefix += nums[right]
            while dq and dq[0][0] <= prefix:
                _, prev_prefix, prev_dp = dq.popleft()
            last, dp = prefix-prev_prefix, prev_dp+1
            while dq and dq[-1][0] >= last+prefix:
                dq.pop()
            dq.append((last+prefix, prefix, dp))
        return dp


",n
"import bisect



class Solution3(object):
    def findMaximumLength(self, nums):
        dp = prefix = left = 0
        stk = [(0, 0, 0)]
        for right in range(len(nums)):
            prefix += nums[right]
            left = bisect.bisect_left(stk, (prefix+1, 0, 0))-1
            last, dp = prefix-stk[left][1], stk[left][2]+1
            while stk and stk[-1][0] >= last+prefix:
                stk.pop()
            stk.append((last+prefix, prefix, dp))
        return dp


",nlogn
"import bisect



class Solution4(object):
    def findMaximumLength(self, nums):
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        dp = [float(""inf"")]*(len(nums)+1)
        dp[0] = 0
        prev = [-1]*(len(nums)+1)
        left = -1
        for right in range(len(nums)):
            left = max(left, prev[right])
            dp[right+1] = dp[left+1]+1
            next_right = bisect.bisect_left(prefix, prefix[right+1]+(prefix[right+1]-prefix[left+1]))-1
            prev[next_right] = right
        return dp[-1]
",nlogn
"
import collections
import itertools


class Solution(object):
    def threeSumMulti(self, A, target):
        count = collections.Counter(A)
        result = 0
        for i, j in itertools.combinations_with_replacement(count, 2):
            k = target - i - j
            if i == j == k:
                result += count[i] * (count[i]-1) * (count[i]-2) // 6
            elif i == j != k:
                result += count[i] * (count[i]-1) // 2 * count[k]
            elif max(i, j) < k:
                result += count[i] * count[j] * count[k]
        return result % (10**9 + 7)
",n^2
"
class Solution(object):
    def maximumScore(self, a, b, c):
        return min((a+b+c)//2, a+b+c - max(a, b, c))
",1
"
import collections



class Solution(object):
    def maxProfit(self, workers, tasks):
        cnt = collections.defaultdict(int)
        for x in workers:
            cnt[x] += 1
        tasks.sort(key=lambda x: x[1], reverse=True)
        result = 0
        k = 1
        for s, p in tasks:
            if cnt[s]:
                cnt[s] -= 1
                result += p
            elif k:
                k -= 1
                result += p
        return result
",n + tlogt
"
import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def minMalwareSpread(self, graph, initial):
        initial_set = set(initial)
        clean = [i for i in range(len(graph)) if i not in initial_set]
        union_find = UnionFind(len(graph))
        for i in range(len(clean)):
            for j in range(i+1, len(clean)):
                if graph[clean[i]][clean[j]] == 1:
                    union_find.union_set(clean[i], clean[j])
        union_size = collections.Counter(union_find.find_set(i) for i in range(len(graph)))
        
        shared_union = collections.defaultdict(set)
        for i in initial:
            for j in clean:                  
                if graph[i][j] == 1:
                    x = union_find.find_set(j)
                    shared_union[x].add(i)

        result, total = float(""inf""), float(""-inf"")
        for i in initial:
            lookup = set()
            curr = 0
            for j in clean:                  
                if graph[i][j] == 1:
                    x = union_find.find_set(j)
                    if len(shared_union[x]) == 1 and \
                       x not in lookup:
                        curr += union_size[x]
                        lookup.add(x)
            if curr > total or \
               (curr == total and i < result):
                total = curr
                result = i
        return result
",n^2
"

class Solution(object):
    def subsequenceSumOr(self, nums):
        result = prefix = 0
        for x in nums:
            prefix += x
            result |= x|prefix
        return result


",n
"
class Solution2(object):
    def subsequenceSumOr(self, nums):
        result = cnt = 0
        for i in range(64):
            cnt >>= 1
            for x in nums:
                cnt += (x>>i)&1
            if cnt:
                result |= 1<<i
        return result
",nlogn
"
from sortedcontainers import SortedList


class Solution(object):
    def maxTaskAssign(self, tasks, workers, pills, strength):
        def check(tasks, workers, pills, strength, x):
            t = SortedList(tasks[:x])
            for worker in workers[-x:]: 
                i = t.bisect_right(worker)-1
                if i != -1:
                    t.pop(i)
                    continue
                if pills:
                    i = t.bisect_right(worker+strength)-1
                    if i != -1:
                        t.pop(i)
                        pills -= 1
                        continue
                return False
            return True

        tasks.sort()
        workers.sort()
        left, right = 1, min(len(workers), len(tasks))
        while left <= right:
            mid = left + (right-left)//2
            if not check(tasks, workers, pills, strength, mid):
                right = mid-1
            else:
                left = mid+1
        return right


",n * (logn)^2
"from sortedcontainers import SortedList


class Solution2(object):
    def maxTaskAssign(self, tasks, workers, pills, strength):
        def check(tasks, workers, pills, strength, x):
            w = SortedList(workers[-x:])
            for task in tasks[-x:]: 
                i = w.bisect_left(task)
                if i != len(w):
                    w.pop(i)
                    continue
                if pills:
                    i = w.bisect_left(task-strength)
                    if i != len(w):
                        w.pop(i)
                        pills -= 1
                        continue
                return False
            return True

        tasks.sort(reverse=True)
        workers.sort()
        left, right = 1, min(len(workers), len(tasks))
        while left <= right:
            mid = left + (right-left)//2
            if not check(tasks, workers, pills, strength, mid):
                right = mid-1
            else:
                left = mid+1
        return right


",n * (logn)^2
"import bisect


class Solution3(object):
    def maxTaskAssign(self, tasks, workers, pills, strength):
        def check(tasks, workers, pills, strength, x):
            t = tasks[:x]
            for worker in workers[-x:]: 
                i = bisect.bisect_right(t, worker)-1
                if i != -1:
                    t.pop(i)
                    continue
                if pills:
                    i = bisect.bisect_right(t, worker+strength)-1
                    if i != -1:
                        t.pop(i)
                        pills -= 1
                        continue
                return False
            return True

        tasks.sort()
        workers.sort()
        left, right = 1, min(len(workers), len(tasks))
        while left <= right:
            mid = left + (right-left)//2
            if not check(tasks, workers, pills, strength, mid):
                right = mid-1
            else:
                left = mid+1
        return right


",n^2 * logn
"import bisect


class Solution4(object):
    def maxTaskAssign(self, tasks, workers, pills, strength):
        def check(tasks, workers, pills, strength, x):
            w = workers[-x:]
            for task in tasks[-x:]: 
                i = bisect.bisect_left(w, task)
                if i != len(w):
                    w.pop(i)
                    continue
                if pills:
                    i = bisect.bisect_left(w, task-strength)
                    if i != len(w):
                        w.pop(i)
                        pills -= 1
                        continue
                return False
            return True

        tasks.sort(reverse=True)
        workers.sort()
        left, right = 1, min(len(workers), len(tasks))
        while left <= right:
            mid = left + (right-left)//2
            if not check(tasks, workers, pills, strength, mid):
                right = mid-1
            else:
                left = mid+1
        return right
",n^2 * logn
"
class Solution(object):
    def longestOnes(self, A, K):
        result, i = 0, 0
        for j in range(len(A)):
            K -= int(A[j] == 0)
            while K < 0:
                K += int(A[i] == 0)
                i += 1
            result = max(result, j-i+1)
        return result
",n
"
import collections



class Solution(object):
    def countAnagrams(self, s):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def lazy_init(n):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)

        def factorial(n):
            lazy_init(n)
            return fact[n]

        def inv_factorial(n):
            lazy_init(n)
            return inv_fact[n]

        def count(j, i):
            result = 1
            cnt = collections.Counter()
            for k in  range(j, i+1):
                cnt[s[k]] += 1
            result = factorial(sum(cnt.values()))
            for c in cnt.values():
                result = (result*inv_factorial(c))%MOD
            return result

        result = 1
        j = 0
        for i in range(len(s)):
            if i+1 != len(s) and s[i+1] != ' ':
                continue
            result = (result*count(j, i))%MOD
            j = i+2
        return result
",n
"

class Solution(object):
    def convertTemperature(self, celsius):
        return [celsius+273.15, celsius*1.80+32.00]
",1
"

class Solution(object):
    def vowelStrings(self, words, queries):
        VOWELS = {'a', 'e', 'i', 'o', 'u'}
        prefix = [0]*(len(words)+1)
        for i, w in enumerate(words):
            prefix[i+1] = prefix[i]+int(w[0] in VOWELS and w[-1] in VOWELS)
        return [prefix[r+1]-prefix[l] for l, r in queries]
",n + q
"
class Solution(object):
    def addNegabinary(self, arr1, arr2):
        result = []
        carry = 0
        while arr1 or arr2 or carry:
            if arr1:
                carry += arr1.pop()
            if arr2:
                carry += arr2.pop()
            result.append(carry & 1)
            carry = -(carry >> 1)
        while len(result) > 1 and result[-1] == 0:
            result.pop()
        result.reverse()
        return result
",n
"

class Solution(object):
    def clearStars(self, s):
        result = list(s)
        lookup = [[] for _ in range(26)]
        for i, x in enumerate(s):
            if x != '*':
                lookup[ord(x)-ord('a')].append(i)
                continue
            for stk in lookup:
                if not stk:
                    continue
                result[stk.pop()] = '*'
                break
        return """".join(x for x in result if x != '*')
",n + 26
"

class Solution(object):
    def sumOfThree(self, num):
        return [num//3-1, num//3, num//3+1] if num%3 == 0 else []
",1
"
class Solution(object):
    def minKnightMoves(self, x, y):
        x, y = abs(x), abs(y)
        if x < y:
            x, y = y, x
        lookup = {(1, 0):3, (2, 2):4} 
        if (x, y) in lookup:
            return lookup[(x, y)]
        k = x-y
        if y > k:
            return k - 2*((k-y)//3)
        return k - 2*((k-y)//4)


",1
"class Solution2(object):
    def __init__(self):
        self.__lookup = {(0, 0):0, (1, 1):2, (1, 0):3} 

    def minKnightMoves(self, x, y):
        def dp(x, y):
            x, y = abs(x), abs(y)
            if x < y:
                x, y = y, x
            if (x, y) not in self.__lookup: 
                self.__lookup[(x, y)] = min(dp(x-1, y-2), dp(x-2, y-1)) + 1
            return self.__lookup[(x, y)]
        return dp(x, y)
",n^2
"

class Solution(object):
    def maxProfit(self, n, edges, score):
        def popcount(x):
            return bin(x).count('1')

        adj = [0]*n
        for i, j in edges:
            adj[j] |= 1<<i
        dp = [-1]*(1<<n)
        dp[0] = 0 
        for mask in range(1<<n):
            if dp[mask] == -1:
                continue
            l = popcount(mask)+1
            for i in range(n):
                if mask&(1<<i):
                    continue
                if (mask & adj[i]) == adj[i]: 
                    dp[mask|(1<<i)] = max(dp[mask|(1<<i)], dp[mask]+l*score[i])
        return dp[-1]
",n * 2^n
"
class Solution(object):
    def diStringMatch(self, S):
        result = []
        left, right = 0, len(S)
        for c in S:
            if c == 'I':
                result.append(left)
                left += 1
            else:
                result.append(right)
                right -= 1
        result.append(left)
        return result
",n
"
class Solution(object):
    def minNumberOperations(self, target):
        return sum(max((target[i] if i < len(target) else 0)-(target[i-1] if i-1 >= 0 else 0), 0) for i in range(len(target)+1))
",n
"

class Solution(object):
    def countMatchingSubarrays(self, nums, pattern):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i, x in enumerate(text):
                while j+1 > 0 and pattern[j+1] != x:
                    j = prefix[j]
                if pattern[j+1] == x:
                    j += 1
                if j+1 == len(pattern):
                    yield i-j
                    j = prefix[j]

        return sum(1 for _ in KMP((cmp(nums[i+1], nums[i]) for i in range(len(nums)-1)), pattern))


",n
"
class Solution2(object):
    def countMatchingSubarrays(self, nums, pattern):
        def check(i):
            return all(nums[i+j] == pattern[j] for j in range(len(pattern)))
    
        for i in range(len(nums)-1):
            nums[i] = cmp(nums[i+1], nums[i])
        return sum(check(i) for i in range(len(nums)-len(pattern)+1))
",n * m
"
import collections



class Solution(object):
    def minSteps(self, s, t):
        cnt1, cnt2 = collections.Counter(s), collections.Counter(t)
        return sum((cnt1-cnt2).values())+sum((cnt2-cnt1).values())
",n
"
import collections


class Solution(object):

    def __init__(self):
        _trie = lambda: collections.defaultdict(_trie)
        self.__root = _trie()


    def insert(self, key, val):
        curr = self.__root
        for c in key:
            curr = curr[c]
        delta = val
        if ""_end"" in curr:
            delta -= curr[""_end""]

        curr = self.__root
        for c in key:
            curr = curr[c]
            if ""_count"" in curr:
                curr[""_count""] += delta
            else:
                curr[""_count""] = delta
        curr[""_end""] = val


    def sum(self, prefix):
        curr = self.__root
        for c in prefix:
            if c not in curr:
                return 0
            curr = curr[c]
        return curr[""_count""]



",n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def btreeGameWinningMove(self, root, n, x):
        def count(node, x, left_right):
            if not node:
                return 0
            left, right = count(node.left, x, left_right), count(node.right, x, left_right)
            if node.val == x:
                left_right[0], left_right[1] = left, right
            return left + right + 1

        left_right = [0, 0]
        count(root, x, left_right)
        blue = max(max(left_right), n-(sum(left_right)+1))
        return blue > n-blue
",n
"

class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def getDecimalValue(self, head):
        result = 0
        while head: 
            result = result*2 + head.val 
            head = head.__next__ 
        return result
",n
"
class Solution(object):
    def totalMoney(self, n):
        def arithmetic_sequence_sum(a, d, n):
            return (2*a + (n-1)*d) * n //2

        cost, day = 1, 7
        first_week_cost = arithmetic_sequence_sum(cost, cost, day)
        week, remain_day = divmod(n, day)
        return arithmetic_sequence_sum(first_week_cost, cost*day, week) + \
               arithmetic_sequence_sum(cost*(week+1), cost, remain_day)
",1
"
class Solution(object):
    def finalValueAfterOperations(self, operations):
        return sum(1 if '+' == op[1] else -1 for op in operations)
",n
"
import collections
import heapq



class Solution(object):
    def minMaxWeight(self, n, edges, threshold):
        def dijkstra():
            best = [float(""inf"")]*len(adj)
            best[0] = 0
            min_heap = [(best[0], 0)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if curr != best[u]:
                    continue
                for v, w in adj[u].items():
                    if not (max(curr, w) < best[v]):
                        continue
                    best[v] = max(curr, w)
                    heapq.heappush(min_heap, (best[v], v))
            result = max(best)
            return result if result != float(""inf"") else -1

        adj = [collections.defaultdict(lambda: float(""inf"")) for _ in range(n)]
        for i, j, w in edges:
            adj[j][i] = min(adj[j][i], w)
        return dijkstra()


",nlogn + e
"import collections
import heapq



class Solution2(object):
    def minMaxWeight(self, n, edges, threshold):
        def prim():
            best = [float(""inf"")]*len(adj)
            min_heap = [(0, 0)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if best[u] != float(""inf""):
                    continue
                best[u] = curr
                for v, w in adj[u].items():
                    if best[v] != float(""inf""):
                        continue
                    heapq.heappush(min_heap, (w, v))
            result = max(best)
            return result if result != float(""inf"") else -1

        adj = [collections.defaultdict(lambda: float(""inf"")) for _ in range(n)]
        for i, j, w in edges:
            adj[j][i] = min(adj[j][i], w)
        return prim()


",nlogn + e
"import collections



class Solution3(object):
    def minMaxWeight(self, n, edges, threshold):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(x):
            cnt = len(adj)
            lookup = [False]*len(adj)
            lookup[0] = True
            cnt -= 1
            q = [0]
            while q:
                new_q = []
                for u in q:
                    for v, w in adj[u].items():
                        if w > x or lookup[v]:
                            continue
                        lookup[v] = True
                        cnt -= 1
                        new_q.append(v)
                q = new_q
            return cnt == 0
    
        adj = [collections.defaultdict(lambda: float(""inf"")) for _ in range(n)]
        for i, j, w in edges:
            adj[j][i] = min(adj[j][i], w)
        left, right = min(w for _, _, w in edges), max(w for _, _, w in edges)
        result = binary_search(left, right, check)
        return result if result <= right else -1
",nlogw + e
"

class Solution(object):
    def findShortestCycle(self, n, edges):
        INF = float(""inf"")
        def bfs(u):
            result = INF
            dist = [float(""inf"")]*len(adj)
            dist[u] = 0
            q = [u]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[v] != INF:
                            assert(abs(dist[v]-dist[u]) <= 1)
                            if dist[v] != dist[u]-1:
                                result = min(result, 1+dist[u]+dist[v]) 
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                if result != INF: 
                    break
                q = new_q
            return result

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = min(bfs(u) for u in range(n))
        return result if result != INF else -1
",n^2
"

class Solution(object):
    def countOfSubstrings(self, word, k):
        VOWELS = set(""aeiou"")
        def update(i, d):
            if word[i] not in VOWELS:
                curr2[0] += d
                return
            x = ord(word[i])-ord('a')
            if cnt1[x] == 0:
                curr1[0] += 1
            cnt1[x] += d
            if cnt1[x] == 0:
                curr1[0] -= 1

        result = 0
        cnt1, cnt2 = [0]*26, [0]*26
        curr1, curr2 = [0], [0]
        mid = left = 0
        for right in range(len(word)):
            update(right, +1)
            while curr2[0] > k:
                update(left, -1)
                if left < mid:
                    assert(word[left] in VOWELS)
                    cnt2[ord(word[left])-ord('a')] -= 1
                left += 1
                mid = max(mid, left)
            if not (curr1[0] == len(VOWELS) and curr2[0] == k):
                continue
            while word[mid] in VOWELS and cnt1[ord(word[mid])-ord('a')]-(cnt2[ord(word[mid])-ord('a')]+1) >= 1:
                cnt2[ord(word[mid])-ord('a')] += 1
                mid += 1
            result += mid-left+1
        return result


",n
"
class Solution2(object):
    def countOfSubstrings(self, word, k):
        VOWELS = set(""aeiou"")
        def count(k):
            def update(i, d):
                if word[i] not in VOWELS:
                    curr2[0] += d
                    return
                x = ord(word[i])-ord('a')
                if cnt[x] == 0:
                    curr1[0] += 1
                cnt[x] += d
                if cnt[x] == 0:
                    curr1[0] -= 1

            result = 0
            cnt = [0]*26
            curr1, curr2 = [0], [0]
            left = 0
            for right in range(len(word)):
                update(right, +1)
                while curr1[0] == len(VOWELS) and curr2[0] >= k:
                    result += len(word)-right
                    update(left, -1)
                    left += 1
            return result

        return count(k)-count(k+1)
",n
"
import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    students.dropna(subset=[""name""], inplace=True)
    return students
",n
"

class Solution(object):
    def maximumTop(self, nums, k):
        if len(nums) == 1 == k%2:
            return -1
        if k <= 1:
            return nums[k]
        return max(nums[i] for i in range(min(k+1, len(nums))) if i != k-1)
","min(n, k)"
"

class Solution(object):
    def minimumSubstringsInPartition(self, s):
        INF = float(""inf"")
        dp = [INF]*(len(s)+1)
        dp[0] = 0
        for i in range(len(s)):
            cnt = [0]*26
            d = mx = 0
            for j in reversed(range(i+1)):
                k = ord(s[j])-ord('a')
                if cnt[k] == 0:
                    d += 1
                cnt[k] += 1
                mx = max(mx, cnt[k])
                if d*mx == i-j+1:
                    dp[i+1] = min(dp[i+1], dp[j]+1)
        return dp[-1]
",n * (n + 26)
"
import collections


class Solution(object):
    def frequencySort(self, nums):
        count = collections.Counter(nums)
        return sorted(nums, key=lambda x: (count[x], -x))
",nlogn
"
class Solution(object):
    def longestConsecutive(self, num):
        result, lengths = 1, {key: 0 for key in num}
        for i in num:
            if lengths[i] == 0:
                lengths[i] = 1
                left, right = lengths.get(i - 1, 0), lengths.get(i + 1, 0)
                length = 1 + left + right
                result, lengths[i - left], lengths[i + right] = max(result, length), length, length
        return result

",n
"
import itertools



class Solution(object):
    def maxArea(self, height, positions, directions):
        diff = [0]*(2*height+1)
        for d, i in zip(directions, positions):
            if d == 'U':
                diff[height-i] -= 1
                diff[(height-i)+height] += 1
            else:
                diff[i] += 1
                diff[i+height] -= 1
        result = total = sum(positions)
        cnt = directions.count('U')
        for t in range(1, len(diff)):
            total += -(len(directions)-cnt)+cnt
            result = max(result, total)
            cnt += diff[t]
        return result


",h
"import collections
import itertools



class Solution2(object):
    def maxArea(self, height, positions, directions):
        diff = collections.defaultdict(int)
        for d, i in zip(directions, positions):
            if d == 'U':
                diff[height-i] -= 1
                diff[(height-i)+height] += 1
            else:
                diff[i] += 1
                diff[i+height] -= 1
        result = total = sum(positions)
        cnt = directions.count('U')
        prev = 0
        for t, d in sorted(diff.items()):
            total += (t-prev)*(-(len(directions)-cnt)+cnt)
            result = max(result, total)
            cnt += d
            prev = t
        return result
",nlogn
"

class Solution(object):
    def frequenciesOfElements(self, head):
        curr = dummy = ListNode(0)
        cnt = 0
        while head:
            cnt += 1
            if not head.__next__ or head.next.val != head.val:
                curr.next = ListNode(cnt)
                curr = curr.__next__
                cnt = 0
            head = head.__next__
        return dummy.__next__
",n
"

class Solution(object):
    def sortTheStudents(self, score, k):
        score.sort(key=lambda x: x[k], reverse=True)
        return score
",mlogm
"
class Solution(object):
    def sumZero(self, n):
        return [i for i in range(-(n//2), n//2+1) if not (i == 0 and n%2 == 0)]
",n
"
class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1) 

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret



class Solution(object):
    def goodTriplets(self, nums1, nums2):
        lookup = [0]*len(nums1)
        for i, x in enumerate(nums1):
            lookup[x] = i
        result = 0
        bit = BIT(len(nums1))
        for i, x in enumerate(nums2):
            smaller = bit.query(lookup[x]-1)
            larger = (len(nums1)-(lookup[x]+1))-(i-smaller)
            result += smaller*larger
            bit.add(lookup[x], 1)
        return result
",nlogn
"
class Solution(object):
    def countHomogenous(self, s):
        MOD = 10**9+7
        result = cnt = 0
        for i in range(len(s)):
            if i and s[i-1] == s[i]:
                cnt += 1
            else:
                cnt = 1
            result = (result+cnt)%MOD
        return result
",n
"
import collections



class Solution(object):
    def findWinners(self, matches):
        lose = collections.defaultdict(int)
        players_set = set()
        for x, y in matches:
            lose[y] += 1
            players_set.add(x)
            players_set.add(y)
        return [[x for x in sorted(players_set) if lose[x] == i] for i in range(2)]
",nlogn
"
import collections


class Solution(object):
    def getDistances(self, arr):
        lookup = collections.defaultdict(list)
        for i, x in enumerate(arr):
            lookup[x].append(i)
        result = [0]*len(arr)
        for idxs in lookup.values():
            prefix = [0]
            for i in idxs:
                prefix.append(prefix[-1]+i)
            for i, idx in enumerate(idxs):
                result[idx] = (idx*(i+1)-prefix[i+1]) + ((prefix[len(idxs)]-prefix[i])-idx*(len(idxs)-i))
        return result
",n
"
import collections



class Solution(object):
    def subarrayLCM(self, nums, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def lcm(a, b):
            return a//gcd(a, b)*b

        result = 0
        dp = collections.Counter()
        for x in nums:
            new_dp = collections.Counter()
            if k%x == 0:
                dp[x] += 1
                for l, cnt in dp.items():
                    new_dp[lcm(l, x)] += cnt
            dp = new_dp
            result += dp[k]
        return result


",n * sqrt(k) * logk
"
class Solution2(object):
    def subarrayLCM(self, nums, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def lcm(a, b):
            return a//gcd(a, b)*b

        result = 0
        for i in range(len(nums)):
            l = 1
            for j in range(i, len(nums)):
                if k%nums[j]:
                    break
                l = lcm(l, nums[j])
                result += int(l == k)
        return result
",n^2
"
class Solution(object):
    def eraseOverlapIntervals(self, intervals):
        intervals.sort(key=lambda interval: interval[1])
        result, right = 0, float(""-inf"")
        for l, r in intervals:
            if l < right:
                result += 1
            else:
                right = r
        return result


",nlogn
"class Solution2(object):
    def eraseOverlapIntervals(self, intervals):
        intervals.sort(key=lambda interval: interval[0])
        result, prev = 0, 0
        for i in range(1, len(intervals)):
            if intervals[i][0] < intervals[prev][1]:
                if intervals[i][1] < intervals[prev][1]:
                    prev = i
                result += 1
            else:
                prev = i
        return result

",nlogn
"
import collections
from functools import reduce



class Solution(object):
    def countSubMultisets(self, nums, l, r):
        MOD = 10**9+7
        cnt = collections.Counter(nums)
        dp = [0]*(r+1)
        dp[0] = 1
        for x, c in cnt.items():
            for i in reversed(range(max(r-x+1, 1), r+1)):
                curr = reduce(lambda x, y: (x+y)%MOD, (dp[i-x*j] for j in range(min(c, i//x+1))))
                for j in reversed(range((i-1)%x+1, i+1, x)):
                    curr = (curr+(dp[j-x*c] if j-x*c >= 0 else 0)-dp[j])%MOD
                    dp[j] = (dp[j]+curr)%MOD
        return (reduce(lambda x, y: (x+y)%MOD, (dp[i] for i in range(l, r+1)))*(cnt[0]+1))%MOD
",n + d * r
"
class Solution(object):
    def twoSum(self, nums, target):
        start, end = 0, len(nums) - 1

        while start != end:
            sum = nums[start] + nums[end]
            if sum > target:
                end -= 1
            elif sum < target:
                start += 1
            else:
                return [start + 1, end + 1]

",n
"
class Solution(object):
    def evaluate(self, s, knowledge):
        lookup = {k: v for k, v in knowledge}
        result, curr = [], []
        has_pair = False
        for c in s:
            if c == '(':
                has_pair = True
            elif c == ')':
                has_pair = False
                result.append(lookup.get("""".join(curr), '?'))
                curr = []
            elif has_pair:
                curr.append(c)
            else:
                result.append(c)
        return """".join(result)
",n + m
"
class Solution(object):
    def findGoodStrings(self, n, s1, s2, evil):
        MOD = 10**9+7
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
    
        prefix = getPrefix(evil)
        dp = [[[[0]*len(evil) for _ in range(2)] for _ in range(2)] for _ in range(2)]
        dp[0][0][0][0] = 1
        for i in range(n):
            dp[(i+1)%2] = [[[0]*len(evil) for _ in range(2)] for _ in range(2)]
            for j in range(2):
                for k in range(2):
                    min_c = 'a' if j else s1[i]
                    max_c = 'z' if k else s2[i]
                    for l in range(len(evil)):
                        if not dp[i%2][j][k][l]:
                            continue
                        for c in range(ord(min_c)-ord('a'), ord(max_c)-ord('a')+1):
                            c = chr(c+ord('a'))
                            m = l-1
                            while m != -1 and evil[m+1] != c:
                                m = prefix[m]
                            if evil[m+1] == c:
                                m += 1
                            if m+1 == len(evil):
                                continue
                            dp[(i+1)%2][j or (s1[i] != c)][k or (s2[i] != c)][m+1] = \
                                (dp[(i+1)%2][j or (s1[i] != c)][k or (s2[i] != c)][m+1] + dp[i%2][j][k][l]) % MOD
        result = 0
        for j in range(2):
            for k in range(2):
                for l in range(len(evil)):
                    result = (result + dp[n%2][j][k][l]) % MOD
        return result
",m * n
"
class Solution(object):
    def unhappyFriends(self, n, preferences, pairs):
        friends = [[0]*n for _ in range(n)]
        for i in range(len(preferences)):
            for j in range(len(preferences[i])):
                friends[i][preferences[i][j]] = j
        pairing = [0]*n
        for i, j in pairs:
            pairing[i], pairing[j] = j, i
        return sum(any(friends[i][j] < friends[i][pairing[i]] and friends[j][i] < friends[j][pairing[j]]
                       for j in range(len(friends[i])) if j != i and j != pairing[i])
                   for i in range(len(friends)))
",n^2
"
import operator
from functools import reduce


class Solution(object):
    def singleNumber(self, A):
        return reduce(operator.xor, A)

",n
"
class Solution(object):
    def maxDotProduct(self, nums1, nums2):
        if len(nums1) < len(nums2):
            return self.maxDotProduct(nums2, nums1)
        dp = [[0]*len(nums2) for i in range(2)]
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                dp[i%2][j] = nums1[i]*nums2[j]
                if i and j:
                    dp[i%2][j] += max(dp[(i-1)%2][j-1], 0)
                if i:
                    dp[i%2][j] = max(dp[i%2][j], dp[(i-1)%2][j])
                if j:
                    dp[i%2][j] = max(dp[i%2][j], dp[i%2][j-1])
        return dp[(len(nums1)-1)%2][-1]
",m * n
"
class Solution(object):
    def reverseParentheses(self, s):
        stk, lookup = [], {}
        for i, c in enumerate(s):
            if c == '(':
                stk.append(i)
            elif c == ')':
                j = stk.pop()
                lookup[i], lookup[j] = j, i
        result = []
        i, d = 0, 1
        while i < len(s):
            if i in lookup:
                i = lookup[i]
                d *= -1
            else:
                result.append(s[i])
            i += d
        return """".join(result)


",n
"class Solution2(object):
    def reverseParentheses(self, s):
        stk = [[]]
        for c in s:
            if c == '(':
                stk.append([])
            elif c == ')':
                end = stk.pop()
                end.reverse()
                stk[-1].extend(end)
            else:
                stk[-1].append(c)
        return """".join(stk.pop())
",n^2
"

class Solution(object):
    def hasMatch(self, s, p):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern, i):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(i, len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1

        i = 0
        for x in p.split('*'):
            if not x:
                continue
            i = KMP(s, x, i)
            if i == -1:
                return False
            i += len(x)
        return True
  
",n + m
"


class Solution(object):
    def countWays(self, nums):
        cnt = [0]*(len(nums)+1)
        for x in nums:
            cnt[x] += 1
        result = prefix = 0
        for i in range(len(nums)+1):
            if prefix == i and cnt[i] == 0:
                result += 1
            prefix += cnt[i]
        return result


",n
"

class Solution2(object):
    def countWays(self, nums):
        nums.sort()
        return sum((i == 0 or nums[i-1] < i) and (i == len(nums) or nums[i] > i) for i in range(len(nums)+1))
",nlogn
"

class Solution(object):
    def hasIncreasingSubarrays(self, nums, k):
        result = 0
        curr, prev = 1, 0
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                curr += 1
            else:
                prev = curr
                curr = 1
            result = max(result, curr//2, min(prev, curr))
        return result >= k
",n
"

class Solution(object):
    def maximumLengthOfRanges(self, nums):
        result = [0]*len(nums)
        stk = [-1]
        nums.append(float(""inf""))
        for i, x in enumerate(nums):
            while stk[-1] != -1 and nums[stk[-1]] < x:
                j = stk.pop()
                result[j] = (i-1)-stk[-1]
            stk.append(i)
        return result
",n
"

class Solution(object):
    def maximizeSquareHoleArea(self, n, m, hBars, vBars):
        def max_gap(arr):
            result = l = 1
            lookup = set(arr)
            while lookup:
                x = next(iter(lookup))
                left = x
                while left-1 in lookup:
                    left -= 1
                right = x
                while right+1 in lookup:
                    right += 1
                for i in range(left, right+1):
                    lookup.remove(i)
                result = max(result, (right-left+1)+1)
            return result

        return min(max_gap(hBars), max_gap(vBars))**2


",h + v
"
class Solution2(object):
    def maximizeSquareHoleArea(self, n, m, hBars, vBars):
        def max_gap(arr):
            arr.sort()
            result = l = 1
            for i in range(len(arr)):
                l += 1
                result = max(result, l)
                if i+1 != len(arr) and arr[i+1] != arr[i]+1:
                    l = 1
            return result

        return min(max_gap(hBars), max_gap(vBars))**2
",hlogh + vlogv
"

class Solution(object):
    def possiblyEquals(self, s1, s2):
        def general_possible_numbers(s): 
            dp = [set() for _ in range(len(s))]
            for i in range(len(s)):
                curr, basis = 0, 1
                for j in reversed(range(i+1)):
                    curr += int(s[j])*basis
                    basis *= 10
                    if s[j] == '0':
                        continue
                    if j == 0:
                        dp[i].add(curr)
                    else:
                        dp[i].update(x+curr for x in dp[j-1])        
            return dp[-1]

        def optimized_possible_numbers(s):
            assert(len(s) <= 3)
            result = {int(s)}
            if len(s) >= 2:
                if s[1] != '0':
                    result.add(int(s[:1])+int(s[1:]))
            if len(s) >= 3:
                if s[2] != '0':
                    result.add(int(s[:2])+int(s[2:]))
                    if s[1] != '0':
                        result.add(int(s[0:1])+int(s[1:2])+int(s[2:]))
            return result
    
        def memoization(s1, s2, i, j, k, lookup):
            if (i, j, k) not in lookup:
                if i == len(s1) and j == len(s2):
                    lookup[(i, j, k)] = (k == 0)
                elif i != len(s1) and s1[i].isdigit():
                    lookup[(i, j, k)] = False
                    for ni in range(i+1, len(s1)+1):
                        if ni == len(s1) or not s1[ni].isdigit():
                            break
                    for x in optimized_possible_numbers(s1[i:ni]):
                        if memoization(s1, s2, ni, j, k+x, lookup):
                            lookup[(i, j, k)] = True
                            break
                elif j != len(s2) and s2[j].isdigit():
                    lookup[(i, j, k)] = False
                    for nj in range(j+1, len(s2)+1):
                        if nj == len(s2) or not s2[nj].isdigit():
                            break
                    for x in optimized_possible_numbers(s2[j:nj]):
                        if memoization(s1, s2, i, nj, k-x, lookup):
                            lookup[(i, j, k)] = True
                            break
                elif k < 0:
                    lookup[(i, j, k)] = memoization(s1, s2, i+1, j, k+1, lookup) if i != len(s1) else False
                elif k > 0:
                    lookup[(i, j, k)] = memoization(s1, s2, i, j+1, k-1, lookup) if j != len(s2) else False
                else:
                    lookup[(i, j, k)] = memoization(s1, s2, i+1, j+1, k, lookup) if i != len(s1) and j != len(s2) and s1[i] == s2[j] else False
            return lookup[(i, j, k)]

        return memoization(s1, s2, 0, 0, 0, {})


",m * n * k
"
class Solution2(object):
    def possiblyEquals(self, s1, s2):
        def memoization(s1, s2, i, j, k, lookup):
            if (i, j, k) not in lookup:
                if i == len(s1) and j == len(s2):
                    lookup[(i, j, k)] = (k == 0)
                elif i != len(s1) and s1[i].isdigit():
                    lookup[(i, j, k)] = False
                    for ni in range(i+1, len(s1)+1):
                        if (ni == len(s1) or s1[ni] != '0') and memoization(s1, s2, ni, j, k+int(s1[i:ni]), lookup):
                            lookup[(i, j, k)] = True
                            break
                        if ni == len(s1) or not s1[ni].isdigit():
                            break
                elif j != len(s2) and s2[j].isdigit():
                    lookup[(i, j, k)] = False
                    for nj in range(j+1, len(s2)+1):
                        if (nj == len(s2) or s2[nj] != '0') and memoization(s1, s2, i, nj, k-int(s2[j:nj]), lookup):
                            lookup[(i, j, k)] = True
                            break
                        if nj == len(s2) or not s2[nj].isdigit():
                            break
                elif k < 0:
                    lookup[(i, j, k)] = memoization(s1, s2, i+1, j, k+1, lookup) if i != len(s1) else False
                elif k > 0:
                    lookup[(i, j, k)] = memoization(s1, s2, i, j+1, k-1, lookup) if j != len(s2) else False
                else:
                    lookup[(i, j, k)] = memoization(s1, s2, i+1, j+1, k, lookup) if i != len(s1) and j != len(s2) and s1[i] == s2[j] else False
            return lookup[(i, j, k)]

        return memoization(s1, s2, 0, 0, 0, {})


",m * n * k
"
class Solution3(object):
    def possiblyEquals(self, s1, s2):
        MAX_DIGIT_LEN = 3
        w = 1+MAX_DIGIT_LEN
        dp = [[set() for _ in range(len(s2)+1)] for _ in range(w)]
        dp[0][0].add(0)
        for i in range(len(s1)+1):
            if i:
                dp[(i-1)%w] = [set() for _ in range(len(s2)+1)]
            if i != len(s1) and s1[i] == '0':
                continue
            for j in range(len(s2)+1):
                for k in dp[i%w][j]:
                    if i != len(s1) and j != len(s2) and s1[i] == s2[j] and k == 0:
                        dp[(i+1)%w][j+1].add(k)
                    if k <= 0 and i != len(s1):
                        if not s1[i].isdigit():
                            if k:
                                dp[(i+1)%w][j].add(k+1)
                        elif s1[i] != '0':
                            curr = 0
                            for ni in range(i, len(s1)):
                                if not s1[ni].isdigit():
                                    break
                                curr = curr*10 + int(s1[ni])
                                dp[(ni+1)%w][j].add(k+curr)
                    if k >= 0 and j != len(s2):
                        if not s2[j].isdigit():
                            if k:
                                dp[i%w][j+1].add(k-1)
                        elif s2[j] != '0':
                            curr = 0
                            for nj in range(j, len(s2)):
                                if not s2[nj].isdigit():
                                    break
                                curr = curr*10 + int(s2[nj])
                                dp[i%w][nj+1].add(k-curr)
        return 0 in dp[len(s1)%w][len(s2)]
",m * n * k
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def getDirections(self, root, startValue, destValue):
        def iter_dfs(root, val):
            path = []
            stk = [(1, (root,))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node = args[0]
                    if node.val == val:
                        path.reverse()
                        return path
                    for i, child in enumerate((node.left, node.right)):
                        if not child:
                            continue
                        stk.append((3, None))
                        stk.append((1, (child,)))
                        stk.append((2, (""LR""[i],)))
                elif step == 2:
                    path.append(args[0])
                elif step == 3:
                    path.pop()
            return []
    
        src = iter_dfs(root, startValue)
        dst = iter_dfs(root, destValue)
        while len(src) and len(dst) and src[-1] == dst[-1]:
            src.pop()
            dst.pop()
        dst.reverse()
        return """".join(['U']*len(src) + dst)


",n
"class Solution2(object):
    def getDirections(self, root, startValue, destValue):
        def dfs(node, val, path):
            if node.val == val:
                return True
            if node.left and dfs(node.left, val, path):
                path.append('L')
            elif node.right and dfs(node.right, val, path):
                path.append('R')
            return path

        src, dst = [], []
        dfs(root, startValue, src)
        dfs(root, destValue, dst)
        while len(src) and len(dst) and src[-1] == dst[-1]:
            src.pop()
            dst.pop()
        dst.reverse()
        return """".join(['U']*len(src) + dst)
",n
"
class Solution(object):
    def findSolution(self, customfunction, z):
        result = []
        x, y = 1, 1
        while customfunction.f(x, y) < z:
            y += 1
        while y > 0:
            while y > 0 and customfunction.f(x, y) > z:
                y -= 1
            if y > 0 and customfunction.f(x, y) == z:
                result.append([x, y])
            x += 1
        return result
",n
"
import collections


class Solution(object):
    def kthDistinct(self, arr, k):
        count = collections.Counter(arr)
        arr = [x for x in arr if count[x] == 1]
        return arr[k-1] if k-1 < len(arr) else """"
",n
"
from sortedcontainers import SortedList



class Solution(object):
    def minimumPairRemoval(self, nums):
        def add(i):
            if 0 <= i < right[i] < len(nums):
                sl.add([nums[i]+nums[right[i]], i])
                if nums[i] > nums[right[i]]:
                    cnt[0] += 1

        def remove(i):
            if 0 <= i < right[i] < len(nums):
                sl.remove([nums[i]+nums[right[i]], i])
                if nums[i] > nums[right[i]]:
                    cnt[0] -= 1

        left = list(range(-1, (len(nums)+1)-1))
        right = list(range(1, len(nums)+1))
        cnt = [sum(nums[i] > nums[i+1] for i in range(len(nums)-1))]
        sl = SortedList([nums[i]+nums[i+1], i] for i in range(len(nums)-1))
        result = 0
        while cnt[0]:
            _, i = sl[0]
            remove(left[i])
            remove(i)
            remove(right[i])
            nums[i] += nums[right[i]]
            left[right[right[i]]] = i
            right[i] = right[right[i]]
            add(left[i])
            add(i)
            result += 1
        return result
",nlogn
"

class Solution(object):
    def matrixSumQueries(self, n, queries):
        lookup = [[False]*n for _ in range(2)]
        cnt = [0]*2
        result = 0
        for t, i, v in reversed(queries):
            if lookup[t][i]:
                continue
            lookup[t][i] = True
            cnt[t] += 1
            result += v*(n-cnt[t^1])
        return result
",n + q
"
class Solution(object):
    def minimumPossibleSum(self, n, target):
        def arithmetic_progression_sum(a, d, n):
            return (a+(a+(n-1)*d))*n//2
    
        a = min(target//2, n)
        b = n-a
        return arithmetic_progression_sum(1, 1, a)+arithmetic_progression_sum(target, 1, b)
    
",1
"

class Solution(object):
    def waysToReachStair(self, k):
        def ceil_log2_x(x):
            return (x-1).bit_length()

        l = ceil_log2_x(k)
        while (1<<l)-k <= l+1:
            l += 1
        fact = [1]*(l+1)
        for i in range(len(fact)-1):
            fact[i+1] = fact[i]*(i+1)
        def nCr(n, r):
            if not (0 <= r <= n):
                return 0
            return fact[n]//fact[r]//fact[n-r]

        return sum(nCr(i+1, (1<<i)-k) for i in range(l))
",logk
"
class Solution(object):
    def arraysIntersection(self, arr1, arr2, arr3):
        result = []
        i, j, k = 0, 0, 0
        while i != len(arr1) and j != len(arr2) and k != len(arr3):
            if arr1[i] == arr2[j] == arr3[k]:
                result.append(arr1[i])
                i += 1
                j += 1
                k += 1
            else:
                curr = max(arr1[i], arr2[j], arr3[k])
                while i != len(arr1) and arr1[i] < curr:
                    i += 1
                while j != len(arr2) and arr2[j] < curr:
                    j += 1
                while k != len(arr3) and arr3[k] < curr:
                    k += 1
        return result


",n
"class Solution2(object):
    def arraysIntersection(self, arr1, arr2, arr3):
        intersect = reduce(set.intersection, list(map(set, [arr2, arr3])))
        return [x for x in arr1 if x in intersect]
",n
"

class Solution(object):
    def minimumDistance(self, points):
        def max_distance(exclude):
            max_sum = max((x+y, i) for i, (x, y) in enumerate(points) if i != exclude)
            min_sum = min((x+y, i) for i, (x, y) in enumerate(points) if i != exclude)
            max_diff = max((x-y, i) for i, (x, y) in enumerate(points) if i != exclude)
            min_diff = min((x-y, i) for i, (x, y) in enumerate(points) if i != exclude)
            return max((max_sum[0]-min_sum[0], max_sum[1], min_sum[1]), 
                       (max_diff[0]-min_diff[0], max_diff[1], min_diff[1]))
        
        _, i, j = max_distance(-1)
        return min(max_distance(i)[0], max_distance(j)[0])
",n
"
import collections



class Solution(object):
    def repeatLimitedString(self, s, repeatLimit):
        cnt = collections.Counter([ord(x)-ord('a') for x in s])
        result = []
        top1 = 25
        while True:
            top1 = next((i for i in reversed(range(top1+1)) if cnt[i]), -1)
            if top1 == -1:
                break
            c = min(cnt[top1], repeatLimit-int(len(result) > 0 and result[-1] == top1))
            cnt[top1] -= c
            result.extend([top1]*c)
            top2 = next((j for j in reversed(range(top1)) if cnt[j]), -1)
            if top2 == -1:
                break
            cnt[top2] -= 1
            result.append(top2)
        return """".join([chr(x+ord('a')) for x in result])
",26 * n
"
class Solution(object):
    def beautySum(self, s):
        result = 0 
        for i in range(len(s)):
            lookup = [0]*26
            for j in range(i, len(s)):
                lookup[ord(s[j])-ord('a')] += 1
                result += max(lookup) - min(x for x in lookup if x)
        return result
",n^2
"

class Solution(object):
    def countCompleteDayPairs(self, hours):
        result = 0
        cnt = [0]*24
        for x in hours:
            result += cnt[-x%24]
            cnt[x%24] += 1
        return result


",n + 24
"
class Solution2(object):
    def countCompleteDayPairs(self, hours):
        return sum((hours[i]+hours[j])%24 == 0 for i in range(len(hours)-1) for j in range(i+1, len(hours)))
",n^2
"
class Solution(object):
    def toHex(self, num):
        if not num:
            return ""0""

        result = []
        while num and len(result) != 8:
            h = num & 15
            if h < 10:
                result.append(str(chr(ord('0') + h)))
            else:
                result.append(str(chr(ord('a') + h-10)))
            num >>= 4
        result.reverse()

        return """".join(result)

",logn
"
class Solution(object):
    def partitionLabels(self, S):
        lookup = {c: i for i, c in enumerate(S)}
        first, last = 0, 0
        result = []
        for i, c in enumerate(S):
            last = max(last, lookup[c])
            if i == last:
                result.append(i-first+1)
                first = i+1
        return result

",n
"
class Solution(object):
    def checkString(self, s):
        return ""ba"" not in s
",n
"

class Solution(object):
    def canMakeSubsequence(self, str1, str2):
        i = 0
        for c in str1:
            if (ord(str2[i])-ord(c))%26 > 1:
                continue
            i += 1
            if i == len(str2):
                return True
        return False
",n
"
import collections


class Solution(object):
    def movesToStamp(self, stamp, target):
        M, N = len(stamp), len(target)

        q = collections.deque()
        lookup = [False]*N
        result = []
        A = []
        for i in range(N-M+1):
            made, todo = set(), set()
            for j, c in enumerate(stamp):
                if c == target[i+j]:
                    made.add(i+j)
                else:
                    todo.add(i+j)
            A.append((made, todo))
            if todo:
                continue
            result.append(i)
            for m in made:
                if lookup[m]:
                    continue
                q.append(m)
                lookup[m] = True

        while q:
            i = q.popleft()
            for j in range(max(0, i-M+1), min(N-M, i)+1):
                made, todo = A[j]
                if i not in todo:
                    continue
                todo.discard(i)
                if todo:
                    continue
                result.append(j)
                for m in made:
                    if lookup[m]:
                        continue
                    q.append(m)
                    lookup[m] = True
        return result[::-1] if all(lookup) else []
",(n - m) * m
"

class Solution(object):
    def findWordsContaining(self, words, x):
        return [i for i, w in enumerate(words) if x in w]
",n * l
"
class Solution(object):
    def minIncrementForUnique(self, A):
        A.sort()
        A.append(float(""inf""))
        result, duplicate = 0, 0
        for i in range(1, len(A)):
            if A[i-1] == A[i]:
                duplicate += 1
                result -= A[i]
            else:
                move = min(duplicate, A[i]-A[i-1]-1)
                duplicate -= move
                result += move*A[i-1] + move*(move+1)//2
        return result
",nlogn
"
from collections import defaultdict

class Solution(object):
    def firstUniqChar(self, s):
        lookup = defaultdict(int)
        candidtates = set()
        for i, c in enumerate(s):
            if lookup[c]:
                candidtates.discard(lookup[c])
            else:
                lookup[c] = i+1
                candidtates.add(i+1)

        return min(candidtates)-1 if candidtates else -1

",n
"
import collections



class Solution(object):
    def divideArray(self, nums):
        return all(cnt%2 == 0 for cnt in collections.Counter(nums).values())
",n
"
import bisect


class Solution(object):
    def findRightInterval(self, intervals):
        sorted_intervals = sorted((interval.start, i) for i, interval in enumerate(intervals))
        result = []
        for interval in intervals:
            idx = bisect.bisect_left(sorted_intervals, (interval.end,))
            result.append(sorted_intervals[idx][1] if idx < len(sorted_intervals) else -1)
        return result

",nlogn
"
class Solution(object):
    def findMaxAverage(self, nums, k):
        result = total = sum(nums[:k])
        for i in range(k, len(nums)):
            total += nums[i] - nums[i-k]
            result = max(result, total)
        return float(result) / k

",n
"

class Solution(object):
    def countEven(self, num):
        def parity(x):
            result = 0
            while x:
                result += x%10
                x //= 10
            return result%2

        return (num-parity(num))//2


",logn
"
class Solution2(object):
    def countEven(self, num):
        def parity(x):
            result = 0
            while x:
                result += x%10
                x //= 10
            return result%2

        return sum(parity(x) == 0 for x in range(1, num+1))


",nlogn
"
class Solution3(object):
    def countEven(self, num):
        return sum(sum(map(int, str(x)))%2 == 0 for x in range(1, num+1))
",nlogn
"

class Solution(object):
    def returnToBoundaryCount(self, nums):
        result = curr = 0
        for x in nums:
            curr += x
            if curr == 0:
                result += 1
        return result
",n
"

class Solution(object):
    def findLatestTime(self, s):
        result = list(s)
        if result[0] == '?': 
            result[0] = '1' if result[1] == '?' or result[1] <= '1' else '0'
        if result[1] == '?': 
            result[1] = '1' if result[0] == '1' else '9'
        if result[3] == '?':
            result[3] = '5'
        if result[4] == '?':
            result[4] = '9'
        return """".join(result)
",1
"
import itertools
from functools import reduce



class Solution(object):
    def minimumCost(self, target, words, costs):
        INF = float(""inf"")
        l = max(len(w) for w in words)
        dp = [INF]*(l+1)
        dp[0] = 0
        for i in range(len(target)):
            if dp[i%len(dp)] == INF:
                continue
            for w, c in zip(words, costs):
                if target[i:i+len(w)] == w:
                    dp[(i+len(w))%len(dp)] = min(dp[(i+len(w))%len(dp)], dp[i%len(dp)]+c)
            dp[i%len(dp)] = INF
        return dp[len(target)%len(dp)] if dp[len(target)%len(dp)] != INF else -1


",n * w * l
"import itertools



class Solution2(object):
    def minimumCost(self, target, words, costs):
        INF = float(""inf"")
        def query(i):
            curr = trie
            for j in range(i, len(target)):
                x = target[j]
                if x not in curr:
                    break
                curr = curr[x]
                if ""_end"" in curr:
                    dp[j+1] = min(dp[j+1], dp[i]+curr[""_end""])

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for w, c in zip(words, costs):
            node = reduce(dict.__getitem__, w, trie)
            if ""_end"" not in node:
                node[""_end""] = INF
            node[""_end""] = min(node[""_end""], c)
        dp = [INF]*(len(target)+1)
        dp[0] = 0
        for i in range(len(target)):
            if dp[i] == INF:
                continue
            query(i)
        return dp[-1] if dp[-1] != INF else -1


",n^2 + w * l
"import itertools



class Solution3(object):
    def minimumCost(self, target, words, costs):
        INF = float(""inf"")
        class Trie(object):
            def __init__(self):
                self.__nodes = []
                self.__mns = []
                self.__new_node()
            
            def __new_node(self):
                self.__nodes.append([-1]*26)
                self.__mns.append(INF)
                return len(self.__nodes)-1

            def add(self, w, c):
                curr = 0
                for x in w:
                    x = ord(x)-ord('a')
                    if self.__nodes[curr][x] == -1:
                        self.__nodes[curr][x] = self.__new_node()
                    curr = self.__nodes[curr][x]
                self.__mns[curr] = min(self.__mns[curr], c)
            
            def query(self, i):
                curr = 0
                for j in range(i, len(target)):
                    x = ord(target[j])-ord('a')
                    if self.__nodes[curr][x] == -1:
                        break
                    curr = self.__nodes[curr][x]
                    if self.__mns[curr] != INF:
                        dp[j+1] = min(dp[j+1], dp[i]+self.__mns[curr])
    
        trie = Trie()
        for w, c in zip(words, costs):
            trie.add(w, c)
        dp = [INF]*(len(target)+1)
        dp[0] = 0
        for i in range(len(target)):
            if dp[i] == INF:
                continue
            trie.query(i)
        return dp[-1] if dp[-1] != INF else -1
",n^2 + w * l
"
import heapq


class Solution(object):
    def longestDiverseString(self, a, b, c):
        max_heap = []
        if a:
            heapq.heappush(max_heap, (-a, 'a'))
        if b:
            heapq.heappush(max_heap, (-b, 'b'))
        if c:
            heapq.heappush(max_heap, (-c, 'c'))
        result = []
        while max_heap:
            count1, c1 = heapq.heappop(max_heap)
            if len(result) >= 2 and result[-1] == result[-2] == c1:
                if not max_heap:
                    return """".join(result)
                count2, c2 = heapq.heappop(max_heap)
                result.append(c2)
                count2 += 1
                if count2:
                    heapq.heappush(max_heap, (count2, c2))
                heapq.heappush(max_heap, (count1, c1))
                continue
            result.append(c1)
            count1 += 1
            if count1 != 0:
                heapq.heappush(max_heap, (count1, c1))
        return """".join(result)


",n
"class Solution2(object):
    def longestDiverseString(self, a, b, c):
        choices = [[a, 'a'], [b, 'b'], [c, 'c']]
        result = []
        for _ in range(a+b+c):
            choices.sort(reverse=True)
            for i, (x, c) in enumerate(choices):
                if x and result[-2:] != [c, c]:
                    result.append(c)
                    choices[i][0] -= 1
                    break
            else:
                break
        return """".join(result)
",n
"

class Solution(object):
    def maxScore(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def lcm(a, b):
            return a//gcd(a, b)*b

        right1 = [0]*(len(nums)+1)
        right2 = [0]*(len(nums)+1)
        right2[-1] = 1
        for i in reversed(range(len(nums))):
            right1[i] = gcd(right1[i+1], nums[i])
            right2[i] = lcm(right2[i+1], nums[i])
        result = right1[0]*right2[0]
        curr1, curr2 = 0, 1
        for i in range(len(nums)):
            result = max(result, gcd(curr1, right1[i+1])*lcm(curr2, right2[i+1]))
            curr1 = gcd(curr1, nums[i])
            curr2 = lcm(curr2, nums[i])
        return result
",nlogr
"
import collections



class Solution(object):
    def findCommonResponse(self, responses):
        cnt = collections.defaultdict(int)
        for r in responses:
            for x in set(r):
                cnt[x] += 1
        return min((-c, x) for x, c in cnt.items())[1]
",n * l
"
import fractions



class Solution(object):
    def rotateGrid(self, grid, k):
        def get_index(m, n, l):
            if l < m-1:
                return l, 0
            if l < (m-1)+(n-1):
                return m-1, l-(m-1)
            if l < (m-1)+(n-1)+(m-1):
                return (m-1)-(l-((m-1)+(n-1))), n-1
            return 0, (n-1)-(l-((m-1)+(n-1)+(m-1)))

        m, n = len(grid), len(grid[0])
        for i in range(min(m, n)//2):
            total = 2*((m-1)+(n-1))
            nk = k%total
            num_cycles = fractions.gcd(total, nk)
            cycle_len = total//num_cycles
            for offset in range(num_cycles):
                r, c = get_index(m, n, offset)
                for j in range(1, cycle_len):
                    nr, nc = get_index(m, n, (offset+j*nk)%total)
                    grid[i+nr][i+nc], grid[i+r][i+c] = grid[i+r][i+c], grid[i+nr][i+nc]
            m, n = m-2, n-2
        return grid


",m * n
"
class Solution2(object):
    def rotateGrid(self, grid, k):
        def get_index(m, n, l):
            if l < m-1:
                return l, 0
            if l < (m-1)+(n-1):
                return m-1, l-(m-1)
            if l < (m-1)+(n-1)+(m-1):
                return (m-1)-(l-((m-1)+(n-1))), n-1
            return 0, (n-1)-(l-((m-1)+(n-1)+(m-1)))

        def reverse(grid, m, n, i, left, right):
            while left < right:
                lr, lc = get_index(m, n, left)
                rr, rc = get_index(m, n, right)
                grid[i+lr][i+lc], grid[i+rr][i+rc] = grid[i+rr][i+rc], grid[i+lr][i+lc]
                left += 1
                right -= 1

        m, n = len(grid), len(grid[0])
        for i in range(min(m, n)//2):
            total = 2*((m-1)+(n-1))
            nk = k%total
            reverse(grid, m, n, i, 0, total-1)
            reverse(grid, m, n, i, 0, nk-1)
            reverse(grid, m, n, i, nk, total-1)
            m, n = m-2, n-2
        return grid
",m * n
"
class Solution(object):
    def shortestCommonSupersequence(self, str1, str2):
        dp = [[0 for _ in range(len(str2)+1)] for _ in range(2)]
        bt = [[None for _ in range(len(str2)+1)] for _ in range(len(str1)+1)]
        for i, c in enumerate(str1):
            bt[i+1][0] = (i, 0, c)
        for j, c in enumerate(str2):
            bt[0][j+1] = (0, j, c)
        for i in range(len(str1)):
            for j in range(len(str2)):
                if dp[i % 2][j+1] > dp[(i+1) % 2][j]:
                    dp[(i+1) % 2][j+1] = dp[i % 2][j+1]
                    bt[i+1][j+1] = (i, j+1, str1[i])
                else:
                    dp[(i+1) % 2][j+1] = dp[(i+1) % 2][j]
                    bt[i+1][j+1] = (i+1, j, str2[j])
                if str1[i] != str2[j]:
                    continue
                if dp[i % 2][j]+1 > dp[(i+1) % 2][j+1]:
                    dp[(i+1) % 2][j+1] = dp[i % 2][j]+1
                    bt[i+1][j+1] = (i, j, str1[i])
        
        i, j = len(str1), len(str2)
        result = []
        while i != 0 or j != 0:
            i, j, c = bt[i][j]
            result.append(c)
        result.reverse()
        return """".join(result)
",m * n
"

class Solution(object):
    def countSubarrays(self, nums, minK, maxK):
        result = left = 0
        right = [-1]*2
        for i, x in enumerate(nums):
            if not (minK <= x <= maxK):
                left = i+1
                continue
            if x == minK:
                right[0] = i
            if x == maxK:
                right[1] = i
            result += max(min(right)-left+1, 0)
        return result
",n
"
import collections


class Solution(object):
    def findLength(self, A, B):
        if len(A) < len(B): return self.findLength(B, A)
        result = 0
        dp = [[0] * (len(B)+1) for _ in range(2)]
        for i in range(len(A)):
            for j in range(len(B)):
                if A[i] == B[j]:
                    dp[(i+1)%2][j+1] = dp[i%2][j]+1
                else:
                    dp[(i+1)%2][j+1] = 0
            result = max(result, max(dp[(i+1)%2]))
        return result


",m * n
"
class Solution2(object):
    def findLength(self, A, B):
        if len(A) > len(B): return self.findLength(B, A)
        M, p = 10**9+7, 113
        p_inv = pow(p, M-2, M)
        def check(guess):
            def rolling_hashes(source, length):
                if length == 0:
                    yield 0, 0
                    return

                val, power = 0, 1
                for i, x in enumerate(source):
                    val = (val + x*power) % M
                    if i < length - 1:
                        power = (power*p) % M
                    else:
                        yield val, i-(length-1)
                        val = (val-source[i-(length-1)])*p_inv % M

            hashes = collections.defaultdict(list)
            for hash_val, i in rolling_hashes(A, guess):
                hashes[hash_val].append(i)
            for hash_val, j in rolling_hashes(B, guess):
                if any(A[i:i+guess] == B[j:j+guess] for i in hashes[hash_val]):
                    return True
            return False

        left, right = 0, min(len(A), len(B)) + 1
        while left < right:
            mid = left + (right-left)/2
            if not check(mid): 
                right = mid
            else:
                left = mid+1
        return left-1


","m * n * log(min(m, n))"
"
class Solution3(object):
    def findLength(self, A, B):
        if len(A) > len(B): return self.findLength(B, A)

        def check(length):
            lookup = set(A[i:i+length] \
                       for i in range(len(A)-length+1))
            return any(B[j:j+length] in lookup \
                       for j in range(len(B)-length+1))

        A = ''.join(map(chr, A))
        B = ''.join(map(chr, B))
        left, right = 0, min(len(A), len(B)) + 1
        while left < right:
            mid = left + (right-left)/2
            if not check(mid): 
                right = mid
            else:
                left = mid+1
        return left-1

","m * n * min(m, n) * log(min(m, n))"
"
from random import randint


class Solution(object):
    def minTotalDistance(self, grid):
        x = [i for i, row in enumerate(grid) for v in row if v == 1]
        y = [j for row in grid for j, v in enumerate(row) if v == 1]
        mid_x = self.findKthLargest(x, len(x) / 2 + 1)
        mid_y = self.findKthLargest(y, len(y) / 2 + 1)

        return sum([abs(mid_x-i) + abs(mid_y-j)
                   for i, row in enumerate(grid)
                   for j, v in enumerate(row) if v == 1])

    def findKthLargest(self, nums, k):
        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = randint(left, right)
            new_pivot_idx = self.PartitionAroundPivot(left, right,
                                                      pivot_idx, nums)
            if new_pivot_idx == k - 1:
                return nums[new_pivot_idx]
            elif new_pivot_idx > k - 1:
                right = new_pivot_idx - 1
            else: 
                left = new_pivot_idx + 1

    def PartitionAroundPivot(self, left, right, pivot_idx, nums):
        pivot_value = nums[pivot_idx]
        new_pivot_idx = left
        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
        for i in range(left, right):
            if nums[i] > pivot_value:
                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                new_pivot_idx += 1

        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
        return new_pivot_idx

",m * n
"

class Solution(object):
    def generateParenthesis(self, n):
        result, curr = [], []
        stk = [(1, (n, n))]
        while stk:
            step, args = stk.pop()
            if step == 1:
                left, right = args
                if left == 0 and right == 0:
                    result.append("""".join(curr))
                if left < right:
                    stk.append((3, tuple()))
                    stk.append((1, (left, right-1)))
                    stk.append((2, (')')))
                if left > 0:
                    stk.append((3, tuple()))
                    stk.append((1, (left-1, right)))
                    stk.append((2, ('(')))
            elif step == 2:
                curr.append(args[0])
            elif step == 3:
                curr.pop()
        return result


",4^n / n^(3/2)
"
class Solution2(object):
    def generateParenthesis(self, n):
        def generateParenthesisRecu(left, right, curr, result):
            if left == 0 and right == 0:
                result.append("""".join(curr))
            if left > 0:
                curr.append('(')
                generateParenthesisRecu(left-1, right, curr, result)
                curr.pop()
            if left < right:
                curr.append(')')
                generateParenthesisRecu(left, right-1, curr, result)
                curr.pop()

        result = []
        generateParenthesisRecu(n, n, [], result)
        return result
",4^n / n^(3/2)
"
import collections


class Solution(object):
    def findTargetSumWays(self, nums, S):
        def subsetSum(nums, S):
            dp = collections.defaultdict(int)
            dp[0] = 1
            for n in nums:
                for i in reversed(range(n, S+1)):
                    if i-n in dp:
                        dp[i] += dp[i-n]
            return dp[S]

        total = sum(nums)
        if total < S or (S + total) % 2: return 0
        P = (S + total) // 2
        return subsetSum(nums, P)

",n * S
"
class Solution(object):
    def romanToInt(self, s):
        numeral_map = {""I"": 1, ""V"": 5, ""X"": 10, ""L"": 50, ""C"":100, ""D"": 500, ""M"": 1000}
        decimal = 0
        for i in range(len(s)):
            if i > 0 and numeral_map[s[i]] > numeral_map[s[i - 1]]:
                decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]]
            else:
                decimal += numeral_map[s[i]]
        return decimal

",n
"
class Solution(object):
    def findPairs(self, nums, k):
        if k < 0: return 0
        result, lookup = set(), set()
        for num in nums:
            if num-k in lookup:
                result.add(num-k)
            if num+k in lookup:
                result.add(num)
            lookup.add(num)
        return len(result)

",n
"
import collections


class Solution(object):
    def tallestBillboard(self, rods):
        def dp(A):
            lookup = collections.defaultdict(int)
            lookup[0] = 0
            for x in A:
                for d, y in list(lookup.items()):
                    lookup[d+x] = max(lookup[d+x], y)
                    lookup[abs(d-x)] = max(lookup[abs(d-x)], y + min(d, x))
            return lookup

        left, right = dp(rods[:len(rods)//2]), dp(rods[len(rods)//2:])
        return max(left[d]+right[d]+d for d in left if d in right)
",n * 3^(n/2)
"
class Solution(object):
    def validWordSquare(self, words):
        for i in range(len(words)):
            for j in range(len(words[i])):
                if j >= len(words) or i >= len(words[j]) or \
                   words[j][i] != words[i][j]:
                   return False
        return True

",m * n
"
import collections



class Solution(object):
    def maxSubarrayLength(self, nums, k):
        cnt = collections.Counter()
        result = left = 0
        for right in range(len(nums)):
            cnt[nums[right]] += 1
            while not (cnt[nums[right]] <= k):
                cnt[nums[left]] -= 1
                left += 1
            result = max(result, right-left+1)
        return result
",n
"
import collections


class Solution(object):
    def numSubmatrixSumTarget(self, matrix, target):
        if len(matrix) > len(matrix[0]):
            return self.numSubmatrixSumTarget(list(map(list, list(zip(*matrix)))), target)
        
        for i in range(len(matrix)):
            for j in range(len(matrix[i])-1):
                matrix[i][j+1] += matrix[i][j]

        result = 0
        for i in range(len(matrix)):
            prefix_sum = [0]*len(matrix[i])
            for j in range(i, len(matrix)):
                lookup = collections.defaultdict(int)
                lookup[0] = 1
                for k in range(len(matrix[j])):
                    prefix_sum[k] += matrix[j][k]
                    if prefix_sum[k]-target in lookup:
                        result += lookup[prefix_sum[k]-target]
                    lookup[prefix_sum[k]] += 1
        return result
",m^2*n
"
class Solution(object):
    def toLowerCase(self, str):
        return """".join([chr(ord('a')+ord(c)-ord('A')) 
                        if 'A' <= c <= 'Z' else c for c in str])

",n
"
import collections


class Solution(object):
    def checkInclusion(self, s1, s2):
        counts = collections.Counter(s1)
        l = len(s1)
        for i in range(len(s2)):
            if counts[s2[i]] > 0:
                l -= 1
            counts[s2[i]] -= 1
            if l == 0:
                return True
            start = i + 1 - len(s1)
            if start >= 0:
                counts[s2[start]] += 1
                if counts[s2[start]] > 0:
                    l += 1
        return False

",n
"

class Solution(object):
    def maxBottlesDrunk(self, numBottles, numExchange):
        result = numBottles
        while numBottles >= numExchange:
            numBottles -= numExchange
            numExchange += 1
            result += 1
            numBottles += 1
        return result
",sqrt(n)
"

class Solution(object):
    def cellsInRange(self, s):
        return [chr(x)+chr(y) for x in range(ord(s[0]), ord(s[3])+1) for y in range(ord(s[1]), ord(s[4])+1)]
",26^2
"
class Solution(object):
    def maximumSwap(self, num):
        digits = list(str(num))
        left, right = 0, 0
        max_idx = len(digits)-1
        for i in reversed(range(len(digits))):
            if digits[i] > digits[max_idx]:
                max_idx = i
            elif digits[max_idx] > digits[i]:
                left, right = i, max_idx
        digits[left], digits[right] = digits[right], digits[left]
        return int("""".join(digits))

",logn
"

class Solution(object):
    def minimumTime(self, hens, grains):
        def check(x):
            i = 0
            for h in hens:
                if h-grains[i] > x:
                    return False
                elif h-grains[i] > 0:
                    d = h-grains[i]
                    c = max(x-2*d, (x-d)//2) 
                else:
                    c = x                   
                while i < len(grains) and grains[i] <= h+c:
                    i += 1
                if i == len(grains):
                    return True
            return False
    
        hens.sort()
        grains.sort()
        left, right = 0, 2*(max(grains[-1], hens[-1])-min(grains[0], hens[0]))
        while left <= right:
            mid = left+(right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return left
    
",mlogm + nlogn + (m + n) * logr
"
class Solution(object):
    def longestConsecutive(self, root):
        def longestConsecutiveHelper(root):
            if not root:
                return 0, 0
            left_len = longestConsecutiveHelper(root.left)
            right_len = longestConsecutiveHelper(root.right)
            cur_inc_len, cur_dec_len = 1, 1
            if root.left:
                if root.left.val == root.val + 1:
                    cur_inc_len = max(cur_inc_len, left_len[0] + 1)
                elif root.left.val == root.val - 1:
                    cur_dec_len = max(cur_dec_len, left_len[1] + 1)
            if root.right:
                if root.right.val == root.val + 1:
                    cur_inc_len = max(cur_inc_len, right_len[0] + 1)
                elif root.right.val == root.val - 1:
                    cur_dec_len = max(cur_dec_len, right_len[1] + 1)
            self.max_len = max(self.max_len, cur_dec_len + cur_inc_len - 1)
            return cur_inc_len, cur_dec_len

        self.max_len = 0
        longestConsecutiveHelper(root)
        return self.max_len

",n
"
import collections



class Solution(object):
    def maxScore(self, prices):
        cnt = collections.Counter()
        for i, x in enumerate(prices):
            cnt[x-i] += x
        return max(cnt.values())
",n
"
class Solution(object):
    def uniquePathsIII(self, grid):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        def index(grid, r, c):
            return 1 << (r*len(grid[0])+c)

        def dp(grid, src, dst, todo, lookup):
            if src == dst:
                return int(todo == 0)
            key = (src, todo)
            if key in lookup:
                return lookup[key]

            result = 0
            for d in directions:
                r, c = src[0]+d[0], src[1]+d[1]
                if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and \
                   grid[r][c] % 2 == 0 and \
                   todo & index(grid, r, c):
                    result += dp(grid, (r, c), dst, todo ^ index(grid, r, c), lookup)

            lookup[key] = result
            return lookup[key]

        todo = 0
        src, dst = None, None
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val % 2 == 0:
                    todo |= index(grid, r, c)
                if val == 1:
                    src = (r, c)
                elif val == 2:
                    dst = (r, c)
        return dp(grid, src, dst, todo, {})
",m * n * 2^(m * n)
"
class Solution(object):
    def modifyString(self, s):
        s = list(s)
        for i in range(len(s)):
            if s[i] != '?':
                continue
            for c in ('a', 'b', 'c'):
                if (i == 0 or s[i-1] != c) and (i == len(s)-1 or c != s[i+1]):
                    break
            s[i] = c
        return """".join(s)
",n
"
import collections


class Solution(object):
    def leadsToDestination(self, n, edges, source, destination):
        UNVISITED, VISITING, DONE = list(range(3))
        def dfs(children, node, destination, status):
            if status[node] == DONE:
                return True
            if status[node] == VISITING:
                return False
            status[node] = VISITING
            if node not in children and node != destination:
                return False
            if node in children:
                for child in children[node]:
                    if not dfs(children, child, destination, status):
                        return False
            status[node] = DONE
            return True
        
        children = collections.defaultdict(list)
        for parent, child in edges:
            children[parent].append(child)
        return dfs(children, source, destination, [0]*n)
",n + e
"

class Solution(object):
    def countOfPairs(self, n, x, y):
        x, y = x-1, y-1
        if x > y:
            x, y = y, x
        diff = [0]*n
        for i in range(n):
            diff[0] += 1+1                                        
            diff[min(abs(i-x), abs(i-y)+1)] += 1                  
            diff[min(abs(i-y), abs(i-x)+1)] += 1                  
            diff[min(abs(i-0), abs(i-y)+1+abs(x-0))] -= 1         
            diff[min(abs(i-(n-1)), abs(i-x)+1+abs(y-(n-1)))] -= 1 
            diff[max(x-i, 0)+max(i-y, 0)+((y-x)+0)//2] -= 1       
            diff[max(x-i, 0)+max(i-y, 0)+((y-x)+1)//2] -= 1       
        for i in range(n-1):
            diff[i+1] += diff[i]
        return diff
",n
"
import itertools


class Solution(object):
    def maxWidthOfVerticalArea(self, points):
        sorted_x = sorted({x for x, y in points})
        return max([b-a for a, b in zip(sorted_x, sorted_x[1:])] + [0])
",nlogn
"

class Solution(object):
    def lengthOfLongestSubsequence(self, nums, target):
        dp = [-1]*(target+1)
        dp[0] = 0
        for x in nums:
            for i in reversed(range(x, len(dp))):
                if dp[i-x] != -1:
                    dp[i] = max(dp[i], dp[i-x]+1)
        return dp[-1]
",n * t
"
class Solution(object):
    def minFlips(self, a, b, c):
        def number_of_1_bits(n):
            result = 0
            while n:
                n &= n-1
                result += 1
            return result

        return number_of_1_bits((a|b)^c) + number_of_1_bits(a&b&~c)


",31
"class Solution2(object):
    def minFlips(self, a, b, c):
        result = 0
        for i in range(31):
            a_i, b_i, c_i = [x&1 for x in [a, b, c]]
            if (a_i | b_i) != c_i:
                result += 2 if a_i == b_i == 1 else 1
            a, b, c = a >> 1, b >> 1, c >> 1
        return result
",31
"
class Solution(object):
    def minSessions(self, tasks, sessionTime):
        dp = [float(""inf"") for _ in range(1<<len(tasks))]
        dp[0] = 0
        for mask in range(len(dp)-1):
            basis = 1
            for task in tasks:
                new_mask = mask|basis
                basis <<= 1
                if new_mask == mask:
                    continue
                if dp[mask]%sessionTime + task > sessionTime:
                    task += sessionTime-dp[mask]%sessionTime 
                dp[new_mask] = min(dp[new_mask], dp[mask]+task)
        return (dp[-1]+sessionTime-1)//sessionTime


",n * 2^n
"class Solution2(object):
    def minSessions(self, tasks, sessionTime):
        dp = [[float(""inf"")]*2 for _ in range(1<<len(tasks))]
        dp[0] = [0, sessionTime]
        for mask in range(len(dp)-1):
            basis = 1
            for task in tasks:
                new_mask = mask|basis
                basis <<= 1
                if new_mask == mask:
                    continue
                if dp[mask][1]+task <= sessionTime:
                    dp[new_mask] = min(dp[new_mask], [dp[mask][0], dp[mask][1]+task])
                else:
                    dp[new_mask] = min(dp[new_mask], [dp[mask][0]+1, task])
        return dp[-1][0]
",n * 2^n
"
class Solution(object):
    def verifyPreorder(self, preorder):
        low, i = float(""-inf""), -1
        for p in preorder:
            if p < low:
                return False
            while i >= 0 and p > preorder[i]:
                low = preorder[i]
                i -= 1
            i += 1
            preorder[i] = p
        return True

",n
"class Solution2(object):
    def verifyPreorder(self, preorder):
        low = float(""-inf"")
        path = []
        for p in preorder:
            if p < low:
                return False
            while path and p > path[-1]:
                low = path[-1]
                path.pop()
            path.append(p)
        return True

",n
"

class Solution(object):
    def maxProfit(self, prices):
        if not prices:
            return 0
        buy, sell, coolDown = [0] * 2, [0] * 2, [0] * 2
        buy[0] = -prices[0]
        for i in range(1, len(prices)):
            buy[i % 2] = max(buy[(i - 1) % 2],
                             coolDown[(i - 1) % 2] - prices[i])
            sell[i % 2] = buy[(i - 1) % 2] + prices[i]
            coolDown[i % 2] = max(coolDown[(i - 1) % 2], sell[(i - 1) % 2])
        return max(coolDown[(len(prices) - 1) % 2],
                   sell[(len(prices) - 1) % 2])

",n
"
import re


class Solution(object):

    def __init__(self, compressedString):
        self.__result = re.findall(r""([a-zA-Z])(\d+)"", compressedString)
        self.__index, self.__num, self.__ch = 0, 0, ' '

    def __next__(self):
        if not self.hasNext():
            return ' '
        if self.__num == 0:
            self.__ch = self.__result[self.__index][0]
            self.__num = int(self.__result[self.__index][1])
            self.__index += 1
        self.__num -= 1
        return self.__ch


    def hasNext(self):
        return self.__index != len(self.__result) or self.__num != 0




",1
"

class Solution(object):
    def reportSpam(self, message, bannedWords):
        THRESHOLD = 2
        lookup = set(bannedWords)
        return sum(m in lookup for m in message) >= THRESHOLD
",n + m
"
class Solution(object):
    def orderOfLargestPlusSign(self, N, mines):
        lookup = {tuple(mine) for mine in mines}
        dp = [[0] * N for _ in range(N)]
        result = 0
        for i in range(N):
            l = 0
            for j in range(N):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = l
            l = 0
            for j in reversed(range(N)):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)

        for j in range(N):
            l = 0
            for i in range(N):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)
            l = 0
            for i in reversed(range(N)):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)
                result = max(result, dp[i][j])
        return result

",n^2
"
class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def findCriticalAndPseudoCriticalEdges(self, n, edges):
        def MST(n, edges, unused=None, used=None):
            union_find = UnionFind(n)
            weight = 0
            if used is not None:
                u, v, w, _ = edges[used]
                if union_find.union_set(u, v):
                    weight += w
            for i, (u, v, w, _) in enumerate(edges):
                if i == unused:
                    continue
                if union_find.union_set(u, v):
                    weight += w
            return weight if union_find.count == 1 else float(""inf"")
        
        for i, edge in enumerate(edges):
            edge.append(i)
        edges.sort(key=lambda x: x[2])
        mst = MST(n, edges)
        result = [[], []]
        for i, edge in enumerate(edges):
            if mst < MST(n, edges, unused=i):
                result[0].append(edge[3])
            elif mst == MST(n, edges, used=i):
                result[1].append(edge[3])
        return result
",nlogn
"
class Solution(object):
    def reachingPoints(self, sx, sy, tx, ty):
        while tx >= sx and ty >= sy:
            if tx < ty:
                sx, sy = sy, sx
                tx, ty = ty, tx
            if ty > sy:
                tx %= ty
            else:
                return (tx - sx) % ty == 0

        return False

","log(max(m, n))"
"
class Solution(object):
    def maxSideLength(self, mat, threshold):
        def check(dp, mid, threshold):
            for i in range(mid, len(dp)):
                for j in range(mid, len(dp[0])):
                    if dp[i][j] - dp[i-mid][j] - dp[i][j-mid] + dp[i-mid][j-mid] <= threshold:
                        return True
            return False
        
        dp = [[0 for _ in range(len(mat[0])+1)] for _ in range(len(mat)+1)]
        for i in range(1, len(mat)+1):
            for j in range(1, len(mat[0])+1):
                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1]

        left, right = 0, min(len(mat), len(mat[0])+1)
        while left <= right:
            mid = left + (right-left)//2
            if not check(dp, mid, threshold):
                right = mid-1
            else:
                left = mid+1
        return right
","m * n * log(min(m, n))"
"
class Solution(object):
    def sumOfBeauties(self, nums):
        right = [nums[-1]]*len(nums)
        for i in reversed(range(2, len(nums)-1)):
            right[i] = min(right[i+1], nums[i])
        result, left = 0, nums[0]
        for i in range(1, len(nums)-1):
            if left < nums[i] < right[i+1]:
                result += 2
            elif nums[i-1] < nums[i] < nums[i+1]:
                result += 1
            left = max(left, nums[i])
        return result
",n
"
import collections



class Solution(object):
    def supersequences(self, words):
        def f(x):
            x = ord(x)-ord('a')
            if char_to_int[x] == -1:
                int_to_char[len(indegree)] = x
                char_to_int[x] = len(indegree)
                indegree.append(0)
            return char_to_int[x]
                
        def topological_sort(cnt):
            total = sum(cnt)
            if total > ans[0]:
                return
            new_cnt = cnt[:]
            new_indgree = indegree[:]
            lookup = [False]*len(cnt)
            q = []
            for u in range(len(indegree)):
                if not new_indgree[u] or new_cnt[u] == 2:
                    new_cnt[u] -= 1
                    lookup[u] = True
                    q.append(u)
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        new_indgree[v] -= 1
                        if new_indgree[v]:
                            continue
                        new_cnt[v] -= 1
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            if any(new_cnt):
                return
            if total < ans[0]:
                ans[0] = total
                ans[1][:] = []
            ans[1].append(cnt)

        adj = [[] for _ in range(26)]
        char_to_int, int_to_char, indegree = [-1]*26, [0]*26, []
        for w in words:
            adj[f(w[0])].append(f(w[1]))
            indegree[f(w[1])] += 1
        ans = [float(""inf""), []]
        for mask in range(1<<len(indegree)):
            topological_sort([2 if mask&(1<<i) else 1 for i in range(len(indegree))])
        result = []
        for cnt in ans[1]:
            new_cnt = [0]*26
            for i, x in enumerate(cnt):
                new_cnt[int_to_char[i]] = x
            result.append(new_cnt)
        return result
",n + k^2 * 2^k
"

class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []



class Solution(object):
    def moveSubTree(self, root, p, q):
        def iter_find_parents(node, parent, p, q, is_ancestor, lookup):
            stk = [(1, [node, None, False])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, parent, is_ancestor = params
                    if node in (p, q):
                        lookup[node] = parent
                        if len(lookup) == 2:
                            return is_ancestor
                    stk.append((2, [node, is_ancestor, reversed(node.children)]))
                else:
                    node, is_ancestor, it = params
                    child = next(it, None)
                    if not child:
                        continue
                    stk.append((2, [node, is_ancestor, it]))
                    stk.append((1, [child, node, is_ancestor or node == p]))
            assert(False)
            return False

        lookup = {}
        is_ancestor = iter_find_parents(root, None, p, q, False, lookup)
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not is_ancestor:
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root


",n
"
class Solution_Recu(object):
    def moveSubTree(self, root, p, q):
        def find_parents(node, parent, p, q, is_ancestor, lookup):
            if node in (p, q):
                lookup[node] = parent
                if len(lookup) == 2:
                    return True, is_ancestor
            for child in node.children:
                found, new_is_ancestor = find_parents(child, node, p, q, is_ancestor or node == p, lookup)
                if found:
                    return True, new_is_ancestor
            return False, False

        lookup = {}
        is_ancestor = find_parents(root, None, p, q, False, lookup)[1]
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not is_ancestor:
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root


",n
"
class Solution2(object):
    def moveSubTree(self, root, p, q):
        def iter_find_parents(node, parent, p, q, lookup):
            stk = [(1, [node, None])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, parent = params
                    if node in (p, q):
                        lookup[node] = parent
                        if len(lookup) == 2:
                            return
                    stk.append((2, [node, reversed(node.children)]))
                else:
                    node, it = params
                    child = next(it, None)
                    if not child:
                        continue
                    stk.append((2, [node, it]))
                    stk.append((1, [child, node]))

        def iter_is_ancestor(node, q):
            stk = [(1, [node])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node = params[0]
                    stk.append((2, [reversed(node.children)]))
                else:
                    it = params[0]
                    child = next(it, None)
                    if not child:
                        continue
                    if child == q:
                        return True
                    stk.append((2, [it]))
                    stk.append((1, [child]))
            return False

        lookup = {}
        iter_find_parents(root, None, p, q, lookup)
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not iter_is_ancestor(p, q):
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root


",n
"
class Solution2_Recu(object):
    def moveSubTree(self, root, p, q):
        def find_parents(node, parent, p, q, lookup):
            if node in (p, q):
                lookup[node] = parent
                if len(lookup) == 2:
                    return True
            for child in node.children:
                if find_parents(child, node, p, q, lookup):
                    return True
            return False

        def is_ancestor(node, q):
            for child in node.children:
                if node == q or is_ancestor(child, q):
                    return True
            return False

        lookup = {}
        find_parents(root, None, p, q, lookup)
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not is_ancestor(p, q):
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root
",n
"
class Solution(object):
    def simplifyPath(self, path):
        stack, tokens = [], path.split(""/"")
        for token in tokens:
            if token == "".."" and stack:
                stack.pop()
            elif token != "".."" and token != ""."" and token:
                stack.append(token)
        return ""/"" + ""/"".join(stack)

",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def constructMaximumBinaryTree(self, nums):
        nodeStack = []
        for num in nums:
            node = TreeNode(num)
            while nodeStack and num > nodeStack[-1].val:
                node.left = nodeStack.pop()
            if nodeStack:
                nodeStack[-1].right = node
            nodeStack.append(node)
        return nodeStack[0]

",n
"
class Solution(object):
    def countQuadruples(self, firstString, secondString):
        lookup1 = [-1]*26
        for i in reversed(range(len(firstString))):
            lookup1[ord(firstString[i])-ord('a')] = i
        lookup2 = [-1]*26
        for i in range(len(secondString)):
            lookup2[ord(secondString[i])-ord('a')] = i
        result, diff = 0, float(""inf"")
        for i in range(26):
            if lookup1[i] == -1 or lookup2[i] == -1:
                continue
            if lookup1[i]-lookup2[i] < diff:
                diff = lookup1[i]-lookup2[i]
                result = 0
            result += int(lookup1[i]-lookup2[i] == diff)
        return result
",n
"
import bisect



class Solution(object):
    def minOperations(self, nums):
        def longest_non_increasing_subsequence(arr):
            result = []
            for x in arr:
                right = bisect.bisect_right(result, -x)
                if right == len(result):
                    result.append(-x)
                else:
                    result[right] = -x
            return len(result)
        
        return longest_non_increasing_subsequence(nums)
",nlogn
"

class Solution(object):
    def differenceOfSum(self, nums):
        def total(x):
            result = 0
            while x:
                result += x%10
                x //= 10
            return result

        return abs(sum(nums)-sum(total(x) for x in nums))
",nlogr
"
class Solution(object):
    def applyOperations(self, nums):
        for i in range(len(nums)-1):
            if nums[i] == nums[i+1]:
                nums[i], nums[i+1] = 2*nums[i], 0
        i = 0
        for x in nums:
            if not x:
                continue
            nums[i] = x
            i += 1
        for i in range(i, len(nums)):
            nums[i] = 0
        return nums
",n
"
import heapq



class Solution(object):
    def maxRunTime(self, n, batteries):
        total = sum(batteries)
        for i in range(len(batteries)):
            batteries[i] = -batteries[i] 
        heapq.heapify(batteries)
        while -batteries[0] > total//n:
            n -= 1
            total -= -heapq.heappop(batteries)
        return total//n


",nlogm
"
class Solution2(object):
    def maxRunTime(self, n, batteries):
        def check(n, batteries, x):
            return sum(min(b, x) for b in batteries) >= n*x

        left, right = min(batteries), sum(batteries)//n
        while left <= right:
            mid = left + (right-left)//2
            if not check(n, batteries, mid):
                right = mid-1
            else:
                left = mid+1
        return right
",nlogr
"

class Solution(object):
    def smallestNumber(self, num):
        def inplace_counting_sort(nums, reverse=False): 
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()

        sign = 1 if num >= 0 else -1
        nums = list(map(int, list(str(abs(num)))))
        inplace_counting_sort(nums, reverse=(sign == -1))
        i = next((i for i in range(len(nums)) if nums[i] != 0), 0)
        nums[0], nums[i] = nums[i], nums[0]
        return sign*int("""".join(map(str, nums)))


",d
"
class Solution2(object):
    def smallestNumber(self, num):
        sign = 1 if num >= 0 else -1
        nums = sorted(str(abs(num)), reverse=(sign == -1))
        i = next((i for i in range(len(nums)) if nums[i] != '0'), 0)
        nums[0], nums[i] = nums[i], nums[0]
        return sign*int("""".join(nums))
",dlogd
"

class Solution(object):
    def sumOfMultiples(self, n):
        def f(d):
            return d*((1+(n//d))*(n//d)//2)
        
        return (f(3)+f(5)+f(7))-(f(3*5)+f(5*7)+f(7*3))+f(3*5*7)
",1
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right



class Solution(object):
    def isValidSequence(self, root, arr):
        q = [root]
        for depth in range(len(arr)):
            new_q = []
            while q:
                node = q.pop()
                if not node or node.val != arr[depth]:
                    continue
                if depth+1 == len(arr) and node.left == node.right:
                    return True
                new_q.extend(child for child in (node.left, node.right))
            q = new_q
        return False


",n
"
class Solution2(object):
    def isValidSequence(self, root, arr):
        s = [(root, 0)]
        while s:
            node, depth = s.pop()
            if not node or depth == len(arr) or node.val != arr[depth]:
                continue
            if depth+1 == len(arr) and node.left == node.right:
                return True
            s.append((node.right, depth+1))
            s.append((node.left, depth+1))
        return False


",n
"
class Solution3(object):
    def isValidSequence(self, root, arr):
        def dfs(node, arr, depth):
            if not node or depth == len(arr) or node.val != arr[depth]:
                return False
            if depth+1 == len(arr) and node.left == node.right:
                return True
            return dfs(node.left, arr, depth+1) or dfs(node.right, arr, depth+1)

        return dfs(root, arr, 0)
",n
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def replaceValueInTree(self, root):
        q = [(root, root.val)]
        while q:
            new_q = []
            total = sum(node.val for node, _ in q)
            for node, x in q:
                node.val = total-x
                x = (node.left.val if node.left else 0) + (node.right.val if node.right else 0)
                if node.left:
                    new_q.append((node.left, x))
                if node.right:
                    new_q.append((node.right, x))
            q = new_q
        return root
",n
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def correctBinaryTree(self, root):
        q = {root:None}
        while q:
            new_q = {}
            for node, parent in q.items():
                if node.right in q:
                    if parent.left == node:
                        parent.left = None
                    else:
                        parent.right = None
                    return root
                if node.left:
                    new_q[node.left] = node
                if node.right:
                    new_q[node.right] = node
            q = new_q
",n
"
class Solution(object):
    def decodeString(self, s):
        n, curr, nums, strs = 0, [], [], []
        for c in s:
            if c.isdigit():
                n = n*10 + ord(c)-ord('0')
            elif c.isalpha():
                curr.append(c)
            elif c == '[':
                nums.append(n)
                strs.append(curr)
                n, curr = 0, []
            elif c == ']':
                strs[-1].extend(curr*nums.pop())
                curr = strs.pop()
        return """".join(curr)
",n
"
class Solution(object):
    def cherryPickup(self, grid):
        n = len(grid)
        dp = [[-1 for _ in range(n)] for _ in range(n)]
        dp[0][0] = grid[0][0]
        max_len = 2 * (n-1)
        directions = [(0, 0), (-1, 0), (0, -1), (-1, -1)]
        for k in range(1, max_len+1):
            for i in reversed(range(max(0, k-n+1), min(k+1, n))): 
                for j in reversed(range(i, min(k+1, n))):         
                    if grid[i][k-i] == -1 or grid[j][k-j] == -1:
                        dp[i][j] = -1
                        continue
                    cnt = grid[i][k-i]
                    if i != j:
                        cnt += grid[j][k-j]
                    max_cnt = -1
                    for direction in directions:
                        ii, jj = i+direction[0], j+direction[1]
                        if ii >= 0 and jj >= 0 and dp[ii][jj] >= 0:
                            max_cnt = max(max_cnt, dp[ii][jj]+cnt)
                    dp[i][j] = max_cnt
        return max(dp[n-1][n-1], 0)

",n^3
"
import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        return True


class Solution(object):
    def smallestStringWithSwaps(self, s, pairs):
        union_find = UnionFind(len(s))
        for x,y in pairs: 
            union_find.union_set(x, y)
        components = collections.defaultdict(list)
        for i in range(len(s)): 
            components[union_find.find_set(i)].append(s[i])
        for i in components.keys(): 
            components[i].sort(reverse=True)
        result = []
        for i in range(len(s)): 
            result.append(components[union_find.find_set(i)].pop())
        return """".join(result)


",nlogn
"import itertools
class Solution2(object):
    def smallestStringWithSwaps(self, s, pairs):
        def dfs(i, adj, lookup, component):
            lookup.add(i)
            component.append(i)
            for j in adj[i]:
                if j in lookup:
                    continue
                dfs(j, adj, lookup, component)
            
        adj = collections.defaultdict(list)
        for i, j in pairs:
            adj[i].append(j)
            adj[j].append(i)
        lookup = set()
        result = list(s)
        for i in range(len(s)):
            if i in lookup:
                continue
            component = []
            dfs(i, adj, lookup, component)
            component.sort()
            chars = sorted(result[k] for k in component)
            for comp, char in zip(component, chars):
                result[comp] = char
        return """".join(result)
",nlogn
"
class Solution(object):
    def maxSubarraySumCircular(self, A):
        total, max_sum, cur_max, min_sum, cur_min = 0, -float(""inf""), 0, float(""inf""), 0
        for a in A:
            cur_max = max(cur_max+a, a)
            max_sum = max(max_sum, cur_max)
            cur_min = min(cur_min+a, a)
            min_sum = min(min_sum, cur_min)
            total += a
        return max(max_sum, total-min_sum) if max_sum >= 0 else max_sum

",n
"
class Solution(object):
    def combinationSum3(self, k, n):
        result = []
        self.combinationSumRecu(result, [], 1, k, n)
        return result

    def combinationSumRecu(self, result, intermediate, start, k, target):
        if k == 0 and target == 0:
            result.append(list(intermediate))
        elif k < 0:
            return
        while start < 10 and start * k + k * (k - 1) / 2 <= target:
            intermediate.append(start)
            self.combinationSumRecu(result, intermediate, start + 1, k - 1, target - start)
            intermediate.pop()
            start += 1

","k * C(n, k)"
"
class Solution(object):
    def optimalDivision(self, nums):
        if len(nums) == 1:
            return str(nums[0])
        if len(nums) == 2:
            return str(nums[0]) + ""/"" + str(nums[1])
        result = [str(nums[0]) + ""/("" + str(nums[1])]
        for i in range(2, len(nums)):
            result += ""/"" + str(nums[i])
        result += "")""
        return """".join(result)

",n
"

class Solution(object):
    def minimumOperations(self, nums):
        return len({x for x in nums if x})
",n
"
class Solution(object):
    def mergeTrees(self, t1, t2):
        if t1 is None:
            return t2
        if t2 is None:
            return t1
        t1.val += t2.val
        t1.left = self.mergeTrees(t1.left, t2.left)
        t1.right = self.mergeTrees(t1.right, t2.right)
        return t1

",n
"
class Solution(object):
    def removeInvalidParentheses(self, s):
        def findMinRemove(s):
            left_removed, right_removed = 0, 0
            for c in s:
                if c == '(':
                    left_removed += 1
                elif c == ')':
                    if not left_removed:
                        right_removed += 1
                    else:
                        left_removed -= 1
            return (left_removed, right_removed)

        def isValid(s):
            sum = 0
            for c in s:
                if c == '(':
                    sum += 1
                elif c == ')':
                    sum -= 1
                if sum < 0:
                    return False
            return sum == 0

        def removeInvalidParenthesesHelper(start, left_removed, right_removed):
            if left_removed == 0 and right_removed == 0:
                tmp = """"
                for i, c in enumerate(s):
                    if i not in removed:
                        tmp += c
                if isValid(tmp):
                    res.append(tmp)
                return

            for i in range(start, len(s)):
                if right_removed == 0 and left_removed > 0 and s[i] == '(':
                    if i == start or s[i] != s[i - 1]: 
                        removed[i] = True
                        removeInvalidParenthesesHelper(i + 1, left_removed - 1, right_removed)
                        del removed[i]
                elif right_removed > 0 and s[i] == ')':
                    if i == start or s[i] != s[i - 1]: 
                        removed[i] = True
                        removeInvalidParenthesesHelper(i + 1, left_removed, right_removed - 1)
                        del removed[i]

        res, removed = [], {}
        (left_removed, right_removed) = findMinRemove(s)
        removeInvalidParenthesesHelper(0, left_removed, right_removed)
        return res

","C(n, c)"
"

class Solution(object):
    def beautifulIndices(self, s, a, b, k):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    yield i-j
                    j = prefix[j]

        result = []
        if not (len(a) <= len(s) and len(b) <= len(s)):
            return result
        lookup = list(KMP(s, b))
        j = 0
        for i in KMP(s, a):
            while j < len(lookup) and lookup[j] < i-k:
                j += 1
            if j < len(lookup) and lookup[j] <= i+k:
                result.append(i)
        return result


",n
"import bisect



class Solution2(object):
    def beautifulIndices(self, s, a, b, k):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern+
            return ((i-(len(pattern)+1))-(len(pattern)-1) for i in range((len(pattern)+1)+(len(pattern)-1) , len(prefix)) if prefix[i]+1 == len(pattern))
    
        result = []
        if not (len(a) <= len(s) and len(b) <= len(s)):
            return result
        lookup = list(KMP(s, b))
        j = 0
        for i in KMP(s, a):
            j = bisect.bisect_left(lookup, i-k)
            if j < len(lookup) and lookup[j] <= i+k:
                result.append(i)
        return result
",n + xlogy
"
import collections
import itertools


class Solution(object):
    def alertNames(self, keyName, keyTime):
        THRESHOLD = 3
        name_to_times = collections.defaultdict(list)
        for name, hour_minute in zip(keyName, keyTime):
            hour, minute = list(map(int, hour_minute.split(':')))
            name_to_times[name].append(hour*60 + minute)
        names = []    
        for name, times in name_to_times.items():
            times.sort()
            left = 0
            for right, time in enumerate(times):
                while time-times[left] > 60:
                    left += 1
                if right-left+1 >= THRESHOLD:
                    names.append(name)
                    break
        names.sort()
        return names
",nlogn
"

class Solution(object):
    def findValidPair(self, s):
        cnt = [0]*9
        for x in s:
            cnt[ord(x)-ord('1')] += 1
        for i in range(len(s)-1):
            if s[i] != s[i+1] and cnt[ord(s[i])-ord('1')] == ord(s[i])-ord('0') and cnt[ord(s[i+1])-ord('1')] == ord(s[i+1])-ord('0'):
                return s[i:i+2]
        return """"
",n
"

class Solution(object):
    def queryConversions(self, conversions, queries):
        MOD = 10**9+7
        def divmod(a, b):
            return (a*pow(b, MOD-2, MOD))%MOD

        def unit():
            adj = [[] for _ in range(len(conversions)+1)]
            for u, v, w in conversions:
                adj[u].append((v, w))
            result = [0]*len(adj)
            result[0] = 1
            q = [0]
            while q:
                new_q = []
                for u in q:
                    for v, w in adj[u]:
                        result[v] = (result[u]*w)%MOD
                        new_q.append(v)
                q = new_q
            return result
        
        lookup = unit()
        return [divmod(lookup[b], lookup[a]) for a, b in queries]
",n + qlogm
"
import collections


class Solution(object):
    def canConstruct(self, s, k):
        count = collections.Counter(s)
        odd = sum(v%2 for v in count.values())
        return odd <= k <= len(s)
",n
"
class Solution(object):
    def removeDuplicates(self, s, k):
        stk = [['^', 0]]
        for c in s:
            if stk[-1][0] == c:
                stk[-1][1] += 1
                if stk[-1][1] == k:
                    stk.pop()
            else:
                stk.append([c, 1])
        return """".join(c*k for c, k in stk)
",n
"

class Solution(object):
    def minimumChairs(self, s):
        result = curr = 0
        for x in s:
            curr += +1 if x == ""E"" else -1
            result = max(result, curr)
        return result
",n
"
class Node(object):
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight


class Solution(object):
    def intersect(self, quadTree1, quadTree2):
        if quadTree1.isLeaf:
            return quadTree1 if quadTree1.val else quadTree2
        elif quadTree2.isLeaf:
            return quadTree2 if quadTree2.val else quadTree1
        topLeftNode = self.intersect(quadTree1.topLeft, quadTree2.topLeft)
        topRightNode = self.intersect(quadTree1.topRight, quadTree2.topRight)
        bottomLeftNode = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)
        bottomRightNode = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)
        if topLeftNode.isLeaf and topRightNode.isLeaf and \
           bottomLeftNode.isLeaf and bottomRightNode.isLeaf and \
           topLeftNode.val == topRightNode.val == bottomLeftNode.val == bottomRightNode.val:
            return Node(topLeftNode.val, True, None, None, None, None)
        return Node(True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode)

",n
"
import collections


class Solution(object):
    def restoreArray(self, adjacentPairs):
        adj = collections.defaultdict(list)
        for u, v in adjacentPairs: 
            adj[u].append(v)
            adj[v].append(u)
        result = next([x, adj[x][0]] for x in adj if len(adj[x]) == 1)
        while len(result) != len(adjacentPairs)+1:
            result.append(adj[result[-1]][adj[result[-1]][0] == result[-2]])
        return result
",n
"

class Solution(object):
    def countGoodIntegers(self, n, k):
        def reverse(x, n):
            if n%2:
                x //= 10
            result = 0
            while x:
                result = result*10+x%10
                x //= 10
            return result

        def palindrome(x, n):
            return x*(10**(n//2))+reverse(x, n)

        def count(x):
            cnt = [0]*10
            while x:
                cnt[x%10] += 1
                x //= 10
            return tuple(cnt)

        fact = [1]*(n+1)
        for i in range(len(fact)-1):
            fact[i+1] = fact[i]*(i+1)
        l = (n+1)//2
        result = 0
        lookup = set()
        for d in range(10**(l-1), 10**l):
            x = palindrome(d, n)
            if x%k:
                continue
            cnt = count(x)
            if cnt in lookup:
                continue
            lookup.add(cnt)
            total = (n-cnt[0])*fact[n-1]
            for c in cnt:
                total //= fact[c]
            result += total
        return result
",n + 10 * 10^((n + 1)/2)
"
class Solution(object):
    def __init__(self):
        self.min = None
        self.stack = []

    def push(self, x):
        if not self.stack:
            self.stack.append(0)
            self.min = x
        else:
            self.stack.append(x - self.min)
            if x < self.min:
                self.min = x

    def pop(self):
        x = self.stack.pop()
        if x < 0:
            self.min = self.min - x

    def top(self):
        x = self.stack[-1]
        if x > 0:
            return x + self.min
        else:
            return self.min

    def getMin(self):
        return self.min

",n
"class Solution2(object):
    def __init__(self):
        self.stack, self.minStack = [], []
    def push(self, x):
        self.stack.append(x)
        if len(self.minStack):
            if x < self.minStack[-1][0]:
                self.minStack.append([x, 1])
            elif x == self.minStack[-1][0]:
                self.minStack[-1][1] += 1
        else:
            self.minStack.append([x, 1])

    def pop(self):
        x = self.stack.pop()
        if x == self.minStack[-1][0]:
            self.minStack[-1][1] -= 1
            if self.minStack[-1][1] == 0:
                self.minStack.pop()

    def top(self):
        return self.stack[-1]

    def getMin(self):
        return self.minStack[-1][0]

",n
"
class Solution3(object):

    def __init__(self):
        self.stack = []

    def push(self, x):
        if self.stack:
            current_min = min(x, self.stack[-1][0])
            self.stack.append((current_min, x))
        else:
            self.stack.append((x, x))

    def pop(self):
        return self.stack.pop()[1]

    def top(self):
        return self.stack[-1][1]

    def getMin(self):
        return self.stack[-1][0]
",1
"
import bisect



class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def countGreatEnoughNodes(self, root, k):
        def merge_at_most_k(a, b):
            result = []
            i = j = 0
            while i < len(a) or j < len(b):
                if j == len(b) or (i < len(a) and a[i] < b[j]):
                    result.append(a[i])
                    i += 1
                else:
                    result.append(b[j])
                    j += 1
                if len(result) == k:
                    break
            return result

        def merge_sort(node):
            if not node:
                return []
            left, right = merge_sort(node.left), merge_sort(node.right)
            smallest_k = merge_at_most_k(left, right)
            i = bisect.bisect_left(smallest_k, node.val)
            if i == k:
                result[0] += 1
            else:
                smallest_k.insert(i, node.val)
                if len(smallest_k) == k+1:
                    smallest_k.pop()
            return smallest_k

        result = [0]
        merge_sort(root)
        return result[0]
",k * h
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def addOneRow(self, root, v, d):
        if d in (0, 1):
            node = TreeNode(v)
            if d == 1:
                node.left = root
            else:
                node.right = root
            return node
        if root and d >= 2:
            root.left = self.addOneRow(root.left,  v, d-1 if d > 2 else 1)
            root.right = self.addOneRow(root.right, v, d-1 if d > 2 else 0)
        return root

",n
"
import collections
import itertools
from functools import reduce



class Solution(object):
    def similarPairs(self, words):
        cnt = collections.Counter()
        result = 0
        for w in words:
            mask = reduce(lambda total, x: total|x, map(lambda c: 1<<(ord(c)-ord('a')), w))
            result += cnt[mask]
            cnt[mask] += 1
        return result
",n * l
"
from collections import defaultdict

class Solution(object):

    def __init__(self):
        self.lookup = defaultdict(int)



    def add(self, number):
        self.lookup[number] += 1


    def find(self, value):
        for key in self.lookup:
            num = value - key
            if num in self.lookup and (num != key or self.lookup[key] > 1):
                return True
        return False


",n
"

class Solution(object):
    def numberOfAlternatingGroups(self, colors):
        k = 3
        result = curr = left = 0
        for right in range(len(colors)+k-1):  
            if right-left+1 == k:
                result += int(curr == k-1)
                curr -= int(colors[left] != colors[(left+1)%len(colors)])
                left += 1
            curr += int(colors[right%len(colors)] != colors[(right+1)%len(colors)])
        return result


",n
"
class Solution2(object):
    def numberOfAlternatingGroups(self, colors):
        return sum(colors[i] != colors[(i+1)%len(colors)] != colors[(i+2)%len(colors)] for i in range(len(colors)))
",n
"
class Solution(object):
    def gcdOfStrings(self, str1, str2):
        def check(s, common):
            i = 0
            for c in s:
                if c != common[i]:
                    return False
                i = (i+1)%len(common)
            return True
    
        def gcd(a, b): 
            while b:
                a, b = b, a % b
            return a
        
        if not str1 or not str2:
            return """"
        c = gcd(len(str1), len(str2))
        result = str1[:c]
        return result if check(str1, result) and check(str2, result) else """"
",m + n
"
import collections



class Solution(object):
    def maximumRobots(self, chargeTimes, runningCosts, budget):
        result = left = curr = 0
        dq = collections.deque()
        for right in range(len(chargeTimes)):
            while dq and chargeTimes[dq[-1]] <= chargeTimes[right]:
                dq.pop()
            dq.append(right)
            curr += runningCosts[right]
            if chargeTimes[dq[0]]+(right-left+1)*curr > budget:
                if dq[0] == left:
                    dq.popleft()
                curr -= runningCosts[left]
                left += 1
        return right-left+1


",n
"import collections



class Solution2(object):
    def maximumRobots(self, chargeTimes, runningCosts, budget):
        result = left = curr = 0
        dq = collections.deque()
        for right in range(len(chargeTimes)):
            while dq and chargeTimes[dq[-1]] <= chargeTimes[right]:
                dq.pop()
            dq.append(right)
            curr += runningCosts[right]
            while dq and chargeTimes[dq[0]]+(right-left+1)*curr > budget:
                if dq[0] == left:
                    dq.popleft()
                curr -= runningCosts[left]
                left += 1
            result = max(result, right-left+1)            
        return result
",n
"
import collections



class Solution(object):
    def canMakeSquare(self, grid):
        N, W = 3, 2
        return any(max(collections.Counter(grid[i+h][j+w] for h in range(W) for w in range(W)).values()) >= W**2-1
                   for i in range(N-W+1) for j in range(N-W+1))
",(n - w + 1)^2 * w^2
"

class Solution(object):
    def maximumSetSize(self, nums1, nums2):
        lookup1, lookup2 = set(nums1), set(nums2)
        n, c = len(nums1), len(lookup1&lookup2)
        d1, d2 = min(len(lookup1)-c, n//2), min(len(lookup2)-c, n//2)
        return min(n, d1+d2+c)


",n
"
class Solution2(object):
    def maximumSetSize(self, nums1, nums2):
        lookup1, lookup2 = set(nums1), set(nums2)
        n, c = len(nums1), len(lookup1&lookup2)
        d1, d2 = min(len(lookup1)-c, n//2), min(len(lookup2)-c, n//2)
        r1, r2 = n//2-d1, n//2-d2
        return d1+d2+min(r1+r2, c) 
",n
"
class Solution(object):

    def __init__(self):
        self.__overlaps = []
        self.__calendar = []


    def book(self, start, end):
        for i, j in self.__overlaps:
            if start < j and end > i:
                return False
        for i, j in self.__calendar:
            if start < j and end > i:
                self.__overlaps.append((max(start, i), min(end, j)))
        self.__calendar.append((start, end))
        return True



",n^2
"
import heapq


class Solution(object):
    def findMaximizedCapital(self, k, W, Profits, Capital):
        curr = []
        future = sorted(zip(Capital, Profits), reverse=True)
        for _ in range(k):
            while future and future[-1][0] <= W:
                heapq.heappush(curr, -future.pop()[1])
            if curr:
                W -= heapq.heappop(curr)
        return W

",nlogn
"

class Solution(object):
    def smallestString(self, s):
        result = list(s)
        i = next((i for i in range(len(s)) if s[i] != 'a'), len(s))
        if i == len(s):
            result[-1] = 'z'
        else:
            for i in range(i, len(s)):
                if result[i] == 'a':
                    break
                result[i] = chr(ord(result[i])-1)
        return """".join(result)
",n
"
from collections import defaultdict
from operator import getitem


class Solution(object):
    def longestWord(self, words):
        _trie = lambda: defaultdict(_trie)
        trie = _trie()
        for i, word in enumerate(words):
            reduce(getitem, word, trie)[""_end""] = i

        stack = list(trie.values())
        result = """"
        while stack:
            curr = stack.pop()
            if ""_end"" in curr:
                word = words[curr[""_end""]]
                if len(word) > len(result) or (len(word) == len(result) and word < result):
                    result = word
                stack += [curr[letter] for letter in curr if letter != ""_end""]
        return result

",n
"
class Solution(object):
    def lengthOfLongestSubstringKDistinct(self, s, k):
        longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in range(256)]
        for i, char in enumerate(s):
            if visited[ord(char)] == 0:
                distinct_count += 1
            visited[ord(char)] += 1
            while distinct_count > k:
                visited[ord(s[start])] -= 1
                if visited[ord(s[start])] == 0:
                    distinct_count -= 1
                start += 1
            longest = max(longest, i - start + 1)
        return longest


",n
"from collections import Counter


class Solution2(object):
    def lengthOfLongestSubstringKDistinct(self, s, k):
        counter = Counter()
        left, max_length = 0, 0
        for right, char in enumerate(s):
            counter[char] += 1
            while len(counter) > k:
                counter[s[left]] -= 1
                if counter[s[left]] == 0:
                    del counter[s[left]]
                left += 1
            max_length = max(max_length, right-left+1)
        return max_length
",n
"
class UndirectedGraphNode(object):
    def __init__(self, x):
        self.label = x
        self.neighbors = []

class Solution(object):
    def cloneGraph(self, node):
        if node is None:
            return None
        cloned_node = UndirectedGraphNode(node.label)
        cloned, queue = {node:cloned_node}, [node]

        while queue:
            current = queue.pop()
            for neighbor in current.neighbors:
                if neighbor not in cloned:
                    queue.append(neighbor)
                    cloned_neighbor = UndirectedGraphNode(neighbor.label)
                    cloned[neighbor] = cloned_neighbor
                cloned[current].neighbors.append(cloned[neighbor])
        return cloned[node]

",n
"

class Solution(object):
    def countTestedDevices(self, batteryPercentages):
        result = 0
        for x in batteryPercentages:
            if x > result:
                result += 1
        return result
",n
"

class Solution(object):
    def minEnd(self, n, x):
        n -= 1
        base_n = base_x = 1
        while base_n <= n:
            if (x&base_x) == 0:
                if n&base_n:
                    x |= base_x
                base_n <<= 1
            base_x <<= 1
        return x
",logn
"
class Solution(object):
    def atMostNGivenDigitSet(self, D, N):
        str_N = str(N)
        set_D = set(D)
        result = sum(len(D)**i for i in range(1, len(str_N)))
        i = 0
        while i < len(str_N):
            result += sum(c < str_N[i] for c in D) * (len(D)**(len(str_N)-i-1))
            if str_N[i] not in set_D:
                break
            i += 1
        return result + int(i == len(str_N))

",logn
"
class Solution(object):
    def maxNumberOfApples(self, arr):
        LIMIT = 5000
        arr.sort()
        result, total = 0, 0
        for x in arr:
            if total+x > LIMIT:
                break
            total += x
            result += 1
        return result
",nlogn
"

class Solution(object):
    def findIntersectionValues(self, nums1, nums2):
        lookup1, lookup2 = set(nums1), set(nums2)
        return [sum(x in lookup2 for x in nums1), sum(x in lookup1 for x in nums2)]
",n + m
"

class Solution(object):
    def treeDiameter(self, edges):
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    for v in reversed(adj[u]):
                        if v == p:
                            continue
                        ret2 = [0]
                        stk.append((2, (ret2, ret)))
                        stk.append((1, (v, u, ret2)))
                elif step == 2:
                    ret2, ret = args
                    result = max(result, ret[0]+(ret2[0]+1))
                    ret[0] = max(ret[0], ret2[0]+1)
            return result
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()


",|V| + |E|
"
class Solution2(object):
    def treeDiameter(self, edges):
        def dfs(u, p):
            mx = 0
            for v in adj[u]:
                if v == p:
                    continue
                curr = dfs(v, u)
                result[0] = max(result[0], mx+(curr+1))
                mx = max(mx, curr+1)
            return mx
            
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1)
        return result[0]


",|V| + |E|
"
class Solution3(object):
    def treeDiameter(self, edges):
        def bfs():
            result = 0
            dp = [0]*len(adj)
            degree = list(map(len, adj))
            q = [u for u in range(len(degree)) if degree[u] == 1]
            while q:
                new_q = []
                for u in q:
                    if degree[u] == 0:
                        continue
                    degree[u] -= 1
                    for v in adj[u]:
                        if degree[v] == 0:
                            continue
                        result = max(result, dp[v]+(dp[u]+1))
                        dp[v] = max(dp[v], (dp[u]+1))
                        degree[v] -= 1
                        if degree[v] == 1:
                            new_q.append(v)
                q = new_q
            return result
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return bfs()


",|V| + |E|
"
class Solution4(object):
    def treeDiameter(self, edges):
        def bfs(root):
            d = new_root = -1
            lookup = [False]*len(adj)
            lookup[root] = True
            q = [root]
            while q:
                d, new_root = d+1, q[0]
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return d, new_root
        
        adj = [[] for _ in range(len(edges)+1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        _, root = bfs(0)
        d, _ = bfs(root)
        return d
",|V| + |E|
"
import collections



class Solution(object):
    def findValidSplit(self, nums):
        def factorize(x):
            result = []
            d = 2
            while d*d <= x:
                e = 0
                while x%d == 0:
                    x //= d
                    e += 1
                if e:
                    result.append([d, e])
                d += 1 if d == 2 else 2
            if x > 1:
                result.append([x, 1])
            return result
        
        right = collections.Counter()
        for x in reversed(nums):
            for p, c in factorize(x):
                right[p] += c
        left = collections.Counter()
        cnt = 0
        for i in range(len(nums)-1):
            for p, c in factorize(nums[i]):
                if not left[p]:
                    cnt += 1
                left[p] += c
                right[p] -= c
                if not right[p]:
                    cnt -= 1
            if not cnt:
                return i
        return -1
",n * sqrt(r)
"

class Solution(object):
    def findChampion(self, grid):
        return next(u for u in range(len(grid)) if sum(grid[u]) == len(grid)-1)
",n^2
"
class Solution(object):
    def longestPalindromeSubseq(self, s):
        dp = [[[0]*26 for _ in range(len(s))] for _ in range(2)]
        for i in reversed(range(len(s))):
            for j in range(i+1, len(s)):
                if i == j-1:
                    if s[j] == s[i]:
                        dp[i%2][j][ord(s[i])-ord('a')] = 2
                else:
                    for k in range(26):
                        if s[j] == s[i] and ord(s[j])-ord('a') != k:
                            dp[i%2][j][ord(s[j])-ord('a')] = max(dp[i%2][j][ord(s[j])-ord('a')], dp[(i+1)%2][j-1][k]+2)
                        dp[i%2][j][k] = max(dp[i%2][j][k], dp[i%2][j-1][k], dp[(i+1)%2][j][k], dp[(i+1)%2][j-1][k])
        return max(dp[0][-1])
",n^2
"

class Solution(object):
    def maximumStrength(self, nums, k):
        dp = [0]*(len(nums)+1)
        for i in range(k):
            new_dp = [float(""-inf"")]*(len(nums)+1)
            for j in range(len(nums)):
                new_dp[j+1] = max(new_dp[j], dp[j])+nums[j]*(k-i)*(1 if i%2 == 0 else -1)
            dp = new_dp
        return max(dp)


",k * n
"
class Solution2(object):
    def maximumStrength(self, nums, k):
        dp = [[float(""-inf"")]*(len(nums)+1) for _ in range(k+1)]
        dp[0] = [0]*(len(nums)+1)
        for i in range(k):
            for j in range(len(nums)):
                dp[i+1][j+1] = max(dp[i+1][j], dp[i][j])+nums[j]*(k-i)*(1 if i%2 == 0 else -1)
        return max(dp[-1])
",k * n
"
class Solution(object):
    def probabilityOfHeads(self, prob, target):
        dp = [0.0]*(target+1)
        dp[0] = 1.0
        for p in prob:
            for i in reversed(range(target+1)):
                dp[i] = (dp[i-1] if i >= 1 else 0.0)*p + dp[i]*(1-p)
        return dp[target]
",n^2
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

    def __repr__(self):
        if self:
            serial = []
            queue = [self]

            while queue:
                cur = queue[0]

                if cur:
                    serial.append(cur.val)
                    queue.append(cur.left)
                    queue.append(cur.right)
                else:
                    serial.append(

                queue = queue[1:]

            while serial[-1] == 
                serial.pop()

            return repr(serial)

        else:
            return None

class Solution(object):
    def generateTrees(self, n):
        return self.generateTreesRecu(1, n)

    def generateTreesRecu(self, low, high):
        result = []
        if low > high:
            result.append(None)
        for i in range(low, high + 1):
            left = self.generateTreesRecu(low, i - 1)
            right = self.generateTreesRecu(i + 1, high)
            for j in left:
                for k in right:
                    cur = TreeNode(i)
                    cur.left = j
                    cur.right = k
                    result.append(cur)
        return result

",4^n / n^(3/2)
"
import collections
from functools import reduce



class Solution(object):
    def countWinningSequences(self, s):
        MOD = 10**9+7
        lookup = {x:i for i, x in enumerate(""FWE"")}
        dp = [collections.defaultdict(int) for _ in range(3)]
        for i, c in enumerate(s):
            new_dp = [collections.defaultdict(int) for _ in range(3)]
            x = lookup[c]
            for j in range(3):
                diff = (j-x+1)%3-1
                if i == 0:
                    new_dp[j][diff] = 1
                    continue
                for k in range(3):
                    if k == j:
                        continue
                    for v, c in dp[k].items():
                        new_dp[j][v+diff] = (new_dp[j][v+diff]+c)%MOD
            dp = new_dp
        return reduce(lambda accu, x: (accu+x)%MOD, (c for j in range(3) for v, c in dp[j].items() if v >= 1), 0)
    
",n^2
"
import collections


class Solution(object):
    def sumOfUnique(self, nums):
        return sum(x for x, c in collections.Counter(nums).items() if c == 1)
",n
"
class Solution(object):
    def minMoves(self, nums, limit):
        diff = [0]*(2*(limit+1))
        for i in range(len(nums)//2):
            left, right = nums[i], nums[-1-i]
            diff[min(left, right)+1] -= 1       
            diff[left+right] -= 1               
            diff[left+right+1] += 1             
            diff[max(left, right)+limit+1] += 1 
        result = count = len(nums)              
        for total in range(2, 2*limit+1):      
            count += diff[total]
            result = min(result, count)
        return result
",n + k
"

class Solution(object):
    def minimumLevels(self, possible):
        prefix = [0]*(len(possible)+1)
        for i in range(len(possible)):
            prefix[i+1] = prefix[i]+(+1 if possible[i] else -1)
        return next((i+1 for i in range(len(possible)-1) if prefix[i+1] > prefix[-1]-prefix[i+1]), -1)
",n
"

class Solution(object):
    def getSmallestString(self, s, k):
        result = [ord(x)-ord('a') for x in s]
        for i in range(len(result)):
            d = min(result[i]-0, 26-result[i])
            result[i] = 0 if d <= k else result[i]-k
            k -= min(d, k)
            if k == 0:
                break
        return """".join([chr(x+ord('a')) for x in result])
",n
"
class Solution(object):
    def cleanRoom(self, robot):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        def goBack(robot):
            robot.turnLeft()
            robot.turnLeft()
            robot.move()
            robot.turnRight()
            robot.turnRight()

        def dfs(pos, robot, d, lookup):
            robot.clean()
            for _ in directions:
                new_pos = (pos[0]+directions[d][0],
                           pos[1]+directions[d][1])
                if new_pos not in lookup:
                    lookup.add(new_pos)
                    if robot.move():
                        dfs(new_pos, robot, d, lookup)
                        goBack(robot)
                robot.turnRight()
                d = (d+1) % len(directions)
        
        dfs((0, 0), robot, 0, set())
",n
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self is None:
            return ""Nil""
        else:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def removeNthFromEnd(self, head, n):
        dummy = ListNode(-1)
        dummy.next = head
        slow, fast = dummy, dummy

        for i in range(n):
            fast = fast.__next__

        while fast.__next__:
            slow, fast = slow.__next__, fast.__next__

        slow.next = slow.next.__next__

        return dummy.__next__

",n
"

class Solution(object):
    def shortestPalindrome(self, s):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if not s:
            return s

        A = s + 
        return s[getPrefix(A)[-1]+1:][::-1] + s


",n
"class Solution2(object):
    def shortestPalindrome(self, s):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if not s:
            return s

        A = s + s[::-1]
        prefix = getPrefix(A)
        i = prefix[-1]
        while i >= len(s):
            i = prefix[i]
        return s[i+1:][::-1] + s


",n
"
class Solution3(object):
    def shortestPalindrome(self, s):
        def preProcess(s):
            if not s:
                return ['^', '$']
            string = ['^']
            for c in s:
                string +=  [
            string += [
            return string

        string = preProcess(s)
        palindrome = [0] * len(string)
        center, right = 0, 0
        for i in range(1, len(string) - 1):
            i_mirror = 2 * center - i
            if right > i:
                palindrome[i] = min(right - i, palindrome[i_mirror])
            else:
                palindrome[i] = 0

            while string[i + 1 + palindrome[i]] == string[i - 1 - palindrome[i]]:
                palindrome[i] += 1

            if i + palindrome[i] > right:
                center, right = i, i + palindrome[i]

        max_len = 0
        for i in range(1, len(string) - 1):
            if i - palindrome[i] == 1:
                max_len = palindrome[i]
        return s[len(s)-1:max_len-1:-1] + s

",n
"

class Solution(object):
    def areSimilar(self, mat, k):
        return all(row[i] == row[(i+k)%len(row)]for row in mat for i in range(len(row)))
",m * n
"
class Solution(object):
    def validSquare(self, p1, p2, p3, p4):
        def dist(p1, p2):
            return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2

        lookup = set([dist(p1, p2), dist(p1, p3),\
                      dist(p1, p4), dist(p2, p3),\
                      dist(p2, p4), dist(p3, p4)])
        return 0 not in lookup and len(lookup) == 2

",1
"

class Solution(object):
    def maxActiveSectionsAfterTrade(self, s):
        curr = prev = mx = cnt1 = 0
        for x in s:
            if x == '0':
                curr += 1
            else:
                if curr:
                    prev = curr
                    curr = 0
                cnt1 += 1
            mx = max(mx, prev+curr)
        return cnt1 if mx in (prev, curr) else mx+cnt1
",n
"
class Solution(object):
    def canMeasureWater(self, x, y, z):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        return z == 0 or ((z <= x + y) and (z % gcd(x, y) == 0))

",logn
"

class Solution(object):
    def maxSubarrays(self, nums):
        result = curr = 0
        for x in nums:
            curr = curr&x if curr else x
            if not curr:
                result += 1
        return max(result, 1)
",n
"

class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def pairSum(self, head):
        def reverseList(head):
            dummy = ListNode()
            while head:
                dummy.next, head.next, head = head, dummy.next, head.next
            return dummy.__next__

        dummy = ListNode(next=head)
        slow = fast = dummy
        while fast.__next__ and fast.next.__next__:
            slow, fast = slow.__next__, fast.next.__next__
        result = 0
        head2 = reverseList(slow)
        while head:
            result = max(result, head.val+head2.val)
            head, head2 = head.__next__, head2.__next__
        return result
",n
"

class Solution(object):
    def countTime(self, time):
        result = 1
        if time[4] == '?':
            result *= 10
        if time[3] == '?':
            result *= 6
        if time[1] == time[0] == '?':
            result *= 24
        elif time[1] == '?':
            result *= 10 if time[0] != '2' else 4
        elif time[0] == '?':
            result *= 3 if time[1] < '4' else 2
        return result
",1
"
class Solution(object):
    def intersectionSizeTwo(self, intervals):
        intervals.sort(key = lambda s_e: (s_e[0], -s_e[1]))
        cnts = [2] * len(intervals)
        result = 0
        while intervals:
            (start, _), cnt = intervals.pop(), cnts.pop()
            for s in range(start, start+cnt):
                for i in range(len(intervals)):
                    if cnts[i] and s <= intervals[i][1]:
                        cnts[i] -= 1
            result += cnt
        return result

",nlogn
"
import bisect



class Solution(object):
    def maximumWeight(self, intervals):
        K = 4
        lookup = {}
        for i, (l, r, w) in enumerate(intervals):
            if (r, l, w) not in lookup:
                lookup[r, l, w] = i
        sorted_intervals = sorted(iter(lookup.keys()), key=lambda x: x[0])
        dp = [[[0, []] for _ in range(K+1)] for _ in range(len(sorted_intervals)+1)]
        for i in range(len(dp)-1):
            j = bisect.bisect_right(sorted_intervals, (sorted_intervals[i][1], 0, 0))-1
            idx = lookup[sorted_intervals[i]]
            for k in range(1, len(dp[i])):
                new_dp = [dp[j+1][k-1][0]-sorted_intervals[i][2], dp[j+1][k-1][1][:]]
                insort(new_dp[1], idx)
                dp[i+1][k] = min(dp[i][k], new_dp)
        return dp[len(sorted_intervals)][K][1]


",nlogn + n * k^2
"import bisect



class Solution2(object):
    def maximumWeight(self, intervals):
        K = 4
        lookup = {}
        for i, (l, r, w) in enumerate(intervals):
            if (l, r, w) not in lookup:
                lookup[l, r, w] = i
        sorted_intervals = sorted(iter(lookup.keys()), key=lambda x: x[0])
        dp = [[[0, []] for _ in range(K+1)] for _ in range(len(sorted_intervals)+1)]
        for i in reversed(range(len(dp)-1)):
            j = bisect.bisect_right(sorted_intervals, (sorted_intervals[i][1]+1, 0, 0))
            idx = lookup[sorted_intervals[i]]
            for k in range(1, len(dp[i])):
                new_dp = [dp[j][k-1][0]-sorted_intervals[i][2], dp[j][k-1][1][:]]
                insort(new_dp[1], idx)
                dp[i][k] = min(dp[i+1][k], new_dp)
        return dp[0][K][1]
",nlogn + n * k^2
"



















class Solution(object):
    def recoverArray(self, n, sums):
        sums.sort() 
        shift, l = 0, len(sums)
        result = []
        for _ in range(n): 
            new_shift = sums[0]-sums[1]
            assert(new_shift <= 0)
            has_zero, j, k = False, 0, 0
            for i in range(l):
                if k < j and sums[k] == sums[i]: 
                    k += 1
                else:
                    if shift == sums[i]-new_shift:
                        has_zero = True
                    sums[j] = sums[i]-new_shift
                    j += 1
            if has_zero: 
                result.append(new_shift)
            else: 
                result.append(-new_shift)
                shift -= new_shift
            l //= 2
        return result


",n * 2^n
"
import collections
from functools import reduce



class Solution2(object):
    def recoverArray(self, n, sums):
        min_sum, max_sum = min(sums), max(sums)
        dp = [0]*(max_sum-min_sum+1)
        for x in sums:
            dp[x-min_sum] += 1
        sorted_sums = [x for x in range(min_sum, max_sum+1) if dp[x-min_sum]] 
        shift = 0
        result = []
        for _ in range(n): 
            new_dp = [0]*(max_sum-min_sum+1)
            new_sorted_sums = []
            new_shift = sorted_sums[0]-sorted_sums[1] if dp[sorted_sums[0]-min_sum] == 1 else 0
            assert(new_shift <= 0)
            for x in sorted_sums:
                if not dp[x-min_sum]:
                    continue
                dp[(x-new_shift)-min_sum] -= dp[x-min_sum] if new_shift else dp[x-min_sum]//2
                new_dp[(x-new_shift)-min_sum] = dp[x-min_sum]
                new_sorted_sums.append(x-new_shift)
            dp = new_dp
            sorted_sums = new_sorted_sums
            if dp[shift-min_sum]: 
                result.append(new_shift)
            else: 
                result.append(-new_shift)
                shift -= new_shift
        return result


",2^n + n * r
"import collections
import operator



class Solution3(object):
    def recoverArray(self, n, sums):
        dp = {k: v for k, v in collections.Counter(sums).items()}
        total = reduce(operator.ior, iter(dp.values()), 0)
        basis = total&-total 
        if basis > 1:
            for k in dp.keys():
                dp[k] //= basis
        sorted_sums = sorted(dp.keys()) 
        shift = 0
        result = [0]*(basis.bit_length()-1)
        for _ in range(n-len(result)): 
            new_dp = {}
            new_sorted_sums = []
            new_shift = sorted_sums[0]-sorted_sums[1]
            assert(new_shift < 0)
            for x in sorted_sums:
                if not dp[x]:
                    continue
                dp[x-new_shift] -= dp[x]
                new_dp[x-new_shift] = dp[x]
                new_sorted_sums.append(x-new_shift)
            dp = new_dp
            sorted_sums = new_sorted_sums
            if shift in dp: 
                result.append(new_shift)
            else: 
                result.append(-new_shift)
                shift -= new_shift
        return result


",n * 2^n
"import collections



class Solution4(object):
    def recoverArray(self, n, sums):
        dp = {k: v for k, v in collections.Counter(sums).items()}
        sorted_sums = sorted(dp.keys()) 
        shift = 0
        result = []
        for _ in range(n): 
            new_dp = {}
            new_sorted_sums = []
            new_shift = sorted_sums[0]-sorted_sums[1] if dp[sorted_sums[0]] == 1 else 0
            assert(new_shift <= 0)
            for x in sorted_sums:
                if not dp[x]:
                    continue
                dp[x-new_shift] -= dp[x] if new_shift else dp[x]//2
                new_dp[x-new_shift] = dp[x]
                new_sorted_sums.append(x-new_shift)
            dp = new_dp
            sorted_sums = new_sorted_sums
            if shift in dp: 
                result.append(new_shift)
            else: 
                result.append(-new_shift)
                shift -= new_shift
        return result


",n * 2^n
"import collections



class Solution5(object):
    def recoverArray(self, n, sums):
        dp = OrderedDict(sorted(collections.Counter(sums).items())) 
        shift = 0
        result = []
        for _ in range(n): 
            new_dp = OrderedDict()
            it = iter(dp)
            min_sum = next(it)
            new_shift = min_sum-next(it) if dp[min_sum] == 1 else 0
            assert(new_shift <= 0)
            for x in dp.keys():
                if not dp[x]:
                    continue
                dp[x-new_shift] -= dp[x] if new_shift else dp[x]//2
                new_dp[x-new_shift] = dp[x]
            dp = new_dp
            if shift in dp: 
                result.append(new_shift)
            else: 
                result.append(-new_shift)
                shift -= new_shift
        return result
",n * 2^n
"

class Solution(object):
    def maxRectangleArea(self, points):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret
    
        points.sort()
        y_to_idx = {y:idx for idx, y in enumerate(sorted(set(y for _, y in points)))}
        bit = BIT(len(y_to_idx))
        lookup = {}
        result = -1
        for i, (x, y) in enumerate(points):
            y_idx = y_to_idx[y]
            bit.add(y_idx, +1)
            if not (i-1 >= 0 and points[i-1][0] == x):
                continue
            prev_y_idx = y_to_idx[points[i-1][1]]
            curr = bit.query(y_idx)-bit.query(prev_y_idx-1)
            if (prev_y_idx, y_idx) in lookup and lookup[prev_y_idx, y_idx][0] == curr-2:
                result = max(result, (x-lookup[prev_y_idx, y_idx][1])*(y-points[i-1][1]))
            lookup[prev_y_idx, y_idx] = (curr, x)
        return result


",nlogn
"
class Solution2(object):
    def maxRectangleArea(self, points):
        result = -1
        points.sort()
        for i in range(len(points)-3):
            if points[i][0] != points[i+1][0]:
                continue
            j = next((j for j in range(i+2, len(points)-1) if points[i][1] <= points[j][1] <= points[i+1][1]), len(points)-1)
            if j == len(points)-1 or not (points[j][0] == points[j+1][0] and points[i][1] == points[j][1] and points[i+1][1] == points[j+1][1]):
                continue
            result = max(result, (points[i+1][1]-points[i][1])*(points[j][0]-points[i][0]))
        return result
 
",n^2
"
class Solution(object):
    def largestPalindrome(self, n):
        if n == 1:
            return 9
        upper = 10**n-1
        for k in range(2, upper+1):
            left = 10**n-k
            right = int(str(left)[::-1])
            d = k**2-right*4
            if d < 0:
                continue
            if d**0.5 == int(d**0.5) and k%2 == int(d**0.5)%2:
                return (left*10**n+right)%1337
        return -1


",n * 10^n
"class Solution2(object):
    def largestPalindrome(self, n):
        def divide_ceil(a, b):
            return (a+b-1)//b

        if n == 1:
            return 9
        upper, lower = 10**n-1, 10**(n-1)
        for i in reversed(range(lower, upper**2//(10**n)+1)):
            candidate = int(str(i) + str(i)[::-1])
            for y in reversed(range(divide_ceil(lower, 11)*11, upper+1, 11)): 
                if candidate//y > upper:
                    break
                if candidate%y == 0 and lower <= candidate//y:
                    return candidate%1337
        return -1
",10^(2n)
"

class Solution(object):
    def distinctAverages(self, nums):
        lookup = set()
        nums.sort()
        left, right = 0, len(nums)-1
        while left < right:
            lookup.add(nums[left]+nums[right])
            left, right = left+1, right-1
        return len(lookup)
",nlogn
"
import collections


class Solution(object):
    def numRabbits(self, answers):
        count = collections.Counter(answers)
        return sum((((k+1)+v-1)//(k+1))*(k+1) for k, v in count.items())

",n
"
class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def swimInWater(self, grid):
        n = len(grid)
        positions = [None] * (n**2)
        for i in range(n):
            for j in range(n):
                positions[grid[i][j]] = (i, j)
        directions = ((-1, 0), (1, 0), (0, -1), (0, 1))

        union_find = UnionFind(n**2)
        for elevation in range(n**2):
            i, j = positions[elevation]
            for direction in directions:
                x, y = i+direction[0], j+direction[1]
                if 0 <= x < n and 0 <= y < n and grid[x][y] <= elevation:
                    union_find.union_set(i*n+j, x*n+y)
                    if union_find.find_set(0) == union_find.find_set(n**2-1):
                        return elevation
        return n**2-1


",n^2
"
from fractions import Fraction


class Solution(object):
    def isRationalEqual(self, S, T):
        def frac(S):
            if '.' not in S:
                return Fraction(int(S), 1)

            i = S.index('.')
            result = Fraction(int(S[:i]), 1)
            non_int_part = S[i+1:]
            if '(' not in non_int_part:
                if non_int_part:
                    result += Fraction(int(non_int_part), 10**len(non_int_part))
                return result

            i = non_int_part.index('(')
            if i:
                result += Fraction(int(non_int_part[:i]), 10**i)
            repeat_part = non_int_part[i+1:-1]
            result += Fraction(int(repeat_part), 10**i * (10**len(repeat_part)-1))
            return result

        return frac(S) == frac(T)
",1
"
class Solution(object):
    def minDeletionSize(self, A):
        result = 0
        unsorted = set(range(len(A)-1))
        for j in range(len(A[0])):
            if any(A[i][j] > A[i+1][j] for i in unsorted):
                result += 1
            else:
                unsorted -= set(i for i in unsorted if A[i][j] < A[i+1][j])
        return result


",n * l
"class Solution2(object):
    def minDeletionSize(self, A):
        result = 0
        is_sorted = [False]*(len(A)-1)
        for j in range(len(A[0])):
            tmp = is_sorted[:]
            for i in range(len(A)-1):
                if A[i][j] > A[i+1][j] and tmp[i] == False:
                    result += 1
                    break
                if A[i][j] < A[i+1][j]:
                    tmp[i] = True
            else:
                is_sorted = tmp
        return result
",n * m
"
class Solution(object):
    def boxDelivering(self, boxes, portsCount, maxBoxes, maxWeight):
        dp = [0]*(len(boxes)+1)
        left, cost, curr = 0, 1, 0
        for right in range(len(boxes)):
            if right == 0 or boxes[right][0] != boxes[right-1][0]:
                cost += 1
            curr += boxes[right][1]
            while right-left+1 > maxBoxes or \
                  curr > maxWeight or \
                  (left+1 < right+1 and dp[left+1] == dp[left]): 
                curr -= boxes[left][1]
                if boxes[left+1][0] != boxes[left][0]:
                    cost -= 1
                left += 1
            dp[right+1] = dp[(left-1)+1] + cost
        return dp[len(boxes)]
",n
"
class Solution(object):
    def numWays(self, s):
        MOD = 10**9+7

        ones = s.count('1')
        if ones % 3:
            return 0
        ones //= 3
        if ones == 0:
            return (len(s)-1)*(len(s)-2)//2 % MOD
        count = left = right = 0
        for c in s:
            if c == '1':
                count += 1
            if count == ones:
                left += 1
            elif count == 2*ones:
                right += 1
        return left*right % MOD
",n
"
class Solution(object):
    def inorderSuccessor(self, root, p):
        if p and p.right:
            p = p.right
            while p.left:
                p = p.left
            return p

        successor = None
        while root and root != p:
            if root.val > p.val:
                successor = root
                root = root.left
            else:
                root = root.right

        return successor

",h
"
import operator

class Solution(object):
    def evalRPN(self, tokens):
        numerals, operators = [], {""+"": operator.add, ""-"": operator.sub, ""*"": operator.mul, ""/"": operator.div}
        for token in tokens:
            if token not in operators:
                numerals.append(int(token))
            else:
                y, x = numerals.pop(), numerals.pop()
                numerals.append(int(operators[token](x * 1.0, y)))
        return numerals.pop()

",n
"

class Solution(object):
    def maxDistToClosest(self, seats):
        prev, result = -1, 1
        for i in range(len(seats)):
            if seats[i]:
                if prev < 0:
                    result = i
                else:
                    result = max(result, (i-prev)//2)
                prev = i
        return max(result, len(seats)-1-prev)

",n
"
class Solution(object):
    def wiggleSort(self, nums):
        for i in range(1, len(nums)):
            if ((i % 2) and nums[i - 1] > nums[i]) or \
                (not (i % 2) and nums[i - 1] < nums[i]):
                nums[i - 1], nums[i] = nums[i], nums[i - 1]


",n
"class Solution2(object):
    def wiggleSort(self, nums):
        nums.sort()
        med = (len(nums) - 1) // 2
        nums[::2], nums[1::2] = nums[med::-1], nums[:med:-1]
",nlogn
"

class Solution(object):
    def makeFancyString(self, s):
        s = list(s)
        cnt = j = 0
        for i, c in enumerate(s):
            cnt = cnt+1 if i >= 1 and c == s[i-1] else 1
            if cnt < 3:
                s[j] = c
                j += 1
        s[:] = s[:j]
        return """".join(s)
",n
"
class Solution(object):
    def sortString(self, s):
        result, count = [], [0]*26
        for c in s:
            count[ord(c)-ord('a')] += 1
        while len(result) != len(s):
            for c in range(len(count)):
                if not count[c]:
                    continue
                result.append(chr(ord('a')+c))
                count[c] -= 1
            for c in reversed(range(len(count))):
                if not count[c]:
                    continue
                result.append(chr(ord('a')+c))
                count[c] -= 1
        return """".join(result)


",n
"import collections


class Solution2(object):
    def sortString(self, s):
        result, count, desc = [], collections.Counter(s), False
        while count:
            for c in sorted(list(count.keys()), reverse=desc):
                result.append(c)
                count[c] -= 1
                if not count[c]:
                    del count[c]
            desc = not desc
        return """".join(result)

",n
"
import string


class Solution(object):
    def validIPAddress(self, IP):
        blocks = IP.split('.')
        if len(blocks) == 4:
            for i in range(len(blocks)):
                if not blocks[i].isdigit() or not 0 <= int(blocks[i]) < 256 or \
                   (blocks[i][0] == '0' and len(blocks[i]) > 1):
                    return ""Neither""
            return ""IPv4""

        blocks = IP.split(':')
        if len(blocks) == 8:
            for i in range(len(blocks)):
                if not (1 <= len(blocks[i]) <= 4) or \
                   not all(c in string.hexdigits for c in blocks[i]):
                    return ""Neither""
            return ""IPv6""
        return ""Neither""

",1
"

class Solution:
    def toArray(self, node):
        while node.prev:
            node = node.prev
        result = []
        while node:
            result.append(node.val)
            node = node.__next__
        return result
",n
"
class Solution(object):
    def checkOnesSegment(self, s):
        return ""01"" not in s
",n
"
class Solution(object):
    def isPalindrome(self, s):
        i, j = 0, len(s) - 1
        while i < j:
            while i < j and not s[i].isalnum():
                i += 1
            while i < j and not s[j].isalnum():
                j -= 1
            if s[i].lower() != s[j].lower():
                return False
            i, j = i + 1, j - 1
        return True

",n
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):		
        if self:		
            return ""{} -> {}"".format(self.val, self.__next__)



class Solution(object):
    def mergeKLists(self, lists):
        def mergeTwoLists(l1, l2):
            curr = dummy = ListNode(0)
            while l1 and l2:
                if l1.val < l2.val:
                    curr.next = l1
                    l1 = l1.__next__
                else:
                    curr.next = l2
                    l2 = l2.__next__
                curr = curr.__next__
            curr.next = l1 or l2
            return dummy.__next__

        if not lists:
            return None
        left, right = 0, len(lists) - 1
        while right > 0:
            lists[left] = mergeTwoLists(lists[left], lists[right])
            left += 1
            right -= 1
            if left >= right:
                left = 0
        return lists[0]


",nlogk
"
class Solution2(object):
    def mergeKLists(self, lists):
        def mergeTwoLists(l1, l2):
            curr = dummy = ListNode(0)
            while l1 and l2:
                if l1.val < l2.val:
                    curr.next = l1
                    l1 = l1.__next__
                else:
                    curr.next = l2
                    l2 = l2.__next__
                curr = curr.__next__
            curr.next = l1 or l2
            return dummy.__next__

        def mergeKListsHelper(lists, begin, end):
            if begin > end:
                return None
            if begin == end:
                return lists[begin]
            return mergeTwoLists(mergeKListsHelper(lists, begin, (begin + end) / 2), \
                                 mergeKListsHelper(lists, (begin + end) / 2 + 1, end))

        return mergeKListsHelper(lists, 0, len(lists) - 1)


",nlogk
"
import heapq
class Solution3(object):
    def mergeKLists(self, lists):
        dummy = ListNode(0)
        current = dummy

        heap = []
        for sorted_list in lists:
            if sorted_list:
                heapq.heappush(heap, (sorted_list.val, sorted_list))

        while heap:
            smallest = heapq.heappop(heap)[1]
            current.next = smallest
            current = current.__next__
            if smallest.__next__:
                heapq.heappush(heap, (smallest.next.val, smallest.__next__))

        return dummy.__next__


",nlogk
"
import collections



class Solution(object):
    def isPossibleToSplit(self, nums):
        return all(v <= 2 for v in collections.Counter(nums).values())
",n
"

class Solution(object):
    def numberOfWays(self, n, x):
        MOD = 10**9+7

        dp = [0]*(n+1)
        dp[0] = 1
        for i in range(1, n+1):
            i_pow_x = i**x
            if i_pow_x > n:
                break
            for j in reversed(range(i_pow_x, n+1)):
                dp[j] = (dp[j]+dp[j-i_pow_x])%MOD
        return dp[-1]
",nlogn
"
class Solution(object):
    def numberOfArrays(self, s, k):
        MOD = 10**9 + 7
        klen = len(str(k))
        dp = [0]*(klen+1)
        dp[len(s)%len(dp)] = 1
        for i in reversed(range(len(s))):
            dp[i%len(dp)] = 0
            if s[i] == '0':
                continue
            curr = 0
            for j in range(i, min(i+klen, len(s))):
                curr = 10*curr + int(s[j])
                if curr > k:
                    break
                dp[i%len(dp)] = (dp[i%len(dp)] + dp[(j+1)%len(dp)])%MOD
        return dp[0]
",nlogk
"
import heapq



class Solution(object):
    def minimumTime(self, grid):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))
        def dijkstra(start, target):
            best = [[float(""inf"")]*len(grid[0]) for _ in range(len(grid))]
            best[start[0]][start[1]] = 0
            min_heap = [(0, start[0], start[1])]
            while min_heap:
                curr, i, j = heapq.heappop(min_heap)
                if best[i][j] < curr:
                    continue
                if (i, j) == target:
                    break
                for di, dj in DIRECTIONS:  
                    ni, nj = i+di, j+dj   
                    if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and best[ni][nj] > max(grid[ni][nj]+int(grid[ni][nj]%2 == best[i][j]%2), curr+1)):
                        continue
                    best[ni][nj] = max(grid[ni][nj]+int(grid[ni][nj]%2 == best[i][j]%2), curr+1)
                    heapq.heappush(min_heap, (best[ni][nj], ni, nj))
            return best[target[0]][target[1]]

        if min(grid[0][1], grid[1][0]) > 1:
            return -1
        return dijkstra((0, 0), (len(grid)-1, len(grid[0])-1))
",m * n * log(m * n)
"

class Solution(object):
    def minImpossibleOR(self, nums):
        lookup = set(nums)
        return next(1<<i for i in range(31) if 1<<i not in lookup)
",logr
"
class Solution(object):
    def sortArrayByParity(self, A):
        i = 0
        for j in range(len(A)):
            if A[j] % 2 == 0:
                A[i], A[j] = A[j], A[i]
                i += 1
        return A

",n
"
class Solution(object):
    def crackSafe(self, n, k):
        M = k**(n-1)
        P = [q*k+i for i in range(k) for q in range(M)] 
        result = [str(k-1)]*(n-1)
        for i in range(k**n):
            j = i
            while P[j] >= 0:
                result.append(str(j//M))
                P[j], j = -1, P[j]
        return """".join(result)


",k^n
"class Solution2(object):
    def crackSafe(self, n, k):
        total = k**n
        M = total//k
        unique_rolling_hash = 0
        result = [str(0)]*(n-1)
        lookup = set()
        while len(lookup) < total:
            for i in reversed(range(k)): 
                new_unique_rolling_hash = unique_rolling_hash*k + i
                if new_unique_rolling_hash not in lookup:
                    lookup.add(new_unique_rolling_hash)
                    result.append(str(i))
                    unique_rolling_hash = new_unique_rolling_hash%M
                    break
        return """".join(result)


",k^n
"class Solution3(object):
    def crackSafe(self, n, k):
        M = k**(n-1)
        def dfs(k, unique_rolling_hash, lookup, result):
            for i in reversed(range(k)): 
                new_unique_rolling_hash = unique_rolling_hash*k + i
                if new_unique_rolling_hash not in lookup:
                    lookup.add(new_unique_rolling_hash)
                    result.append(str(i))
                    dfs(k, new_unique_rolling_hash%M, lookup, result)
                    break

        unique_rolling_hash = 0
        result = [str(0)]*(n-1)
        lookup = set()
        dfs(k, unique_rolling_hash, lookup, result)
        return """".join(result)


",k^n
"class Solution4(object):
    def crackSafe(self, n, k):
        result = [str(k-1)]*(n-1)
        lookup = set()
        total = k**n
        while len(lookup) < total:
            node = result[len(result)-n+1:]
            for i in range(k): 
                neighbor = """".join(node) + str(i)
                if neighbor not in lookup:
                    lookup.add(neighbor)
                    result.append(str(i))
                    break
        return """".join(result)


",n * k^n
"class Solution5(object):
    def crackSafe(self, n, k):
        def dfs(k, node, lookup, result):
            for i in range(k): 
                neighbor = node + str(i)
                if neighbor not in lookup:
                    lookup.add(neighbor)
                    result.append(str(i))
                    dfs(k, neighbor[1:], lookup, result)
                    break

        result = [str(k-1)]*(n-1)
        lookup = set()
        dfs(k, """".join(result), lookup, result)
        return """".join(result)

",n * k^n
"

class Solution(object):
    def baseUnitConversions(self, conversions):
        MOD = 10**9+7
        adj = [[] for _ in range(len(conversions)+1)]
        for u, v, w in conversions:
            adj[u].append((v, w))
        result = [0]*len(adj)
        result[0] = 1
        q = [0]
        while q:
            new_q = []
            for u in q:
                for v, w in adj[u]:
                    result[v] = (result[u]*w)%MOD
                    new_q.append(v)
            q = new_q
        return result
",n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def minCameraCover(self, root):
        UNCOVERED, COVERED, CAMERA = list(range(3))
        def dfs(root, result):
            left = dfs(root.left, result) if root.left else COVERED
            right = dfs(root.right, result) if root.right else COVERED
            if left == UNCOVERED or right == UNCOVERED:
                result[0] += 1
                return CAMERA
            if left == CAMERA or right == CAMERA:
                return COVERED
            return UNCOVERED
        
        result = [0]
        if dfs(root, result) == UNCOVERED:
            result[0] += 1
        return result[0]
",n
"
import random

class Solution(object):
    def minOperations(self, grid, x):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        nums = [v for row in grid for v in row]
        if len(set(v%x for v in nums)) > 1:
            return -1
        nth_element(nums, len(nums)//2)
        median = nums[len(nums)//2]
        return sum(abs(v-median)//x for v in nums)
",m * n
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def canMerge(self, trees):
        def find_leaves_and_roots(trees, leaf_vals_set, val_to_root):
            for root in trees:
                val_to_root[root.val] = root
                q = [root]
                while q:
                    new_q = []
                    for node in q:
                        if node.left is None and node.right is None:
                            if node is not root:
                                leaf_vals_set.add(node.val)
                            continue
                        if node.left:
                            new_q.append(node.left)
                        if node.right:
                            new_q.append(node.right)
                    q = new_q

        def find_root(trees, left_vals_set, val_to_root):
            root = None
            for node in trees:
                if node.val in leaf_vals_set:
                    continue
                if root: 
                    return None
                root = node
            return root

        def merge_bsts(root, left_vals_set, val_to_root):
            if not root:
                return None
            del val_to_root[root.val]
            q = [(root, float(""-inf""), float(""inf""))]
            while q:
                new_q = []
                for node, left, right in q:
                    if not (left < node.val < right):
                        return None
                    if node.left:
                        if node.left.val in leaf_vals_set and node.left.val in val_to_root:
                            node.left = val_to_root[node.left.val]
                            del val_to_root[node.left.val]
                        new_q.append((node.left, left, node.val))
                    if node.right:
                        if node.right.val in leaf_vals_set and node.right.val in val_to_root:
                            node.right = val_to_root[node.right.val]
                            del val_to_root[node.right.val]
                        new_q.append((node.right, node.val, right))
                q = new_q
            return root if not val_to_root else None

        leaf_vals_set, val_to_root = set(), {}
        find_leaves_and_roots(trees, leaf_vals_set, val_to_root)    
        root = find_root(trees, leaf_vals_set, val_to_root)
        return merge_bsts(root, leaf_vals_set, val_to_root)
",n
"
class Solution(object):
    def shuffle(self, nums, n):
        def index(i):
            return 2*i if i < n else 2*(i-n)+1
    
        for i in range(len(nums)):
            j = i
            while nums[i] >= 0:
                j = index(j)
                nums[i], nums[j] = nums[j], ~nums[i] 
        for i in range(len(nums)):
            nums[i] = ~nums[i]
        return nums
",n
"

class Solution(object):
    def leftRigthDifference(self, nums):
        total = sum(nums)
        result = []
        curr = 0
        for x in nums:
            curr += x
            result.append(abs((curr-x)-(total-curr)))
        return result
",n
"

class Solution(object):
    def removeStars(self, s):
        result = []
        for c in s:
            if c == '*':
                result.pop()
            else:
                result.append(c)
        return """".join(result)
",n
"
import collections
from functools import reduce



class Solution(object):
    def sumOfGoodSubsequences(self, nums):
        MOD = 10**9+7
        dp = collections.defaultdict(int)
        cnt = collections.defaultdict(int)
        for x in nums:
            c = cnt[x-1]+cnt[x+1]+1
            cnt[x] = (cnt[x]+c)%MOD
            dp[x] = (dp[x]+(dp[x-1]+dp[x+1]+x*c))%MOD
        return reduce(lambda accu, x: (accu+x)%MOD, iter(dp.values()))
    
",n
"
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def diameterOfBinaryTree(self, root):
        def iter_dfs(node):
            result = 0
            stk = [(1, [node, [0]])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    result = max(result, ret1[0]+ret2[0])
                    ret[0] = 1+max(ret1[0], ret2[0])
            return result
        
        return iter_dfs(root)


",n
"class Solution2(object):
    def diameterOfBinaryTree(self, root):
        def dfs(root):
            if not root: 
                return 0, 0
            left_d, left_h = dfs(root.left)
            right_d, right_h = dfs(root.right)
            return max(left_d, right_d, left_h+right_h), 1+max(left_h, right_h)
 
        return dfs(root)[0]
",n
"
def read4(buf):
    global file_content
    i = 0
    while i < len(file_content) and i < 4:
        buf[i] = file_content[i]
        i += 1

    if len(file_content) > 4:
        file_content = file_content[4:]
    else:
        file_content = """"
    return i






class Solution(object):
    def __init__(self):
        self.__buf4 = [''] * 4
        self.__i4 = 0
        self.__n4 = 0

    def read(self, buf, n):
        i = 0
        while i < n:
            if self.__i4 < self.__n4: 
                buf[i] = self.__buf4[self.__i4]
                i += 1
                self.__i4 += 1
            else:
                self.__n4 = read4(self.__buf4) 
                if self.__n4:
                    self.__i4 = 0
                else: 
                    break

        return i

",n
"
class Solution(object):
    def addBinary(self, a, b):
        result, carry, val = """", 0, 0
        for i in range(max(len(a), len(b))):
            val = carry
            if i < len(a):
                val += int(a[-(i + 1)])
            if i < len(b):
                val += int(b[-(i + 1)])
            carry, val = divmod(val, 2)
            result += str(val)
        if carry:
            result += str(carry)
        return result[::-1]


",n
"from itertools import zip_longest


class Solution2(object):
    def addBinary(self, a, b):
        result = """"
        carry = 0
        for x, y in zip_longest(reversed(a), reversed(b), fillvalue=""0""):
            carry, remainder = divmod(int(x)+int(y)+carry, 2)
            result += str(remainder)
        
        if carry:
            result += str(carry)
        
        return result[::-1]
",n
"
class Solution(object):
    def sumFourDivisors(self, nums):
        result = 0
        for num in nums:
            facs, i = [], 1
            while i*i <= num:
                if num % i:
                    i+= 1
                    continue
                facs.append(i)
                if i != num//i:
                    facs.append(num//i)
                    if len(facs) > 4:
                        break
                i += 1
            if len(facs) == 4:            
                result += sum(facs)
        return result 


",n * sqrt(n)
"import itertools


class Solution2(object):
    def sumFourDivisors(self, nums):
        def factorize(x):
            result = []
            d = 2
            while d*d <= x:
                e = 0
                while x%d == 0:
                    x //= d
                    e += 1
                if e:
                    result.append([d, e])
                d += 1 if d == 2 else 2
            if x > 1:
                result.append([x, 1])
            return result
       
        result = 0
        for facs in map(factorize, nums):
            if len(facs) == 1 and facs[0][1] == 3:
                p = facs[0][0]
                result += (p**4-1)//(p-1) 
            elif len(facs) == 2 and facs[0][1] == facs[1][1] == 1:
                p, q = facs[0][0], facs[1][0]
                result += (1 + p) * (1 + q)
        return result
",n * sqrt(n)
"

class Solution(object):
    def maxPower(self, stations, r, k):
        def min_power():
            mn = float(""inf"")
            curr = sum(stations[i] for i in range(r))
            for i in range(len(stations)):
                if i+r < len(stations):
                    curr += stations[i+r]
                if i >= r+1:
                    curr -= stations[i-(r+1)]
                mn = min(mn, curr)
            return mn
    
        def check(target):
            arr = stations[:]
            curr = sum(arr[i] for i in range(r))
            cnt = k
            for i in range(len(arr)):
                if i+r < len(arr):
                    curr += arr[i+r]
                if i >= r+1:
                    curr -= arr[i-(r+1)]
                if curr >= target:
                    continue
                diff = target-curr
                if diff > cnt:
                    return False
                cnt -= diff
                curr += diff
                if i+r < len(arr):
                    arr[i+r] += diff
            return True

        mn = min_power() 
        left, right = mn, mn+k
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right
    
",nlogk
"
class Solution(object):
    def maxSumOfThreeSubarrays(self, nums, k):
        n = len(nums)
        accu = [0]
        for num in nums:
            accu.append(accu[-1]+num)

        left_pos = [0] * n
        total = accu[k]-accu[0]
        for i in range(k, n):
            if accu[i+1]-accu[i+1-k] > total:
                left_pos[i] = i+1-k
                total = accu[i+1]-accu[i+1-k]
            else:
                left_pos[i] = left_pos[i-1]

        right_pos = [n-k] * n
        total = accu[n]-accu[n-k]
        for i in reversed(range(n-k)):
            if accu[i+k]-accu[i] > total:
                right_pos[i] = i
                total = accu[i+k]-accu[i]
            else:
                right_pos[i] = right_pos[i+1]

        result, max_sum = [], 0
        for i in range(k, n-2*k+1):
            left, right = left_pos[i-1], right_pos[i+k]
            total = (accu[i+k]-accu[i]) + \
                    (accu[left+k]-accu[left]) + \
                    (accu[right+k]-accu[right])
            if total > max_sum:
                max_sum = total
                result = [left, i, right]
        return result

",n
"
class Solution(object):
    def maxProduct(self, s):
        def palindromic_subsequence_length(s, mask):
            result = 0
            left, right = 0, len(s)-1
            left_bit, right_bit = 1<<left, 1<<right
            while left <= right:
                if mask&left_bit == 0:
                    left, left_bit = left+1, left_bit<<1
                elif mask&right_bit == 0:
                    right, right_bit = right-1, right_bit>>1
                elif s[left] == s[right]:
                    result += 1 if left == right else 2
                    left, left_bit = left+1, left_bit<<1
                    right, right_bit = right-1, right_bit>>1
                else:
                    return 0
            return result
        
        dp = [palindromic_subsequence_length(s, mask) for mask in range(1<<len(s))]
        result = 0
        for mask in range(len(dp)):
            if dp[mask]*(len(s)-dp[mask]) <= result: 
                continue
            submask = inverse_mask = (len(dp)-1)^mask
            while submask:
                result = max(result, dp[mask]*dp[submask])
                submask = (submask-1)&inverse_mask
        return result
",3^n
"
class Solution(object):
    def isSelfCrossing(self, x):
        if len(x) >= 5 and x[3] == x[1] and x[4] + x[0] >= x[2]:
            return True

        for i in range(3, len(x)):
            if x[i] >= x[i - 2] and x[i - 3] >= x[i - 1]:
                return True
            elif i >= 5 and x[i - 4] <= x[i - 2] and x[i] + x[i - 4] >= x[i - 2] and \
                            x[i - 1] <= x[i - 3] and x[i - 5] + x[i - 1] >= x[i - 3]:
                return True
        return False

",n
"

class Solution(object):
    def maxSubarraySum(self, nums, k):
        dp = [float(""inf"")]*k
        dp[-1] = 0
        curr = 0
        result = float(""-inf"")
        for i, x in enumerate(nums):
            curr += x
            result = max(result, curr-dp[i%k])
            dp[i%k] = min(dp[i%k], curr)
        return result
",n
"
class Solution(object):
    def arrayRankTransform(self, arr):
        return list(map({x: i+1 for i, x in enumerate(sorted(set(arr)))}.get, arr))
",nlogn
"

class Solution(object):
    def minPushBox(self, grid):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def dot(a, b):
            return a[0]*b[0]+a[1]*b[1]

        def can_reach(grid, b, p, t):
            closer, detour = [p], []
            lookup = set([b])
            while closer or detour:
                if not closer:
                    closer, detour = detour, closer
                p = closer.pop()
                if p == t:
                    return True
                if p in lookup:
                    continue
                lookup.add(p)
                for dx, dy in directions:
                    np = (p[0]+dx, p[1]+dy)
                    if not (0 <= np[0] < len(grid) and 0 <= np[1] < len(grid[0]) and
                       grid[np[0]][np[1]] != 
                        continue
                    (closer if dot((dx, dy), (t[0]-p[0], t[1]-p[1])) > 0 else detour).append(np)
            return False

        def g(a, b):
            return abs(a[0]-b[0])+abs(a[1]-b[1])
        
        def a_star(grid, b, p, t):
            f, dh = g(b, t), 2
            closer, detour = [(b, p)], []
            lookup = set()
            while closer or detour:
                if not closer:
                    f += dh
                    closer, detour = detour, closer
                b, p = closer.pop()
                if b == t:
                    return f
                if (b, p) in lookup:
                    continue
                lookup.add((b, p))
                for dx, dy in directions:
                    nb, np = (b[0]+dx, b[1]+dy), (b[0]-dx, b[1]-dy)
                    if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and
                            0 <= np[0] < len(grid) and 0 <= np[1] < len(grid[0]) and
                            grid[nb[0]][nb[1]] != 
                            (nb, b) not in lookup and can_reach(grid, b, p, np)):
                        continue
                    (closer if dot((dx, dy), (t[0]-b[0], t[1]-b[1])) > 0 else detour).append((nb, b))
            return -1
        
        b, p, t = None, None, None
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 'B':
                    b = (i, j)
                elif grid[i][j] == 'S':
                    p = (i, j)
                elif grid[i][j] == 'T':
                    t = (i, j)
        return a_star(grid, b, p, t)
",m^2 * n^2
"

class Solution(object):
    def minimumArea(self, grid):
        min_r, max_r, min_c, max_c = len(grid), -1, len(grid[0]), -1
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 0:
                    continue
                min_r, max_r, min_c, max_c = min(min_r, i), max(max_r, i), min(min_c, j), max(max_c, j)
        return (max_r-min_r+1)*(max_c-min_c+1)
",n * m
"

class Solution(object):
    def findPermutationDifference(self, s, t):
        lookup = [-1]*26
        for i, x in enumerate(s):
            lookup[ord(x)-ord('a')] = i
        return sum(abs(lookup[ord(x)-ord('a')]-i)for i, x in enumerate(t))
",n + 26
"
import collections


class Solution(object):
    def longestStrChain(self, words):
        words.sort(key=len)
        dp = collections.defaultdict(int)
        for w in words:
            for i in range(len(w)):
                dp[w] = max(dp[w], dp[w[:i]+w[i+1:]]+1)
        return max(dp.values())
",n * l^2
"

class Solution(object):
    def minOperations(self, nums, x, y):
        def ceil_divide(a, b):
            return (a+b-1)//b

        def check(total):
            return sum(ceil_divide(max(v-min(ceil_divide(v, y), total)*y, 0), x-y) for v in nums) <= total
    
        left, right = 1, ceil_divide(max(nums), y)
        while left <= right:
            mid = left+(right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return left
",nlogr
"
import collections

        
class Solution(object):
    def minSetSize(self, arr):
        counting_sort = [0]*len(arr)
        count = collections.Counter(arr)
        for c in count.values():
            counting_sort[c-1] += 1
        result, total = 0, 0
        for c in reversed(range(len(arr))):
            if not counting_sort[c]:
                continue
            count = min(counting_sort[c],
                        ((len(arr)+1)//2 - total - 1)//(c+1) + 1)
            result += count
            total += count*(c+1)
            if total >= (len(arr)+1)//2:
                break
        return result
",n
"

class Solution(object):
    def allPathsSourceTarget(self, graph):
        def dfs(graph, curr, path, result):
            if curr == len(graph)-1:
                result.append(path[:])
                return
            for node in graph[curr]:
                path.append(node)
                dfs(graph, node, path, result)
                path.pop()

        result = []
        dfs(graph, 0, [0], result)
        return result

",p + r * n
"
class Solution(object):
    def maxTaxiEarnings(self, n, rides):
        rides.sort()
        dp = [0]*(n+1)
        j = 0
        for i in range(1, n+1):
            dp[i] = max(dp[i], dp[i-1])
            while j < len(rides) and rides[j][0] == i:
                dp[rides[j][1]] = max(dp[rides[j][1]], dp[i]+rides[j][1]-rides[j][0]+rides[j][2])
                j += 1
        return dp[-1]
",n + mlogm
"
class Solution(object):
    def longestPalindrome(self, word1, word2):
        s = word1+word2
        dp = [[0]*len(s) for _ in range(len(s))]
        result = 0
        for j in range(len(s)):
            dp[j][j] = 1
            for i in reversed(range(j)):
                if s[i] == s[j]:
                    dp[i][j] = 2 if i+1 == j else dp[i+1][j-1] + 2
                    if i < len(word1) <= j:
                        result = max(result, dp[i][j])
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        return result


",(m + n)^2
"class Solution2(object):
    def longestPalindrome(self, word1, word2):
        s = word1+word2
        dp = [[0]*len(s) for _ in range(len(s))]
        for j in range(len(s)):
            dp[j][j] = 1
            for i in reversed(range(j)):
                if s[i] == s[j]:
                    dp[i][j] = 2 if i+1 == j else dp[i+1][j-1] + 2
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        return max([dp[i][j] for i in range(len(word1)) for j in range(len(word1), len(s)) if s[i] == s[j]] or [0])
",(m + n)^2
"

class Solution(object):
    def doesAliceWin(self, s):
        return any(x in ""aeiou"" for x in s)
",n
"

class Solution(object):
    def findMaxK(self, nums):
        lookup = set(nums)
        return max([x for x in lookup if x > 0 and -x in lookup] or [-1])
",n
"

class Solution(object):
    def resultArray(self, nums, k, queries):
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                         update_fn=lambda x: x):
                self.tree = [None]*(1<<((N-1).bit_length()+1))
                self.base = len(self.tree)>>1
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x >>= 1
                    self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])

            def query(self, L, R):
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L >>= 1
                    R >>= 1
                return self.query_fn(left, right)
        
        def build(i):
            x = nums[i]%k
            cnt = [0]*(k+1)
            cnt[x] = 1
            cnt[-1] = x
            return cnt

        def update(x):
            x %= k
            cnt = [0]*(k+1)
            cnt[x] = 1
            cnt[-1] = x
            return cnt
            
        def query(x, y):
            if x is None:
                return y
            if y is None:
                return x
            cnt = x[:]
            for i in range(k):
                cnt[x[-1]*i%k] += y[i]
            cnt[-1] = x[-1]*y[-1]%k
            return cnt
        
        st = SegmentTree(len(nums), build_fn=build, update_fn=update, query_fn=query)
        result = [0]*len(queries)
        for idx, (i, v, s, x) in enumerate(queries):
            st.update(i, v)
            result[idx] = st.query(s, len(nums)-1)[x]
        return result
",n * k + q * k * logn
"
import heapq


class Solution(object):
    def isPossible(self, target):
        total = sum(target)
        max_heap = [-x for x in target]
        heapq.heapify(max_heap)
        while total != len(target):
            y = -heapq.heappop(max_heap)
            remain = total-y
            x = y-remain
            if x <= 0:
                return False
            if x > remain: 
                x = x%remain + remain
            heapq.heappush(max_heap, -x)
            total = x+remain
        return True
",log(max(t)) * logn
"

class Solution(object):
    def countCompleteDayPairs(self, hours):
        result = 0
        cnt = [0]*24
        for x in hours:
            result += cnt[-x%24]
            cnt[x%24] += 1
        return result
",n + 24
"
class Solution(object):

    def __init__(self, k):
        self.__start = 0
        self.__size = 0
        self.__buffer = [0] * k

    def insertFront(self, value):
        if self.isFull():
            return False
        self.__start = (self.__start-1) % len(self.__buffer)
        self.__buffer[self.__start] = value
        self.__size += 1
        return True

    def insertLast(self, value):
        if self.isFull():
            return False
        self.__buffer[(self.__start+self.__size) % len(self.__buffer)] = value
        self.__size += 1
        return True

    def deleteFront(self):
        if self.isEmpty():
            return False
        self.__start = (self.__start+1) % len(self.__buffer)
        self.__size -= 1
        return True

    def deleteLast(self):
        if self.isEmpty():
            return False
        self.__size -= 1
        return True

    def getFront(self):
        return -1 if self.isEmpty() else self.__buffer[self.__start]

    def getRear(self):
        return -1 if self.isEmpty() else self.__buffer[(self.__start+self.__size-1) % len(self.__buffer)]

    def isEmpty(self):
        return self.__size == 0

    def isFull(self):
        return self.__size == len(self.__buffer)



",1
"
class Solution(object):
    def maximumDifference(self, nums):
        result, prefix = 0, float(""inf"")
        for x in nums: 
            result = max(result, x-prefix)
            prefix = min(prefix, x)
        return result if result else -1
",n
"
class Solution(object):
    def kthSmallestPath(self, destination, k):
        def nCr(n, r): 
            if n < r:
                return 0
            if n-r < r:
                return nCr(n, n-r)
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c

        r, c = destination        
        result = []
        while r+c:
            count = nCr(r+(c-1), r) 
            if k <= count: 
                c -= 1
                result.append('H')
            else: 
                k -= count 
                r -= 1
                result.append('V')
        return """".join(result)
",(m + n)^2
"
import collections



class Solution(object):
    def frogPosition(self, n, edges, t, target):
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)

        stk = [(t, 1, 0, 1)]
        while stk:
            new_stk = []
            while stk:
                t, node, parent, choices = stk.pop()
                if not t or not (len(G[node])-(parent != 0)):
                    if node == target:
                        return 1.0/choices
                    continue
                for child in G[node]:
                    if child == parent:
                        continue
                    new_stk.append((t-1, child, node,
                                    choices*(len(G[node])-(parent != 0))))
            stk = new_stk
        return 0.0


",n
"
class Solution2(object):
    def frogPosition(self, n, edges, t, target):
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)

        stk = [(t, 1, 0, 1)]
        while stk:
            t, node, parent, choices = stk.pop()
            if not t or not (len(G[node])-(parent != 0)):
                if node == target:
                    return 1.0/choices
                continue
            for child in G[node]:
                if child == parent:
                    continue
                stk.append((t-1, child, node,
                            choices*(len(G[node])-(parent != 0))))
        return 0.0


",n
"
class Solution3(object):
    def frogPosition(self, n, edges, t, target):
        def dfs(G, target, t, node, parent):
            if not t or not (len(G[node])-(parent != 0)):
                return int(node == target)
            result = 0
            for child in G[node]:
                if child == parent:
                    continue
                result = dfs(G, target, t-1, child, node)
                if result:
                    break
            return result*(len(G[node])-(parent != 0))
        
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)
        choices = dfs(G, target, t, 1, 0)
        return 1.0/choices if choices else 0.0


",n
"
class Solution4(object):
    def frogPosition(self, n, edges, t, target):
        def dfs(G, target, t, node, parent):
            if not t or not (len(G[node])-(parent != 0)):
                return float(node == target)
            for child in G[node]:
                if child == parent:
                    continue
                result = dfs(G, target, t-1, child, node)
                if result:
                    break
            return result/(len(G[node])-(parent != 0))
        
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)
        return dfs(G, target, t, 1, 0)
",n
"
class Solution(object):
    def smallestRepunitDivByK(self, K):
        if K % 2 == 0 or K % 5 == 0:
            return -1

        result = 0
        for N in range(1, K+1):
            result = (result*10+1) % K
            if not result:
                return N
        assert(False)
        return -1 
",k
"
class Solution(object):
    def maximumElementAfterDecrementingAndRearranging(self, arr):
        arr.sort()
        result = 1
        for i in range(1, len(arr)):
            result = min(result+1, arr[i])
        return result
",nlogn
"
class Solution(object):

    def __init__(self, big, medium, small):
        self.__space = [0, big, medium, small]

    def addCar(self, carType):
        if self.__space[carType] > 0:
            self.__space[carType] -= 1
            return True
        return False
",1
"
class Solution(object):
    def maxSumDivThree(self, nums):
        dp = [0, 0, 0]
        for num in nums:
            for i in [num+x for x in dp]:
                dp[i%3] = max(dp[i%3], i)
        return dp[0]
",n
"

class Solution(object):
    def solveQueries(self, nums, queries):
        dist = [len(nums)]*len(nums)
        left = {}
        for i in range(2*len(nums)-1):
            x = nums[i%len(nums)]
            if x in left:
                dist[i%len(dist)] = min(dist[i%len(dist)], i-left[x])
            left[x] = i
        right = {}
        for i in reversed(range(2*len(nums)-1)):
            x = nums[i%len(nums)]
            if x in right:
                dist[i%len(dist)] = min(dist[i%len(dist)], right[x]-i)
            right[x] = i
        result = [-1]*len(queries)
        for i, x in enumerate(queries):
            if dist[x] < len(nums):
                result[i] = dist[x]
        return result
",n
"
class Solution(object):
    def minimumMoves(self, grid):
        level, q, lookup = 0, [(0, 0, False)], set()
        while q:
            next_q = []
            for r, c, is_vertical in q:
                if (r, c, is_vertical) in lookup:
                    continue
                if (r, c, is_vertical) == (len(grid)-1, len(grid)-2, False):
                    return level
                lookup.add((r, c, is_vertical))
                if not is_vertical:
                    if c+2 != len(grid[0]) and grid[r][c+2] == 0:
                        next_q.append((r, c+1, is_vertical))
                    if r+1 != len(grid) and grid[r+1][c] == 0 and grid[r+1][c+1] == 0:
                        next_q.append((r+1, c, is_vertical))
                        next_q.append((r, c, not is_vertical))
                else:
                    if r+2 != len(grid) and grid[r+2][c] == 0:
                        next_q.append((r+1, c, is_vertical))
                    if c+1 != len(grid) and grid[r][c+1] == 0 and grid[r+1][c+1] == 0:
                        next_q.append((r, c+1, is_vertical))
                        next_q.append((r, c, not is_vertical))
            q = next_q
            level += 1
        return -1
",n
"
class Solution(object):
    def countGoodTriplets(self, arr, a, b, c):
        return sum(abs(arr[i]-arr[j]) <= a and
                   abs(arr[j]-arr[k]) <= b and
                   abs(arr[k]-arr[i]) <= c 
                   for i in range(len(arr)-2)
                       for j in range(i+1, len(arr)-1)
                           for k in range(j+1, len(arr)))
  
",n^3
"

class Solution(object):
    def minLargest(self, nums1, nums2):
        if len(nums1) < len(nums2):
            nums1, nums2 = nums2, nums1
        dp = [float(""inf"")]*(len(nums2)+1)
        dp[0] = 0
        for i in range(len(nums1)+1):
            for j in range(len(nums2)+1):
                if not i and not j:
                    continue
                curr = float(""inf"")
                if i-1 >= 0:
                    curr = min(curr, dp[j]+(2 if dp[j]%2 == nums1[i-1]%2 else 1))
                if j-1 >= 0:
                    curr = min(curr, dp[j-1]+(2 if dp[j-1]%2 == nums2[j-1]%2 else 1))
                dp[j] = curr
        return dp[-1]
",m * n
"
class Solution(object):
    def averageHeightOfBuildings(self, buildings):
        points = []
        for x, y, h in buildings:
            points.append((x, 1, h))
            points.append((y, -1, h))
        points.sort()
        result = []
        total = cnt = 0
        prev = -1
        for curr, c, h in points:
            if cnt and curr != prev:
                if result and result[-1][1] == prev and result[-1][2] == total//cnt:
                    result[-1][1] = curr
                else:
                    result.append([prev, curr, total//cnt])
            total += h*c
            cnt += c
            prev = curr
        return result


",nlogn
"import collections


class Solution2(object):
    def averageHeightOfBuildings(self, buildings):
        count = collections.defaultdict(lambda: (0, 0))
        for x, y, h in buildings:
            count[x] = (count[x][0]+1, count[x][1]+h)
            count[y] = (count[y][0]-1, count[y][1]-h)
        result = []
        total = cnt = 0
        prev = -1
        for curr, (c, h) in sorted(count.items()):
            if cnt:
                if result and result[-1][1] == prev and result[-1][2] == total//cnt:
                    result[-1][1] = curr
                else:
                    result.append([prev, curr, total//cnt])
            total += h
            cnt += c
            prev = curr
        return result
",nlogn
"
import collections


class Solution(object):
    def predictPartyVictory(self, senate):
        n = len(senate)
        radiant, dire = collections.deque(), collections.deque()
        for i, c in enumerate(senate):
            if c == 'R':
                radiant.append(i)
            else:
                dire.append(i)
        while radiant and dire:
            r_idx, d_idx = radiant.popleft(), dire.popleft()
            if r_idx < d_idx:
                radiant.append(r_idx+n)
            else:
                dire.append(d_idx+n)
        return ""Radiant"" if len(radiant) > len(dire) else ""Dire""

",n
"

class Solution(object):
    def maximumPossibleSize(self, nums):
        result = prev = 0
        for x in nums:
            if prev <= x:
                prev = x
                result += 1
        return result
",n
"
class Solution(object):
    def wiggleMaxLength(self, nums):
        if len(nums) < 2:
            return len(nums)

        length, up = 1, None

        for i in range(1, len(nums)):
            if nums[i - 1] < nums[i] and (up is None or up is False):
                length += 1
                up = True
            elif nums[i - 1] > nums[i] and (up is None or up is True):
                length += 1
                up = False

        return length

",n
"
import heapq


class Solution(object):
    def assignTasks(self, servers, tasks):
        idle = [(servers[i], i) for i in range(len(servers))]
        working = []
        heapq.heapify(idle)
        result = []
        t = 0
        for i in range(len(tasks)):
            t = max(t, i) if idle else working[0][0]
            while working and working[0][0] <= t:
                _, w, idx = heapq.heappop(working)
                heapq.heappush(idle, (w, idx))
            w, idx = heapq.heappop(idle)
            heapq.heappush(working, (t+tasks[i], w, idx))
            result.append(idx)
        return result
",n + mlogn
"

class Solution(object):
    def checkValidCuts(self, n, rectangles):
        def check(idx):
            cnt = 0
            curr = rectangles[0][idx+2]
            for x in rectangles:
                cnt += int(curr <= x[idx])
                curr = max(curr, x[idx+2])
            return cnt >= 2
    
        for idx in range(2):
            rectangles.sort(key=lambda x: x[idx])
            if check(idx):
                return True
        return False
",nlogn
"
from sortedcontainers import SortedList



class Solution(object):
    def minOperations(self, nums, x, k):
        class SlidingWindow(object):
            def __init__(self):
                self.left = SortedList()
                self.right = SortedList()
                self.total1 = self.total2 = 0

            def add(self, val):
                if not self.left or val <= self.left[-1]:
                    self.left.add(val)
                    self.total1 += val
                else:
                    self.right.add(val)
                    self.total2 += val
                self.rebalance()

            def remove(self, val):
                if val <= self.left[-1]:
                    self.left.remove(val)
                    self.total1 -= val
                else:
                    self.right.remove(val)
                    self.total2 -= val
                self.rebalance()

            def rebalance(self):
                if len(self.left) < len(self.right):
                    self.total2 -= self.right[0]
                    self.total1 += self.right[0]
                    self.left.add(self.right[0])
                    self.right.pop(0)
                elif len(self.left) > len(self.right)+1:
                    self.total1 -= self.left[-1]
                    self.total2 += self.left[-1]
                    self.right.add(self.left[-1])
                    self.left.pop()

            def median(self):
                return self.left[-1]


        INF = float(""inf"")
        sw = SlidingWindow()
        cost = [INF]*(len(nums)+1)
        for i in range(len(nums)):
            if i-x >= 0:
                sw.remove(nums[i-x])
            sw.add(nums[i])
            if i >= x-1:
                cost[i+1] = (sw.median()*len(sw.left)-sw.total1) + (sw.total2-sw.median()*len(sw.right))
        dp = [0]*(len(nums)+1)
        for i in range(k):
            new_dp = [INF]*(len(nums)+1)
            for j in range((i+1)*x, len(nums)+1):
                new_dp[j] = min(new_dp[j-1], dp[j-x]+cost[j])
            dp = new_dp
        return dp[-1]


",nlogx + k * n
"import heapq
import collections



class Solution2(object):
    def minOperations(self, nums, x, k):
        class LazyHeap(object):
            def __init__(self, sign):
                self.heap = []
                self.to_remove = collections.defaultdict(int)
                self.cnt = 0
                self.sign = sign

            def push(self, val):
                heapq.heappush(self.heap, self.sign*val)

            def full_remove(self):
                result = []
                for x in self.heap:
                    if x not in self.to_remove:
                        result.append(x)
                        continue
                    self.to_remove[x] -= 1
                    if not self.to_remove[x]:
                        del self.to_remove[x]
                self.heap[:] = result
                heapq.heapify(self.heap)
    
            def remove(self, val):
                self.to_remove[self.sign*val] += 1
                self.cnt += 1
                if self.cnt > len(self.heap)-self.cnt:
                    self.full_remove()
                    self.cnt = 0

            def pop(self):
                self.remove(self.top())

            def top(self):
                while self.heap and self.heap[0] in self.to_remove:
                    self.to_remove[self.heap[0]] -= 1
                    self.cnt -= 1
                    if self.to_remove[self.heap[0]] == 0:
                        del self.to_remove[self.heap[0]]
                    heapq.heappop(self.heap)
                return self.sign*self.heap[0]

            def __len__(self):
                return len(self.heap)-self.cnt


        class SlidingWindow(object):
            def __init__(self):
                self.left = LazyHeap(-1)  
                self.right = LazyHeap(+1) 
                self.total1 = self.total2 = 0

            def add(self, val):
                if not self.left or val <= self.left.top():
                    self.left.push(val)
                    self.total1 += val
                else:
                    self.right.push(val)
                    self.total2 += val
                self.rebalance()

            def remove(self, val):
                if val <= self.left.top():
                    self.left.remove(val)
                    self.total1 -= val
                else:
                    self.right.remove(val)
                    self.total2 -= val
                self.rebalance()

            def rebalance(self):
                if len(self.left) < len(self.right):
                    self.total2 -= self.right.top()
                    self.total1 += self.right.top()
                    self.left.push(self.right.top())
                    self.right.pop()
                elif len(self.left) > len(self.right)+1:
                    self.total1 -= self.left.top()
                    self.total2 += self.left.top()
                    self.right.push(self.left.top())
                    self.left.pop()

            def median(self):
                return self.left.top()


        INF = float(""inf"")
        sw = SlidingWindow()
        cost = [INF]*(len(nums)+1)
        for i in range(len(nums)):
            if i-x >= 0:
                sw.remove(nums[i-x])
            sw.add(nums[i])
            if i >= x-1:
                cost[i+1] = (sw.median()*len(sw.left)-sw.total1) + (sw.total2-sw.median()*len(sw.right))
        dp = [0]*(len(nums)+1)
        for i in range(k):
            new_dp = [INF]*(len(nums)+1)
            for j in range((i+1)*x, len(nums)+1):
                new_dp[j] = min(new_dp[j-1], dp[j-x]+cost[j])
            dp = new_dp
        return dp[-1]
",nlogx + k * n
"

class Solution(object):
    def makeStringGood(self, s):
        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        result = len(s)
        for f in range(min(x for x in cnt if x), max(cnt)+1):
            dp1 = dp2 = 0
            for i in range(26):
                if not cnt[i]:
                    continue
                if cnt[i] >= f:
                    new_dp1 = len(s)
                    new_dp2 = min(dp1, dp2)+(cnt[i]-f)
                else:
                    free = (cnt[i-1]-f if cnt[i-1] >= f else cnt[i-1]) if i-1 >= 0 else 0
                    new_dp1 = min(min(dp1, dp2)+(f-cnt[i]), dp2+max((f-cnt[i])-free, 0))
                    new_dp2 = min(dp1, dp2)+cnt[i]
                dp1, dp2 = new_dp1, new_dp2
            result = min(result, dp1, dp2)
        return result
",26 * n
"

class Solution(object):
    def minimumString(self, a, b, c):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j != -1 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1
    
        def merge(a, b):
            if KMP(b, a) != -1:
                return b
            prefix = getPrefix(b+'
            l = prefix[-1]+1 
            return a+b[l:]

        result = [merge(a, merge(b, c)), merge(a, merge(c, b)),
                  merge(b, merge(a, c)), merge(b, merge(c, a)),
                  merge(c, merge(a, b)), merge(c, merge(b, a))]
        return min(result, key=lambda x: (len(x), x))


",l
"
class Solution2(object):
    def minimumString(self, a, b, c):
        def merge(a, b):
            if a in b:
                return b
            l = next((l for l in reversed(range(1, min(len(a), len(b)))) if a[-l:] == b[:l]), 0)
            return a+b[l:]

        result = [merge(a, merge(b, c)), merge(a, merge(c, b)),
                  merge(b, merge(a, c)), merge(b, merge(c, a)),
                  merge(c, merge(a, b)), merge(c, merge(b, a))]
        return min(result, key=lambda x: (len(x), x))
",l^2
"
class Solution(object):
    def canCompleteCircuit(self, gas, cost):
        start, total_sum, current_sum = 0, 0, 0
        for i in range(len(gas)):
            diff = gas[i] - cost[i]
            current_sum += diff
            total_sum += diff
            if current_sum < 0:
                start = i + 1
                current_sum = 0
        if total_sum >= 0:
            return start

        return -1

",n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def deepestLeavesSum(self, root):
        curr = [root]
        while curr:
            prev, curr = curr, [child for p in curr for child in [p.left, p.right] if child]
        return sum(node.val for node in prev)
",n
"
class GridMaster(object):
    def canMove(self, direction):
        pass

    def move(self, direction):
        pass

    def isTarget(self):
        pass


import collections
import heapq


class Solution(object):
    def findShortestPath(self, master):
        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}
        rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}

        def dfs(pos, target, master, lookup, adj):
            if target[0] is None and master.isTarget():
                target[0] = pos
            lookup.add(pos)
            for d, (di, dj) in directions.items():
                if not master.canMove(d):
                    continue
                nei = (pos[0]+di, pos[1]+dj)
                if nei in adj[pos]:
                    continue
                adj[pos][nei] = master.move(d)
                if nei not in lookup:
                    dfs(nei, target, master, lookup, adj)
                adj[nei][pos] = master.move(rollback[d])
                        
        def dijkstra(adj, start, target):
            dist = {start:0}
            min_heap = [(0, start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if dist[u] < curr:
                    continue
                for v, w in adj[u].items():
                    if v in dist and dist[v] <= curr+w:
                        continue
                    dist[v] = curr+w
                    heapq.heappush(min_heap, (curr+w, v))
            return dist[target] if target in dist else -1 
        
        start = (0, 0)
        target = [None]
        adj = collections.defaultdict(dict)
        dfs(start, target, master, set(), adj)
        if not target[0]:
            return -1
        return dijkstra(adj, start, target[0])
",m * n * log(m * n)
"
class Solution(object):
    def countElements(self, arr):
        lookup = set(arr)
        return sum(1 for x in arr if x+1 in lookup)


",n
"class Solution(object):
    def countElements(self, arr):
        arr.sort()
        result, l = 0, 1
        for i in range(len(arr)-1):
            if arr[i] == arr[i+1]:
                l += 1
                continue
            if arr[i]+1 == arr[i+1]:
                result += l
            l = 1
        return result
",nlogn
"
import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.size = [1]*n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        self.size[max(x_root, y_root)] += self.size[min(x_root, y_root)]
        return True


class Solution(object):
    def largestComponentSize(self, A):
        def prime_factors(i): 
            result = []
            d = 2
            if i%d == 0:
                while i%d == 0:
                    i //= d
                result.append(d)
            d = 3
            while d*d <= i:
                if i%d == 0:
                    while i%d == 0:
                        i //= d
                    result.append(d)
                d += 2
            if i != 1:
                result.append(i)
            return result
        
        union_find = UnionFind(len(A))
        nodesWithCommonFactor = collections.defaultdict(int)
        for i in range(len(A)):
            for factor in prime_factors(A[i]):
                if factor not in nodesWithCommonFactor:
                    nodesWithCommonFactor[factor] = i
                union_find.union_set(nodesWithCommonFactor[factor], i)
        return max(union_find.size)


",f * n
"import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.size = [1]*n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        self.size[max(x_root, y_root)] += self.size[min(x_root, y_root)]
        return True


class Solution2(object):
    def largestComponentSize(self, A):
        def prime_factors(x): 
            result = []
            p = 2
            while p*p <= x:
                if x%p == 0:
                    while x%p == 0:
                        x //= p
                    result.append(p)
                p += 1
            if x != 1:
                result.append(x)
            return result
        
        union_find = UnionFind(len(A))
        nodesWithCommonFactor = collections.defaultdict(int)
        for i in range(len(A)):
            for factor in prime_factors(A[i]):
                if factor not in nodesWithCommonFactor:
                    nodesWithCommonFactor[factor] = i
                union_find.union_set(nodesWithCommonFactor[factor], i)
        return max(union_find.size)
",f * n
"
class Solution(object):
    def tree2str(self, t):
        if not t: return """"
        s = str(t.val)
        if t.left or t.right:
            s += ""("" + self.tree2str(t.left) + "")""
        if t.right:
            s += ""("" + self.tree2str(t.right) + "")""
        return s

",n
"

class Solution(object):
    def maxNumOfMarkedIndices(self, nums):
        nums.sort()
        left = 0
        for right in range((len(nums)+1)//2, len(nums)):
            if nums[right] >= 2*nums[left]:
                left += 1
        return left*2


",nlogn
"
class Solution2(object):
    def maxNumOfMarkedIndices(self, nums):
        nums.sort()
        left = 0
        for right in range(len(nums)):
            if nums[right] >= 2*nums[left]:
                left += 1
        return min(left, len(nums)//2)*2
",nlogn
"

class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []


class Solution(object):
    def cloneTree(self, root):
        result = [None]
        stk = [(1, (root, result))]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, ret = params
                if not node:
                    continue
                ret[0] = Node(node.val)
                for child in reversed(node.children):
                    ret1 = [None]
                    stk.append((2, (ret1, ret)))
                    stk.append((1, (child, ret1)))
            else:
                ret1, ret = params
                ret[0].children.append(ret1[0])
        return result[0]


",n
"class Solution2(object):
    def cloneTree(self, root):
        def dfs(node):
            if not node:
                return None
            copy = Node(node.val)
            for child in node.children:
                copy.children.append(dfs(child))
            return copy
        
        return dfs(root)
",n
"
class Solution(object):
    def threeConsecutiveOdds(self, arr):
        count = 0
        for x in arr:
            count = count+1 if x%2 else 0
            if count == 3:
                return True
        return False
",n
"
class Solution(object):
    def longestConsecutive(self, root):
        self.max_len = 0

        def longestConsecutiveHelper(root):
            if not root:
                return 0

            left_len = longestConsecutiveHelper(root.left)
            right_len = longestConsecutiveHelper(root.right)

            cur_len = 1
            if root.left and root.left.val == root.val + 1:
                cur_len = max(cur_len, left_len + 1)
            if root.right and root.right.val == root.val + 1:
                cur_len = max(cur_len, right_len + 1)

            self.max_len = max(self.max_len, cur_len)

            return cur_len

        longestConsecutiveHelper(root)
        return self.max_len

",n
"
class Solution(object):
    def superEggDrop(self, K, N):
        def check(n, K, N):
            total, c = 0, 1
            for k in range(1, K+1):
                c *= n-k+1
                c //= k
                total += c
                if total >= N:
                    return True
            return False

        left, right = 1, N
        while left <= right:
            mid = left + (right-left)//2
            if check(mid, K, N):
                right = mid-1
            else:
                left = mid+1
        return left

",klogn
"
class Solution(object):
    def isValid(self, S):
        stack = []
        for i in S:
            if i == 'c':
                if stack[-2:] == ['a', 'b']:
                    stack.pop()
                    stack.pop()
                else:
                    return False
            else:
                stack.append(i)
        return not stack
",n
"
class Solution(object):
    def kthSmallestProduct(self, nums1, nums2, k):
        def check(nums1, nums2, k, neg_cnt, target):
            cnt = 0
            left, right = 0, len(nums2)-1
            direction = reversed if target >= 0 else lambda x: x
            for i in direction(range(neg_cnt)):
                while left < len(nums2) and nums1[i]*nums2[left] > target:
                    left += 1
                cnt += (len(nums2)-1)-left+1
            direction = (lambda x: x) if target >= 0 else reversed
            for i in direction(range(neg_cnt, len(nums1))): 
                if nums1[i] == 0: 
                    if target >= 0:
                        cnt += len(nums2)
                    continue
                while right >= 0 and nums1[i]*nums2[right] > target:
                    right -= 1
                cnt += right-0+1
            return cnt >= k

        neg_cnt = sum(x < 0 for x in nums1)
        left = min(nums1[i]*nums2[j] for i in (0, -1) for j in (0, -1))
        right = max(nums1[i]*nums2[j] for i in (0, -1) for j in (0, -1))
        while left <= right:
            mid = left + (right-left)//2
            if check(nums1, nums2, k, neg_cnt, mid):
                right = mid-1
            else:
                left = mid+1
        return left
",(m + n) * logr
"
class Solution(object):
    def minTaps(self, n, ranges):
        def jump_game(A):
            jump_count, reachable, curr_reachable = 0, 0, 0
            for i, length in enumerate(A):
                if i > reachable:
                    return -1
                if i > curr_reachable:
                    curr_reachable = reachable
                    jump_count += 1
                reachable = max(reachable, i+length)
            return jump_count
    
        max_range = [0]*(n+1)
        for i, r in enumerate(ranges):
            left, right = max(i-r, 0), min(i+r, n)
            max_range[left] = max(max_range[left], right-left)
        return jump_game(max_range)
",n
"

class Solution(object):
    def minimumTimeToInitialState(self, word, k):
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        def z_function(s): 
            z = [0]*len(s)
            l, r = 0, 0
            for i in range(1, len(z)):
                if i <= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 > r:
                    l, r = i, i+z[i]-1
            return z

        z = z_function(word)
        for i in range(k, len(word), k):
            if z[i] == len(word)-i:
                return i//k
        return ceil_divide(len(word), k)


",n
"
class Solution2(object):
    def minimumTimeToInitialState(self, word, k):
        def ceil_divide(a, b):
            return (a+b-1)//b

        for i in range(k, len(word), k):
            if all(word[i+j] == word[j] for j in range(len(word)-i)):
                return i//k
        return ceil_divide(len(word), k)
",n^2
"

class Solution(object):
    def countTexts(self, pressedKeys):
        MOD = 10**9+7
        dp = [1]*5
        for i in range(1, len(pressedKeys)+1):
            dp[i%5] = 0
            for j in reversed(range(max(i-(4 if pressedKeys[i-1] in ""79"" else 3), 0), i)):
                if pressedKeys[j] != pressedKeys[i-1]:
                    break
                dp[i%5] = (dp[i%5]+dp[j%5])%MOD
        return dp[len(pressedKeys)%5]
",n
"

class Solution(object):
    def findNonMinOrMax(self, nums):
        mx, mn = float(""-inf""), float(""inf"")
        result = -1
        for x in nums:
            if mn < x < mx:
                return x
            if x < mn:
                result = mn
                mn = x
            if x > mx:
                result = mx
                mx = x
        return result if mn < result < mx else -1


",n
"
class Solution2(object):
    def findNonMinOrMax(self, nums):
        mx, mn = max(nums), min(nums)
        return next((x for x in nums if x not in (mx, mn)), -1)
",n
"
import heapq



class Solution(object):
    def kSum(self, nums, k):
        total = sum(x for x in nums if x > 0)
        sorted_vals = sorted(abs(x) for x in nums)
        max_heap = [(-total, 0)]
        for _ in range(k):
            result, i = heapq.heappop(max_heap)
            result = -result
            if i == len(sorted_vals):
                continue
            heapq.heappush(max_heap, (-(result-sorted_vals[i]), i+1))
            if i-1 >= 0:
                heapq.heappush(max_heap, (-(result+sorted_vals[i-1]-sorted_vals[i]), i+1))
        return result
",nlogn + klogk
"
class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def earliestAcq(self, logs, N):
        logs.sort()
        union_find = UnionFind(N)
        for t, a, b in logs:
            union_find.union_set(a, b)
            if union_find.count == 1:
                return t
        return -1
",nlogn
"
import bisect



class Solution(object):
    def maxSubstringLength(self, s):
        def check(left, right):
            for x in idxs:
                if not x or x[-1] < left or x[0] > right or (left <= x[0] and x[-1] <= right):
                    continue
                i = bisect.bisect_left(x, left)
                if i != len(x) and x[i] <= right:
                    return False
            return True

        idxs = [[] for _ in range(26)]
        for i, x in enumerate(s):
            idxs[ord(x)-ord('a')].append(i)
        result = -1
        for x in idxs:
            if not x:
                continue
            left = x[0]
            for y in idxs:
                if not y:
                    continue
                right = y[-1]
                if left <= right and result < right-left+1 != len(s) and check(left, right):
                    result = right-left+1
        return result


",n + 26^3 * logn
"import bisect



class Solution2(object):
    def maxSubstringLength(self, s):
        def check(left, right):
            for x in idxs:
                if not x:
                    continue
                l = bisect.bisect_left(x, left)
                r = bisect.bisect_right(x, right)-1
                if not (r-l+1 == len(x) or r-l+1 == 0):
                    return False
            return True

        idxs = [[] for _ in range(26)]
        for i, x in enumerate(s):
            idxs[ord(x)-ord('a')].append(i)
        result = -1
        for x in idxs:
            if not x:
                continue
            left = x[0]
            for y in idxs:
                if not y:
                    continue
                right = y[-1]
                if left <= right and right-left+1 != len(s) and check(left, right):
                    result = max(result, right-left+1)
        return result


",n + 26^3 * logn
"
class Solution3(object):
    def maxSubstringLength(self, s):
        def update(x, d, distinct, valid):
            x = ord(x)-ord('a')
            if cnt2[x] == cnt[x]:
                valid -= 1
            if cnt2[x] == 0:
                distinct += 1
            cnt2[x] += d
            if cnt2[x] == 0:
                distinct -= 1
            if cnt2[x] == cnt[x]:
                valid += 1
            return distinct, valid
                
        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        result = -1
        for l in range(1, sum(x != 0 for x in cnt)):
            cnt2 = [0]*26
            left = distinct = valid = 0
            for right in range(len(s)):
                distinct, valid = update(s[right], +1, distinct, valid)
                while distinct == l+1:
                    distinct, valid = update(s[left], -1, distinct, valid)
                    left += 1
                if valid == l:
                    result = max(result, right-left+1)
        return result


",26 * n
"
class Solution5(object):
    def maxSubstringLength(self, s):
        def check(l, r):
            return all(l <= left[ord(s[i])-ord('a')] and right[ord(s[i])-ord('a')] <= r for i in range(l, r+1))

        left, right = [-1]*26, [-1]*26
        for i, x in enumerate(s):
            x = ord(x)-ord('a')
            if left[x] == -1:
                left[x] = i
            right[x] = i
        result = -1
        for l in left:
            if l == -1:
                continue
            for r in right:
                if r == -1:
                    continue
                if l <= r and result < r-l+1 != len(s) and check(l, r):
                    result = r-l+1
        return result
",26^2 * n
"
import heapq


class Solution(object):
    def minBuildTime(self, blocks, split):
        heapq.heapify(blocks)
        while len(blocks) != 1:
            x, y = heapq.heappop(blocks), heapq.heappop(blocks)
            heapq.heappush(blocks, y+split)
        return heapq.heappop(blocks)
",nlogn
"

class Solution(object):
    def maxSum(self, nums, k):
        MOD = 10**9+7
        l = max(nums).bit_length()
        cnt = [0]*l
        for i in range(l):
            for x in nums:
                if x&(1<<i):
                    cnt[i] += 1
        return reduce(lambda x, y: (x+y)%MOD, (sum(1<<i for i in range(l) if cnt[i] >= j)**2 for j in range(1, k+1)))
",nlogr
"
import collections


class Solution(object):
    def findSubstring(self, s, words):
        if not words:
            return []

        result, m, n, k = [], len(s), len(words), len(words[0])
        if m < n*k:
            return result

        lookup = collections.defaultdict(int)
        for i in words:
            lookup[i] += 1               

        for i in range(k):              
            left, count = i, 0
            tmp = collections.defaultdict(int)
            for j in range(i, m-k+1, k):
                s1 = s[j:j+k]            
                if s1 in lookup:
                    tmp[s1] += 1
                    count += 1
                    while tmp[s1] > lookup[s1]:
                        tmp[s[left:left+k]] -= 1
                        count -= 1
                        left += k
                    if count == n:
                        result.append(left)
                else:
                    tmp = collections.defaultdict(int)
                    count = 0
                    left = j+k
        return result


",(m + n) * k
"class Solution2(object):
    def findSubstring(self, s, words):
        result, m, n, k = [], len(s), len(words), len(words[0])
        if m < n*k:
            return result

        lookup = collections.defaultdict(int)
        for i in words:
            lookup[i] += 1                           

        for i in range(m+1-k*n):                    
            cur, j = collections.defaultdict(int), 0
            while j < n:                             
                word = s[i+j*k:i+j*k+k]              
                if word not in lookup:
                    break
                cur[word] += 1
                if cur[word] > lookup[word]:
                    break
                j += 1
            if j == n:
                result.append(i)

        return result


",m * n * k
"
class Solution(object):
    def thousandSeparator(self, n):
        result = []
        s = str(n)
        for i, c in enumerate(str(n)):
            if i and (len(s)-i)%3 == 0:
                result.append(""."")
            result.append(c)
        return """".join(result)
",n
"
import itertools


class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):
    def areSentencesSimilarTwo(self, words1, words2, pairs):
        if len(words1) != len(words2): return False

        lookup = {}
        union_find = UnionFind(2 * len(pairs))
        for pair in pairs:
            for p in pair:
                if p not in lookup:
                    lookup[p] = len(lookup)
            union_find.union_set(lookup[pair[0]], lookup[pair[1]])

        return all(w1 == w2 or
                   w1 in lookup and w2 in lookup and
                   union_find.find_set(lookup[w1]) == union_find.find_set(lookup[w2])
                   for w1, w2 in zip(words1, words2))

",n + p
"
class Solution(object):
    def isSubsequence(self, s, t):
        if not s:
            return True

        i = 0
        for c in t:
            if c == s[i]:
                i += 1
            if i == len(s):
                break
        return i == len(s)

",n
"
import collections
import itertools



class Solution(object):
    def countSubranges(self, nums1, nums2):
        MOD = 10**9+7

        result = 0
        dp = collections.Counter()
        for x, y in zip(nums1, nums2):
            new_dp = collections.Counter()
            new_dp[x] += 1
            new_dp[-y] += 1
            for v, c in dp.items():
                new_dp[v+x] = (new_dp[v+x]+c)%MOD
                new_dp[v-y] = (new_dp[v-y]+c)%MOD
            dp = new_dp
            result = (result+dp[0])%MOD
        return result
",n^2 * v
"
class Solution(object):
    def maximumUnits(self, boxTypes, truckSize):
        boxTypes.sort(key=lambda x: x[1], reverse=True)
        result = 0
        for box, units in boxTypes:
            if truckSize > box:
                truckSize -= box
                result += box*units
            else:
                result += truckSize*units
                break
        return result
",nlogn
"

class Solution(object):
    def minScore(self, grid):
        idxs = [(i, j) for i in range(len(grid)) for j in range(len(grid[0]))]
        idxs.sort(key=lambda x: grid[x[0]][x[1]])
        row_max, col_max = [0]*len(grid), [0]*len(grid[0])
        for i, j in idxs:
            grid[i][j] = row_max[i] = col_max[j] = max(row_max[i], col_max[j])+1
        return grid
",(m * n) * log(m * n)
"

class Solution(object):
    def minimumMoves(self, nums, k, maxChanges):
        idxs = [i for i, x in enumerate(nums) if x]
        prefix = [0]*(len(idxs)+1)
        for i in range(len(idxs)):
            prefix[i+1] = prefix[i]+idxs[i]
        result = float(""inf"")
        cnt = max(k-maxChanges, 0)
        for l in range(cnt, min(cnt+3, k, len(idxs))+1):
            cnt1 = (k-l)*2
            for i in range(len(idxs)-l+1):
                cnt2 = (prefix[(i+l-1)+1]-prefix[(i+l-1)-(l//2-1)])-(prefix[(i+(l//2-1))+1]-prefix[i])
                result = min(result, cnt2+cnt1)
        return result
",n
"
import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    return students[students[""student_id""] == 101][[""name"", ""age""]]
",n
"
class Solution(object):
    def getConcatenation(self, nums):
        nums.extend(nums)
        return nums


",n
"class Solution2(object):
    def getConcatenation(self, nums):
        return nums+nums


",n
"class Solution3(object):
    def getConcatenation(self, nums):
        return nums*2
",n
"
import collections



class Solution(object):
    def countPairs(self, nums, low, high):
        def count(nums, x):
            result = 0
            dp = collections.Counter(nums)
            while x:
                if x&1:
                    result += sum(dp[(x^1)^k]*dp[k] for k in dp.keys())//2 
                dp = collections.Counter({k>>1: dp[k]+dp[k^1] for k in dp.keys()})
                x >>= 1
            return result
    
        return count(nums, high+1)-count(nums, low)


",n
"
class Trie(object):
    def __init__(self):
        self.__root = {}
        
    def insert(self, num):
        node = self.__root
        for i in reversed(range(32)):
            curr = (num>>i) & 1
            if curr not in node:
                node[curr] = {""_count"":0}
            node = node[curr]
            node[""_count""] += 1
                
    def query(self, num, limit):
        node, result = self.__root, 0
        for i in reversed(range(32)):
            curr = (num>>i) & 1
            bit = (limit>>i) & 1
            if bit:
                if curr in node:
                    result += node[0^curr][""_count""] 
            if bit^curr not in node:
                break
            node = node[bit^curr]
        return result


class Solution2(object):
    def countPairs(self, nums, low, high):
        result = 0
        trie = Trie()
        for x in nums:
            result += trie.query(x, high+1)-trie.query(x, low)
            trie.insert(x)
        return result
",n
"
class Solution(object):
    def numberOfUniqueGoodSubsequences(self, binary):
        MOD = 10**9+7
        ends0, ends1 = 0, 0
        has_zero = False
        for b in binary:
            if b == '1':
                ends1 = (ends0+ends1+1)%MOD 
            else:
                ends0 = (ends0+ends1)%MOD 
                has_zero = True
        return (ends0+ends1+int(has_zero))%MOD 
",n
"

class Solution(object):
    def smallestEvenMultiple(self, n):
        return n<<(n&1)
",1
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def reverseKGroup(self, head, k):
        dummy = ListNode(-1)
        dummy.next = head

        cur, cur_dummy = head, dummy
        length = 0

        while cur:
            next_cur = cur.__next__
            length = (length + 1) % k

            if length == 0:
                next_dummy = cur_dummy.__next__
                self.reverse(cur_dummy, cur.__next__)
                cur_dummy = next_dummy

            cur = next_cur

        return dummy.__next__

    def reverse(self, begin, end):
            first = begin.__next__
            cur = first.__next__

            while cur != end:
                first.next = cur.__next__
                cur.next = begin.__next__
                begin.next = cur
                cur = first.__next__

",n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sufficientSubset(self, root, limit):
        if not root:
            return None
        if not root.left and not root.right:
            return None if root.val < limit else root
        root.left = self.sufficientSubset(root.left, limit-root.val)
        root.right = self.sufficientSubset(root.right, limit-root.val)
        if not root.left and not root.right:
            return None
        return root
",n
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def insertIntoMaxTree(self, root, val):
        if not root:
            return TreeNode(val)

        if val > root.val:
            node = TreeNode(val)
            node.left = root
            return node
        
        curr = root
        while curr.right and curr.right.val > val:
            curr = curr.right
        node = TreeNode(val)
        curr.right, node.left = node, curr.right
        return root
",h
"
class Solution(object):
    def maximumBeauty(self, flowers):
        lookup = {}
        prefix = [0]
        result = float(""-inf"")
        for i, f in enumerate(flowers):
            prefix.append(prefix[-1]+f if f > 0 else prefix[-1])
            if not f in lookup:
                lookup[f] = i
                continue
            result = max(result, 2*f+prefix[i+1]-prefix[lookup[f]] if f < 0 else prefix[i+1]-prefix[lookup[f]])
        return result
",n
"
class Solution(object):
    def numberOfWays(self, num_people):
        MOD = 10**9+7
        def inv(x, m): 
            return pow(x, m-2, m) 

        def nCr(n, k, m):
            if n-k < k:
                return nCr(n, n-k, m)
            result = 1
            for i in range(1, k+1):
                result = result*(n-k+i)*inv(i, m)%m
            return result

        n = num_people//2
        return nCr(2*n, n, MOD)*inv(n+1, MOD) % MOD 


",n
"class Solution2(object):
    def numberOfWays(self, num_people):
        MOD = 10**9+7
        dp = [0]*(num_people//2+1)
        dp[0] = 1
        for k in range(1, num_people//2+1):
            for i in range(k):
                dp[k] = (dp[k] + dp[i]*dp[k-1-i]) % MOD
        return dp[num_people//2]
",n^2
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def postorderTraversal(self, root):
        dummy = TreeNode(0)
        dummy.left = root
        result, cur = [], dummy
        while cur:
            if cur.left is None:
                cur = cur.right
            else:
                node = cur.left
                while node.right and node.right != cur:
                    node = node.right

                if node.right is None:
                    node.right = cur
                    cur = cur.left
                else:
                    result += self.traceBack(cur.left, node)
                    node.right = None
                    cur = cur.right

        return result

    def traceBack(self, frm, to):
        result, cur = [], frm
        while cur is not to:
            result.append(cur.val)
            cur = cur.right
        result.append(to.val)
        result.reverse()
        return result


",n
"
class Solution2(object):
    def postorderTraversal(self, root):
        result, stack = [], [(root, False)]
        while stack:
            root, is_visited = stack.pop()
            if root is None:
                continue
            if is_visited:
                result.append(root.val)
            else:
                stack.append((root, True))
                stack.append((root.right, False))
                stack.append((root.left, False))
        return result

",n
"
class Solution(object):
    def countPalindromicSubsequence(self, s):
        first, last = [len(s)]*26, [-1]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        return sum(len(set(s[i] for i in range(first[c]+1, last[c]))) for c in range(26))
",n
"
import collections
from functools import reduce



class Solution(object):
    def getSum(self, nums):
        def count(d):
            result = 0
            cnt = collections.defaultdict(int)
            prefix = collections.defaultdict(int)
            for x in nums:
                c = (cnt[x-d]+1)%MOD
                cnt[x] = (cnt[x]+c)%MOD
                total = (prefix[x-d]+x*c)%MOD
                prefix[x] = (prefix[x]+total)%MOD
                result = (result+total)%MOD
            return result
    
        MOD = 10**9+7
        return (count(+1)+count(-1)-reduce(lambda accu, x: (accu+x)%MOD, nums, 0))%MOD
",n
"
from collections import deque

class Solution(object):
    def wallsAndGates(self, rooms):
        INF = 2147483647
        q = deque([(i, j) for i, row in enumerate(rooms) for j, r in enumerate(row) if not r])
        while q:
            (i, j) = q.popleft()
            for I, J in (i+1, j), (i-1, j), (i, j+1), (i, j-1):
                if 0 <= I < len(rooms) and 0 <= J < len(rooms[0]) and \
                   rooms[I][J] == INF:
                    rooms[I][J] = rooms[i][j] + 1
                    q.append((I, J))


",m * n
"
import collections



class Solution(object):

    def __init__(self, capacity):
        self.__capa = capacity
        self.__size = 0
        self.__min_freq = float(""inf"")
        self.__freq_to_nodes = collections.defaultdict(collections.OrderedDict)
        self.__key_to_freq = {}

    def get(self, key):
        if key not in self.__key_to_freq:
            return -1
        value = self.__freq_to_nodes[self.__key_to_freq[key]][key]
        self.__update(key, value)
        return value

    def put(self, key, value):
        if self.__capa <= 0:
            return

        if key not in self.__key_to_freq and self.__size == self.__capa:
            del self.__key_to_freq[self.__freq_to_nodes[self.__min_freq].popitem(last=False)[0]]
            if not self.__freq_to_nodes[self.__min_freq]:
                del self.__freq_to_nodes[self.__min_freq]
            self.__size -= 1
        self.__update(key, value)
        
    def __update(self, key, value):
        freq = 0
        if key in self.__key_to_freq:
            freq = self.__key_to_freq[key]
            del self.__freq_to_nodes[freq][key]
            if not self.__freq_to_nodes[freq]:
                del self.__freq_to_nodes[freq]
                if self.__min_freq == freq:
                    self.__min_freq += 1
            self.__size -= 1

        freq += 1
        self.__min_freq = min(self.__min_freq, freq)
        self.__key_to_freq[key] = freq
        self.__freq_to_nodes[freq][key] = value
        self.__size += 1


",1
"import collections


class ListNode(object):
    def __init__(self, key, value, freq):
        self.key = key
        self.val = value
        self.freq = freq
        self.next = None
        self.prev = None


class LinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, node):
        node.next, node.prev = None, None 
        if self.head is None:
            self.head = node
        else:
            self.tail.next = node
            node.prev = self.tail
        self.tail = node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.__next__
        else:
            self.head = node.__next__
        if node.__next__:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        node.next, node.prev = None, None 


class Solution2(object):

    def __init__(self, capacity):
        self.__capa = capacity
        self.__size = 0
        self.__min_freq = float(""inf"")
        self.__freq_to_nodes = collections.defaultdict(LinkedList)
        self.__key_to_node = {}

    def get(self, key):
        if key not in self.__key_to_node:
            return -1
        value = self.__key_to_node[key].val
        self.__update(key, value)
        return value

    def put(self, key, value):
        if self.__capa <= 0:
            return

        if key not in self.__key_to_node and self.__size == self.__capa:
            del self.__key_to_node[self.__freq_to_nodes[self.__min_freq].head.key]
            self.__freq_to_nodes[self.__min_freq].delete(self.__freq_to_nodes[self.__min_freq].head)
            if not self.__freq_to_nodes[self.__min_freq].head:
                del self.__freq_to_nodes[self.__min_freq]
            self.__size -= 1
        self.__update(key, value)
        
    def __update(self, key, value):
        freq = 0
        if key in self.__key_to_node:
            old_node = self.__key_to_node[key]
            freq = old_node.freq
            self.__freq_to_nodes[freq].delete(old_node)
            if not self.__freq_to_nodes[freq].head:
                del self.__freq_to_nodes[freq]
                if self.__min_freq == freq:
                    self.__min_freq += 1
            self.__size -= 1

        freq += 1
        self.__min_freq = min(self.__min_freq, freq)
        self.__key_to_node[key] = ListNode(key, value, freq)
        self.__freq_to_nodes[freq].append(self.__key_to_node[key])
        self.__size += 1
",1
"
import collections


class Solution(object):
    def numEquivDominoPairs(self, dominoes):
        counter = collections.Counter((min(x), max(x)) for x in dominoes)
        return sum(v*(v-1)//2 for v in counter.values())
",n
"
class Solution(object):
    def shiftingLetters(self, S, shifts):
        result = []
        times = sum(shifts) % 26
        for i, c in enumerate(S):
            index = ord(c) - ord('a')
            result.append(chr(ord('a') + (index+times) % 26))
            times = (times-shifts[i]) % 26
        return """".join(result)

",n
"
class Solution(object):
    def countAndSay(self, n):
        seq = ""1""
        for i in range(n - 1):
            seq = self.getNext(seq)
        return seq

    def getNext(self, seq):
        i, next_seq = 0, """"
        while i < len(seq):
            cnt = 1
            while i < len(seq) - 1 and seq[i] == seq[i + 1]:
                cnt += 1
                i += 1
            next_seq += str(cnt) + seq[i]
            i += 1
        return next_seq

",n * 2^n
"

class Solution(object):
    def numberOfSubmatrices(self, grid):
        result = 0
        dp1 = [[0]*(len(grid[0])+1) for _ in range(len(grid)+1)]
        dp2 = [[0]*(len(grid[0])+1) for _ in range(len(grid)+1)]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                dp1[i+1][j+1] = dp1[i][j+1]+dp1[i+1][j]-dp1[i][j]+int(grid[i][j] == 'X')
                dp2[i+1][j+1] = dp2[i][j+1]+dp2[i+1][j]-dp2[i][j]+int(grid[i][j] == 'Y')
                result += int(dp1[i+1][j+1] == dp2[i+1][j+1] != 0)
        return result


",n * m
"
class Solution2(object):
    def numberOfSubmatrices(self, grid):
        result = 0
        dp1 = [[0]*len(grid[0]) for _ in range(len(grid))]
        dp2 = [[0]*len(grid[0]) for _ in range(len(grid))]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i-1 >= 0:
                    dp1[i][j] += dp1[i-1][j]
                    dp2[i][j] += dp2[i-1][j]
                if j-1 >= 0:
                    dp1[i][j] += dp1[i][j-1]
                    dp2[i][j] += dp2[i][j-1]
                if i-1 >= 0 and j-1 >= 0:
                    dp1[i][j] -= dp1[i-1][j-1]
                    dp2[i][j] -= dp2[i-1][j-1]
                dp1[i][j] += int(grid[i][j] == 'X')
                dp2[i][j] += int(grid[i][j] == 'Y')
                result += int(dp1[i][j] == dp2[i][j] != 0)
        return result
",n * m
"
class Solution(object):
    def surfaceArea(self, grid):
        result = 0
        for i in range(len(grid)):
            for j in range(len(grid)):
                if grid[i][j]:
                    result += 2 + grid[i][j]*4
                if i:
                    result -= min(grid[i][j], grid[i-1][j])*2
                if j:
                    result -= min(grid[i][j], grid[i][j-1])*2
        return result

",n^2
"
import heapq



class Solution(object):
    def minOperations(self, nums, k):
        result = 0
        heapq.heapify(nums)
        while nums:
            if nums[0] >= k:
                break
            mn1 = heapq.heappop(nums)
            mn2 = heapq.heappop(nums)
            heapq.heappush(nums, 2*mn1+mn2)
            result += 1
        return result
",nlogn
"
import collections


class Solution(object):
    def closeStrings(self, word1, word2):
        if len(word1) != len(word2):
            return False 
        
        cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2)  
        return set(cnt1.keys()) == set(cnt2.keys()) and \
               collections.Counter(iter(cnt1.values())) == collections.Counter(iter(cnt2.values()))
",n
"
class Solution(object):
    def minimumTime(self, n, relations, time):
        adj = [[] for _ in range(n)]
        in_degree = [0]*n
        for prev, nxt in relations:
            adj[prev-1].append(nxt-1)
            in_degree[nxt-1] += 1
        q = [u for u in range(n) if not in_degree[u]]
        dist = [time[u] if not in_degree[u] else 0 for u in range(n)] 
        while q:
            new_q = []
            for u in q:
                for v in adj[u]:
                    dist[v] = max(dist[v], dist[u]+time[v])
                    in_degree[v] -= 1
                    if not in_degree[v]:
                        new_q.append(v)
            q = new_q
        return max(dist)
",|V| + |E|
"
import collections


class Solution(object):
    def getProbability(self, balls):
        def nCrs(n): 
            c = 1
            for k in range(n+1):
                yield c
                c *= n-(k+1)+1
                c //= k+1
        
        def nCr(n, r): 
            if n-r < r:
                return nCr(n, n-r)
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
        
        dp = collections.defaultdict(int)
        dp[0, 0] = 1 
        for n in balls: 
            new_dp = collections.defaultdict(int)
            for (ndiff, cdiff), count in dp.items(): 
                for k, new_count in enumerate(nCrs(n)): 
                    new_ndiff = ndiff+(k-(n-k))
                    new_cdiff = cdiff-1 if k == 0 else (cdiff+1 if k == n else cdiff)
                    new_dp[new_ndiff, new_cdiff] += count*new_count
            dp = new_dp
        total = sum(balls)
        return float(dp[0, 0])/nCr(total, total//2)
",k^3 * n^2
"
class Solution(object):
    def findDiagonalOrder(self, matrix):
        if not matrix or not matrix[0]:
            return []

        result = []
        row, col, d = 0, 0, 0
        dirs = [(-1, 1), (1, -1)]

        for i in range(len(matrix) * len(matrix[0])):
            result.append(matrix[row][col])
            row += dirs[d][0]
            col += dirs[d][1]

            if row >= len(matrix):
                row = len(matrix) - 1
                col += 2
                d = 1 - d
            elif col >= len(matrix[0]):
                col = len(matrix[0]) - 1
                row += 2
                d = 1 - d
            elif row < 0:
                row = 0
                d = 1 - d
            elif col < 0:
                col = 0
                d = 1 - d

        return result


",m * n
"
class Solution(object):
    def solveSudoku(self, board):
        def isValid(board, x, y):
            for i in range(9):
                if i != x and board[i][y] == board[x][y]:
                    return False
            for j in range(9):
                if j != y and board[x][j] == board[x][y]:
                    return False
            i = 3 * (x / 3)
            while i < 3 * (x / 3 + 1):
                j = 3 * (y / 3)
                while j < 3 * (y / 3 + 1):
                    if (i != x or j != y) and board[i][j] == board[x][y]:
                        return False
                    j += 1
                i += 1
            return True

        def solver(board):
            for i in range(len(board)):
                for j in range(len(board[0])):
                    if(board[i][j] == '.'):
                        for k in range(9):
                            board[i][j] = chr(ord('1') + k)
                            if isValid(board, i, j) and solver(board):
                                return True
                            board[i][j] = '.'
                        return False
            return True

        solver(board)

",(9!)^9
"
class Solution(object):
    def insert(self, intervals, newInterval):
        result = []
        i = 0
        while i < len(intervals) and newInterval[0] > intervals[i][1]:
            result += intervals[i],
            i += 1
        while i < len(intervals) and newInterval[1] >= intervals[i][0]:
            newInterval = [min(newInterval[0], intervals[i][0]),
                           max(newInterval[1], intervals[i][1])]
            i += 1
        result.append(newInterval)
        result.extend(intervals[i:])
        return result
",n
"
class Solution(object):
    def checkPossibility(self, nums):
        modified, prev = False, nums[0]
        for i in range(1, len(nums)):
            if prev > nums[i]:
                if modified:
                    return False
                if i-2 < 0 or nums[i-2] <= nums[i]:
                    prev = nums[i]   


                modified = True
            else:
                prev = nums[i]
        return True


",n
"

class Solution(object):
    def repeatedCharacter(self, s):
        lookup = set()
        for c in s:
            if c in lookup:
                break
            lookup.add(c)
        return c
",n
"

class Solution(object):
    def findNumber(self):
        return reduce(lambda accu, x: accu|x, (1<<i for i in range(30) if commonSetBits(1<<i)))
",logn
"
class Node(object):
    def __init__(self, val, next):
        self.val = val
        self.next = next


class Solution(object):
    def insert(self, head, insertVal):
        def insertAfter(node, val):
            node.next = Node(val, node.next)
        
        if not head:
            node = Node(insertVal, None)
            node.next = node
            return node

        curr = head
        while True:
            if curr.val < curr.next.val:
                if curr.val <= insertVal and \
                   insertVal <= curr.next.val:
                    insertAfter(curr, insertVal)
                    break
            elif curr.val > curr.next.val:
                if curr.val <= insertVal or \
                   insertVal <= curr.next.val:
                    insertAfter(curr, insertVal)
                    break
            else:
                if curr.__next__ == head:
                    insertAfter(curr, insertVal)
                    break
            curr = curr.__next__
        return head

",n
"

class Solution(object):
    def minArrayLength(self, nums, k):
        if 0 in nums:
            return 1
        result = len(nums)
        curr = nums[0]
        for i in range(1, len(nums)):
            if curr*nums[i] > k:
                curr = nums[i]
            else:
                curr *= nums[i]
                result -= 1
        return result
 
",n
"
import itertools


class Solution(object):
    def distanceBetweenBusStops(self, distance, start, destination):
        if start > destination:
            start, destination = destination, start
        s_to_d = sum(itertools.islice(distance, start, destination))
        d_to_s = sum(itertools.islice(distance, 0, start)) + \
                 sum(itertools.islice(distance, destination, len(distance)))
        return min(s_to_d, d_to_s)
",n
"
class Solution(object):
    def splitBST(self, root, V):
        if not root:
            return None, None
        elif root.val <= V:
            result = self.splitBST(root.right, V)
            root.right = result[0]
            return root, result[1]
        else:
            result = self.splitBST(root.left, V)
            root.left = result[1]
            return result[0], root

",n
"

class Solution(object):
    def rankTeams(self, votes):
        count = {v: [0]*len(votes[0]) + [v] for v in votes[0]}
        for vote in votes:
            for i, v in enumerate(vote):
                count[v][i] -= 1
        return """".join(sorted(votes[0], key=count.__getitem__))
",m * (n + mlogm)
"

class Solution(object):
    def numOfUnplacedFruits(self, fruits, baskets):
        class SegmentTree(object):
            def __init__(self, N,
                        build_fn=lambda _: 0,
                        query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                        update_fn=lambda x: x):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def binary_search(self, x):
                if self.tree[1] < x:
                    return -1
                i = 1
                while not i >= self.base:
                    if self.tree[2*i] >= x:
                        i = 2*i
                    else:
                        i = 2*i+1
                return i-self.base

        def build(i):
            return baskets[i]

        st = SegmentTree(len(baskets), build_fn=build)
        result = 0
        for x in fruits:
            i = st.binary_search(x)
            if i == -1:
                result += 1
            else:
                st.update(i, 0)
        return result
",nlogn
"
class Solution(object):
    def countSubTrees(self, n, edges, labels):
        def iter_dfs(labels, adj, node, parent, result):
            stk = [(1, (node, parent, [0]*26))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, parent, ret = params
                    stk.append((4, (node, ret)))
                    stk.append((2, (node, parent, reversed(adj[node]), ret)))
                elif step == 2:
                    node, parent, it, ret = params
                    child = next(it, None)
                    if not child or child == parent:
                        continue
                    ret2 = [0]*26
                    stk.append((2, (node, parent, it, ret)))
                    stk.append((3, (ret2, ret)))
                    stk.append((1, (child, node, ret2)))
                elif step == 3:
                    ret2, ret = params
                    for k in range(len(ret2)):
                        ret[k] += ret2[k]
                else:
                    node, ret = params
                    ret[ord(labels[node]) - ord('a')] += 1
                    result[node] += ret[ord(labels[node]) - ord('a')]
        
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*n
        iter_dfs(labels, adj, 0, -1, result)
        return result


",n
"import collections


class Solution2(object):
    def countSubTrees(self, n, edges, labels):
        def dfs(labels, adj, node, parent, result):
            count = [0]*26
            for child in adj[node]:
                if child == parent:
                    continue
                new_count = dfs(labels, adj, child, node, result)
                for k in range(len(new_count)):
                    count[k] += new_count[k]
            count[ord(labels[node]) - ord('a')] += 1
            result[node] = count[ord(labels[node]) - ord('a')]
            return count
        
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*n
        dfs(labels, adj, 0, -1, result)
        return result
",n
"
class Solution(object):
    def stringShift(self, s, shift):
        left_shifts = 0
        for direction, amount in shift:
            if not direction:
                left_shifts += amount
            else:
                left_shifts -= amount
        left_shifts %= len(s)
        return s[left_shifts:] + s[:left_shifts]
",n + l
"
class Solution(object):
    def findMinDifference(self, timePoints):
        minutes = [int(x[:2]) * 60 + int(x[3:]) for x in timePoints]
        minutes.sort()
        return min((y - x) % (24 * 60)  \
                   for x, y in zip(minutes, minutes[1:] + minutes[:1]))

",nlogn
"
import collections



class Solution(object):
    def minExtraChar(self, s, dictionary):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for word in dictionary:
            reduce(dict.__getitem__, word, trie).setdefault(""_end"")
        dp = [float(""inf"")]*(len(s)+1)
        dp[0] = 0
        for i in range(len(s)):
            dp[i+1] = min(dp[i+1], dp[i]+1)
            curr = trie
            for j in range(i, len(s)):
                if s[j] not in curr:
                    break
                curr = curr[s[j]]
                if ""_end"" in curr:
                    dp[j+1] = min(dp[j+1], dp[i])
        return dp[-1]
",(n + m) * l
"
class Solution(object):
    def countPyramids(self, grid):
        def count(grid, reverse):
            def get_grid(i, j):
                return grid[~i][j] if reverse else grid[i][j]

            result = 0
            dp = [0]*len(grid[0])
            for i in range(1, len(grid)):
                new_dp = [0]*len(grid[0])
                for j in range(1, len(grid[0])-1):
                    if get_grid(i, j) == get_grid(i-1, j-1) == get_grid(i-1, j) == get_grid(i-1, j+1) == 1:
                        new_dp[j] = min(dp[j-1], dp[j+1])+1
                dp = new_dp
                result += sum(dp)
            return result
        
        return count(grid, False) + count(grid, True)


",m * n
"class Solution2(object):
    def countPyramids(self, grid):
        def count(grid):
            dp = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]
            for i in range(1, len(grid)):
                for j in range(1, len(grid[0])-1):
                    if grid[i][j] == grid[i-1][j-1] == grid[i-1][j] == grid[i-1][j+1] == 1:
                        dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1])+1
            return sum(sum(row) for row in dp)
        
        return count(grid) + count(grid[::-1])
",m * n
"

class Solution(object):
    def findPrimePairs(self, n):
        def linear_sieve_of_eratosthenes(n):
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return spf 

        spf = linear_sieve_of_eratosthenes(n)
        return [[i, n-i] for i in range(2, n//2+1) if spf[i] == i and spf[n-i] == n-i]
",n
"

class Solution(object):
    def minimumSwaps(self, nums):
        min_idx = min(range(len(nums)), key=nums.__getitem__)
        max_idx = max(reversed(range(len(nums))), key=nums.__getitem__)
        return ((len(nums)-1)-max_idx)+min_idx-int(max_idx < min_idx)
",n
"

class Solution(object):
    def equalizeWater(self, buckets, loss):
        def check(buckets, rate, x):
            return sum(b-x for b in buckets if b-x > 0)*rate >= sum(x-b for b in buckets if x-b > 0)

        EPS = 1e-5
        rate = (100-loss)/100.0
        left, right = float(min(buckets)), float(sum(buckets))/len(buckets)
        while right-left > EPS:
            mid = left + (right-left)/2
            if not check(buckets, rate, mid):
                right = mid
            else:
                left = mid
        return left
",nlogr
"
class Solution(object):
    def isInterleave(self, s1, s2, s3):
        if len(s1) + len(s2) != len(s3):
            return False
        if len(s1) > len(s2):
            return self.isInterleave(s2, s1, s3)
        match = [False for i in range(len(s1) + 1)]
        match[0] = True
        for i in range(1, len(s1) + 1):
            match[i] = match[i -1] and s1[i - 1] == s3[i - 1]
        for j in range(1, len(s2) + 1):
            match[0] = match[0] and s2[j - 1] == s3[j - 1]
            for i in range(1, len(s1) + 1):
                match[i] = (match[i - 1] and s1[i - 1] == s3[i + j - 1]) \
                                       or (match[i] and s2[j - 1] == s3[i + j - 1])
        return match[-1]

",m * n
"
class Solution2(object):
    def isInterleave(self, s1, s2, s3):
        if len(s1) + len(s2) != len(s3):
            return False
        match = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]
        match[0][0] = True
        for i in range(1, len(s1) + 1):
            match[i][0] = match[i - 1][0] and s1[i - 1] == s3[i - 1]
        for j in range(1, len(s2) + 1):
            match[0][j] = match[0][j - 1] and s2[j - 1] == s3[j - 1]
        for i in range(1, len(s1) + 1):
            for j in range(1, len(s2) + 1):
                match[i][j] = (match[i - 1][j] and s1[i - 1] == s3[i + j - 1]) \
                                       or (match[i][j - 1] and s2[j - 1] == s3[i + j - 1])
        return match[-1][-1]

",m * n
"
class Solution3(object):
    def isInterleave(self, s1, s2, s3):
        self.match = {}
        if len(s1) + len(s2) != len(s3):
            return False
        return self.isInterleaveRecu(s1, s2, s3, 0, 0, 0)

    def isInterleaveRecu(self, s1, s2, s3, a, b, c):
        if repr([a, b]) in list(self.match.keys()):
            return self.match[repr([a, b])]

        if c == len(s3):
            return True

        result = False
        if a < len(s1) and s1[a] == s3[c]:
            result = result or self.isInterleaveRecu(s1, s2, s3, a + 1, b, c + 1)
        if b < len(s2) and s2[b] == s3[c]:
            result = result or self.isInterleaveRecu(s1, s2, s3, a, b + 1, c + 1)

        self.match[repr([a, b])] = result

        return result

",m * n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def zigzagLevelOrder(self, root):
        if root is None:
            return []
        result, current = [], [root]
        while current:
            next_level, vals = [], []
            for node in current:
                vals.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            result.append(vals[::-1] if len(result) % 2 else vals)
            current = next_level
        return result
",n
"
import collections


class Solution(object):
    def countKDifference(self, nums, k):
        lookup = collections.defaultdict(int)
        result = 0
        for x in nums:
            if x-k in lookup:
                result += lookup[x-k]
            if x+k in lookup:
                result += lookup[x+k]
            lookup[x] += 1            
        return result
",n
"

class Solution(object):
    def numberOfWays(self, n, m, k, source, dest):
        MOD = 10**9+7
        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        T = [[0, m-1, n-1,           0],
             [1, m-2,   0,         n-1],
             [1,   0, n-2,         m-1],
             [0,   1,   1, (n-2)+(m-2)]]
        dp = [0]*4 
        if source == dest:
            dp[0] = 1
        elif source[0] == dest[0]:
            dp[1] = 1
        elif source[1] == dest[1]:
            dp[2] = 1
        else:
            dp[3] = 1
        dp = matrix_mult([dp], matrix_expo(T, k))[0] 
        return dp[0]


",logn
"
class Solution2(object):
    def numberOfWays(self, n, m, k, source, dest):
        MOD = 10**9+7
        both_same = row_same = col_same = no_same = 0
        if source == dest:
            both_same = 1
        elif source[0] == dest[0]:
            row_same = 1
        elif source[1] == dest[1]:
            col_same = 1
        else:
            no_same = 1
        for _ in range(k):
            both_same, row_same, col_same, no_same = (row_same+col_same)%MOD, (both_same*(m-1)+row_same*(m-2)+no_same)%MOD, (both_same*(n-1)+col_same*(n-2)+no_same)%MOD, (row_same*(n-1)+col_same*(m-1)+no_same*((n-2)+(m-2)))%MOD
        return both_same
",n
"
import collections


class Solution(object):
    def minCharacters(self, a, b):
        count1 = collections.Counter(ord(c)-ord('a') for c in a)
        count2 = collections.Counter(ord(c)-ord('a') for c in b)
        result = len(a) + len(b) - max((count1+count2).values()) 
        for i in range(26-1):
            if i > 0:
                count1[i] += count1[i-1]
                count2[i] += count2[i-1]
            result = min(result, len(a) - count1[i] + count2[i]) 
            result = min(result, len(b) - count2[i] + count1[i]) 
        return result
",m + n
"
class Solution(object):
    def minScoreTriangulation(self, A):
        dp = [[0 for _ in range(len(A))] for _ in range(len(A))]
        for p in range(3, len(A)+1):
            for i in range(len(A)-p+1):
                j = i+p-1
                dp[i][j] = float(""inf"")
                for k in range(i+1, j):
                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j] + A[i]*A[j]*A[k])
        return dp[0][-1]
",n^3
"
class Solution(object):
    def multiply(self, num1, num2):
        result = [0]*(len(num1)+len(num2))
        for i in reversed(range(len(num1))):
            for j in reversed(range(len(num2))):
                result[i+j+1] += int(num1[i])*int(num2[j])
                result[i+j] += result[i+j+1]//10
                result[i+j+1] %= 10
        for i in range(len(result)):
            if result[i]:
                break
        return """".join([str(x) for x in result[i:]])

",m * n
"class Solution2(object):
    def multiply(self, num1, num2):
        num1, num2 = num1[::-1], num2[::-1]
        result = [0]*(len(num1)+len(num2))
        for i in range(len(num1)):
            for j in range(len(num2)):
                result[i+j] += int(num1[i])*int(num2[j])
                result[i+j+1] += result[i+j]//10
                result[i+j] %= 10
        for i in reversed(range(len(result))):
            if result[i]:
                break
        return """".join(map(str, result[i::-1]))

",m * n
"
class Solution3(object):
    def multiply(self, num1, num2):
        return str(int(num1) * int(num2))
",m * n
"
class Solution(object):
    def minNumberOfFrogs(self, croakOfFrogs):
        S = ""croak""
        lookup = [0]*len(S)
        result = 0
        for c in croakOfFrogs:
            i = S.find(c)
            lookup[i] += 1
            if lookup[i-1]:
                lookup[i-1] -= 1
            elif i == 0:
                result += 1
            else:
                return -1
        return result if result == lookup[-1] else -1
",n
"
class Solution(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):
        boxes.sort(reverse=True)
        left, right = 0, len(warehouse)-1
        for h in boxes:
            if h <= warehouse[left]:
                left += 1
            elif h <= warehouse[right]:
                right -= 1
            if left > right:
                break
        return left + (len(warehouse)-1-right)
",nlogn
"

class Solution(object):
    def isWinner(self, player1, player2):
        k = 2
        def f(arr):
            result = cnt = 0
            for i in range(len(arr)):
                result += 2*arr[i] if cnt else arr[i]
                cnt += (arr[i] == 10)
                if i-k >= 0:
                    cnt -= (arr[i-k] == 10)
            return result

        a, b = f(player1), f(player2)
        return 1 if a > b else 2 if a < b else 0
",n
"
class Solution(object):
    def circularArrayLoop(self, nums):
        def next_index(nums, i):
            return (i + nums[i]) % len(nums)

        for i in range(len(nums)):
            if nums[i] == 0:
                continue

            slow, fast = i, i
            while nums[next_index(nums, slow)] * nums[i] > 0 and \
                  nums[next_index(nums, fast)] * nums[i] > 0 and \
                  nums[next_index(nums, next_index(nums, fast))] * nums[i] > 0:
                slow = next_index(nums, slow)
                fast = next_index(nums, next_index(nums, fast))
                if slow == fast:
                    if slow == next_index(nums, slow):
                        break
                    return True

            slow, val = i, nums[i]
            while nums[slow] * val > 0:
                tmp = next_index(nums, slow)
                nums[slow] = 0
                slow = tmp

        return False

",n
"
class Solution(object):
    def largest1BorderedSquare(self, grid):
        top, left = [a[:] for a in grid], [a[:] for a in grid]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if not grid[i][j]:
                    continue
                if i:
                    top[i][j] = top[i-1][j] + 1
                if j:
                    left[i][j] = left[i][j-1] + 1
        for l in reversed(range(1, min(len(grid), len(grid[0]))+1)):
            for i in range(len(grid)-l+1):
                for j in range(len(grid[0])-l+1):
                    if min(top[i+l-1][j],
                           top[i+l-1][j+l-1],
                           left[i][j+l-1],
                           left[i+l-1][j+l-1]) >= l:
                        return l*l
        return 0
",n^3
"

class Solution(object):
    def findMaximumScore(self, nums):
        result = mx = 0
        for x in nums:
            result += mx
            mx = max(mx, x)
        return result
",n
"
class Solution(object):
    def imageSmoother(self, M):
        def getGray(M, i, j):
            total, count = 0, 0.0
            for r in range(-1, 2):
                for c in range(-1, 2):
                    ii, jj = i + r, j + c
                    if 0 <= ii < len(M) and 0 <= jj < len(M[0]):
                        total += M[ii][jj]
                        count += 1.0
            return int(total / count)

        result = [[0 for _ in range(len(M[0]))] for _ in range(len(M))]
        for i in range(len(M)):
            for j in range(len(M[0])):
                result[i][j] = getGray(M, i, j)
        return result

",m * n
"
class Solution(object):
    def isValidSudoku(self, board):
        for i in range(9):
            if not self.isValidList([board[i][j] for j in range(9)]) or \
               not self.isValidList([board[j][i] for j in range(9)]):
                return False
        for i in range(3):
            for j in range(3):
                if not self.isValidList([board[m][n] for n in range(3 * j, 3 * j + 3) \
                                                     for m in range(3 * i, 3 * i + 3)]):
                    return False
        return True

    def isValidList(self, xs):
        xs = [x for x in xs if x != '.']
        return len(set(xs)) == len(xs)


",9^2
"
import heapq



class Solution(object):
    def minTimeToReach(self, moveTime):
        def dijkstra(start, target):
            DIRECTIONS = [(1, 0), (0, 1), (-1, 0), (0, -1)]
            dist = [[float(""inf"")]*len(moveTime[0]) for _ in range(len(moveTime))]
            dist[start[0]][start[1]] = 0
            min_heap = [(dist[start[0]][start[1]], start[0], start[1])]
            while min_heap:
                curr, i, j = heapq.heappop(min_heap)
                if curr != dist[i][j]:
                    continue
                if (i, j) == target:
                    break
                for di, dj in DIRECTIONS:
                    ni, nj = i+di, j+dj
                    c = (i+j)%2+1
                    if not (0 <= ni < len(moveTime) and 0 <= nj < len(moveTime[0]) and dist[ni][nj] > max(moveTime[ni][nj], curr)+c):
                        continue
                    dist[ni][nj] = max(moveTime[ni][nj], curr)+c
                    heapq.heappush(min_heap, (dist[ni][nj], ni, nj))
            return dist[target[0]][target[1]]
    
        return dijkstra((0, 0), (len(moveTime)-1, len(moveTime[0])-1))
",n * m * logn(n * m)
"
import random
import collections



class Solution(object):
    def minCost(self, basket1, basket2):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        cnt = collections.Counter()
        for x in basket1:
            cnt[x] += 1
        for x in basket2:
            cnt[x] -= 1
        mn = min(cnt.keys())
        swaps = []
        for k, v in cnt.items():
            if v%2:
                return -1
            swaps.extend(k for _ in range(abs(v)//2))
        nth_element(swaps, len(swaps)//2)
        return sum(min(swaps[i], mn*2) for i in range(len(swaps)//2))
",n
"
class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):
        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
            if visited in lookup:
                return lookup[visited]

            mask = 1
            for i in range(maxChoosableInteger):
                if visited & mask == 0:
                    if i + 1 >= desiredTotal or \
                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):
                        lookup[visited] = True
                        return True
                mask <<= 1
            lookup[visited] = False
            return False

        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
            return False

        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})

",n!
"

class Solution(object):
    def isAdditiveNumber(self, num):
        def add(a, b):
            res, carry, val = """", 0, 0
            for i in range(max(len(a), len(b))):
                val = carry
                if i < len(a):
                    val += int(a[-(i + 1)])
                if i < len(b):
                    val += int(b[-(i + 1)])
                carry, val = val / 10, val % 10
                res += str(val)
            if carry:
                res += str(carry)
            return res[::-1]

        for i in range(1, len(num)):
            for j in range(i + 1, len(num)):
                s1, s2 = num[0:i], num[i:j]
                if (len(s1) > 1 and s1[0] == '0') or \
                   (len(s2) > 1 and s2[0] == '0'):
                    continue

                expected = add(s1, s2)
                cur = s1 + s2 + expected
                while len(cur) < len(num):
                    s1, s2, expected = s2, expected, add(s2, expected)
                    cur += expected
                if cur == num:
                    return True
        return False

",n^3
"

class Solution(object):
    def maximumBobPoints(self, numArrows, aliceArrows):
        def check(mask, numArrows):
            score = 0
            cnt = [0]*len(aliceArrows)
            i, base = 0, 1
            for k, a in enumerate(aliceArrows):
                if mask&1:
                    need = a+1
                    if need > numArrows:
                        return 0, [0]*len(aliceArrows)
                    numArrows -= need
                    cnt[k] = need
                    score += k
                mask >>= 1
            cnt[-1] += numArrows
            return score, cnt
        
        result = [0]*len(aliceArrows)
        best = 0
        for mask in range(1, 2**len(aliceArrows)):
            score, cnt = check(mask, numArrows)
            if score > best:
                best = score
                result = cnt
        return result
",n * 2^n
"
import pandas as pd



def Solution(employees: pd.DataFrame) -> pd.DataFrame:
    return employees.head(3)
",1
"
class Solution(object):
    def maxProfit(self, prices):
        hold1, hold2 = float(""-inf""), float(""-inf"")
        release1, release2 = 0, 0
        for i in prices:
            hold1 = max(hold1, -i)
            release1 = max(release1, hold1 + i)
            hold2 = max(hold2, release1 - i)
            release2 = max(release2, hold2 + i)
        return release2


",n
"class Solution2(object):
    def maxProfit(self, prices):
        def maxAtMostKPairsProfit(prices, k):
            max_buy = [float(""-inf"") for _ in range(k + 1)]
            max_sell = [0 for _ in range(k + 1)]
            for i in range(len(prices)):
                for j in range(1, k + 1):
                    max_buy[j] = max(max_buy[j], max_sell[j-1] - prices[i])
                    max_sell[j] = max(max_sell[j], max_buy[j] + prices[i])
            return max_sell[k]

        return maxAtMostKPairsProfit(prices, 2)


",k * n
"class Solution3(object):
    def maxProfit(self, prices):
        min_price, max_profit_from_left, max_profits_from_left = \
            float(""inf""), 0, []
        for price in prices:
            min_price = min(min_price, price)
            max_profit_from_left = max(max_profit_from_left, price - min_price)
            max_profits_from_left.append(max_profit_from_left)

        max_price, max_profit_from_right, max_profits_from_right = 0, 0, []
        for i in reversed(list(range(len(prices)))):
            max_price = max(max_price, prices[i])
            max_profit_from_right = max(max_profit_from_right,
                                        max_price - prices[i])
            max_profits_from_right.insert(0, max_profit_from_right)

        max_profit = 0
        for i in range(len(prices)):
            max_profit = max(max_profit,
                             max_profits_from_left[i] +
                             max_profits_from_right[i])

        return max_profit

",n
"
import collections


class Trie(object):
    def __init__(self, bit_count):
        self.__root = {}
        self.__bit_count = bit_count
        
    def insert(self, num, v):
        node = self.__root
        for i in reversed(range(self.__bit_count)):
            curr = (num>>i) & 1
            new_node = node.setdefault(curr, collections.defaultdict(int))
            new_node[""_cnt""] += v
            if not new_node[""_cnt""]:
                del node[curr]
                break
            node = new_node
                
    def query(self, num):
        node, result = self.__root, 0
        for i in reversed(range(self.__bit_count)):
            curr = (num>>i) & 1
            if 1^curr in node:
                node = node[1^curr]
                result |= 1<<i
            else:
                node = node[curr]
        return result


class Solution(object):
    def maxGeneticDifference(self, parents, queries):
        def iter_dfs(adj, qs, trie, result):
            stk = [(1, adj[-1][0])]
            while stk:
                step, node = stk.pop()
                if step == 1:
                    trie.insert(node, 1)
                    for i, val in qs[node]:
                        result[i] = trie.query(val)
                    stk.append((2, node))
                    for child in reversed(adj[node]):
                        stk.append((1, child))
                elif step == 2:
                    trie.insert(node, -1)
    
        adj = collections.defaultdict(list)
        for node, parent in enumerate(parents):
            adj[parent].append(node)
        qs = collections.defaultdict(list)
        max_val = len(parents)-1
        for i, (node, val) in enumerate(queries):
            qs[node].append((i, val))
            max_val = max(max_val, val)
        result = [0]*len(queries)
        iter_dfs(adj, qs, Trie(max_val.bit_length()), result)
        return result


",nlogk + mlogk
"import collections


class Trie(object):
    def __init__(self, bit_count):
        self.__root = {}
        self.__bit_count = bit_count
        
    def insert(self, num, v):
        node = self.__root
        for i in reversed(range(self.__bit_count)):
            curr = (num>>i) & 1
            new_node = node.setdefault(curr, collections.defaultdict(int))
            new_node[""_cnt""] += v
            if not new_node[""_cnt""]:
                del node[curr]
                break
            node = new_node
                
    def query(self, num):
        node, result = self.__root, 0
        for i in reversed(range(self.__bit_count)):
            curr = (num>>i) & 1
            if 1^curr in node:
                node = node[1^curr]
                result |= 1<<i
            else:
                node = node[curr]
        return result


class Solution2(object):
    def maxGeneticDifference(self, parents, queries):
        def dfs(adj, qs, node, trie, result):
            trie.insert(node, 1)
            for i, val in qs[node]:
                result[i] = trie.query(val)
            for child in adj[node]:
                dfs(adj, qs, child, trie, result)
            trie.insert(node, -1)

        adj = collections.defaultdict(list)
        for node, parent in enumerate(parents):
            adj[parent].append(node)
        qs = collections.defaultdict(list)
        max_val = len(parents)-1
        for i, (node, val) in enumerate(queries):
            qs[node].append((i, val))
            max_val = max(max_val, val)
        result = [0]*len(queries)
        dfs(adj, qs, adj[-1][0], Trie(max_val.bit_length()), result)
        return result
",nlogk + mlogk
"
import collections


class Solution(object):
    def findLeastNumOfUniqueInts(self, arr, k):
        count = collections.Counter(arr)
        result, count_count = len(count), collections.Counter(iter(count.values()))
        for c in range(1, len(arr)+1): 
            if k < c*count_count[c]:
                result -= k//c
                break
            k -= c*count_count[c]
            result -= count_count[c]                
        return result
",n
"
class Solution(object):
    def distributeCandies(self, candies, num_people):
        p = int((2*candies + 0.25)**0.5 - 0.5) 
        remaining = candies - (p+1)*p//2
        rows, cols = divmod(p, num_people)
        
        result = [0]*num_people
        for i in range(num_people):
            result[i] = (i+1)*(rows+1) + (rows*(rows+1)//2)*num_people if i < cols else \
                        (i+1)*rows + ((rows-1)*rows//2)*num_people
        result[cols] += remaining
        return result


",n + logc
"class Solution2(object):
    def distributeCandies(self, candies, num_people):
        left, right = 1, candies
        while left <= right:
            mid = left + (right-left)//2
            if not ((mid <= candies*2 // (mid+1))):
                right = mid-1
            else:
                left = mid+1
        p = right
        remaining = candies - (p+1)*p//2
        rows, cols = divmod(p, num_people)
        
        result = [0]*num_people
        for i in range(num_people):
            result[i] = (i+1)*(rows+1) + (rows*(rows+1)//2)*num_people if i < cols else \
                        (i+1)*rows + ((rows-1)*rows//2)*num_people
        result[cols] += remaining
        return result


",n + logc
"class Solution3(object):
    def distributeCandies(self, candies, num_people):
        result = [0]*num_people
        i = 0
        while candies != 0:
            result[i % num_people] += min(candies, i+1)
            candies -= min(candies, i+1)
            i += 1
        return result
",sqrt(c)
"
class Solution(object):
    def threeSum(self, nums):
        result = []
        nums.sort()
        for i in reversed(list(range(2, len(nums)))):
            if i+1 < len(nums) and nums[i] == nums[i+1]:
                continue
            target = -nums[i]
            left, right = 0, i-1
            while left < right:
                if nums[left]+nums[right] < target:
                    left += 1
                elif nums[left]+nums[right] > target:
                    right -= 1
                else:
                    result.append([nums[left], nums[right], nums[i]])
                    left += 1
                    right -= 1
                    while left < right and nums[left] == nums[left-1]:
                        left += 1
                    while left < right and nums[right] == nums[right+1]:
                        right -= 1
        return result


",n^2
"class Solution2(object):
    def threeSum(self, nums):
        nums, result, i = sorted(nums), [], 0
        while i < len(nums) - 2:
            if i == 0 or nums[i] != nums[i - 1]:
                j, k = i + 1, len(nums) - 1
                while j < k:
                    if nums[i] + nums[j] + nums[k] < 0:
                        j += 1
                    elif nums[i] + nums[j] + nums[k] > 0:
                        k -= 1
                    else:
                        result.append([nums[i], nums[j], nums[k]])
                        j, k = j + 1, k - 1
                        while j < k and nums[j] == nums[j - 1]:
                            j += 1
                        while j < k and nums[k] == nums[k + 1]:
                            k -= 1
            i += 1
        return result

",n^2
"
class Solution(object):
    def longestSubarray(self, nums):
        count, left = 0, 0
        for right in range(len(nums)):
            count += (nums[right] == 0)
            if count >= 2:
                count -= (nums[left] == 0)
                left += 1
        return (right-left+1)-1


",n
"class Solution2(object):
    def longestSubarray(self, nums):
        result, count, left = 0, 0, 0
        for right in range(len(nums)):
            count += (nums[right] == 0)
            while count >= 2:
                count -= (nums[left] == 0)
                left += 1
            result = max(result, right-left+1)
        return result-1
",n
"
class Solution(object):
    def mctFromLeafValues(self, arr):
        result = 0
        stk = [float(""inf"")]
        for x in arr:
            while stk[-1] <= x:
                result += stk.pop() * min(stk[-1], x)
            stk.append(x)
        while len(stk) > 2:
            result += stk.pop() * stk[-1]
        return result
",n
"

class Solution(object):
    def strongPasswordCheckerII(self, password):
        SPECIAL = set(""!
        return (len(password) >= 8 and
                any(c.islower() for c in password) and
                any(c.isupper() for c in password) and
                any(c.isdigit() for c in password) and
                any(c in SPECIAL for c in password) and
                all(password[i] != password[i+1] for i in range(len(password)-1)))
",n
"

class Solution(object):
    def minLength(self, s, numOps):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def lengths():
            cnt = 0
            for i in range(len(s)):
                cnt += 1
                if i+1 == len(s) or s[i+1] != s[i]:
                    yield cnt
                    cnt = 0
    
        def check(x):
            if x == 1:
                cnt = sum(int(x) != i%2 for i, x in enumerate(s))
                return min(cnt, len(s)-cnt) <= numOps
            return sum(l//(x+1) for l in lengths()) <= numOps
    
        return binary_search(1, len(s), check)


",nlogn
"
class Solution2(object):
    def minLength(self, s, numOps):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(x):
            if x == 1:
                cnt = sum(int(x) != i%2 for i, x in enumerate(s))
                return min(cnt, len(s)-cnt) <= numOps
            return sum(l//(x+1) for l in arr) <= numOps
    
        arr = []
        cnt = 0
        for i in range(len(s)):
            cnt += 1
            if i+1 == len(s) or s[i+1] != s[i]:
                arr.append(cnt)
                cnt = 0
        return binary_search(1, len(s), check)

",nlogn
"

class Solution(object):
    def beautifulIndices(self, s, a, b, k):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    yield i-j
                    j = prefix[j]

        result = []
        if not (len(a) <= len(s) and len(b) <= len(s)):
            return result
        lookup = list(KMP(s, b))
        j = 0
        for i in KMP(s, a):
            while j < len(lookup) and lookup[j] < i-k:
                j += 1
            if j < len(lookup) and lookup[j] <= i+k:
                result.append(i)
        return result


",n
"import bisect



class Solution2(object):
    def beautifulIndices(self, s, a, b, k):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            prefix = getPrefix(pattern+
            return ((i-(len(pattern)+1))-(len(pattern)-1) for i in range((len(pattern)+1)+(len(pattern)-1) , len(prefix)) if prefix[i]+1 == len(pattern))
    
        result = []
        if not (len(a) <= len(s) and len(b) <= len(s)):
            return result
        lookup = list(KMP(s, b))
        j = 0
        for i in KMP(s, a):
            j = bisect.bisect_left(lookup, i-k)
            if j < len(lookup) and lookup[j] <= i+k:
                result.append(i)
        return result
",n + xlogy
"
class Solution(object):
    def longestPalindromeSubseq(self, s):
        if s == s[::-1]: 
            return len(s)

        dp = [[1] * len(s) for _ in range(2)]
        for i in reversed(range(len(s))):
            for j in range(i+1, len(s)):
                if s[i] == s[j]:
                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2
                else:
                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])
        return dp[0][-1]

",n^2
"
class Solution(object):
    def ipToCIDR(self, ip, n):
        def ipToInt(ip):
            result = 0
            for i in ip.split('.'):
                result = 256 * result + int(i)
            return result

        def intToIP(n):
            return ""."".join(str((n >> i) % 256) \
                            for i in (24, 16, 8, 0))

        start = ipToInt(ip)
        result = []
        while n:
            mask = max(33-(start & ~(start-1)).bit_length(), \
                       33-n.bit_length())
            result.append(intToIP(start) + '/' + str(mask))
            start += 1 << (32-mask)
            n -= 1 << (32-mask)
        return result

",n
"
class Solution(object):
    def splitArray(self, nums, m):
        def check(nums, m, s):
            cnt, curr_sum = 1, 0
            for num in nums:
                curr_sum += num
                if curr_sum > s:
                    curr_sum = num
                    cnt += 1
            return cnt <= m

        left, right = max(nums), sum(nums)
        while left <= right:
            mid = left + (right - left) // 2
            if check(nums, m, mid):
                right = mid - 1
            else:
                left = mid + 1
        return left
",nlogs
"

class Solution(object):
    def sameEndSubstringCount(self, s, queries):
        prefix = [[0]*26]
        for i in range(len(s)):
            prefix.append(prefix[-1][:])
            prefix[-1][ord(s[i])-ord('a')] += 1
        result = [0]*len(queries)
        for i, (l, r) in enumerate(queries):
            for j in range(26):
                cnt = prefix[r+1][j]-prefix[l][j]
                result[i] += (1+cnt)*cnt//2
        return result
",26 * (n + q)
"

class Solution(object):
    def calculateScore(self, s):
        result = 0
        lookup = [[] for _ in range(26)]
        for i, x in enumerate(s):
            x = ord(x)-ord('a')
            if lookup[25-x]:
                result += i-lookup[25-x].pop()
            else:
                lookup[x].append(i)
        return result
",n + 26
"
import collections



class Solution(object):
    def minimumCoins(self, prices):
        dp = [float(""inf"")]*(len(prices)+1)
        dp[0] = 0
        dq = collections.deque()
        j = 0
        for i in range(len(prices)):
            while dq and dp[dq[-1]]+prices[dq[-1]] >= dp[i]+prices[i]:
                dq.pop()
            dq.append(i)
            while j+(j+1) < i:
                assert(len(dq) != 0)
                if dq[0] == j:
                    dq.popleft()
                j += 1
            dp[i+1] = dp[dq[0]]+prices[dq[0]]
        return dp[-1]


",n
"
from sortedcontainers import SortedList


class Solution2(object):
    def minimumCoins(self, prices):
        dp = [float(""inf"")]*(len(prices)+1)
        dp[0] = 0
        sl = SortedList()
        j = 0
        for i in range(len(prices)):
            sl.add((dp[i]+prices[i], i))
            while j+(j+1) < i:
                sl.remove(((dp[j]+prices[j], j)))
                j += 1
            dp[i+1] = sl[0][0]
        return dp[-1]
",nlogn
"
class Solution(object):
    def largestRectangleArea(self, heights):
        stk, result = [-1], 0
        for i in range(len(heights)+1):
            while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):
                result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))
            stk.append(i) 
        return result
",n
"
class Solution(object):
    def relativeSortArray(self, arr1, arr2):
        lookup = {v: i for i, v in enumerate(arr2)}
        return sorted(arr1, key=lambda i: lookup.get(i, len(arr2)+i))
",nlogn
"
import itertools


class Solution(object):
    def expressiveWords(self, S, words):
        def RLE(S):
            return zip(*[(k, len(list(grp)))
                                  for k, grp in itertools.groupby(S)])

        R, count = RLE(S)
        result = 0
        for word in words:
            R2, count2 = RLE(word)
            if R2 != R:
                continue
            result += all(c1 >= max(c2, 3) or c1 == c2
                          for c1, c2 in zip(count, count2))
        return result

",n + s
"
class Solution(object):

    def __init__(self, width, height):
        self.__w = width
        self.__h = height
        self.__curr = 0

    def move(self, num):
        self.__curr += num

    def getPos(self):
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n < self.__w:
            return [n, 0]
        n -= self.__w-1
        if n < self.__h:
            return [self.__w-1, n]
        n -= self.__h-1
        if n < self.__w:
            return [(self.__w-1)-n, self.__h-1]
        n -= self.__w-1
        return [0, (self.__h-1)-n]

    def getDir(self):
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n < self.__w:
            return ""South"" if n == 0 and self.__curr else ""East""
        n -= self.__w-1
        if n < self.__h:
            return ""North""
        n -= self.__h-1
        if n < self.__w:
            return ""West""
        n -= self.__w-1
        return ""South""


",1
"class Solution2(object):

    def __init__(self, width, height):
        self.__w = width
        self.__h = height
        self.__curr = 0

    def move(self, num):
        self.__curr += num

    def getPos(self):
        return self.__getPosDir()[0] 

    def getDir(self):
        return self.__getPosDir()[1]

    def __getPosDir(self):
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n < self.__w:
            return [[n, 0], ""South"" if n == 0 and self.__curr else ""East""]
        n -= self.__w-1
        if n < self.__h:
            return [[self.__w-1, n], ""North""]
        n -= self.__h-1
        if n < self.__w:
            return [[(self.__w-1)-n, self.__h-1], ""West""]
        n -= self.__w-1
        return [[0, (self.__h-1)-n], ""South""]
",1
"
class Solution(object):
    def intersection(self, nums1, nums2):
        if len(nums1) > len(nums2):
            return self.intersection(nums2, nums1)

        lookup = set()
        for i in nums1:
            lookup.add(i)

        res = []
        for i in nums2:
            if i in lookup:
                res += i,
                lookup.discard(i)

        return res

    def intersection2(self, nums1, nums2):
        return list(set(nums1) & set(nums2))


",m + n
"
class Solution2(object):
    def intersection(self, nums1, nums2):
        if len(nums1) > len(nums2):
            return self.intersection(nums2, nums1)

        def binary_search(compare, nums, left, right, target):
            while left < right:
                mid = left + (right - left) / 2
                if compare(nums[mid], target):
                    right = mid
                else:
                    left = mid + 1
            return left

        nums1.sort(), nums2.sort()

        res = []
        left = 0
        for i in nums1:
            left = binary_search(lambda x, y: x >= y, nums2, left, len(nums2), i)
            if left != len(nums2) and nums2[left] == i:
                res += i,
                left = binary_search(lambda x, y: x > y, nums2, left, len(nums2), i)

        return res


","max(m, n) * log(max(m, n))"
"
class Solution3(object):
    def intersection(self, nums1, nums2):
        nums1.sort(), nums2.sort()
        res = []

        it1, it2 = 0, 0
        while it1 < len(nums1) and it2 < len(nums2):
            if nums1[it1] < nums2[it2]:
                it1 += 1
            elif nums1[it1] > nums2[it2]:
                it2 += 1
            else:
                if not res or res[-1] != nums1[it1]:
                    res += nums1[it1],
                it1 += 1
                it2 += 1

        return res

","max(m, n) * log(max(m, n))"
"

class Solution(object):
    def maxTotalReward(self, rewardValues):
        mx = max(rewardValues)
        dp = 1
        mask = (1<<mx)-1
        for v in sorted(set(rewardValues)):
            x = dp&((1<<v)-1)
            dp |= (x<<v)&mask
        return mx+(dp.bit_length()-1)


",nlogn + r^2
"
class Solution2(object):
    def maxTotalReward(self, rewardValues):
        dp = 1
        for v in sorted(set(rewardValues)):
            x = dp&((1<<v)-1)
            dp |= x<<v
        return dp.bit_length()-1
",nlogn + r^2
"
class Solution(object):
    def closestDivisors(self, num):
        def divisors(n):
            for d in reversed(range(1, int(n**0.5)+1)):
                if n % d == 0:
                    return d, n//d
            return 1, n

        return min([divisors(num+1), divisors(num+2)], key=lambda x: x[1]-x[0])



",sqrt(n)
"class Solution2(object):
    def closestDivisors(self, num):
        result, d = [1, num+1], 1
        while d*d <= num+2:
            if (num+2) % d == 0:
                result = [d, (num+2)//d]
            if (num+1) % d == 0:
                result = [d, (num+1)//d]
            d += 1
        return result
",sqrt(n)
"

class Solution(object):
    def minNumber(self, nums1, nums2):
        common = set(nums1)&set(nums2)
        if common:
            return min(common)
        mn1, mn2 = min(nums1), min(nums2)
        if mn1 > mn2:
            mn1, mn2 = mn2, mn1
        return 10*mn1+mn2
",m + n
"
class Solution(object):
    def getLastMoment(self, n, left, right):
        return max(max(left or [0]), n-min(right or [n]))
",n
"
import math


class Solution(object):
    def powerfulIntegers(self, x, y, bound):
        result = set()
        log_x = int(math.floor(math.log(bound) / math.log(x)))+1 if x != 1 else 1
        log_y = int(math.floor(math.log(bound) / math.log(y)))+1 if y != 1 else 1
        pow_x = 1
        for i in range(log_x):
            pow_y = 1
            for j in range(log_y):
                val = pow_x + pow_y
                if val <= bound:
                    result.add(val)
                pow_y *= y
            pow_x *= x
        return list(result)
",(logn)^2
"
from random import randint


class Solution(object):
    def minMoves2(self, nums):
        def kthElement(nums, k):
            def PartitionAroundPivot(left, right, pivot_idx, nums):
                pivot_value = nums[pivot_idx]
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if nums[i] > pivot_value:
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)
                if new_pivot_idx == k:
                    return nums[new_pivot_idx]
                elif new_pivot_idx > k:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1

        median = kthElement(nums, len(nums)//2)
        return sum(abs(num - median) for num in nums)

    def minMoves22(self, nums):
        median = sorted(nums)[len(nums) / 2]
        return sum(abs(num - median) for num in nums)

",n
"
import itertools


class Solution(object):
    def maximumWealth(self, accounts):
        return max(map(sum, accounts))
",m * n
"
import collections


class Solution(object):
    def fourSumCount(self, A, B, C, D):
        A_B_sum = collections.Counter(a+b for a in A for b in B)
        return sum(A_B_sum[-c-d] for c in C for d in D)

",n^2
"
class Solution(object):
    def findMaximums(self, nums):
        def find_bound(nums, direction, init):
            result = [0]*len(nums)
            stk = [init]
            for i in direction(range(len(nums))):
                while stk[-1] != init and nums[stk[-1]] >= nums[i]:
                    stk.pop()
                result[i] = stk[-1]
                stk.append(i)
            return result

        left = find_bound(nums, lambda x: x, -1)
        right = find_bound(nums, reversed, len(nums))
        result = [-1]*len(nums)
        for i, v in enumerate(nums):
            result[((right[i]-1)-left[i])-1] = max(result[((right[i]-1)-left[i])-1], v)
        for i in reversed(range(len(nums)-1)):
            result[i] = max(result[i], result[i+1])
        return result
",n
"
class Solution(object):
    def largestOddNumber(self, num):
        for i in reversed(range(len(num))):
            if int(num[i])%2:
                return num[:i+1]
        return """"
",n
"
class Solution(object):
    def wateringPlants(self, plants, capacity):
        result, can = len(plants), capacity
        for i, x in enumerate(plants):
            if can < x:
                result += 2*i
                can = capacity
            can -= x
        return result
",n
"
from collections import deque


class Solution(object):

    def __init__(self, vec2d):
        self.stack = deque((len(v), iter(v)) for v in vec2d if v)

    def __next__(self):
        length, iterator = self.stack.popleft()
        if length > 1:
            self.stack.appendleft((length-1, iterator))
        return next(iterator)

    def hasNext(self):
        return bool(self.stack)
",1
"
class Solution(object):
    def stoneGameVII(self, stones):
        def score(i, j):
            return prefix[j+1]-prefix[i]

        prefix = [0]
        for stone in stones:
            prefix.append(prefix[-1]+stone)
        dp = [[0 for _ in range(len(stones))] for _ in range(2)]
        for i in reversed(range(len(stones))):
            for j in range(i+1, len(stones)):
                dp[i%2][j] = max(score(i+1, j)-dp[(i+1)%2][j], score(i, j-1)-dp[i%2][j-1])
        return dp[0][-1]
",n^2
"
class Solution(object):
    def minimumTimeRequired(self, jobs, k):
        def backtracking(jobs, i, cap, counts):
            if i == len(jobs):
                return True
            for j in range(len(counts)):
                if counts[j]+jobs[i] <= cap:
                    counts[j] += jobs[i]
                    if backtracking(jobs, i+1, cap, counts):
                        return True
                    counts[j] -= jobs[i]
                if counts[j] == 0:
                    break
            return False

        jobs.sort(reverse=True)
        left, right = max(jobs), sum(jobs)
        while left <= right:
            mid = left + (right-left)//2
            if backtracking(jobs, 0, mid, [0]*k):
                right = mid-1
            else:
                left = mid+1
        return left


",k^n * logr
"class Solution2(object):
    def minimumTimeRequired(self, jobs, k):
        def backtracking(jobs, i, counts, result):
            if i == len(jobs):
                result[0] = min(result[0], max(counts))
                return
            for j in range(len(counts)):
                if counts[j]+jobs[i] <= result[0]:
                    counts[j] += jobs[i]
                    backtracking(jobs, i+1, counts, result)
                    counts[j] -= jobs[i]
                if counts[j] == 0:
                    break

        jobs.sort(reverse=False)
        result = [sum(jobs)]
        backtracking(jobs, 0, [0]*k, result)
        return result[0]
",k * k^n
"
class Solution(object):
    def minSwap(self, A, B):
        dp_no_swap, dp_swap = [0]*2, [1]*2
        for i in range(1, len(A)):
            dp_no_swap[i%2], dp_swap[i%2] = float(""inf""), float(""inf"")
            if A[i-1] < A[i] and B[i-1] < B[i]:
                dp_no_swap[i%2] = min(dp_no_swap[i%2], dp_no_swap[(i-1)%2])
                dp_swap[i%2] = min(dp_swap[i%2], dp_swap[(i-1)%2]+1)
            if A[i-1] < B[i] and B[i-1] < A[i]:
                dp_no_swap[i%2] = min(dp_no_swap[i%2], dp_swap[(i-1)%2])
                dp_swap[i%2] = min(dp_swap[i%2], dp_no_swap[(i-1)%2]+1)
        return min(dp_no_swap[(len(A)-1)%2], dp_swap[(len(A)-1)%2])

",n
"
class Solution(object):
    def numDistinct(self, S, T):
        ways = [0 for _ in range(len(T) + 1)]
        ways[0] = 1
        for S_char in S:
            for j, T_char in reversed(list(enumerate(T))):
                if S_char == T_char:
                    ways[j + 1] += ways[j]
        return ways[len(T)]

",n^2
"

class Solution(object):
    def findDelayedArrivalTime(self, arrivalTime, delayedTime):
        return (arrivalTime + delayedTime)%24
",1
"

class Solution(object):
    def monkeyMove(self, n):
        MOD = 10**9+7
        return (pow(2, n, MOD)-2)%MOD
",logn
"
import collections


class Solution(object):
    def smallestSubsequence(self, text):
        count = collections.Counter(text)

        lookup, stk = set(), []
        for c in text:
            if c not in lookup:
                while stk and stk[-1] > c and count[stk[-1]]:
                    lookup.remove(stk.pop())
                stk += c
                lookup.add(c)
            count[c] -= 1
        return """".join(stk)
",n
"
import collections
from functools import partial





class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n
        self.ancestor = list(range(n)) 

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True

    def find_ancestor_of_set(self, x): 
        return self.ancestor[self.find_set(x)]

    def update_ancestor_of_set(self, x): 
        self.ancestor[self.find_set(x)] = x


class TreeInfos(object): 
    def __init__(self, adj, pairs):
        def preprocess(u, p, w): 
            D[u] = 1 if p == -1 else D[p]+1
            if w != -1: 
                cnt[w] += 1
            CNT[u] = cnt[:] 

        def divide(u, p, w): 
            stk.append(partial(postprocess, u, w)) 
            for i in reversed(range(len(adj[u]))):
                v, nw = adj[u][i]
                if v == p:
                    continue
                stk.append(partial(conquer, v, u))
                stk.append(partial(divide, v, u, nw)) 
            stk.append(partial(preprocess, u, p, w)) 

        def conquer(u, p):
            uf.union_set(u, p)
            uf.update_ancestor_of_set(p)

        def postprocess(u, w): 
            lookup[u] = True
            for v in pairs[u]:
                if not lookup[v]:
                    continue
                lca[min(u, v), max(u, v)] = uf.find_ancestor_of_set(v)
            if w != -1: 
                cnt[w] -= 1

        N = len(adj)
        D, uf, lca = [0]*N, UnionFind(N), {}
        CNT = [[0]*MAX_W for _ in range(N)] 
        cnt = [0]*MAX_W 
        stk, lookup = [], [False]*N
        stk.append(partial(divide, 0, -1, -1)) 
        while stk:
            stk.pop()()
        self.D, self.lca = D, lca
        self.CNT = CNT 



MAX_W = 26
class Solution(object):
    def minOperationsQueries(self, n, edges, queries):
        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            w -= 1
            adj[u].append((v, w))
            adj[v].append((u, w))
        pairs = collections.defaultdict(set)
        for a, b in queries:
            pairs[a].add(b), pairs[b].add(a)
        tree_infos = TreeInfos(adj, pairs)
        result = [0]*len(queries)
        for i, (a, b) in enumerate(queries):
            lca = tree_infos.lca[min(a, b), max(a, b)]
            result[i] = (tree_infos.D[a]+tree_infos.D[b]-2*tree_infos.D[lca])-max(tree_infos.CNT[a][w]+tree_infos.CNT[b][w]-2*tree_infos.CNT[lca][w] for w in range(MAX_W))
        return result


",r * (n + q)
"import collections
from functools import partial




class TreeInfos2(object): 
    def __init__(self, adj): 
        def preprocess(u, p, w):
            D[u] = 1 if p == -1 else D[p]+1
            if p != -1:
                P[u].append(p)
            i = 0
            while i < len(P[u]) and i < len(P[P[u][i]]):
                P[u].append(P[P[u][i]][i])
                i += 1
            C[0] += 1
            L[u] = C[0]
            if w != -1: 
                cnt[w] += 1
            CNT[u] = cnt[:] 

        def divide(u, p, w): 
            stk.append(partial(postprocess, u, w)) 
            for i in reversed(range(len(adj[u]))):
                v, nw = adj[u][i]
                if v == p:
                    continue
                stk.append(partial(divide, v, u, nw)) 
            stk.append(partial(preprocess, u, p, w)) 

        def postprocess(u, w): 
            R[u] = C[0]
            if w != -1: 
                cnt[w] -= 1

        N = len(adj)
        L, R, D, P, C = [0]*N, [0]*N, [0]*N, [[] for _ in range(N)], [-1]
        CNT = [[0]*MAX_W for _ in range(N)] 
        cnt = [0]*MAX_W 
        stk = []
        stk.append(partial(divide, 0, -1, -1)) 
        while stk:
            stk.pop()()
        assert(C[0] == N-1)
        self.L, self.R, self.D, self.P = L, R, D, P
        self.CNT = CNT 

    def is_ancestor(self, a, b): 
        return self.L[a] <= self.L[b] <= self.R[b] <= self.R[a]

    def lca(self, a, b):
        if self.D[a] > self.D[b]:
            a, b = b, a
        if self.is_ancestor(a, b):
            return a
        for i in reversed(range(len(self.P[a]))): 
            if i < len(self.P[a]) and not self.is_ancestor(self.P[a][i], b):
                a = self.P[a][i]
        return self.P[a][0]



MAX_W = 26
class Solution2(object):
    def minOperationsQueries(self, n, edges, queries):
        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            w -= 1
            adj[u].append((v, w))
            adj[v].append((u, w))
        tree_infos = TreeInfos2(adj)
        result = [0]*len(queries)
        for i, (a, b) in enumerate(queries):
            lca = tree_infos.lca(a, b)
            result[i] = (tree_infos.D[a]+tree_infos.D[b]-2*tree_infos.D[lca])-max(tree_infos.CNT[a][w]+tree_infos.CNT[b][w]-2*tree_infos.CNT[lca][w] for w in range(MAX_W))
        return result
",r * (n + q) + nlogn + qlogn
"
class Solution(object):
    def myAtoi(self, str):
        INT_MAX =  2147483647
        INT_MIN = -2147483648
        result = 0

        if not str:
            return result

        i = 0
        while i < len(str) and str[i].isspace():
            i += 1

        if len(str) == i:
            return result

        sign = 1
        if str[i] == ""+"":
            i += 1
        elif str[i] == ""-"":
            sign = -1
            i += 1

        while i < len(str) and '0' <= str[i] <= '9':
            if result > (INT_MAX - int(str[i])) / 10:
                return INT_MAX if sign > 0 else INT_MIN
            result = result * 10 + int(str[i])
            i += 1

        return sign * result

",n
"
import pandas as pd



def Solution(employees: pd.DataFrame) -> pd.DataFrame:
    return employees.assign(bonus=2*employees[""salary""])
",n
"
import collections
import functools


class Solution(object):
    def minimumLengthEncoding(self, words):
        words = list(set(words))
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()

        nodes = [functools.reduce(dict.__getitem__, word[::-1], trie)
                 for word in words]

        return sum(len(word) + 1
                   for i, word in enumerate(words)
                   if len(nodes[i]) == 0)

",n
"
class Solution(object):
    def carFleet(self, target, position, speed):
        times = [float(target-p)/s for p, s in sorted(zip(position, speed))]
        result, curr = 0, 0
        for t in reversed(times):
            if t > curr:
                result += 1
                curr = t
        return result

",nlogn
"
import collections


class Solution(object):
    def countPoints(self, rings):
        bits = {'R':0b001, 'G':0b010, 'B':0b100}
        rods = collections.defaultdict(int)
        for i in range(0, len(rings), 2):
            rods[int(rings[i+1])] |= bits[rings[i]]
        return sum(x == 0b111 for x in rods.values())
",n
"

class Solution(object):
    def minFlips(self, grid):
        m, n = len(grid), len(grid[0])
        result = 0
        for i in range(m//2):
            for j in range(n//2):
                c = grid[i][j]+grid[i][~j]+grid[~i][j]+grid[~i][~j]
                result += min(c, 4-c)
        diff = cnt1 = 0
        if m%2:
            for j in range(n//2):
                diff += grid[m//2][j]^grid[m//2][~j]
                cnt1 += grid[m//2][j]+grid[m//2][~j]
        if n%2:
            for i in range(m//2):
                diff += grid[i][n//2]^grid[~i][n//2]
                cnt1 += grid[i][n//2]+grid[~i][n//2]
        if m%2 and n%2:
            result += grid[m//2][n//2]
        if diff == 0:
            result += (-cnt1)%4
        return result+diff
",m * n
"

class Solution(object):
    def countServers(self, n, logs, x, queries):
        logs.sort(key=lambda x:x[1])
        result = [0]*len(queries)
        cnt = [0]*n
        curr = left = right = 0
        for t, i in sorted((t, i) for i, t in enumerate(queries)):
            while right < len(logs) and logs[right][1] <= t:
                if cnt[logs[right][0]-1] == 0:
                    curr += 1
                cnt[logs[right][0]-1] += 1
                right += 1
            while left < right and logs[left][1] < t-x:
                cnt[logs[left][0]-1] -= 1
                if cnt[logs[left][0]-1] == 0:
                    curr -= 1
                left += 1
            result[i] = n-curr
        return result


",nlogn + mlogm
"
class Solution2(object):
    def countServers(self, n, logs, x, queries):
        events = []
        for sid, t in logs:
            events.append((t, +1, sid-1))
            events.append((t+x+1, -1, sid-1))
        events.append((float(""inf""), 0, 0))
        events.sort()

        events2 = []
        for i, t in enumerate(queries):
            events2.append((t, i))
        events2.sort(reverse=True)

        result = [0]*len(queries)
        cnt = [0]*n
        curr = 0
        for t, c, i in events:
            while events2 and events2[-1][0] < t:                
                result[events2.pop()[1]] += n-curr
            if cnt[i] == 0:
                curr += 1
            cnt[i] += c
            if cnt[i] == 0:
                curr -= 1
        return result
",nlogn + mlogm
"
class Solution(object):
    def findBottomLeftValue(self, root):
        def findBottomLeftValueHelper(root, curr_depth, max_depth, bottom_left_value):
            if not root:
                return max_depth, bottom_left_value
            if not root.left and not root.right and curr_depth+1 > max_depth:
                return curr_depth+1, root.val
            max_depth, bottom_left_value = findBottomLeftValueHelper(root.left, curr_depth+1, max_depth, bottom_left_value)
            max_depth, bottom_left_value = findBottomLeftValueHelper(root.right, curr_depth+1, max_depth, bottom_left_value)
            return max_depth, bottom_left_value

        result, max_depth = 0, 0
        return findBottomLeftValueHelper(root, 0, max_depth, result)[1]


",n
"import collections


class Solution2(object):
    def findBottomLeftValue(self, root):
        last_node, q = None, collections.deque([root])
        while q:
            last_node = q.popleft()
            q.extend([n for n in [last_node.right, last_node.left] if n])
        return last_node.val

",n
"
class Solution(object):
    def combine(self, n, k):
        if k > n:
            return []
        nums, idxs = list(range(1, n+1)), list(range(k))
        result = [[nums[i] for i in idxs]]
        while True:
            for i in reversed(range(k)):
                if idxs[i] != i+n-k:
                    break
            else:
                break
            idxs[i] += 1
            for j in range(i+1, k):
                idxs[j] = idxs[j-1]+1
            result.append([nums[i] for i in idxs])
        return result


","k * C(n, k)"
"class Solution2(object):
    def combine(self, n, k):
        result, combination = [], []
        i = 1
        while True:
            if len(combination) == k:
                result.append(combination[:])
            if len(combination) == k or \
               len(combination)+(n-i+1) < k:
                if not combination:
                    break
                i = combination.pop()+1
            else:
                combination.append(i)
                i += 1
        return result


","k * C(n, k)"
"class Solution3(object):
    def combine(self, n, k):
        def combineDFS(n, start, intermediate, k, result):
            if k == 0:
                result.append(intermediate[:])
                return
            for i in range(start, n):
                intermediate.append(i+1)
                combineDFS(n, i+1, intermediate, k-1, result)
                intermediate.pop()

        result = []
        combineDFS(n, 0, [], k, result)
        return result


","k * C(n, k)"
"

class Node(object):
    def __init__(self, val, left, right, parent):
        self.val = val
        self.left = left
        self.right = right
        self.parent = parent

        
class Solution(object):
    def inorderSuccessor(self, node):
        if not node:
            return None
        
        if node.right:
            node = node.right
            while node.left:
                node = node.left
            return node
        
        while node.parent and node.parent.right is node:
            node = node.parent
        return node.parent
",h
"
import collections



class Solution(object):
    def queryResults(self, limit, queries):
        result = [0]*len(queries)
        lookup = {}
        cnt = collections.Counter()
        for i, (x, y) in enumerate(queries):
            if x in lookup:
                cnt[lookup[x]] -= 1
                if not cnt[lookup[x]]:
                    del cnt[lookup[x]]
            lookup[x] = y
            cnt[lookup[x]] += 1
            result[i] = len(cnt)
        return result
",q
"
import collections


class Solution(object):
    def brightestPosition(self, lights):
        count = collections.Counter()
        for i, r in lights:
            count[i-r] += 1
            count[i+r+1] -= 1
        result = None
        max_cnt = cnt = 0
        for i, c in sorted(count.items()):
            cnt += c
            if cnt > max_cnt:
                max_cnt, result = cnt, i
        return result
",nlogn
"
class Solution(object):
    def shipWithinDays(self, weights, D):
        def possible(weights, D, mid):
            result, curr = 1, 0
            for w in weights:
                if curr+w > mid:
                    result += 1
                    curr = 0
                curr += w
            return result <= D
    
        left, right = max(weights), sum(weights)
        while left <= right:
            mid = left + (right-left)//2
            if possible(weights, D, mid):
                right = mid-1
            else:
                left = mid+1
        return left
",nlogr
"

class Solution(object):
    def longestPalindrome(self, s, t):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        def longest_palindrome(s):
            result = [0]*(len(s)+1)
            P = manacher(s)
            for i in range(1, len(P)-1):
                result[(i-P[i])//2] = P[i]
            return result

        t = t[::-1]
        p1 = longest_palindrome(s)
        p2 = longest_palindrome(t)
        result = 0
        dp = [[0]*(len(t)+1) for _ in range(len(s)+1)]
        for i in range(len(s)):
            for j in range(len(t)):
                dp[i+1][j+1] = dp[i][j]+2 if s[i] == t[j] else 0
                result = max(result, dp[i+1][j+1]+max(p1[i+int(s[i] == t[j])] , p2[j+int(s[i] == t[j])]))
        return result
",n * m
"
import heapq



class Solution(object):
    def findMaxSum(self, nums1, nums2, k):
        result = [0]*len(nums1)
        min_heap = []
        idxs = list(range(len(nums1)))
        idxs.sort(key=lambda x: nums1[x])
        total = j = 0
        for i in range(len(idxs)):
            while nums1[idxs[j]] < nums1[idxs[i]]:
                total += nums2[idxs[j]]
                heapq.heappush(min_heap, nums2[idxs[j]])
                if len(min_heap) == k+1:
                    total -= heapq.heappop(min_heap)
                j += 1
            result[idxs[i]] = total            
        return result
",nlogn
"
class Solution(object):
    def splitString(self, s):
        def backtracking(s, i, num, cnt):
            if i == len(s):
                return cnt >= 2
            new_num = 0
            for j in range(i, len(s)):
                new_num = new_num*10 + int(s[j])
                if new_num >= num >= 0:
                    break
                if (num == -1 or num-1 == new_num) and backtracking(s, j+1, new_num, cnt+1):
                    return True
            return False
            
        return backtracking(s, 0, -1, 0)
",n^2
"

class Solution(object):
    def countDaysTogether(self, arriveAlice, leaveAlice, arriveBob, leaveBob):
        NUMS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        prefix = [0]*(len(NUMS)+1)
        for i in range(len(NUMS)):
            prefix[i+1] += prefix[i]+NUMS[i]
    
        def day(date):
            return prefix[int(date[:2])-1]+int(date[3:])

        return max(day(min(leaveAlice, leaveBob))-day(max(arriveAlice, arriveBob))+1, 0)
",1
"

class Solution(object):
    def countPairs(self, nums, target):
        nums.sort()
        result = 0
        left, right = 0, len(nums)-1
        while left < right:
            if nums[left]+nums[right] < target:
                result += right-left
                left += 1
            else:
                right -= 1
        return result
",nlogn
"
class Solution(object):
    def findSmallestSetOfVertices(self, n, edges):
        result = []
        lookup = set()
        for u, v in edges:
            lookup.add(v)
        for i in range(n):
            if i not in lookup:
                result.append(i)
        return result
",e
"
class Solution(object):
    def checkPowersOfThree(self, n):
        while n > 0:
            if n%3 == 2:
                return False
            n //= 3
        return True
",logn
"
class Solution(object):
    def gameOfLife(self, board):
        m = len(board)
        n = len(board[0]) if m else 0
        for i in range(m):
            for j in range(n):
                count = 0
                for I in range(max(i-1, 0), min(i+2, m)):
                    for J in range(max(j-1, 0), min(j+2, n)):
                        count += board[I][J] & 1

                if (count == 4 and board[i][j]) or count == 3:
                    board[i][j] |= 2 

        for i in range(m):
            for j in range(n):
                board[i][j] >>= 1 

",m * n
"
class Solution(object):
    def maximumBinaryString(self, binary):
        result = list(binary)
        zeros = ones = 0
        for i, c in enumerate(result):
            if c == '0':
                zeros += 1
            elif zeros == 0:
                ones += 1
            result[i] = '1'
        if ones != len(result):
            result[zeros+ones-1] = '0'
        return """".join(result)
",n
"

class Solution(object):
    def minCost(self, grid):
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        def a_star(grid, b, t):
            f, dh = 0, 1
            closer, detour = [b], []
            lookup = set()
            while closer or detour:
                if not closer:
                    f += dh
                    closer, detour = detour, closer
                b = closer.pop()
                if b in lookup:
                    continue
                lookup.add(b)
                if b == t:
                    return f
                for nd, (dr, dc) in enumerate(directions, 1):
                    nb = (b[0]+dr, b[1]+dc)
                    if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and nb not in lookup):
                        continue
                    (closer if nd == grid[b[0]][b[1]] else detour).append(nb)
            return -1

        return a_star(grid, (0, 0), (len(grid)-1, len(grid[0])-1))


",m * n
"import collections



class Solution2(object):
    def minCost(self, grid):
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        b, t = (0, 0), (len(grid)-1, len(grid[0])-1)
        dq = collections.deque([(b, 0)])
        lookup = set()
        while dq:
            b, d = dq.popleft()
            if b in lookup:
                continue
            lookup.add(b)
            if b == t:
                return d
            for nd, (dr, dc) in enumerate(directions, 1):
                nb = (b[0]+dr, b[1]+dc)
                if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and nb not in lookup):
                    continue
                if nd == grid[b[0]][b[1]]:
                    dq.appendleft((nb, d))
                else:
                    dq.append((nb, d+1))
        return -1 
",m * n
"
class Solution(object):
    def getCollisionTimes(self, cars):
        stk = []
        result = [-1.0]*len(cars)
        for i in reversed(range(len(cars))):
            p, s = cars[i]
            while stk and (cars[stk[-1]][1] >= s or 
                           0 < result[stk[-1]] <= float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])):
                stk.pop()
            if stk:
                result[i] = float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])
            stk.append(i)
        return result
",n
"
class GridMaster(object):
    def canMove(self, direction):
        pass

    def move(self, direction):
        pass

    def isTarget(self):
        pass


import collections


class Solution(object):
    def findShortestPath(self, master):
        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}
        rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}

        def dfs(pos, target, master, lookup, adj):
            if target[0] is None and master.isTarget():
                target[0] = pos
            lookup.add(pos)
            for d, (di, dj) in directions.items():
                if not master.canMove(d):
                    continue
                nei = (pos[0]+di, pos[1]+dj)
                adj[pos].add(nei)
                adj[nei].add(pos)
                if nei in lookup:
                    continue
                master.move(d)
                dfs(nei, target, master, lookup, adj)
                master.move(rollback[d])
                        
        def bi_bfs(adj, start, target):
            left, right = {start}, {target}
            lookup = set()
            steps = 0
            while left:
                for pos in left:
                    lookup.add(pos)
                new_left = set()
                for pos in left:
                    if pos in right: 
                        return steps
                    for nei in adj[pos]:
                        if nei in lookup:
                            continue
                        new_left.add(nei)
                left = new_left
                steps += 1
                if len(left) > len(right): 
                    left, right = right, left
            return -1         
        
        start = (0, 0)
        target = [None]
        adj = collections.defaultdict(set)
        dfs(start, target, master, set(), adj)
        if not target[0]:
            return -1
        return bi_bfs(adj, start, target[0])


",m * n
"class Solution2(object):
    def findShortestPath(self, master):
        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}
        rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}

        def dfs(pos, target, master, lookup, adj):
            if target[0] is None and master.isTarget():
                target[0] = pos
            lookup.add(pos)
            for d, (di, dj) in directions.items():
                if not master.canMove(d):
                    continue
                nei = (pos[0]+di, pos[1]+dj)
                adj[pos].add(nei)
                adj[nei].add(pos)
                if nei in lookup:
                    continue
                master.move(d)
                dfs(nei, target, master, lookup, adj)
                master.move(rollback[d])
                        
        def bfs(adj, start, target):
            q = [start]
            lookup = set(q)
            steps = 0
            while q:
                new_q = []
                for pos in q:
                    if pos == target:
                        return steps
                    for nei in adj[pos]:
                        if nei in lookup:
                            continue
                        lookup.add(nei)
                        new_q.append(nei)
                q = new_q
                steps += 1
            return -1  
        
        start = (0, 0)
        target = [None]
        adj = collections.defaultdict(set)
        dfs(start, target, master, set(), adj)
        if not target[0]:
            return -1
        return bfs(adj, start, target[0])
",m * n
"
class Solution(object):

    def __init__(self):
        self.__s = []

    def next(self, price):
        result = 1
        while self.__s and self.__s[-1][0] <= price:
            result += self.__s.pop()[1]
        self.__s.append([price, result])
        return result



",n
"
import collections


class Solution(object):
    def commonChars(self, A):
        result = collections.Counter(A[0])
        for a in A:
            result &= collections.Counter(a)
        return list(result.elements())
",n * l
"

class Solution(object):
    def goodIndices(self, nums, k):
        left = [1]*len(nums)
        for i in range(1, len(nums)-1):
            if nums[i] <= nums[i-1]:
                left[i] = left[i-1]+1
        right = [1]*len(nums)
        for i in reversed(range(1, len(nums)-1)):
            if nums[i] <= nums[i+1]:
                right[i] = right[i+1]+1
        return [i for i in range(k, len(nums)-k) if min(left[i-1], right[i+1]) >= k]
",n
"

class Interval(object):
    def __init__(self, s=0, e=0):
        self.start = s
        self.end = e


class Solution(object):
    def intervalIntersection(self, A, B):
        result = []
        i, j = 0, 0
        while i < len(A) and j < len(B):
            left = max(A[i].start, B[j].start)
            right = min(A[i].end, B[j].end)
            if left <= right:
                result.append(Interval(left, right))
            if A[i].end < B[j].end:
                i += 1
            else:
                j += 1
        return result
",m + n
"
class Solution(object):
    def lexicalOrder(self, n):
        result = []

        i = 1
        while len(result) < n:
            k = 0
            while i * 10**k <= n:
                result.append(i * 10**k)
                k += 1

            num = result[-1] + 1
            while num <= n and num % 10:
                result.append(num)
                num += 1

            if not num % 10:
                num -= 1
            else:
                num /= 10

            while num % 10 == 9:
                num /= 10

            i = num+1

        return result

",n
"
class Solution(object):
    def smallestSubsequence(self, s, k, letter, repetition):
        stk = []
        suffix = [0]*(len(s)+1)
        for i in reversed(range(len(suffix)-1)):
            suffix[i] = suffix[i+1]+(s[i] == letter)
        for i, c in enumerate(s): 
            while stk and stk[-1] > c and len(stk)+(len(s)-i) > k and (stk[-1] != letter or repetition+1 <= suffix[i]):
                repetition += (stk.pop() == letter)
            if len(stk) < min(k-(repetition-(c == letter)), k):
                repetition -= (c == letter)
                stk.append(c)
        return """".join(stk)
",n
"

class Solution(object):
    def magnificentSets(self, n, edges):
        def iter_dfs(u):
            group = []
            stk = [u]
            lookup[u] = 0
            while stk:
                u = stk.pop()
                group.append(u)
                for v in adj[u]:
                    if lookup[v] != -1:
                        if lookup[v] == lookup[u]: 
                            return []
                        continue
                    lookup[v] = lookup[u]^1
                    stk.append(v)
            return group

        def bfs(u):
            result = 0
            lookup = [False]*n
            q = [u]
            lookup[u] = True
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
                result += 1
            return result
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        result = 0
        lookup = [-1]*n
        for u in range(n):
            if lookup[u] != -1:
                continue
            group = iter_dfs(u)
            if not group:
                return -1
            result += max(bfs(u) for u in group)
        return result


",n^2
"
class Solution2(object):
    def magnificentSets(self, n, edges):
        def bfs(u):
            group = []
            q = {u}
            lookup[u] = True
            while q:
                new_q = set()
                for u in q:
                    group.append(u)
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.add(v)
                q = new_q
            return group
    
        def bfs2(u):
            result = 0
            lookup = [False]*n
            q = {u}
            lookup[u] = True
            while q:
                new_q = set()
                for u in q:
                    for v in adj[u]:
                        if v in q:
                            return 0
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.add(v)
                q = new_q
                result += 1
            return result
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        result = 0
        lookup = [0]*n
        for u in range(n):
            if lookup[u]:
                continue
            group = bfs(u)
            mx = 0
            for u in group:
                d = bfs2(u)
                if d == 0:
                    return -1
                mx = max(mx, d)
            result += mx
        return result
",n^2
"
class Solution(object):
    def consecutiveNumbersSum(self, N):
        result = 1
        while N % 2 == 0:
            N /= 2
        i = 3
        while i*i <= N:
            count = 0
            while N % i == 0:
                N /= i
                count += 1
            result *= count+1
            i += 2
        if N != 1: 
            result *= 1+1
        return result

",sqrt(n)
"
import math


class Solution(object):
    def reachNumber(self, target):
        target = abs(target)
        k = int(math.ceil((-1+math.sqrt(1+8*target))/2))
        target -= k*(k+1)/2
        return k if target%2 == 0 else k+1+k%2


",logn
"class Solution2(object):
    def reachNumber(self, target):
        target = abs(target)
        k = 0
        while target > 0:
            k += 1
            target -= k
        return k if target%2 == 0 else k+1+k%2

",sqrt(n)
"

class Solution(object):
    def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k):
        return min(numOnes, k)-max(k-numOnes-numZeros, 0)
",1
"

   def hasShips(self, topRight, bottomLeft):
       pass

class Point(object):
	def __init__(self, x, y):
		self.x = x
		self.y = y

class Solution(object):
    def countShips(self, sea, topRight, bottomLeft):
        result = 0
        if topRight.x >= bottomLeft.x and \
           topRight.y >= bottomLeft.y and \
           sea.hasShips(topRight, bottomLeft):
            if (topRight.x, topRight.y) == (bottomLeft.x, bottomLeft.y):
                return 1
            mid_x, mid_y = (topRight.x+bottomLeft.x)//2, (topRight.y+bottomLeft.y)//2
            result += self.countShips(sea, topRight, Point(mid_x+1, mid_y+1))
            result += self.countShips(sea, Point(mid_x, topRight.y), Point(bottomLeft.x, mid_y+1))
            result += self.countShips(sea, Point(topRight.x, mid_y), Point(mid_x+1, bottomLeft.y))
            result += self.countShips(sea, Point(mid_x, mid_y), bottomLeft)
        return result
",s * log(m * n)
"
import collections


class Solution(object):
    def findFrequentTreeSum(self, root):
        def countSubtreeSumHelper(root, counts):
            if not root:
                return 0
            total = root.val + \
                    countSubtreeSumHelper(root.left, counts) + \
                    countSubtreeSumHelper(root.right, counts)
            counts[total] += 1
            return total

        counts = collections.defaultdict(int)
        countSubtreeSumHelper(root, counts)
        max_count = max(counts.values()) if counts else 0
        return [total for total, count in counts.items() if count == max_count]

",n
"
class Solution(object):
    def generateTheString(self, n):
        result = ['a']*(n-1)
        result.append('a' if n%2 else 'b')
        return """".join(result)
",n
"
class Solution(object):
    def checkZeroOnes(self, s):
        max_cnt = [0]*2
        cnt = 0
        for i in range(len(s)+1):
            if i == len(s) or (i >= 1 and s[i] != s[i-1]):
                max_cnt[int(s[i-1])] = max(max_cnt[int(s[i-1])], cnt)
                cnt = 0
            cnt += 1
        return max_cnt[0] < max_cnt[1]
",n
"

class Solution(object):
    def connectTwoGroups(self, cost):
        total = 2**len(cost[0])
        dp = [[float(""inf"")]*total for _ in range(2)]
        dp[0][0] = 0
        for i in range(len(cost)):
            dp[(i+1)%2] = [float(""inf"")]*total
            for mask in range(total):
                base = 1
                for j in range(len(cost[0])):
                    dp[i%2][mask|base] = min(dp[i%2][mask|base], cost[i][j]+dp[i%2][mask])
                    dp[(i+1)%2][mask|base] = min(dp[(i+1)%2][mask|base], cost[i][j]+dp[i%2][mask])
                    base <<= 1
        return dp[len(cost)%2][-1]
",m * n * 2^n
"
class Node(object):
    def __init__(self, value):
        self.val = value
        self.next = self.prev = None


class Solution(object):

    def __init__(self):
        self.__head = self.__tail = Node(-1)
        self.__head.next = self.__tail
        self.__tail.prev = self.__head
        self.__size = 0

    def get(self, index):
        if 0 <= index <= self.__size // 2:
            return self.__forward(0, index, self.__head.__next__).val
        elif self.__size // 2 < index < self.__size:
            return self.__backward(self.__size, index, self.__tail).val
        return -1

    def addAtHead(self, val):
        self.__add(self.__head, val)

    def addAtTail(self, val):
        self.__add(self.__tail.prev, val)

    def addAtIndex(self, index, val):
        if 0 <= index <= self.__size // 2:
            self.__add(self.__forward(0, index, self.__head.__next__).prev, val)
        elif self.__size // 2 < index <= self.__size:
            self.__add(self.__backward(self.__size, index, self.__tail).prev, val)

    def deleteAtIndex(self, index):
        if 0 <= index <= self.__size // 2:
            self.__remove(self.__forward(0, index, self.__head.__next__))
        elif self.__size // 2 < index < self.__size:
            self.__remove(self.__backward(self.__size, index, self.__tail))

    def __add(self, preNode, val):
        node = Node(val)
        node.prev = preNode
        node.next = preNode.__next__
        node.prev.next = node.next.prev = node
        self.__size += 1
        
    def __remove(self, node):
        node.prev.next = node.__next__
        node.next.prev = node.prev
        self.__size -= 1
        
    def __forward(self, start, end, curr):
        while start != end:
            start += 1
            curr = curr.__next__
        return curr
    
    def __backward(self, start, end, curr):
        while start != end:
            start -= 1
            curr = curr.prev
        return curr



",n
"
class Solution(object):
    def findAllConcatenatedWordsInADict(self, words):
        lookup = set(words)
        result = []
        for word in words:
            dp = [False] * (len(word)+1)
            dp[0] = True
            for i in range(len(word)):
                if not dp[i]:
                    continue

                for j in range(i+1, len(word)+1):
                    if j - i < len(word) and word[i:j] in lookup:
                        dp[j] = True

                if dp[len(word)]:
                    result.append(word)
                    break

        return result

",n * l^2
"

class Solution(object):
    def numberOfPowerfulInt(self, start, finish, limit, s):
        def count(x):
            def length(x):
                result = 0
                while x:
                    x //= 10
                    result += 1
                return result

            result = 0
            n = length(x)
            base = 10**n
            l = n-len(s)
            cnt = (limit+1)**l
            for i in range(l):
                base //= 10
                curr = x//base%10
                cnt //= limit+1
                result += (min(curr-1, limit)-0+1)*cnt
                if curr > limit:
                    break
            else:
                if x%base >= int(s):
                    result += 1
            return result

        return count(finish)-count(start-1)


",logf
"
class Solution2(object):
    def numberOfPowerfulInt(self, start, finish, limit, s):
        def count(x):
            result = 0
            str_x = str(x)
            l = len(str_x)-len(s)
            cnt = (limit+1)**l
            for i in range(l):
                cnt //= limit+1
                result += (min(int(str_x[i])-1, limit)-0+1)*cnt
                if int(str_x[i]) > limit:
                    break
            else:
                if int(str_x[-len(s):]) >= int(s):
                    result += 1
            return result

        return count(finish)-count(start-1)
",logf
"
class Solution(object):

    def __init__(self, k):
        self.__start = 0
        self.__size = 0
        self.__buffer = [0] * k

    def enQueue(self, value):
        if self.isFull():
            return False
        self.__buffer[(self.__start+self.__size) % len(self.__buffer)] = value
        self.__size += 1
        return True

    def deQueue(self):
        if self.isEmpty():
            return False
        self.__start = (self.__start+1) % len(self.__buffer)
        self.__size -= 1
        return True

    def Front(self):
        return -1 if self.isEmpty() else self.__buffer[self.__start]

    def Rear(self):
        return -1 if self.isEmpty() else self.__buffer[(self.__start+self.__size-1) % len(self.__buffer)]

    def isEmpty(self):
        return self.__size == 0

    def isFull(self):
        return self.__size == len(self.__buffer)



",1
"

class Solution(object):
    def captureForts(self, forts):
        result = left = 0
        for right in range(len(forts)):
            if not forts[right]:
                continue
            if forts[right] == -forts[left]:
                result = max(result, right-left-1)
            left = right
        return result
",n
"
from sortedcontainers import SortedList



class Solution(object):
    def resultArray(self, nums):
        sl1, sl2 = SortedList([nums[0]]), SortedList([nums[1]])
        a, b = [nums[0]], [nums[1]]
        for i in range(2, len(nums)):
            cnt1 = len(sl1)-sl1.bisect_right(nums[i])
            cnt2 = len(sl2)-sl2.bisect_right(nums[i])
            if cnt1 > cnt2 or (cnt1 == cnt2 and len(a) <= len(b)):
                sl1.add(nums[i])
                a.append(nums[i])
            else:
                sl2.add(nums[i])
                b.append(nums[i])
        return a+b
",nlogn
"

class Solution(object):
    def maxSubarrayLength(self, nums):
        stk = []
        for i in reversed(range(len(nums))):
            if not stk or nums[stk[-1]] > nums[i]:
                stk.append(i)
        result = 0
        for left in range(len(nums)):
            while stk and nums[stk[-1]] < nums[left]:
                result = max(result, stk.pop()-left+1)
        return result


",n
"
class Solution2(object):
    def maxSubarrayLength(self, nums):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x], reverse=True)
        result = 0
        for left in range(len(nums)):
            while idxs and nums[idxs[-1]] < nums[left]:
                result = max(result, idxs.pop()-left+1)
        return result
",nlogn
"

class Solution(object):
    def numberOfPairs(self, points):
        points.sort(key=lambda x: (x[0], -x[1]))
        result = 0
        for i in range(len(points)):
            y = float(""-inf"")
            for j in range(i+1, len(points)):
                if points[i][1] < points[j][1]:
                    continue
                if points[j][1] > y:
                    y = points[j][1]
                    result += 1
        return result


",n^2
"
class Solution2(object):
    def numberOfPairs(self, points):
        points.sort(key=lambda x: (x[0], -x[1]))
        return sum(all(not points[i][1] >= points[k][1] >= points[j][1] for k in range(i+1, j))
                   for i in range(len(points))
                   for j in range(i+1, len(points)) if points[i][1] >= points[j][1])
 
",n^3
"

class Solution(object):
    def isBalanced(self, num):
        return sum(ord(num[i])-ord('0') for i in range(0, len(num), 2)) == sum(ord(num[i])-ord('0') for i in range(1, len(num), 2))
",n
"

class Solution(object):
    def minimumOperations(self, nums, target):
        for i in range(len(target)):
            target[i] -= nums[i]
        return sum(max((target[i] if i < len(target) else 0)-(target[i-1] if i-1 >= 0 else 0), 0) for i in range(len(target)+1))
",n
"
class Solution(object):
    def smallestRangeII(self, A, K):
        A.sort()
        result = A[-1]-A[0]
        for i in range(len(A)-1):
            result = min(result,
                         max(A[-1]-K, A[i]+K) -
                         min(A[0]+K, A[i+1]-K))
        return result

",nlogn
"
import collections


class Solution(object):

    def __init__(self):
        _trie = lambda: collections.defaultdict(_trie)
        self.trie = _trie()


    def buildDict(self, dictionary):
        for word in dictionary:
            reduce(dict.__getitem__, word, self.trie).setdefault(""_end"")


    def search(self, word):
        def find(word, curr, i, mistakeAllowed):
            if i == len(word):
                return ""_end"" in curr and not mistakeAllowed

            if word[i] not in curr:
                return any(find(word, curr[c], i+1, False) for c in curr if c != ""_end"") \
                           if mistakeAllowed else False

            if mistakeAllowed:
                return find(word, curr[word[i]], i+1, True) or \
                       any(find(word, curr[c], i+1, False) \
                           for c in curr if c not in (""_end"", word[i]))
            return find(word, curr[word[i]], i+1, False)

        return find(word, self.trie, 0, True)




",n
"

class BigArray:
    def at(self, index):
        pass
    def size(self):
        pass



class Solution(object):
    def countBlocks(self, nums):
        def binary_search_right(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right

        n = nums.size()
        result = left = 0
        while left != n:
            target = nums.at(left)
            left = binary_search_right(left, n-1, lambda x: nums.at(x) == target)+1
            result += 1
        return result
",klogn
"
class Solution(object):
    def peakIndexInMountainArray(self, arr):
        left, right = 0, len(arr)-1
        while left <= right:
            mid = left + (right-left)//2
            if arr[mid] > arr[mid+1]:
                right = mid-1
            else:
                left = mid+1
        return left

",logn
"
class Solution(object):
    def minCost(self, s, cost):
        result = accu = max_cost = 0
        for i in range(len(s)):
            if i and s[i] != s[i-1]:
                result += accu-max_cost
                accu = max_cost = 0
            accu += cost[i]
            max_cost = max(max_cost, cost[i])
        result += accu-max_cost
        return result
",n
"
class Solution(object):
    def numSpecial(self, mat):
        rows, cols = [0]*len(mat), [0]*len(mat[0])
        for i in range(len(rows)):
            for j in range(len(cols)):
                if mat[i][j]:
                    rows[i] += 1
                    cols[j] += 1
        result = 0
        for i in range(len(rows)):
            for j in range(len(cols)):
                if mat[i][j] == rows[i] == cols[j] == 1:
                    result += 1
        return result
",n^2
"

class Solution(object):
    def findColumnWidth(self, grid):
        def length(x):
            l = 1
            if x < 0:
                x = -x
                l += 1
            while x >= 10:
                x //= 10
                l += 1
            return l

        return [max(length(grid[i][j]) for i in range(len(grid))) for j in range(len(grid[0]))]


",m * n
"
class Solution2(object):
    def findColumnWidth(self, grid):
        return [max(len(str(grid[i][j])) for i in range(len(grid))) for j in range(len(grid[0]))]


",m * n
"import itertools



class Solution3(object):
    def findColumnWidth(self, grid):
        return [max(len(str(x)) for x in col) for col in zip(*grid)]
",m * n
"

class Solution(object):
    def colorRed(self, n):
        result = [[1, 1]]
        for i in range(2, n+1):
            if i%2 == n%2:
                result.extend([i, j] for j in range((1 if i%4 == n%4 else 3), 2*i, 2))
            else:
                result.append([i, (2 if i%4 == (n-1)%4 else 1)])
        return result
",n^2
"

class Solution(object):
    def maxProductPath(self, grid):
        MOD = 10**9+7
        max_dp = [[0]*len(grid[0]) for _ in range(2)]
        min_dp = [[0]*len(grid[0]) for _ in range(2)]
        for i in range(len(grid)):
            for j in range(len(grid[i])):
                if i == 0 and j == 0:
                    max_dp[i%2][j] = min_dp[i%2][j] = grid[i][j]
                    continue
                curr_max = max(max_dp[(i-1)%2][j] if i > 0 else max_dp[i%2][j-1],
                               max_dp[i%2][j-1] if j > 0 else max_dp[(i-1)%2][j])
                curr_min = min(min_dp[(i-1)%2][j] if i > 0 else min_dp[i%2][j-1],
                               min_dp[i%2][j-1] if j > 0 else min_dp[(i-1)%2][j])
                if grid[i][j] < 0:
                    curr_max, curr_min = curr_min, curr_max
                max_dp[i%2][j] = curr_max*grid[i][j]
                min_dp[i%2][j] = curr_min*grid[i][j]
        return max_dp[(len(grid)-1)%2][-1]%MOD if max_dp[(len(grid)-1)%2][-1] >= 0 else -1
",m * n
"
class Solution(object):
    def hIndex(self, citations):
        n = len(citations)
        count = [0] * (n + 1)
        for x in citations:
            if x >= n:
                count[n] += 1
            else:
                count[x] += 1

        h = 0
        for i in reversed(range(0, n + 1)):
            h += count[i]
            if h >= i:
                return i
        return h

",n
"class Solution2(object):
    def hIndex(self, citations):
        citations.sort(reverse=True)
        h = 0
        for x in citations:
            if x >= h + 1:
                h += 1
            else:
                break
        return h

",nlogn
"class Solution3(object):
    def hIndex(self, citations):
        return sum(x >= i + 1 for i, x in enumerate(sorted(citations, reverse=True)))


",nlogn
"
class Solution(object):
    def canBeValid(self, s, locked):
        if len(s)%2:
            return False
        for direction, c in ((lambda x:x, '('), (reversed, ')')):
            cnt = bal = 0
            for i in direction(range(len(s))):
                if locked[i] == '0':
                    cnt += 1
                else:
                    bal += 1 if s[i] == c else -1
                    if cnt+bal < 0:
                        return False
        return True
",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def constructFromPrePost(self, pre, post):
        stack = [TreeNode(pre[0])]
        j = 0
        for i in range(1, len(pre)):
            node = TreeNode(pre[i])
            while stack[-1].val == post[j]:
                stack.pop()
                j += 1
            if not stack[-1].left:
                stack[-1].left = node
            else:
                stack[-1].right = node
            stack.append(node)
        return stack[0]


",n
"class Solution2(object):
    def constructFromPrePost(self, pre, post):
        def constructFromPrePostHelper(pre, pre_s, pre_e, post, post_s, post_e, post_entry_idx_map):
            if pre_s >= pre_e or post_s >= post_e:
                return None
            node = TreeNode(pre[pre_s])
            if pre_e-pre_s > 1:
                left_tree_size = post_entry_idx_map[pre[pre_s+1]]-post_s+1
                node.left = constructFromPrePostHelper(pre, pre_s+1, pre_s+1+left_tree_size, 
                                                       post, post_s, post_s+left_tree_size,
                                                       post_entry_idx_map)
                node.right = constructFromPrePostHelper(pre, pre_s+1+left_tree_size, pre_e,
                                                        post, post_s+left_tree_size, post_e-1,
                                                        post_entry_idx_map)
            return node

        post_entry_idx_map = {}
        for i, val in enumerate(post):
            post_entry_idx_map[val] = i
        return constructFromPrePostHelper(pre, 0, len(pre), post, 0, len(post), post_entry_idx_map)

",n
"
import itertools




class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda _: float(""inf""),
                 query_fn=lambda x, y: x if y is None else min(x, y),
                 update_fn=lambda x: x):
        self.tree = [None]*(2*2**((N-1).bit_length()))
        self.base = len(self.tree)//2
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

    def update(self, i, h):
        x = self.base+i
        self.tree[x] = self.update_fn(h)
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])



class Solution(object):
    def longestRepeating(self, s, queryCharacters, queryIndices):
        LEFT, RIGHT, LEFT_LEN, RIGHT_LEN, LEN, MAX_LEN, SIZE = range(7)
        def build(i):
            return update(s[i])

        def update(y):
            result = [0]*SIZE
            result[LEFT] = result[RIGHT] = y
            result[LEN] = result[LEFT_LEN] = result[RIGHT_LEN] = result[MAX_LEN] = 1
            return result

        def query(x, y):
            return x if y is None else \
                   [x[LEFT],
                    y[RIGHT],
                    x[LEFT_LEN]+(y[LEFT_LEN] if x[LEFT_LEN] == x[LEN] and x[RIGHT] == y[LEFT] else 0),
                    y[RIGHT_LEN]+(x[RIGHT_LEN] if y[RIGHT_LEN] == y[LEN] and y[LEFT] == x[RIGHT] else 0),
                    x[LEN]+y[LEN],
                    max(x[MAX_LEN], y[MAX_LEN], x[RIGHT_LEN]+y[LEFT_LEN] if x[RIGHT] == y[LEFT] else 0)]
        
        result = []
        st = SegmentTree(len(s), build_fn=build, query_fn=query, update_fn=update)
        for c, i in zip(queryCharacters, queryIndices):
            st.update(i, c)
            result.append(st.tree[1][MAX_LEN])
        return result


",nlogn
"import itertools




class SegmentTree2(object):
    def __init__(self, N,
                 build_fn=lambda _: float(""inf""),
                 query_fn=lambda x, y: y if x is None else x if y is None else min(x, y),
                 update_fn=lambda x: x):
        self.tree = [None]*(2*2**((N-1).bit_length()))
        self.base = len(self.tree)//2
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

    def update(self, i, h):
        x = self.base+i
        self.tree[x] = self.update_fn(h)
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

    def query(self, L, R):
        if L > R:
            return None
        L += self.base
        R += self.base
        left = right = None
        while L <= R:
            if L & 1:
                left = self.query_fn(left, self.tree[L])
                L += 1
            if R & 1 == 0:
                right = self.query_fn(self.tree[R], right)
                R -= 1
            L //= 2
            R //= 2
        return self.query_fn(left, right)



class Solution2(object):
    def longestRepeating(self, s, queryCharacters, queryIndices):
        LEFT, RIGHT, LEFT_LEN, RIGHT_LEN, LEN, MAX_LEN, SIZE = range(7)
        def build(i):
            return update(s[i])

        def update(y):
            result = [0]*SIZE
            result[LEN] = result[LEFT_LEN] = result[RIGHT_LEN] = result[MAX_LEN] = 1
            result[LEFT] = result[RIGHT] = y
            return result

        def query(x, y):
            return y if x is None else x if y is None else \
                   [x[LEFT],
                    y[RIGHT],
                    x[LEFT_LEN]+(y[LEFT_LEN] if x[LEFT_LEN] == x[LEN] and x[RIGHT] == y[LEFT] else 0),
                    y[RIGHT_LEN]+(x[RIGHT_LEN] if y[RIGHT_LEN] == y[LEN] and y[LEFT] == x[RIGHT] else 0),
                    x[LEN]+y[LEN],
                    max(x[MAX_LEN], y[MAX_LEN], x[RIGHT_LEN]+y[LEFT_LEN] if x[RIGHT] == y[LEFT] else 0)]
        
        result = []
        st = SegmentTree2(len(s), build_fn=build, query_fn=query, update_fn=update)
        for c, i in zip(queryCharacters, queryIndices):
            st.update(i, c)
            result.append(st.query(0, len(s)-1)[MAX_LEN])
        return result
",nlogn
"
class Solution(object):
    def numDifferentIntegers(self, word):
        result, num = set(), None
        for i in range(len(word)+1):
            c = word[i] if i < len(word) else ' '
            if c.isdigit():
                num = 10*num+int(c) if num is not None else int(c)
            elif num is not None:
                result.add(num)
                num = None
        return len(result)
",n
"
class Solution(object):
    def hasAlternatingBits(self, n):
        n, curr = divmod(n, 2)
        while n > 0:
            if curr == n % 2:
                return False
            n, curr = divmod(n, 2)
        return True

",1
"
import collections



class Solution(object):
    def countBlackBlocks(self, m, n, coordinates):
        L = 2

        cnt = collections.Counter()
        for x, y in coordinates:
            for nx in range(max(x-(L-1), 0), min(x+1, m-(L-1))):
                for ny in range(max(y-(L-1), 0), min(y+1, n-(L-1))):
                    cnt[nx, ny] += 1
        result = [0]*(L**2+1)
        for c in cnt.values():
            result[c] += 1
        result[0] = (m-(L-1))*(n-(L-1))-sum(result[i] for i in range(1, len(result)))
        return result
",c
"
class Solution(object):
    def PredictTheWinner(self, nums):
        if len(nums) % 2 == 0 or len(nums) == 1:
            return True

        dp = [0] * len(nums)
        for i in reversed(range(len(nums))):
            dp[i] = nums[i]
            for j in range(i+1, len(nums)):
                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1])

        return dp[-1] >= 0


",n^2
"
class Solution(object):
    def countSubIslands(self, grid1, grid2):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def dfs(grid1, grid2, i, j):
            if not (0 <= i < len(grid2) and
                    0 <= j < len(grid2[0]) and
                    grid2[i][j] == 1):
                return 1
            grid2[i][j] = 0
            result = grid1[i][j]
            for di, dj in directions:
                result &= dfs(grid1, grid2, i+di, j+dj)
            return result
            
        return sum(dfs(grid1, grid2, i, j) for i in range(len(grid2)) for j in range(len(grid2[0])) if grid2[i][j])
",m * n
"

class Solution(object):
    def minFlips(self, grid):
        def count(m, n, get):
            return sum(get(i, j) != get(i, ~j) for i in range(m) for j in range(n//2))

        m, n = len(grid), len(grid[0])
        return min(count(m, n, lambda i, j: grid[i][j]),
                   count(n, m, lambda i, j: grid[j][i]))
",m * n
"

class Solution(object):
    def isPreorder(self, nodes):
        stk = [nodes[0][0]]
        for i in range(1, len(nodes)):
            while stk and stk[-1] != nodes[i][1]:
                stk.pop()                
            if not stk:
                return False            
            stk.append(nodes[i][0])            
        return True
",n
"
class Solution(object):
    def containsPattern(self, arr, m, k):
        cnt = 0
        for i in range(len(arr)-m):
            if arr[i] != arr[i+m]:
                cnt = 0
                continue
            cnt += 1
            if cnt == (k-1)*m:
                return True
        return False
",n
"
class Solution(object):
    def waysToDistribute(self, n, k):
        MOD = 10**9+7
        dp = [1]*k
        for i in range(1, n):
            for j in reversed(range(1, min(i, k))):
                dp[j] = ((j+1)*dp[j] + dp[j-1]) % MOD
        return dp[k-1]
",n * k
"

class Solution(object):
    def pathExistenceQueries(self, n, nums, maxDiff, queries):
        def ceil_log2_x(x):
            return (x-1).bit_length() if x-1 >= 0 else -1

        sorted_i = sorted((i for i in range(n)), key=lambda i : nums[i])
        i_to_idx = [0]*n
        for idx, i in enumerate(sorted_i):
            i_to_idx[i] = idx
        prefix = [0]*n
        for i in range(n-1):
            prefix[i+1] = prefix[i]+int(nums[sorted_i[i+1]]-nums[sorted_i[i]] > maxDiff)
        P = [[n-1]*n for _ in range(ceil_log2_x(n-1)+1)]
        left = 0
        for right in range(n):
            while nums[sorted_i[right]]-nums[sorted_i[left]] > maxDiff:
                P[0][left] = right-1
                left += 1
        for i in range(len(P)-1):
            for j in range(n):
                P[i+1][j] = P[i][P[i][j]]
        result = [-1]*len(queries)
        for idx, (i, j) in enumerate(queries):
            if i == j:
                result[idx] = 0
                continue
            if prefix[i_to_idx[i]] != prefix[i_to_idx[j]]:
                continue
            if i_to_idx[i] > i_to_idx[j]:
                i, j = j, i
            curr, l = i_to_idx[i], 0
            for k in reversed(range(len(P))):
                if P[k][curr] < i_to_idx[j]:
                    curr = P[k][curr]
                    l += 1<<k
            result[idx] = l+1
        return result
",(n + q) * logn
"

class Solution(object):
    def numberOfCuts(self, n):
        return 0 if n == 1 else n if n%2 else n//2
",1
"
import collections


class Solution(object):
    def checkEqualTree(self, root):
        def getSumHelper(node, lookup):
            if not node:
                return 0
            total = node.val + \
                    getSumHelper(node.left, lookup) + \
                    getSumHelper(node.right, lookup)
            lookup[total] += 1
            return total

        lookup = collections.defaultdict(int)
        total = getSumHelper(root, lookup)
        if total == 0:
            return lookup[total] > 1
        return total%2 == 0 and (total/2) in lookup

",n
"

class Solution(object):
    def minProcessingTime(self, processorTime, tasks):
        K = 4
        processorTime.sort()
        tasks.sort(reverse=True)
        result = 0
        for i in range(len(processorTime)):
            for j in range(K):
                result = max(result, processorTime[i]+tasks[i*K+j])
        return result
",nlogn
"
class Solution(object):
    def canBeTypedWords(self, text, brokenLetters):
        lookup = set(brokenLetters)
        result, broken = 0, False
        for c in text:
            if c == ' ':
                result += int(broken == False)
                broken = False
            elif c in lookup:
                broken = True
        return result + int(broken == False)
",n
"

class Solution(object):
    def findMissingAndRepeatedValues(self, grid):
        n = len(grid)
        a_xor_b = 0
        for i in range(n**2):
            r, c = divmod(i, n)
            a_xor_b ^= grid[r][c]^(i+1)
        base = a_xor_b&-a_xor_b
        result = [0]*2
        for i in range(n**2):
            r, c = divmod(i, len(grid[0]))
            result[1 if (i+1)&base != 0 else 0] ^= i+1
            result[1 if grid[r][c]&base != 0 else 0] ^= grid[r][c]
        if any(x == result[1] for row in grid for x in row):
            result[0], result[1] = result[1], result[0]
        return result


",n^2
"import collections



class Solution2(object):
    def findMissingAndRepeatedValues(self, grid):
        cnt = collections.Counter(x for row in grid for x in row)
        return [next(k for k, v in cnt.items() if v == 2), next(x for x in range(1, len(grid)**2+1) if x not in cnt)]
",n^2
"
class Solution(object):
    def maxPoints(self, points):
        dp = points[0]
        for i in range(1, len(points)):
            prefix = [0]*len(points[i])
            prefix[0] = dp[0]
            for j in range(1, len(points[i])):
                prefix[j] = max(prefix[j-1], dp[j]+j)
            suffix = [0]*len(points[i])
            suffix[-1] = dp[-1]-(len(points[i])-1)
            for j in reversed(range(len(points[i])-1)):
                suffix[j] = max(suffix[j+1], dp[j]-j)
            new_dp = [0]*len(points[i])
            for j in range(len(points[i])):
                new_dp[j] = max(prefix[j]-j, suffix[j]+j)+points[i][j]
            dp = new_dp
        return max(dp)
",m * n
"
import collections


class Solution(object):
    def reformat(self, s):
        def char_gen(start, end, count):
            for c in range(ord(start), ord(end)+1):
                c = chr(c)
                for i in range(count[c]):
                    yield c
            yield ''
    
        count = collections.defaultdict(int)
        alpha_cnt = 0
        for c in s:
            count[c] += 1
            if c.isalpha():
                alpha_cnt += 1
        if abs(len(s)-2*alpha_cnt) > 1:
            return """"

        result = []
        it1, it2 = char_gen('a', 'z', count), char_gen('0', '9', count)
        if alpha_cnt < len(s)-alpha_cnt:
            it1, it2 = it2, it1
        while len(result) < len(s):
            result.append(next(it1))
            result.append(next(it2))
        return """".join(result)
",n
"
import collections


class Solution(object):
    def checkWays(self, pairs):
        adj = collections.defaultdict(set)
        for x, y in pairs:
            adj[x].add(y)
            adj[y].add(x)
        n, mul = len(adj), False
        lookup = set()
        for node in sorted(iter(adj.keys()), key=lambda i: len(adj[i]), reverse=True):
            lookup.add(node)
            parent = 0
            for x in adj[node]:
                if x not in lookup:
                    continue
                if parent == 0 or len(adj[x]) < len(adj[parent]):
                    parent = x
            if parent:
                if any(True for x in adj[node] if x != parent and x not in adj[parent]):
                    return 0
                mul |= len(adj[parent]) == len(adj[node])
            elif len(adj[node]) != n-1:
                return 0
        return 1 + mul
",nlogn
"

class Solution(object):
    def findMinimumTime(self, tasks):
        tasks.sort(key=lambda x: x[1])
        lookup = set()
        for s, e, d in tasks:
            d -= sum(i in lookup for i in range(s, e+1))
            for i in reversed(range(1, e+1)):
                if d <= 0:
                    break
                if i in lookup:
                    continue
                lookup.add(i)
                d -= 1
        return len(lookup)
",nlogn + n * r
"
class Solution(object):
    def canSeePersonsCount(self, heights):
        result = [0]*len(heights)
        stk = []
        for i, h in enumerate(heights):
            while stk and heights[stk[-1]] < h:
                result[stk.pop()] += 1
            if stk:
                result[stk[-1]] += 1
            if stk and heights[stk[-1]] == h:
                stk.pop()
            stk.append(i)
        return result


",n
"class Solution2(object):
    def canSeePersonsCount(self, heights):
        result = [0]*len(heights)
        stk = []
        for i in reversed(range(len(heights))):
            cnt = 0
            while stk and heights[stk[-1]] < heights[i]:
                stk.pop()
                cnt += 1
            result[i] = cnt+1 if stk else cnt
            if stk and heights[stk[-1]] == heights[i]:
                stk.pop()
            stk.append(i)
        return result
",n
"

class Solution(object):
    def minimumPartition(self, s, k):
        result = 1
        curr = 0
        for c in s:
            if int(c) > k:
                return -1
            if curr*10+int(c) > k:
                result += 1
                curr = 0
            curr = curr*10+int(c)
        return result
",n
"

class Solution(object):
    def hasTrailingZeros(self, nums):
        return sum(x%2 == 0 for x in nums) >= 2
",n
"
class Solution(object):
    def removeCoveredIntervals(self, intervals):
        intervals.sort(key=lambda x: [x[0], -x[1]])
        result, max_right = 0, 0
        for left, right in intervals:
            result += int(right > max_right)
            max_right = max(max_right, right)
        return result
",nlogn
"
class Solution(object):
    def guessNumber(self, n):
        left, right = 1, n
        while left <= right:
            mid = left + (right - left) / 2
            if guess(mid) <= 0:
                right = mid - 1
            else:
                left = mid + 1
        return left

",logn
"
import pandas as pd



def Solution(products: pd.DataFrame) -> pd.DataFrame:
    products[""quantity""].fillna(0, inplace=True)
    return products
",n
"
class Solution(object):
    def search(self, reader, target):
        left, right = 0, 19999
        while left <= right:
            mid = left + (right-left)//2
            response = reader.get(mid)
            if response > target:
                right = mid-1
            elif response < target:
                left = mid+1
            else:
                return mid
        return -1

",logn
"
class Solution(object):
    def canChoose(self, groups, nums):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
        
        def KMP(text, pattern, start):
            prefix = getPrefix(pattern)
            j = -1
            for i in range(start, len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1

        pos = 0
        for group in groups:
            pos = KMP(nums, group, pos)
            if pos == -1:
                return False
            pos += len(group)
        return True

",n
"
import itertools
from functools import reduce



class Solution(object):
    def getSneakyNumbers(self, nums):
        def f(check):
            return reduce(lambda accu, x: accu^x, (x for x in itertools.chain(nums, range(n)) if check(x)), 0)

        n = len(nums)-2
        x_xor_y = f(lambda _: True)
        bit = x_xor_y&-x_xor_y
        return [f(lambda x: x&bit == 0), f(lambda x: x&bit != 0)]
",n
"
class Solution(object):
    def isPerfectSquare(self, num):
        left, right = 1, num
        while left <= right:
            mid = left + (right - left) / 2
            if mid >= num / mid:
                right = mid - 1
            else:
                left = mid + 1
        return left == num / left and num % left == 0

",logn
"

class Solution(object):
    def minimizeSum(self, nums):
        nums.sort()
        return min(nums[-3+i]-nums[i] for i in range(3))
",nlogn
"
class Solution(object):
    def kWeakestRows(self, mat, k):
        result, lookup = [], set()
        for j in range(len(mat[0])):
            for i in range(len(mat)):
                if mat[i][j] or i in lookup:
                    continue
                lookup.add(i)
                result.append(i)
                if len(result) == k:
                    return result
        for i in range(len(mat)):
            if i in lookup:
                continue
            lookup.add(i)
            result.append(i)
            if len(result) == k:
                break
        return result


",m * n
"import collections


class Solution2(object):
    def kWeakestRows(self, mat, k):
        lookup = collections.OrderedDict()
        for j in range(len(mat[0])):
            for i in range(len(mat)):
                if mat[i][j] or i in lookup:
                    continue
                lookup[i] = True
                if len(lookup) == k:
                    return list(lookup.keys())
        for i in range(len(mat)):
            if i in lookup:
                continue
            lookup[i] = True
            if len(lookup) == k:
                break
        return list(lookup.keys())


",m * n
"import random


class Solution3(object):
    def kWeakestRows(self, mat, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def partition_around_pivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == n:
                    return
                elif new_pivot_idx > n:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
        
        nums = [(sum(mat[i]), i) for i in range(len(mat))]
        nth_element(nums, k)
        return [x[1] for x in sorted(nums[:k])]
",m * n + klogk
"

class Solution(object):
    def goodSubsetofBinaryMatrix(self, grid):
        lookup = {}
        for i in range(len(grid)):
            mask = reduce(lambda mask, j: mask|(grid[i][j]<<j), range(len(grid[0])), 0)
            if not mask:
                return [i]
            for mask2, j in lookup.items():
                if mask2&mask == 0:
                    return [j, i]
            lookup[mask] = i
        return []
",m * 2^n
"
class Solution(object):
    def missingNumber(self, arr):
        def check(arr, d, x):
            return arr[x] != arr[0] + d*x

        d = (arr[-1]-arr[0])//len(arr)
        left, right = 0, len(arr)-1
        while left <= right:
            mid = left + (right-left)//2
            if check(arr, d, mid):
                right = mid-1
            else:
                left = mid+1
        return arr[0] + d*left


",logn
"class Solution2(object):
    def missingNumber(self, arr):
        return (min(arr)+max(arr))*(len(arr)+1)//2 - sum(arr)
",n
"

class Solution(object):
    def maxProfitAssignment(self, difficulty, profit, worker):
        jobs = list(zip(difficulty, profit))
        jobs.sort()
        worker.sort()
        result, i, max_profit = 0, 0, 0
        for ability in worker:
            while i < len(jobs) and jobs[i][0] <= ability:
                max_profit = max(max_profit, jobs[i][1])
                i += 1
            result += max_profit
        return result

",mlogm + nlogn
"
class Solution(object):
    def ways(self, pizza, k):
        MOD = 10**9+7
        prefix = [[0]*len(pizza[0]) for _ in range(len(pizza))]
        for j in reversed(range(len(pizza[0]))):
            accu = 0
            for i in reversed(range(len(pizza))):
                accu += int(pizza[i][j] == 'A')
                prefix[i][j] = (prefix[i][j+1] if (j+1 < len(pizza[0])) else 0) + accu
        dp = [[[0]*k for _ in range(len(pizza[0]))] for _ in range(len(pizza))]
        for i in reversed(range(len(pizza))):
            for j in reversed(range(len(pizza[0]))):
                dp[i][j][0] = 1
                for m in range(1, k):
                    for n in range(i+1, len(pizza)):
                        if prefix[i][j] == prefix[n][j]:
                            continue
                        if prefix[n][j] == 0:
                            break
                        dp[i][j][m] = (dp[i][j][m] + dp[n][j][m-1]) % MOD
                    for n in range(j+1, len(pizza[0])):
                        if prefix[i][j] == prefix[i][n]:
                            continue
                        if prefix[i][n] == 0:
                            break
                        dp[i][j][m] = (dp[i][j][m] + dp[i][n][m-1]) % MOD
        return dp[0][0][k-1]
",m * n * k * (m + n)
"
class Solution(object):
    def findMiddleIndex(self, nums):
        total = sum(nums)
        accu = 0
        for i, x in enumerate(nums):
            if accu*2 == total-x:
                return i
            accu += x
        return -1
",n
"
import collections


class Solution(object):
    def canBeEqual(self, target, arr):
        return collections.Counter(target) == collections.Counter(arr)


",n
"class Solution2(object):
    def canBeEqual(self, target, arr):
        target.sort(), arr.sort()
        return target == arr
",nlogn
"
import collections


class Solution(object):

    def __init__(self):
        self.__q = collections.deque()

    def ping(self, t):
        self.__q.append(t)
        while self.__q[0] < t-3000:
            self.__q.popleft()
        return len(self.__q)
",1
"
class Solution(object):
    def findPeakElement(self, nums):
        left, right = 0, len(nums) - 1

        while left < right:
            mid = left + (right - left) / 2
            if nums[mid] > nums[mid + 1]:
                right = mid
            else:
                left = mid + 1

        return left


",logn
"
import collections


class Solution(object):
    def findLucky(self, arr):
        count = collections.Counter(arr)
        result = -1
        for k, v in count.items():
            if k == v:
                result = max(result, k)
        return result
",n
"

class Solution(object):
    def stringIndices(self, wordsContainer, wordsQuery):
        INF = float(""INF"")
        class Trie(object):
            def __init__(self):
                self.__nodes = []
                self.__mns = []
                self.__new_node()
            
            def __new_node(self):
                self.__nodes.append([-1]*26)
                self.__mns.append((INF, INF))
                return len(self.__nodes)-1

            def add(self, i, w):
                curr = 0
                self.__mns[curr] = min(self.__mns[curr], (len(w), i))
                for c in reversed(w):
                    x = ord(c)-ord('a')
                    if self.__nodes[curr][x] == -1:
                        self.__nodes[curr][x] = self.__new_node()
                    curr = self.__nodes[curr][x]
                    self.__mns[curr] = min(self.__mns[curr], (len(w), i))
            
            def query(self, w):
                curr = 0
                for c in reversed(w):
                    x = ord(c)-ord('a')
                    if self.__nodes[curr][x] == -1:
                        break
                    curr = self.__nodes[curr][x]
                return self.__mns[curr][1]
    
        trie = Trie()
        for i, w in enumerate(wordsContainer): 
            trie.add(i, w)
        return [trie.query(w) for w in wordsQuery]
",(n + q) * l
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, repr(self.__next__))

class Solution(object):
    def reorderList(self, head):
        if head == None or head.__next__ == None:
            return head

        fast, slow, prev = head, head, None
        while fast != None and fast.__next__ != None:
            fast, slow, prev = fast.next.__next__, slow.__next__, slow
        current, prev.next, prev = slow, None, None

        while current != None:
            current.next, prev, current = prev, current, current.next

        l1, l2 = head, prev
        dummy = ListNode(0)
        current = dummy

        while l1 != None and l2 != None:
            current.next, current, l1 = l1, l1, l1.__next__
            current.next, current, l2 = l2, l2, l2.__next__

        return dummy.__next__

",n
"


class Solution(object):
    def minOperations(self, n):
        def popcount(x):
            return bin(x)[2:].count('1')

        return popcount(n^(n*0b11))


",logn
"
class Solution2(object):
    def minOperations(self, n):
        result = 0
        while n:
            if n&1:
                n >>= 1
                n += n&1
                result += 1
            n >>= 1
        return result
",logn
"
from sortedcontainers import SortedList



class Solution(object):
    def minimumSumSubarray(self, nums, l, r):
        INF = float(""inf"")
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        result = INF
        sl = SortedList()
        for i in range(len(nums)):
            if i-l+1 >= 0:
                sl.add(prefix[i-l+1])
            if i-r >= 0:
                sl.remove(prefix[i-r])
            idx = sl.bisect_left(prefix[i+1])-1
            if idx >= 0:
                result = min(result, prefix[i+1]-sl[idx])
        return result if result != INF else -1
",nlogn
"

class Solution(object):
    def countAsterisks(self, s):
        result = cnt = 0
        for c in s:
            if c == '|':
                cnt = (cnt+1)%2
                continue
            if c == '*' and cnt == 0:
                result += 1
        return result
",n
"
class Solution(object):
    def countTriples(self, n):
        lookup = set()
        for i in range(1, n+1):
            lookup.add(i**2)
        result = 0
        for i in range(1, n+1):
            for j in range(1, n+1):
                result += int(i**2+j**2 in lookup)
        return result
",n^2
"
class Solution(object):
    def findPermutation(self, s):
        result = []
        for i in range(len(s)+1):
            if i == len(s) or s[i] == 'I':
                result += list(range(i+1, len(result), -1))
        return result

",n
"
import itertools



class Solution(object):
    def maxUpgrades(self, count, upgrade, sell, money):
        return [min(c+(m-c*u)//(u+s), c) for c, u, s, m in zip(count, upgrade, sell, money)]
",n
"
class Solution(object):
    def maxSatisfaction(self, satisfaction):
        satisfaction.sort(reverse=True)
        result, curr = 0, 0
        for x in satisfaction:
            curr += x
            if curr <= 0:
                break
            result += curr
        return result
",nlogn
"
class Solution(object):
    def countSpecialSubsequences(self, nums):
        MOD = 10**9+7
        dp = [0]*3
        for x in nums:
            dp[x] = ((dp[x]+dp[x])%MOD+(dp[x-1] if x-1 >= 0 else 1))%MOD
        return dp[-1]
",n
"
class Solution(object):
    def numSteps(self, s):
        result, carry = 0, 0
        for i in reversed(range(1, len(s))):
            if int(s[i]) + carry == 1:
                carry = 1 
                result += 2
            else:
                result += 1
        return result+carry
",n
"

class Solution(object):
    def maxDistinctElements(self, nums, k):
        result = 0
        nums.sort()
        curr = float(""-inf"")
        for x in nums:
            if curr > x+k:
                continue
            curr = max(curr, x-k)+1
            result += 1
        return result
",nlogn
"
class Solution(object):
    def __init__(self):
        def dayOfMonth(M):
            return (28 if (M == 2) else 31-(M-1)%7%2)

        self.__lookup = [0]*12
        for M in range(1, len(self.__lookup)):
            self.__lookup[M] += self.__lookup[M-1]+dayOfMonth(M)
            
    def dayOfYear(self, date):
        Y, M, D = list(map(int, date.split(""-"")))
        leap = 1 if M > 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0)) else 0
        return self.__lookup[M-1]+D+leap


",1
"class Solution2(object):
    def dayOfYear(self, date):
        def numberOfDays(Y, M):
            leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0
            return (28+leap if (M == 2) else 31-(M-1)%7%2)

        Y, M, result = list(map(int, date.split(""-"")))
        for i in range(1, M):
            result += numberOfDays(Y, i)
        return result
",1
"
class Solution(object):
    def findLongestChain(self, pairs):
        pairs.sort(key=lambda x: x[1])
        cnt, i = 0, 0
        for j in range(len(pairs)):
            if j == 0 or pairs[i][1] < pairs[j][0]:
                cnt += 1
                i = j
        return cnt

",nlogn
"
import heapq
from functools import reduce


class Solution(object):
    def getNumberOfBacklogOrders(self, orders):
        MOD = 10**9 + 7
        buy, sell  = [], [] 
        for p, a, t in orders:
            if t == 0:
                heapq.heappush(buy, [-p, a])
            else:
                heapq.heappush(sell, [p, a])
            while sell and buy and sell[0][0] <= -buy[0][0]:
                k = min(buy[0][1], sell[0][1])
                tmp = heapq.heappop(buy)
                tmp[1] -= k
                if tmp[1]:
                    heapq.heappush(buy, tmp)
                tmp = heapq.heappop(sell)
                tmp[1] -= k
                if tmp[1]:
                    heapq.heappush(sell, tmp)
        return reduce(lambda x, y: (x+y) % MOD, (a for _, a in buy + sell))
",nlogn
"
import heapq



class Solution(object):
    def shortestPathWithHops(self, n, edges, s, d, k):
        def modified_dijkstra():
            best = [[float(""inf"")]*(k+1) for _ in range(len(adj))]
            best[s][0] = 0
            min_heap = [(best[s][0], s, 0)]
            while min_heap:
                curr, u, cnt = heapq.heappop(min_heap)
                if curr > best[u][cnt]:
                    continue
                if u == d:
                    return curr
                for v, w in adj[u]:
                    if curr+w < best[v][cnt]:
                        best[v][cnt] = curr+w
                        heapq.heappush(min_heap, (best[v][cnt], v, cnt))
                    if cnt+1 <= k and curr < best[v][cnt+1]:
                        best[v][cnt+1] = curr
                        heapq.heappush(min_heap, (best[v][cnt+1], v, cnt+1))
            return -1
        
        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        return modified_dijkstra()
",n * k + (e * k) * log(n * k)
"

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def reverseOddLevels(self, root):
        q = [root]
        parity = 0
        while q:
            if parity:
                left, right = 0, len(q)-1
                while left < right:
                    q[left].val, q[right].val = q[right].val, q[left].val
                    left += 1
                    right -= 1
            if not q[0].left:
                break
            new_q = []
            for node in q:
                new_q.append(node.left)
                new_q.append(node.right)
            q = new_q       
            parity ^= 1
        return root
",n
"
class Solution(object):
    def intToRoman(self, num):
        numeral_map = {1: ""I"", 4: ""IV"", 5: ""V"", 9: ""IX"", \
                       10: ""X"", 40: ""XL"", 50: ""L"", 90: ""XC"", \
                       100: ""C"", 400: ""CD"", 500: ""D"", 900: ""CM"", \
                       1000: ""M""}
        keyset, result = sorted(numeral_map.keys()), []

        while num > 0:
            for key in reversed(keyset):
                while num / key > 0:
                    num -= key
                    result += numeral_map[key]

        return """".join(result)


",n
"

class Solution(object):
    def countMentions(self, numberOfUsers, events):
        result = [0]*numberOfUsers
        lookup = [1]*numberOfUsers
        events.sort(key=lambda x: (int(x[1]), x[0] == ""MESSAGE""))
        for m, t, s in events:                  
            if m == ""OFFLINE"":
                lookup[int(s)] = int(t)+60
                continue
            if s == ""ALL"":
                for i in range(len(lookup)):
                    result[i] += 1
            elif s == ""HERE"":
                for i in range(len(lookup)):
                    if lookup[i] <= int(t):
                        result[i] += 1
            else:
                for idx in s.split():
                    result[int(idx[2:])] += 1
        return result
",eloge + e * n
"
class Solution(object):
    def findIntegers(self, num):
        dp = [0] * 32
        dp[0], dp[1] = 1, 2
        for i in range(2, len(dp)):
            dp[i] = dp[i-1] + dp[i-2]
        result, prev_bit = 0, 0
        for i in reversed(range(31)):
            if (num & (1 << i)) != 0:
                result += dp[i]
                if prev_bit == 1:
                    result -= 1
                    break
                prev_bit = 1
            else:
                prev_bit = 0
        return result + 1

",1
"

class Solution(object):
    def countArrays(self, original, bounds):
        left, right = bounds[0]
        result = right-left+1
        for i in range(1, len(original)):
            diff = original[i]-original[i-1]
            left = max(left+diff, bounds[i][0])
            right = min(right+diff, bounds[i][1])
            result = min(result, max(right-left+1, 0))
        return result
",n
"
import collections



class Solution(object):
    def countPrefixSuffixPairs(self, words):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result = 0
        for w in words:
            curr = trie
            for i in range(len(w)):
                curr = curr[w[i], w[~i]]
                result += curr[""_cnt""] if ""_cnt"" in curr else 0
            curr[""_cnt""] = curr[""_cnt""]+1 if ""_cnt"" in curr else 1
        return result
",n * l
"
import collections


class Solution(object):
    def maxNumberOfBalloons(self, text):
        TARGET = ""balloon""
        source_count = collections.Counter(text)
        target_count = collections.Counter(TARGET)
        return min(source_count[c]//target_count[c] for c in target_count.keys())
",n
"
class Solution(object):
    def cherryPickup(self, grid):
        dp = [[[float(""-inf"")]*(len(grid[0])+2) for _ in range(len(grid[0])+2)] for _ in range(2)]
        dp[0][1][len(grid[0])] = grid[0][0] + grid[0][len(grid[0])-1]
        for i in range(1, len(grid)):
            for j in range(1, len(grid[0])+1):
                for k in range(1, len(grid[0])+1):
                    dp[i%2][j][k] = max(dp[(i-1)%2][j+d1][k+d2] for d1 in range(-1, 2) for d2 in range(-1, 2)) + \
                                    ((grid[i][j-1]+grid[i][k-1]) if j != k else grid[i][j-1])
        return max(list(map(max, *dp[(len(grid)-1)%2])))


",m * n^2
"
class Solution2(object):
    def cherryPickup(self, grid):
        dp = [[[float(""-inf"")]*len(grid[0]) for _ in range(len(grid[0]))] for _ in range(2)]
        dp[0][0][len(grid[0])-1] = grid[0][0] + grid[0][len(grid[0])-1]
        for i in range(1, len(grid)):
            for j in range(len(grid[0])):
                for k in range(len(grid[0])):
                    dp[i%2][j][k] = max(dp[(i-1)%2][j+d1][k+d2] for d1 in range(-1, 2) for d2 in range(-1, 2)
                                        if 0 <= j+d1 < len(grid[0]) and 0 <= k+d2 < len(grid[0])) + \
                                    ((grid[i][j]+grid[i][k]) if j != k else grid[i][j])
        return max(list(map(max, *dp[(len(grid)-1)%2])))

",m * n^2
"

class Solution(object):
    def minimizeConcatenatedLength(self, words):
        dp = [[float(""-inf"")]*26 for _ in range(2)]
        dp[0][ord(words[0][-1])-ord('a')] = dp[1][ord(words[0][0])-ord('a')] = 0
        for i in range(1, len(words)):
            new_dp = [[float(""-inf"")]*26 for _ in range(2)]
            for right in range(2):
                for c in range(26):
                    if dp[right][c] == float(""-inf""):
                        continue
                    l = c if right else ord(words[i-1][0])-ord('a')
                    r = c if not right else ord(words[i-1][-1])-ord('a')
                    new_dp[0][r] = max(new_dp[0][r], dp[right][c]+int(ord(words[i][-1])-ord('a') == l))
                    new_dp[1][l] = max(new_dp[1][l], dp[right][c]+int(r == ord(words[i][0])-ord('a')))
            dp = new_dp
        return sum(len(w) for w in words)-max(dp[right][c] for right in range(2) for c in range(26))
",n
"

class Solution(object):
    def largestLocal(self, grid):
        def find_max(i, j):
            return max(grid[ni][nj] for ni in range(i, i+3) for nj in range(j, j+3))

        return [[find_max(i, j) for j in range(len(grid[0])-2)] for i in range(len(grid)-2)]
",m * n
"

class Solution(object):
    def largestGoodInteger(self, num):
        result = ''
        cnt = 0
        for i, x in enumerate(num):
            cnt += 1
            if i+1 < len(num) and num[i] == num[i+1]:
                continue
            if cnt >= 3:
                result = max(result, num[i])
            cnt = 0
        return result*3


",n
"
class Solution2(object):
    def largestGoodInteger(self, num):
        return max(num[i] if num[i] == num[i+1] == num[i+2] else '' for i in range(len(num)-2))*3
",n
"

class Solution(object):
    def minCostGoodCaption(self, caption):
        L = 3
        n = len(caption)
        if n < L:
            return """"
        dp = [[[0]*2 for _ in range(26)] for _ in range(n-L+1)]
        mn = [[0]*2 for _ in range(n-L+1)]
        cap = [ord(x)-ord('a') for x in caption]
        for i in reversed(range(n-L+1)):
            for j in range(26):
                if i == n-L:
                    dp[i][j][:] = [sum(abs(cap[k]-j) for k in range(i, i+L)), L]
                    continue
                dp[i][j][:] = [dp[i+1][j][0]+abs(cap[i]-j), 1]
                if i+L < n-2:
                    curr, c = mn[i+L]
                    curr += sum(abs(cap[k]-j) for k in range(i, i+L))
                    if curr < dp[i][j][0] or (curr == dp[i][j][0] and c < j):
                        dp[i][j][:] = [curr, L]
            mn[i] = min([dp[i][j][0], j] for j in range(26))
        result = []
        i, j, l = 0, mn[0][1], 1
        while i != n:
            if l == L:
                j = mn[i][1]
            l = dp[i][j][1]
            result.append(chr(ord('a')+j)*l)
            i += l
        return """".join(result)
",26 * n
"

class Solution(object):
    def maxEnergyBoost(self, energyDrinkA, energyDrinkB):
        dp = [0]*2
        for i in range(len(energyDrinkA)):
            dp = [max(dp[0]+energyDrinkA[i], dp[1]), max(dp[1]+energyDrinkB[i], dp[0])]
        return max(dp)
",n
"
import bisect


class Solution(object):
    def isMajorityElement(self, nums, target):
        if len(nums) % 2:
            if nums[len(nums)//2] != target:
                return False
        else:
            if not (nums[len(nums)//2-1] == nums[len(nums)//2] == target):
                return False

        left = bisect.bisect_left(nums, target)
        right= bisect.bisect_right(nums, target)
        return (right-left)*2 > len(nums)
",logn
"
import collections


class Solution(object):
    def orangesRotting(self, grid):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        count = 0
        q = collections.deque()
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val == 2:
                    q.append((r, c, 0))
                elif val == 1:
                    count += 1

        result = 0
        while q:
            r, c, result = q.popleft()
            for d in directions:
                nr, nc = r+d[0], c+d[1]
                if not (0 <= nr < len(grid) and \
                        0 <= nc < len(grid[r])):
                    continue
                if grid[nr][nc] == 1:
                    count -= 1
                    grid[nr][nc] = 2
                    q.append((nr, nc, result+1))
        return result if count == 0 else -1
",m * n
"
import collections



class Solution(object):
    def rearrangeCharacters(self, s, target):
        cnt1 = collections.Counter(s)
        cnt2 = collections.Counter(target)
        return min(cnt1[k]//v for k, v in cnt2.items())
",n + m
"
import heapq



class Solution(object):
    def findCrossingTime(self, n, k, time):
        left_bridge, right_ware, right_bridge, left_ware = [(-(time[i][0]+time[i][2]), -i) for i in range(k)], [], [], []
        heapq.heapify(left_bridge)
        curr = 0
        while n:
            while left_ware and left_ware[0][0] <= curr:
                _, i = heapq.heappop(left_ware)
                heapq.heappush(left_bridge, (-(time[i][0]+time[i][2]), -i))
            while right_ware and right_ware[0][0] <= curr:
                _, i = heapq.heappop(right_ware)
                heapq.heappush(right_bridge, (-(time[i][0]+time[i][2]), -i))
            if right_bridge:
                _, i = heapq.heappop(right_bridge)
                i = -i
                curr += time[i][2]
                heapq.heappush(left_ware, (curr+time[i][3], i))
                n -= 1
            elif left_bridge and n-len(right_ware):
                _, i = heapq.heappop(left_bridge)
                i = -i
                curr += time[i][0]
                heapq.heappush(right_ware, (curr+time[i][1], i))
            else:
                curr = min(left_ware[0][0] if left_ware else float(""inf""),
                           right_ware[0][0] if right_ware else float(""inf""))
        return curr
",k + nlogk
"
import collections



class Solution(object):
    def countPairs(self, coordinates, k):
        result = 0
        cnt = collections.Counter()
        for x, y in coordinates:
            for i in range(k+1):
                result += cnt.get((x^i, y^(k-i)), 0)
            cnt[(x, y)] += 1
        return result
",n * k
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sumRootToLeaf(self, root):
        M = 10**9 + 7
        def sumRootToLeafHelper(root, val):
            if not root:
                return 0
            val = (val*2 + root.val) % M
            if not root.left and not root.right:
                return val
            return (sumRootToLeafHelper(root.left, val) +
                    sumRootToLeafHelper(root.right, val)) % M
        
        return sumRootToLeafHelper(root, 0)
",n
"
class Solution(object):
    def maxFrequency(self, nums, k):
        left = 0
        nums.sort()
        for right in range(len(nums)):
            k += nums[right]
            if k < nums[right]*(right-left+1):
                k -= nums[left]
                left += 1
        return right-left+1
",nlogn
"
import collections



class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteDuplicatesUnsorted(self, head):
        count = collections.defaultdict(int)
        curr = head
        while curr:
            count[curr.val] += 1
            curr = curr.__next__
        curr = dummy = ListNode(0, head)
        while curr.__next__:
            if count[curr.next.val] == 1:
                curr = curr.__next__
            else:
                curr.next = curr.next.__next__
        return dummy.__next__
",n
"
class Solution(object):
    def isGoodArray(self, nums):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result = nums[0]
        for num in nums:
            result = gcd(result, num)
            if result == 1:
                break
        return result == 1
",n
"
import abc 
from abc import ABCMeta, abstractmethod 


class Node(metaclass=ABCMeta):
    @abstractmethod
    def evaluate(self):
        pass


import operator


class Solution(Node):
    ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
    
    def __init__(self, val):
        self.val = val
        self.left = None 
        self.right = None
    
    def evaluate(self):
        result = [0]
        stk = [(1, (self, result))]
        while stk:
            step, args = stk.pop()
            if step == 1:
                node, ret = args
                if node.val.isdigit():
                    ret[0] = int(node.val)
                    continue
                ret1, ret2 = [0], [0]
                stk.append((2, (node, ret1, ret2, ret)))
                stk.append((1, (node.right, ret2)))
                stk.append((1, (node.left, ret1)))
            elif step == 2:
                node, ret1, ret2, ret = args
                ret[0] = Solution.ops[node.val](ret1[0], ret2[0])
        return result[0]


class TreeBuilder(object):
    def buildTree(self, postfix):
        stk = []
        for c in postfix:
            if c.isdigit():
                stk.append(Solution(c))
            else:
                node = Solution(c)
                node.right = stk.pop()
                node.left = stk.pop()
                stk.append(node)                
        return stk.pop()


",n
"class Solution2(Node):
    ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
    
    def __init__(self, val):
        self.val = val
        self.left = None 
        self.right = None

    def evaluate(self):
        if self.val.isdigit():
            return int(self.val)
        return Solution2.ops[self.val](self.left.evaluate(), self.right.evaluate())
        

class TreeBuilder2(object):
    def buildTree(self, postfix):
        stk = []
        for c in postfix:
            if c.isdigit():
                stk.append(Solution2(c))
            else:
                node = Solution2(c)
                node.right = stk.pop()
                node.left = stk.pop()
                stk.append(node)
        return stk.pop()
",n
"

class Solution(object):
    def appealSum(self, s):
        result = curr = 0
        lookup = [-1]*26
        for i, c in enumerate(s):
            result += (i-lookup[ord(c)-ord('a')])*(len(s)-i)
            lookup[ord(c)-ord('a')] = i
        return result


",n
"
class Solution2(object):
    def appealSum(self, s):
        result = cnt = 0
        lookup = [-1]*26
        for i, c in enumerate(s):
            cnt += i-lookup[ord(c)-ord('a')]
            lookup[ord(c)-ord('a')] = i
            result += cnt
        return result

",n
"
import collections



class Solution(object):
    def dividePlayers(self, skill):
        target = sum(skill)//(len(skill)//2)
        cnt = collections.Counter(skill)
        result = 0
        for k, v in cnt.items():
            if target-k not in cnt or cnt[target-k] != cnt[k]:
                return -1
            result += k*(target-k)*v
        return result//2
",n
"
class Solution(object):
    def findLongestWord(self, s, d):
        d.sort(key = lambda x: (-len(x), x))
        for word in d:
            i = 0
            for c in s:
                if i < len(word) and word[i] == c:
                    i += 1
            if i == len(word):
                return word
        return """"

",(d * l) * logd
"

class Solution(object):
    def numberOfSubarrays(self, nums):
        result = 0
        stk = []
        for x in nums:
            while stk and stk[-1][0] < x:
                stk.pop()
            if not stk or stk[-1][0] != x:
                stk.append([x, 0])
            stk[-1][1] += 1
            result += stk[-1][1]
        return result
",n
"
class Solution(object):
    def reverseStr(self, s, k):
        s = list(s)
        for i in range(0, len(s), 2*k):
            s[i:i+k] = reversed(s[i:i+k])
        return """".join(s)

",n
"

class Solution(object):
    def hasValidPath(self, grid):
        if (len(grid)+len(grid[0])-1)%2:
            return False
        dp = [0]*(len(grid[0])+1)
        for i in range(len(grid)):
            dp[0] = int(not i)
            for j in range(len(grid[0])):
                dp[j+1] = (dp[j]|dp[j+1])<<1 if grid[i][j] == '(' else (dp[j]|dp[j+1])>>1
        return dp[-1]&1


",(m * n) * (m + n) / 32
"
class Solution_WA(object):
    def hasValidPath(self, grid):
        if (len(grid)+len(grid[0])-1)%2:
            return False
        dp = [[float(""inf""), float(""-inf"")] for _ in range(len(grid[0])+1)]
        for i in range(len(grid)):
            dp[0] = [0, 0] if not i else [float(""inf""), float(""-inf"")]
            for j in range(len(grid[0])):
                d = 1 if grid[i][j] == '(' else -1
                dp[j+1] = [min(dp[j+1][0], dp[j][0])+d, max(dp[j+1][1], dp[j][1])+d]
                if dp[j+1][1] < 0:
                    dp[j+1] = [float(""inf""), float(""-inf"")]
                else:
                    dp[j+1][0] = max(dp[j+1][0], dp[j+1][1]%2)
        return dp[-1][0] == 0
",m * n
"

class Solution(object):
    def countGoodStrings(self, low, high, zero, one):
        MOD = 10**9+7
        result = 0
        dp = [0]*(high+1)
        dp[0] = 1
        for i in range(1, high+1):
            if i >= zero:
                dp[i] = (dp[i]+dp[i-zero])%MOD
            if i >= one:
                dp[i] = (dp[i]+dp[i-one])%MOD
            if i >= low:
                result = (result+dp[i])%MOD
        return result
",n
"

class Solution(object):
    def findClosest(self, x, y, z):
        return list(range(3))[cmp(abs(y-z), abs(x-z))]
",1
"

class Solution(object):
    def sum(self, num1, num2):
        return num1+num2
",1
"

class Solution(object):
    def smallestNumber(self, num, t):
        LOOKUP = [[(0, 0, 0, 0), (0, 1, 0, 0)],
                  [(1, 0, 0, 0), (0, 0, 0, 1)],
                  [(0, 0, 1, 0), (1, 0, 0, 1)]]
        def count(x):
            cnt = [0]*10
            for i in range(2, 9+1):
                while x%i == 0:
                    x //= i
                    cnt[i] += 1
                if x == 1:
                    return cnt
            return []
    
        def update(total, cnt, d):
            for i, x in enumerate(cnt):
                total[i] += d*x

        def diff(expect, total):
            return [max(expect[i]-total[i], 0) for i in range(len(expect))]

        def min_factors(cnt):
            cnt8, r2 = divmod(cnt[2], 3)
            cnt9, r3 = divmod(cnt[3], 2)
            cnt2, cnt3, cnt4, cnt6 = LOOKUP[r2][r3]
            return (cnt2, cnt3, cnt4, cnt[5], cnt6, cnt[7], cnt8, cnt9)
    
        def format(cnt, l):
            return '1'*(l-sum(cnt))+"""".join(str(x)*cnt[x-2] for x in range(2, 9+1))
    
        expect = count(t)
        if not expect:
            return ""-1""
        nums = list(map(int, num))
        i = next((i for i in range(len(nums)) if not nums[i]), len(nums))
        for j in range(i, len(nums)):
            nums[j] = 1
        total = [0]*10
        for x in nums:
            update(total, count(x), +1)
        if all(d == 0 for d in diff(expect, total)):
            return """".join(map(str, nums))
        for i in reversed(range(len(nums))):
            update(total, count(nums[i]), -1)
            for x in range(nums[i]+1, 9+1):
                update(total, count(x), +1)
                tmp = min_factors(diff(expect, total))
                update(total, count(x), -1)
                if sum(tmp) > len(nums)-1-i:
                    continue
                return """".join(map(str, nums[:i]))+str(x)+format(tmp, len(nums)-1-i)
        return format(min_factors(diff(expect, total)), len(nums)+1)


",n + logt
"
class Solution2(object):
    def smallestNumber(self, num, t):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def find_candidates(t, l): 
            candidates = []
            for x in reversed(range(2, 9+1)):
                while t%x == 0:
                    t //= x
                    candidates.append(x)
                    if len(candidates) > l:
                        return []
                if t == 1:
                    candidates.reverse()
                    return candidates
            return []
    
        def format(candidates, l):
            result = [1]*l
            i = len(result)-len(candidates)
            for x in candidates:
                result[i] = x
                i += 1
            return """".join(map(str, result))

        nums = list(map(int, num))
        candidates = find_candidates(t, float(""inf""))
        if t != 1 and not candidates:
            return ""-1""
        i = next((i for i in range(len(nums)) if not nums[i]), len(nums))
        for j in range(i, len(nums)):
            nums[j] = 1
        prefix = [1]*(len(nums)+1)
        for i in range(len(prefix)-1):
            prefix[i+1] = (prefix[i]*nums[i])%t
        if not prefix[-1]:
            return """".join(map(str, nums))
        for i in reversed(range(len(nums))):
             target = t//gcd(t, prefix[i])
             for x in range(nums[i]+1, 9+1):
                new_target = target//gcd(target, x)
                tmp = find_candidates(new_target, len(nums)-1-i)
                if new_target != 1 and not tmp:
                    continue
                nums[i] = x
                return """".join(map(str, nums[:i+1]))+format(tmp, len(nums)-1-i)
        return format(candidates, max(len(nums)+1, len(candidates)))
",nlogt
"
class Solution(object):
    def maxSubArray(self, nums):
        result, curr = float(""-inf""), float(""-inf"")
        for x in nums:
            curr = max(curr+x, x)
            result = max(result, curr)
        return result
",n
"

class Solution(object):
    def numberOfSpecialSubstrings(self, s):
        result = left = 0
        lookup = [-1]*26
        for right in range(len(s)):
            if lookup[ord(s[right])-ord('a')] >= left:
                left = lookup[ord(s[right])-ord('a')]+1
            lookup[ord(s[right])-ord('a')] = right
            result += (right-left+1)
        return result


",n
"
class Solution2(object):
    def numberOfSpecialSubstrings(self, s):
        result = left = 0
        lookup = [False]*26
        for right in range(len(s)):
            while lookup[ord(s[right])-ord('a')]:
                lookup[ord(s[left])-ord('a')] = False
                left += 1
            lookup[ord(s[right])-ord('a')] = True
            result += (right-left+1)
        return result
",n
"

class Solution(object):
    def secondGreaterElement(self, nums):
        result, stk1, stk2 = [-1]*len(nums), [], []
        for i, x in enumerate(nums):
            while stk2 and nums[stk2[-1]] < x:
                result[stk2.pop()] = x
            tmp = []
            while stk1 and nums[stk1[-1]] < x:
                tmp.append(stk1.pop())
            stk1.append(i)
            for x in reversed(tmp):
                stk2.append(x)
        return result
",n
"
class Solution(object):
    def closedIsland(self, grid):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def fill(grid, i, j):
            if not (0 <= i < len(grid) and 
                    0 <= j < len(grid[0]) and 
                    grid[i][j] == 0):
                return False
            grid[i][j] = 1
            for dx, dy in directions:
                fill(grid, i+dx, j+dy)
            return True

        for j in range(len(grid[0])):
            fill(grid, 0, j)
            fill(grid, len(grid)-1, j)
        for i in range(1, len(grid)):
            fill(grid, i, 0)
            fill(grid, i, len(grid[0])-1)
        result = 0
        for i in range(1, len(grid)-1):
            for j in range(1, len(grid[0])-1):
                if fill(grid, i, j):
                    result += 1
        return result
",m * n
"
class Solution(object):
    def jump(self, A):
        jump_count = 0
        reachable = 0
        curr_reachable = 0
        for i, length in enumerate(A):
            if i > reachable:
                return -1
            if i > curr_reachable:
                curr_reachable = reachable
                jump_count += 1
            reachable = max(reachable, i + length)
        return jump_count


",n
"

import collections


class Solution(object):
    def findItinerary(self, tickets):
        adj = collections.defaultdict(list)
        for ticket in tickets:
            adj[ticket[0]].append(ticket[1])
        for x in adj.values():
            x.sort(reverse=True)
        origin = ""JFK""
        result = []
        stk = [origin]
        while stk:
            while adj[stk[-1]]: 
                stk.append(adj[stk[-1]].pop())
            result.append(stk.pop())
        result.reverse()
        return result


",|V| + |E|log|V|
"

import collections


class Solution2(object):
    def findItinerary(self, tickets):
        def route_helper(origin, ticket_cnt, graph, ans):
            if ticket_cnt == 0:
                return True

            for i, (dest, valid)  in enumerate(graph[origin]):
                if valid:
                    graph[origin][i][1] = False
                    ans.append(dest)
                    if route_helper(dest, ticket_cnt - 1, graph, ans):
                        return ans
                    ans.pop()
                    graph[origin][i][1] = True
            return False

        graph = collections.defaultdict(list)
        for ticket in tickets:
            graph[ticket[0]].append([ticket[1], True])
        for k in list(graph.keys()):
            graph[k].sort()

        origin = ""JFK""
        ans = [origin]
        route_helper(origin, len(tickets), graph, ans)
        return ans

",t! / (n1! * n2! * ... nk!)
"
class Solution(object):
    def mostSimilar(self, n, roads, names, targetPath):
        adj = [[] for _ in range(n)]
        for u, v in roads:
            adj[u].append(v)
            adj[v].append(u)

        dp = [[0]*n for _ in range(len(targetPath)+1)]
        for i in range(1, len(targetPath)+1):
            for v in range(n):
                dp[i][v] = (names[v] != targetPath[i-1]) + min(dp[i-1][u] for u in adj[v]) 

        path = [dp[-1].index(min(dp[-1]))]
        for i in reversed(range(2, len(targetPath)+1)):
            for u in adj[path[-1]]:
                if dp[i-1][u]+(names[path[-1]] != targetPath[i-1]) == dp[i][path[-1]]:
                    path.append(u)
                    break
        return path[::-1]
",n^2 * m
"
import collections


class Solution(object):
    def hasPath(self, maze, start, destination):
        def neighbors(maze, node):
            for i, j in [(-1, 0), (0, 1), (0, -1), (1, 0)]:
                x, y = node
                while 0 <= x + i < len(maze) and \
                      0 <= y + j < len(maze[0]) and \
                      not maze[x+i][y+j]:
                    x += i
                    y += j
                yield x, y

        start, destination = tuple(start), tuple(destination)
        queue = collections.deque([start])
        visited = set()
        while queue:
            node = queue.popleft()
            if node in visited: continue
            if node == destination:
                return True
            visited.add(node)
            for neighbor in neighbors(maze, node):
                queue.append(neighbor)

        return False
","max(r, c) * w"
"
class Solution(object):
    def longestLine(self, M):
        if not M: return 0
        result = 0
        dp = [[[0] * 4 for _ in range(len(M[0]))] for _ in range(2)]
        for i in range(len(M)):
            for j in range(len(M[0])):
                dp[i % 2][j][:] = [0] * 4
                if M[i][j] == 1:
                    dp[i % 2][j][0] = dp[i % 2][j - 1][0]+1 if j > 0 else 1
                    dp[i % 2][j][1] = dp[(i-1) % 2][j][1]+1 if i > 0 else 1
                    dp[i % 2][j][2] = dp[(i-1) % 2][j-1][2]+1 if (i > 0 and j > 0) else 1
                    dp[i % 2][j][3] = dp[(i-1) % 2][j+1][3]+1 if (i > 0 and j < len(M[0])-1) else 1
                    result = max(result, max(dp[i % 2][j]))
        return result

",m * n
"
class Solution(object):
    def mySqrt(self, x):
        if x < 2:
            return x

        left, right = 1, x // 2
        while left <= right:
            mid = left + (right - left) // 2
            if mid > x / mid:
                right = mid - 1
            else:
                left = mid + 1

        return left - 1


",logn
"
class Solution(object):
    def longestAwesome(self, s):
        ALPHABET_SIZE = 10
        result, mask, lookup = 0, 0, [len(s)]*(2**ALPHABET_SIZE)
        lookup[0] = -1
        for i, ch in enumerate(s):
            mask ^= 2**(ord(ch)-ord('0'))
            if lookup[mask] == len(s):
                lookup[mask] = i
            result = max(result, i - lookup[mask])
            for d in range(ALPHABET_SIZE):
                result = max(result, i - lookup[mask^(2**d)])
        return result
",10 * n
"

class Solution(object):
    def minZeroArray(self, nums, queries):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(l):
            def valid(arr, target):
                dp = [False]*(target+1)
                dp[0] = 1
                for i in range(len(arr)):
                    dp = [dp[j] or (j-arr[i] >= 0 and dp[j-arr[i]]) for j in range(target+1)]
                return dp[target]

            return all(valid([queries[j][2] for j in range(l) if queries[j][0] <= i <= queries[j][1]], nums[i]) for i in range(len(nums)))

        result = binary_search(0, len(queries), check)
        return result if result <= len(queries) else -1


",n^2 * r * logq
"
class Solution2(object):
    def minZeroArray(self, nums, queries):
        dp = [{0} for _ in range(len(nums))]
        for i, (l, r, v) in enumerate(queries):
            if all(nums[i] in dp[i] for i in range(len(dp))):
                return i
            for j in range(l, r+1):
                dp[j] |= set(x+v for x in dp[j])
        return len(queries) if all(nums[i] in dp[i] for i in range(len(dp))) else -1
",q * n * 2^n
"

class Solution(object):
    def checkTwoChessboards(self, coordinate1, coordinate2):
        def parity(a):
            return reduce(lambda accu, x: (accu+x)%2, (ord(x) for x in a), 0)
        
        return parity(coordinate1) == parity(coordinate2)
",1
"
import heapq


class Solution(object):
    def getOrder(self, tasks):
        idx = list(range(len(tasks)))
        idx.sort(key=lambda x: tasks[x][0])
        result, min_heap = [], []
        i, time = 0, tasks[idx[0]][0]
        while i < len(idx) or min_heap:
            while i < len(idx) and tasks[idx[i]][0] <= time:
                heapq.heappush(min_heap, (tasks[idx[i]][1], idx[i]))
                i += 1
            if not min_heap:
                time = tasks[idx[i]][0]
                continue
            t, j = heapq.heappop(min_heap)
            time += t
            result.append(j)
        return result
",nlogn
"
class Solution(object):
    def minOperations(self, logs):
        result = 0
        for log in logs:
            if log == ""../"":
                if result > 0:
                    result -= 1
            elif log != ""./"":
                result += 1
        return result
",n
"
import collections



class Solution(object):
    def minLengthAfterRemovals(self, nums):
        mx = max(collections.Counter(nums).values())
        return mx-(len(nums)-mx) if mx > (len(nums)-mx) else len(nums)%2
",n
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def addTwoNumbers(self, l1, l2):
        dummy = ListNode(0)
        current, carry = dummy, 0

        while l1 or l2:
            val = carry
            if l1:
                val += l1.val
                l1 = l1.__next__
            if l2:
                val += l2.val
                l2 = l2.__next__
            carry, val = divmod(val, 10)
            current.next = ListNode(val)
            current = current.__next__

        if carry == 1:
            current.next = ListNode(1)

        return dummy.__next__

",n
"
import math


class Solution(object):
    def judgeSquareSum(self, c):
        for a in range(int(math.sqrt(c))+1):
            b = int(math.sqrt(c-a**2))
            if a**2 + b**2 == c:
                return True
        return False

",sqrt(c) * logc
"
class Solution(object):
    def removePalindromeSub(self, s):
        def is_palindrome(s):
            for i in range(len(s)//2):
                if s[i] != s[-1-i]:
                    return False
            return True
        
        return 2 - is_palindrome(s) - (s == """")
",n
"
import heapq


class Solution(object):
    def minimumDeviation(self, nums):
        max_heap = [-num*2 if num%2 else -num for num in nums]
        heapq.heapify(max_heap)
        min_elem = -max(max_heap)
        result = float(""inf"")
        while len(max_heap) == len(nums):
            num = -heapq.heappop(max_heap)
            result = min(result, num-min_elem)
            if not num%2:
                min_elem = min(min_elem, num//2)
                heapq.heappush(max_heap, -num//2)
        return result
",(n * log(max_num)) * logn
"
class Solution(object):
    def findCelebrity(self, n):
        candidate = 0
        for i in range(1, n):
            if knows(candidate, i): 
                candidate = i       
        for i in range(n):
            candidate_knows_i = knows(candidate, i)
            i_knows_candidate = knows(i, candidate)
            if i != candidate and (candidate_knows_i or
                                   not i_knows_candidate):
                return -1
        return candidate

",n
"

class Solution(object):
    def incremovableSubarrayCount(self, nums):
        for j in reversed(range(1, len(nums))):
            if not nums[j-1] < nums[j]:
                break
        else:
            return (len(nums)+1)*len(nums)//2
        result = len(nums)-j+1
        for i in range(len(nums)-1):
            while j < len(nums) and not (nums[i] < nums[j]):
                j += 1
            result += len(nums)-j+1
            if not (nums[i] < nums[i+1]):
                break
        return result


",n
"
class Solution2(object):
    def incremovableSubarrayCount(self, nums):
        return sum((left == 0 or right == len(nums)-1 or nums[left-1] < nums[right+1]) and
                   all(nums[i] < nums[i+1] for i in range(left-1)) and
                   all(nums[i] < nums[i+1] for i in range(right+1, len(nums)-1))
                   for left in range(len(nums)) for right in range(left, len(nums)))
",n^3
"
class Solution(object):
    def minimumDeletions(self, s):
        result = b_cnt = 0
        for c in s:
            if c == 'b':
                b_cnt += 1
            elif b_cnt:
                b_cnt -= 1
                result += 1
        return result
",n
"

class Solution(object):
    def maximumSubsequenceCount(self, text, pattern):
        result = cnt1 = cnt2 = 0
        for c in text:
            if c == pattern[1]:
                result += cnt1
                cnt2 += 1
            if c == pattern[0]:
                cnt1 += 1
        return result + max(cnt1, cnt2) 
",n
"
import operator
import collections
from functools import reduce


class Solution(object):
    def findTheDifference(self, s, t):
        return chr(reduce(operator.xor, list(map(ord, s)), 0) ^ reduce(operator.xor, list(map(ord, t)), 0))

    def findTheDifference2(self, s, t):
        t = list(t)
        s = list(s)
        for i in s:
            t.remove(i)
        return t[0]

    def findTheDifference3(self, s, t):
        return chr(reduce(operator.xor, list(map(ord, s + t))))

    def findTheDifference4(self, s, t):
        return list((collections.Counter(t) - collections.Counter(s)))[0]

    def findTheDifference5(self, s, t):
        s, t = sorted(s), sorted(t)
        return t[-1] if s == t[:-1] else [x[1] for x in zip(s, t) if x[0] != x[1]][0]


",n
"
class BinaryMatrix(object):
    def get(self, row, col):
        pass

    def dimensions(self):
        pass


class Solution(object):
    def leftMostColumnWithOne(self, binaryMatrix):
        m, n = binaryMatrix.dimensions()
        r, c = 0, n-1
        while r < m and c >= 0:
            if not binaryMatrix.get(r, c):
                r += 1
            else:
                c -= 1        
        return c+1 if c+1 != n else -1
",m + n
"

class Solution(object):
    def doesValidArrayExist(self, derived):
        return reduce(lambda total, x: total^x, derived, 0) == 0
",n
"
class Solution(object):
    def prisonAfterNDays(self, cells, N):
        N -= max(N-1, 0) // 14 * 14 
        for i in range(N):
            cells = [0] + [cells[i-1] ^ cells[i+1] ^ 1 for i in range(1, 7)] + [0]
        return cells


",1
"class Solution2(object):
    def prisonAfterNDays(self, cells, N):
        cells = tuple(cells)
        lookup = {}
        while N:
            lookup[cells] = N
            N -= 1
            cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in range(1, 7)] + [0])
            if cells in lookup:
                assert(lookup[cells] - N in (1, 7, 14))
                N %= lookup[cells] - N
                break

        while N:
            N -= 1
            cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in range(1, 7)] + [0])
        return list(cells)
",1
"

class Solution(object):
    def modifiedList(self, nums, head):
        lookup = set(nums)
        curr = dummy = ListNode(0, head)
        while curr.__next__:
            if curr.next.val not in lookup:
                curr = curr.__next__
            else:
                curr.next = curr.next.__next__
        return dummy.__next__
",n
"

class Solution(object):
    def longestSubsequence(self, nums):
        result = 2
        mx = max(nums)
        dp = [[0]*mx for _ in range(mx)]
        for x in nums:
            x -= 1
            for nx in range(len(dp[x])):
                d = abs(nx-x)
                dp[x][d] = max(dp[x][d], dp[nx][d]+1)
            for d in reversed(range(len(dp[x])-1)):
                dp[x][d] = max(dp[x][d], dp[x][d+1])
            result = max(result, dp[x][0])
        return result


",r^2 + n * r
"
class Solution2(object):
    def longestSubsequence(self, nums):
        result = 2
        mx = max(nums)
        dp = [[0]*mx for _ in range(mx)]
        for x in reversed(nums):
            x -= 1
            for nx in range(len(dp[x])):
                d = abs(nx-x)
                dp[x][d] = max(dp[x][d], dp[nx][d]+1)
            for d in range(1, len(dp[x])):
                dp[x][d] = max(dp[x][d], dp[x][d-1])
            result = max(result, dp[x][-1])
        return result
",r^2 + n * r
"
class Solution(object):
    def depthSum(self, nestedList):
        def depthSumHelper(nestedList, depth):
            res = 0
            for l in nestedList:
                if l.isInteger():
                    res += l.getInteger() * depth
                else:
                    res += depthSumHelper(l.getList(), depth + 1)
            return res
        return depthSumHelper(nestedList, 1)

",n
"
import collections


class Solution(object):
    def subdomainVisits(self, cpdomains):
        result = collections.defaultdict(int)
        for domain in cpdomains:
            count, domain = domain.split()
            count = int(count)
            frags = domain.split('.')
            curr = []
            for i in reversed(range(len(frags))):
                curr.append(frags[i])
                result[""."".join(reversed(curr))] += count

        return [""{} {}"".format(count, domain) \
                for domain, count in result.items()]

",n
"
class Solution(object):
    def sumOfDigits(self, A):
        total = sum([int(c) for c in str(min(A))])
        return 1 if total % 2 == 0 else 0
",n * l
"

class Solution(object):
    def mostPoints(self, questions):
        dp = [0]*(len(questions)+1)
        for i in reversed(range(len(dp)-1)):
            dp[i] = max(dp[i+1], questions[i][0] + (dp[i+1+questions[i][1]] if i+1+questions[i][1] < len(dp) else 0))
        return dp[0]
",n
"
class Solution(object):
    def licenseKeyFormatting(self, S, K):
        result = []
        for i in reversed(range(len(S))):
            if S[i] == '-':
                continue
            if len(result) % (K + 1) == K:
                result += '-'
            result += S[i].upper()
        return """".join(reversed(result))
",n
"

class Solution(object):
    def validPartition(self, nums):
        dp = [False]*4
        dp[0] = True
        for i in range(len(nums)):
            dp[(i+1)%4] = False
            if i-1 >= 0 and nums[i] == nums[i-1]:
                dp[(i+1)%4] |= dp[((i+1)-2)%4]
            if i-2 >= 0 and (nums[i] == nums[i-1] == nums[i-2] or
                             nums[i] == nums[i-1]+1 == nums[i-2]+2):
                dp[(i+1)%4] |= dp[((i+1)-3)%4]
        return dp[len(nums)%4]
",n
"
import bisect


class Solution(object):
    def numSmallerByFrequency(self, queries, words):
        words_freq = sorted(word.count(min(word)) for word in words)
        return [len(words)-bisect.bisect_right(words_freq, query.count(min(query))) \
                for query in queries]
",(m + n)logn
"
class Solution(object):
    def getMaximumGold(self, grid):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def backtracking(grid, i, j):
            result = 0
            grid[i][j] *= -1
            for dx, dy in directions:
                ni, nj = i+dx, j+dy
                if not (0 <= ni < len(grid) and
                        0 <= nj < len(grid[0]) and
                        grid[ni][nj] > 0):
                    continue
                result = max(result, backtracking(grid, ni, nj))
            grid[i][j] *= -1
            return grid[i][j] + result

        result = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]:
                    result = max(result, backtracking(grid, i, j))
        return result
",m^2 * n^2
"

class Solution(object):
    def longestCommonPrefix(self, s, t):
        result = i = j = 0
        removed = False
        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                result += 1
                i += 1
                j += 1
            elif not removed:
                removed = True
                i += 1
            else:
                break
        return result
",n
"
import collections


class Solution(object):
    def countWords(self, words1, words2):
        cnt = collections.Counter(words1)
        for c in words2:
            if cnt[c] < 2:
                cnt[c] -= 1
        return sum(v == 0 for v in cnt.values())
",m + n
"

class Solution(object):
    def pivotArray(self, nums, pivot):
        result = [pivot]*len(nums)
        left, right = 0, len(nums)-sum(x > pivot for x in nums)
        for x in nums:
            if x < pivot:
                result[left] = x
                left += 1
            elif x > pivot:
                result[right] = x
                right += 1
        return result
",n
"

class Solution(object):
    def minimizeSet(self, divisor1, divisor2, uniqueCnt1, uniqueCnt2):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def lcm(a, b):
            return a//gcd(a, b)*b

        def count(cnt, d1, d2):
            l = lcm(d1, d2)
            return cnt+cnt//(l-1)-int(cnt%(l-1) == 0)
        
        return max(count(uniqueCnt1, divisor1, 1),
                   count(uniqueCnt2, divisor2, 1),
                   count(uniqueCnt1+uniqueCnt2, divisor1, divisor2))


","log(min(d1, d2))"
"
class Solution2(object):
    def minimizeSet(self, divisor1, divisor2, uniqueCnt1, uniqueCnt2):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def lcm(a, b):
            return a//gcd(a, b)*b

        def check(cnt):
            return (cnt-cnt//divisor1 >= uniqueCnt1 and
                    cnt-cnt//divisor2 >= uniqueCnt2 and
                    cnt-cnt//l >= uniqueCnt1+uniqueCnt2)

        l = lcm(divisor1, divisor2)
        left, right = 2, 2**31-1
        while left <= right:
            mid = left+(right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return left
","log(min(d1, d2)) + logr"
"

class Solution(object):
    def smallestSubarrays(self, nums):
        result = [0]*len(nums)
        lookup = [-1]*max(max(nums).bit_length(), 1)
        for i in reversed(range(len(nums))):
            for bit in range(len(lookup)):
                if nums[i]&(1<<bit):
                    lookup[bit] = i
            result[i] = max(max(lookup)-i+1, 1)
        return result
",n
"
import itertools



class Solution(object):
    def numberOfSpecialChars(self, word):
        lookup1 = [False]*26
        lookup2 = [False]*26
        for x in word:
            if x.islower():
                lookup1[ord(x)-ord('a')] = True
            else:
                lookup2[ord(x)-ord('A')] = True
        return sum(x == y == True for x, y in zip(lookup1, lookup2))
",n + 26
"
import collections
import re


class Solution(object):
    def countOfAtoms(self, formula):
        parse = re.findall(r""([A-Z][a-z]*)(\d*)|(\()|(\))(\d*)"", formula)
        stk = [collections.Counter()]
        for name, m1, left_open, right_open, m2 in parse:
            if name:
              stk[-1][name] += int(m1 or 1)
            if left_open:
              stk.append(collections.Counter())
            if right_open:
                top = stk.pop()
                for k, v in top.items():
                  stk[-1][k] += v * int(m2 or 1)

        return """".join(name + (str(stk[-1][name]) if stk[-1][name] > 1 else '') \
                       for name in sorted(stk[-1]))

",n
"
import collections


class Solution(object):
    def minTime(self, n, edges, hasApple):
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        result = [0, 0]
        s = [(1, (-1, 0, result))]
        while s:
            step, params = s.pop()
            if step == 1:
                par, node, ret = params
                ret[:] = [0, int(hasApple[node])]
                for nei in reversed(graph[node]):
                    if nei == par:
                        continue
                    new_ret = [0, 0]
                    s.append((2, (new_ret, ret)))
                    s.append((1, (node, nei, new_ret)))
            else:
                new_ret, ret = params
                ret[0] += new_ret[0]+new_ret[1]
                ret[1] |= bool(new_ret[0]+new_ret[1])
        return 2*result[0]


",n
"class Solution_Recu(object):
    def minTime(self, n, edges, hasApple):
        def dfs(graph, par, node, hasApple):
            result, extra = 0, int(hasApple[node])
            for nei in graph[node]:
                if nei == par:
                    continue
                count, found = dfs(graph, node, nei, hasApple)
                result += count+found
                extra |= bool(count+found)
            return result, extra
        
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        return 2*dfs(graph, -1, 0, hasApple)[0]


",n
"class Solution2(object):
    def minTime(self, n, edges, hasApple):
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        result = [0]
        s = [(1, (-1, 0, result))]
        while s:
            step, params = s.pop()
            if step == 1:
                par, node, ret = params
                tmp = [int(hasApple[node])]
                s.append((3, (tmp, ret)))
                for nei in reversed(graph[node]):
                    if nei == par:
                        continue
                    new_ret = [0]
                    s.append((2, (new_ret, tmp, ret)))
                    s.append((1, (node, nei, new_ret)))
            elif step == 2:
                new_ret, tmp, ret = params
                ret[0] += new_ret[0]
                tmp[0] |= bool(new_ret[0])
            else:
                tmp, ret = params
                ret[0] += tmp[0]
        return 2*max(result[0]-1, 0)


",n
"class Solution2_Recu(object):
    def minTime(self, n, edges, hasApple):
        def dfs(graph, par, node, has_subtree):
            result, extra = 0, int(hasApple[node])
            for nei in graph[node]:
                if nei == par:
                    continue
                count = dfs(graph, node, nei, hasApple)
                result += count
                extra |= bool(count)
            return result+extra
        
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        return 2*max(dfs(graph, -1, 0, hasApple)-1, 0)
",n
"
class Solution(object):
    def largestSubmatrix(self, matrix):
        for c in range(len(matrix[0])):
            h = 0
            for r in range(len(matrix)):
                h = h+1 if matrix[r][c] == 1 else 0
                matrix[r][c] = h
        result = 0
        for row in matrix:
            row.sort()
            for c in range(len(row)):
                result = max(result, (len(row)-c) * row[c])
        return result
",m * nlogn
"
class Solution(object):
    def numTrees(self, n):
        if n == 0:
            return 1

        def combination(n, k):
            count = 1
            for i in range(1, k + 1):
                count = count * (n - i + 1) / i
            return count

        return combination(2 * n, n) - combination(2 * n, n - 1)

",n
"
class Solution2(object):
    def numTrees(self, n):
        counts = [1, 1]
        for i in range(2, n + 1):
            count = 0
            for j in range(i):
                count += counts[j] * counts[i - j - 1]
            counts.append(count)
        return counts[-1]

",n^2
"
import heapq


class Solution(object):
    def minRefuelStops(self, target, startFuel, stations):
        max_heap = []
        stations.append((target, float(""inf"")))

        result = prev = 0
        for location, capacity in stations:
            startFuel -= location - prev
            while max_heap and startFuel < 0:
                startFuel += -heapq.heappop(max_heap)
                result += 1
            if startFuel < 0:
                return -1
            heapq.heappush(max_heap, -capacity)
            prev = location

        return result

",nlogn
"
import collections
import string

class Solution(object):
    def minDeletions(self, s):
        count = collections.Counter(s)
        result = 0
        lookup = set()
        for c in string.ascii_lowercase:
            for i in reversed(range(1, count[c]+1)):
                if i not in lookup:
                    lookup.add(i)
                    break
                result += 1
        return result
",n
"
class HtmlParser(object):
   def getUrls(self, url):
       pass


class Solution(object):
    def crawl(self, startUrl, htmlParser):
        SCHEME = ""http://""
        def hostname(url):
            pos = url.find('/', len(SCHEME))
            if pos == -1:
                return url
            return url[:pos]

        result = [startUrl]
        lookup = set(result)
        for from_url in result:
            name = hostname(from_url)
            for to_url in htmlParser.getUrls(from_url):
                if to_url not in lookup and name == hostname(to_url):
                    result.append(to_url)
                    lookup.add(to_url)
        return result
",|V| + |E|
"

class Solution(object):
    def countSubarrays(self, nums, k):
        mx = max(nums)
        result = left = cnt = 0
        for right in range(len(nums)):
            cnt += int(nums[right] == mx)
            while cnt == k:
                cnt -= int(nums[left] == mx)
                left += 1
            result += left
        return result


",n
"
class Solution2(object):
    def countSubarrays(self, nums, k):
        mx = max(nums)
        result = (len(nums)+1)*len(nums)//2
        left = cnt = 0
        for right in range(len(nums)):
            cnt += int(nums[right] == mx)
            while cnt == k:
                cnt -= int(nums[left] == mx)
                left += 1
            result -= right-left+1
        return result
",n
"
class Solution(object):
    def maximum69Number (self, num):
        curr, base, change = num, 3, 0
        while curr:
            if curr%10 == 6:
                change = base
            base *= 10
            curr //= 10
        return num+change


",logn
"class Solution2(object):
    def maximum69Number (self, num):
        return int(str(num).replace('6', '9', 1))
",logn
"

class Solution(object):
    def findMinimumTime(self, strength, K):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 

        def ceil_divide(a, b):
            return (a+b-1)//b
    
        adj = [[ceil_divide(strength[i], 1+j*K) for j in range(len(strength))] for i in range(len(strength))]
        return hungarian(adj)[0]


",n^3
"
class Solution2(object):
    def findMinimumTime(self, strength, K):
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        def popcount(x):
            return bin(x).count('1')
    
        dp = [float('inf')]*(1<<len(strength))
        dp[0] = 0
        for mask in range(1, len(dp)):
            x = 1+(popcount(mask)-1)*K
            for i in range(len(strength)):
                if not (mask&(1<<i)):
                    continue
                dp[mask] = min(dp[mask], dp[mask^(1<<i)]+ceil_divide(strength[i], x))
        return dp[-1]
",n ^ 2^n
"

class Solution(object):
    def buildWall(self, height, width, bricks):
        MOD = 10**9+7
        def backtracking(height, width, bricks, total, mask, lookup, patterns):
            if mask in lookup:
                return
            lookup.add(mask)
            if total >= width:
                if total == width:
                    patterns.append(mask^(1<<width))
                return
            for x in bricks:
                backtracking(height, width, bricks, total+x, mask|(1<<(total+x)), lookup, patterns)

        patterns, lookup = [], set()
        backtracking(height, width, bricks, 0, 0, lookup, patterns)
        adj = [[j for j, r2 in enumerate(patterns) if not (r1 & r2)] for r1 in patterns]
        dp = [[1]*len(patterns), [0]*len(patterns)]
        for i in range(height-1):
            dp[(i+1)%2] = [sum(dp[i%2][k] for k in adj[j]) % MOD for j in range(len(patterns))]
        return sum(dp[(height-1)%2]) % MOD


",h * p^2
"
class Solution_TLE(object):
    def buildWall(self, height, width, bricks):
        MOD = 10**9+7
        def backtracking(height, width, bricks, total, mask, lookup, patterns):
            if mask in lookup:
                return
            lookup.add(mask)
            if total >= width:
                if total == width:
                    patterns.append(mask^(1<<width))
                return
            for x in bricks:
                backtracking(height, width, bricks, total+x, mask|(1<<(total+x)), lookup, patterns)

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        patterns, lookup = [], set()
        backtracking(height, width, bricks, 0, 0, lookup, patterns)
        return reduce(lambda x,y: (x+y)%MOD,
                      matrix_mult([[1]*len(patterns)],
                                   matrix_expo([[int((mask1 & mask2) == 0)
                                                 for mask2 in patterns] 
                                                 for mask1 in patterns], height-1))[0],
                      0) 
",p^3 * logh
"

class Solution(object):
    def makeStringsEqual(self, s, target):
        return ('1' in s) == ('1' in target)
",n
"
class Solution(object):
    def eventualSafeNodes(self, graph):
        WHITE, GRAY, BLACK = list(range(3))

        def dfs(graph, node, lookup):
            if lookup[node] != WHITE:
                return lookup[node] == BLACK
            lookup[node] = GRAY
            if any(not dfs(graph, child, lookup) for child in graph[node]):
                return False
            lookup[node] = BLACK
            return True

        lookup = [WHITE]*len(graph)
        return [node for node in range(len(graph)) if dfs(graph, node, lookup)]
",|V| + |E|
"
import collections


class Solution(object):
    def countStudents(self, students, sandwiches):
        count = collections.Counter(students)
        for i, s in enumerate(sandwiches):
            if not count[s]:
                break
            count[s] -= 1
        else:
            i = len(sandwiches)
        return len(sandwiches)-i
",n
"

class Solution(object):
    def buttonWithLongestTime(self, events):
        return -max((events[i][1]-(events[i-1][1] if i-1 >= 0 else 0), -events[i][0])for i in range(len(events)))[1]
",n
"

class Solution(object):
    def numberOfChild(self, n, k):
        q, r = divmod(k, n-1)
        return r if q&1 == 0 else (n-1)-r


",1
"
class Solution2(object):
    def numberOfChild(self, n, k):
        r = k%(2*(n-1))
        return r if r <= n-1 else (n-1)-(r-(n-1))
",1
"

class Solution(object):
    def seePeople(self, heights):
        def count(h, stk):
            cnt = 0
            while stk and stk[-1] < h:
                stk.pop()
                cnt += 1
            if stk:
                cnt += 1
            if not stk or stk[-1] != h:
                stk.append(h)
            return cnt
            
        result = [[0]*len(heights[0]) for _ in range(len(heights))]
        for i in range(len(heights)):
            stk = []
            for j in reversed(range(len(heights[0]))):
                result[i][j] += count(heights[i][j], stk)     
        for j in range(len(heights[0])):
            stk = []
            for i in reversed(range(len(heights))):
                result[i][j] += count(heights[i][j], stk)             
        return result


",m * n
"
class Solution2(object):
    def seePeople(self, heights):
        def count(heights, i, stk):
            cnt = 0
            while stk and heights(stk[-1]) < heights(i):
                stk.pop()
                cnt += 1
            if stk:
                cnt += 1
            if stk and heights(stk[-1]) == heights(i):
                stk.pop()
            stk.append(i)
            return cnt
            
        result = [[0]*len(heights[0]) for _ in range(len(heights))]
        for i in range(len(heights)):
            stk = []
            for j in reversed(range(len(heights[0]))):
                result[i][j] += count(lambda x: heights[i][x], j, stk)     
        for j in range(len(heights[0])):
            stk = []
            for i in reversed(range(len(heights))):
                result[i][j] += count(lambda x: heights[x][j], i, stk)             
        return result


",m * n
"
class Solution3(object):
    def seePeople(self, heights):
        def count(heights, i, stk, add):
            while stk and heights(stk[-1]) < heights(i):
                increase(stk.pop())
            if stk:
                increase(stk[-1])
            if stk and heights(stk[-1]) == heights(i):
                stk.pop()
            stk.append(i)
            
        result = [[0]*len(heights[0]) for _ in range(len(heights))]
        for i in range(len(heights)):
            stk = []
            def increase(x): result[i][x] += 1
            for j in range(len(heights[0])):
                count(lambda x: heights[i][x], j, stk, add)
        for j in range(len(heights[0])):
            stk = []
            def increase(x): result[x][j] += 1
            for i in range(len(heights)):
                count(lambda x: heights[x][j], i, stk, add)
        return result
",m * n
"
class Solution(object):
    def shortestDistance(self, grid):
        def bfs(grid, dists, cnts, x, y):
            dist, m, n = 0, len(grid), len(grid[0])
            visited = [[False for _ in range(n)] for _ in range(m)]

            pre_level = [(x, y)]
            visited[x][y] = True
            while pre_level:
                dist += 1
                cur_level = []
                for i, j in pre_level:
                    for dir in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                        I, J = i+dir[0], j+dir[1]
                        if 0 <= I < m and 0 <= J < n and grid[I][J] == 0 and not visited[I][J]:
                            cnts[I][J] += 1
                            dists[I][J] += dist
                            cur_level.append((I, J))
                            visited[I][J] = True

                pre_level = cur_level


        m, n, cnt = len(grid),  len(grid[0]), 0
        dists = [[0 for _ in range(n)] for _ in range(m)]
        cnts = [[0 for _ in range(n)] for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    cnt += 1
                    bfs(grid, dists, cnts, i, j)

        shortest = float(""inf"")
        for i in range(m):
            for j in range(n):
                if dists[i][j] < shortest and cnts[i][j] == cnt:
                    shortest = dists[i][j]

        return shortest if shortest != float(""inf"") else -1

",k * m * n
"

class Solution(object):
    def evenOddBit(self, n):
        def popcount(x):
            return bin(x)[2:].count('1')

        return [popcount(n&0b0101010101), popcount(n&0b1010101010)]
",1
"
import itertools


class Solution(object):
    def widestPairOfIndices(self, nums1, nums2):
        lookup = {0:-1}
        result = total = 0
        for i, (n1, n2) in enumerate(zip(nums1, nums2)):
            total += n1-n2
            if total not in lookup:
                lookup[total] = i
            result = max(result, i-lookup[total])
        return result
",n
"
import itertools
from functools import reduce


class Solution(object):
    def minDominoRotations(self, A, B):
        intersect = reduce(set.__and__, [set(d) for d in zip(A, B)])
        if not intersect:
            return -1
        x = intersect.pop()
        return min(len(A)-A.count(x), len(B)-B.count(x))
",n
"
class Solution(object):
    def numUniqueEmails(self, emails):
        def convert(email):
            name, domain = email.split('@')
            name = name[:name.index('+')]
            return """".join(["""".join(name.split(""."")), '@', domain])

        lookup = set()
        for email in emails:
            lookup.add(convert(email))
        return len(lookup)
  
",n * l
"

class Solution(object):
    def smallestPalindrome(self, s, k):
        cnt = [0]*26
        for i in range(len(s)//2):
            cnt[ord(s[i])-ord('a')] += 1
        total, count, remain = 0, 1, 0
        for i in reversed(range(len(cnt))):
            for c in range(1, cnt[i]+1):
                total += 1
                count = count*total//c
                if count >= k:
                    remain = cnt[i]-c
                    break
            if count >= k:
                break
        else:
            return """"
        result = []
        for j in range(i+1):
            x = chr(ord('a')+j)
            for _ in range(cnt[j] if j != i else remain):
                cnt[j] -= 1
                result.append(x)
        while total:
            for j in range(i, len(cnt)):
                if not cnt[j]:
                    continue
                new_count = count*cnt[j]//total
                if new_count < k:
                    k -= new_count
                    continue
                count = new_count
                cnt[j] -= 1
                total -= 1
                result.append(chr(ord('a')+j))
                break
        if len(s)%2:
            result.append(s[len(s)//2])
        result.extend((result[i] for i in reversed(range(len(result)-len(s)%2))))
        return """".join(result)
",26 * n
"
import collections


class Solution(object):
    def deckRevealedIncreasing(self, deck):
        d = collections.deque()
        deck.sort(reverse=True)
        for i in deck:
            if d:
                d.appendleft(d.pop())
            d.appendleft(i)
        return list(d)
",n
"
class Solution(object):
    def numSubarrayProductLessThanK(self, nums, k):
        if k <= 1: return 0
        result, start, prod = 0, 0, 1
        for i, num in enumerate(nums):
            prod *= num
            while prod >= k:
                prod /= nums[start]
                start += 1
            result += i-start+1
        return result


",n
"
import math


class Solution(object):
    def constructRectangle(self, area):
        w = int(math.sqrt(area))
        while area % w:
            w -= 1
        return [area // w, w]

",1
"

class Solution(object):
    def maximalNetworkRank(self, n, roads):
        MAX_N = 100
        MAX_NUM = MAX_N-1
        def counting_sort(arr, key=lambda x:x, reverse=False): 
            count = [0]*(MAX_NUM+1)
            for x in arr:
                count[key(x)] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            result = [0]*len(arr)
            if not reverse:
                for x in reversed(arr): 
                    count[key(x)] -= 1
                    result[count[key(x)]] = x
            else:
                for x in arr: 
                    count[key(x)] -= 1
                    result[count[key(x)]] = x
                result.reverse()
            return result

        degree = [0]*n
        adj = collections.defaultdict(set)
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
            adj[a].add(b)
            adj[b].add(a)
        sorted_idx = counting_sort(range(n), key=lambda x:degree[x], reverse=True)
        m = 2
        while m < n:
            if degree[sorted_idx[m]] != degree[sorted_idx[1]]:
                break
            m += 1
        result = degree[sorted_idx[0]] + degree[sorted_idx[1]] - 1 
        for i in range(m-1): 
            for j in range(i+1, m):
                if degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]]) > result: 
                    return degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]])                                                 
        return result


",m + n + k^2
"import collections



class Solution2(object):
    def maximalNetworkRank(self, n, roads):
        degree = [0]*n
        adj = collections.defaultdict(set)
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
            adj[a].add(b)
            adj[b].add(a)
        sorted_idx = list(range(n))
        sorted_idx.sort(key=lambda x:-degree[x])
        m = 2
        while m < n:
            if degree[sorted_idx[m]] != degree[sorted_idx[1]]:
                break
            m += 1
        result = degree[sorted_idx[0]] + degree[sorted_idx[1]] - 1 
        for i in range(m-1): 
            for j in range(i+1, m):
                if degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]]) > result: 
                    return degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]])                                                 
        return result


",m + nlogn + k^2
"import collections


class Solution3(object):
    def maximalNetworkRank(self, n, roads):
        degree = [0]*n
        adj = collections.defaultdict(set)
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
            adj[a].add(b)
            adj[b].add(a)
        result = 0
        for i in range(n-1):
            for j in range(i+1, n):
                result = max(result, degree[i]+degree[j]-int(i in adj and j in adj[i]))
        return result
",m + n^2
"
import collections


class Solution(object):
    def totalFruit(self, tree):
        count = collections.defaultdict(int)
        result, i = 0, 0
        for j, v in enumerate(tree):
            count[v] += 1
            while len(count) > 2:
                count[tree[i]] -= 1
                if count[tree[i]] == 0:
                    del count[tree[i]]
                i += 1
            result = max(result, j-i+1)
        return result
 

",n
"
import random




class Solution(object):
    def minimumCost(self, nums):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        def nearest_palindromic(x):
            n = str(x)
            l = len(n)
            result = {10**l+1, 10**(l-1)-1}
            prefix = int(n[:(l+1)/2])
            for i in map(str, (prefix-1, prefix, prefix+1)):
                result.add(int(i+[i, i[:-1]][l%2][::-1]))
            return result

        nth_element(nums, len(nums)//2)
        median = nums[len(nums)//2]
        if len(nums)%2 == 0:
            nth_element(nums, len(nums)//2-1)
            median = (median+nums[len(nums)//2-1])//2
        return min(sum(abs(x-p) for x in nums) for p in nearest_palindromic(median))


",n + logr
"

class Solution2(object):
    def minimumCost(self, nums):
        def nearest_palindromic(x):
            n = str(x)
            l = len(n)
            result = {10**l+1, 10**(l-1)-1}
            prefix = int(n[:(l+1)/2])
            for i in map(str, (prefix-1, prefix, prefix+1)):
                result.add(int(i+[i, i[:-1]][l%2][::-1]))
            return result
    
        nums.sort()
        median = nums[len(nums)//2]
        if len(nums)%2 == 0:
            median = (median+nums[len(nums)//2-1])//2
        return min(sum(abs(x-p) for x in nums) for p in nearest_palindromic(median))
",nlogn + logr
"

class Solution(object):
    def sortArray(self, nums):
        def min_moves(d):
            def index(x):
                return d*(len(nums)-1) if x == 0 else x-d

            lookup = [False]*len(nums)
            result = len(nums)
            for i in range(len(nums)):
                if lookup[nums[i]]:
                    continue
                l = 0
                while not lookup[nums[i]]:
                    lookup[nums[i]] = True
                    l += 1
                    i = index(nums[i])
                result -= 1
                if l >= 2:
                    result += 2
            return result-2*int(nums[d*(len(nums)-1)] != 0)

        return min(min_moves(0), min_moves(1))


",n
"
class Solution2(object):
    def sortArray(self, nums):
        def min_moves(d):
            def index(x):
                return d*(len(nums)-1) if x == 0 else x-d

            a = nums[:]
            result = 0
            for i in range(len(a)):
                l, has_zero = 1, (a[i] == 0)
                while index(a[i]) != i:
                    j = index(a[i])
                    a[i], a[j] = a[j], a[i]
                    l += 1
                    has_zero |= (a[i] == 0)
                if l >= 2:
                    result += l-1 if has_zero else l+1
            return result

        return min(min_moves(0), min_moves(1))
",n
"
import collections



class Solution(object):
    def equalDigitFrequency(self, s):
        MOD = 10**9+7
        D = 27
        lookup = set()
        for i in range(len(s)):
            cnt = collections.Counter()
            h = max_cnt = 0
            for j in range(i, len(s)):
                d = ord(s[j])-ord('0')+1
                h = (h*D+d)%MOD
                cnt[d] += 1
                max_cnt = max(max_cnt, cnt[d])
                if len(cnt)*max_cnt == j-i+1:
                    lookup.add(h)
        return len(lookup)
",n^2
"

class Solution(object):
    def maxChunksToSorted(self, arr):
        result, increasing_stk = 0, []
        for num in arr:
            max_num = num if not increasing_stk else max(increasing_stk[-1], num)
            while increasing_stk and increasing_stk[-1] > num:
                increasing_stk.pop()
            increasing_stk.append(max_num)
        return len(increasing_stk)


",n
"class Solution2(object):
    def maxChunksToSorted(self, arr):
        def compare(i1, i2):
            return arr[i1]-arr[i2] if arr[i1] != arr[i2] else i1-i2

        idxs = [i for i in range(len(arr))]
        result, max_i = 0, 0
        for i, v in enumerate(sorted(idxs, cmp=compare)):
            max_i = max(max_i, v)
            if max_i == i:
                result += 1
        return result

",nlogn
"
class Solution(object):
    def minimizeTheDifference(self, mat, target):
        chosen_min = sum(min(row) for row in mat)
        if chosen_min >= target:
            return chosen_min-target
        dp = {0}
        for row in mat:
            dp = {total+x for total in dp for x in row if (total+x)-target < target-chosen_min}
        return min(abs(target-total) for total in dp)
",t * m * n
"
class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def minCostToSupplyWater(self, n, wells, pipes):
        w = [[c, 0, i] for i, c in enumerate(wells, 1)]
        p = [[c, i, j] for i, j, c in pipes]
        result = 0
        union_find = UnionFind(n+1)
        for c, x, y in sorted(w+p):
            if not union_find.union_set(x, y):
                continue
            result += c
            if union_find.count == 1:
                break
        return result
",nlogn
"
import collections


class Solution(object):
    def isAnagram(self, s, t):
        if len(s) != len(t):
            return False
        count = collections.defaultdict(int)
        for c in s:
            count[c] += 1
        for c in t:
            count[c] -= 1
            if count[c] < 0:
                return False
        return True


",n
"class Solution2(object):
    def isAnagram(self, s, t):
        return collections.Counter(s) == collections.Counter(t)


",n
"class Solution3(object):
    def isAnagram(self, s, t):
        return sorted(s) == sorted(t)

",nlogn
"

def linear_sieve_of_eratosthenes(n): 
    primes = []
    spf = [-1]*(n+1) 
    for i in range(2, n+1):
        if spf[i] == -1:
            spf[i] = i
            primes.append(i)
        for p in primes:
            if i*p > n or p > spf[i]:
                break
            spf[i*p] = p
    return primes


MAX_N = 10**5
PRIMES = linear_sieve_of_eratosthenes(int(MAX_N**0.5))
class Solution(object):
    def smallestValue(self, n):
        while True:
            curr, new_n = n, 0
            for p in PRIMES:
                if p**2 > curr:
                    break
                while curr%p == 0:
                    curr //= p
                    new_n += p
            if curr > 1: 
                new_n += curr
            if new_n == n:
                break
            n = new_n
        return n
",s * logn
"

class Solution(object):
    def countSubarrays(self, nums, k):
        result = total = left = 0
        for right in range(len(nums)):
            total += nums[right]
            while total*(right-left+1) >= k:
                total -= nums[left]
                left += 1
            result += right-left+1
        return result
",n
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def preorderTraversal(self, root):
        result, curr = [], root
        while curr:
            if curr.left is None:
                result.append(curr.val)
                curr = curr.right
            else:
                node = curr.left
                while node.right and node.right != curr:
                    node = node.right

                if node.right is None:
                    result.append(curr.val)
                    node.right = curr
                    curr = curr.left
                else:
                    node.right = None
                    curr = curr.right

        return result


",n
"
class Solution2(object):
    def preorderTraversal(self, root):
        result, stack = [], [(root, False)]
        while stack:
            root, is_visited = stack.pop()
            if root is None:
                continue
            if is_visited:
                result.append(root.val)
            else:
                stack.append((root.right, False))
                stack.append((root.left, False))
                stack.append((root, True))
        return result

",n
"
import itertools


class Solution(object):
    def climbStairs(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) \
                     for col in ZB] for row in A]

        T = [[1, 1],
             [1, 0]]
        return matrix_mult([[1,  0]], matrix_expo(T, n))[0][0] 


",logn
"class Solution2(object):
    def climbStairs(self, n):
        prev, current = 0, 1
        for i in range(n):
            prev, current = current, prev + current,
        return current
",n
"
class Solution(object):
    def minSkips(self, dist, speed, hoursBefore):
        def ceil(a, b):
            return (a+b-1)//b

        dp = [0]*((len(dist)-1)+1) 
        for i, d in enumerate(dist):
            for j in reversed(range(len(dp))):
                dp[j] = ceil(dp[j]+d, speed)*speed if i < len(dist)-1 else dp[j]+d
                if j-1 >= 0:
                    dp[j] = min(dp[j], dp[j-1]+d)
        target = hoursBefore*speed
        for i in range(len(dist)):
            if dp[i] <= target:
                return i
        return -1
",n^2
"
class Solution(object):
    def encode(self, num):
        result = []
        while num:
            result.append('0' if num%2 else '1')
            num = (num-1)//2
        return """".join(reversed(result))
",logn
"
class Solution(object):
    def chalkReplacer(self, chalk, k):
        k %= sum(chalk)
        for i, x in enumerate(chalk):
            if k < x:
                return i
            k -= x
        return -1
",n
"

class Solution(object):
    def distinctNames(self, ideas):
        lookup = [set() for _ in range(26)]
        for x in ideas:
            lookup[ord(x[0])-ord('a')].add(x[1:])
        result = 0
        for i in range(len(lookup)):
            for j in range(i+1, len(lookup)):
                common = len(lookup[i]&lookup[j])
                result += (len(lookup[i])-common)*(len(lookup[j])-common)
        return result*2
",26 * n * l
"

class Solution(object):
    def longestSemiRepetitiveSubstring(self, s):
        result = left = prev = 0
        for right in range(len(s)):
            if right-1 >= 0 and s[right-1] == s[right]:
                left, prev = prev, right
            result = max(result, right-left+1)
        return result
",n
"

class Solution(object):
    def edgeScore(self, edges):
        score = [0]*len(edges)
        for u, v in enumerate(edges):
            score[v] += u
        return max(range(len(edges)), key=lambda x:score[x])
    
",n
"


import collections


class AhoNode(object):
    def __init__(self):
        self.children = collections.defaultdict(AhoNode)
        self.indices = []
        self.suffix = None
        self.output = None


class AhoTrie(object):
    def step(self, letter):
        while self.__node and letter not in self.__node.children:
            self.__node = self.__node.suffix
        self.__node = self.__node.children[letter] if self.__node else self.__root
        return self.__get_ac_node_outputs(self.__node)
    
    def __init__(self, patterns):
        self.__root = self.__create_ac_trie(patterns)
        self.__node = self.__create_ac_suffix_and_output_links(self.__root)
        self.__lookup = set() 
    
    def __create_ac_trie(self, patterns): 
        root = AhoNode()
        for i, pattern in enumerate(patterns):
            node = root
            for c in pattern:
                node = node.children[c]
            node.indices.append(i)
        return root

    def __create_ac_suffix_and_output_links(self, root): 
        queue = collections.deque()
        for node in root.children.values():
            queue.append(node)
            node.suffix = root

        while queue:
            node = queue.popleft()
            for c, child in node.children.items():
                queue.append(child)
                suffix = node.suffix
                while suffix and c not in suffix.children:
                    suffix = suffix.suffix
                child.suffix = suffix.children[c] if suffix else root
                child.output = child.suffix if child.suffix.indices else child.suffix.output
                
        return root

    def __get_ac_node_outputs(self, node): 
        result = []
        if node not in self.__lookup: 
            self.__lookup.add(node) 
            for i in node.indices:
                result.append(i)
            output = node.output
            while output and output not in self.__lookup: 
                self.__lookup.add(output) 
                for i in output.indices:
                    result.append(i)
                output = output.output
        return result



class Solution(object):
    def numOfStrings(self, patterns, word):
        trie = AhoTrie(patterns)
        return sum(len(trie.step(c)) for c in word)


",n * l + m
"


class Solution2(object):
    def numOfStrings(self, patterns, word):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
            
        def kmp(text, pattern):
            if not pattern:
                return 0
            prefix = getPrefix(pattern)
            if len(text) < len(pattern):
                return -1
            j = -1
            for i in range(len(text)):
                while j != -1 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1
        
        return sum(kmp(word, pattern) != -1 for pattern in patterns)


",n * (l + m)
"


class Solution3(object):
    def numOfStrings(self, patterns, word):
        return sum(pattern in word for pattern in patterns)
",n * m * l
"

class Solution(object):
    def minMaxDifference(self, num):
        def f(dst):
            result = 0
            base = 1
            while base <= num:
                base *= 10
            base //= 10
            src = -1
            while base:
                d = num//base%10
                if src == -1 and d != dst:
                    src = d
                result += base*(dst if d == src else d)
                base //= 10
            return result
    
        return f(9)-f(0)
",logn
"
class Solution(object):
    def reverseWords(self, s):
        return ' '.join(reversed(s.split()))

",n
"

class Solution(object):
    def minOperations(self, nums, k):
        return sum(x < k for x in nums)
",n
"
class Solution(object):
    def maxScore(self, s):
        result, zeros, ones = 0, 0, 0
        for i in range(1, len(s)-1):
            if s[i] == '0':
                zeros += 1
            else:
                ones += 1
            result = max(result, zeros-ones)
        return result + ones + (s[0] == '0') + (s[-1] == '1')
",n
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

    def __repr__(self):
        if self:
            return ""{} -> {}"".format(self.val, self.__next__)

class Solution(object):
    def swapPairs(self, head):
        dummy = ListNode(0)
        dummy.next = head
        current = dummy
        while current.__next__ and current.next.__next__:
            next_one, next_two, next_three = current.__next__, current.next.__next__, current.next.next.__next__
            current.next = next_two
            next_two.next = next_one
            next_one.next = next_three
            current = next_one
        return dummy.__next__

",n
"

class Solution(object):
    def maxDivScore(self, nums, divisors):
        return max(divisors, key=lambda d: (sum(x%d == 0 for x in nums), -d))
",n * d
"
class Solution(object):
    def lastSubstring(self, s):
        left, right, l = 0, 1, 0
        while right+l < len(s):
            if s[left+l] == s[right+l]:
                l += 1
                continue
            if s[left+l] > s[right+l]:
                right += l+1
            else:
                left = max(right, left+l+1)
                right = left+1
            l = 0
        return s[left:]


",n
"import collections


class Solution2(object):
    def lastSubstring(self, s):
        count = collections.defaultdict(list)
        for i in range(len(s)):
            count[s[i]].append(i)

        max_c = max(count.keys())
        starts = {}
        for i in count[max_c]:
            starts[i] = i+1
        while len(starts)-1 > 0:
            lookup = set()
            next_count = collections.defaultdict(list)
            for start, end in starts.items():
                if end == len(s): 
                    lookup.add(start)
                    continue
                next_count[s[end]].append(start)				
                if end in starts: 
                    lookup.add(end)			
            next_starts = {}
            max_c = max(next_count.keys())
            for start in next_count[max_c]:
                if start not in lookup:
                    next_starts[start] = starts[start]+1
            starts = next_starts
        return s[next(iter(starts.keys())):]
",n
"

class Solution(object):
    def getGoodIndices(self, variables, target):
        return [i for i, (a, b, c, m) in enumerate(variables) if pow(pow(a, b, 10), c, m) == target]
",n * (logb + logc)
"
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    head = None
    def sortedListToBST(self, head):
        current, length = head, 0
        while current is not None:
            current, length = current.__next__, length + 1
        self.head = head
        return self.sortedListToBSTRecu(0, length)

    def sortedListToBSTRecu(self, start, end):
        if start == end:
            return None
        mid = start + (end - start) / 2
        left = self.sortedListToBSTRecu(start, mid)
        current = TreeNode(self.head.val)
        current.left = left
        self.head = self.head.__next__
        current.right = self.sortedListToBSTRecu(mid + 1, end)
        return current

",n
"
import collections


class Solution(object):
    def shortestPathBinaryMatrix(self, grid):
        directions = [(-1, -1), (-1, 0), (-1, 1), \
                      ( 0, -1), ( 0, 1), \
                      ( 1, -1), ( 1, 0), ( 1, 1)]
        result = 0
        q = collections.deque([(0, 0)])
        while q:
            result += 1
            next_depth = collections.deque()
            while q:
                i, j = q.popleft()
                if 0 <= i < len(grid) and \
                   0 <= j < len(grid[0]) and \
                    not grid[i][j]:
                    grid[i][j] = 1
                    if i == len(grid)-1 and j == len(grid)-1:
                        return result
                    for d in directions:
                        next_depth.append((i+d[0], j+d[1]))
            q = next_depth
        return -1
",n^2
"
import math



class Solution(object):
    def findTheArrayConcVal(self, nums):
        return sum((nums[i]*10**(int(math.log10(nums[~i]))+1) for i in range(len(nums)//2)))+sum(nums[i] for i in range(len(nums)//2, len(nums)))
",nlogr
"
import collections


class Solution(object):
    def canPermutePalindrome(self, s):
        return sum(v % 2 for v in list(collections.Counter(s).values())) < 2

",n
"
class Solution(object):
    def sumEvenAfterQueries(self, A, queries):
        total = sum(v for v in A if v % 2 == 0)
        
        result = []
        for v, i in queries:
            if A[i] % 2 == 0:
                total -= A[i]
            A[i] += v
            if A[i] % 2 == 0:
                total += A[i]
            result.append(total)
        return result
",n + q
"
import itertools
from sortedcontainers import SortedList



class Solution(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        def query(sl, k):
            j = sl.bisect_left((k,))
            return sl[j-1][1] if j-1 >= 0 else NEG_INF
    
        def update(sl, k, v):
            j = sl.bisect_left((k,))
            if j < len(sl) and sl[j][0] == k:
                if not (sl[j][1] < v):
                    return
                del sl[j]
            elif not (j-1 < 0 or sl[j-1][1] < v):
                return
            sl.add((k, v))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]

        result = NEG_INF
        sl1, sl2 = SortedList(), SortedList()
        for price, profit in zip(prices, profits):
            result = max(result, query(sl2, price)+profit)
            update(sl1, price, profit)
            update(sl2, price, query(sl1, price)+profit)
        return result if result != NEG_INF else -1


",nlogn
"from sortedcontainers import SortedList



class Solution2(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")

        right = [NEG_INF]*len(prices)
        sl = SortedList()
        for i in reversed(range(len(prices))):
            j = sl.bisect_left((-prices[i],))
            if j-1 >= 0:
                right[i] = sl[j-1][1]
            if not (j-1 < 0 or sl[j-1][1] < profits[i]):
                continue
            sl.add((-prices[i], profits[i]))
            j = sl.bisect_left((-prices[i], profits[i]))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]
        result = NEG_INF
        sl = SortedList()
        for i in range(len(prices)):
            j = sl.bisect_left((prices[i],))
            if j-1 >= 0:
                result = max(result, sl[j-1][1]+profits[i]+right[i])
            if not (j-1 < 0 or sl[j-1][1] < profits[i]):
                continue
            sl.add((prices[i], profits[i]))
            j = sl.bisect_left((prices[i], profits[i]))
            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:
                del sl[j+1]
        return result if result != NEG_INF else -1


",nlogn
"import itertools



class Solution3(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        class BIT(object): 
            def __init__(self, n, default=0, fn=lambda x, y: x+y):
                self.__bit = [NEG_INF]*(n+1) 
                self.__default = default
                self.__fn = fn

            def update(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] = self.__fn(self.__bit[i], val)
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = self.__default
                while i > 0:
                    ret = self.__fn(ret, self.__bit[i])
                    i -= (i & -i)
                return ret

        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}
        result = NEG_INF
        bit1, bit2 = BIT(len(price_to_idx), default=NEG_INF, fn=max), BIT(len(price_to_idx), default=NEG_INF, fn=max)
        for price, profit in zip(prices, profits):
            result = max(result, bit2.query(price_to_idx[price]-1)+profit)
            bit1.update(price_to_idx[price], profit)
            bit2.update(price_to_idx[price], bit1.query(price_to_idx[price]-1)+profit)
        return result if result != NEG_INF else -1


",nlogn
"import itertools



class Solution4(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y),
                         update_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(self.tree[x], h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}
        result = NEG_INF
        st1, st2 = SegmentTree(len(price_to_idx)), SegmentTree(len(price_to_idx))
        for price, profit in zip(prices, profits):
            mx2 = st2.query(0, price_to_idx[price]-1)
            if mx2 is not None:
                result = max(result, mx2+profit)
            st1.update(price_to_idx[price], profit)
            mx1 = st1.query(0, price_to_idx[price]-1)
            if mx1 is not None:
                st2.update(price_to_idx[price], mx1+profit)
        return result if result != NEG_INF else -1


",nlogn
"
class Solution5(object):
    def maxProfit(self, prices, profits):
        NEG_INF = float(""-inf"")
        class SegmentTree(object):
            def __init__(self, N,
                         build_fn=lambda _: None,
                         query_fn=lambda x, y: max(x, y),
                         update_fn=lambda x, y: max(x, y)):
                self.tree = [None]*(2*2**((N-1).bit_length()))
                self.base = len(self.tree)//2
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(self.tree[x], h)
                while x > 1:
                    x //= 2
                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

            def query(self, L, R):
                if L > R:
                    return None
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L //= 2
                    R //= 2
                return self.query_fn(left, right)

        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}
        right = [NEG_INF]*len(prices)
        st = SegmentTree(len(price_to_idx))
        for i in reversed(range(len(prices))):
            right[i] = st.query(price_to_idx[prices[i]]+1, len(price_to_idx)-1)
            st.update(price_to_idx[prices[i]], profits[i])
        result = NEG_INF
        st = SegmentTree(len(price_to_idx))
        for i in range(len(prices)):
            left = st.query(0, price_to_idx[prices[i]]-1)
            if left is not None and right[i] is not None:
                result = max(result, left+profits[i]+right[i])
            st.update(price_to_idx[prices[i]], profits[i])
        return result if result != NEG_INF else -1
",nlogn
"
import collections


class Solution(object):
    def findAllPeople(self, n, meetings, firstPerson):
        meetings.sort(key=lambda x: x[2])
        result = {0, firstPerson}
        adj = collections.defaultdict(list)
        for i, (x, y, _) in enumerate(meetings):
            adj[x].append(y)
            adj[y].append(x)
            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:
                continue
            q = [i for i in adj.keys() if i in result]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if v in result:
                            continue
                        result.add(v)
                        new_q.append(v)
                q = new_q
            adj = collections.defaultdict(list)
        return list(result)


",nlogn
"import collections


class Solution2(object):
    def findAllPeople(self, n, meetings, firstPerson):
        meetings.sort(key=lambda x: x[2])
        result = {0, firstPerson}
        adj = collections.defaultdict(list)
        for i, (x, y, _) in enumerate(meetings):
            adj[x].append(y)
            adj[y].append(x)
            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:
                continue
            stk = [i for i in adj.keys() if i in result]
            while stk:
                u = stk.pop()
                for v in adj[u]:
                    if v in result:
                        continue
                    result.add(v)
                    stk.append(v)
            adj = collections.defaultdict(list)
        return list(result)


",nlogn
"class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True

    def reset(self, x):
        self.set[x] = x
        self.rank[x] = 0


class Solution3(object):
    def findAllPeople(self, n, meetings, firstPerson):
        meetings.sort(key=lambda x: x[2])
        uf = UnionFind(n)
        uf.union_set(0, firstPerson)
        group = set()
        for i, (x, y, _) in enumerate(meetings):
            group.add(x)
            group.add(y)
            uf.union_set(x, y)
            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:
                continue
            while group:
                x = group.pop()
                if uf.find_set(x) != uf.find_set(0):
                    uf.reset(x)
        return [i for i in range(n) if uf.find_set(i) == uf.find_set(0)]
",nlogn
"

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def isCousins(self, root, x, y):
        def dfs(root, x, depth, parent):
            if not root:
                return False
            if root.val == x:
                return True
            depth[0] += 1
            prev_parent, parent[0] = parent[0], root
            if dfs(root.left, x, depth, parent):
                return True
            parent[0] = root
            if dfs(root.right, x, depth, parent):
                return True
            parent[0] = prev_parent
            depth[0] -= 1
            return False
        
        depth_x, depth_y = [0], [0]
        parent_x, parent_y = [None], [None]
        return dfs(root, x, depth_x, parent_x) and \
               dfs(root, y, depth_y, parent_y) and \
               depth_x[0] == depth_y[0] and \
               parent_x[0] != parent_y[0]
                
        
",n
"
import collections



class Solution(object):
    def minimumSeconds(self, nums):
        lookup = collections.defaultdict(int)
        dist = collections.defaultdict(int)
        for i in range(2*len(nums)):
            x = nums[i%len(nums)]
            dist[x] = max(dist[x], i-lookup[x])
            lookup[x] = i
        return min(dist.values())//2
",n
"
import bisect



class Solution(object):
    def fullBloomFlowers(self, flowers, persons):
        cnt = collections.Counter()
        for s, e in flowers:
            cnt[s] += 1
            cnt[e+1] -= 1
        events = sorted(cnt.keys())
        prefix = [0]
        for x in events:
            prefix.append(prefix[-1]+cnt[x])
        return [prefix[bisect.bisect_right(events, t)] for t in persons]


",nlogn + mlogn
"import bisect



class Solution(object):
    def fullBloomFlowers(self, flowers, persons):
        starts, ends = [], []
        for s, e in flowers:
            starts.append(s)
            ends.append(e+1)
        starts.sort()
        ends.sort()
        return [bisect.bisect_right(starts, t)-bisect.bisect_right(ends, t) for t in persons]
",nlogn + mlogn
"
class Solution(object):
    def minCut(self, s):
        lookup = [[False for j in range(len(s))] for i in range(len(s))]
        mincut = [len(s) - 1 - i for i in range(len(s) + 1)]

        for i in reversed(range(len(s))):
            for j in range(i, len(s)):
                if s[i] == s[j]  and (j - i < 2 or lookup[i + 1][j - 1]):
                    lookup[i][j] = True
                    mincut[i] = min(mincut[i], mincut[j + 1] + 1)

        return mincut[0]

",n^2
"
import bisect


class Solution(object):
    def nextGreatestLetter(self, letters, target):
        i = bisect.bisect_right(letters, target)
        return letters[0] if i == len(letters) else letters[i]

",logn
"

class Solution(object):
    def maximumPoints(self, edges, coins, k):
        NEG_INF = float(""-inf"")
        def dfs(u, p, base):
            if base >= max_base:
                return 0
            if lookup[u]&base: 
                return NEG_INF
            lookup[u] |= base
            return max(((coins[u]//base)-k)+sum(dfs(v, u, base) for v in adj[u] if v != p),
                        (coins[u]//(base<<1))+sum(dfs(v, u, base<<1) for v in adj[u] if v != p) if (coins[u]//base)-k < coins[u]//(base*2) else NEG_INF) 

        adj = [[] for _ in range(len(coins))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        max_base = 1<<max(coins).bit_length()
        lookup = [0]*len(coins)
        return dfs(0, -1, 1)


",nlogr
"
class Solution2(object):
    def maximumPoints(self, edges, coins, k):
        def memoization(u, p, d):
            if d >= max_d:
                return 0
            if lookup[u][d] is None:
                lookup[u][d] = max(((coins[u]>>d)-k)+sum(memoization(v, u, d) for v in adj[u] if v != p),
                                    (coins[u]>>(d+1))+sum(memoization(v, u, d+1) for v in adj[u] if v != p))
            return lookup[u][d]

        adj = [[] for _ in range(len(coins))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        max_d = max(coins).bit_length()
        lookup = [[None]*max_d for _ in range(len(coins))]
        return memoization(0, -1, 0)
",nlogr
"

class Solution(object):
    def minDifference(self, nums):
        def binary_search(left, right, check):
            while left <= right:
                mid = left+(right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def check(d):
            prev = cnt = 0
            for i in range(len(nums)):
                if nums[i] == -1:
                    cnt += 1
                    continue
                if prev and cnt and min(max(abs(prev-x), abs(nums[i]-x)) for x in (left+d, right-d)) > d and (cnt == 1 or (right-d)-(left+d) > d):
                    return False
                prev = nums[i]
                cnt = 0
            return True

        max_diff, left, right = 0, float(""inf""), 0
        for i in range(len(nums)):  
            if nums[i] != -1:
                if i+1 < len(nums) and nums[i+1] != -1:
                    max_diff = max(max_diff, abs(nums[i]-nums[i+1]))  
                continue          
            if i-1 < len(nums) and nums[i-1] != -1:
                left = min(left, nums[i-1])
                right = max(right, nums[i-1])
            if i+1 < len(nums) and nums[i+1] != -1:
                left = min(left, nums[i+1])
                right = max(right, nums[i+1])
        return binary_search(max_diff, (right-left)//2, check)
",nlogr
"

class Solution(object):
    def maximumLength(self, s):
        lookup = [[0]*3 for _ in range(26)]
        result = cnt = 0
        for i, c in enumerate(s):
            cnt += 1
            if i+1 != len(s) and s[i+1] == s[i]:
                continue
            curr = lookup[ord(c)-ord('a')]
            for j in range(len(curr)):
                if curr[j] < cnt:
                    cnt, curr[j] = curr[j], cnt
            cnt = 0
            result = max(result, max(curr[0]-2, min(curr[0]-1, curr[1]), curr[2]))
        return result if result else -1


",26 * 3 + n * 3
"
class Solution2(object):
    def maximumLength(self, s):
        lookup = [[0] for _ in range(26)]
        result = 0
        for i, c in enumerate(s):
            curr = lookup[ord(c)-ord('a')]
            for j in range(i, len(s)):
                if s[j] != s[i]:
                    break
                if j-i+1 == len(curr):
                    curr.append(0)
                curr[j-i+1] += 1
                if curr[j-i+1] == 3:
                    result = max(result, j-i+1)
        return result if result else -1
",26 + n^2
"
class Solution(object):
    def sumGame(self, num):
        cnt = total = 0
        for i in range(len(num)):
            if num[i] == '?':
                cnt += (-1 if i < len(num)//2 else 1)
            else:
                total += (int(num[i]) if i < len(num)//2 else -int(num[i]))
        return True if cnt%2 else total != cnt//2*9
",n
"
class Solution(object):
    def numEnclaves(self, A):
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        def dfs(A, i, j):
            if not (0 <= i < len(A) and 0 <= j < len(A[0]) and A[i][j]):
                return
            A[i][j] = 0
            for d in directions:
                dfs(A, i+d[0], j+d[1])
        
        for i in range(len(A)):
            dfs(A, i, 0)
            dfs(A, i, len(A[0])-1)
        for j in range(1, len(A[0])-1):
            dfs(A, 0, j)
            dfs(A, len(A)-1, j)
        return sum(sum(row) for row in A)
  
",m * n
"
class Solution(object):
    def largestNumber(self, cost, target):
        dp = [0]
        for t in range(1, target+1):
            dp.append(-1)
            for i, c in enumerate(cost):
                if t-c < 0 or dp[t-c] < 0:
                    continue
                dp[t] = max(dp[t], dp[t-c]+1)
        if dp[target] < 0:
            return ""0""
        result = []
        for i in reversed(range(9)):
            while target >= cost[i] and dp[target] == dp[target-cost[i]]+1:
                target -= cost[i]
                result.append(i+1)
        return """".join(map(str, result))


",t
"class Solution2(object):
    def largestNumber(self, cost, target):
        def key(bag):
            return sum(bag), bag
        
        dp = [[0]*9]
        for t in range(1, target+1):
            dp.append([])
            for d, c in enumerate(cost):
                if t < c or not dp[t-c]:
                    continue
                curr = dp[t-c][:]
                curr[~d] += 1
                if key(curr) > key(dp[t]):
                    dp[-1] = curr        
        if not dp[-1]:
            return ""0""
        return """".join(str(9-i)*c for i, c in enumerate(dp[-1]))


",t
"class Solution3(object):
    def largestNumber(self, cost, target):
        dp = [0]
        for t in range(1, target+1):
            dp.append(-1)
            for i, c in enumerate(cost):
                if t-c < 0:
                    continue
                dp[t] = max(dp[t], dp[t-c]*10 + i+1)
        return str(max(dp[t], 0))
",t^2
"

class Solution(object):
    def numSubmat(self, mat):
        def count(heights):
            result = curr = 0
            stk = []
            for i in range(len(heights)):
                while stk and heights[stk[-1]] >= heights[i]:
                    j = stk.pop()
                    curr -= (heights[j]-heights[i])*(j-(stk[-1] if stk else -1))
                stk.append(i)
                curr += heights[i]
                result += curr
            return result

        result = 0
        heights = [0]*len(mat[0])
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                heights[j] = heights[j]+1 if mat[i][j] == 1 else 0
            result += count(heights)
        return result


",m * n
"
class Solution2(object):
    def numSubmat(self, mat):
        def count(heights):
            dp, stk = [0]*len(heights), []
            for i in range(len(heights)):
                while stk and heights[stk[-1]] >= heights[i]:
                    stk.pop()
                dp[i] = dp[stk[-1]] + heights[i]*(i-stk[-1]) if stk else heights[i]*(i-(-1))
                stk.append(i)
            return sum(dp)

        result = 0
        heights = [0]*len(mat[0])
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                heights[j] = heights[j]+1 if mat[i][j] == 1 else 0
            result += count(heights)
        return result
",m * n
"
import itertools


class Solution(object):
    def canConvert(self, str1, str2):
        if str1 == str2:
            return True
        lookup = {}
        for i, j in zip(str1, str2):
            if lookup.setdefault(i, j) != j:
                return False
        return len(set(str2)) < 26
",n
"
class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n+1))
        self.size = [1]*(n+1)
        self.size[-1] = 0

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        self.size[max(x_root, y_root)] += self.size[min(x_root, y_root)]
        return True

    def top(self):
        return self.size[self.find_set(len(self.size)-1)]


class Solution(object):
    def hitBricks(self, grid, hits):
        def index(C, r, c):
            return r*C+c

        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        R, C = len(grid), len(grid[0])

        hit_grid = [row[:] for row in grid]
        for i, j in hits:
            hit_grid[i][j] = 0

        union_find = UnionFind(R*C)
        for r, row in enumerate(hit_grid):
            for c, val in enumerate(row):
                if not val:
                    continue
                if r == 0:
                    union_find.union_set(index(C, r, c), R*C)
                if r and hit_grid[r-1][c]:
                    union_find.union_set(index(C, r, c), index(C, r-1, c))
                if c and hit_grid[r][c-1]:
                    union_find.union_set(index(C, r, c), index(C, r, c-1))

        result = []
        for r, c in reversed(hits):
            prev_roof = union_find.top()
            if grid[r][c] == 0:
                result.append(0)
                continue
            for d in directions:
                nr, nc = (r+d[0], c+d[1])
                if 0 <= nr < R and 0 <= nc < C and hit_grid[nr][nc]:
                    union_find.union_set(index(C, r, c), index(C, nr, nc))
            if r == 0:
                union_find.union_set(index(C, r, c), R*C)
            hit_grid[r][c] = 1
            result.append(max(0, union_find.top()-prev_roof-1))
        return result[::-1]

",r * c
"

class Solution(object):
    def findMinimumTime(self, strength):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 

        K = 1
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        adj = [[ceil_divide(strength[i], 1+j*K) for j in range(len(strength))] for i in range(len(strength))]
        return hungarian(adj)[0]
",n^3
"

class Solution(object):
    def removeAlmostEqualCharacters(self, word):
        result = 0
        for i in range(len(word)-1):
            if (i+1)+result >= len(word):
                break
            if abs(ord(word[(i+1)+result])-ord(word[i+result])) <= 1:
                result += 1
        return result
",n
"

class Solution(object):
    def deleteGreatestValue(self, grid):
        for row in grid:
            row.sort()
        return sum(max(grid[i][j] for i in range(len(grid))) for j in range(len(grid[0])))
",m * nlogn
"

class Solution(object):
    def distributeCandies(self, n, limit):
        def nCr(n, r): 
            if not 0 <= r <= n:
                return 0
            if n-r < r:
                r = n-r
            c = 1
            for k in range(1, r+1):
                c *= n-k+1
                c //= k
            return c
        
        def nHr(n, r):
            return nCr(n+(r-1), r-1)
    
        R = 3
        return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R) for r in range(R+1))
",1
"

class Solution(object):
    def minimumSum(self, n, k):
        def arithmetic_progression_sum(a, d, n):
            return (a+(a+(n-1)*d))*n//2
    
        a = min(k//2, n)
        b = n-a
        return arithmetic_progression_sum(1, 1, a)+arithmetic_progression_sum(k, 1, b)
",1
"

class Solution(object):
    def reformatNumber(self, number):
        number = list(number)
        src_len = 0
        for c in number: 
            if c.isdigit():
                number[src_len] = c
                src_len += 1
        dst_len = src_len + (src_len-1)//3
        if dst_len > len(number): 
            number.extend([0]*(dst_len-len(number)))
        while dst_len < len(number):
            number.pop()
        curr = dst_len-1
        for l, i in enumerate(reversed(range(src_len)), (3-src_len%3)%3):
            if l and l%3 == 0: 
                number[curr] = '-'
                curr -= 1
            number[curr] = number[i]
            curr -= 1
        if dst_len >= 3 and number[dst_len-2] == '-': 
            number[dst_len-3], number[dst_len-2] = number[dst_len-2], number[dst_len-3]            
        return """".join(number)
",n
"
import itertools


class Solution(object):

    def __init__(self, characters, combinationLength):
        self.__it = itertools.combinations(characters, combinationLength)
        self.__curr = None
        self.__last = characters[-combinationLength:]

    def __next__(self):
        self.__curr = """".join(next(self.__it))
        return self.__curr
    
    def hasNext(self):
        return self.__curr != self.__last


",k
"import functools


class Solution2(object):

    def __init__(self, characters, combinationLength):
        self.__characters = characters
        self.__combinationLength = combinationLength
        self.__it = self.__iterative_backtracking()
        self.__curr = None
        self.__last = characters[-combinationLength:]
        
    def __iterative_backtracking(self):
        def conquer():
            if len(curr) == self.__combinationLength:
                return curr

        def prev_divide(c):
            curr.append(c)
        
        def divide(i):
            if len(curr) != self.__combinationLength:
                for j in reversed(range(i, len(self.__characters)-(self.__combinationLength-len(curr)-1))):
                    stk.append(functools.partial(post_divide))
                    stk.append(functools.partial(divide, j+1))
                    stk.append(functools.partial(prev_divide, self.__characters[j]))
            stk.append(functools.partial(conquer))

        def post_divide():
            curr.pop()
            
        curr = []
        stk = [functools.partial(divide, 0)]
        while stk:
            result = stk.pop()()
            if result is not None:
                yield result

    def __next__(self):
        self.__curr = """".join(next(self.__it))
        return self.__curr
        
    def hasNext(self):
        return self.__curr != self.__last






",k
"

class Solution(object):
    def longestCommonPrefix(self, arr1, arr2):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for x in arr1:
            reduce(dict.__getitem__, str(x), trie)
        result = 0
        for x in arr2:
            curr = trie
            for i, c in enumerate(str(x)):
                if c not in curr:
                    break
                curr = curr[c]
            else:
                i += 1
            result = max(result, i)
        return result


",(n + m) * l
"
class Solution2(object):
    def longestCommonPrefix(self, arr1, arr2):
        lookup = {0}
        for x in arr1:
            while x not in lookup:
                lookup.add(x)
                x //= 10
        result = 0
        for x in arr2:
            l = len(str(x))
            while x not in lookup:
                x //= 10
                l -= 1
            result = max(result, l)
        return result
",(n + m) * l
"
class Solution(object):
    def countUnivalSubtrees(self, root):
        [is_uni, count] = self.isUnivalSubtrees(root, 0)
        return count

    def isUnivalSubtrees(self, root, count):
        if not root:
            return [True, count]

        [left, count] = self.isUnivalSubtrees(root.left, count)
        [right, count] = self.isUnivalSubtrees(root.right, count)
        if self.isSame(root, root.left, left) and \
           self.isSame(root, root.right, right):
                count += 1
                return [True, count]

        return [False, count]

    def isSame(self, root, child, is_uni):
        return not child or (is_uni and root.val == child.val)

",n
"
class Solution(object):
    def countBinarySubstrings(self, s):
        result, prev, curr = 0, 0, 1
        for i in range(1, len(s)):
            if s[i-1] != s[i]:
                result += min(prev, curr)
                prev, curr = curr, 1
            else:
                curr += 1
        result += min(prev, curr)
        return result

",n
"

class Solution(object):
    def maxScore(self, grid):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 

        mx = max(x for row in grid for x in row)
        adj = [[0]*max(mx, len(grid)) for _ in range(len(grid))]
        for i, row in enumerate(grid):
            for x in row:
                adj[i][x-1] = -x
        return -hungarian(adj)[0]


","n^2 * max(n, r)"
"
class Solution2(object):
    def maxScore(self, grid):
        mx = max(x for row in grid for x in row)
        lookup = [set() for _ in range(mx)]
        for i, row in enumerate(grid):
            for x in row:
                lookup[x-1].add(i)
        dp = [float(""-inf"")]*(1<<len(grid))
        dp[0] = 0
        for x in range(len(lookup)):
            if not lookup[x]:
                continue
            for mask in reversed(range(len(dp))):
                for i in lookup[x]:
                    if mask&(1<<i):
                        continue
                    dp[mask|(1<<i)] = max(dp[mask|(1<<i)], dp[mask]+(x+1))
        return max(dp)
",r + (n * m) * 2^n
"

class Solution(object):
    def minimizeArrayValue(self, nums):
        def ceil_divide(a, b):
            return (a+b-1)//b

        result = curr = 0
        for i, x in enumerate(nums):
            curr += x
            result = max(result, ceil_divide(curr, i+1))
        return result
",n
"
class Solution(object):
    def badSensor(self, sensor1, sensor2):
        for i in range(len(sensor1)-1):
            if sensor1[i] == sensor2[i]:
                continue
            while i+1 < len(sensor2) and sensor2[i+1] == sensor1[i]:
                i += 1
            return 1 if i+1 == len(sensor2) else 2
        return -1
",n
"

class Solution(object):
    def prefixCount(self, words, pref):
        return sum(x.startswith(pref) for x in words)
",n * p
"
import collections



class Solution(object):
    def finalString(self, s):
        dq = collections.deque()
        parity = 0
        for x in s:
            if x == 'i':
                parity ^= 1
            else:
                dq.appendleft(x) if parity else dq.append(x)
        if parity:
            dq.reverse()
        return """".join(dq)
",n
"
import threading


class Solution(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = False
        self.__cv = threading.Condition()

    def foo(self, printFoo):
        for i in range(self.__n):
            with self.__cv:
                while self.__curr != False:
                    self.__cv.wait()
                self.__curr = not self.__curr
                printFoo()
                self.__cv.notify()

    def bar(self, printBar):
        for i in range(self.__n):
            with self.__cv:
                while self.__curr != True:
                        self.__cv.wait()
                self.__curr = not self.__curr
                printBar()
                self.__cv.notify()
",n
"

class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True


class Solution(object):
    def countComponents(self, nums, threshold):
        uf = UnionFind(threshold)
        lookup = [-1]*threshold
        result = len(nums)
        for x in nums:
            if x-1 >= threshold:
                continue
            for i in range(x, threshold+1, x):
                if lookup[i-1] == -1:
                    lookup[i-1] = x-1
                    continue
                if uf.union_set(lookup[i-1], x-1):
                    result -= 1
                if i == x:
                    break
        return result


",n + tlogt
"
class Solution2(object):
    def countComponents(self, nums, threshold):
        uf = UnionFind(threshold)
        lookup = [-1]*threshold
        for x in nums:
            if x-1 >= threshold:
                continue
            for i in range(x+x, threshold+1, x):
                uf.union_set(i-1, x-1)
        return sum(x-1 >= threshold or uf.find_set(x-1) == x-1 for x in nums)
",n + tlogt
"
import collections




class Solution(object):
    def countTriplets(self, A):
        def FWT(A, v):
            B = A[:]
            d = 1
            while d < len(B):
                for i in range(0, len(B), d << 1):
                    for j in range(d):
                        B[i+j] += B[i+j+d] * v
                d <<= 1
            return B

        k = 3
        n, max_A = 1, max(A)
        while n <= max_A:
            n *= 2
        count = collections.Counter(A)
        B = [count[i] for i in range(n)]
        C = FWT([x**k for x in FWT(B, 1)], -1)
        return C[0]


",nlogn
"import collections


class Solution2(object):
    def countTriplets(self, A):
        count = collections.defaultdict(int)
        for i in range(len(A)):
            for j in range(len(A)):
                count[A[i]&A[j]] += 1
        result = 0
        for k in range(len(A)):
            for v in count:
                if A[k]&v == 0:
                    result += count[v]
        return result
",n^3
"

class Solution(object):
    def minOperations(self, nums, k):
        lookup = [False]*k
        for i in reversed(range(len(nums))):
            if nums[i] > len(lookup) or lookup[nums[i]-1]:
                continue
            lookup[nums[i]-1] = True
            k -= 1
            if not k:
                break
        return len(nums)-i
",n
"
class Solution(object):
    def minRemoveToMakeValid(self, s):
        result = list(s)
        count = 0
        for i, v in enumerate(result):
            if v == '(':
                count += 1
            elif v == ')':
                if count:
                    count -= 1
                else:
                    result[i] = """"
        if count:
            for i in reversed(range(len(result))):
                if result[i] == '(':
                    result[i] = """"
                    count -= 1
                    if not count:
                        break
        return """".join(result)
",n
"

class Solution(object):
    def circularGameLosers(self, n, k):
        lookup = [False]*n
        idx = 0
        for i in range(n):
            if lookup[idx]:
                break
            lookup[idx] = True
            idx = (idx+(i+1)*k)%n
        return [i+1 for i in range(n) if not lookup[i]]
",n
"

class Solution(object):
    def maxOperations(self, nums):
        result = 1
        target = nums[0]+nums[1]
        for i in range(2, len(nums)-1, 2):
            if nums[i]+nums[i+1] != target:
                break
            result += 1
        return result
",n
"
class Solution(object):
    def stoneGame(self, piles):
        if len(piles) % 2 == 0 or len(piles) == 1:
            return True

        dp = [0] * len(piles)
        for i in reversed(range(len(piles))):
            dp[i] = piles[i]
            for j in range(i+1, len(piles)):
                dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])
        return dp[-1] >= 0

",n^2
"
class Solution(object):
    def canPlaceFlowers(self, flowerbed, n):
        for i in range(len(flowerbed)):
            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and \
                (i == len(flowerbed)-1 or flowerbed[i+1] == 0):
                flowerbed[i] = 1
                n -= 1
            if n <= 0:
                return True
        return False

",n
"
import heapq


class Solution(object):
    def getBiggestThree(self, grid):
        K = 3
        left = [[grid[i][j] for j in range(len(grid[i]))] for i in range(len(grid))]
        right = [[grid[i][j] for j in range(len(grid[i]))] for i in range(len(grid))]
        for i in range(1, len(grid)):
            for j in range(len(grid[0])-1):
                left[i][j] += left[i-1][j+1]
        for i in range(1, len(grid)):
            for j in range(1, len(grid[0])):
                right[i][j] += right[i-1][j-1]
        min_heap = []
        lookup = set()
        for k in range((min(len(grid), len(grid[0]))+1)//2):
            for i in range(k, len(grid)-k):
                for j in range(k, len(grid[0])-k):
                    total = (((left[i][j-k]-left[i-k][j])+(right[i][j+k]-right[i-k][j])+grid[i-k][j]) +  
                             ((left[i+k][j]-left[i][j+k])+(right[i+k][j]-right[i][j-k])-grid[i+k][j])) if k else grid[i][j]
                    if total in lookup:
                        continue
                    lookup.add(total)
                    heapq.heappush(min_heap, total)
                    if len(min_heap) == K+1:                        
                        lookup.remove(heapq.heappop(min_heap))
        min_heap.sort(reverse=True)
        return min_heap
","m * n * min(m, n)"
"
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass



class Solution(object):
    def minimumOperations(self, root):
        result = 0
        q = [root]
        while q:
            new_q = []
            for node in q:
                if node.left:
                    new_q.append(node.left)
                if node.right:
                    new_q.append(node.right)
            idx = list(range(len(q)))
            idx.sort(key=lambda x: q[x].val)
            for i in range(len(q)):
                while idx[i] != i:
                    idx[idx[i]], idx[i] = idx[i], idx[idx[i]]
                    result += 1
            q = new_q
        return result
",nlogn
"

class Solution(object):
    def maxOutput(self, n, edges, price):
        def iter_dfs():
            result = 0
            stk = [(1, (0, -1, [price[0], 0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    stk.append((2, (u, p, ret, 0)))
                elif step == 2:
                    u, p, ret, i = args
                    if i == len(adj[u]):
                        continue
                    stk.append((2, (u, p, ret, i+1)))
                    v = adj[u][i]
                    if v == p:
                        continue
                    new_ret = [price[v], 0] 
                    stk.append((3, (u, new_ret, ret)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    u, new_ret, ret = args
                    result = max(result, ret[0]+new_ret[1], ret[1]+new_ret[0])
                    ret[0] = max(ret[0], new_ret[0]+price[u])
                    ret[1] = max(ret[1], new_ret[1]+price[u])
            return result
        
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()


",n
"
class Solution2(object):
    def maxOutput(self, n, edges, price):
        def dfs(u, p):
            dp = [price[u], 0] 
            for v in adj[u]:
                if v == p:
                    continue
                new_dp = dfs(v, u)
                result[0] = max(result[0], dp[0]+new_dp[1], dp[1]+new_dp[0])
                dp[0] = max(dp[0], new_dp[0]+price[u])
                dp[1] = max(dp[1], new_dp[1]+price[u])
            return dp
        
        result = [0]
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dfs(0, -1)
        return result[0]


",n
"
class Solution3(object):
    def maxOutput(self, n, edges, price):
        def iter_dfs():
            dp = [0]*n 
            stk = [(1, 0, -1)]
            while stk:
                step, u, p = stk.pop()
                if step == 1:
                    stk.append((2, u, p))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, v, u))
                elif step == 2:
                    dp[u] = price[u]
                    for v in adj[u]:
                        if v == p:
                            continue
                        dp[u] = max(dp[u], dp[v]+price[u])
            return dp
        
        def iter_dfs2():
            result = 0
            stk = [(0, -1, 0)]
            while stk:
                u, p, curr = stk.pop()
                result = max(result, curr, dp[u]-price[u])
                top2 = [[curr, p], [0, -1]]
                for v in adj[u]:
                    if v == p:
                        continue
                    curr = [dp[v], v]
                    for i in range(len(top2)):
                        if curr > top2[i]:
                            top2[i], curr = curr, top2[i]
                for v in adj[u]:
                    if v == p:
                        continue
                    stk.append((v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u]))
            return result
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dp = iter_dfs()
        return iter_dfs2()


",n
"
class Solution4(object):
    def maxOutput(self, n, edges, price):
        def dfs(u, p):
            dp[u] = price[u]
            for v in adj[u]:
                if v == p:
                    continue
                dp[u] = max(dp[u], dfs(v, u)+price[u])
            return dp[u]
        
        def dfs2(u, p, curr):
            result[0] = max(result[0], curr, dp[u]-price[u])
            top2 = [[curr, p], [0, -1]]
            for v in adj[u]:
                if v == p:
                    continue
                curr = [dp[v], v]
                for i in range(len(top2)):
                    if curr > top2[i]:
                        top2[i], curr = curr, top2[i]
            for v in adj[u]:
                if v == p:
                    continue
                dfs2(v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u])
    
        result = [0]
        dp = [0]*n 
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        dfs(0, -1)
        dfs2(0, -1, 0)
        return result[0]
",n
"
import collections


class Solution(object):
    def longestPalindrome(self, words):
        cnt = collections.Counter(words)
        result = remain = 0
        for x, c in cnt.items():
            if x == x[::-1]:
                result += c//2
                remain |= c%2
            elif x < x[::-1] and x[::-1] in cnt:
                result += min(c, cnt[x[::-1]])
        return result*4+remain*2
",n
"

class Solution(object):
    def maximumImportance(self, n, roads):
        def inplace_counting_sort(nums, reverse=False): 
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()

        degree = [0]*n
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
        inplace_counting_sort(degree)
        return sum(i*x for i, x in enumerate(degree, 1))


",n
"
class Solution2(object):
    def maximumImportance(self, n, roads):
        degree = [0]*n
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
        degree.sort()
        return sum(i*x for i, x in enumerate(degree, 1))
",nlogn
"
class Solution(object):
    def getFactors(self, n):
        result = []
        factors = []
        self.getResult(n, result, factors)
        return result

    def getResult(self, n, result, factors):
        i = 2 if not factors else factors[-1]
        while i <= n / i:
            if n % i == 0:
                factors.append(i)
                factors.append(n / i)
                result.append(list(factors))
                factors.pop()
                self.getResult(n / i, result, factors)
                factors.pop()
            i += 1

",nlogn
"
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        result, left = 0, 0
        lookup = {}
        for right in range(len(s)):
            if s[right] in lookup:
                left = max(left, lookup[s[right]]+1)
            lookup[s[right]] = right
            result = max(result, right-left+1)
        return result
",n
"
class Solution(object):
    def findMinFibonacciNumbers(self, k):
        result, a, b = 0, 1, 1
        while b <= k:
            b, a = a+b, b
        while k:
            if a <= k:
                k -= a
                result += 1
            a, b = b-a, a
        return result
",logk
"
class Solution(object):
    def smallestEqual(self, nums):
        return next((i for i, x in enumerate(nums) if i%10 == x), -1)
",n
"

class Solution(object):
    def numberOfBeautifulIntegers(self, low, high, k):
        TIGHT, UNTIGHT, UNBOUND = list(range(3))
        def f(x):
            digits = list(map(int, str(x)))
            lookup = [[[[-1]*k for _ in range(2*len(digits)+1)] for _ in range(3)] for _ in range(len(digits))]
            def memoization(i, state, diff, total):
                if i == len(digits):
                    return int(state != UNBOUND and diff == total == 0)
                if lookup[i][state][diff][total] == -1:
                    result = int(i != 0 and diff == total == 0) 
                    for d in range(1 if i == 0 else 0, 10):
                        new_state = state
                        if state == TIGHT and d != digits[i]:
                            new_state = UNTIGHT if d < digits[i] else UNBOUND
                        new_diff = diff+(1 if d%2 == 0 else -1)
                        new_total = (total*10+d)%k
                        result += memoization(i+1, new_state, new_diff, new_total)
                    lookup[i][state][diff][total] = result
                return lookup[i][state][diff][total]
    
            return memoization(0, TIGHT, 0, 0)

        return f(high)-f(low-1)


",n^2 * k
"
class Solution2(object):
    def numberOfBeautifulIntegers(self, low, high, k):
        TIGHT, UNTIGHT, UNBOUND = list(range(3))
        def f(x):
            digits = list(map(int, str(x)))
            dp = [[[0]*k for _ in range(2*len(digits)+1)] for _ in range(3)]
            for tight in range(2):
                for state in (TIGHT, UNTIGHT):
                    dp[state][0][0] = 1
            for i in reversed(range(len(digits))):
                new_dp = [[[0]*k for _ in range(2*len(digits)+1)] for _ in range(3)]
                for state in (TIGHT, UNTIGHT, UNBOUND):
                    new_dp[state][0][0] = int(i != 0) 
                    for d in range(1 if i == 0 else 0, 10):
                        new_state = state
                        if state == TIGHT and d != digits[i]:
                            new_state = UNTIGHT if d < digits[i] else UNBOUND
                        for diff in range(-len(digits), len(digits)+1):
                            new_diff = diff+(1 if d%2 == 0 else -1)
                            for total in range(k):
                                new_total = (total*10+d)%k
                                new_dp[state][diff][total] += dp[new_state][new_diff][new_total]
                dp = new_dp
            return dp[TIGHT][0][0]

        return f(high)-f(low-1)


",n^2 * k
"
class Solution3(object):
    def numberOfBeautifulIntegers(self, low, high, k):
        def f(x):
            digits = list(map(int, str(x)))
            lookup = [[[[[-1]*k for _ in range(2*len(digits)+1)] for _ in range(2)] for _ in range(2)] for _ in range(len(digits))]
            def memoization(i, zero, tight, diff, total):
                if i == len(digits):
                    return int(zero == diff == total == 0)
                if lookup[i][zero][tight][diff][total] == -1:
                    result = 0
                    for d in range((digits[i] if tight else 9)+1):
                        new_zero = int(zero and d == 0)
                        new_tight = int(tight and d == digits[i])
                        new_diff = diff+((1 if d%2 == 0 else -1) if new_zero == 0 else 0)
                        new_total = (total*10+d)%k
                        result += memoization(i+1, new_zero, new_tight, new_diff, new_total)
                    lookup[i][zero][tight][diff][total] = result
                return lookup[i][zero][tight][diff][total]
    
            return memoization(0, 1, 1, 0, 0)

        return f(high)-f(low-1)


",n^2 * k
"
class Solution4(object):
    def numberOfBeautifulIntegers(self, low, high, k):
        def f(x):
            digits = list(map(int, str(x)))
            dp = [[[[0]*k for _ in range(2*len(digits)+1)] for _ in range(2)] for _ in range(2)]
            for tight in range(2):
                dp[0][tight][0][0] = 1
            for i in reversed(range(len(digits))):
                new_dp = [[[[0]*k for _ in range(2*len(digits)+1)] for _ in range(2)] for _ in range(2)]
                for zero in range(2):
                    for tight in range(2):
                        for d in range((digits[i] if tight else 9)+1):
                            new_zero = int(zero and d == 0)
                            new_tight = int(tight and d == digits[i])
                            for diff in range(-len(digits), len(digits)+1):
                                new_diff = diff+((1 if d%2 == 0 else -1) if new_zero == 0 else 0)
                                for total in range(k):
                                    new_total = (total*10+d)%k
                                    new_dp[zero][tight][diff][total] += dp[new_zero][new_tight][new_diff][new_total]
                dp = new_dp
            return dp[1][1][0][0]

        return f(high)-f(low-1)
",n^2 * k
"
class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children



class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def encode(self, root):
        def encodeHelper(root, parent, index):
            if not root:
                return None
            node = TreeNode(root.val)
            if index+1 < len(parent.children):
                node.left = encodeHelper(parent.children[index+1], parent, index+1)
            if root.children:
                node.right = encodeHelper(root.children[0], root, 0)
            return node

        if not root:
            return None
        node = TreeNode(root.val)
        if root.children:
            node.right = encodeHelper(root.children[0], root, 0)
        return node

    def decode(self, data):
        def decodeHelper(root, parent):
            if not root:
                return
            children = []
            node = Node(root.val, children)
            decodeHelper(root.right, node)
            parent.children.append(node)
            decodeHelper(root.left, parent)

        if not data:
            return None
        children = []
        node = Node(data.val, children)
        decodeHelper(data.right, node)
        return node
        


",n
"

class Solution(object):
    def intersection(self, nums):
        MAX_NUM = 1000
        cnt = [0]*(MAX_NUM+1)
        for num in nums:
            for x in num:
                cnt[x] += 1
        return [i for i in range(1, MAX_NUM+1) if cnt[i] == len(nums)]


",n * l + r
"
class Solution2(object):
    def intersection(self, nums):
        result = set(nums[0])
        for i in range(1, len(nums)):
            result = set(x for x in nums[i] if x in result)
        return [i for i in range(min(result), max(result)+1) if i in result] if result else []


",n * l + r
"
class Solution3(object):
    def intersection(self, nums):
        result = set(nums[0])
        for i in range(1, len(nums)):
            result = set(x for x in nums[i] if x in result)
        return sorted(result)
",n * l + llogl
"

class Solution(object):
    def minimumScore(self, s, t):
        right = [-1]*len(s) 
        j = len(t)-1
        for i in reversed(range(len(s))):
            if j >= 0 and t[j] == s[i]:
                j -= 1
            right[i] = j
        result = j+1
        left = 0 
        for i in range(len(s)):
            result = max(min(result, right[i]-left+1), 0)
            if left < len(t) and t[left] == s[i]:
                left += 1
        result = min(result, len(t)-left)
        return result
",n
"

import collections


class TrieNode(object):

    def __init__(self):
        self.__TOP_COUNT = 3
        self.infos = []
        self.leaves = {}


    def insert(self, s, times):
        cur = self
        cur.add_info(s, times)
        for c in s:
            if c not in cur.leaves:
                cur.leaves[c] = TrieNode()
            cur = cur.leaves[c]
            cur.add_info(s, times)


    def add_info(self, s, times):
        for p in self.infos:
            if p[1] == s:
                p[0] = -times
                break
        else:
            self.infos.append([-times, s])
        self.infos.sort()
        if len(self.infos) > self.__TOP_COUNT:
            self.infos.pop()


class Solution(object):

    def __init__(self, sentences, times):
        self.__trie = TrieNode()
        self.__cur_node = self.__trie
        self.__search = []
        self.__sentence_to_count = collections.defaultdict(int)
        for sentence, count in zip(sentences, times):
            self.__sentence_to_count[sentence] = count
            self.__trie.insert(sentence, count)


    def input(self, c):
        result = []
        if c == 
            self.__sentence_to_count["""".join(self.__search)] += 1
            self.__trie.insert("""".join(self.__search), self.__sentence_to_count["""".join(self.__search)])
            self.__cur_node = self.__trie
            self.__search = []
        else:
            self.__search.append(c)
            if self.__cur_node:
                if c not in self.__cur_node.leaves:
                    self.__cur_node = None
                    return []
                self.__cur_node = self.__cur_node.leaves[c]
                result = [p[1] for p in self.__cur_node.infos]
        return result



",p^2
"

class Solution(object):
    def constructGridLayout(self, n, edges):
        def bfs(u):
            dist = [0]*n
            dist[u] = 1
            q = [u]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[v]:
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                q = new_q
            return dist
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        mn = min(len(x) for x in adj)
        corners = [u for u in range(n) if len(adj[u]) == mn]
        dist1 = bfs(corners[0])
        corners.sort(key=lambda x: dist1[x])
        dist2 = bfs(corners[1])
        c = dist1[corners[1]]
        r = n//c
        result = [[0]*c for _ in range(r)]
        for u in range(n):
            i = ((dist1[u]+dist2[u])-(1+c))//2
            j = (dist1[u]-1)-i
            result[i][j] = u
        return result
",n
"
import collections


class Solution(object):
    def numIdenticalPairs(self, nums):
        return sum(c*(c-1)//2 for c in collections.Counter(nums).values())
",n
"
class Solution(object):
    def longestCommonPrefix(self, strs):
        if not strs:
            return """"

        for i in range(len(strs[0])):
            for string in strs[1:]:
                if i >= len(string) or string[i] != strs[0][i]:
                    return strs[0][:i]
        return strs[0]


",n * k
"class Solution2(object):
    def longestCommonPrefix(self, strs):
        prefix = """"
        
        for chars in zip(*strs):
            if all(c == chars[0] for c in chars):
                prefix += chars[0]
            else:
                return prefix
            
        return prefix
",n * k
"

class Solution(object):
    def longestNiceSubarray(self, nums):
        result = left = curr = 0
        for right in range(len(nums)):
            while curr&nums[right]:
                curr ^= nums[left]
                left += 1
            curr |= nums[right]
            result = max(result, right-left+1)
        return result
",n
"
class Solution(object):
    def combinationSum2(self, candidates, target):
        result = []
        self.combinationSumRecu(sorted(candidates), result, 0, [], target)
        return result

    def combinationSumRecu(self, candidates, result, start, intermediate, target):
        if target == 0:
            result.append(list(intermediate))
        prev = 0
        while start < len(candidates) and candidates[start] <= target:
            if prev != candidates[start]:
                intermediate.append(candidates[start])
                self.combinationSumRecu(candidates, result, start + 1, intermediate, target - candidates[start])
                intermediate.pop()
                prev = candidates[start]
            start += 1

","k * C(n, k)"
"
import math


class Solution(object):
    def getPermutation(self, n, k):
        seq, k, fact = """", k - 1, math.factorial(n - 1)
        perm = [i for i in range(1, n + 1)]
        for i in reversed(range(n)):
            curr = perm[k / fact]
            seq += str(curr)
            perm.remove(curr)
            if i > 0:
                k %= fact
                fact /= i
        return seq


",n^2
"
class Solution(object):
    def findRelativeRanks(self, nums):
        sorted_nums = sorted(nums)[::-1]
        ranks = [""Gold Medal"", ""Silver Medal"", ""Bronze Medal""] + list(map(str, list(range(4, len(nums) + 1))))
        return list(map(dict(list(zip(sorted_nums, ranks))).get, nums))

",nlogn
"
import pandas as pd



def Solution(students: pd.DataFrame) -> pd.DataFrame:
    return students.astype({""grade"" : int})
",n
"
import collections
import itertools



class Solution(object):
    def largestWordCount(self, messages, senders):
        cnt = collections.Counter()
        for m, s in zip(messages, senders):
            cnt[s] += m.count(' ')+1
        return max((k for k in cnt.keys()), key=lambda x: (cnt[x], x))
",n * l
"
class Solution(object):
    def minimumAbsDifference(self, arr):
        result = []
        min_diff = float(""inf"")
        arr.sort()
        for i in range(len(arr)-1):
            diff = arr[i+1]-arr[i]
            if diff < min_diff:
                min_diff = diff
                result = [[arr[i], arr[i+1]]]
            elif diff == min_diff:
                result.append([arr[i], arr[i+1]])
        return result
",nlogn
"
from collections import Counter
from heapq import heapify, heappop


class Solution(object):
    def isNStraightHand(self, hand, W):
        if len(hand) % W:
            return False

        counts = Counter(hand)
        min_heap = list(hand)
        heapify(min_heap)
        for _ in range(len(min_heap)//W):
            while counts[min_heap[0]] == 0:
                heappop(min_heap)
            start = heappop(min_heap)
            for _ in range(W):
                counts[start] -= 1
                if counts[start] < 0:
                    return False
                start += 1
        return True
",nlogn
"

class Solution(object):
    def minBitFlips(self, start, goal):
        return bin(start^goal).count('1')
",logn
"
import heapq



class Solution(object):
    def maxRemoval(self, nums, queries):
        queries.sort(reverse=True)
        max_heap, min_heap = [], []
        for i in range(len(nums)):
            while queries and queries[-1][0] <= i:
                heapq.heappush(max_heap, -queries.pop()[1])
            while min_heap and min_heap[0] < i:
                heapq.heappop(min_heap)
            while len(min_heap) < nums[i]:
                if not max_heap or -max_heap[0] < i:
                    return -1
                heapq.heappush(min_heap, -heapq.heappop(max_heap))
        return len(max_heap)
",n + qlogq
"
from collections import Counter


class Solution(object):
    def leastInterval(self, tasks, n):
        counter = Counter(tasks)
        _, max_count = counter.most_common(1)[0]
        return max((max_count-1) * (n+1) + list(counter.values()).count(max_count), len(tasks))
",n
"
import collections



class Solution(object):
    def countGood(self, nums, k):
        result = curr = left = 0
        cnt = collections.Counter()
        for right in range(len(nums)):
            curr += cnt[nums[right]]
            cnt[nums[right]] += 1
            while curr >= k:
                cnt[nums[left]] -= 1
                curr -= cnt[nums[left]]
                left += 1
            result += left
        return result
",n
"

class Solution(object):
    def incremovableSubarrayCount(self, nums):
        for j in reversed(range(1, len(nums))):
            if not nums[j-1] < nums[j]:
                break
        else:
            return (len(nums)+1)*len(nums)//2
        result = len(nums)-j+1
        for i in range(len(nums)-1):
            while j < len(nums) and not (nums[i] < nums[j]):
                j += 1
            result += len(nums)-j+1
            if not (nums[i] < nums[i+1]):
                break
        return result
",n
"
class Solution(object):
    def numberWays(self, hats):
        MOD = 10**9 + 7
        HAT_SIZE = 40
        hat_to_people = [[] for _ in range(HAT_SIZE)]
        for i in range(len(hats)):
            for h in hats[i]:
                hat_to_people[h-1].append(i)
        dp = [0]*(1<<len(hats))
        dp[0] = 1
        for people in hat_to_people:
            for mask in reversed(range(len(dp))):
                for p in people:
                    if mask & (1<<p):
                        continue
                    dp[mask | (1<<p)] += dp[mask]
                    dp[mask | (1<<p)] %= MOD
        return dp[-1]
",h * 2^n
"

class Solution(object):
    def maximumEnergy(self, energy, k):
        result = float(""-inf"")
        for i in range(k):
            curr = 0
            for j in reversed(range(((len(energy)-i)-1)%k, len(energy)-i, k)): 
                curr += energy[j]
                result = max(result, curr)
        return result
",n
"

class Solution(object):
    def maximumTripletValue(self, nums):
        NEG_INF = float(""-inf"")
        result = 0
        mx_diff = mx = NEG_INF
        for x in nums:
            if mx_diff != NEG_INF:
                result = max(result, mx_diff*x)
            if mx != NEG_INF:
                mx_diff = max(mx_diff, mx-x)
            mx = max(mx, x)
        return result
",n
"

class Solution(object):
    def buyChoco(self, prices, money):
        i = min(range(len(prices)), key=lambda x: prices[x])
        j = min((j for j in range(len(prices)) if j != i), key=lambda x: prices[x])
        return money-(prices[i]+prices[j]) if prices[i]+prices[j] <= money else money
",n
"
class Solution(object):
    def searchRange(self, nums, target):
        def binarySearch(n, check): 
            left, right = 0, n-1 
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left 

        def binarySearch2(n, check): 
            left, right = 0, n 
            while left < right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid
                else:
                    left = mid+1
            return left 

        def binarySearch3(n, check): 
            left, right = -1, n-1 
            while left < right:
                mid = right - (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid
            return left+1 

        def binarySearch4(n, check): 
            left, right = -1, n 
            while right-left >= 2:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid
                else:
                    left = mid
            return left+1 

        left = binarySearch(len(nums), lambda i: nums[i] >= target)
        if left == len(nums) or nums[left] != target:
            return [-1, -1]
        right = binarySearch(len(nums), lambda i: nums[i] > target)
        return [left, right-1]
",logn
"
class Solution(object):
    def countVowels(self, word):
        VOWELS = set(""aeiou"")
        return sum((i-0+1) * ((len(word)-1)-i+1) for i, c in enumerate(word) if c in VOWELS)
",n
"
class Solution(object):
    def isPrefixOfWord(self, sentence, searchWord):
        def KMP(text, pattern):
            def getPrefix(pattern):
                prefix = [-1] * len(pattern)
                j = -1
                for i in range(1, len(pattern)):
                    while j > -1 and pattern[j + 1] != pattern[i]:
                        j = prefix[j]
                    if pattern[j + 1] == pattern[i]:
                        j += 1
                    prefix[i] = j
                return prefix
    
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j != -1 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1
        
        if sentence.startswith(searchWord):
            return 1
        p = KMP(sentence, ' ' + searchWord)
        if p == -1:
            return -1
        return 1+sum(sentence[i] == ' ' for i in range(p+1))
",n
"
class Solution(object):
    def prefixesDivBy5(self, A):
        for i in range(1, len(A)):
            A[i] += A[i-1] * 2 % 5
        return [x % 5 == 0 for x in A]
",n
"
import collections
import fractions


class Solution(object):
    def interchangeableRectangles(self, rectangles):
        count = collections.defaultdict(int)
        for w, h in rectangles:
            g = fractions.gcd(w, h) 
            count[(w//g, h//g)] += 1
        return sum(c*(c-1)//2 for c in count.values())
",n
"
class Solution(object):
    def countMatches(self, items, ruleKey, ruleValue):
        rule = {""type"":0, ""color"":1, ""name"":2}
        return sum(item[rule[ruleKey]] == ruleValue for item in items)
",n
"

class Solution(object):
    def countKConstraintSubstrings(self, s, k, queries):
        def count(l):
            return (l+1)*l//2

        result = cnt = left = 0
        prefix = [0]*(len(s)+1)
        lookup = [-1]*len(s)
        for right in range(len(s)):
            cnt += int(s[right] == '1')
            while not (cnt <= k or (right-left+1)-cnt <= k):
                cnt -= int(s[left] == '1')
                left += 1
            result += right-left+1
            prefix[right+1] = prefix[right]+(right-left+1)
            lookup[left] = right
        assert(lookup[0] != -1)
        for i in range(len(s)-1):
            if lookup[i+1] == -1:
                lookup[i+1] = lookup[i]
        return [count(min(lookup[left], right)-left+1)+(prefix[right+1]-prefix[min(lookup[left], right)+1]) for left, right in queries]
",n
"
class Solution(object):
    def confusingNumberII(self, n):
        lookup = {""0"":""0"", ""1"":""1"", ""6"":""9"", ""8"":""8"", ""9"":""6""}
        centers = {""0"":""0"", ""1"":""1"", ""8"":""8""}
        def totalCount(n): 
            s = str(n)
            total = 0 
            p = len(lookup)**(len(s)-1)
            for i in range(len(s)+1):
                if i == len(s):
                    total += 1
                    break
                smaller = sum(int(c < s[i]) for c in lookup.keys())
                total += smaller * p
                if s[i] not in lookup:
                    break
                p //= len(lookup)
            return total-1 

        def validCountInLessLength(n): 
            s = str(n)
            valid = 0
            total = len(centers)
            for i in range(1, len(s), 2): 
                if i == 1:
                    valid += len({c for c in centers.keys() if c != '0'})
                else:
                    valid += total * (len(lookup)-1)
                    total *= len(lookup)
            total = 1
            for i in range(2, len(s), 2): 
                valid += total * (len(lookup)-1)
                total *= len(lookup)
            return valid

        def validCountInFullLength(n): 
            s = str(n)
            half_s = s[:(len(s)+1)//2]
            total = 0
            choices = centers if (len(s) % 2) else lookup
            p = int(len(lookup)**(len(half_s)-2) * len(choices))
            for i in range(len(half_s)):
                if i == len(half_s)-1:
                    total += sum(int(c < half_s[i]) for c in choices.keys() if i != 0 or c != '0')
                    if half_s[i] not in choices:
                        break
                    tmp = list(half_s)+[lookup[half_s[i]] for i in reversed(range(len(half_s)-(len(s) % 2)))]
                    total += 0 < int("""".join(tmp)) <= n
                    break
                smaller = sum(int(c < half_s[i]) for c in lookup.keys() if i != 0 or c != '0')
                total += smaller * p
                if half_s[i] not in lookup:
                    break
                p //= len(lookup)
            return total

        return totalCount(n) - validCountInLessLength(n) - validCountInFullLength(n)


",logn
"class Solution2(object):
    def confusingNumberII(self, n):
        lookup = {""0"":""0"", ""1"":""1"", ""6"":""9"", ""8"":""8"", ""9"":""6""}
        centers = {""0"":""0"", ""1"":""1"", ""8"":""8""}
        def totalCount(n): 
            s = str(n)
            total = 0 
            p = len(lookup)**(len(s)-1)
            for i in range(len(s)+1):
                if i == len(s):
                    total += 1
                    break
                smaller = sum(int(c < s[i]) for c in lookup.keys())
                total += smaller * p
                if s[i] not in lookup:
                    break
                p //= len(lookup)
            return total

        def validCountInLessLength(n): 
            s = str(n)
            valid = 0
            total = len(centers)
            for i in range(1, len(s), 2): 
                if i == 1:
                    valid += len(centers)
                else:
                    valid += total * (len(lookup)-1)
                    total *= len(lookup)
            total = 1
            for i in range(2, len(s), 2): 
                valid += total * (len(lookup)-1)
                total *= len(lookup)
            return valid

        def validCountInFullLength(n): 
            s = str(n)
            half_s = s[:(len(s)+1)//2]
            total = 0
            choices = centers if (len(s) % 2) else lookup
            p = int(len(lookup)**(len(half_s)-2) * len(choices))
            for i in range(len(half_s)):
                if i == len(half_s)-1:
                    total += sum(int(c < half_s[i]) for c in choices.keys() if len(s) != 2 or c != '0')
                    if half_s[i] not in choices:
                        break
                    tmp = list(half_s)+[lookup[half_s[i]] for i in reversed(range(len(half_s)-(len(s) % 2)))]
                    total += int("""".join(tmp)) <= n
                    break
                smaller = sum(int(c < half_s[i]) for c in lookup.keys() if i != 0 or c != '0')
                total += smaller * p
                if half_s[i] not in lookup:
                    break
                p //= len(lookup)
            return total

        def f(n): 
            return totalCount(n) - validCountInLessLength(n) - validCountInFullLength(n)

        return f(n) - f(0) 
",logn
"

class Solution(object):
    def numberOfAlternatingGroups(self, colors, k):
        result = curr = left = 0
        for right in range(len(colors)+k-1):  
            if right-left+1 == k:
                result += int(curr == k-1)
                curr -= int(colors[left] != colors[(left+1)%len(colors)])
                left += 1
            curr += int(colors[right%len(colors)] != colors[(right+1)%len(colors)])
        return result
",n
"
class Solution(object):
    def fairCandySwap(self, A, B):
        diff = (sum(A)-sum(B))//2
        setA = set(A)
        for b in set(B):
            if diff+b in setA:
                return [diff+b, b]
        return []

",m + n
"
import collections



class Solution(object):
    def robotWithString(self, s):
        cnt = collections.Counter(s)
        result, stk = [], []
        mn = 'a'
        for c in s:
            stk.append(c)
            cnt[c] -= 1
            while mn < 'z' and cnt[mn] == 0:
                mn = chr(ord(mn)+1)
            while stk and stk[-1] <= mn:
                result.append(stk.pop())
        return """".join(result) 
",n
"
class Solution(object):
    def solve(self, nums, queries):
        MOD = 10**9+7

        prefix = {}          
        result = []
        for x, y in queries:
            if y*y > len(nums):
                total = 0
                for i in range(x, len(nums), y):
                    total += nums[i]
                    total %= MOD
                result.append(total)
            else:
                begin = x%y
                if (begin, y) not in prefix:
                    prefix[(begin, y)] = [0]
                    for i in range(begin, len(nums), y):
                        prefix[(begin, y)].append((prefix[(begin, y)][-1] + nums[i]) % MOD)
                result.append((prefix[(begin, y)][-1]-prefix[(begin, y)][x//y]) % MOD)
        return result
",n * sqrt(n)
"

class Solution(object):
    def countLatticePoints(self, circles):
        lookup = set()
        for x, y, r in circles:
            for i in range(-r, r+1):
                for j in range(-r, r+1):
                    if i**2+j**2 <= r**2:
                        lookup.add(((x+i), (y+j)))
        return len(lookup)


",n * r^2
"
class Solution2(object):
    def countLatticePoints(self, circles):
        max_x = max(x+r for x, _, r in circles)
        max_y = max(y+r for _, y, r in circles)
        result = 0
        for i in range(max_x+1):
            for j in range(max_y+1):
                if any((i-x)**2+(j-y)**2 <= r**2 for x, y, r in circles):
                    result += 1
        return result
",n * max_x * max_y
"

class Solution(object):
    def sumOfPower(self, nums, k):
        MOD = 10**9+7
        dp = [0]*(k+1)
        dp[0] = 1
        for x in nums:
            for i in reversed(range(k+1)):
                dp[i] = (dp[i]+(dp[i]+(dp[i-x] if i-x >= 0 else 0)))%MOD
        return dp[k]
",n * k
"
class Solution(object):
    def nextClosestTime(self, time):
        h, m = time.split("":"")
        curr = int(h) * 60 + int(m)
        result = None
        for i in range(curr+1, curr+1441):
            t = i % 1440
            h, m = t // 60, t % 60
            result = ""%02d:%02d"" % (h, m)
            if set(result) <= set(time):
                break
        return result

",1
"
import collections



class Solution(object):
    def minimumRounds(self, tasks):
        cnt = collections.Counter(tasks)
        return sum((x+2)//3 for x in cnt.values()) if 1 not in iter(cnt.values()) else -1
",n
"

class Solution(object):
    def distMoney(self, money, children):
        if money < children*1:
            return -1
        money -= children*1
        q, r = divmod(money, 7)
        return min(q, children) - int(q > children or (q == children and r != 0) or (q == children-1 and r == 3))


",1
"
class Solution2(object):
    def distMoney(self, money, children):
        if money < children*1:
            return -1
        money -= children*1
        q, r = divmod(money, 7)
        if q > children:
            return children-1
        if q == children:
            return q-int(r != 0)
        if q == children-1:
            return q-int(r == 3)
        return q
",1
"
import math


class Solution(object):
    def arrangeCoins(self, n):
        return int((math.sqrt(8*n+1)-1) / 2) 


",logn
"class Solution2(object):
    def arrangeCoins(self, n):
        def check(mid, n):
            return mid*(mid+1) <= 2*n

        left, right = 1, n
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid, n):
                right = mid-1
            else:
                left = mid+1
        return right
",logn
"
class Solution(object):
    def widthOfBinaryTree(self, root):
        def dfs(node, i, depth, leftmosts):
            if not node:
                return 0
            if depth >= len(leftmosts):
                leftmosts.append(i)
            return max(i-leftmosts[depth]+1, \
                       dfs(node.left, i*2, depth+1, leftmosts), \
                       dfs(node.right, i*2+1, depth+1, leftmosts))

        leftmosts = []
        return dfs(root, 1, 0, leftmosts)

",n
"
class Solution(object):
    def maxVacationDays(self, flights, days):
        if not days or not flights:
            return 0
        dp = [[0] * len(days) for _ in range(2)]
        for week in reversed(range(len(days[0]))):
            for cur_city in range(len(days)):
                dp[week % 2][cur_city] = days[cur_city][week] + dp[(week+1) % 2][cur_city]
                for dest_city in range(len(days)):
                    if flights[cur_city][dest_city] == 1:
                        dp[week % 2][cur_city] = max(dp[week % 2][cur_city], \
                                                     days[dest_city][week] + dp[(week+1) % 2][dest_city])
        return dp[0][0]

",n^2 * k
"

class Solution(object):
    def findAnswer(self, parent, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P
    
        def iter_dfs(u):
            cnt = 0
            curr = []
            lookup = [None]*len(adj)
            stk = [(1, (0,))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u = args[0]
                    stk.append((2, (u, cnt)))
                    for v in reversed(adj[u]):
                        stk.append((1, (v,)))
                elif step == 2:
                    u, left = args
                    curr.append(s[u])
                    lookup[u] = (left, cnt)
                    cnt += 1
            return curr, lookup

        adj = [[] for _ in range(len(parent))]
        for v in range(1, len(parent)):
            adj[parent[v]].append(v)
        curr, lookup = iter_dfs(0)
        P = manacher(curr)
        return [P[(2*(left+1)+2*(right+1))//2] >= right-left+1 for left, right in lookup]


",n
"
class Solution2(object):
    def findAnswer(self, parent, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P
    
        def dfs(u):
            left = cnt[0]
            for v in adj[u]:
                dfs(v)
            curr.append(s[u])
            lookup[u] = (left, cnt[0])
            cnt[0] += 1

        adj = [[] for _ in range(len(parent))]
        for v in range(1, len(parent)):
            adj[parent[v]].append(v)
        cnt = [0]
        curr = []
        lookup = [None]*len(adj)
        dfs(0)
        P = manacher(curr)
        return [P[(2*(left+1)+2*(right+1))//2] >= right-left+1 for left, right in lookup]
",n
"




import random


class SkipNode(object):
    def __init__(self, level=0, num=None):
        self.num = num
        self.nexts = [None]*level


class Solution(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2 
    MAX_LEVEL = 32 

    def __init__(self):
        self.__head = SkipNode()
        self.__len = 0

    def search(self, target):
        return True if self.__find(target, self.__find_prev_nodes(target)) else False
        
    def add(self, num):
        node = SkipNode(self.__random_level(), num)
        if len(self.__head.nexts) < len(node.nexts): 
            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))
        prevs = self.__find_prev_nodes(num)
        for i in range(len(node.nexts)):
            node.nexts[i] = prevs[i].nexts[i]
            prevs[i].nexts[i] = node
        self.__len += 1

    def erase(self, num):
        prevs = self.__find_prev_nodes(num)
        curr = self.__find(num, prevs)
        if not curr:
            return False
        self.__len -= 1   
        for i in reversed(range(len(curr.nexts))):
            prevs[i].nexts[i] = curr.nexts[i]
            if not self.__head.nexts[i]:
                self.__head.nexts.pop()
        return True
    
    def __find(self, num, prevs):
        if prevs:
            candidate = prevs[0].nexts[0]
            if candidate and candidate.num == num:
                return candidate
        return None

    def __find_prev_nodes(self, num):
        prevs = [None]*len(self.__head.nexts)
        curr = self.__head
        for i in reversed(range(len(self.__head.nexts))):
            while curr.nexts[i] and curr.nexts[i].num < num:
                curr = curr.nexts[i]
            prevs[i] = curr
        return prevs

    def __random_level(self):
        level = 1
        while random.randint(1, Solution.P_DENOMINATOR) <= Solution.P_NUMERATOR and \
              level < Solution.MAX_LEVEL:
            level += 1
        return level

    def __len__(self):
        return self.__len
    
    def __str__(self):
        result = []
        for i in reversed(range(len(self.__head.nexts))):
            result.append([])
            curr = self.__head.nexts[i]
            while curr:
                result[-1].append(str(curr.num))
                curr = curr.nexts[i]
        return ""\n"".join([""->"".join(x) for x in result])
",logn
"
import collections


class Solution(object):
    def numberOfBoomerangs(self, points):
        result = 0

        for i in range(len(points)):
            group = collections.defaultdict(int)
            for j in range(len(points)):
                if j == i:
                    continue
                dx, dy =  points[i][0] - points[j][0], points[i][1] - points[j][1]
                group[dx**2 + dy**2] += 1

            for _, v in group.items():
                if v > 1:
                    result += v * (v-1)

        return result

    def numberOfBoomerangs2(self, points):
        cnt = 0
        for a, i in enumerate(points):
            dis_list = []
            for b, k in enumerate(points[:a] + points[a + 1:]):
                dis_list.append((k[0] - i[0]) ** 2 + (k[1] - i[1]) ** 2)
            for z in list(collections.Counter(dis_list).values()):
                if z > 1:
                    cnt += z * (z - 1)
        return cnt

",n^2
"
class Solution(object):
    def checkPalindromeFormation(self, a, b):
        def is_palindrome(s, i, j):
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        def check(a, b):
            i, j = 0, len(b)-1
            while i < j:
                if a[i] != b[j]:
                    return is_palindrome(a, i, j) or is_palindrome(b, i, j)
                i += 1
                j -= 1
            return True

        return check(a, b) or check(b, a)
",n
"
import collections


class Solution(object):
    def shortestCompletingWord(self, licensePlate, words):
        def contains(counter1, w2):
            c2 = collections.Counter(w2.lower())
            c2.subtract(counter1)
            return all([x >= 0 for x in list(c2.values())])

        result = None
        counter = collections.Counter(c.lower() for c in licensePlate if c.isalpha())
        for word in words:
            if (result is None or (len(word) < len(result))) and \
               contains(counter, word):
                result = word
        return result

",n
"
import collections



class Solution(object):
    def maxIncreasingCells(self, mat):
        lookup = collections.defaultdict(list)
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                lookup[mat[i][j]].append((i, j))
        dp = [[0]*len(mat[0]) for _ in range(len(mat))]
        row, col = [0]*len(mat), [0]*len(mat[0])
        for x in sorted(lookup.keys()):
            for i, j in lookup[x]:
                dp[i][j] = max(row[i], col[j])+1
            for i, j in lookup[x]:
                row[i] = max(row[i], dp[i][j])
                col[j] = max(col[j], dp[i][j])
        return max(row)
",m * n * log(m * n)
"
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def numComponents(self, head, G):
        lookup = set(G)
        dummy = ListNode(-1)
        dummy.next = head
        curr = dummy
        result = 0
        while curr and curr.__next__:
            if curr.val not in lookup and curr.next.val in lookup:
                result += 1
            curr = curr.__next__
        return result

",m + n
"

class Solution(object):
    def coloredCells(self, n):
        return n**2+(n-1)**2


",1
"
class Solution2(object):
    def coloredCells(self, n):
        return (1+(1+2*(n-1)))*n//2*2-(2*n-1)
",1
"
import collections



class Solution(object):
    def removeAnagrams(self, words):
        result = []
        prev = None
        for x in words:
            cnt = collections.Counter(x)
            if prev and prev == cnt:
                continue
            prev = cnt
            result.append(x)
        return result


",n * l
"import collections



class Solution2(object):
    def removeAnagrams(self, words):
        result = []
        prev = None
        for x in words:
            s = sorted(x)
            if prev and prev == s:
                continue
            prev = s
            result.append(x)
        return result


",n * llogl
"import collections



class Solution3(object):
    def removeAnagrams(self, words):
        return [words[i] for i in range(len(words)) if i == 0 or sorted(words[i-1]) != sorted(words[i])]
",n * llogl
"
import collections



class Solution(object):
    def findMatrix(self, nums):
        result = []
        cnt = collections.Counter()
        for x in nums:
            if cnt[x] == len(result):
                result.append([])
            result[cnt[x]].append(x)
            cnt[x] += 1
        return result


",n
"import collections



class Solution2(object):
    def findMatrix(self, nums):
        result = []
        cnt = collections.Counter(nums)
        while cnt:
            result.append(list(cnt.keys()))
            cnt = {k:v-1 for k, v in cnt.items() if v-1}
        return result
",n
"
class Solution(object):
    def isRectangleOverlap(self, rec1, rec2):
        def intersect(p_left, p_right, q_left, q_right):
            return max(p_left, q_left) < min(p_right, q_right)

        return (intersect(rec1[0], rec1[2], rec2[0], rec2[2]) and
                intersect(rec1[1], rec1[3], rec2[1], rec2[3]))

",1
"
import re


class Solution(object):
    def fractionAddition(self, expression):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        ints = list(map(int, re.findall('[+-]?\d+', expression)))
        A, B = 0, 1
        for i in range(0, len(ints), 2):
            a, b = ints[i], ints[i+1]
            A = A * b + a * B
            B *= b
            g = gcd(A, B)
            A //= g
            B //= g
        return '%d/%d' % (A, B)

",nlogx
"
class Solution(object):
    def minimumSwap(self, s1, s2):
        x1, y1 = 0, 0
        for i in range(len(s1)):
            if s1[i] == s2[i]:
                continue
            x1 += int(s1[i] == 'x')
            y1 += int(s1[i] == 'y')
        if x1%2 !=  y1%2: 
            return -1
        return (x1//2 + y1//2) + (x1%2 + y1%2)
",n
"

class Solution(object):
    def areaOfMaxDiagonal(self, dimensions):
        return max((l**2+w**2, l*w) for l, w in dimensions)[1]
",n
"

class Solution(object):
    def countSteppingNumbers(self, low, high):
        MOD = 10**9+7
        def f(s):
            dp = [[0]*10 for _ in range(2)]
            for j in range(1, ord(s[0])-ord('0')+1):
                dp[0][j] = 1
            prefix = True
            for i in range(1, len(s)):
                for j in range(10):
                    dp[i%2][j] = int(j != 0)
                    if j-1 >= 0:
                        dp[i%2][j] = (dp[i%2][j]+(dp[(i-1)%2][j-1]-int(prefix and (ord(s[i-1])-ord('0')) == j-1 and j > (ord(s[i])-ord('0')))))%MOD
                    if j+1 < 10:
                        dp[i%2][j] = (dp[i%2][j]+(dp[(i-1)%2][j+1]-int(prefix and (ord(s[i-1])-ord('0')) == j+1 and j > (ord(s[i])-ord('0')))))%MOD
                if abs(ord(s[i])-ord(s[i-1])) != 1:
                    prefix = False
            return reduce(lambda x, y: (x+y)%MOD, dp[(len(s)-1)%2])

        return (f(high)-f(str(int(low)-1)))%MOD
",n
