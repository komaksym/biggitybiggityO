code,label
"class Solution(object):
    def findEvenNumbers(self, digits):
        k = 3
        def backtracking(curr, cnt, result):
            if len(curr) == k:
                result.append(reduce(lambda x, y: x*10+y, curr))
                return
            for i, c in enumerate(cnt):
                if c == 0 or (not curr and i == 0) or (len(curr) == k-1 and i%2 != 0):
                    continue
                cnt[i] -= 1
                curr.append(i)
                backtracking(curr, cnt, result)
                curr.pop()
                cnt[i] += 1

        cnt = [0]*10
        for d in digits:
            cnt[d] += 1
        result = []
        backtracking([], cnt, result)
        return result

","# Time:  O(1) ~ O(n), n is 10^3"
"class Solution2(object):
    def findEvenNumbers(self, digits):
        result, cnt = [], collections.Counter(digits)
        for i in range(1, 10):
            for j in range(10):
                for k in range(0, 10, 2):
                    if cnt[i] > 0 and cnt[j] > (j == i) and cnt[k] > (k == i) + (k == j):
                        result.append(i*100 + j*10 + k)
        return result

","# Time:  O(n), n is 10^3"
"class Solution3(object):
    def findEvenNumbers(self, digits):
        k = 3
        
        def backtracking(curr, dummy, result):
            if len(curr) == k:
                result.append(reduce(lambda x, y: x*10+y, curr))
                return
            node = dummy.right
            while node:
                if (not curr and node.val[0] == 0) or (len(curr) == k-1 and node.val[0]%2 != 0):
                    node = node.right
                    continue
                node.val[1] -= 1
                if node.val[1] == 0:
                    if node.left:
                        node.left.right = node.right
                    if node.right:
                        node.right.left = node.left
                curr.append(node.val[0])
                backtracking(curr, dummy, result)
                curr.pop()
                if node.val[1] == 0:
                    if node.left:
                        node.left.right = node
                    if node.right:
                        node.right.left = node
                node.val[1] += 1
                node = node.right

        prev = dummy = Node()
        for digit, cnt in sorted(map(list, iter(collections.Counter(digits).items()))):
            prev.right = Node(val=[digit, cnt], left=prev)
            prev = prev.right
        result = []
        backtracking([], dummy, result)
        return result

","# Time:  O(1) ~ O(n), n is 10^3"
"class Solution4(object):
    def findEvenNumbers(self, digits):
        k = 3
        def backtracking(curr, digit_cnt, result):
            if len(curr) == k:
                result.append(reduce(lambda x, y: x*10+y, curr))
                return
            for i, (digit, cnt) in enumerate(digit_cnt):
                if (not curr and digit == 0) or (len(curr) == k-1 and digit%2 != 0):
                    continue
                digit_cnt[i][1] -= 1
                digit_cnt[i], digit_cnt[-1] = digit_cnt[-1], digit_cnt[i]
                removed = []
                if digit_cnt[-1][1] == 0:
                    removed = digit_cnt.pop()
                curr.append(digit)
                backtracking(curr, digit_cnt, result)
                curr.pop()
                if removed:
                    digit_cnt.append(removed)
                digit_cnt[i], digit_cnt[-1] = digit_cnt[-1], digit_cnt[i]
                digit_cnt[i][1] += 1

        cnt = collections.Counter(digits)
        digit_cnt = list(map(list, iter(cnt.items())))
        result = []
        backtracking([], digit_cnt, result)
        result.sort()
        return result","# Time:  O(1) ~ O(nlogn), n is 10^3"
"class Solution(object):
    def isSubPath(self, head, root):
        def getPrefix(head):
            pattern, prefix = [head.val], [-1]
            j = -1
            node = head.__next__
            while node:
                while j+1 and pattern[j+1] != node.val:
                    j = prefix[j]
                if pattern[j+1] == node.val:
                    j += 1
                pattern.append(node.val)
                prefix.append(j)
                node = node.__next__
            return pattern, prefix
            
        def dfs(pattern, prefix, root, j):
            if not root:
                return False
            while j+1 and pattern[j+1] != root.val:
                j = prefix[j]
            if pattern[j+1] == root.val:
                j += 1
            if j+1 == len(pattern):
                return True
            return dfs(pattern, prefix, root.left, j) or \
                   dfs(pattern, prefix, root.right, j)
        
        if not head:
            return True
        pattern, prefix = getPrefix(head)
        return dfs(pattern, prefix, root, -1)
    

    
",# Time:  O(n + l)
"class Solution2(object):
    def isSubPath(self, head, root):
        def dfs(head, root):
            if not head:
                return True
            if not root:
                return False
            return root.val == head.val and \
                   (dfs(head.__next__, root.left) or 
                    dfs(head.__next__, root.right))
    
        if not head:
            return True
        if not root:
            return False
        return dfs(head, root) or \
               self.isSubPath(head, root.left) or \
               self.isSubPath(head, root.right)",# Time:  O(n + l)
"class Solution(object):
    def topKFrequent(self, nums, k):
        counts = collections.Counter(nums)
        buckets = [[] for _ in range(len(nums)+1)]
        for i, count in counts.items():
            buckets[count].append(i)

        result = []
        for i in reversed(range(len(buckets))):
            for j in range(len(buckets[i])):
                result.append(buckets[i][j])
                if len(result) == k:
                    return result
        return result

",# Time:  O(n)
"class Solution2(object):
    def topKFrequent(self, nums, k):
        counts = collections.Counter(nums)
        p = []
        for key, val in counts.items():
            p.append((-val, key))
        self.kthElement(p, k-1)

        result = []
        for i in range(k):
            result.append(p[i][1])
        return result

    def kthElement(self, nums, k):
        def PartitionAroundPivot(left, right, pivot_idx, nums):
            pivot_value = nums[pivot_idx]
            new_pivot_idx = left
            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
            for i in range(left, right):
                if nums[i] < pivot_value:
                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                    new_pivot_idx += 1

            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
            return new_pivot_idx

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = randint(left, right)
            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)
            if new_pivot_idx == k:
                return
            elif new_pivot_idx > k:
                right = new_pivot_idx - 1
            else: 
                left = new_pivot_idx + 1

","# Time:  O(n) ~ O(n^2), O(n) on average."
"class Solution3(object):
    def topKFrequent(self, nums, k):
        return [key for key, _ in collections.Counter(nums).most_common(k)]
",# Time:  O(nlogk)
"class Solution(object):
    def pyramidTransition(self, bottom, allowed):
        def pyramidTransitionHelper(bottom, edges, lookup):
            def dfs(bottom, edges, new_bottom, idx, lookup):
                if idx == len(bottom)-1:
                    return pyramidTransitionHelper("""".join(new_bottom), edges, lookup)
                for i in edges[ord(bottom[idx])-ord('A')][ord(bottom[idx+1])-ord('A')]:
                    new_bottom[idx] = chr(i+ord('A'))
                    if dfs(bottom, edges, new_bottom, idx+1, lookup):
                        return True
                return False

            if len(bottom) == 1:
                return True
            if bottom in lookup:
                return False
            lookup.add(bottom)
            for i in range(len(bottom)-1):
                if not edges[ord(bottom[i])-ord('A')][ord(bottom[i+1])-ord('A')]:
                    return False
            new_bottom = ['A']*(len(bottom)-1)
            return dfs(bottom, edges, new_bottom, 0, lookup)

        edges = [[[] for _ in range(7)] for _ in range(7)]
        for s in allowed:
            edges[ord(s[0])-ord('A')][ord(s[1])-ord('A')].append(ord(s[2])-ord('A'))
        return pyramidTransitionHelper(bottom, edges, set())
","# Time:  O((a^(b+1)-a)/(a-1)) = O(a^b) , a is the size of allowed,"
"class Solution(object):
    def fallingSquares(self, positions):
        result = []
        pos = [-1]
        heights = [0]
        maxH = 0
        for left, side in positions:
            l = bisect.bisect_right(pos, left)
            r = bisect.bisect_left(pos, left+side)
            high = max(heights[l-1:r] or [0]) + side
            pos[l:r] = [left, left+side]        
            heights[l:r] = [high, heights[r-1]] 
            maxH = max(maxH, high)
            result.append(maxH)
        return result


class SegmentTree(object):
    def __init__(self, N,
                 query_fn=min,
                 update_fn=lambda x, y: y,
                 default_val=float(""inf"")):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = [default_val] * (2 * N)
        self.lazy = [None] * N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h):
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2 + 1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1:
                self.__apply(L, h)
                L += 1
            if R & 1 == 0:
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R):
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = self.default_val
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1:
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0:
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def data(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return showList


class SegmentTree2(object):
    def __init__(self, nums,
                 query_fn=min,
                 update_fn=lambda x, y: y,
                 default_val=float(""inf"")):
        N = len(nums)
        self.__original_length = N
        self.__tree_length = 2**(N.bit_length() + (N&(N-1) != 0))-1
        self.__query_fn = query_fn
        self.__update_fn = update_fn
        self.__default_val = default_val
        self.__tree = [default_val for _ in range(self.__tree_length)]
        self.__lazy = [None for _ in range(self.__tree_length)]
        self.__constructTree(nums, 0, self.__original_length-1, 0)

    def update(self, i, j, val):
        self.__updateTree(val, i, j, 0, self.__original_length-1, 0)

    def query(self, i, j):
        return self.__queryRange(i, j, 0, self.__original_length-1, 0)

    def __constructTree(self, nums, left, right, idx):
        if left > right:
             return
        if left == right:
            self.__tree[idx] = self.__update_fn(self.__tree[idx], nums[left])
            return 
        mid = left + (right-left)//2
        self.__constructTree(nums, left, mid, idx*2 + 1)
        self.__constructTree(nums, mid+1, right, idx*2 + 2)
        self.__tree[idx] = self.__query_fn(self.__tree[idx*2 + 1], self.__tree[idx*2 + 2])

    def __apply(self, left, right, idx, val):
        self.__tree[idx] = self.__update_fn(self.__tree[idx], val)
        if left != right:
            self.__lazy[idx*2 + 1] = self.__update_fn(self.__lazy[idx*2 + 1], val)
            self.__lazy[idx*2 + 2] = self.__update_fn(self.__lazy[idx*2 + 2], val)

    def __updateTree(self, val, range_left, range_right, left, right, idx):
        if left > right:
            return
        if self.__lazy[idx] is not None:
            self.__apply(left, right, idx, self.__lazy[idx])
            self.__lazy[idx] = None
        if range_left > right or range_right < left:
            return
        if range_left <= left and right <= range_right:
            self.__apply(left, right, idx, val)
            return
        mid = left + (right-left)//2
        self.__updateTree(val, range_left, range_right, left, mid, idx*2 + 1)
        self.__updateTree(val, range_left, range_right, mid+1, right, idx*2 + 2)
        self.__tree[idx] = self.__query_fn(self.__tree[idx*2 + 1],
                                           self.__tree[idx*2 + 2])

    def __queryRange(self, range_left, range_right, left, right, idx):
        if left > right:
            return self.__default_val
        if self.__lazy[idx] is not None:
            self.__apply(left, right, idx, self.__lazy[idx])
            self.__lazy[idx] = None
        if right < range_left or left > range_right:
            return self.__default_val
        if range_left <= left and right <= range_right:
            return self.__tree[idx]
        mid = left + (right-left)//2
        return self.__query_fn(self.__queryRange(range_left, range_right, left, mid, idx*2 + 1), 
                               self.__queryRange(range_left, range_right, mid + 1, right, idx*2 + 2))

","# Time:  O(n^2), could be improved to O(nlogn) in cpp by ordered map (bst)"
"class Solution2(object):
    def fallingSquares(self, positions):
        index = set()
        for left, size in positions:
            index.add(left)
            index.add(left+size-1)
        index = sorted(list(index))
        tree = SegmentTree(len(index), max, max, 0)
        max_height = 0
        result = []
        for left, size in positions:
            L, R = bisect.bisect_left(index, left), bisect.bisect_left(index, left+size-1)
            h = tree.query(L, R) + size
            tree.update(L, R, h)
            max_height = max(max_height, h)
            result.append(max_height)
        return result

",# Time:  O(nlogn)
"class Solution3(object):
    def fallingSquares(self, positions):
        def query(heights, left, right, B, blocks, blocks_read):
            result = 0
            while left % B and left <= right:
                result = max(result, heights[left], blocks[left//B])
                left += 1
            while right % B != B-1 and left <= right:
                result = max(result, heights[right], blocks[right//B])
                right -= 1
            while left <= right:
                result = max(result, blocks[left//B], blocks_read[left//B])
                left += B
            return result

        def update(heights, left, right, B, blocks, blocks_read, h):
            while left % B and left <= right:
                heights[left] = max(heights[left], h)
                blocks_read[left//B] = max(blocks_read[left//B], h)
                left += 1
            while right % B != B-1 and left <= right:
                heights[right] = max(heights[right], h)
                blocks_read[right//B] = max(blocks_read[right//B], h)
                right -= 1
            while left <= right:
                blocks[left//B] = max(blocks[left//B], h)
                left += B

        index = set()
        for left, size in positions:
            index.add(left)
            index.add(left+size-1)
        index = sorted(list(index))
        W = len(index)
        B = int(W**.5)
        heights = [0] * W
        blocks = [0] * (B+2)
        blocks_read = [0] * (B+2)

        max_height = 0
        result = []
        for left, size in positions:
            L, R = bisect.bisect_left(index, left), bisect.bisect_left(index, left+size-1)
            h = query(heights, L, R, B, blocks, blocks_read) + size
            update(heights, L, R, B, blocks, blocks_read, h)
            max_height = max(max_height, h)
            result.append(max_height)
        return result

",# Time:  O(n * sqrt(n))
"class Solution4(object):
    def fallingSquares(self, positions):
        heights = [0] * len(positions)
        for i in range(len(positions)):
            left_i, size_i = positions[i]
            right_i = left_i + size_i
            heights[i] += size_i
            for j in range(i+1, len(positions)):
                left_j, size_j = positions[j]
                right_j = left_j + size_j
                if left_j < right_i and left_i < right_j: 
                    heights[j] = max(heights[j], heights[i])

        result = []
        for height in heights:
            result.append(max(result[-1], height) if result else height)
        return result
",# Time:  O(n^2)
"class Solution(object):
    def longestPath(self, parent, s):
        def topological_sort(s, adj, in_degree):
            result = 1
            top2 = collections.defaultdict(lambda:[0]*2)
            q =  [(i, 1) for i, d in enumerate(in_degree) if not d]
            while q:
                new_q = []
                for (u, l) in q:
                    for v in adj[u]:
                        if s[v] != s[u]:
                            if l > top2[v][0]:
                                top2[v][0], top2[v][1] = l, top2[v][0]
                            elif l > top2[v][1]:
                                top2[v][1] = l
                        in_degree[v] -= 1
                        if in_degree[v]:
                            continue
                        new_q.append((v, top2[v][0]+1))
                        result = max(result, top2[v][0]+top2[v][1]+1)
                        del top2[v]
                q = new_q
            return result

        adj = [[] for _ in range(len(s))]
        in_degree = [0]*len(s)
        for i in range(1, len(parent)):
            adj[i].append(parent[i])
            in_degree[parent[i]] += 1
        return topological_sort(s, adj, in_degree)

",# Time:  O(n)
"class Solution2(object):
    def longestPath(self, parent, s):
        def iter_dfs(s, adj):
            result = 0
            stk = [(1, (0, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, ret = args
                    top2 = [0]*2
                    stk.append((4, (top2, ret)))
                    stk.append((2, (u, 0, top2, ret)))
                elif step == 2:
                    u, i, top2, ret = args
                    if i == len(adj[u]):
                        continue
                    ret2 = [0]
                    stk.append((3, (u, i, top2, ret2)))
                    stk.append((1, (adj[u][i], ret2))) 
                elif step == 3:
                    u, i, top2, ret2 = args
                    if s[adj[u][i]] != s[u]:
                        if ret2[0] > top2[0]:
                            top2[0], top2[1] = ret2[0], top2[0]
                        elif ret2[0] > top2[1]:
                            top2[1] = ret2[0]
                    stk.append((2, (u, i+1, top2, ret)))
                elif step == 4:
                    top2, ret = args
                    result = max(result, top2[0]+top2[1]+1)
                    ret[0] = top2[0]+1
            return result
    
        
        adj = [[] for _ in range(len(s))]
        for i in range(1, len(parent)):
            adj[parent[i]].append(i)
        return iter_dfs(s, adj)
    
    
",# Time:  O(n)
"class Solution3(object):
    def longestPath(self, parent, s):
        def dfs(s, adj, u, result):
            top2 = [0]*2
            for v in adj[u]:
                l = dfs(s, adj, v, result)
                if s[v] == s[u]:
                    continue
                if l > top2[0]:
                    top2[0], top2[1] = l, top2[0]
                elif l > top2[1]:
                    top2[1] = l
            result[0] = max(result[0], top2[0]+top2[1]+1)
            return top2[0]+1
    
        
        adj = [[] for _ in range(len(s))]
        for i in range(1, len(parent)):
            adj[parent[i]].append(i)
        result = [0]
        dfs(s, adj, 0, result)
        return result[0]
    ",# Time:  O(n)
"class Solution(object):
    def maximumLength(self, nums):
        cnt = collections.Counter(nums)
        dp = {}
        result = 0
        for x in cnt.keys():
            if x == 1:
                result = max(result, cnt[x]-(1 if cnt[x]%2 == 0 else 0))
                continue
            stk = []
            while x not in dp and x in cnt and cnt[x] >= 2:
                stk.append(x)
                x *= x
            if x not in dp:
                if x not in cnt:
                    x = stk.pop()
                dp[x] = 1
            l = dp[x]
            while stk:
                l += 2
                dp[stk.pop()] = l
            result = max(result, l)
        return result 
    
    
import collections


",# Time:  O(n)
"class Solution2(object):
    def maximumLength(self, nums):
        cnt = collections.Counter(nums)
        result = 0
        for x in cnt.keys():
            if x == 1:
                result = max(result, cnt[x]-(1 if cnt[x]%2 == 0 else 0))
                continue
            l = 0
            while x in cnt and cnt[x] >= 2:
                l += 2
                x *= x
            l += 1 if x in cnt else -1
            result = max(result, l)
        return result 
        ",# Time:  O(n)
"class Solution(object):
    def singleNumber(self, A):
        one, two = 0, 0
        for x in A:
            one, two = (~x & one) | (x & ~one & ~two), (~x & two) | (x & one)
        return one

",# Time:  O(n)
"class Solution2(object):
    def singleNumber(self, A):
        one, two, carry = 0, 0, 0
        for x in A:
            two |= one & x
            one ^= x
            carry = one & two
            one &= ~carry
            two &= ~carry
        return one

",# Time:  O(n)
"class Solution3(object):
    def singleNumber(self, nums):
        return list((collections.Counter(list(set(nums)) * 3) - collections.Counter(nums)).keys())[0]

",# Time:  O(n)
"class Solution4(object):
    def singleNumber(self, nums):
        return (sum(set(nums)) * 3 - sum(nums)) / 2


",# Time:  O(n)
"class Solution5(object):
    def singleNumber(self, A):
        one, two, three = 0, 0, 0
        for x in A:
            one, two, three = (~x & one) | (x & ~one & ~two & ~three), (~x & two) | (x & one), (~x & three) | (x & two)
        return two
",# Time:  O(n)
"class Solution(object):
    def tribonacci(self, n):
        def matrix_expo(A, K):
            result = [[int(i==j) for j in range(len(A))] \
                      for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b for a, b in zip(row, col)) \
                     for col in ZB] for row in A]

        T = [[1, 1, 0],
             [1, 0, 1],
             [1, 0, 0]]
        return matrix_mult([[1, 0, 0]], matrix_expo(T, n))[0][1] 
    
    ",# Time:  O(logn)
"class Solution2(object):
    def tribonacci(self, n):
        a, b, c = 0, 1, 1
        for _ in range(n):
            a, b, c = b, c, a+b+c
        return a",# Time:  O(logn)
"class Solution(object):
    def maxIntersectionCount(self, y):
        val_to_idx = {x:i for i, x in enumerate(sorted(set(y)))}
        cnts = [0]*(2*len(val_to_idx)+1)
        for i in range(len(y)-1):
            left, right = 2*val_to_idx[y[i]], 2*val_to_idx[y[i+1]]+(-1 if y[i] < y[i+1] else +1)
            cnts[min(left, right)] += 1
            cnts[max(left, right)+1] -= 1
        cnts[2*val_to_idx[y[-1]]] += 1
        cnts[2*val_to_idx[y[-1]]+1] -= 1
        result = cnt = 0
        for c in cnts:
            cnt += c
            result = max(result, cnt)
        return result
    
    
",# Time:  O(nlogn)
"class Solution2(object):
    def maxIntersectionCount(self, y):
        events = []
        for i in range(len(y)-1):
            left, right = 2*y[i], 2*y[i+1]+(-1 if y[i] < y[i+1] else +1)
            events.append((min(left, right), +1))
            events.append((max(left, right)+1, -1))
        events.append((2*y[-1], +1))
        events.append((2*y[-1]+1, -1))
        events.sort()
        result = cnt = 0
        for _, c in events:
            cnt += c
            result = max(result, cnt)
        return result",# Time:  O(nlogn)
"class Solution(object):
    def minimumSum(self, num):
        def inplace_counting_sort(nums, reverse=False): 
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()
    
        nums = list(map(int, list(str(num))))
        inplace_counting_sort(nums)
        a = b = 0
        for x in nums:
            a = a*10+x
            a, b = b, a
        return a+b

","# Time:  O(d) = O(1), d is the number of digits"
"class Solution2(object):
    def minimumSum(self, num):
        nums = sorted(map(int, list(str(num))))
        a = b = 0
        for x in nums:
            a = a*10+x
            a, b = b, a
        return a+b","# Time:  O(dlogd) = O(1), d is the number of digits"
"class Solution(object):
    def numSimilarGroups(self, A):
        def isSimilar(a, b):
            diff = 0
            for x, y in zip(a, b):
                if x != y:
                    diff += 1
                    if diff > 2:
                        return False
            return diff == 2

        N, L = len(A), len(A[0])
        union_find = UnionFind(N)
        if N < L*L:
            for (i1, word1), (i2, word2) in \
                    itertools.combinations(enumerate(A), 2):
                if isSimilar(word1, word2):
                    union_find.union_set(i1, i2)
        else:
            buckets = collections.defaultdict(list)
            lookup = set()
            for i in range(len(A)):
                word = list(A[i])
                if A[i] not in lookup:
                    buckets[A[i]].append(i)
                    lookup.add(A[i])
                for j1, j2 in itertools.combinations(range(L), 2):
                    word[j1], word[j2] = word[j2], word[j1]
                    buckets["""".join(word)].append(i)
                    word[j1], word[j2] = word[j2], word[j1]
            for word in A: 
                for i1, i2 in itertools.combinations(buckets[word], 2):
                    union_find.union_set(i1, i2)
        return union_find.size()
",# Time:  O(n^2 * l) ~ O(n * l^4)
"class Solution(object):
    def braceExpansionII(self, expression):
        def form_words(options):
            words = list(map("""".join, itertools.product(*options)))
            words.sort()
            return words

        def generate_option(expr, i):
            option_set = set()
            while i[0] != len(expr) and expr[i[0]] != ""}"":
                i[0] += 1 
                for option in generate_words(expr, i):
                    option_set.add(option)
            i[0] += 1 
            option = list(option_set)
            option.sort()
            return option

        def generate_words(expr, i):
            options = []
            while i[0] != len(expr) and expr[i[0]] not in "",}"":
                tmp = []
                if expr[i[0]] not in ""{,}"":
                    tmp.append(expr[i[0]])
                    i[0] += 1 
                elif expr[i[0]] == ""{"":
                    tmp = generate_option(expr, i)
                options.append(tmp)
            return form_words(options)

        return generate_words(expression, [0])

","# Time:  O(p*l * log(p*l)), p is the production of all number of options"
"class Solution2(object):
    def braceExpansionII(self, expression):
        def form_words(options):
            words = []
            total = 1
            for opt in options:
                total *= len(opt)
            for i in range(total):
                tmp = []
                for opt in reversed(options):
                    i, c = divmod(i, len(opt))
                    tmp.append(opt[c])
                tmp.reverse()
                words.append("""".join(tmp))
            words.sort()
            return words

        def generate_option(expr, i):
            option_set = set()
            while i[0] != len(expr) and expr[i[0]] != ""}"":
                i[0] += 1 
                for option in generate_words(expr, i):
                    option_set.add(option)
            i[0] += 1 
            option = list(option_set)
            option.sort()
            return option

        def generate_words(expr, i):
            options = []
            while i[0] != len(expr) and expr[i[0]] not in "",}"":
                tmp = []
                if expr[i[0]] not in ""{,}"":
                    tmp.append(expr[i[0]])
                    i[0] += 1 
                elif expr[i[0]] == ""{"":
                    tmp = generate_option(expr, i)
                options.append(tmp)
            return form_words(options)

        return generate_words(expression, [0])","# Time:  O(p*l * log(p*l)), p is the production of all number of options"
"class Solution(object):
    def maxNumEdgesToRemove(self, n, edges):
        result = 0
        union_find_a, union_find_b = UnionFind(n), UnionFind(n)
        for t, i, j in edges:
            if t != 3:
                continue
            a = union_find_a.union_set(i-1, j-1)
            b = union_find_b.union_set(i-1, j-1)
            if not a and not b:
                result += 1
        for t, i, j in edges:
            if t == 1:
                if not union_find_a.union_set(i-1, j-1):
                    result += 1
            elif t == 2:
                if not union_find_b.union_set(i-1, j-1):
                    result += 1
        return result if union_find_a.count == union_find_b.count == 1 else -1",# Time:  O(n + m * α(n)) ~= O(n + m)
"class Solution(object):
    def waysToBuyPensPencils(self, total, cost1, cost2):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a
        
        def ceil_divide(a, b):
            return (a+b-1)//b

        def arithmetic_progression_sum(a, d, l):
            return (a+(a+(l-1)*d))*l//2
            
        if cost1 < cost2:
            cost1, cost2 = cost2, cost1
        lcm = cost1*cost2//gcd(cost1, cost2)
        result = 0
        d = lcm//cost2
        for i in range(min(total//cost1+1, lcm//cost1)):
            cnt = (total-i*cost1)//cost2+1
            l = ceil_divide(cnt, d)
            result += arithmetic_progression_sum(cnt, -d, l)
        return result

","# Time:  O(min(t / c1, c2 / g)) = O(sqrt(t)), c1 = max(cost1, cost2)"
"class Solution2(object):
    def waysToBuyPensPencils(self, total, cost1, cost2):
        if cost1 < cost2:
            cost1, cost2 = cost2, cost1
        return sum((total-i*cost1)//cost2+1 for i in range(total//cost1+1))","# Time:  O(t / c1), c1 = max(cost1, cost2)"
"class Solution(object):
    def search(self, nums, target):
        left, right = 0, len(nums) - 1

        while left <= right:
            mid = left + (right - left) / 2

            if nums[mid] == target:
                return True
            elif nums[mid] == nums[left]:
                left += 1
            elif (nums[mid] > nums[left] and nums[left] <= target < nums[mid]) or \
                 (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])):
                right = mid - 1
            else:
                left = mid + 1

        return False

",# Time:  O(logn) ~ O(n)
"class Solution(object):
    def minimumDiameterAfterMerge(self, edges1, edges2):
        def ceil_divide(a, b):
            return (a+b-1)//2
    
        def tree_diameter(edges):
            def iter_dfs():
                result = 0
                stk = [(1, (0, -1, [0]))]
                while stk:
                    step, args = stk.pop()
                    if step == 1:
                        u, p, ret = args
                        for v in reversed(adj[u]):
                            if v == p:
                                continue
                            ret2 = [0]
                            stk.append((2, (ret2, ret)))
                            stk.append((1, (v, u, ret2)))
                    elif step == 2:
                        ret2, ret = args
                        result = max(result, ret[0]+(ret2[0]+1))
                        ret[0] = max(ret[0], ret2[0]+1)
                return result
            
            adj = [[] for _ in range(len(edges)+1)]
            for u, v in edges:
                adj[u].append(v)
                adj[v].append(u)
            return iter_dfs()
        
        d1 = tree_diameter(edges1)
        d2 = tree_diameter(edges2)
        return max(ceil_divide(d1, 2)+1+ceil_divide(d2, 2), d1, d2)
    
    
",# Time:  O(n + m)
"class Solution2(object):
    def minimumDiameterAfterMerge(self, edges1, edges2):
        def ceil_divide(a, b):
            return (a+b-1)//2
    
        def tree_diameter(edges):
            def dfs(u, p):
                mx = 0
                for v in adj[u]:
                    if v == p:
                        continue
                    curr = dfs(v, u)
                    result[0] = max(result[0], mx+(curr+1))
                    mx = max(mx, curr+1)
                return mx
            
            adj = [[] for _ in range(len(edges)+1)]
            for u, v in edges:
                adj[u].append(v)
                adj[v].append(u)
            result = [0]
            dfs(0, -1)
            return result[0]
        
        d1 = tree_diameter(edges1)
        d2 = tree_diameter(edges2)
        return max(ceil_divide(d1, 2)+1+ceil_divide(d2, 2), d1, d2)

",# Time:  O(n + m)
"class Solution3(object):
    def minimumDiameterAfterMerge(self, edges1, edges2):
        def ceil_divide(a, b):
            return (a+b-1)//2
    
        def tree_diameter(edges):
            def bfs():
                result = 0
                dp = [0]*len(adj)
                degree = list(map(len, adj))
                q = [u for u in range(len(degree)) if degree[u] == 1]
                while q:
                    new_q = []
                    for u in q:
                        if degree[u] == 0:
                            continue
                        degree[u] -= 1
                        for v in adj[u]:
                            if degree[v] == 0:
                                continue
                            result = max(result, dp[v]+(dp[u]+1))
                            dp[v] = max(dp[v], (dp[u]+1))
                            degree[v] -= 1
                            if degree[v] == 1:
                                new_q.append(v)
                    q = new_q
                return result
            
            adj = [[] for _ in range(len(edges)+1)]
            for u, v in edges:
                adj[u].append(v)
                adj[v].append(u)
            return bfs()

        d1 = tree_diameter(edges1)
        d2 = tree_diameter(edges2)
        return max(ceil_divide(d1, 2)+1+ceil_divide(d2, 2), d1, d2)

",# Time:  O(n + m)
"class Solution4(object):
    def minimumDiameterAfterMerge(self, edges1, edges2):
        def ceil_divide(a, b):
            return (a+b-1)//2
    
        def tree_diameter(edges):
            def bfs(root):
                d = new_root = -1
                lookup = [False]*len(adj)
                lookup[root] = True
                q = [root]
                while q:
                    d, new_root = d+1, q[0]
                    new_q = []
                    for u in q:
                        for v in adj[u]:
                            if lookup[v]:
                                continue
                            lookup[v] = True
                            new_q.append(v)
                    q = new_q
                return d, new_root
            
            adj = [[] for _ in range(len(edges)+1)]
            for u, v in edges:
                adj[u].append(v)
                adj[v].append(u)
            _, root = bfs(0)
            d, _ = bfs(root)
            return d
        
        d1 = tree_diameter(edges1)
        d2 = tree_diameter(edges2)
        return max(ceil_divide(d1, 2)+1+ceil_divide(d2, 2), d1, d2)",# Time:  O(n + m)
"class Solution(object):
    def maxScore(self, edges):
        def iter_dfs():
            result = [(0, 0) for _ in range(len(adj))]
            stk = [(1, 0)]
            while stk:
                step, u = stk.pop()
                if step == 1:
                    if not adj[u]:
                        continue
                    stk.append((2, u))
                    for v, _ in adj[u]:
                        stk.append((1, v))
                elif step == 2:
                    without_u = sum(max(result[v]) for v, w in adj[u])
                    with_u = max(without_u-max(result[v])+(result[v][1]+w) for v, w in adj[u])
                    result[u] = (with_u, without_u)
            return max(result[0])
            
        adj = [[] for _ in range(len(edges))]
        for i, (p, w) in enumerate(edges):
            if i == 0:
                continue
            adj[p].append((i, w))
        return iter_dfs()
    

",# Time:  O(n)
"class Solution2(object):
    def maxScore(self, edges):
        def dfs(u):
            if not adj[u]:
                return (0, 0)
            children = [dfs(v) for v, _ in adj[u]]
            without_u = sum(max(with_v, without_v) for with_v, without_v in children)
            with_u = max(without_u-max(with_v, without_v)+(without_v+adj[u][i][1]) for i, (with_v, without_v) in enumerate(children))
            return (with_u, without_u)
            
        adj = [[] for _ in range(len(edges))]
        for i, (p, w) in enumerate(edges):
            if i == 0:
                continue
            adj[p].append((i, w))
        return max(dfs(0))",# Time:  O(n)
"class Solution(object):
    def findMin(self, nums):
        left, right = 0, len(nums) - 1
        while left < right:
            mid = left + (right - left) / 2

            if nums[mid] == nums[right]:
                right -= 1
            elif nums[mid] < nums[right]:
                right = mid
            else:
                left = mid + 1

        return nums[left]

",# Time:  O(logn) ~ O(n)
"class Solution2(object):
    def findMin(self, nums):
        left, right = 0, len(nums) - 1
        while left < right and nums[left] >= nums[right]:
            mid = left + (right - left) / 2

            if nums[mid] == nums[left]:
                left += 1
            elif nums[mid] < nums[left]:
                right = mid
            else:
                left = mid + 1

        return nums[left]

",# Time:  O(logn) ~ O(n)
"class Solution(object):
    def wordPatternMatch(self, pattern, str):
        w2p, p2w = {}, {}
        return self.match(pattern, str, 0, 0, w2p, p2w)


    def match(self, pattern, str, i, j, w2p, p2w):
        is_match = False
        if i == len(pattern) and j == len(str):
            is_match = True
        elif i < len(pattern) and j < len(str):
            p = pattern[i]
            if p in p2w:
                w = p2w[p]
                if w == str[j:j+len(w)]: 
                    is_match = self.match(pattern, str, i + 1, j + len(w), w2p, p2w)
            else:
                for k in range(j, len(str)): 
                    w = str[j:k+1]
                    if w not in w2p:
                        w2p[w], p2w[p] = p, w
                        is_match = self.match(pattern, str, i + 1, k + 1, w2p, p2w)
                        w2p.pop(w), p2w.pop(p)
                    if is_match:
                        break
        return is_match

","# Time:  O(n * C(n - 1, c - 1)), n is length of str, c is unique count of pattern,"
"class Solution(object):
    def longestNiceSubstring(self, s):
        lookup = set(list(s))
        prev = -1
        result = """"
        for i in range(len(s)+1):
            if not (i == len(s) or s[i] not in lookup or s[i].swapcase() not in lookup):
                continue
            if prev == -1 and i == len(s):
                return s
            tmp = self.longestNiceSubstring(s[prev+1:i])
            if len(tmp) > len(result):
                result = tmp
            prev = i
        return result",# Time:  O(26 * n) = O(n)
"class Solution(object):
    def preorder(self, root):
        if not root:
            return []
        result, stack = [], [root]
        while stack:
            node = stack.pop()
            result.append(node.val)
            for child in reversed(node.children):
                if child:
                    stack.append(child)
        return result

",# Time:  O(n)
"class Solution2(object):
    def preorder(self, root):
        def dfs(root, result):
            result.append(root.val)
            for child in root.children:
                if child:
                    dfs(child, result)
        
        result = []
        if root:
            dfs(root, result)
        return result
",# Time:  O(n)
"class Solution(object):
    def minimizeResult(self, expression):
        def stoi(s, i, j):
            result = 0
            for k in range(i, j):
                result = result*10+(ord(s[k])-ord('0'))
            return result

        best = None
        min_val = float(""inf"")
        pos = expression.index('+')
        left, right = stoi(expression, 0, pos), stoi(expression, pos+1, len(expression))
        base1, base2_init = 10**pos, 10**(len(expression)-(pos+1)-1)
        for i in range(pos):
            base2 = base2_init
            for j in range(pos+1, len(expression)):
                a, b = divmod(left, base1)
                c, d = divmod(right, base2)
                val = max(a, 1)*(b+c)*max(d, 1)
                if val < min_val:
                    min_val = val
                    best = (i, j)
                base2 //= 10
            base1 //= 10
        return """".join(itertools.chain((expression[i] for i in range(best[0])),
                                       '(', (expression[i] for i in range(best[0], best[1]+1)), ')',
                                       (expression[i] for i in range(best[1]+1, len(expression)))))

",# Time:  O(n^2)
"class Solution2(object):
    def minimizeResult(self, expression):
        best = None
        min_val = float(""inf"")
        pos = expression.index('+')
        left, right = int(expression[0:pos]), int(expression[pos+1:]) 
        base1, base2_init = 10**pos, 10**(len(expression)-(pos+1)-1)
        for i in range(pos):
            base2 = base2_init
            for j in range(pos+1, len(expression)):
                a, b = divmod(left, base1)
                c, d = divmod(right, base2)
                val = max(a, 1)*(b+c)*max(d, 1)
                if val < min_val:
                    min_val = val
                    best = (i, j)
                base2 //= 10
            base1 //= 10
        return """".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]]) 

",# Time:  O(n^2)
"class Solution3(object):
    def minimizeResult(self, expression):
        best = None
        min_val = float(""inf"")
        pos = expression.index('+')
        for i in range(pos):
            for j in range(pos+1, len(expression)):
                val = (int(expression[:i] or ""1"")*
                       (int(expression[i:pos])+int(expression[pos+1:j+1]))*
                       int(expression[j+1:] or ""1"")) 
                if val < min_val:
                    min_val = val
                    best = (i, j)
        return """".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]]) ",# Time:  O(n^2)
"class Solution(object):
    def arithmeticTriplets(self, nums, diff):
        lookup = set(nums)
        return sum((x-diff in lookup) and (x-2*diff in lookup) for x in nums)

import collections


",# Time:  O(n)
"class Solution2(object):
    def arithmeticTriplets(self, nums, diff):
        result = 0
        cnt1 = collections.Counter()
        cnt2 = collections.Counter()
        for x in nums:
            result += cnt2[x-diff]
            cnt2[x] += cnt1[x-diff]
            cnt1[x] += 1
        return result",# Time:  O(n)
"class Solution(object):

    def serialize(self, root):
        def serializeHelper(node):
            if not node:
                vals.append(
                return
            vals.append(str(node.val))
            serializeHelper(node.left)
            serializeHelper(node.right)
        vals = []
        serializeHelper(root)
        return ' '.join(vals)


    def deserialize(self, data):
        def deserializeHelper():
            val = next(vals)
            if val == 
                return None
            node = TreeNode(int(val))
            node.left = deserializeHelper()
            node.right = deserializeHelper()
            return node
        def isplit(source, sep):
            sepsize = len(sep)
            start = 0
            while True:
                idx = source.find(sep, start)
                if idx == -1:
                    yield source[start:]
                    return
                yield source[start:idx]
                start = idx + sepsize
        vals = iter(isplit(data, ' '))
        return deserializeHelper()

",# Time:  O(n)
"class Solution2(object):
    def serialize(self, root):
        def gen_preorder(node):
            if not node:
                yield 
            else:
                yield str(node.val)
                for n in gen_preorder(node.left):
                    yield n
                for n in gen_preorder(node.right):
                    yield n
                
        return ' '.join(gen_preorder(root))
        
    def deserialize(self, data):
        def builder(chunk_iter):
            val = next(chunk_iter)
            if val == 
                return None
            node = TreeNode(int(val))
            node.left = builder(chunk_iter)
            node.right = builder(chunk_iter)
            return node
        chunk_iter = iter(data.split())
        return builder(chunk_iter)",# time: O(n)
"class Solution(object):
    def countPalindromes(self, s):
        MOD = 10**9+7
        cnt = [0]*10
        left = [[[0]*10 for _ in range(10)] for _ in range(len(s)+1)]
        for k in range(len(s)):
            left[k+1] = [[left[k][i][j] for j in range(10)] for i in range(10)]
            for i in range(10):
                left[k+1][int(s[k])][i] += cnt[i]
            cnt[int(s[k])] += 1
        cnt = [0]*10
        right = [[0]*10 for _ in range(10)]
        result = 0
        for k in reversed(range(len(s))):
            for i in range(10):
                for j in range(10):
                    result = (result+left[k][i][j]*right[i][j])%MOD
            for i in range(10):
                right[int(s[k])][i] += cnt[i]
            cnt[int(s[k])] += 1
        return result
    
    
","# Time:  O(10^(l/2) * n), l = 5"
"class Solution2(object):
    def countPalindromes(self, s):
        MOD = 10**9+7
        result = 0
        for i in range(10):
            for j in range(10):
                pattern = ""%s%s*%s%s"" % (i, j, j, i)
                dp = [0]*(5+1)
                dp[0] = 1
                for k in range(len(s)):
                    for l in reversed(range(5)):
                        if pattern[l] == '*' or pattern[l] == s[k]:
                            dp[l+1] = (dp[l+1]+dp[l])%MOD
                result = (result+dp[5])%MOD
        return result","# Time:  O(10^(l/2) * n), l = 5"
"class Solution(object):
    def maxIncreasingGroups(self, usageLimits):
        def inplace_counting_sort(nums, reverse=False): 
            if not nums:
                return
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()

        usageLimits = [min(x, len(usageLimits)) for x in usageLimits]
        inplace_counting_sort(usageLimits)
        result = curr = 0
        for x in usageLimits:
            curr += x
            if curr >= result+1:
                curr -= result+1
                result += 1
        return result

",# Time:  O(n)
"class Solution2(object):
    def maxIncreasingGroups(self, usageLimits):
        usageLimits.sort()
        result = curr = 0
        for x in usageLimits:
            curr += x
            if curr >= result+1:
                curr -= result+1
                result += 1
        return result

",# Time:  O(nlogn)
"class Solution3(object):
    def maxIncreasingGroups(self, usageLimits):
        def check(l):
            curr = 0
            for i in range(l):
                curr += usageLimits[~i]-(l-i)
                curr = min(curr, 0)
            for i in range(len(usageLimits)-l):
                curr += usageLimits[i]
            return curr >= 0

        usageLimits.sort()
        left, right = 1, len(usageLimits)
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right

",# Time:  O(nlogn)
"class Solution4(object):
    def maxIncreasingGroups(self, usageLimits):
        def check(l):
            return all((i+1)*i//2 <= prefix[len(usageLimits)-(l-i)] for i in range(1, l+1))

        usageLimits.sort()
        prefix = [0]*(len(usageLimits)+1)
        for i in range(len(usageLimits)):
            prefix[i+1] = prefix[i]+usageLimits[i]
        left, right = 1, len(usageLimits)
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right",# Time:  O(nlogn)
"class Solution(object):
    def isSymmetric(self, root):
        if root is None:
            return True
        stack = []
        stack.append(root.left)
        stack.append(root.right)

        while stack:
            p, q = stack.pop(), stack.pop()

            if p is None and q is None:
                continue

            if p is None or q is None or p.val != q.val:
                return False

            stack.append(p.left)
            stack.append(q.right)

            stack.append(p.right)
            stack.append(q.left)

        return True


",# Time:  O(n)
"class Solution2(object):
    def isSymmetric(self, root):
        if root is None:
            return True

        return self.isSymmetricRecu(root.left, root.right)

    def isSymmetricRecu(self, left, right):
        if left is None and right is None:
            return True
        if left is None or right is None or left.val != right.val:
            return False
        return self.isSymmetricRecu(left.left, right.right) and self.isSymmetricRecu(left.right, right.left)
",# Time:  O(n)
"class Solution(object):
    def getLucky(self, s, k):
        total = reduce(lambda total, x: total+sum(divmod((ord(x)-ord('a')+1), 10)), s, 0)
        while k > 1 and total > 9:
            new_total = 0
            while total:
                total, x = divmod(total, 10)
                new_total += x
            total = new_total
            k -= 1
        return total",# Time:  O(n + logn + log(logn) + ...) = O(n)
"class Solution(object):
    def kthLargestNumber(self, nums, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
        
        nth_element(nums, k-1, compare=lambda a, b: a > b if len(a) == len(b) else len(a) > len(b))
        return nums[k-1]","# Time:  O(n) ~ O(n^2), O(n) on average"
"class Solution(object):
    def kInversePairs(self, n, k):
        MOD = 10**9+7
        dp = [1]
        for i in range(n):
            new_dp = [0]*min(len(dp)+((i+1)-1), k+1)
            for j in range(len(new_dp)):
                new_dp[j] = dp[j] if j < len(dp) else 0
                if j-1 >= 0:
                    new_dp[j] = (new_dp[j]+new_dp[j-1])%MOD
                if j-(i+1) >= 0:
                    new_dp[j] = (new_dp[j]-dp[j-(i+1)])%MOD
            dp = new_dp
        return dp[k] if k < len(dp) else 0

",# Time:  O(n * k)
"class Solution2(object):
    def kInversePairs(self, n, k):
        MOD = 10**9+7
        dp = [0]*(k+1)
        dp[0] = 1
        for i in range(n):
            new_dp = [0]*len(dp)
            for j in range(len(dp)):
                new_dp[j] = dp[j]
                if j-1 >= 0:
                    new_dp[j] = (new_dp[j]+new_dp[j-1])%MOD
                if j-(i+1) >= 0:
                    new_dp[j] = (new_dp[j]-dp[j-(i+1)])%MOD
            dp = new_dp
        return dp[-1]

",# Time:  O(n * k)
"class Solution3(object):
    def kInversePairs(self, n, k):
        MOD = 10**9+7
        dp = [0]*(k+1)
        dp[0] = 1
        for i in range(n):
            new_dp = [0]*len(dp)
            curr = 0
            for j in range(len(dp)):
                curr = (curr+dp[j])%MOD
                if j-(i+1) >= 0:
                    curr = (curr-dp[j-(i+1)])%MOD
                new_dp[j] = curr
            dp = new_dp
        return dp[-1]

",# Time:  O(n * k)
"class Solution_TLE(object):
    def kInversePairs(self, n, k):
        MOD = 10**9+7
        dp = [0]*(k+1)
        dp[0] = 1
        for i in range(n):
            dp = [reduce(lambda total, k: (total+dp[j-k])%MOD, range(min(i+1, j+1)), 0) for j in range(len(dp))]
        return dp[-1]%MOD

",# Time:  O(n^2 * k)
"class Solution_ConstructPermutation(object):
    def kInversePairs(self, n, k):
        MOD = 10**9+7
        dp = [[] for _ in range(k+1)]
        dp[0].append([])
        for i in range(n):
            dp = [[[x+int(x >= i-k) for x in p]+[i-k] for k in range(min(i+1, j+1)) for p in dp[j-k]] for j in range(len(dp))]
        assert(all(sum(int(p[j] > p[i]) for i in range(n) for j in range(i)) == len(dp)-1) for p in dp[-1])
        return len(dp[-1])%MOD

",# Time:  O(n^2 * k)
"class Solution_ConstructPermutation2(object):
    def kInversePairs(self, n, k):
        MOD = 10**9+7
        dp = [[] for _ in range(k+1)]
        dp[0].append([])
        for i in range(n):
            dp = [[p[:len(p)-k]+[i]+p[len(p)-k:] for k in range(min(i+1, j+1)) for p in dp[j-k]] for j in range(len(dp))]
        assert(all(sum(int(p[j] > p[i]) for i in range(n) for j in range(i)) == len(dp)-1) for p in dp[-1])
        return len(dp[-1])%MOD",# Time:  O(n^2 * k)
"class Solution(object):
    def smallestEquivalentString(self, A, B, S):
        union_find = UnionFind(26)
        for i in range(len(A)):
            union_find.union_set(ord(A[i])-ord('a'), ord(B[i])-ord('a'))
        result = []
        for i in range(len(S)):
            parent = union_find.find_set(ord(S[i])-ord('a'))
            result.append(chr(parent+ord('a')))
        return """".join(result)","# Time:  O(nlog*n) ~= O(n), n is the length of S"
"class Solution(object):
    def kSimilarity(self, A, B):
        def neighbors(s, B):
            for i, c in enumerate(s):
                if c != B[i]:
                    break
            t = list(s)
            for j in range(i+1, len(s)):
                if t[j] == B[i]:
                    t[i], t[j] = t[j], t[i]
                    yield """".join(t)
                    t[j], t[i] = t[i], t[j]

        q = collections.deque([A])
        lookup = set()
        result = 0
        while q:
            for _ in range(len(q)):
                s = q.popleft()
                if s == B:
                    return result
                for t in neighbors(s, B):
                    if t not in lookup:
                        lookup.add(t)
                        q.append(t)
            result += 1
","# Time:  O(n * n!/(c_a!*...*c_z!), n is the length of A, B,"
"class Solution(object):
    def __init__(self):
        self.__max_log3 = int(math.log(0x7fffffff) / math.log(3))
        self.__max_pow3 = 3 ** self.__max_log3

    def isPowerOfThree(self, n):
        return n > 0 and self.__max_pow3 % n == 0

",# Time:  O(1)
"class Solution2(object):
    def isPowerOfThree(self, n):
        return n > 0 and (math.log10(n)/math.log10(3)).is_integer()
",# Time:  O(1)
"class Solution(object):
    def equalCountSubstrings(self, s, count):
        result = 0
        for l in range(1, min(len(set(s)), len(s)//count)+1):
            cnt, equal_cnt = collections.Counter(), 0
            for i, c in enumerate(s):
                cnt[c] += 1
                equal_cnt += (cnt[c] == count)
                if i >= count*l:
                    equal_cnt -= (cnt[s[i-count*l]] == count)
                    cnt[s[i-count*l]] -= 1
                result += (equal_cnt == l)
        return result",# Time:  O(26 * n) = O(n)
"class Solution(object):
    def maxMoves(self, kx, ky, positions):
        N = 50
        DIRECTIONS = ((1, 2), (-1, 2), (1, -2), (-1, -2), (2, 1), (-2, 1), (2, -1), (-2, -1))
        POS_INF = float(""inf"")
        NEG_INF = float(""-inf"")
        def popcount(r):
            return bin(r)[2:].count('1')
    
        def bfs(r, c):
            dist = [[POS_INF]*N for _ in range(N)]
            dist[r][c] = 0
            q = [(r, c)]
            while q:
                new_q = []
                for r, c in q:
                    for dr, dc in DIRECTIONS:
                        nr, nc = r+dr, c+dc
                        if not (0 <= nr < N and 0 <= nc < N and dist[nr][nc] == POS_INF):
                            continue
                        dist[nr][nc] = dist[r][c]+1
                        new_q.append((nr, nc))
                q = new_q
            return dist

        p = len(positions)
        positions.append([kx, ky])
        dist = [[0]*(p+1) for _ in range(p+1)]
        for i, (r, c) in enumerate(positions):
            d = bfs(r, c)
            for j in range(i+1, p+1):
                dist[j][i] = dist[i][j] = d[positions[j][0]][positions[j][1]]
        dp = [[POS_INF if popcount(mask)&1 else NEG_INF]*p for mask in range(1<<p)]
        dp[-1] = [0]*p
        for mask in reversed(range(1, 1<<p)):
            fn = (max, min)[(popcount(mask)&1)^1]
            for i in range(p):
                if (mask&(1<<i)) == 0:
                    continue
                for j in range(p):
                    if j == i or (mask&(1<<j)) == 0:
                        continue
                    dp[mask^(1<<i)][j] = fn(dp[mask^(1<<i)][j], dp[mask][i]+dist[i][j])
        return max(dp[1<<i][i]+dist[i][p] for i in range(p))",# Time:  O(p * n^2 + p^2 + p^2 * 2^p) = O(p^2 * 2^p)
"class Solution(object):
    def countPairs(self, nums, k):
        def gcd(x, y):
            while y:
                x, y = y, x%y
            return x
    
        idxs = collections.defaultdict(list)
        for i, x in enumerate(nums):
            idxs[x].append(i)
        result = 0
        for idx in idxs.values():
            gcds = collections.Counter()
            for i in idx:
                gcd_i = gcd(i, k)
                result += sum(cnt for gcd_j, cnt in gcds.items() if gcd_i*gcd_j%k == 0)
                gcds[gcd_i] += 1
        return result

",# Time:  O(nlogk + n * sqrt(k))
"class Solution2(object):
    def countPairs(self, nums, k):
        def gcd(x, y):
            while y:
                x, y = y, x%y
            return x
    
        cnts = collections.defaultdict(collections.Counter)
        for i, x in enumerate(nums):
            cnts[x][gcd(i, k)] += 1
        result = 0
        for cnt in cnts.values():
            for x in cnt.keys():
                for y in cnt.keys():
                    if x > y or x*y%k:
                        continue
                    result += cnt[x]*cnt[y] if x != y else cnt[x]*(cnt[x]-1)//2
        return result

",# Time:  O(nlogk + n * sqrt(k)^2) = O(n * k)
"class Solution3(object):
    def countPairs(self, nums, k):
        idxs = collections.defaultdict(list)
        for i, x in enumerate(nums):
            idxs[x].append(i)
        return sum(idx[i]*idx[j]%k == 0 for idx in idxs.values() for i in range(len(idx)) for j in range(i+1, len(idx)))",# Time:  O(n^2)
"class Solution(object):
    def findComplement(self, num):
        return 2 ** (len(bin(num)) - 2) - 1 - num

",# Time:  O(1)
"class Solution2(object):
    def findComplement(self, num):
        i = 1
        while i <= num:
            i <<= 1
        return (i - 1) ^ num

",# Time:  O(1)
"class Solution3(object):
    def findComplement(self, num):
        bits = '{0:b}'.format(num)
        complement_bits = ''.join('1' if bit == '0' else '0' for bit in bits)
        return int(complement_bits, 2)
",# Time:  O(1)
"class Solution(object):
    def trimMean(self, arr):
        P = 20
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
        
        k = len(arr)//P
        nth_element(arr, k-1)
        nth_element(arr, len(arr)-k, left=k)
        return float(sum(arr[i] for i in range(k, len(arr)-k)))/(len(arr)-2*k)","# Time:  O(n) on average, using Median of Medians could achieve O(n) (Intro Select)"
"class Solution(object):
    def numIslands2(self, m, n, positions):
        def node_id(node, n):
            return node[0] * n + node[1]

        def find_set(x):
           if set[x] != x:
               set[x] = find_set(set[x]) 
           return set[x]

        def union_set(x, y):
            x_root, y_root = find_set(x), find_set(y)
            set[min(x_root, y_root)] = max(x_root, y_root)

        numbers = []
        number = 0
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        set = {}
        for position in positions:
            node = (position[0], position[1])
            set[node_id(node, n)] = node_id(node, n)
            number += 1

            for d in directions:
                neighbor = (position[0] + d[0], position[1] + d[1])
                if 0 <= neighbor[0] < m and 0 <= neighbor[1] < n and \
                   node_id(neighbor, n) in set:
                   if find_set(node_id(node, n)) != find_set(node_id(neighbor, n)):
                       union_set(node_id(node, n), node_id(neighbor, n))
                       number -= 1
            numbers.append(number)

        return numbers
","# Time:  O(klog*k) ~= O(k), k is the length of the positions"
"class Solution(object):
    def pseudoPalindromicPaths (self, root):
        result = 0
        stk = [(root, 0)]
        while stk:
            node, count = stk.pop()
            if not node:
                continue
            count ^= 1 << (node.val-1)
            result += int(node.left == node.right and count&(count-1) == 0)
            stk.append((node.right, count))
            stk.append((node.left, count))
        return result",# Time:  O(n)
"class Solution2(object):
    def pseudoPalindromicPaths (self, root):
        def dfs(node, count):
            if not root:
                return 0
            count ^= 1 << (node.val-1)
            return int(node.left == node.right and count&(count-1) == 0) + \
                   dfs(node.left, count) + dfs(node.right, count)
        return dfs(root, 0)",# Time:  O(n)
"class Solution(object):
    def __init__(self):
        M = 10**5
        self.__lookup = [0]
        i = 10
        while i < M:
            self.__lookup.append(i)
            i *= 10
        self.__lookup.append(i)

    def findNumbers(self, nums):
        def digit_count(n):
            return bisect.bisect_right(self.__lookup, n)

        return sum(digit_count(n) % 2 == 0 for n in nums)","# Time:  O(nlog(logm)), n the length of nums, m is the max value of nums"
"class Solution2(object):
    def findNumbers(self, nums):
        def digit_count(n):
            result = 0
            while n:
                n //= 10
                result += 1
            return result

        return sum(digit_count(n) % 2 == 0 for n in nums)

","# Time:  O(nlog(logm)), n the length of nums, m is the max value of nums"
"class Solution3(object):
    def findNumbers(self, nums):
        return sum(len(str(n)) % 2 == 0 for n in nums)","# Time:  O(nlogm), n the length of nums, m is the max value of nums"
"class Solution(object):
    def maxProduct(self, words):
        def counting_sort(words):
            k = 1000 
            buckets = [[] for _ in range(k)]
            for word in words:
                buckets[len(word)].append(word)
            res = []
            for i in reversed(range(k)):
                if buckets[i]:
                    res += buckets[i]
            return res

        words = counting_sort(words)
        bits = [0] * len(words)
        for i, word in enumerate(words):
            for c in word:
                bits[i] |= (1 << (ord(c) - ord('a')))

        max_product = 0
        for i in range(len(words) - 1):
            if len(words[i]) ** 2 <= max_product:
                break
            for j in range(i + 1, len(words)):
                if len(words[i]) * len(words[j]) <= max_product:
                    break
                if not (bits[i] & bits[j]):
                    max_product = len(words[i]) * len(words[j])
        return max_product
",# Time:  O(n) ~ O(n^2)
"class Solution2(object):
    def maxProduct(self, words):
        words.sort(key=lambda x: len(x), reverse=True)
        bits = [0] * len(words)
        for i, word in enumerate(words):
            for c in word:
                bits[i] |= (1 << (ord(c) - ord('a')))

        max_product = 0
        for i in range(len(words) - 1):
            if len(words[i]) ** 2 <= max_product:
                break
            for j in range(i + 1, len(words)):
                if len(words[i]) * len(words[j]) <= max_product:
                    break
                if not (bits[i] & bits[j]):
                    max_product = len(words[i]) * len(words[j])
        return max_product
",# Time:  O(nlogn) ~ O(n^2)
"class Solution(object):
    def luckyNumbers(self, matrix):
        rows = list(map(min, matrix))
        cols = list(map(max, zip(*matrix)))
        return [cell for i, row in enumerate(matrix)
                     for j, cell in enumerate(row) if rows[i] == cols[j]]

import itertools

",# Time:  O(m * n)
"class Solution2(object):
    def luckyNumbers(self, matrix):
        return list(set(map(min, matrix)) &
                    set(map(max, zip(*matrix))))
 ",# Time:  O(m * n)
"class Solution(object):
    def maximumScore(self, nums, k):
        MOD = 10**9+7
        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return primes 


        lookup = {}
        def count_of_distinct_prime_factors(x):
            y = x
            if y not in lookup:
                cnt = 0
                for p in primes:
                    if p*p > x:
                        break
                    if x%p != 0:
                        continue
                    cnt += 1
                    while x%p == 0:
                        x //= p
                if x != 1:
                    cnt += 1
                lookup[y] = cnt
            return lookup[y]

        primes = linear_sieve_of_eratosthenes(int(max(nums)**0.5))
        scores = [count_of_distinct_prime_factors(x) for x in nums]

        left = [-1]*len(scores)
        stk = [-1]
        for i in range(len(scores)):
            while stk[-1] != -1 and scores[stk[-1]] < scores[i]: 
                stk.pop()
            left[i] = stk[-1]
            stk.append(i)
        right = [-1]*len(scores)
        stk = [len(scores)]
        for i in reversed(range(len(scores))):
            while stk[-1] != len(scores) and scores[stk[-1]] <= scores[i]:
                stk.pop()
            right[i] = stk[-1]
            stk.append(i)
        
        result = 1
        max_heap = [(-x, i) for i, x in enumerate(nums)]
        heapq.heapify(max_heap)
        while max_heap:
            _, i = heapq.heappop(max_heap)
            c = min((i-left[i])*(right[i]-i), k)
            result = (result*pow(nums[i], c, MOD))%MOD
            k -= c
            if not k:
                break
        return result
","# Time:  O(sqrt(r) + n * (logr + pi(sqrt(r))) + klogn) = O(sqrt(r) + n * (logr + sqrt(r)/log(sqrt(r))) + klogn), m is max(k for _, k in queries), pi(n) = number of primes in a range [1, n] = O(n/logn) by prime number theorem, see https://en.wikipedia.org/wiki/Prime_number_theorem"
"class Solution(object):
    def countDistinct(self, nums, k, p):
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result = 0
        for i in range(len(nums)):
            cnt = 0
            curr = trie
            for j in range(i, len(nums)):
                cnt += (nums[j]%p == 0)
                if cnt > k:
                    break
                if nums[j] not in curr:
                    result += 1
                curr = curr[nums[j]]
        return result

",# Time:  O(n^2)
"class Solution2(object):
    def countDistinct(self, nums, k, p):
        MOD, P = 10**9+7, 113
        def check(nums, lookup, l, i):
            return all(any(nums[i+k] != nums[j+k] for k in range(l)) for j in lookup)

        result = 0
        cnt, h = [0]*len(nums), [0]*len(nums)
        for l in range(1, len(nums)+1):
            lookup = collections.defaultdict(list)
            for i in range(len(nums)-l+1):
                cnt[i] += (nums[i+l-1]%p == 0)
                if cnt[i] > k:
                    continue
                h[i] = (h[i]*P+nums[i+l-1])%MOD
                if not check(nums, lookup[h[i]], l, i):
                    continue
                lookup[h[i]].append(i)
                result += 1
        return result

","# Time:  O(n^2) on average, worst is O(n^3)"
"class Solution3(object):
    def countDistinct(self, nums, k, p):
        MOD, P = 10**9+7, 200
        result = 0
        cnt, h = [0]*len(nums), [0]*len(nums)
        for l in range(1, len(nums)+1):
            lookup = set()
            for i in range(len(nums)-l+1):
                cnt[i] += (nums[i+l-1]%p == 0)
                if cnt[i] > k:
                    continue
                h[i] = (h[i]*P+nums[i+l-1])%MOD
                lookup.add(h[i])
            result += len(lookup)
        return result",# Time:  O(n^2)
"class Solution(object):
    def findSmallestInteger(self, nums, value):
        cnt = collections.Counter(x%value for x in nums)
        mn = min((cnt[i], i) for i in range(value))[1]
        return value*cnt[mn]+mn
import collections


",# Time:  O(n)
"class Solution2(object):
    def findSmallestInteger(self, nums, value):
        cnt = collections.Counter(x%value for x in nums)
        for i in range(len(nums)+1):
            if not cnt[i%value]:
                return i
            cnt[i%value] -= 1",# Time:  O(n)
"class Solution(object):
    def leastOpsExpressTarget(self, x, target):
        pos, neg, k = 0, 0, 0
        while target:
            target, r = divmod(target, x)
            if k:
                pos, neg = min(r*k + pos, (r+1)*k + neg), \
                           min((x-r)*k + pos, (x-r-1)*k + neg)
            else:
                pos, neg = r*2, (x-r)*2
            k += 1
        return min(pos, k+neg) - 1",# Time:  O(logn/logx) = O(1)
"class Solution(object):
    def maxRepOpt1(self, text):
        K = 1
        result = 0
        total_count, count = collections.Counter(), collections.Counter()
        left, max_count = 0, 0
        for i in range(len(text)):
            total_count[text[i]] += 1
            count[text[i]] += 1
            max_count = max(max_count, count[text[i]])
            if i-left+1 - max_count > K:
                count[text[left]] -= 1
                left += 1
            result = max(result, min(i-left+1, total_count[text[i]]))
        return result


import itertools

",# Time:  O(n)
"class Solution2(object):
    def maxRepOpt1(self, text):
        A = [[c, len(list(group))] for c, group in itertools.groupby(text)]
        total_count = collections.Counter(text)
        result = max(min(l+1, total_count[c]) for c, l in A)
        for i in range(1, len(A)-1):
            if A[i-1][0] == A[i+1][0] and A[i][1] == 1:
                result = max(result, min(A[i-1][1] + 1 + A[i+1][1], total_count[A[i+1][0]]))
        return result",# Time:  O(n)
"class Solution(object):
    def triangularSum(self, nums):
        def exp_mod(p, mod):
            result = [p]
            while result[-1]*p%10 != result[0]:
                 result.append(result[-1]*p%10)
            return [result[-1]]+result[:-1]

        def inv_mod(x, mod):
            y = x
            while y*x%10 != 1:
                y = y*x%10
            return y

        def factor_p(x, p, cnt, diff):
            if x == 0:
                return x, cnt
            while x%p == 0:
                x //= p
                cnt += diff
            return x, cnt
    
        EXP = {p:exp_mod(p, 10) for p in (2, 5)} 
        INV = {i:inv_mod(i, 10) for i in range(1, 10) if i%2 and i%5} 
        result = 0
        nCr = 1
        cnt = {2:0, 5:0}
        for i in range(len(nums)):
            if not cnt[2] and not cnt[5]:
                result = (result + nCr*nums[i])%10
            elif cnt[2] and not cnt[5]:
                result = (result + nCr*EXP[2][cnt[2]%len(EXP[2])]*nums[i])%10
            elif not cnt[2] and cnt[5]:
                result = (result + nCr*EXP[5][cnt[5]%len(EXP[5])]*nums[i])%10
            mul, cnt[2] = factor_p((len(nums)-1)-i, 2, cnt[2], 1)
            mul, cnt[5] = factor_p(mul, 5, cnt[5], 1)
            div, cnt[2] = factor_p(i+1, 2, cnt[2], -1)
            div, cnt[5] = factor_p(div, 5, cnt[5], -1)
            nCr = nCr*mul%10
            nCr = nCr*INV[div%10]%10
        return result

",# Time:  O(n)
"class Solution2(object):
    def triangularSum(self, nums):
        result = 0
        nCr = 1
        for i in range(len(nums)):
            result = (result+nCr*nums[i])%10
            nCr *= (len(nums)-1)-i
            nCr //= i+1
        return result

",# Time:  O(n)
"class Solution3(object):
    def triangularSum(self, nums):
        for i in reversed(range(len(nums))):
            for j in range(i):
                nums[j] = (nums[j]+nums[j+1])%10
        return nums[0]",# Time:  O(n^2)
"class Solution(object):
    def minimumEffortPath(self, heights):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        dst = (len(heights)-1, len(heights[0])-1)
        dist = [[float(""inf"")]*len(heights[0]) for _ in range(len(heights))]
        dist[0][0] = 0
        min_heap = [(0, 0, 0)]
        lookup = [[False]*len(heights[0]) for _ in range(len(heights))]
        while min_heap:
            d, r, c = heapq.heappop(min_heap)
            if lookup[r][c]:
                continue
            lookup[r][c] = True
            if (r, c) == dst:
                return d
            for dr, dc in directions:
                nr, nc = r+dr, c+dc
                if not (0 <= nr < len(heights) and 0 <= nc < len(heights[0]) and not lookup[nr][nc]):
                    continue
                nd = max(d, abs(heights[nr][nc]-heights[r][c]))
                if nd < dist[nr][nc]:
                    dist[nr][nc] = nd
                    heapq.heappush(min_heap, (nd, nr, nc))
        return -1

",# Time:  O(m * n * log(m * n))
"class Solution2(object):
    def minimumEffortPath(self, heights):
        def index(n, i, j):
            return i*n + j
    
        diffs = []
        for i in range(len(heights)):
            for j in range(len(heights[0])):
                if i > 0:
                    diffs.append((abs(heights[i][j]-heights[i-1][j]), index(len(heights[0]), i-1, j), index(len(heights[0]), i, j)))
                if j > 0:
                    diffs.append((abs(heights[i][j]-heights[i][j-1]), index(len(heights[0]), i, j-1), index(len(heights[0]), i, j)))
        diffs.sort()
        union_find = UnionFind(len(heights)*len(heights[0]))
        for d, i, j in diffs:
            if union_find.union_set(i, j):
                if union_find.find_set(index(len(heights[0]), 0, 0)) == \
                   union_find.find_set(index(len(heights[0]), len(heights)-1, len(heights[0])-1)):
                    return d
        return 0

",# Time:  O(m * n * log(m * n) + m * n * α(m * n)) = O(m * n * log(m * n))
"class Solution3(object):
    def minimumEffortPath(self, heights):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def check(heights, x): 
            lookup = [[False]*len(heights[0]) for _ in range(len(heights))]
            left, right = {(0, 0)}, {(len(heights)-1, len(heights[0])-1)}
            while left:
                for r, c in left:
                    lookup[r][c] = True
                new_left = set()
                for r, c in left:
                    if (r, c) in right: 
                        return True
                    for dr, dc in directions:
                        nr, nc = r+dr, c+dc
                        if not (0 <= nr < len(heights) and
                                0 <= nc < len(heights[0]) and
                                abs(heights[nr][nc]-heights[r][c]) <= x and
                                not lookup[nr][nc]):
                            continue
                        new_left.add((nr, nc))
                left = new_left
                if len(left) > len(right): 
                    left, right = right, left
            return False            
        

        left, right = 0, 10**6
        while left <= right:
            mid = left + (right-left)//2
            if check(heights, mid):
                right = mid-1
            else:
                left = mid+1
        return left

",# Time:  O(m * n * logh)
"class Solution4(object):
    def minimumEffortPath(self, heights):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def check(heights, x):
            lookup = [[False]*len(heights[0]) for _ in range(len(heights))]
            q = collections.deque([(0, 0)])
            while q:
                r, c = q.popleft()
                if (r, c) == (len(heights)-1, len(heights[0])-1):
                    return True
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 <= nr < len(heights) and
                                0 <= nc < len(heights[0]) and
                                abs(heights[nr][nc]-heights[r][c]) <= x and
                                not lookup[nr][nc]):
                            continue
                    lookup[nr][nc] = True
                    q.append((nr, nc))
            return False            
        
        left, right = 0, 10**6
        while left <= right:
            mid = left + (right-left)//2
            if check(heights, mid):
                right = mid-1
            else:
                left = mid+1
        return left

",# Time:  O(m * n * logh)
"class Solution5(object):
    def minimumEffortPath(self, heights):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def check(heights, x):
            lookup = [[False]*len(heights[0]) for _ in range(len(heights))]
            stk = [(0, 0)]
            while stk:
                r, c = stk.pop()
                if (r, c) == (len(heights)-1, len(heights[0])-1):
                    return True
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 <= nr < len(heights) and
                                0 <= nc < len(heights[0]) and
                                abs(heights[nr][nc]-heights[r][c]) <= x and
                                not lookup[nr][nc]):
                            continue
                    lookup[nr][nc] = True
                    stk.append((nr, nc))
            return False            
        
        left, right = 0, 10**6
        while left <= right:
            mid = left + (right-left)//2
            if check(heights, mid):
                right = mid-1
            else:
                left = mid+1
        return left",# Time:  O(m * n * logh)
"class Solution(object):
    def rotate(self, nums, k):
        def reverse(nums, start, end):
            while start < end:
                nums[start], nums[end - 1] = nums[end - 1], nums[start]
                start += 1
                end -= 1

        k %= len(nums)
        reverse(nums, 0, len(nums))
        reverse(nums, 0, k)
        reverse(nums, k, len(nums))

",# Time:  O(n)
"class Solution2(object):
    def rotate(self, nums, k):
        def apply_cycle_permutation(k, offset, cycle_len, nums):
            tmp = nums[offset]
            for i in range(1, cycle_len):
                nums[(offset + i * k) % len(nums)], tmp = tmp, nums[(offset + i * k) % len(nums)]
            nums[offset] = tmp

        k %= len(nums)
        num_cycles = gcd(len(nums), k)
        cycle_len = len(nums) / num_cycles
        for i in range(num_cycles):
            apply_cycle_permutation(k, i, cycle_len, nums)

",# Time:  O(n)
"class Solution3(object):
    def rotate(self, nums, k):
        count = 0
        start = 0
        while count < len(nums):
            curr = start
            prev = nums[curr]
            while True:
                idx = (curr + k) % len(nums)
                nums[idx], prev = prev, nums[idx]
                curr = idx
                count += 1
                if start == curr:
                    break
            start += 1

",# Time:  O(n)
"class Solution4(object):
    def rotate(self, nums, k):
        nums[:] = nums[len(nums) - k:] + nums[:len(nums) - k]",# Time:  O(n)
"class Solution5(object):
    def rotate(self, nums, k):
        while k > 0:
            nums.insert(0, nums.pop())
            k -= 1

 ",# Time:  O(n)
"class Solution(object):
    def getCoprimes(self, nums, edges):
        def iter_dfs(nums, adj):
            result = [-1]*len(nums)
            path = collections.defaultdict(list)
            stk = [(1, (-1, 0, 0))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    prev, node, depth = params
                    stk.append((4, (node,)))
                    stk.append((3, (prev, node, depth)))
                    stk.append((2, (node,)))
                elif step == 2:
                    node = params[0]
                    max_d = -1
                    for x in path.keys():
                        if fractions.gcd(nums[node], x) != 1:
                            continue
                        if path[x][-1][1] > max_d:
                            max_d = path[x][-1][1]
                            result[node] = path[x][-1][0]
                elif step == 3:
                    prev, node, depth = params
                    path[nums[node]].append((node, depth))
                    for nei in adj[node]:
                        if nei == prev:
                            continue
                        stk.append((1, (node, nei, depth+1)))
                elif step == 4:
                    node = params[0]
                    path[nums[node]].pop()
                    if not path[nums[node]]:
                        path.pop(nums[node])
            return result

        adj = collections.defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs(nums, adj)

",# Time:  O(50 * n) = O(n)
"class Solution2(object):
    def getCoprimes(self, nums, edges):
        def dfs(nums, adj, prev, node, depth, path, result):
            max_d = -1
            for x in path.keys():
                if fractions.gcd(nums[node], x) != 1:
                    continue
                if path[x][-1][1] > max_d:
                    max_d = path[x][-1][1]
                    result[node] = path[x][-1][0]
            path[nums[node]].append((node, depth))
            for nei in adj[node]:
                if nei == prev:
                    continue
                dfs(nums, adj, node, nei, depth+1, path, result)
            path[nums[node]].pop()
            if not path[nums[node]]:
                path.pop(nums[node])

        adj = collections.defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [-1]*len(nums)
        path = collections.defaultdict(list)
        dfs(nums, adj, -1, 0, 0, path, result)
        return result",# Time:  O(50 * n) = O(n)
"class Solution(object):
    def numOfSubarrays(self, arr, k, threshold):
        result, curr = 0, sum(itertools.islice(arr, 0, k-1))
        for i in range(k-1, len(arr)):
            curr += arr[i]-(arr[i-k] if i-k >= 0 else 0)
            result += int(curr >= threshold*k)
        return result",# Time:  O(n)
"class Solution2(object):
    def numOfSubarrays(self, arr, k, threshold):
        accu = [0]
        for x in arr:
            accu.append(accu[-1]+x)
        result = 0
        for i in range(len(accu)-k):
            if accu[i+k]-accu[i] >= threshold*k:
                result += 1
        return result",# Time:  O(n)
"class Solution(object):
    def firstPalindrome(self, words):
        def is_palindrome(s):
            i, j = 0, len(s)-1
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        for w in words:
            if is_palindrome(w):
                return w
        return """"
",# Time:  O(n)
"class Solution2(object):
    def firstPalindrome(self, words):
        return next((x for x in words if x == x[::-1]), """")",# Time:  O(n)
"class Solution(object):
    def reverseBits(self, n):
        n = (n >> 16) | (n << 16)
        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8)
        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4)
        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2)
        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1)
        return n

",# Time : O(32)
"class Solution2(object):
    def reverseBits(self, n):
        result = 0
        for i in range(32):
            result <<= 1
            result |= n & 1
            n >>= 1
        return result
",# Time : O(logn) = O(32)
"class Solution(object):
    def minReverseOperations(self, n, p, banned, k):
        lookup = [False]*n
        for i in banned:
            lookup[i] = True
        d = 0
        result = [-1]*n
        result[p] = d
        uf = UnionFind(n+2)
        uf.union_set(p, p+2)
        q = [p]
        d += 1
        while q:
            new_q = []
            for p in q:
                left, right = 2*max(p-(k-1), 0)+(k-1)-p, 2*min(p+(k-1), n-1)-(k-1)-p
                p = uf.right_set(left)
                while p <= right:
                    if not lookup[p]:
                        result[p] = d
                        new_q.append(p)
                    uf.union_set(p, p+2)
                    p = uf.right_set(p)
            q = new_q
            d += 1
        return result

",# Time:  O(n * alpha(n)) = O(n)
"class Solution2(object):
    def minReverseOperations(self, n, p, banned, k):
        lookup = [False]*n
        for i in banned:
            lookup[i] = True
        d = 0
        result = [-1]*n
        result[p] = d
        sl = [SortedList(i for i in range(0, n, 2)), SortedList(i for i in range(1, n, 2))]
        sl[p%2].remove(p)
        q = [p]
        d += 1
        while q:
            new_q = []
            for p in q:
                left, right = 2*max(p-(k-1), 0)+(k-1)-p, 2*min(p+(k-1), n-1)-(k-1)-p
                for p in list(sl[left%2].irange(left, right)):
                    if not lookup[p]:
                        result[p] = d
                        new_q.append(p)
                    sl[left%2].remove(p)
            q = new_q
            d += 1
        return result",# Time:  O(nlogn)
"class Solution(object):
    def countNodes(self, root):
        def height(root):
            h = -1
            while root:
                h += 1
                root = root.left
            return h

        result, h = 0, height(root)
        while root:
            if height(root.right) == h-1:
                result += 2**h
                root = root.right
            else:
                result += 2**(h-1)
                root = root.left
            h -= 1
        return result
",# Time:  O(h * h) = O((logn)^2)
"class Solution2(object):
    def countNodes(self, root):
        def check(node, n):
            base = 1
            while base <= n:
                base <<= 1
            base >>= 2

            while base:
                if (n & base) == 0:
                    node = node.left
                else:
                    node = node.right
                base >>= 1
            return bool(node)

        if not root:
            return 0

        node, level = root, 0
        while node.left:
            node = node.left
            level += 1

        left, right = 2**level, 2**(level+1)-1
        while left <= right:
            mid = left+(right-left)//2
            if not check(root, mid):
                right = mid-1
            else:
                left = mid+1
        return right",# Time:  O(h * h) = O((logn)^2)
"class Solution(object):
    def countHousePlacements(self, n):
        MOD = 10**9+7
        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        T = [[1, 1],
             [1, 0]]
        return pow(matrix_mult([[2, 1]], matrix_expo(T, n-1))[0][0], 2, MOD) 

",# Time:  O(logn)
"class Solution2(object):
    def countHousePlacements(self, n):
        MOD = 10**9+7
        prev, curr = 1, 2
        for _ in range(n-1):
            prev, curr = curr, (prev+curr)%MOD
        return pow(curr, 2, MOD)",# Time:  O(logn)
"class Solution(object):
    def kthSmallest(self, root, k):
        s, cur, rank = [], root, 0

        while s or cur:
            if cur:
                s.append(cur)
                cur = cur.left
            else:
                cur = s.pop()
                rank += 1
                if rank == k:
                    return cur.val
                cur = cur.right

        return float(""-inf"")

","# Time:  O(max(h, k))"
"class Solution2(object):
    def kthSmallest(self, root, k):
        def gen_inorder(root):
            if root:
                for n in gen_inorder(root.left):
                    yield n

                yield root.val

                for n in gen_inorder(root.right):
                    yield n

        return next(islice(gen_inorder(root), k-1, k))","# time: O(max(h, k))"
"class Solution(object):
    def kSmallestPairs(self, nums1, nums2, k):
        pairs = []
        if len(nums1) > len(nums2):
            tmp = self.kSmallestPairs(nums2, nums1, k)
            for pair in tmp:
                pairs.append([pair[1], pair[0]])
            return pairs

        min_heap = []
        def push(i, j):
            if i < len(nums1) and j < len(nums2):
                heappush(min_heap, [nums1[i] + nums2[j], i, j])

        push(0, 0)
        while min_heap and len(pairs) < k:
            _, i, j = heappop(min_heap)
            pairs.append([nums1[i], nums2[j]])
            push(i, j + 1)
            if j == 0:
                push(i + 1, 0) 
        return pairs

","# Time:  O(k * log(min(n, m, k))), where n is the size of num1, and m is the size of num2."
"class Solution2(object):
    def kSmallestPairs(self, nums1, nums2, k):
        return nsmallest(k, product(nums1, nums2), key=sum)",# time: O(mn * log k)
"class Solution(object):
    def maximumValueSum(self, board):
        k = 3
        min_heaps = [[] for _ in range(len(board[0]))]
        for i in range(len(board)):
            min_heap = []
            for j in range(len(board[0])):
                heapq.heappush(min_heap, (board[i][j], i, j))
                if len(min_heap) == k+1:
                    heapq.heappop(min_heap)
            for v, i, j in min_heap:
                heapq.heappush(min_heaps[j], (v, i, j))
                if len(min_heaps[j]) == k+1:
                    heapq.heappop(min_heaps[j])
        min_heap = []
        for h in min_heaps:
            for x in h:
                heapq.heappush(min_heap, x)
                if len(min_heap) == ((k-1)*(2*k-1)+1)+1: 
                    heapq.heappop(min_heap)
        return max(sum(x[0] for x in c) for c in itertools.combinations(min_heap, k) if len({x[1] for x in c}) == k == len({x[2] for x in c}))

","# Time:  O(m * n * logk + nCr((k-1)*(2*k-1)+1), k) * k) = O(m * n)"
"class Solution2(object):
    def maximumValueSum(self, board):
        k = 3
        rows = [heapq.nlargest(k, [(board[i][j], i, j) for j in range(len(board[0]))]) for i in range(len(board))]
        cols = [heapq.nlargest(k, [(board[i][j], i, j) for i in range(len(board))]) for j in range(len(board[0]))]
        min_heap = heapq.nlargest((k-1)*(2*k-1)+1, set(itertools.chain(*rows)) & set(itertools.chain(*cols))) 
        return max(sum(x[0] for x in c) for c in itertools.combinations(min_heap, k) if len({x[1] for x in c}) == k == len({x[2] for x in c}))","# Time:  O(m * n * logk + nCr((k-1)*(2*k-1)+1), k) * k) = O(m * n)"
"class Solution(object):
    def sequentialDigits(self, low, high):
        result = []
        q = collections.deque(list(range(1, 9)))
        while q:
            num = q.popleft()
            if num > high:
                continue
            if low <= num:
                result.append(num)
            if num%10+1 < 10:
                q.append(num*10+num%10+1)
        return result",# Time:  O((8 + 1) * 8 / 2) = O(1)
"class Solution(object):
    def distanceLimitedPathsExist(self, n, edgeList, queries):
        for i, q in enumerate(queries):
            q.append(i)
        edgeList.sort(key=lambda x: x[2])
        queries.sort(key=lambda x: x[2])
        
        union_find = UnionFind(n)
        result = [False]*len(queries)
        curr = 0
        for u, v, w, i in queries: 
            while curr < len(edgeList) and edgeList[curr][2] < w: 
                union_find.union_set(edgeList[curr][0], edgeList[curr][1])
                curr += 1
            result[i] = union_find.find_set(u) == union_find.find_set(v)
        return result ",# Time:  O(nlogn + mlogm + n * α(n)) = O(nlogn + mlogm)
"class Solution(object):
    def maximumSumScore(self, nums):
        prefix = suffix = 0
        result = float(""-inf"")
        right = len(nums)-1
        for left in range(len(nums)):
            prefix += nums[left]
            suffix += nums[right]
            right -= 1
            result = max(result, prefix, suffix)
        return result

",# Time:  O(n)
"class Solution2(object):
    def maximumSumScore(self, nums):
        total = sum(nums)
        prefix = 0
        result = float(""-inf"")
        for x in nums:
            prefix += x
            result = max(result, prefix, total-prefix+x)
        return result",# Time:  O(n)
"class Solution(object):
    def findLexSmallestString(self, s, a, b):
        def less(s, i, j):
            for k in range(len(s)):
                if s[(k+i)%len(s)] != s[(k+j)%len(s)]:
                    return s[(k+i)%len(s)] < s[(k+j)%len(s)]
            return False

        s = list(s)
        result = s[:]
        even = [False]*10
        while not even[int(s[0])]: 
            even[int(s[0])] = True
            odd = [False]*10
            while not odd[int(s[1])]: 
                odd[int(s[1])] = True
                best_rotate = 0
                lookup = [False]*len(s)
                i = b
                while not lookup[i]: 
                    lookup[i] = True
                    if less(s, i, best_rotate): 
                        best_rotate = i
                    i = (i+b)%len(s)
                result = min(result, s[best_rotate:] + s[:best_rotate])
                for k in range(1, len(s), 2): 
                    s[k] = str((int(s[k])+a) % 10)
            if b%2: 
                for k in range(0, len(s), 2): 
                    s[k] = str((int(s[k])+a) % 10)
        return """".join(result)

",# Time:  O(100 * n^2) = O(n^2)
"class Solution2(object):
    def findLexSmallestString(self, s, a, b):
        q, lookup, result = collections.deque([s]), {s}, s
        while q:
            curr = q.popleft()
            if curr < result:
                result = curr
            add_a = list(curr)    
            for i, c in enumerate(add_a):
                if i%2:
                    add_a[i] = str((int(c)+a) % 10)
            add_a = """".join(add_a)        
            if add_a not in lookup:
                lookup.add(add_a)
                q.append(add_a)
            rotate_b = curr[b:] + curr[:b]
            if rotate_b not in lookup:
                lookup.add(rotate_b)
                q.append(rotate_b)
        return result","# Time:  O(100 * n^2), at most O(100n) strings and each compare costs O(n)"
"class Solution(object):
    def unequalTriplets(self, nums):
        K = 3
        cnt = collections.Counter()
        dp = [0]*K 
        for x in nums:
            cnt[x] += 1
            other_cnt = 1
            for i in range(K):
                dp[i] += other_cnt
                other_cnt = dp[i]-cnt[x]*other_cnt
        return dp[K-1]",# Time:  O(n * k) = O(3 * n)
"class Solution(object):
    def friendRequests(self, n, restrictions, requests):
        result = []
        uf = UnionFind(n)
        for u, v in requests:
            pu, pv = uf.find_set(u), uf.find_set(v)
            ok = True
            for x, y in restrictions:
                px, py = uf.find_set(x), uf.find_set(y)
                if {px, py} == {pu, pv}:
                    ok = False
                    break
            result.append(ok)
            if ok:
                uf.union_set(u, v) 
        return result",# Time:  O(n * (alpha(n) + r)) = O(n * r)
"class Solution(object):
    def maxAbsValExpr(self, arr1, arr2):
        result = 0
        for c1 in [1, -1]:
            for c2 in [1, -1]:
                min_prev = float(""inf"")
                for i in range(len(arr1)):
                    curr = c1*arr1[i] + c2*arr2[i] + i
                    result = max(result, curr-min_prev)
                    min_prev = min(min_prev, curr)
        return result
",# Time:  O(n)
"class Solution2(object):
    def maxAbsValExpr(self, arr1, arr2):
        return max(max(c1*arr1[i] + c2*arr2[i] + i for i in range(len(arr1))) -
                   min(c1*arr1[i] + c2*arr2[i] + i for i in range(len(arr1)))
                   for c1 in [1, -1] for c2 in [1, -1])",# Time:  O(n)
"class Solution(object):
    def findLonelyPixel(self, picture):
        rows, cols = [0] * len(picture),  [0] * len(picture[0])
        for i in range(len(picture)):
            for j in range(len(picture[0])):
                if picture[i][j] == 'B':
                    rows[i] += 1
                    cols[j] += 1

        result = 0
        for i in range(len(picture)):
            if rows[i] == 1:
                for j in range(len(picture[0])):
                     result += picture[i][j] == 'B' and cols[j] == 1
        return result

",# Time:  O(m * n)
"class Solution2(object):
    def findLonelyPixel(self, picture):
        return sum(col.count('B') == 1 == picture[col.index('B')].count('B') \
               for col in zip(*picture))
",# Time:  O(m * n)
"class Solution(object):
    def maximumStrongPairXor(self, nums):
        class Trie(object):
            def __init__(self, bit_length):
                self.__nodes = []
                self.__cnts = []
                self.__new_node()
                self.__bit_length = bit_length
            
            def __new_node(self):
                self.__nodes.append([-1]*2)
                self.__cnts.append(0)
                return len(self.__nodes)-1

            def update(self, num, d):
                curr = 0
                for i in reversed(range(self.__bit_length)):
                    x = num>>i
                    if self.__nodes[curr][x&1] == -1:
                        self.__nodes[curr][x&1] = self.__new_node()
                    curr = self.__nodes[curr][x&1]
                    self.__cnts[curr] += d
                        
            def query(self, num):
                result = curr = 0
                for i in reversed(range(self.__bit_length)):
                    result <<= 1
                    x = num>>i
                    if self.__nodes[curr][1^(x&1)] != -1 and self.__cnts[self.__nodes[curr][1^(x&1)]]:
                        curr = self.__nodes[curr][1^(x&1)]
                        result |= 1
                    else:
                        curr = self.__nodes[curr][x&1]
                return result
    
        nums.sort()
        trie = Trie(nums[-1].bit_length())
        result = j = 0
        for i, num in enumerate(nums):
            trie.update(num, +1)
            while not (nums[i] <= 2*nums[j]) :
                trie.update(nums[j], -1)
                j += 1
            result = max(result, trie.query(num))
        return result

","# Time:  O(nlogn + nlogr) = O(nlogr), r = max(nums)"
"class Solution2(object):
    def maximumStrongPairXor(self, nums):
        class Trie(object):
            def __init__(self, bit_length):
                self.__nodes = []
                self.__mins = []
                self.__maxs = []
                self.__new_node()
                self.__bit_length = bit_length
            
            def __new_node(self):
                self.__nodes.append([-1]*2)
                self.__mins.append(float(""inf""))
                self.__maxs.append(float(""-inf""))
                return len(self.__nodes)-1

            def insert(self, num):
                curr = 0
                for i in reversed(range(self.__bit_length)):
                    x = num>>i
                    if self.__nodes[curr][x&1] == -1:
                        self.__nodes[curr][x&1] = self.__new_node()
                    curr = self.__nodes[curr][x&1]
                    self.__mins[curr] = min(self.__mins[curr], num)
                    self.__maxs[curr] = max(self.__maxs[curr], num)
                        
            def query(self, num):
                result = curr = 0
                for i in reversed(range(self.__bit_length)):
                    result <<= 1
                    x = num>>i
                    y = (result|1)^x
                    assert(x != y) 
                    if (self.__nodes[curr][y&1] != -1 and
                        ((x > y and num <= 2*self.__maxs[self.__nodes[curr][y&1]]) or
                         (x < y and self.__mins[self.__nodes[curr][y&1]] <= 2*num))):
                        result |= 1
                        curr = self.__nodes[curr][y&1]
                    else:
                        curr = self.__nodes[curr][1^(y&1)]
                return result
    
        trie = Trie(max(nums).bit_length())
        result = 0
        for num in nums:
            trie.insert(num)
            result = max(result, trie.query(num))
        return result

","# Time:  O(nlogr), r = max(nums)"
"class Solution3(object):
    def maximumStrongPairXor(self, nums):
        result = 0
        for i in reversed(range(max(nums).bit_length())):
            prefix_min, prefix_max = {}, {}
            for x in nums:
                y = x>>i
                if y not in prefix_min:
                    prefix_min[y] = prefix_max[y] = x
                prefix_min[y] = min(prefix_min[y], x)
                prefix_max[y] = max(prefix_max[y], x)
            result <<= 1
            for x in prefix_min.keys():
                y = (result|1)^x
                assert(x != y)
                if y in prefix_max and prefix_min[max(x, y)] <= 2*prefix_max[min(x, y)]:
                    result |= 1
                    break
        return result","# Time:  O(nlogr), r = max(nums)"
"class Solution(object):
    def stringCount(self, n):
        MOD = 10**9 + 7
        return (
            pow(26, n, MOD)
            - (25 + 25 + 25 + n) * pow(25, n - 1, MOD)
            + (24 + 24 + 24 + n + n + 0) * pow(24, n - 1, MOD)
            - (23 + n + 0 + 0) * pow(23, n - 1, MOD)
        ) % MOD

",# Time:  O(logn)
"class Solution2(object):
    def stringCount(self, n):
        MOD = 10**9 + 7
        L, E, EE, T = [1 << i for i in range(4)]
        dp = [0] * (1 << 4)
        dp[0] = 1
        for _ in range(n):
            new_dp = [0] * (1 << 4)
            for mask in range(len(dp)):
                new_dp[mask | L] = (new_dp[mask | L] + dp[mask]) % MOD
                if not (mask & E):
                    new_dp[mask | E] = (new_dp[mask | E] + dp[mask]) % MOD
                else:
                    new_dp[mask | EE] = (new_dp[mask | EE] + dp[mask]) % MOD
                new_dp[mask | T] = (new_dp[mask | T] + dp[mask]) % MOD
                new_dp[mask] = (new_dp[mask] + 23 * dp[mask]) % MOD
            dp = new_dp
        return dp[-1]",# Time:  O(2^4 * n) = O(n)
"class Solution(object):
    def minAnagramLength(self, s):
        def factors(n):
            for i in range(1, n+1):
                if i*i > n:
                    break
                if n%i:
                    continue
                yield i
                if n//i != i:
                    yield n//i
                    
        def check(l):
            def count(i):
                cnt = [0]*26
                for j in range(i, i+l):
                    cnt[ord(s[j])-ord('a')] += 1
                return cnt
    
            cnt = count(0)
            return all(count(i) == cnt for i in range(l, len(s), l))

        return min(l for l in factors(len(s)) if check(l))","# Time:  O(sqrt(n) * n + (26 * sum(n/i for i in range(1, n+1) if n%i == 0))) < O(sqrt(n) * n + 26 * sum(n/i for i in range(1, n+1)) = O(sqrt(n) * n + 26 * nlogn)"
"class Solution(object):
    def convertToBase7(self, num):
        if num < 0:
            return '-' + self.convertToBase7(-num)
        result = ''
        while num:
            result = str(num % 7) + result
            num //= 7
        return result if result else '0'

",# Time:  O(1)
"class Solution2(object):
    def convertToBase7(self, num):
        if num < 0:
            return '-' + self.convertToBase7(-num)
        if num < 7:
            return str(num)
        return self.convertToBase7(num // 7) + str(num % 7)
",# Time:  O(1)
"class Solution(object):
    def maximumInvitations(self, grid):
        adj = collections.defaultdict(list)
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if not grid[i][j]:
                    continue
                adj[j].append(i)
        return len(bipartiteMatch(adj)[0])

",# Time:  O(m * n * sqrt(m + n)) = O(E * sqrt(V))
"class Solution2(object):
    def maximumInvitations(self, grid):
        def augment(grid, u, lookup, match):
            for v in range(V):
                if not get_grid(u, v) or v in lookup:
                    continue
                lookup.add(v)
                if v not in match or augment(grid, match[v], lookup, match):
                    match[v] = u 
                    return True
            return False
    
        def hungarian(grid):
            match = {}
            for i in range(U):
                augment(grid, i, set(), match)
            return len(match)

        U, V = min(len(grid), len(grid[0])), max(len(grid), len(grid[0]))
        get_grid = (lambda x, y: grid[x][y]) if len(grid) < len(grid[0]) else (lambda x, y: grid[y][x])
        return hungarian(grid)

","# Time:  O(|V| * |E|) = O(min(m, n) * (m * n))"
"class Solution3(object):
    def maximumInvitations(self, grid):
        def augment(adj, u, lookup, match):
            for v in adj[u]:
                if v in lookup:
                    continue
                lookup.add(v)
                if v not in match or augment(adj, match[v], lookup, match):
                    match[v] = u 
                    return True
            return False
    
        def hungarian(adj):
            match = {}
            for i in adj.keys():
                augment(adj, i, set(), match)
            return len(match)
        
        adj = collections.defaultdict(list)
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if not grid[i][j]:
                    continue
                if len(grid) < len(grid[0]):
                    adj[i].append(j)
                else:
                    adj[j].append(i)
        return hungarian(adj)","# Time:  O(|V| * |E|) = O(min(m, n) * (m * n))"
"class Solution(object):
    def judgePoint24(self, nums):
        if len(nums) == 1:
            return abs(nums[0]-24) < 1e-6
        ops = [add, sub, mul, truediv]
        for i in range(len(nums)):
            for j in range(len(nums)):
                if i == j:
                    continue
                next_nums = [nums[k] for k in range(len(nums)) if i != k != j]
                for op in ops:
                    if ((op is add or op is mul) and j > i) or \
                       (op == truediv and nums[j] == 0):
                        continue
                    next_nums.append(op(nums[i], nums[j]))
                    if self.judgePoint24(next_nums):
                        return True
                    next_nums.pop()
        return False

","# Time:  O(n^3 * 4^n) = O(1), n = 4"
"class Solution2(object):
    def judgePoint24(self, nums):
        def dfs(nums):
            if len(nums) == 1:
                return nums[0] == 24
            ops = [add, sub, mul, truediv]
            for i in range(len(nums)):
                for j in range(len(nums)):
                    if i == j:
                        continue
                    next_nums = [nums[k] for k in range(len(nums))
                                 if i != k != j]
                    for op in ops:
                        if ((op is add or op is mul) and j > i) or \
                           (op == truediv and nums[j] == 0):
                            continue
                        next_nums.append(op(nums[i], nums[j]))
                        if dfs(next_nums):
                            return True
                        next_nums.pop()
            return False

        return dfs(list(map(Fraction, nums)))
","# Time:  O(n^3 * 4^n) = O(1), n = 4"
"class Solution(object):
    def minimumSum(self, grid):
        def count(dir1, dir2):
            dp = [[0]*len(grid[0]) for _ in range(len(grid))]
            up = [len(grid)]*len(grid[0])
            down = [-1]*len(grid[0])
            for i in dir1(range(len(grid))):
                l, r, u, d = len(grid[0]), -1, len(grid), -1
                for j in dir2(range(len(grid[0]))):
                    if grid[i][j]:
                        up[j] = min(up[j], i)
                        down[j] = max(down[j], i)
                    u = min(u, up[j])
                    d = max(d, down[j])
                    if down[j] >= 0:
                        l = min(l, j)
                        r = max(r, j)
                    dp[i][j] = (r-l+1)*(d-u+1) if r >= 0 else 0
            return dp
        
        def count2(is_vertical):
            def get_n():
                return len(grid) if not is_vertical else len(grid[0])

            def get_m():
                return len(grid[0]) if not is_vertical else len(grid)

            def get(i, j):
                return grid[i][j] if not is_vertical else grid[j][i]
    
            left = [get_m() for _ in range(get_n())]
            right = [-1 for _ in range(get_n())]
            for i in range(get_n()):
                for j in range(get_m()):
                    if get(i, j) == 0:
                        continue
                    left[i] = min(left[i], j)
                    right[i] = max(right[i], j)
            dp = [[0]*get_n() for _ in range(get_n())]
            for i in range(len(dp)):
                l, r, u, d = get_m(), -1, get_n(), -1
                for j in range(i, len(dp[0])):
                    if right[j] != -1:
                        l = min(l, left[j])
                        r = max(r, right[j])
                        u = min(u, j)
                        d = max(d, j)
                    dp[i][j] = (r-l+1)*(d-u+1) if r >= 0 else 0
            return dp

        up_left = count(lambda x: x, lambda x: x)
        up_right = count(lambda x: x, reversed)
        down_left = count(reversed, lambda x: x)
        down_right = count(reversed, reversed)
        horizon = count2(False)
        vertical = count2(True)
        result = float(""inf"")
        for i in range(len(grid)-1):
            for j in range(len(grid[0])-1):
                result = min(result,
                             up_left[i][j]+up_right[i][j+1]+horizon[i+1][len(grid)-1],
                             horizon[0][i]+down_left[i+1][j]+down_right[i+1][j+1],
                             up_left[i][j]+down_left[i+1][j]+vertical[j+1][len(grid[0])-1],
                             vertical[0][j]+up_right[i][j+1]+down_right[i+1][j+1])
        for i in range(len(grid)-2):
            for j in range(i+1, len(grid)-1):
                result = min(result, horizon[0][i]+horizon[i+1][j]+horizon[j+1][len(grid)-1])
        for i in range(len(grid[0])-2):
            for j in range(i+1, len(grid[0])-1):
                result = min(result, vertical[0][i]+vertical[i+1][j]+vertical[j+1][len(grid[0])-1])
        return result

","# Time:  O(max(n, m)^2)"
"class Solution2(object):
    def minimumSum(self, grid):
        class SparseTable(object):
            def __init__(self, arr, fn):
                self.fn = fn
                self.bit_length = [0]
                n = len(arr)
                k = n.bit_length()-1 
                for i in range(k+1):
                    self.bit_length.extend(i+1 for _ in range(min(1<<i, (n+1)-len(self.bit_length))))
                self.st = [[0]*n for _ in range(k+1)]
                self.st[0] = arr[:]
                for i in range(1, k+1): 
                    for j in range((n-(1<<i))+1):
                        self.st[i][j] = fn(self.st[i-1][j], self.st[i-1][j+(1<<(i-1))])
        
            def query(self, L, R): 
                i = self.bit_length[R-L+1]-1 
                return self.fn(self.st[i][L], self.st[i][R-(1<<i)+1])

        def minimumArea(min_i, max_i, min_j, max_j):
            min_r = min(st_min_i[min_i].query(min_j, max_j), max_i+1)
            max_r = max(st_max_i[max_i].query(min_j, max_j), min_i-1)
            min_c = min(st_min_j[min_j].query(min_i, max_i), max_j+1)
            max_c = max(st_max_j[max_j].query(min_i, max_i), min_j-1)
            return (max_r-min_r+1)*(max_c-min_c+1) if min_r <= max_i else 0

        st_min_i = [None]*len(grid)
        curr = [len(grid)]*len(grid[0])
        for i in reversed(range(len(grid))):
            for j in range(len(grid[0])):
                if grid[i][j]:
                    curr[j] = i
            st_min_i[i] = SparseTable(curr, min)
        st_max_i = [None]*len(grid)
        curr = [-1]*len(grid[0])
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]:
                    curr[j] = i
            st_max_i[i] = SparseTable(curr, max)
        st_min_j = [None]*len(grid[0])
        curr = [len(grid[0])]*len(grid)
        for j in reversed(range(len(grid[0]))):
            for i in range(len(grid)):
                if grid[i][j]:
                    curr[i] = j
            st_min_j[j] = SparseTable(curr, min)
        st_max_j = [None]*len(grid[0])
        curr = [-1]*len(grid)
        for j in range(len(grid[0])):
            for i in range(len(grid)):
                if grid[i][j]:
                    curr[i] = j
            st_max_j[j] = SparseTable(curr, max)
        result = float(""inf"")
        for i in range(len(grid)-1):
            a = minimumArea(i+1, len(grid)-1, 0, len(grid[0])-1)
            for j in range(len(grid[0])-1):
                b = minimumArea(0, i, 0, j)
                c = minimumArea(0, i, j+1, len(grid[0])-1)
                result = min(result, a+b+c)
        for i in range(len(grid)-1):
            a = minimumArea(0, i, 0, len(grid[0])-1)
            for j in range(len(grid[0])-1):
                b = minimumArea(i+1, len(grid)-1, 0, j)
                c = minimumArea(i+1, len(grid)-1, j+1, len(grid[0])-1)
                result = min(result, a+b+c)
        for j in range(len(grid[0])-1):
            a = minimumArea(0, len(grid)-1, j+1, len(grid[0])-1)
            for i in range(len(grid)-1):
                b = minimumArea(0, i, 0, j)
                c = minimumArea(i+1, len(grid)-1, 0, j)
                result = min(result, a+b+c)
        for j in range(len(grid[0])-1):
            a = minimumArea(0, len(grid)-1, 0, j)
            for i in range(len(grid)-1):
                b = minimumArea(0, i, j+1, len(grid[0])-1)
                c = minimumArea(i+1, len(grid)-1, j+1, len(grid[0])-1)
                result = min(result, a+b+c)
        for i in range(len(grid)-2):
            a = minimumArea(0, i, 0, len(grid[0])-1)
            for j in range(i+1, len(grid)-1):
                b = minimumArea(i+1, j, 0, len(grid[0])-1)
                c = minimumArea(j+1, len(grid)-1, 0, len(grid[0])-1)
                result = min(result, a+b+c)
        for i in range(len(grid[0])-2):
            a = minimumArea(0, len(grid)-1, 0, i)
            for j in range(i+1, len(grid[0])-1):
                b = minimumArea(0, len(grid)-1, i+1, j)
                c = minimumArea(0, len(grid)-1, j+1, len(grid[0])-1)
                result = min(result, a+b+c)
        return result

","# Time:  O(n * m * log(max(n, m)) + max(n, m)^2)"
"class Solution3(object):
    def minimumSum(self, grid):
        class SparseTable(object):
            def __init__(self, arr, fn):
                self.fn = fn
                self.bit_length = [0]
                n = len(arr)
                k = n.bit_length()-1 
                for i in range(k+1):
                    self.bit_length.extend(i+1 for _ in range(min(1<<i, (n+1)-len(self.bit_length))))
                self.st = [[0]*n for _ in range(k+1)]
                self.st[0] = arr[:]
                for i in range(1, k+1): 
                    for j in range((n-(1<<i))+1):
                        self.st[i][j] = fn(self.st[i-1][j], self.st[i-1][j+(1<<(i-1))])
        
            def query(self, L, R): 
                i = self.bit_length[R-L+1]-1 
                return self.fn(self.st[i][L], self.st[i][R-(1<<i)+1])

        def minimumArea(min_i, max_i, min_j, max_j):
            min_r = min(st_min_i[min_i].query(min_j, max_j), max_i+1)
            max_r = max(st_max_i[max_i].query(min_j, max_j), min_i-1)
            min_c = min(st_min_j[min_j].query(min_i, max_i), max_j+1)
            max_c = max(st_max_j[max_j].query(min_i, max_i), min_j-1)
            return (max_r-min_r+1)*(max_c-min_c+1) if min_r <= max_i else 0

        result = float(""inf"")
        for _ in range(4):
            st_min_i = [None]*len(grid)
            curr = [len(grid)]*len(grid[0])
            for i in reversed(range(len(grid))):
                for j in range(len(grid[0])):
                    if grid[i][j]:
                        curr[j] = i
                st_min_i[i] = SparseTable(curr, min)
            st_max_i = [None]*len(grid)
            curr = [-1]*len(grid[0])
            for i in range(len(grid)):
                for j in range(len(grid[0])):
                    if grid[i][j]:
                        curr[j] = i
                st_max_i[i] = SparseTable(curr, max)
            st_min_j = [None]*len(grid[0])
            curr = [len(grid[0])]*len(grid)
            for j in reversed(range(len(grid[0]))):
                for i in range(len(grid)):
                    if grid[i][j]:
                        curr[i] = j
                st_min_j[j] = SparseTable(curr, min)
            st_max_j = [None]*len(grid[0])
            curr = [-1]*len(grid)
            for j in range(len(grid[0])):
                for i in range(len(grid)):
                    if grid[i][j]:
                        curr[i] = j
                st_max_j[j] = SparseTable(curr, max)        
            for i in range(len(grid)-1):
                a = minimumArea(0, i, 0, len(grid[0])-1)
                for j in range(len(grid[0])-1):
                    b = minimumArea(i+1, len(grid)-1, 0, j)
                    c = minimumArea(i+1, len(grid)-1, j+1, len(grid[0])-1)
                    result = min(result, a+b+c)
            for i in range(len(grid)-2):
                a = minimumArea(0, i, 0, len(grid[0])-1)
                for j in range(i+1, len(grid)-1):
                    b = minimumArea(i+1, j, 0, len(grid[0])-1)
                    c = minimumArea(j+1, len(grid)-1, 0, len(grid[0])-1)
                    result = min(result, a+b+c)
            grid = list(zip(*grid[::-1]))
        return result

","# Time:  O(n * m * log(max(n, m)) + max(n, m)^2)"
"class Solution4(object):
    def minimumSum(self, grid):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left
        
        def binary_search_right(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right

        def minimumArea(min_i, max_i, min_j, max_j):
            def count(x1, y1, x2, y2):
                cnt = grid[x2][y2]
                if x1-1 >= 0:
                    cnt -= grid[x1-1][y2]
                if y1-1 >= 0:
                    cnt -= grid[x2][y1-1]
                if x1-1 >= 0 and y1-1 >= 0:
                    cnt += grid[x1-1][y1-1]
                return cnt

            min_r = binary_search(min_i, max_i, lambda i: count(min_i, min_j, i, max_j))
            max_r = binary_search_right(min_i, max_i, lambda i: count(i, min_j, max_i, max_j))
            min_c = binary_search(min_j, max_j, lambda j: count(min_i, min_j, max_i, j))
            max_c = binary_search_right(min_j, max_j, lambda j: count(min_i, j, max_i, max_j))
            return (max_r-min_r+1)*(max_c-min_c+1) if min_r <= max_i else 0
    
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i-1 >= 0:
                    grid[i][j] += grid[i-1][j]
                if j-1 >= 0:
                    grid[i][j] += grid[i][j-1]
                if i-1 >= 0 and j-1 >= 0:
                    grid[i][j] -= grid[i-1][j-1]
        result = float(""inf"")
        result = float(""inf"")
        for i in range(len(grid)-1):
            a = minimumArea(i+1, len(grid)-1, 0, len(grid[0])-1)
            for j in range(len(grid[0])-1):
                b = minimumArea(0, i, 0, j)
                c = minimumArea(0, i, j+1, len(grid[0])-1)
                result = min(result, a+b+c)
        for i in range(len(grid)-1):
            a = minimumArea(0, i, 0, len(grid[0])-1)
            for j in range(len(grid[0])-1):
                b = minimumArea(i+1, len(grid)-1, 0, j)
                c = minimumArea(i+1, len(grid)-1, j+1, len(grid[0])-1)
                result = min(result, a+b+c)
        for j in range(len(grid[0])-1):
            a = minimumArea(0, len(grid)-1, j+1, len(grid[0])-1)
            for i in range(len(grid)-1):
                b = minimumArea(0, i, 0, j)
                c = minimumArea(i+1, len(grid)-1, 0, j)
                result = min(result, a+b+c)
        for j in range(len(grid[0])-1):
            a = minimumArea(0, len(grid)-1, 0, j)
            for i in range(len(grid)-1):
                b = minimumArea(0, i, j+1, len(grid[0])-1)
                c = minimumArea(i+1, len(grid)-1, j+1, len(grid[0])-1)
                result = min(result, a+b+c)
        for i in range(len(grid)-2):
            a = minimumArea(0, i, 0, len(grid[0])-1)
            for j in range(i+1, len(grid)-1):
                b = minimumArea(i+1, j, 0, len(grid[0])-1)
                c = minimumArea(j+1, len(grid)-1, 0, len(grid[0])-1)
                result = min(result, a+b+c)
        for i in range(len(grid[0])-2):
            a = minimumArea(0, len(grid)-1, 0, i)
            for j in range(i+1, len(grid[0])-1):
                b = minimumArea(0, len(grid)-1, i+1, j)
                c = minimumArea(0, len(grid)-1, j+1, len(grid[0])-1)
                result = min(result, a+b+c)
        return result

","# Time:  O(max(n, m)^2 * log(max(n, m)))"
"class Solution5(object):
    def minimumSum(self, grid):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left
        
        def binary_search_right(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right

        def minimumArea(min_i, max_i, min_j, max_j):
            def count(x1, y1, x2, y2):
                cnt = prefix[x2][y2]
                if x1-1 >= 0:
                    cnt -= prefix[x1-1][y2]
                if y1-1 >= 0:
                    cnt -= prefix[x2][y1-1]
                if x1-1 >= 0 and y1-1 >= 0:
                    cnt += prefix[x1-1][y1-1]
                return cnt

            min_r = binary_search(min_i, max_i, lambda i: count(min_i, min_j, i, max_j))
            max_r = binary_search_right(min_i, max_i, lambda i: count(i, min_j, max_i, max_j))
            min_c = binary_search(min_j, max_j, lambda j: count(min_i, min_j, max_i, j))
            max_c = binary_search_right(min_j, max_j, lambda j: count(min_i, j, max_i, max_j))
            return (max_r-min_r+1)*(max_c-min_c+1) if min_r <= max_i else 0
    
        result = float(""inf"")
        for _ in range(4):
            prefix = [[0]*len(grid[0]) for _ in range(len(grid))]
            for i in range(len(grid)):
                for j in range(len(grid[0])):
                    prefix[i][j] = grid[i][j]
                    if i-1 >= 0:
                        prefix[i][j] += prefix[i-1][j]
                    if j-1 >= 0:
                        prefix[i][j] += prefix[i][j-1]
                    if i-1 >= 0 and j-1 >= 0:
                        prefix[i][j] -= prefix[i-1][j-1]
            for i in range(len(grid)-1):
                a = minimumArea(0, i, 0, len(grid[0])-1)
                for j in range(len(grid[0])-1):
                    b = minimumArea(i+1, len(grid)-1, 0, j)
                    c = minimumArea(i+1, len(grid)-1, j+1, len(grid[0])-1)
                    result = min(result, a+b+c)
            for i in range(len(grid)-2):
                a = minimumArea(0, i, 0, len(grid[0])-1)
                for j in range(i+1, len(grid)-1):
                    b = minimumArea(i+1, j, 0, len(grid[0])-1)
                    c = minimumArea(j+1, len(grid)-1, 0, len(grid[0])-1)
                    result = min(result, a+b+c)
            grid = list(zip(*grid[::-1]))
        return result

","# Time:  O(max(n, m)^2 * log(max(n, m)))"
"class Solution6(object):
    def minimumSum(self, grid):
        def minimumArea(min_i, max_i, min_j, max_j):
            min_r, max_r, min_c, max_c = max_i+1, min_i-1, max_j+1, min_j-1
            for i in range(min_i, max_i+1):
                for j in range(min_j, max_j+1):
                    if grid[i][j] == 0:
                        continue
                    min_r, max_r, min_c, max_c = min(min_r, i), max(max_r, i), min(min_c, j), max(max_c, j)
            return (max_r-min_r+1)*(max_c-min_c+1) if min_r <= max_i else 0
    
        result = float(""inf"")
        for i in range(len(grid)-1):
            a = minimumArea(i+1, len(grid)-1, 0, len(grid[0])-1)
            for j in range(len(grid[0])-1):
                b = minimumArea(0, i, 0, j)
                c = minimumArea(0, i, j+1, len(grid[0])-1)
                result = min(result, a+b+c)
        for i in range(len(grid)-1):
            a = minimumArea(0, i, 0, len(grid[0])-1)
            for j in range(len(grid[0])-1):
                b = minimumArea(i+1, len(grid)-1, 0, j)
                c = minimumArea(i+1, len(grid)-1, j+1, len(grid[0])-1)
                result = min(result, a+b+c)
        for j in range(len(grid[0])-1):
            a = minimumArea(0, len(grid)-1, j+1, len(grid[0])-1)
            for i in range(len(grid)-1):
                b = minimumArea(0, i, 0, j)
                c = minimumArea(i+1, len(grid)-1, 0, j)
                result = min(result, a+b+c)
        for j in range(len(grid[0])-1):
            a = minimumArea(0, len(grid)-1, 0, j)
            for i in range(len(grid)-1):
                b = minimumArea(0, i, j+1, len(grid[0])-1)
                c = minimumArea(i+1, len(grid)-1, j+1, len(grid[0])-1)
                result = min(result, a+b+c)
        for i in range(len(grid)-2):
            a = minimumArea(0, i, 0, len(grid[0])-1)
            for j in range(i+1, len(grid)-1):
                b = minimumArea(i+1, j, 0, len(grid[0])-1)
                c = minimumArea(j+1, len(grid)-1, 0, len(grid[0])-1)
                result = min(result, a+b+c)
        for i in range(len(grid[0])-2):
            a = minimumArea(0, len(grid)-1, 0, i)
            for j in range(i+1, len(grid[0])-1):
                b = minimumArea(0, len(grid)-1, i+1, j)
                c = minimumArea(0, len(grid)-1, j+1, len(grid[0])-1)
                result = min(result, a+b+c)
        return result

","# Time:  O((n^2 + m^2 + 4 * n * m) * n * m) = O(max(n, m)^3 * min(n, m))"
"class Solution7(object):
    def minimumSum(self, grid):
        def minimumArea(min_i, max_i, min_j, max_j):
            min_r, max_r, min_c, max_c = max_i+1, min_i-1, max_j+1, min_j-1
            for i in range(min_i, max_i+1):
                for j in range(min_j, max_j+1):
                    if grid[i][j] == 0:
                        continue
                    min_r, max_r, min_c, max_c = min(min_r, i), max(max_r, i), min(min_c, j), max(max_c, j)
            return (max_r-min_r+1)*(max_c-min_c+1) if min_r <= max_i else 0
    
        result = float(""inf"")
        for _ in range(4):
            for i in range(len(grid)-1):
                a = minimumArea(0, i, 0, len(grid[0])-1)
                for j in range(len(grid[0])-1):
                    b = minimumArea(i+1, len(grid)-1, 0, j)
                    c = minimumArea(i+1, len(grid)-1, j+1, len(grid[0])-1)
                    result = min(result, a+b+c)
            for i in range(len(grid)-2):
                a = minimumArea(0, i, 0, len(grid[0])-1)
                for j in range(i+1, len(grid)-1):
                    b = minimumArea(i+1, j, 0, len(grid[0])-1)
                    c = minimumArea(j+1, len(grid)-1, 0, len(grid[0])-1)
                    result = min(result, a+b+c)
            grid = list(zip(*grid[::-1]))
        return result","# Time:  O((n^2 + m^2 + 4 * n * m) * n * m) = O(max(n, m)^3 * min(n, m))"
"class Solution(object):
    def grayCode(self, n):
        result = [0]
        for i in range(n):
            for n in reversed(result):
                result.append(1 << i | n)
        return result



",# Time:  O(2^n)
"class Solution2(object):
    def grayCode(self, n):
        return [i >> 1 ^ i for i in range(1 << n)]

",# Time:  O(2^n)
"class Solution(object):
    def findRotateSteps(self, ring, key):
        lookup = collections.defaultdict(list)
        for i in range(len(ring)):
            lookup[ring[i]].append(i)

        dp = [[0] * len(ring) for _ in range(2)]
        prev = [0]
        for i in range(1, len(key)+1):
            dp[i%2] = [float(""inf"")] * len(ring)
            for j in lookup[key[i-1]]:
                for k in prev:
                    dp[i%2][j] = min(dp[i%2][j],
                                     min((k+len(ring)-j) % len(ring), \
                                         (j+len(ring)-k) % len(ring)) + \
                                     dp[(i-1) % 2][k])
            prev = lookup[key[i-1]]
        return min(dp[len(key)%2]) + len(key)
",# Time:  O(k) ~ O(k * r^2)
"class Solution(object):
    def champagneTower(self, poured, query_row, query_glass):
        result = [poured] + [0] * query_row
        for i in range(1, query_row+1):
            for j in reversed(range(i+1)):
                result[j] = max(result[j]-1, 0)/2.0 + \
                            max(result[j-1]-1, 0)/2.0
        return min(result[query_glass], 1)
","# Time:  O(n^2) = O(1), since n is at most 99"
"class Solution(object):
    def reorganizeString(self, S):
        counts = collections.Counter(S)
        if any(v > (len(S)+1)/2 for k, v in counts.items()):
            return """"

        result = []
        max_heap = []
        for k, v in counts.items():
            heapq.heappush(max_heap, (-v, k))
        while len(max_heap) > 1:
            count1, c1 = heapq.heappop(max_heap)
            count2, c2 = heapq.heappop(max_heap)
            if not result or c1 != result[-1]:
                result.extend([c1, c2])
                if count1+1: heapq.heappush(max_heap, (count1+1, c1))
                if count2+1: heapq.heappush(max_heap, (count2+1, c2))
        return """".join(result) + (max_heap[0][1] if max_heap else '')
","# Time:  O(nloga) = O(n), a is the size of alphabet"
"class Solution(object):
    def numIslands(self, grid):
        def index(n, i, j):
            return i*n + j
    
        if not grid:
            return 0

        zero_count = 0
        union_find = UnionFind(len(grid)*len(grid[0]))
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    if i and grid[i-1][j] == '1':
                        union_find.union_set(index(len(grid[0]), i-1, j),
                                             index(len(grid[0]),i, j))
                    if j and grid[i][j-1] == '1':
                        union_find.union_set(index(len(grid[0]), i, j-1),
                                             index(len(grid[0]), i, j))
                else:
                    zero_count += 1        
        return union_find.count-zero_count

",# Time:  O(m * n * α(m * n)) ~= O(m * n)
"class Solution2(object):
    def numIslands(self, grid):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def dfs(grid, i, j):
            if grid[i][j] == '0':
                return False
            grid[i][j] = '0'
            stk = [(i, j)]
            while stk:
                r, c = stk.pop()
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 <= nr < len(grid) and
                            0 <= nc < len(grid[0]) and
                            grid[nr][nc] == '1'):
                        continue
                    grid[nr][nc] = '0'
                    stk.append((nr, nc))
            return True

        count = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if dfs(grid, i, j):
                    count += 1
        return count

import collections


",# Time:  O(m * n)
"class Solution3(object):
    def numIslands(self, grid):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def bfs(grid, i, j):
            if grid[i][j] == '0':
                return False
            grid[i][j] ='0'
            q = collections.deque([(i, j)])
            while q:
                r, c = q.popleft()
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 <= nr < len(grid) and
                            0 <= nc < len(grid[0]) and
                            grid[nr][nc] == '1'):
                        continue
                    grid[nr][nc] = '0'
                    q.append((nr, nc))
            return True

        count = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if bfs(grid, i, j):
                    count += 1
        return count",# Time:  O(m * n)
"class Solution(object):
    def closestRoom(self, rooms, queries):
        def find_closest(ids, r):
            result, min_dist = -1, float(""inf"")
            i = ids.bisect_right(r)
            if i-1 >= 0 and abs(ids[i-1]-r) < min_dist:
                min_dist = abs(ids[i-1]-r)
                result = ids[i-1]
            if i < len(ids) and abs(ids[i]-r) < min_dist:
                min_dist = abs(ids[i]-r)
                result = ids[i]
            return result

        rooms.sort(key=lambda x: x[1], reverse=True)
        for i, q in enumerate(queries):
            q.append(i)
        queries.sort(key=lambda x: x[1], reverse=True)
        ids = SortedList()
        i = 0
        result = [-1]*len(queries)
        for r, s, idx in queries:
            while i < len(rooms) and rooms[i][1] >= s:
                ids.add(rooms[i][0])
                i += 1
            result[idx] = find_closest(ids, r)
        return result

from sortedcontainers import SortedList

",# Time:  O(nlogn + klogk + klogn)
"class Solution2(object):
    def closestRoom(self, rooms, queries):
        def find_closest(ids, r):
            result, min_dist = -1, float(""inf"")
            i = ids.bisect_right(r)
            if i-1 >= 0 and abs(ids[i-1]-r) < min_dist:
                min_dist = abs(ids[i-1]-r)
                result = ids[i-1]
            if i < len(ids) and abs(ids[i]-r) < min_dist:
                min_dist = abs(ids[i]-r)
                result = ids[i]
            return result

        rooms.sort(key=lambda x: x[1])
        for i, q in enumerate(queries):
            q.append(i)
        queries.sort(key=lambda x: x[1])
        ids = SortedList(i for i, _ in rooms)        
        i = 0
        result = [-1]*len(queries)
        for r, s, idx in queries:
            while i < len(rooms) and rooms[i][1] < s:
                ids.remove(rooms[i][0])
                i += 1
            result[idx] = find_closest(ids, r)
        return result",# Time:  O(nlogn + klogk + klogn)
"class Solution(object):
    def rangeBitwiseAnd(self, m, n):
        while m < n:
            n &= n - 1
        return n

",# Time:  O(1)
"class Solution2(object):
    def rangeBitwiseAnd(self, m, n):
        i, diff = 0, n-m
        while diff:
            diff >>= 1
            i += 1
        return n & m >> i << i
",# Time:  O(1)
"class Solution(object):
    def numPrimeArrangements(self, n):
        def count_primes(n):
            if n <= 1:
                return 0
            is_prime = [True]*((n+1)//2)
            cnt = len(is_prime)
            for i in range(3, n+1, 2):
                if i*i > n:
                    break
                if not is_prime[i//2]:
                    continue
                for j in range(i*i, n+1, 2*i):
                    if not is_prime[j//2]:
                        continue
                    cnt -= 1
                    is_prime[j//2] = False
            return cnt
        
        def factorial(n):
            result = 1
            for i in range(2, n+1):
                result = (result*i)%MOD
            return result

        MOD = 10**9+7
        cnt = count_primes(n)
        return factorial(cnt) * factorial(n-cnt) % MOD","# Time:  O(n/2 + n/3 + ... + n/p) = O(nlog(logn)), see https://mathoverflow.net/questions/4596/on-the-series-1-2-1-3-1-5-1-7-1-11"
"class Solution(object):
    def __init__(self):
        self.__max_heap = []
        self.__min_heap = []

    def addNum(self, num):
        if not self.__max_heap or num > -self.__max_heap[0]:
            heappush(self.__min_heap, num)
            if len(self.__min_heap) > len(self.__max_heap) + 1:
                heappush(self.__max_heap, -heappop(self.__min_heap))
        else:
            heappush(self.__max_heap, -num)
            if len(self.__max_heap) > len(self.__min_heap):
                heappush(self.__min_heap, -heappop(self.__max_heap))

    def findMedian(self):
        return (-self.__max_heap[0] + self.__min_heap[0]) / 2.0 \
               if len(self.__min_heap) == len(self.__max_heap) \
               else self.__min_heap[0]

","# Time:  O(nlogn) for total n addNums, O(logn) per addNum, O(1) per findMedian."
"class Solution(object):
    def minAbbreviation(self, target, dictionary):
        def bits_to_abbr_len(targets, bits):
            total = 0
            pre = 0
            for i in range(len(target)):
                if bits & 1:
                    if i - pre > 0:
                        total += len(str(i - pre))
                    pre = i + 1
                    total += 1
                elif i == len(target) - 1:
                    total += len(str(i - pre + 1))
                bits >>= 1
            return total

        def bits_to_abbr(targets, bits):
            abbr = []
            pre = 0
            for i in range(len(target)):
                if bits & 1:
                    if i - pre > 0:
                        abbr.append(str(i - pre))
                    pre = i + 1
                    abbr.append(target[i])
                elif i == len(target) - 1:
                    abbr.append(str(i - pre + 1))
                bits >>= 1
            return """".join(abbr)
  
        diffs = []
        for word in dictionary:
            if len(word) != len(target):
                continue
            diffs.append(sum(2**i for i, c in enumerate(word) if target[i] != c))

        if not diffs:
            return str(len(target))

        result = 2**len(target)-1
        for mask in range(2**len(target)):
            if all(d & mask for d in diffs) and bits_to_abbr_len(target, mask) < bits_to_abbr_len(target, result):
                result = mask
        return bits_to_abbr(target, result)",# Time:  O((d + n) * 2^n)
"class Solution2(object):
    def minAbbreviation(self, target, dictionary):
        def bits_to_abbr(targets, bits):
            abbr = []
            pre = 0
            for i in range(len(target)):
                if bits & 1:
                    if i - pre > 0:
                        abbr.append(str(i - pre))
                    pre = i + 1
                    abbr.append(target[i])
                elif i == len(target) - 1:
                    abbr.append(str(i - pre + 1))
                bits >>= 1
            return """".join(abbr)
  
        diffs = []
        for word in dictionary:
            if len(word) != len(target):
                continue
            diffs.append(sum(2**i for i, c in enumerate(word) if target[i] != c))

        if not diffs:
            return str(len(target))

        result = target
        for mask in range(2**len(target)):
            abbr = bits_to_abbr(target, mask)
            if all(d & mask for d in diffs) and len(abbr) < len(result):
                result = abbr
        return result
",# Time:  O((d + n) * 2^n)
"class Solution(object):
    def numberToWords(self, num):
        if num == 0:
            return ""Zero""

        lookup = {0: ""Zero"", 1:""One"", 2: ""Two"", 3: ""Three"", 4: ""Four"", \
                  5: ""Five"", 6: ""Six"", 7: ""Seven"", 8: ""Eight"", 9: ""Nine"", \
                  10: ""Ten"", 11: ""Eleven"", 12: ""Twelve"", 13: ""Thirteen"", 14: ""Fourteen"", \
                  15: ""Fifteen"", 16: ""Sixteen"", 17: ""Seventeen"", 18: ""Eighteen"", 19: ""Nineteen"", \
                  20: ""Twenty"", 30: ""Thirty"", 40: ""Forty"", 50: ""Fifty"", 60: ""Sixty"", \
                  70: ""Seventy"", 80: ""Eighty"", 90: ""Ninety""}
        unit = ["""", ""Thousand"", ""Million"", ""Billion""]

        res, i = [], 0
        while num:
            cur = num % 1000
            if num % 1000:
                res.append(self.threeDigits(cur, lookup, unit[i]))
            num //= 1000
            i += 1
        return "" "".join(res[::-1])

    def threeDigits(self, num, lookup, unit):
        res = []
        if num / 100:
            res = [lookup[num / 100] + "" "" + ""Hundred""]
        if num % 100:
            res.append(self.twoDigits(num % 100, lookup))
        if unit != """":
            res.append(unit)
        return "" "".join(res)

    def twoDigits(self, num, lookup):
        if num in lookup:
            return lookup[num]
        return lookup[(num / 10) * 10] + "" "" + lookup[num % 10]
","# Time:  O(logn) = O(1), n is the value of the integer, which is less than 2^31 - 1"
"class Solution(object):
    def monotoneIncreasingDigits(self, N):
        nums = list(map(int, list(str(N))))
        leftmost_inverted_idx = len(nums)
        for i in reversed(range(1, len(nums))):
            if nums[i-1] > nums[i]:
                leftmost_inverted_idx = i
                nums[i-1] -= 1
        for i in range(leftmost_inverted_idx, len(nums)):
            nums[i] = 9
        return int("""".join(map(str, nums)))
",# Time:  O(logn) = O(1)
"class Solution(object):
    def minimumIncompatibility(self, nums, k):
        inf = (len(nums)-1)*(len(nums)//k)+1
        def backtracking(nums, d, lookup):
            if not nums:
                return 0
            if nums not in lookup:
                ret = inf
                for new_nums in itertools.combinations(nums, d):
                    new_nums_set = set(new_nums)
                    if len(new_nums_set) < d:
                        continue
                    left = []
                    for num in nums:
                        if num in new_nums_set:
                            new_nums_set.remove(num)
                            continue
                        left.append(num)
                    ret = min(ret, max(new_nums)-min(new_nums) + backtracking(tuple(left), d, lookup))
                lookup[nums] = ret
            return lookup[nums]
        
        result = backtracking(tuple(nums), len(nums)//k, {})
        return result if result != inf else -1

","# Time:  O(sum(i*d * nCr(i*d, d) * nCr(n, i*d) for i in xrange(1, k+1))) < O(sum(n * 2^m * nCr(n, m) for m in xrange(n+1))) = O(n * 3^n)"
"class Solution_TLE(object):
    def minimumIncompatibility(self, nums, k):
        inf = (len(nums)-1)*(len(nums)//k)+1
        POW = [1]
        for i in range(len(nums)):
            POW.append(POW[-1]<<1)
        
        def popcount(n):
            result = 0
            while n:
                n &= n - 1
                result += 1
            return result
    
        def find_candidates(nums, k):
            total = POW[len(nums)]-1
            m = len(nums)//k
            result = [inf]*(total+1)
            for mask in range(total+1):
                if popcount(mask) != m:
                    continue
                lookup = 0
                mx, mn = 0, inf
                for i in range(len(nums)):
                    if mask&POW[i] == 0:
                        continue
                    if lookup&POW[nums[i]]:
                        break
                    lookup |= POW[nums[i]]
                    mx = max(mx, nums[i])
                    mn = min(mn, nums[i])
                else:
                    result[mask] = mx-mn
            return result
        
        candidates = find_candidates(nums, k)
        m = len(nums)//k
        total = POW[len(nums)]-1
        dp = [inf]*(total+1)
        dp[0] = 0
        for mask in range(total+1):
            if popcount(mask) % m != 0:
                continue
            submask = mask
            while submask:
                dp[mask] = min(dp[mask], dp[mask-submask] + candidates[submask])
                submask = (submask-1)&mask
        return dp[-1] if dp[-1] != inf else -1

","# Time:  O(max(n * 2^n, 3^n))"
"class Solution_Wrong_Greedy_SortedList(object):
    def minimumIncompatibility(self, nums, k):
        def greedy(nums, k, is_reversed):
            count = collections.Counter(nums)
            if max(count.values()) > k:
                return -1
            ordered_set = sortedcontainers.SortedList(iter(count.keys()))
            freq_to_nodes = collections.defaultdict(collections.OrderedDict)
            for x in ordered_set:
                freq_to_nodes[count[x]][x] = count[x]
            stks = [[] for _ in range(k)] 
            curr = 0
            while ordered_set: 
                if len(stks)-curr in freq_to_nodes: 
                    for x in freq_to_nodes[len(stks)-curr].keys(): 
                        for i in range(curr, len(stks)):
                            stks[i].append(x)
                        count.pop(x)
                        ordered_set.remove(x)
                    freq_to_nodes.pop(len(stks)-curr)
                to_remove = []
                direction = (lambda x:x) if not is_reversed else reversed
                for x in direction(ordered_set):
                    stks[curr].append(x)
                    freq_to_nodes[count[x]].pop(x)
                    if not freq_to_nodes[count[x]]:
                        freq_to_nodes.pop(count[x])
                    count[x] -= 1 
                    if not count[x]:
                        count.pop(x)
                        to_remove.append(x)
                    else:
                        freq_to_nodes[count[x]][x] = count[x]
                    if len(stks[curr]) == len(nums)//k:
                        curr += 1
                        break
                for x in to_remove:
                    ordered_set.remove(x) 
            return sum([max(stk)-min(stk) for stk in stks])

        return min(greedy(nums, k, False), greedy(nums, k, True)) 

",# Time:  O(nlogn)
"class Solution_Wrong_Greedy_SkipList(object):
    def minimumIncompatibility(self, nums, k):
        def greedy(nums, k, is_reversed):
            count = collections.Counter(nums)
            if max(count.values()) > k:
                return -1
            ordered_set = SkipList() if not is_reversed else SkipList(end=float(""-inf""), cmp=lambda x, y: x > y)
            freq_to_nodes = collections.defaultdict(collections.OrderedDict)
            for x in sorted(list(count.keys()), reverse=is_reversed):
                ordered_set.add(x)
                freq_to_nodes[count[x]][x] = count[x]
            stks = [[] for _ in range(k)] 
            curr = 0
            while ordered_set: 
                if len(stks)-curr in freq_to_nodes: 
                    for x in freq_to_nodes[len(stks)-curr].keys(): 
                        for i in range(curr, len(stks)):
                            stks[i].append(x)
                        count.pop(x)
                        ordered_set.remove(ordered_set.find(x))
                    freq_to_nodes.pop(len(stks)-curr)
                it = ordered_set.begin()
                while it != ordered_set.end():
                    x = it.val
                    stks[curr].append(x)
                    freq_to_nodes[count[x]].pop(x)
                    if not freq_to_nodes[count[x]]:
                        freq_to_nodes.pop(count[x])
                    count[x] -= 1 
                    if not count[x]:
                        count.pop(x)
                        it = ordered_set.remove(it) 
                    else:
                        freq_to_nodes[count[x]][x] = count[x]
                        it = it.nexts[0]
                    if len(stks[curr]) == len(nums)//k:
                        curr += 1
                        break
            return sum([max(stk)-min(stk) for stk in stks])

        return min(greedy(nums, k, False), greedy(nums, k, True)) 

",# Time:  O(nlogn)
"class Solution_Wrong_Greedy(object):
    def minimumIncompatibility(self, nums, k):
        def greedy(nums, k, is_reversed):
            count = collections.Counter(nums)
            if max(count.values()) > k:
                return -1
            sorted_keys = sorted(list(count.keys()), reverse=is_reversed)
            stks = [[] for _ in range(k)] 
            curr, remain = 0, len(nums)
            while remain: 
                for x in sorted_keys: 
                    if count[x] != len(stks)-curr:
                        continue
                    for i in range(curr, len(stks)):
                        stks[i].append(x)
                    remain -= count[x]
                    count[x] = 0
                for x in sorted_keys:
                    if not count[x]:
                        continue
                    stks[curr].append(x)
                    remain -= 1
                    count[x] -= 1
                    if len(stks[curr]) == len(nums)//k:
                        curr += 1
                        break
            return sum([max(stk)-min(stk) for stk in stks])

        return min(greedy(nums, k, False), greedy(nums, k, True)) 
","# Time:  O(nlogn + k * n), could be improved to O(nlogn) by skiplist or orderedlist"
"class Solution(object):
    def maxLength(self, arr):
        def bitset(s):
            result = 0
            for c in s:
                if result & power[ord(c)-ord('a')]:
                    return 0
                result |= power[ord(c)-ord('a')]
            return result
        
        def number_of_one(n):
            result = 0
            while n:
                n &= n-1
                result += 1
            return result

        dp = [0]
        for x in arr:
            x_set = bitset(x)
            if not x_set:
                continue
            curr_len = len(dp)
            for i in range(curr_len):
                if dp[i] & x_set:
                    continue
                dp.append(dp[i] | x_set)
        return max(number_of_one(s_set) for s_set in dp)

",# Time:  O(n) ~ O(2^n)
"class Solution2(object):
    def maxLength(self, arr):
        def bitset(s):
            result = 0
            for c in s:
                if result & power[ord(c)-ord('a')]:
                    return 0
                result |= power[ord(c)-ord('a')]
            return result
    
        bitsets = [bitset(x) for x in arr]
        result = 0
        for i in range(power[len(arr)]):
            curr_bitset, curr_len = 0, 0
            while i:
                j = i & -i 
                i ^= j
                j = log2[j] 
                if not bitsets[j] or (curr_bitset & bitsets[j]):
                    break
                curr_bitset |= bitsets[j]
                curr_len += len(arr[j])
            else:
                result = max(result, curr_len)
        return result",# Time:  O(2^n)
"class Solution(object):
    def rotatedDigits(self, N):
        A = list(map(int, str(N)))
        invalid, diff = set([3, 4, 7]), set([2, 5, 6, 9])
        def dp(A, i, is_prefix_equal, is_good, lookup):
            if i == len(A): return int(is_good)
            if (i, is_prefix_equal, is_good) not in lookup:
                result = 0
                for d in range(A[i]+1 if is_prefix_equal else 10):
                    if d in invalid: continue
                    result += dp(A, i+1,
                                 is_prefix_equal and d == A[i],
                                 is_good or d in diff,
                                 lookup)
                lookup[i, is_prefix_equal, is_good] = result
            return lookup[i, is_prefix_equal, is_good]

        lookup = {}
        return dp(A, 0, True, False, lookup)

",# Time:  O(logn)
"class Solution2(object):
    def rotatedDigits(self, N):
        INVALID, SAME, DIFF = 0, 1, 2
        same, diff = [0, 1, 8], [2, 5, 6, 9]
        dp = [0] * (N+1)
        dp[0] = SAME
        for i in range(N//10+1):
            if dp[i] != INVALID:
                for j in same:
                    if i*10+j <= N:
                        dp[i*10+j] = max(SAME, dp[i])
                for j in diff:
                    if i*10+j <= N:
                        dp[i*10+j] = DIFF
        return dp.count(DIFF)

",# Time:  O(n)
"class Solution3(object):
    def rotatedDigits(self, N):
        invalid, diff = set(['3', '4', '7']), set(['2', '5', '6', '9'])
        result = 0
        for i in range(N+1):
            lookup = set(list(str(i)))
            if invalid & lookup:
                continue
            if diff & lookup:
                result += 1
        return result

","# Time:  O(nlogn) = O(n), because O(logn) = O(32) by this input"
"class Solution(object):
    def maxProduct(self, A):
        global_max, local_max, local_min = float(""-inf""), 1, 1
        for x in A:
            local_max, local_min = max(x, local_max * x, local_min * x), min(x, local_max * x, local_min * x)
            global_max = max(global_max, local_max)
        return global_max
",# Time:  O(n)
"class Solution2(object):
    def maxProduct(self, A):
        global_max, local_max, local_min = float(""-inf""), 1, 1
        for x in A:
            local_max = max(1, local_max)
            if x > 0:
                local_max, local_min = local_max * x, local_min * x
            else:
                local_max, local_min = local_min * x, local_max * x
            global_max = max(global_max, local_max)
        return global_max
",# Time:  O(n)
"class Solution(object):
    def checkContradictions(self, equations, values):
        EPS = 1e-5
        uf = UnionFind()
        return any(not uf.union_set(a, b, k) and abs(uf.query_set(a, b)-k) >= EPS for (a, b), k in zip(equations, values))

",# Time:  O(e + q)
"class Solution2(object):
    def checkContradictions(self, equations, values):
        def isclose(a, b, rel_tol=1e-09, abs_tol=0.0):
            return abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)

        def iter_dfs(adj, u, lookup):
            stk = [u]
            lookup[u] = 1.0
            while stk:
                u = stk.pop()
                for v, k in adj[u]:
                    if v in lookup:
                        if not isclose(lookup[v], lookup[u]*k):
                            return True
                        continue
                    lookup[v] = lookup[u]*k
                    stk.append(v)
            return False

        adj = collections.defaultdict(set)
        for (a, b), k in zip(equations, values):
            adj[a].add((b, 1.0/k))
            adj[b].add((a, 1.0*k))
        lookup = {}
        for u in adj.keys():
            if u in lookup:
                continue
            if iter_dfs(adj, u, lookup):
                return True
        return False",# Time:  O(e + q)
"class Solution(object):
    def rearrangeBarcodes(self, barcodes):
        k = 2
        cnts = collections.Counter(barcodes)
        bucket_cnt = max(cnts.values())
        result = [0]*len(barcodes)
        i = (len(barcodes)-1)%k
        for c in itertools.chain((c for c, v in cnts.items() if v == bucket_cnt), (c for c, v in cnts.items() if v != bucket_cnt)):
            for _ in range(cnts[c]):
                result[i] = c
                i += k
                if i >= len(result):
                    i = (i-1)%k
        return result

import collections

","# Time:  O(n), k is the number of distinct barcodes"
"class Solution2(object):
    def rearrangeBarcodes(self, barcodes):
        cnts = collections.Counter(barcodes)
        sorted_cnts = [[v, k] for k, v in cnts.items()]
        sorted_cnts.sort(reverse=True)

        i = 0
        for v, k in sorted_cnts:
            for _ in range(v):
                barcodes[i] = k
                i += 2
                if i >= len(barcodes):
                    i = 1
        return barcodes","# Time:  O(n), k is the number of distinct barcodes"
"class Solution(object):
    def countPairs(self, nums, k):
        def gcd(x, y):
            while y:
                x, y = y, x%y
            return x
    
        cnt = collections.Counter()
        for x in nums:
            cnt[gcd(x, k)] += 1
        result = 0
        for x in cnt.keys():
            for y in cnt.keys():
                if x > y or x*y%k:
                    continue
                result += cnt[x]*cnt[y] if x != y else cnt[x]*(cnt[x]-1)//2
        return result

",# Time:  O(nlogk + sqrt(k)^2) = O(nlogk + k)
"class Solution2(object):
    def countPairs(self, nums, k):
        def gcd(x, y):
            while y:
                x, y = y, x%y
            return x

        result = 0
        gcds = collections.Counter()
        for x in nums:
            gcd_i = gcd(x, k)
            result += sum(cnt for gcd_j, cnt in gcds.items() if gcd_i*gcd_j%k == 0)
            gcds[gcd_i] += 1
        return result",# Time:  O(nlogk + n * sqrt(k))
"class Solution(object):
    def earliestAndLatest(self, n, firstPlayer, secondPlayer):
        def memoization(t, l, r, lookup):
            if (t, l, r) not in lookup:
                if l == r:
                    return (1, 1)
                if l > r: 
                    l, r, = r, l
                result = [float(""inf""), 0]
                for i in range(l+1):
                    l_win_cnt, l_lose_cnt, nt, pair_cnt = i+1, l-i, (t+1)//2, t//2
                    min_j = max(l_lose_cnt, r-(pair_cnt-l_lose_cnt)) 
                    max_j = min(r-l_win_cnt, (nt-l_win_cnt)-1) 
                    for j in range(min_j, max_j+1):
                        tmp = memoization(nt, i, j, lookup)
                        result = min(result[0], tmp[0]+1), max(result[1], tmp[1]+1)
                lookup[t, l, r] = result
            return lookup[t, l, r]
        
        return memoization(n, firstPlayer-1, n-secondPlayer, {})",# Time:  O(n^2) states * O(n^2) per state = O(n^4)
"class Solution(object):
    def kIncreasing(self, arr, k):
        def longest_non_decreasing_subsequence(arr):
            result = []
            for x in arr:
                right = bisect.bisect_right(result, x)
                if right == len(result):
                    result.append(x)
                else:
                    result[right] = x
            return len(result)

        return len(arr) - sum(longest_non_decreasing_subsequence((arr[j] for j in range(i, len(arr), k))) for i in range(k))",# Time:  O(k * (n/k)log(n/k)) = O(nlog(n/k))
"class Solution(object):
    def closestToTarget(self, arr, target):
        count = BitCount(max(arr).bit_length())
        result, left = float(""inf""), 0
        for right in range(len(arr)):
            count += arr[right]
            while left <= right:
                f = count.bit_and()
                result = min(result, abs(f-target))
                if f >= target:
                    break
                count -= arr[left]
                left += 1
        return result
    
    ","# Time:  O(nlogm), m is the max value of arr"
"class Solution2(object):
    def closestToTarget(self, arr, target):
        result, dp = float(""inf""), set() 
        for x in arr:
            dp = {x}|{f&x for f in dp}
            for f in dp:
                result = min(result, abs(f-target))
        return result","# Time:  O(nlogm), m is the max value of arr"
"class Solution(object):
    def moveZeroes(self, nums):
        pos = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[i], nums[pos] = nums[pos], nums[i]
                pos += 1

    def moveZeroes2(self, nums):
        nums.sort(cmp=lambda a, b: 0 if b else -1)

",# Time:  O(n)
"class Solution2(object):
    def moveZeroes(self, nums):
        pos = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[pos] = nums[i]
                pos += 1

        for i in range(pos, len(nums)):
            nums[i] = 0

",# Time:  O(n)
"class Solution(object): 
    def assignBikes(self, workers, bikes):
        def manhattan(p1, p2):
            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
        
        dp = [[float(""inf"")]*((1<<len(bikes))) for _ in range(2)]
        dp[0][0] = 0
        for i in range(len(workers)):
            dp[(i+1)%2] = [float(""inf"")] * ((1<<len(bikes)))
            for j in range(len(bikes)):
                for taken in range((1<<len(bikes))):
                    if taken & (1<<j):
                        continue
                    dp[(i+1)%2][taken|(1<<j)] = \
                        min(dp[(i+1)%2][taken|(1<<j)],
                            dp[i%2][taken] +
                            manhattan(workers[i], bikes[j]))
        return min(dp[len(workers)%2])

",# Time:  O(w * b * 2^b)
"class Solution2(object):
    def assignBikes(self, workers, bikes):
        def manhattan(p1, p2):
            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
        
        min_heap = [(0, 0, 0)]
        lookup = set()
        while min_heap:
            cost, i, taken = heapq.heappop(min_heap)
            if (i, taken) in lookup:
                continue
            lookup.add((i, taken))
            if i == len(workers):
                return cost
            for j in range(len(bikes)):
                if taken & (1<<j):
                    continue
                heapq.heappush(min_heap, (cost+manhattan(workers[i], bikes[j]), 
                                          i+1,           
                                          taken|(1<<j))) 
",# Time:  O((w * b * 2^b) * log(w * b * 2^b))
"class Solution(object):
    def findDifferentBinaryString(self, nums):
        return """".join(""01""[nums[i][i] == '0'] for i in range(len(nums)))

",# Time:  O(n)
"class Solution2(object):
    def findDifferentBinaryString(self, nums):
        lookup = set([int(x, 2) for x in nums]) 
        return next(bin(i)[2:].zfill(len(nums[0])) for i in range(2**len(nums[0])) if i not in lookup) 

","# Time:  O(k * n) = O(n^2), k is len(nums)"
"class Solution_Extra(object):
    def findAllDifferentBinaryStrings(self, nums):
        lookup = set([int(x, 2) for x in nums]) 
        return [bin(i)[2:].zfill(len(nums[0])) for i in range(2**len(nums[0])) if i not in lookup] ","# Time:  O(k * n + n * 2^n) = O(n * 2^n), k is len(nums)"
"class Solution(object):
    def findOrder(self, numCourses, prerequisites):
        adj = collections.defaultdict(list)
        in_degree = collections.Counter()
        for u, v in prerequisites:
            in_degree[u] += 1
            adj[v].append(u)
        result = []
        q = [u for u in range(numCourses) if u not in in_degree]
        while q:
            new_q = []
            for u in q:
                result.append(u)
                for v in adj[u]:
                    in_degree[v] -= 1
                    if in_degree[v] == 0:
                        new_q.append(v)
            q = new_q
        return result if len(result) == numCourses else []

",# Time:  O(|V| + |E|)
"class Solution2(object):
    def findOrder(self, numCourses, prerequisites):
        adj = collections.defaultdict(list)
        in_degree = collections.Counter()
        for u, v in prerequisites:
            in_degree[u] += 1
            adj[v].append(u)
        result = []
        stk = [u for u in range(numCourses) if u not in in_degree]
        while stk:
            u = stk.pop()
            result.append(u)
            for v in adj[u]:
                in_degree[v] -= 1
                if in_degree[v] == 0:
                    stk.append(v)
        return result if len(result) == numCourses else []

",# Time:  O(|V| + |E|)
"class Solution3(object):
    def findOrder(self, numCourses, prerequisites):
        WHITE, GRAY, BLACK = list(range(3))
        def dfs(u):
            if lookup[u] != WHITE:
                return lookup[u] == BLACK
            lookup[u] = GRAY
            if any(not dfs(v) for v in adj[u]):
                return False
            lookup[u] = BLACK
            result.append(u) 
            return True

        result = []
        adj = collections.defaultdict(list)
        for u, v in prerequisites:
            adj[u].append(v)
        lookup = collections.defaultdict(lambda:WHITE)
        for u in range(numCourses):
            if not dfs(u):
                return []
        return result

import collections


",# Time:  O(|V| + |E|)
"class Solution4(object):
    def findOrder(self, numCourses, prerequisites):
        WHITE, GRAY, BLACK = list(range(3))
        def dfs(u):
            if lookup[u] != WHITE:
                return lookup[u] == BLACK
            lookup[u] = GRAY
            if any(not dfs(v) for v in adj[u]):
                return False
            lookup[u] = BLACK
            result.append(u) 
            return True

        result = []
        adj = collections.defaultdict(list)
        for u, v in prerequisites:
            adj[v].append(u)
        lookup = collections.defaultdict(lambda:WHITE)
        for u in range(numCourses):
            if not dfs(u):
                return []
        result.reverse()
        return result",# Time:  O(|V| + |E|)
"class Solution(object):
    def countOfPairs(self, nums):
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD
    
        def nHr(n, r):
            return nCr(n+r-1, r)

        MOD = 10**9+7
        cnt = nums[-1]-sum(max(nums[i]-nums[i-1], 0) for i in range(1, len(nums)))
        return nHr(len(nums)+1, cnt) if cnt >= 0 else 0
    
","# Time:  O(n + r), r = max(nums)"
"class Solution2(object):
    def countOfPairs(self, nums):
        MOD = 10**9+7
        dp = [int(i <= nums[0]) for i in range(max(nums)+1)] 
        for i in range(1, len(nums)):
            new_dp = [0]*len(dp)
            diff = max(nums[i]-nums[i-1], 0)
            for j in range(diff, nums[i]+1):
                new_dp[j] = (new_dp[j-1]+dp[j-diff])%MOD
            dp = new_dp
        return reduce(lambda accu, x: (accu+x)%MOD, dp, 0)","# Time:  O(n + r), r = max(nums)"
"class Solution(object):
    def maxNumber(self, nums1, nums2, k):
        def get_max_digits(nums, start, end, max_digits):
            max_digits[end] = max_digit(nums, end)
            for i in reversed(range(start, end)):
                max_digits[i] = delete_digit(max_digits[i + 1])

        def max_digit(nums, k):
            drop = len(nums) - k
            res = []
            for num in nums:
                while drop and res and res[-1] < num:
                    res.pop()
                    drop -= 1
                res.append(num)
            return res[:k]

        def delete_digit(nums):
            res = list(nums)
            for i in range(len(res)):
                if i == len(res) - 1 or res[i] < res[i + 1]:
                    res = res[:i] + res[i+1:]
                    break
            return res

        def merge(a, b):
            return [max(a, b).pop(0) for _ in range(len(a)+len(b))]

        m, n = len(nums1), len(nums2)

        max_digits1, max_digits2 = [[] for _ in range(k + 1)], [[] for _ in range(k + 1)]
        get_max_digits(nums1, max(0, k - n), min(k, m), max_digits1)
        get_max_digits(nums2, max(0, k - m), min(k, n), max_digits2)

        return max(merge(max_digits1[i], max_digits2[k-i]) \
                   for i in range(max(0, k - n), min(k, m) + 1))
",# Time:  O(k * (m + n + k)) ~ O(k * (m + n + k^2))
"class Solution(object):
    def maxLevelSum(self, root):
        def dfs(node, i, level_sums):
            if not node:
                return
            if i == len(level_sums):
                level_sums.append(0)
            level_sums[i] += node.val
            dfs(node.left, i+1, level_sums)
            dfs(node.right, i+1, level_sums)

        level_sums = []
        dfs(root, 0, level_sums)
        return level_sums.index(max(level_sums))+1

",# Time:  O(n)
"class Solution2(object):
    def maxLevelSum(self, root):
        result, level, max_total = 0, 1, float(""-inf"")
        q = collections.deque([root])
        while q:
            total = 0
            for _ in range(len(q)):
                node = q.popleft()
                total += node.val
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            if total > max_total:
                result, max_total = level, total
            level += 1
        return result",# Time:  O(n)
"class Solution(object):
    def findKthLargest(self, nums, k):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        nth_element(nums, k-1, compare=lambda a, b: a > b)
        return nums[k-1]

","# Time:  O(n) on average, using Median of Medians could achieve O(n) (Intro Select)"
"class Solution2(object):
    def findKthLargest(self, nums, k):
        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = randint(left, right)
            new_pivot_idx = self.PartitionAroundPivot(left, right, pivot_idx, nums)
            if new_pivot_idx == k - 1:
                return nums[new_pivot_idx]
            elif new_pivot_idx > k - 1:
                right = new_pivot_idx - 1
            else: 
                left = new_pivot_idx + 1

    def PartitionAroundPivot(self, left, right, pivot_idx, nums):
        pivot_value = nums[pivot_idx]
        new_pivot_idx = left
        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
        for i in range(left, right):
            if nums[i] > pivot_value:
                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                new_pivot_idx += 1

        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
        return new_pivot_idx
","# Time:  O(n) on average, using Median of Medians could achieve O(n) (Intro Select)"
"class Solution(object):
    def maximumScore(self, grid):
        prefix = [0]*(len(grid)+1)
        for i in range(len(grid)):
            prefix[i+1] = prefix[i]+grid[i][0]
        result = 0
        dp = [[0]*(len(grid)+1) for _ in range(2)]
        for j in range(1, len(grid[0])):
            new_prefix = [0]*(len(grid)+1)
            for i in range(len(grid)):
               new_prefix[i+1] = new_prefix[i]+grid[i][j]
            new_dp = [[0]*(len(grid)+1) for _ in range(2)]
            for i in range(len(grid)+1):
                for k in range(i+1):
                    new_dp[0][i] = max(new_dp[0][i], (prefix[i]-prefix[k])+dp[0][k])
                new_dp[0][i] = max(new_dp[0][i], max(dp[1]))
                for k in range(i+1, len(grid)+1):
                    new_dp[1][i] = max(new_dp[1][i], dp[1][k]+(new_prefix[k]-new_prefix[i]))
                new_dp[1][i] = max(new_dp[1][i], new_dp[0][i])
            dp, prefix = new_dp, new_prefix
        return max(dp[1])
",# Time:  O(n^3)
"class Solution2(object):
    def maximumScore(self, grid):
        prefix = [0]*(len(grid)+1)
        for i in range(len(grid)):
            prefix[i+1] = prefix[i]+grid[i][0]
        dp = [[0]*(len(grid)+1) for _ in range(2)]
        for j in range(1, len(grid[0])):
            new_prefix = [0]*(len(grid)+1)
            for i in range(len(grid)):
               new_prefix[i+1] = new_prefix[i]+grid[i][j]
            new_dp = [[0]*(len(grid)+1) for _ in range(2)]
            for i in range(len(grid)+1):
                for k in range(len(grid)+1):
                    new_dp[0][i] = max(new_dp[0][i], max(prefix[i]-prefix[k], 0)+dp[0][k])
                    new_dp[1][i] = max(new_dp[1][i], dp[1][k]+max(new_prefix[k]-new_prefix[i], 0))
                new_dp[0][i] = max(new_dp[0][i], max(dp[1]))
                new_dp[1][i] = max(new_dp[1][i], new_dp[0][i])
            dp, prefix = new_dp, new_prefix
        return max(dp[1])
",# Time:  O(n^3)
"class Solution(object):
    def minimumSubarrayLength(self, nums, k):
        def update(x, d, curr):
            for i in range(len(cnt)):
                if x < (1<<i):
                    break
                if not (x&(1<<i)):
                    continue
                if cnt[i] == 0:
                    curr ^= 1<<i
                cnt[i] += d
                if cnt[i] == 0:
                    curr ^= 1<<i
            return curr

        total = reduce(lambda x, y: x|y, nums)
        if total < k:
            return -1
        cnt = [0]*total.bit_length()
        result = len(nums)
        left = curr = 0
        for right in range(len(nums)):
            curr = update(nums[right], +1, curr)
            while left <= right and curr >= k:
                result = min(result, right-left+1)
                curr = update(nums[left], -1, curr)
                left += 1
        return result 

",# Time:  O(nlogr) = O(n * 30)
"class Solution2(object):
    def minimumSubarrayLength(self, nums, k):
        result = float(""inf"")
        for left in range(len(nums)):
            curr = 0
            for right in range(left, len(nums)):
                curr |= nums[right]
                if curr < k:
                    continue
                result = min(result, right-left+1)
                break
        return result if result != float(""inf"") else -1
    ",# Time:  O(n^2)
"class Solution(object):
    def sumOfNumberAndReverse(self, num):
        def backtracking(num, chosen):
            if num == 0:
                return True
            if chosen == 1:
                return False
            if num <= 18:
                return (num%2 == 0) or (num == 11 and chosen == 0)
            if chosen == 2:
                return False
            for x in (num%10, 10+num%10):
                if not (1 <= x <= 18):
                    continue
                base = 11
                if chosen:
                    base = chosen
                else:
                    while x*((base-1)*10+1) <= num:
                        base = (base-1)*10+1
                if num-x*base >= 0 and backtracking((num-x*base)//10, base//100+1):
                    return True
            return False

        return backtracking(num, 0)

",# Time:  O(2^(log10(n)/2)) = O(n^(1/(2*log2(10))))
"class Solution2(object):
    def sumOfNumberAndReverse(self, num):
        def reverse(n):
            result = 0
            while n:
                result = result*10 + n%10
                n //= 10            
            return result

        return any(x+reverse(x) == num for x in range(num//2, num+1))

",# Time:  O(nlogn)
"class Solution3(object):
    def sumOfNumberAndReverse(self, num):
        return any(x+int(str(x)[::-1]) == num for x in range(num//2, num+1))",# Time:  O(nlogn)
"class Solution(object):
    def isNumber(self, s):
        transition_table = [[-1,  0,  3,  1,  2, -1],    
                            [-1,  8, -1,  1,  4,  5],    
                            [-1, -1, -1,  4, -1, -1],    
                            [-1, -1, -1,  1,  2, -1],    
                            [-1,  8, -1,  4, -1,  5],    
                            [-1, -1,  6,  7, -1, -1],    
                            [-1, -1, -1,  7, -1, -1],    
                            [-1,  8, -1,  7, -1, -1],    
                            [-1,  8, -1, -1, -1, -1]]    

        state = 0
        for char in s:
            inputType = InputType.INVALID
            if char.isspace():
                inputType = InputType.SPACE
            elif char == '+' or char == '-':
                inputType = InputType.SIGN
            elif char.isdigit():
                inputType = InputType.DIGIT
            elif char == '.':
                inputType = InputType.DOT
            elif char == 'e' or char == 'E':
                inputType = InputType.EXPONENT

            state = transition_table[state][inputType]

            if state == -1:
                return False

        return state == 1 or state == 4 or state == 7 or state == 8

",# Time:  O(n)
"class Solution2(object):
    def isNumber(self, s):
        import re
        return bool(re.match(""^\s*[\+-]?((\d+(\.\d*)?)|\.\d+)([eE][\+-]?\d+)?\s*$"", s))

",# Time:  O(n)
"class Solution(object):
    def getFinalState(self, nums, k, multiplier):
        MOD = 10**9+7
        EPS = 1e-15
        def count(x, target):
            return int(target-x+EPS)

        if multiplier == 1:
            return nums
        vals = sorted((log(x)/log(multiplier), i) for i, x in enumerate(nums))
        left = 0
        for right in range(1, (int(vals[-1][0])+1)+1):
            while left < len(vals) and count(vals[left][0], right) >= 1:
                left += 1
            if k-left < 0:
                right -= 1
                break
            k -= left
        for idx, (x, i) in enumerate(vals):
            c = count(x, right)
            if c <= 0:
                break
            nums[i] *= pow(multiplier, c)
        q, r = divmod(k, len(nums))
        m = pow(multiplier, q, MOD)
        result = [0]*len(nums)
        for idx, (x, i) in enumerate(sorted((x, i) for i, x in enumerate(nums))):
            result[i] = x*m*(multiplier if idx < r else 1)%MOD
        return result

","# Time:  O(n + (n + logr) + nlog(logr) + nlogn) = O(nlogn), assumed log(x) takes O(1) time"
"class Solution2(object):
    def getFinalState(self, nums, k, multiplier):
        MOD = 10**9+7
        EPS = 1e-15
        def binary_search_right(left, right, check):
            while left <= right:
                mid = left+(right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right

        def count(x, target):
            return int(target-x+EPS)

        def check(target):
            result = 0
            for x, i in vals:
                c = count(x, target)
                if c <= 0:
                    break
                result += c
            return result <= k

        if multiplier == 1:
            return nums
        vals = sorted((log(x)/log(multiplier), i) for i, x in enumerate(nums))
        target = binary_search_right(1, int(vals[-1][0])+1, check)
        for idx, (x, i) in enumerate(vals):
            c = count(x, target)
            if c <= 0:
                break
            k -= c
            nums[i] *= pow(multiplier, c)
        q, r = divmod(k, len(nums))
        m = pow(multiplier, q, MOD)
        result = [0]*len(nums)
        for idx, (x, i) in enumerate(sorted((x, i) for i, x in enumerate(nums))):
            result[i] = x*m*(multiplier if idx < r else 1)%MOD
        return result

","# Time:  O(n + min(n, k) * log(logr) + nlog(logr) + nlogn) = O(nlogr), assumed log(x) takes O(1) time"
"class Solution3(object):
    def getFinalState(self, nums, k, multiplier):
        MOD = 10**9+7
        if multiplier == 1:
            return nums
        min_heap = [(x, i) for i, x in enumerate(nums)]
        heapq.heapify(min_heap)
        mx = max(nums)
        for k in reversed(list(range(1, k+1))):
            if min_heap[0][0]*multiplier > mx:
                break
            x, i = heapq.heappop(min_heap)
            heapq.heappush(min_heap, (x*multiplier, i))
        else:
            k = 0
        vals = sorted(min_heap)
        q, r = divmod(k, len(nums))
        m = pow(multiplier, q, MOD)
        result = [0]*len(nums)
        for idx, (x, i) in enumerate(vals):
            result[i] = x*m*(multiplier if idx < r else 1)%MOD
        return result","# Time:  O(min(nlogr, k) * logn + nlogn) = O(nlogn * logr)"
"class Solution(object):
    def minWindow(self, S, T):
        lookup = [[None for _ in range(26)] for _ in range(len(S)+1)]
        find_char_next_pos = [None]*26
        for i in reversed(range(len(S))):
            find_char_next_pos[ord(S[i])-ord('a')] = i+1
            lookup[i] = list(find_char_next_pos)

        min_i, min_len = None, float(""inf"")
        for i in range(len(S)):
            if S[i] != T[0]:
                continue
            start = i
            for c in T:
                start = lookup[start][ord(c)-ord('a')]
                if start == None:
                    break
            else:
                if start-i < min_len:
                    min_i, min_len = i, start-i
        return S[min_i:min_i+min_len] if min_i is not None else """"
",# Time:  O(s * t)
"class Solution2(object):
    def minWindow(self, S, T):
        dp = [[None for _ in range(len(S))] for _ in range(2)]
        for j, c in enumerate(S):
            if c == T[0]:
                dp[0][j] = j

        for i in range(1, len(T)):
            prev = None
            dp[i%2] = [None] * len(S)
            for j, c in enumerate(S):
                if prev is not None and c == T[i]:
                    dp[i%2][j] = prev
                if dp[(i-1)%2][j] is not None:
                    prev = dp[(i-1)%2][j]

        start, end = 0, len(S)
        for j, i in enumerate(dp[(len(T)-1)%2]):
            if i >= 0 and j-i < end-start:
                start, end = i, j
        return S[start:end+1] if end < len(S) else """"
",# Time:  O(s * t)
"class Solution(object):
    def sumOfPowers(self, nums, k):
        MOD = 10**9+7
        nums.sort()
        result = prev = 0
        for mn in sorted({nums[j]-nums[i] for i in range(len(nums)) for j in range(i+1, len(nums))}, reverse=True):
            dp = [[0]*(k+1) for _ in range(len(nums)+1)]
            dp[0][0] = 1
            j = 0
            for i in range(len(nums)):
                j = next((j for j in range(j, len(nums)) if nums[i]-nums[j] < mn), len(nums))
                for l in range(1, k+1):
                    dp[i+1][l] = (dp[i+1][l]+dp[(j-1)+1][l-1])%MOD 
                for l in range(k+1):
                    dp[i+1][l] = (dp[i+1][l]+dp[i][l])%MOD 
            cnt = (dp[-1][k]-prev)%MOD
            result = (result+mn*cnt)%MOD
            prev = dp[-1][k]
        return result

",# Time:  O(n^2 + len(diffs) * n * k) = O(n^3 * k) at most
"class Solution2(object):
    def sumOfPowers(self, nums, k):
        MOD = 10**9+7
        nums.sort()
        dp = [[collections.defaultdict(int) for _ in range(len(nums)+1)] for _ in range(len(nums))]        
        for i in range(len(nums)):
            for j in range(max(k-(len(nums)-i+1)-1, 0), i):
                diff = nums[i]-nums[j]
                dp[i][2][diff] += 1
                for l in range(max(k-(len(nums)-i+1), 0), i+1):
                    for mn, cnt in dp[j][l].items():
                        dp[i][l+1][min(diff, mn)] = (dp[i][l+1][min(diff, mn)]+cnt)%MOD
        return reduce(lambda accu, x: (accu+x)%MOD, ((mn*cnt)%MOD for i in range(k-1, len(dp)) for mn, cnt in dp[i][k].items()))",# Time:  O(n^3 * len(diffs)) = O(n^5) at most
"class Solution(object):
    def mirrorReflection(self, p, q):
        return 2 if (p & -p) > (q & -q) else 0 if (p & -p) < (q & -q) else 1

",# Time:  O(1)
"class Solution2(object):
    def mirrorReflection(self, p, q):
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        lcm = p*q // gcd(p, q)
        if lcm // p % 2 == 1:
            if lcm // q % 2 == 1:
                return 1 
            return 2 
        return 0 
","# Time:  O(log(max(p, q))) = O(1) due to 32-bit integer"
"class Solution(object):
    def maxCount(self, banned, n, maxSum):
        k = min(int((-1+(1+8*maxSum))**0.5/2), n) 
        total = (k+1)*k//2
        result = k
        lookup = set(banned)
        for x in lookup:
            if x <= k:
                total -= x
                result -= 1
        for i in range(k+1, n+1):
            if i in lookup:
                continue
            if total+i > maxSum:
                break
            total += i
            result += 1
        return result

",# Time:  O(b)
"class Solution2(object):
    def maxCount(self, banned, n, maxSum):
        def check(x):
            return (x+1)*x//2-prefix[bisect.bisect_right(sorted_banned, x)] <= maxSum
    
        sorted_banned = sorted(set(banned))
        prefix = [0]*(len(sorted_banned)+1)
        for i in range(len(sorted_banned)):
            prefix[i+1] = prefix[i]+sorted_banned[i]
        left, right = 1, n
        while left <= right:
            mid = left + (right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right-bisect.bisect_right(sorted_banned, right)

",# Time:  O(blogb + logn * logb)
"class Solution3(object):
    def maxCount(self, banned, n, maxSum):
        lookup = set(banned)
        result = total = 0
        for i in range(1, n+1):
            if i in lookup:
                continue
            if total+i > maxSum:
                break
            total += i
            result += 1
        return result",# Time:  O(blogb + logn * logb)
"class Solution(object):
    def minimumTotalPrice(self, n, edges, price, trips):
        def iter_dfs(u, target):
            stk = [(1, (u, -1))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p = args
                    lookup[u] += 1
                    if u == target:
                        return
                    stk.append((2, (u,)))
                    for v in reversed(adj[u]):
                        if v == p:
                            continue
                        stk.append((1, (v, u)))
                elif step == 2:
                    u = args[0]
                    lookup[u] -= 1
    
            lookup[u] += 1
            if u == target:
                return True
            for v in adj[u]:
                if v == p:
                    continue
                if dfs(v, u, target):
                    return True
            lookup[u] -= 1
            return False
    
        def iter_dfs2():
            result = [price[0]*lookup[0], (price[0]//2)*lookup[0]]
            stk = [(1, (0, -1, result))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    for v in reversed(adj[u]):
                        if v == p:
                            continue
                        new_ret = [price[v]*lookup[v], (price[v]//2)*lookup[v]]
                        stk.append((2, (new_ret, ret)))
                        stk.append((1, (v, u, new_ret)))
                elif step == 2:
                    new_ret, ret = args
                    ret[0] += min(new_ret)
                    ret[1] += new_ret[0]
            return min(result)

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        lookup = [0]*n
        for u, v in trips:
            iter_dfs(u, v)
        return iter_dfs2()
",# Time:  O(t * n)
"class Solution2(object):
    def minimumTotalPrice(self, n, edges, price, trips):
        def dfs(u, p, target):
            lookup[u] += 1
            if u == target:
                return True
            for v in adj[u]:
                if v == p:
                    continue
                if dfs(v, u, target):
                    return True
            lookup[u] -= 1
            return False
    
        def dfs2(u, p):
            full, half = price[u]*lookup[u], price[u]//2*lookup[u]
            for v in adj[u]:
                if v == p:
                    continue
                f, h = dfs2(v, u)
                full += min(f, h)
                half += f
            return full, half

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        lookup = [0]*n
        for u, v in trips:
            dfs(u, -1, v)
        return min(dfs2(0, -1))",# Time:  O(t * n)
"class Solution(object):
    def minimumFlips(self, root, result):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
            4: lambda x, y: x^y ,
            5: lambda x, y: not x if x is not None else not y
        }
        
        def iter_dfs(root, result):
            ret = collections.defaultdict(lambda: INF)
            stk = [(1, (root, ret))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node:
                        ret[None] = 0
                        continue
                    if node.left == node.right:
                        ret[True] = node.val^1
                        ret[False] = node.val^0
                        continue
                    ret1 = collections.defaultdict(lambda: INF)
                    ret2 = collections.defaultdict(lambda: INF)
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    for k1, v1 in ret1.items():
                        for k2, v2 in ret2.items():
                            ret[OP[node.val](k1, k2)] = min(ret[OP[node.val](k1, k2)], v1+v2)
            return ret[result]

        return iter_dfs(root, result)


import collections


",# Time:  O(n)
"class Solution2(object):
    def minimumFlips(self, root, result):
        INF = float(""inf"")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
            4: lambda x, y: x^y ,
            5: lambda x, y: not x if x is not None else not y
        }
        
        def dfs(node):
            if not node:
                return {None: 0} 
            if node.left == node.right:
                return {True: node.val^1, False: node.val^0}
            left = dfs(node.left)
            right = dfs(node.right)
            dp = collections.defaultdict(lambda: INF)
            for k1, v1 in left.items():
                for k2, v2 in right.items():
                    dp[OP[node.val](k1, k2)] = min(dp[OP[node.val](k1, k2)], v1+v2)
            return dp

        return dfs(root)[result]",# Time:  O(n)
"class Solution(object):
    def reverseWords(self, s):
        def reverse(s, begin, end):
            for i in range((end - begin) // 2):
                s[begin + i], s[end - 1 - i] = s[end - 1 - i], s[begin + i]

        s, i = list(s), 0
        for j in range(len(s) + 1):
            if j == len(s) or s[j] == ' ':
                reverse(s, i, j)
                i = j + 1
        return """".join(s)

",# Time:  O(n)
"class Solution2(object):
    def reverseWords(self, s):
        reversed_words = [word[::-1] for word in s.split(' ')]
        return ' '.join(reversed_words)
",# Time:  O(n)
"class Solution(object):
    def reverse(self, x):
        if x < 0:
            return -self.reverse(-x)

        result = 0
        while x:
            result = result * 10 + x % 10
            x //= 10
        return result if result <= 0x7fffffff else 0 

    def reverse2(self, x):
        if x < 0:
            x = int(str(x)[::-1][-1] + str(x)[::-1][:-1])
        else:
            x = int(str(x)[::-1])
        x = 0 if abs(x) > 0x7FFFFFFF else x
        return x

    def reverse3(self, x):
        s = cmp(x, 0)
        r = int(repr(s * x)[::-1])
        return s * r * (r < 2 ** 31)

",# Time:  O(logn) = O(1)
"class Solution(object):
    def catMouseGame(self, graph):
        HOLE, MOUSE_START, CAT_START = list(range(3))
        DRAW, MOUSE, CAT = list(range(3))
        def parents(m, c, t):
            if t == CAT:
                for nm in graph[m]:
                    yield nm, c, MOUSE^CAT^t
            else:
                for nc in graph[c]:
                    if nc != HOLE:
                        yield m, nc, MOUSE^CAT^t

        degree = {}
        ignore = set(graph[HOLE])
        for m in range(len(graph)):
            for c in range(len(graph)):
                degree[m, c, MOUSE] = len(graph[m])
                degree[m, c, CAT] = len(graph[c])-(c in ignore)
        color = collections.defaultdict(int)
        q = collections.deque()
        for i in range(len(graph)):
            if i == HOLE:
                continue
            color[HOLE, i, CAT] = MOUSE
            q.append((HOLE, i, CAT, MOUSE))
            for t in [MOUSE, CAT]:
                color[i, i, t] = CAT
                q.append((i, i, t, CAT))
        while q:
            i, j, t, c = q.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if nt == c:
                    color[ni, nj, nt] = c
                    q.append((ni, nj, nt, c))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = c
                    q.append((ni, nj, nt, c))
        return color[MOUSE_START, CAT_START, MOUSE]

import collections

",# Time:  O(n^3)
"class Solution2(object):
    def catMouseGame(self, graph):
        HOLE, MOUSE_START, CAT_START = list(range(3))
        DRAW, MOUSE, CAT = list(range(3))
        def parents(m, c, t):
            if t == CAT:
                for nm in graph[m]:
                    yield nm, c, MOUSE^CAT^t
            else:
                for nc in graph[c]:
                    if nc != HOLE:
                        yield m, nc, MOUSE^CAT^t

        color = collections.defaultdict(int)
        degree = {}
        ignore = set(graph[HOLE])
        for m in range(len(graph)):
            for c in range(len(graph)):
                degree[m, c, MOUSE] = len(graph[m])
                degree[m, c, CAT] = len(graph[c])-(c in ignore)
        q1 = collections.deque()
        q2 = collections.deque()
        for i in range(len(graph)):
            if i == HOLE:
                continue
            color[HOLE, i, CAT] = MOUSE
            q1.append((HOLE, i, CAT))
            for t in [MOUSE, CAT]:
                color[i, i, t] = CAT
                q2.append((i, i, t))
        while q1:
            i, j, t = q1.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if t == CAT:
                    color[ni, nj, nt] = MOUSE
                    q1.append((ni, nj, nt))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = MOUSE
                    q1.append((ni, nj, nt))
        while q2:
            i, j, t = q2.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if t == MOUSE:
                    color[ni, nj, nt] = CAT
                    q2.append((ni, nj, nt))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = CAT
                    q2.append((ni, nj, nt))
        return color[MOUSE_START, CAT_START, MOUSE]",# Time:  O(n^3)
"class Solution(object):
    def generatePalindromes(self, s):
        cnt = collections.Counter(s)
        mid = ''.join(k for k, v in cnt.items() if v % 2)
        chars = ''.join(k * (v / 2) for k, v in cnt.items())
        return self.permuteUnique(mid, chars) if len(mid) < 2 else []

    def permuteUnique(self, mid, nums):
        result = []
        used = [False] * len(nums)
        self.permuteUniqueRecu(mid, result, used, [], nums)
        return result

    def permuteUniqueRecu(self, mid, result, used, cur, nums):
        if len(cur) == len(nums):
            half_palindrome = ''.join(cur)
            result.append(half_palindrome + mid + half_palindrome[::-1])
            return
        for i in range(len(nums)):
            if not used[i] and not (i > 0 and nums[i-1] == nums[i] and used[i-1]):
                used[i] = True
                cur.append(nums[i])
                self.permuteUniqueRecu(mid, result, used, cur, nums)
                cur.pop()
                used[i] = False
",# Time:  O(n * n!)
"class Solution2(object):
    def generatePalindromes(self, s):
        cnt = collections.Counter(s)
        mid = tuple(k for k, v in cnt.items() if v % 2)
        chars = ''.join(k * (v / 2) for k, v in cnt.items())
        return [''.join(half_palindrome + mid + half_palindrome[::-1]) \
                for half_palindrome in set(itertools.permutations(chars))] if len(mid) < 2 else []
",# Time:  O(n * n!)
"class Solution(object):
    def numOfMinutes(self, n, headID, manager, informTime):
        children = collections.defaultdict(list)
        for child, parent in enumerate(manager):
            if parent != -1:
                children[parent].append(child)

        result = 0
        stk = [(headID, 0)]
        while stk:
            node, curr = stk.pop()
            curr += informTime[node]
            result = max(result, curr)
            if node not in children:
                continue
            for c in children[node]:
                stk.append((c, curr))
        return result

",# Time:  O(n)
"class Solution2(object):
    def numOfMinutes(self, n, headID, manager, informTime):
        def dfs(informTime, children, node):
            return (max(dfs(informTime, children, c)
                        for c in children[node])
                    if node in children
                    else 0) + informTime[node]

        children = collections.defaultdict(list)
        for child, parent in enumerate(manager):
            if parent != -1:
                children[parent].append(child)
        return dfs(informTime, children, headID)",# Time:  O(n)
"class Solution(object):
    def diffWaysToCompute(self, input):
        tokens = re.split('(\D)', input)
        nums = list(map(int, tokens[::2]))
        ops = list(map({'+': operator.add, '-': operator.sub, '*': operator.mul}.get, tokens[1::2]))
        lookup = [[None for _ in range(len(nums))] for _ in range(len(nums))]

        def diffWaysToComputeRecu(left, right):
            if left == right:
                return [nums[left]]
            if lookup[left][right]:
                return lookup[left][right]
            lookup[left][right] = [ops[i](x, y)
                                   for i in range(left, right)
                                   for x in diffWaysToComputeRecu(left, i)
                                   for y in diffWaysToComputeRecu(i + 1, right)]
            return lookup[left][right]

        return diffWaysToComputeRecu(0, len(nums) - 1)
","# Time:  O(n * 4^n / n^(3/2)) ~= n * Catalan numbers = n * (C(2n, n) - C(2n, n - 1)),"
"class Solution2(object):
    def diffWaysToCompute(self, input):
        lookup = [[None for _ in range(len(input) + 1)] for _ in range(len(input) + 1)]
        ops = {'+': operator.add, '-': operator.sub, '*': operator.mul}

        def diffWaysToComputeRecu(left, right):
            if lookup[left][right]:
                return lookup[left][right]
            result = []
            for i in range(left, right):
                if input[i] in ops:
                    for x in diffWaysToComputeRecu(left, i):
                        for y in diffWaysToComputeRecu(i + 1, right):
                            result.append(ops[input[i]](x, y))

            if not result:
                result = [int(input[left:right])]
            lookup[left][right] = result
            return lookup[left][right]

        return diffWaysToComputeRecu(0, len(input))
","# Time:  O(n * 4^n / n^(3/2)) ~= n * Catalan numbers = n * (C(2n, n) - C(2n, n - 1)),"
"class Solution(object):
    def kthGrammar(self, N, K):
        def bitCount(n):
            result = 0
            while n:
                n &= n - 1
                result += 1
            return result

        return bitCount(K-1) % 2
",# Time:  O(logn) = O(1) because n is 32-bit integer
"class Solution(object):
    def buildTree(self, preorder, inorder):
        lookup = {}
        for i, num in enumerate(inorder):
            lookup[num] = i
        return self.buildTreeRecu(lookup, preorder, inorder, 0, 0, len(inorder))

    def buildTreeRecu(self, lookup, preorder, inorder, pre_start, in_start, in_end):
        if in_start == in_end:
            return None
        node = TreeNode(preorder[pre_start])
        i = lookup[preorder[pre_start]]
        node.left = self.buildTreeRecu(lookup, preorder, inorder, pre_start + 1, in_start, i)
        node.right = self.buildTreeRecu(lookup, preorder, inorder, pre_start + 1 + i - in_start, i + 1, in_end)
        return node

",# Time:  O(n)
"class Solution2(object):
    def buildTree(self, preorder, inorder):
        preorder_iterator = iter(preorder)
        inorder_lookup = {n: i for i, n in enumerate(inorder)}
        
        def helper(start, end):
            if start > end:
                return None
            
            root_val = next(preorder_iterator)
            root = TreeNode(root_val)
            idx = inorder_lookup[root_val]
            root.left = helper(start, idx-1)
            root.right = helper(idx+1, end)
            return root

        return helper(0, len(inorder)-1)",# time: O(n)
"class Solution(object):
    def nextBeautifulNumber(self, n):
        candidates = [     1,     22,    122,    212,    221,    333  , 1333,   3133,   3313,   3331,
                        4444,  14444,  22333,  23233,  23323,  23332,  32233,  32323,  32332,  33223,
                       33232,  33322,  41444,  44144,  44414,  44441,  55555, 122333, 123233, 123323,
                      123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233,
                      213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332,
                      232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444,
                      244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233,
                      321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312,
                      323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321,
                      333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442,
                      444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444]
        return candidates[bisect.bisect_right(candidates, n)]

",# Time:  O(logc) = O(1)
"class Solution2(object):
    def nextBeautifulNumber(self, n):
        def next_permutation(nums, begin, end):
            def reverse(nums, begin, end):
                left, right = begin, end-1
                while left < right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 1
                    right -= 1

            k, l = begin-1, begin
            for i in reversed(range(begin, end-1)):
                if nums[i] < nums[i+1]:
                    k = i
                    break
            else:
                reverse(nums, begin, end)
                return False
            for i in reversed(range(k+1, end)):
                if nums[i] > nums[k]:
                    l = i
                    break
            nums[k], nums[l] = nums[l], nums[k]
            reverse(nums, k+1, end)
            return True

        balanced = [1,
                    22,
                    122, 333,
                    1333, 4444,
                    14444, 22333, 55555,
                    122333, 155555, 224444, 666666]
        s = list(str(n))
        result = 1224444
        for x in balanced:
            x = list(str(x))
            if len(x) < len(s):
                continue
            if len(x) > len(s):
                result = min(result, int("""".join(x)))
                continue
            while True:
                if x > s:
                    result = min(result, int("""".join(x)))
                if not next_permutation(x, 0, len(x)): 
                    break
        return result

","# Time:  O(l * c) = O(1), c is the count of all balanced's permutations, l is the max length of permutations"
"class Solution3(object):
    def nextBeautifulNumber(self, n):
        balanced = [1,
                    22,
                    122, 333,
                    1333, 4444,
                    14444, 22333, 55555,
                    122333, 155555, 224444, 666666]
        s = tuple(str(n))
        result = 1224444
        for x in balanced:
            x = tuple(str(x))
            if len(x) < len(s):
                continue
            if len(x) > len(s):
                result = min(result, int("""".join(x)))
                continue
            for perm in itertools.permutations(x): 
                if perm > s:
                    result = min(result, int("""".join(perm)))
        return result","# Time:  O(l * c) = O(1), c is the count of all balanced's permutations, l is the max length of permutations"
"class Solution(object):
    def countCombinations(self, pieces, positions):
        directions = {""rook"": [(0, 1), (1, 0), (0, -1), (-1, 0)],
                      ""bishop"": [(1, 1), (1, -1), (-1, 1), (-1, -1)],
                      ""queen"" : [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]}
        all_mask = 2**7-1 
        def backtracking(pieces, positions, i, lookup):
            if i == len(pieces):
                return 1
            result = 0
            r, c = positions[i]
            r, c = r-1, c-1
            mask = all_mask
            if not (lookup[r][c]&mask):
                lookup[r][c] += mask 
                result += backtracking(pieces, positions, i+1, lookup)
                lookup[r][c] -= mask          
            for dr, dc in directions[pieces[i]]:
                bit, nr, nc = 1, r+dr, c+dc
                mask = all_mask 
                while 0 <= nr < 8 and 0 <= nc < 8 and not (lookup[nr][nc]&bit):
                    lookup[nr][nc] += bit
                    mask -= bit
                    if not (lookup[nr][nc]&mask): 
                        lookup[nr][nc] += mask
                        result += backtracking(pieces, positions, i+1, lookup)
                        lookup[nr][nc] -= mask
                    bit, nr, nc = bit<<1, nr+dr, nc+dc
                while bit>>1:
                    bit, nr, nc = bit>>1, nr-dr, nc-dc
                    lookup[nr][nc] -= bit
            return result

        return backtracking(pieces, positions, 0, [[0]*8 for _ in range(8)])","# Time:  O(n^p) = O(1), n is the max number of possible moves for each piece, and n is at most 29"
"class Solution(object):
    def countQuadruplets(self, nums):
        result = 0
        lookup = collections.defaultdict(int)
        lookup[nums[-1]] = 1
        for c in reversed(range(2, len(nums)-1)):
            for b in range(1, c):
                for a in range(b):
                    if nums[a]+nums[b]+nums[c] in lookup:
                        result += lookup[nums[a]+nums[b]+nums[c]]
            lookup[nums[c]] += 1
        return result


import collections
",# Time:  O(n^3)
"class Solution2(object):
    def countQuadruplets(self, nums):
        lookup = collections.defaultdict(list)
        for d in range(3, len(nums)):
            for c in range(2, d):
                lookup[nums[d]-nums[c]].append(c)
        return sum(sum(b < c for c in lookup[nums[a]+nums[b]]) for b in range(1, len(nums)-2) for a in range(b))",# Time:  O(n^3)
"class Solution(object):
    def findWords(self, words):
        rows = [set(['q', 'w', 'e', 'r', 't', 'y','u', 'i', 'o', 'p']),
                set(['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l']),
                set(['z', 'x', 'c', 'v', 'b' ,'n', 'm'])]

        result = []
        for word in words:
            k = 0
            for i in range(len(rows)):
                if word[0].lower() in rows[i]:
                    k = i
                    break
            for c in word:
                if c.lower() not in rows[k]:
                    break
            else:
                result.append(word)
        return result

",# Time:  O(n)
"class Solution2(object):
    def findWords(self, words):
        keyboard_rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']
        single_row_words = []
        for word in words:
            for row in keyboard_rows:
                if all(letter in row for letter in word.lower()):
                    single_row_words.append(word)
        return single_row_words
",# Time:  O(n)
"class Solution(object):
    def minimumScore(self, nums, edges):
        def is_ancestor(a, b):
            return left[a] <= left[b] and right[b] <= right[a]

        def iter_dfs():
            cnt = 0
            left = [0]*len(nums)
            right = [0]*len(nums)
            stk = [(1, (0, -1))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p = args
                    left[u] = cnt
                    cnt += 1
                    stk.append((2, (u, p)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, (v, u)))
                elif step == 2:
                    u, p = args
                    for v in adj[u]:
                        if v == p:
                            continue
                        nums[u] ^= nums[v]
                    right[u] = cnt
            return left, right
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        left, right = iter_dfs()
        result = float(""inf"")
        for i in range(1, len(nums)):
            for j in range(i+1, len(nums)):
                if is_ancestor(i, j):
                    a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j]
                elif is_ancestor(j, i):
                    a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i]
                else:
                    a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j]
                result = min(result, max(a, b, c)-min(a, b, c))
        return result

",# Time:  O(n^2)
"class Solution2(object):
    def minimumScore(self, nums, edges):
        def is_ancestor(a, b):
            return left[a] <= left[b] and right[b] <= right[a]

        def dfs(u, p):
            left[u] = cnt[0]
            cnt[0] += 1
            for v in adj[u]:
                if v == p:
                    continue
                dfs(v, u)
                nums[u] ^= nums[v]
            right[u] = cnt[0]
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        cnt = [0]
        left = [0]*len(nums)
        right = [0]*len(nums)
        dfs(0, -1)
        result = float(""inf"")
        for i in range(1, len(nums)):
            for j in range(i+1, len(nums)):
                if is_ancestor(i, j):
                    a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j]
                elif is_ancestor(j, i):
                    a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i]
                else:
                    a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j]
                result = min(result, max(a, b, c)-min(a, b, c))
        return result
",# Time:  O(n^2)
"class Solution3(object):
    def minimumScore(self, nums, edges):
        def dfs(u, p, result):
            total = nums[u]
            for v in adj[u]:
                if v == p:
                    continue
                total ^= dfs(v, u, result)
            result.append(total)
            return total
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        total = reduce(lambda x, y: x^y, nums)
        result = float(""inf"")
        for u, v in edges: 
            left = []
            dfs(u, v, left)
            right = []
            dfs(v, u, right)
            for candidates in (left, right):
                total2 = candidates.pop()
                for x in candidates:
                    a, b, c = total^total2, x, total2^x
                    result = min(result, max(a, b, c)-min(a, b, c))
        return result
",# Time:  O(n^2)
"class Solution4(object):
    def minimumScore(self, nums, edges):
        def iter_dfs(nums, adj, u, p):
            result = []
            stk = [(1, (u, p, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    new_rets = []
                    stk.append((2, (u, new_rets, ret)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_rets.append([0])
                        stk.append((1, (v, u, new_rets[-1])))
                elif step == 2:
                    u, new_rets, ret = args
                    ret[0] = nums[u]
                    for x in new_rets:
                        ret[0] ^= x[0]
                    result.append(ret[0])
            return result
                
        adj = [[] for _ in range(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        total = reduce(lambda x, y: x^y, nums)
        result = float(""inf"")
        for u, v in edges: 
            for candidates in (iter_dfs(nums, adj, u, v), iter_dfs(nums, adj, v, u)):
                total2 = candidates.pop()
                for x in candidates:
                    a, b, c = total^total2, x, total2^x
                    result = min(result, max(a, b, c)-min(a, b, c))
        return result",# Time:  O(n^2)
"class Solution(object):
    def __init__(self):
        self.q_ = Queue()

    def push(self, x):
        self.q_.push(x)
        for _ in range(self.q_.size() - 1):
            self.q_.push(self.q_.pop())

    def pop(self):
        self.q_.pop()

    def top(self):
        return self.q_.peek()

    def empty(self):
        return self.q_.empty()

","# Time: push: O(n), pop: O(1), top: O(1)"
"class Solution2(object):
    def __init__(self):
        self.q_ = Queue()
        self.top_ = None

    def push(self, x):
        self.q_.push(x)
        self.top_ = x

    def pop(self):
        for _ in range(self.q_.size() - 1):
            self.top_ = self.q_.pop()
            self.q_.push(self.top_)
        return self.q_.pop() 

    def top(self):
        return self.top_

    def empty(self):
        return self.q_.empty()
","# Time: push: O(1), pop: O(n), top: O(1)"
"class Solution(object):
    def shortestMatchingSubstring(self, s, p):
        INF = float(""inf"")
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        def KMP(text, pattern):
            if not pattern:
                for i in range(len(text)+1):
                    yield i
                return
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j+1 > 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    yield i-j
                    j = prefix[j]
        
        a, b, c = p.split('*')
        n = len(s)
        la, lb, lc = len(a), len(b), len(c)
        result = INF
        j = k = 0
        jt = KMP(s, b)
        kt = KMP(s, c)
        for i in KMP(s, a):
            while j != -1 and j < i+la:
                j = next(jt, -1)
            if j == -1:
                break
            while k != -1 and k < j+lb:
                k = next(kt, -1)
            if k == -1:
                break
            result = min(result, (k+lc)-i)
        return result if result != INF else -1 
    
    
",# Time:  O(n + m)
"class Solution2(object):
    def shortestMatchingSubstring(self, s, p):
        INF = float(""inf"")
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j+1 > 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        a, b, c = p.split('*')
        n = len(s)
        la, lb, lc = len(a), len(b), len(c)
        prefix1 = getPrefix(a+
        prefix2 = getPrefix(b+
        prefix3 = getPrefix(c+
        result = INF
        i = j = k = 0
        while i+lb+lc < n:
            while i < n and prefix1[la+1+i]+1 != la:
                i += 1
            if i == n:
                break
            while j < n and not (j >= i+lb and prefix2[lb+1+j]+1 == lb):
                j += 1
            if j == n:
                break
            while k < n and not (k >= j+lc and prefix3[lc+1+k]+1 == lc):
                k += 1
            if k == n:
                break
            result = min(result, k-(i-la))
            i += 1
        return result if result != INF else -1",# Time:  O(n + m)
"class Solution(object):
    def maximumStrongPairXor(self, nums):
        class Trie(object):
            def __init__(self, bit_length):
                self.__nodes = []
                self.__cnts = []
                self.__new_node()
                self.__bit_length = bit_length
            
            def __new_node(self):
                self.__nodes.append([-1]*2)
                self.__cnts.append(0)
                return len(self.__nodes)-1

            def update(self, num, d):
                curr = 0
                for i in reversed(range(self.__bit_length)):
                    x = num>>i
                    if self.__nodes[curr][x&1] == -1:
                        self.__nodes[curr][x&1] = self.__new_node()
                    curr = self.__nodes[curr][x&1]
                    self.__cnts[curr] += d
                        
            def query(self, num):
                result = curr = 0
                for i in reversed(range(self.__bit_length)):
                    result <<= 1
                    x = num>>i
                    if self.__nodes[curr][1^(x&1)] != -1 and self.__cnts[self.__nodes[curr][1^(x&1)]]:
                        curr = self.__nodes[curr][1^(x&1)]
                        result |= 1
                    else:
                        curr = self.__nodes[curr][x&1]
                return result
    
        nums.sort()
        trie = Trie(nums[-1].bit_length())
        result = j = 0
        for i, num in enumerate(nums):
            trie.update(num, +1)
            while not (nums[i] <= 2*nums[j]) :
                trie.update(nums[j], -1)
                j += 1
            result = max(result, trie.query(num))
        return result

","# Time:  O(nlogn + nlogr) = O(nlogr), r = max(nums)"
"class Solution2(object):
    def maximumStrongPairXor(self, nums):
        class Trie(object):
            def __init__(self, bit_length):
                self.__nodes = []
                self.__mins = []
                self.__maxs = []
                self.__new_node()
                self.__bit_length = bit_length
            
            def __new_node(self):
                self.__nodes.append([-1]*2)
                self.__mins.append(float(""inf""))
                self.__maxs.append(float(""-inf""))
                return len(self.__nodes)-1

            def insert(self, num):
                curr = 0
                for i in reversed(range(self.__bit_length)):
                    x = num>>i
                    if self.__nodes[curr][x&1] == -1:
                        self.__nodes[curr][x&1] = self.__new_node()
                    curr = self.__nodes[curr][x&1]
                    self.__mins[curr] = min(self.__mins[curr], num)
                    self.__maxs[curr] = max(self.__maxs[curr], num)
                        
            def query(self, num):
                result = curr = 0
                for i in reversed(range(self.__bit_length)):
                    result <<= 1
                    x = num>>i
                    y = (result|1)^x
                    assert(x != y) 
                    if (self.__nodes[curr][y&1] != -1 and
                        ((x > y and num <= 2*self.__maxs[self.__nodes[curr][y&1]]) or
                         (x < y and self.__mins[self.__nodes[curr][y&1]] <= 2*num))):
                        result |= 1
                        curr = self.__nodes[curr][y&1]
                    else:
                        curr = self.__nodes[curr][1^(y&1)]
                return result
    
        trie = Trie(max(nums).bit_length())
        result = 0
        for num in nums:
            trie.insert(num)
            result = max(result, trie.query(num))
        return result

","# Time:  O(nlogr), r = max(nums)"
"class Solution3(object):
    def maximumStrongPairXor(self, nums):
        result = 0
        for i in reversed(range(max(nums).bit_length())):
            prefix_min, prefix_max = {}, {}
            for x in nums:
                y = x>>i
                if y not in prefix_min:
                    prefix_min[y] = prefix_max[y] = x
                prefix_min[y] = min(prefix_min[y], x)
                prefix_max[y] = max(prefix_max[y], x)
            result <<= 1
            for x in prefix_min.keys():
                y = (result|1)^x
                assert(x != y)
                if y in prefix_max and prefix_min[max(x, y)] <= 2*prefix_max[min(x, y)]:
                    result |= 1
                    break
        return result

","# Time:  O(nlogr), r = max(nums)"
"class Solution4(object):
    def maximumStrongPairXor(self, nums):
        return max(nums[i]^nums[j] for i in range(len(nums)) for j in range(i, len(nums)) if abs(nums[i]-nums[j]) <= min(nums[i], nums[j]))",# Time:  O(n^2)
"class Solution(object):
    def checkValidGrid(self, grid):
        if grid[0][0]:
            return False
        lookup = [None]*(len(grid)*len(grid[0]))
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                lookup[grid[i][j]] = (i, j)
        return all(sorted([abs(lookup[i+1][0]-lookup[i][0]), abs(lookup[i+1][1]-lookup[i][1])]) == [1, 2] for i in range(len(lookup)-1))


",# Time:  O(m * n)
"class Solution2(object):
    def checkValidGrid(self, grid):
        lookup = {grid[i][j]:(i, j) for i in range(len(grid)) for j in range(len(grid[0]))}
        return grid[0][0] == 0 and all(sorted([abs(lookup[i+1][0]-lookup[i][0]), abs(lookup[i+1][1]-lookup[i][1])]) == [1, 2] for i in range(len(lookup)-1))",# Time:  O(m * n)
"class Solution(object):
    def splitNum(self, num):
        sorted_num = """".join(sorted(str(num)))
        return int(sorted_num[::2])+int(sorted_num[1::2])","# Time:  O(mlogm), m = O(logn)"
"class Solution(object):
    def makeLargestSpecial(self, S):
        result = []
        anchor = count = 0
        for i, v in enumerate(S):
            count += 1 if v == '1' else -1
            if count == 0:
                result.append(""1{}0"".format(self.makeLargestSpecial(S[anchor+1:i])))
                anchor = i+1
        result.sort(reverse = True)
        return """".join(result)
",# Time:  f(n) = k * f(n/k) + n/k * klogk <= O(logn * nlogk) <= O(n^2)
"class Solution(object):
    def minAreaFreeRect(self, points):
        points.sort()
        points = [complex(*z) for z in points]
        lookup = collections.defaultdict(list)
        for P, Q in itertools.combinations(points, 2):
            lookup[P-Q].append((P+Q) / 2)

        result = float(""inf"")
        for A, candidates in lookup.items():
            for P, Q in itertools.combinations(candidates, 2):
                if A.real * (P-Q).real + A.imag * (P-Q).imag == 0.0:
                    result = min(result, abs(A) * abs(P-Q))
        return result if result < float(""inf"") else 0.0",# Time:  O(n^2) ~ O(n^3)
"class Solution(object):
    def maxSumSubmatrix(self, matrix, k):
        if not matrix:
            return 0

        m = min(len(matrix), len(matrix[0]))
        n = max(len(matrix), len(matrix[0]))
        result = float(""-inf"")

        for i in range(m):
            sums = [0] * n
            for j in range(i, m):
                for l in range(n):
                    sums[l] += matrix[j][l] if m == len(matrix) else matrix[l][j]

                accu_sum_set, accu_sum = [0], 0
                for sum in sums:
                    accu_sum += sum
                    it = bisect_left(accu_sum_set, accu_sum - k) 
                    if it != len(accu_sum_set):
                        result = max(result, accu_sum - accu_sum_set[it])
                    insort(accu_sum_set, accu_sum) 

        return result

","# Time:  O(min(m, n)^2 * max(m, n) * log(max(m, n)))"
"class Solution_TLE(object):
    def maxSumSubmatrix(self, matrix, k):
        class BST(object): 
            def __init__(self, val):
                self.val = val
                self.left = None
                self.right = None

            def insert(self, val): 
                curr = self
                while curr:
                    if curr.val >= val:
                        if curr.left:
                            curr = curr.left
                        else:
                            curr.left = BST(val)
                            return
                    else:
                        if curr.right:
                            curr = curr.right
                        else:
                            curr.right = BST(val)
                            return

            def lower_bound(self, val): 
                result, curr = None, self
                while curr:
                    if curr.val >= val:
                        result, curr = curr, curr.left
                    else:
                        curr = curr.right
                return result


        if not matrix:
            return 0

        m = min(len(matrix), len(matrix[0]))
        n = max(len(matrix), len(matrix[0]))
        result = float(""-inf"")

        for i in range(m):
            sums = [0] * n
            for j in range(i, m):
                for l in range(n):
                    sums[l] += matrix[j][l] if m == len(matrix) else matrix[l][j]

                accu_sum_set = BST(0)
                accu_sum = 0
                for sum in sums:
                    accu_sum += sum
                    node = accu_sum_set.lower_bound(accu_sum - k)
                    if node:
                        result = max(result, accu_sum - node.val)
                    accu_sum_set.insert(accu_sum)

        return result
","# Time:  O(min(m, n)^2 * max(m, n) * log(max(m, n))) ~ O(min(m, n)^2 * max(m, n)^2)"
"class Solution(object):
    def nextGreaterElement(self, n):
        digits = list(map(int, list(str(n))))
        k, l = -1, 0
        for i in range(len(digits) - 1):
            if digits[i] < digits[i + 1]:
                k = i

        if k == -1:
            digits.reverse()
            return -1

        for i in range(k + 1, len(digits)):
            if digits[i] > digits[k]:
                l = i

        digits[k], digits[l] = digits[l], digits[k]
        digits[k + 1:] = digits[:k:-1]
        result = int("""".join(map(str, digits)))
        return -1 if result >= 0x7FFFFFFF else result
",# Time:  O(logn) = O(1)
"class Solution(object):
    def findRedundantConnection(self, edges):
        union_find = UnionFind(len(edges)+1)
        for edge in edges:
            if not union_find.union_set(*edge):
                return edge
        return []","# Time:  O(nlog*n) ~= O(n), n is the length of the positions"
"class Solution(object):
    def latestDayToCross(self, row, col, cells):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def index(n, i, j):
            return i*n+j

        start, end = row*col, row*col+1
        uf = UnionFind(row*col+2)
        lookup = [[False]*col for _ in range(row)]
        for i in reversed(range(len(cells))):
            r, c = cells[i]
            r, c = r-1, c-1
            for dr, dc in directions:
                nr, nc = r+dr, c+dc
                if not (0 <= nr < row and 0 <= nc < col and lookup[nr][nc]):
                    continue
                uf.union_set(index(col, r, c), index(col, nr, nc))
            if r == 0:
                uf.union_set(start, index(col, r, c))
            if r == row-1:
                uf.union_set(end, index(col, r, c))
            if uf.find_set(start) == uf.find_set(end):
                return i
            lookup[r][c] = True
        return -1",# Time:  O(m * n + c *  α(c)) = O(m * n)
"class Solution(object):
    def topKFrequent(self, words, k):
        counts = collections.Counter(words)
        p = []
        for key, val in counts.items():
            p.append((-val, key))
        self.kthElement(p, k-1)

        result = []
        sorted_p = sorted(p[:k])
        for i in range(k):
            result.append(sorted_p[i][1])
        return result

    def kthElement(self, nums, k): 
        def PartitionAroundPivot(left, right, pivot_idx, nums):
            pivot_value = nums[pivot_idx]
            new_pivot_idx = left
            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
            for i in range(left, right):
                if nums[i] < pivot_value:
                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                    new_pivot_idx += 1

            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
            return new_pivot_idx

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = randint(left, right)
            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)
            if new_pivot_idx == k:
                return
            elif new_pivot_idx > k:
                right = new_pivot_idx - 1
            else: 
                left = new_pivot_idx + 1

",# Time:  O(n + klogk) on average
"class Solution2(object):
    def topKFrequent(self, words, k):
        class MinHeapObj(object):
            def __init__(self,val):
                self.val = val
            def __lt__(self,other):
                return self.val[1] > other.val[1] if self.val[0] == other.val[0] else \
                       self.val < other.val
            def __eq__(self,other):
                return self.val == other.val
            def __str__(self):
                return str(self.val)

        counts = collections.Counter(words)
        min_heap = []
        for word, count in counts.items():
            heapq.heappush(min_heap, MinHeapObj((count, word)))
            if len(min_heap) == k+1:
                heapq.heappop(min_heap)
        result = []
        while min_heap:
            result.append(heapq.heappop(min_heap).val[1])
        return result[::-1]

",# Time:  O(nlogk)
"class Solution3(object):
    def topKFrequent(self, words, k):
        counts = collections.Counter(words)
        buckets = [[] for _ in range(len(words)+1)]
        for word, count in counts.items():
            buckets[count].append(word)
        pairs = []
        for i in reversed(range(len(words))):
            for word in buckets[i]:
                pairs.append((-i, word))
            if len(pairs) >= k:
                break
        pairs.sort()
        return [pair[1] for pair in pairs[:k]]

",# Time:  O(n + klogk) ~ O(n + nlogn)
"class Solution4(object):
    def topKFrequent(self, words, k):
        counter = Counter(words)
        candidates = list(counter.keys())
        candidates.sort(key=lambda w: (-counter[w], w))
        return candidates[:k]",# time: O(nlogn)
"class Solution(object):
    def copyRandomList(self, head):
        current = head
        while current:
            copied = Node(current.val)
            copied.next = current.__next__
            current.next = copied
            current = copied.__next__

        current = head
        while current:
            if current.random:
                current.next.random = current.random.__next__
            current = current.next.__next__

        dummy = Node(0)
        copied_current, current = dummy, head
        while current:
            copied_current.next = current.__next__
            current.next = current.next.__next__
            copied_current, current = copied_current.__next__, current.__next__
        return dummy.__next__
",# Time:  O(n)
"class Solution2(object):
    def copyRandomList(self, head):
        dummy = Node(0)
        current, prev, copies = head, dummy, {}

        while current:
            copied = Node(current.val)
            copies[current] = copied
            prev.next = copied
            prev, current = prev.__next__, current.__next__

        current = head
        while current:
            if current.random:
                copies[current].random = copies[current.random]
            current = current.__next__

        return dummy.__next__
",# Time:  O(n)
"class Solution3(object):
    def copyRandomList(self, head):
        clone = defaultdict(lambda: Node(0))
        clone[None] = None
        cur = head

        while cur:
            clone[cur].val = cur.val
            clone[cur].next = clone[cur.__next__]
            clone[cur].random = clone[cur.random]
            cur = cur.__next__

        return clone[head]",# time: O(n)
"class Solution(object):
    def __init__(self):
        self.__cache = []

    def rand10(self):
        def generate(cache):
            n = 32
            curr = sum((rand7()-1) * (7**i) for i in range(n))
            rang = 7**n
            while curr < rang//10*10:
                cache.append(curr%10+1)
                curr /= 10
                rang /= 10

        while not self.__cache:
            generate(self.__cache)
        return self.__cache.pop()

","# Time:  O(1.189), counted by statistics, limit would be O(log10/log7) = O(1.183)"
"class Solution2(object):
    def rand10(self):
        while True:
            x = (rand7()-1)*7 + (rand7()-1)
            if x < 40:
                return x%10 + 1
",# Time:  O(2 * (1 + (9/49) + (9/49)^2 + ...)) = O(2/(1-(9/49)) = O(2.45)
"class Solution(object):
    def matrixRankTransform(self, matrix):
        def cb(x, y, z):
            new_rank[x] = max(new_rank[y], new_rank[z])

        lookup = collections.defaultdict(list)
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                lookup[matrix[i][j]].append([i, j])
        rank = [0]*(len(matrix)+len(matrix[0]))
        for x in sorted(lookup):
            new_rank = rank[:]
            union_find = UnionFind(len(matrix)+len(matrix[0]), cb)
            for i, j in lookup[x]:
                union_find.union_set(i, j+len(matrix))
            for i, j in lookup[x]:
                matrix[i][j] = rank[i] = rank[j+len(matrix)] = new_rank[union_find.find_set(i)]+1
        return matrix",# Time:  O(m * n * log(m * n) + m * n * α(m * n)) = O(m * n * log(m * n))
"class Solution(object):
    def suggestedProducts(self, products, searchWord):
        trie = TrieNode()
        for i in range(len(products)):
            trie.insert(products, i)
        result = [[] for _ in range(len(searchWord))]
        for i, c in enumerate(searchWord):
            if c not in trie.leaves:
                break
            trie = trie.leaves[c]
            result[i] = [products[x] for x in trie.infos]
        return result

","# Time:  ctor: O(n * l), n is the number of products"
"class Solution2(object):
    def suggestedProducts(self, products, searchWord):
        products.sort()
        trie = TrieNode2()
        for i in range(len(products)):
            trie.insert(products, i)
        result = [[] for _ in range(len(searchWord))]
        for i, c in enumerate(searchWord):
            if c not in trie.leaves:
                break
            trie = trie.leaves[c]
            result[i] = [products[x] for x in trie.infos]
        return result

","# Time:  ctor: O(n * l * log(n * l)), n is the number of products"
"class Solution3(object):
    def suggestedProducts(self, products, searchWord):
        products.sort() 
        result = []
        prefix = """"
        for i, c in enumerate(searchWord): 
            prefix += c
            start = bisect.bisect_left(products, prefix) 
            new_products = []
            for j in range(start, len(products)): 
                if not (i < len(products[j]) and products[j][i] == c):
                    break
                new_products.append(products[j])
            products = new_products
            result.append(products[:3])
        return result","# Time:  ctor: O(n * l * log(n * l)), n is the number of products"
"class Solution(object):
    def wordsAbbreviation(self, dict):
        def isUnique(prefix, words):
            return sum(word.startswith(prefix) for word in words) == 1

        def toAbbr(prefix, word):
            abbr = prefix + str(len(word) - 1 - len(prefix)) + word[-1]
            return abbr if len(abbr) < len(word) else word

        abbr_to_word = collections.defaultdict(set)
        word_to_abbr = {}

        for word in dict:
            prefix = word[:1]
            abbr_to_word[toAbbr(prefix, word)].add(word)

        for abbr, conflicts in abbr_to_word.items():
            if len(conflicts) > 1:
                for word in conflicts:
                    for i in range(2, len(word)):
                        prefix = word[:i]
                        if isUnique(prefix, conflicts):
                            word_to_abbr[word] = toAbbr(prefix, word)
                            break
            else:
                word_to_abbr[conflicts.pop()] = abbr

        return [word_to_abbr[word] for word in dict]
",# Time:  O(n * l) ~ O(n^2 * l^2)
"class Solution(object):
    def reorderedPowerOf2(self, N):
        count = collections.Counter(str(N))
        return any(count == collections.Counter(str(1 << i))
                   for i in range(31))
",# Time:  O((logn)^2) = O(1) due to n is a 32-bit number
"class Solution(object):
    def selfDividingNumbers(self, left, right):
        def isDividingNumber(num):
            n = num
            while n > 0:
                n, r = divmod(n, 10)
                if r == 0 or (num%r) != 0:
                    return False
            return True
        
        return [num for num in range(left, right+1) if isDividingNumber(num)]

",# Time:  O(nlogr) = O(n)
"class Solution2(object):
    def selfDividingNumbers(self, left, right):
        return [num for num in range(left, right+1) \
                if not any(map(lambda x: int(x) == 0 or num%int(x) != 0, str(num)))]",# Time:  O(nlogr) = O(n)
"class Solution(object):
    def minimumPerimeter(self, neededApples):
        a, b, c, d = 4.0, 6.0, 2.0, float(-neededApples)
        p = (3*a*c-b**2)/(3*a**2) 
        q = (2*b**3-9*a*b*c+27*a**2*d)/(27*a**3) 
        assert((q/2)**2+(p/3)**3 > 0) 
        x = (-q/2 + ((q/2)**2+(p/3)**3)**0.5)**(1.0/3) + \
            (-q/2 - ((q/2)**2+(p/3)**3)**0.5)**(1.0/3)
        return 8*int(math.ceil(x - b/(3*a)))
    
    ",# Time:  O(1)
"class Solution2(object):
    def minimumPerimeter(self, neededApples):
        x = int((2*neededApples)**(1.0/3))
        x -= x%2
        assert((x-2)*(x-1)*x < 2*neededApples < (x+2)**3)
        x += 2
        if (x-2)*(x-1)*x < 2*neededApples:
            x += 2
        return 8*(x-2)//2

",# Time:  O(1)
"class Solution3(object):
    def minimumPerimeter(self, neededApples):
        def check(neededApples, x):
            return r*(2*r+1)*(2*r+2) >= neededApples

        left, right = 1, int((neededApples/4.0)**(1.0/3))
        while left <= right:
            mid = left + (right-left)//2
            if check(neededApples, mid):
                right = mid-1
            else:
                left = mid+1
        return 8*left",# Time:  O(logn)
"class Solution(object):
    def countBalancedPermutations(self, num):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def lazy_init(n):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)

        def nCr(n, k):
            lazy_init(n)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def factorial(n):
            lazy_init(n)
            return fact[n]

        def inv_factorial(n):
            lazy_init(n)
            return inv_fact[n]
    
        total = sum(ord(x)-ord('0') for x in num)
        if total%2:
            return 0
        total //= 2
        cnt = [0]*10
        for x in num:
            cnt[ord(x)-ord('0')] += 1
        even = len(num)//2
        dp = [[0]*(even+1) for _ in range(total+1)]
        dp[0][0] = 1
        for i, x in enumerate(cnt):
            if not x:
                continue
            for j in reversed(range(total+1)):
                for k in reversed(range(even+1)):
                    if not dp[j][k]:
                        continue
                    for c in range(1, x+1):
                        if j+c*i <= total and k+c <= even:
                            dp[j+c*i][k+c] = (dp[j+c*i][k+c]+dp[j][k]*nCr(x, c))%MOD
        return dp[total][even]*factorial(even)*factorial(len(num)-even)*reduce(lambda accu, x: (accu*x)%MOD, (inv_factorial(x) for x in cnt), 1)%MOD",# Time:  O(9 * (9 * n / 2) * (n / 2)) = O(n^2)
"class Solution(object):
    def maximumRequests(self, n, requests):
        for k in reversed(range(1, len(requests)+1)):
            for c in itertools.combinations(range(len(requests)), k):
                change = [0]*n
                for i in c:
                    change[requests[i][0]] -= 1
                    change[requests[i][1]] += 1
                if all(c == 0 for c in change):
                    return k 
        return 0
    
    
",# Time:  O((n + r) * 2^r)
"class Solution2(object):
    def maximumRequests(self, n, requests):
        def evaluate(n, requests, mask):
            change = [0]*n
            base, count = 1, 0
            for i in range(len(requests)):
                if base & mask:
                    change[requests[i][0]] -= 1
                    change[requests[i][1]] += 1
                    count += 1
                base <<= 1
            return count if all(c == 0 for c in change) else 0

        return max(evaluate(n, requests, i) for i in range(1 << len(requests)))",# Time:  O((n + r) * 2^r)
"class Solution(object):
    def gcdSort(self, nums):
        def modified_sieve_of_eratosthenes(n, lookup, uf): 
            if n < 2:
                return
            is_prime = [True]*(n+1)
            for i in range(2, len(is_prime)):
                if not is_prime[i]:
                    continue
                for j in range(i+i, len(is_prime), i):
                    is_prime[j] = False
                    if j in lookup: 
                        uf.union_set(i-1, j-1)

        max_num = max(nums)
        uf = UnionFind(max_num)
        modified_sieve_of_eratosthenes(max_num, set(nums), uf)
        return all(uf.find_set(a-1) == uf.find_set(b-1) for a, b in zip(nums, sorted(nums)))","# Time:  O(nlogn + n * α(n) + m * log(logm)) ~= O(nlogn + m), m is the max of nums"
"class Solution(object):
    def colorTheGrid(self, m, n):
        MOD = 10**9+7
        def backtracking(mask1, mask2, basis, result): 
            if not basis:
                result.append(mask2)
                return
            for i in range(3):
                if (mask1 == -1 or mask1//basis%3 != i) and (mask2 == -1 or mask2//(basis*3)%3 != i):
                    backtracking(mask1, mask2+i*basis if mask2 != -1 else i*basis, basis//3, result)

        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def normalize(basis, mask):
            norm = {}
            result = 0
            while basis:
                x = mask//basis%3
                if x not in norm:
                    norm[x] = len(norm)
                result += norm[x]*basis
                basis //= 3
            return result

        if m > n:
            m, n = n, m
        basis = 3**(m-1)
        masks = []
        backtracking(-1, -1, basis, masks) 
        assert(len(masks) == 3 * 2**(m-1))
        lookup = {mask:normalize(basis, mask) for mask in masks} 
        normalized_mask_cnt = collections.Counter(lookup[mask] for mask in masks)
        assert(len(normalized_mask_cnt) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1)) 
        adj = collections.defaultdict(list)
        for mask in normalized_mask_cnt.keys(): 
            backtracking(mask, -1, basis, adj[mask])
        normalized_adj = collections.defaultdict(lambda:collections.defaultdict(int))
        for mask1, masks2 in adj.items():
            for mask2 in masks2:
                normalized_adj[mask1][lookup[mask2]] = (normalized_adj[mask1][lookup[mask2]]+1)%MOD
        assert(2*3**m // 3 // 2 // 3 <= sum(len(v) for v in normalized_adj.values()) <= 2*3**m // 3 // 2)
        return reduce(lambda x,y: (x+y)%MOD,
                      matrix_mult([list(normalized_mask_cnt.values())],
                                   matrix_expo([[normalized_adj[mask1][mask2]
                                                 for mask2 in normalized_mask_cnt.keys()] 
                                                 for mask1 in normalized_mask_cnt.keys()], n-1))[0],
                      0) 

",# Time:  O(m * 2^m + 3^m + 2^(3 * m) * logn) = O(2^(3 * m) * logn)
"class Solution2(object):
    def colorTheGrid(self, m, n):
        MOD = 10**9+7
        def find_masks(m, basis): 
            masks = [0]
            for c in range(m):
                new_masks = []
                for mask in masks:
                    choices = {0, 1, 2}
                    if c > 0:
                        choices.discard(mask//basis) 
                    for x in choices:
                        new_masks.append((x*basis)+(mask//3)) 
                masks = new_masks
            return masks

        def find_adj(m, basis, dp):
            adj = collections.defaultdict(list)
            for mask in dp.keys(): 
                adj[mask].append(mask)
            for c in range(m):
                assert(sum(len(v) for v in adj.values()) == (3**c * 2**(m-(c-1)) if c >= 1 else 3 * 2**(m-1)) // 3 // (2 if m >= 2 else 1)) 
                new_adj = collections.defaultdict(list)
                for mask1, mask2s in adj.items():
                    for mask in mask2s:
                        choices = {0, 1, 2}
                        choices.discard(mask%3) 
                        if c > 0:
                            choices.discard(mask//basis) 
                        for x in choices:
                            new_adj[mask1].append((x*basis)+(mask//3)) 
                adj = new_adj
            assert(sum(3**c * 2**(m-(c-1)) if c >= 1 else 3 * 2**(m-1) for c in range(m)) == 4*3**m-9*2**(m-1))
            return adj
 
        def normalize(basis, mask):
            norm = {}
            result = 0
            while basis:
                x = mask//basis%3
                if x not in norm:
                    norm[x] = len(norm)
                result += norm[x]*basis
                basis //= 3
            return result

        if m > n:
            m, n = n, m
        basis = 3**(m-1)
        masks = find_masks(m, basis) 
        assert(len(masks) == 3 * 2**(m-1))
        lookup = {mask:normalize(basis, mask) for mask in masks} 
        dp = collections.Counter(lookup[mask] for mask in masks) 
        adj = find_adj(m, basis, dp) 
        normalized_adj = collections.defaultdict(lambda:collections.defaultdict(int))
        for mask1, mask2s in adj.items():
            for mask2 in mask2s:
                normalized_adj[lookup[mask1]][lookup[mask2]] = (normalized_adj[lookup[mask1]][lookup[mask2]]+1)%MOD
        assert(2*3**m // 3 // 2 // 3 <= sum(len(v) for v in normalized_adj.values()) <= 2*3**m // 3 // 2)
        for _ in range(n-1): 
            assert(len(dp) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1)) 
            new_dp = collections.Counter()
            for mask, v in dp.items():
                for new_mask, cnt in normalized_adj[mask].items():
                    new_dp[lookup[new_mask]] = (new_dp[lookup[new_mask]] + v*cnt) % MOD
            dp = new_dp
        return reduce(lambda x,y: (x+y)%MOD, iter(dp.values()), 0) 

",# Time:  O(n * 3^m)
"class Solution3(object):
    def colorTheGrid(self, m, n):
        MOD = 10**9+7
        def normalize(basis, mask, lookup): 
            if mask not in lookup[basis]:
                norm = {}
                result, b = 0, basis
                while b:
                    x = mask//b%3
                    if x not in norm:
                        norm[x] = len(norm)
                    result += norm[x]*b
                    b //= 3
                lookup[basis][mask] = result
            return lookup[basis][mask]

        if m > n:
            m, n = n, m
        basis = b = 3**(m-1)
        lookup = collections.defaultdict(dict)
        dp = collections.Counter({0: 1})
        for idx in range(m*n):
            r, c = divmod(idx, m)
            assert(r != 0 or c != 0 or len(dp) == 1)
            assert(r != 0 or c == 0 or len(dp) == 3*2**(c-1) // 3 // (2 if c >= 2 else 1)) 
            assert(r == 0 or c != 0 or len(dp) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1)) 
            assert(r == 0 or c == 0 or len(dp) == (1 if m == 1 else 2 if m == 2 else 3*3 * 2**(m-2) // 3 // 2)) 
            new_dp = collections.Counter()
            for mask, v in dp.items():
                choices = {0, 1, 2}
                if r > 0:
                    choices.discard(mask%3) 
                if c > 0:
                    choices.discard(mask//basis) 
                for x in choices:
                    new_mask = normalize(basis//b, ((x*basis)+(mask//3))//b, lookup)*b 
                    new_dp[new_mask] = (new_dp[new_mask]+v)%MOD
            if b > 1:
                b //= 3
            dp = new_dp
        return reduce(lambda x,y: (x+y)%MOD, iter(dp.values()), 0) ",# Time:  (m * n grids) * (O(3*3*2^(m-2)) possible states per grid) = O(n * m * 2^m)
"class Solution(object):
    def countPrimes(self, n):
        if n <= 2:
            return 0

        is_prime = [True]*(n//2)
        cnt = len(is_prime)
        for i in range(3, n, 2):
            if i * i >= n:
                break
            if not is_prime[i//2]:
                continue
            for j in range(i*i, n, 2*i):
                if not is_prime[j//2]:
                    continue
                cnt -= 1
                is_prime[j//2] = False

        return cnt

","# Time:  O(n/2 + n/3 + ... + n/p) = O(nlog(logn)), see https://mathoverflow.net/questions/4596/on-the-series-1-2-1-3-1-5-1-7-1-11"
"class Solution_TLE(object):
    def countPrimes(self, n):
        def linear_sieve_of_eratosthenes(n):
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return primes
    
        return len(linear_sieve_of_eratosthenes(n-1))",# Time:  O(n)
"class Solution(object):
    def findDistance(self, root, p, q):
        def iter_dfs(root, p, q):
            result = 0
            dist = [-1]
            stk = [(1, [root, dist])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [-1], [-1]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    if node.val in (p, q):
                        if ret1[0] == ret2[0] == -1:
                            ret[0] = 0
                        else:
                            result = ret1[0]+1 if ret1[0] != -1 else ret2[0]+1
                    elif ret1[0] != -1 and ret2[0] != -1:
                        result = ret1[0]+ret2[0]+2
                    elif ret1[0] != -1:
                        ret[0] = ret1[0]+1
                    elif ret2[0] != -1:
                        ret[0] = ret2[0]+1
            return result
        
        return iter_dfs(root, p, q)
    
    ",# Time:  O(n)
"class Solution2(object):
    def findDistance(self, root, p, q):
        def dfs(node, p, q, result):
            if not node:
                return -1
            left = dfs(node.left, p, q, result)
            right = dfs(node.right, p, q, result)
            if node.val in (p, q):
                if left == right == -1:
                    return 0
                result[0] = left+1 if left != -1 else right+1
            if left != -1 and right != -1:
                result[0] = left+right+2
            elif left != -1:
                return left+1
            elif right != -1:
                return right+1
            return -1
        
        result = [0]
        dfs(root, p, q, result)
        return result[0]",# Time:  O(n)
"class Solution(object):
    def flatten(self, root):
        self.flattenRecu(root, None)

    def flattenRecu(self, root, list_head):
        if root:
            list_head = self.flattenRecu(root.right, list_head)
            list_head = self.flattenRecu(root.left, list_head)
            root.right = list_head
            root.left = None
            return root
        else:
            return list_head

",# Time:  O(n)
"class Solution2(object):
    list_head = None
    def flatten(self, root):
        if root:
            self.flatten(root.right)
            self.flatten(root.left)
            root.right = self.list_head
            root.left = None
            self.list_head = root",# Time:  O(n)
"class Solution(object):
    def countQuadruplets(self, nums):
        dp = [0]*len(nums) 
        result = 0
        for l in range(len(nums)):
            cnt = 0
            for j in range(l):
                if nums[j] < nums[l]:
                    cnt += 1
                    result += dp[j]
                elif nums[j] > nums[l]:
                    dp[j] += cnt
        return result


",# Time:  O(n^2)
"class Solution2(object):
    def countQuadruplets(self, nums):
        right = [[0]*(len(nums)+1) for _ in range(len(nums))]
        for j in range(len(nums)):
            for i in reversed(range(j+1, len(nums))):
                right[j][i] = right[j][i+1] + int(nums[i] > nums[j])
        result = 0
        for k in range(len(nums)):
            left = 0
            for j in range(k):
                if nums[k] < nums[j]:
                    result += left*right[j][k+1]
                left += int(nums[k] > nums[j])
        return result

",# Time:  O(n^2)
"class Solution3(object):
    def countQuadruplets(self, nums):
        left = [[0]*(len(nums)+1) for _ in range(len(nums))]
        for j in range(len(nums)):
            for i in range(j):
                left[j][i+1] = left[j][i] + int(nums[i] < nums[j])
        right = [[0]*(len(nums)+1) for _ in range(len(nums))]
        for j in range(len(nums)):
            for i in reversed(range(j+1, len(nums))):
                right[j][i] = right[j][i+1] + int(nums[i] > nums[j])
        result = 0
        for k in range(len(nums)):
            for j in range(k):
                if nums[k] < nums[j]:
                    result += left[k][j]*right[j][k+1]
        return result",# Time:  O(n^2)
"class Solution(object):
    def countPrimeSetBits(self, L, R):
        def bitCount(n):
            result = 0
            while n:
                n &= n-1
                result += 1
            return result

        primes = {2, 3, 5, 7, 11, 13, 17, 19}
        return sum(bitCount(i) in primes
                   for i in range(L, R+1))
",# Time:  O(log(R - L)) = O(1)
"class Solution(object):
    def longestCommonPrefix(self, words, k):
        idxs = list(range(len(words)))
        idxs.sort(key=lambda x: words[x])
        def longest_common_prefix(k):
            lcp = [0]*len(words)
            for i in range(len(words)-(k-1)):
                left = words[idxs[i]]
                right = words[idxs[i+(k-1)]]
                l = min(len(left), len(right))
                lcp[i] = next((j for j in range(l) if left[j] != right[j]), l)
            return lcp
        
        lcp = longest_common_prefix(k)
        prefix = [0]*len(words)
        prefix[0] = lcp[0]
        for i in range(len(prefix)-1):
            prefix[i+1] = max(prefix[i], lcp[i+1])
        suffix = [0]*len(words)
        suffix[-1] = lcp[-1]
        for i in reversed(range(len(suffix)-1)):
            suffix[i] = max(suffix[i+1], lcp[i])
        result = [0]*len(words)
        mx = max(longest_common_prefix(k+1))
        for i in range(len(words)):
            idx = idxs[i]
            mx1 = prefix[i-k] if i-k >= 0 else 0
            mx2 = suffix[i+1] if i+1 < len(words) else 0
            result[idx] = max(mx, mx1, mx2)
        return result
    
    
",# Time:  O(l * nlogn)
"class Solution2(object):
    def longestCommonPrefix(self, words, k):
        class Trie(object):
            def __init__(self):
                self.__root = self.__new_node()
            
            def __new_node(self):
                return {""cnt"":0, ""max"":0}

            def update(self, w, d, k):
                path = [None]*(len(w)+1)
                path[0] = curr = self.__root
                for i, x in enumerate(w, 1):
                    if x not in curr:
                        curr[x] = self.__new_node()
                    path[i] = curr = curr[x]
                for i in reversed(range(len(path))):
                    curr = path[i]
                    curr[""cnt""] += d
                    curr[""max""] = i if curr[""cnt""] >= k else 0
                    for x in curr.keys():
                        if len(x) == 1:
                            curr[""max""] = max(curr[""max""], curr[x][""max""])

            def query(self):
                return self.__root[""max""]

        trie = Trie()
        for w in words:
            trie.update(w, +1, k)
        result = [0]*len(words)
        for i in range(len(words)):
            trie.update(words[i], -1, k)
            result[i] = trie.query()
            trie.update(words[i], +1, k)
        return result

",# Time:  O(l * nlogn)
"class Solution3(object):
    def longestCommonPrefix(self, words, k):
        class Trie(object):
            def __init__(self):
                self.__nodes = []
                self.__cnt = []
                self.__mx = []
                self.__new_node()
            
            def __new_node(self):
                self.__nodes.append([-1]*26)
                self.__cnt.append(0)
                self.__mx.append(0)
                return len(self.__nodes)-1

            def update(self, w, d, k):
                path = [-1]*(len(w)+1)
                path[0] = curr = 0
                for i, c in enumerate(w, 1):
                    x = ord(c)-ord('a')
                    if self.__nodes[curr][x] == -1:
                        self.__nodes[curr][x] = self.__new_node()
                    path[i] = curr = self.__nodes[curr][x]
                for i in reversed(range(len(path))):
                    curr = path[i]
                    self.__cnt[curr] += d
                    self.__mx[curr] = i if self.__cnt[curr] >= k else 0
                    for x in range(len(self.__nodes[curr])):
                        if self.__nodes[curr][x] != -1:
                            self.__mx[curr]= max(self.__mx[curr], self.__mx[self.__nodes[curr][x]])

            def query(self):
                return self.__mx[0]
        

        result = [0]*len(words)
        trie = Trie()
        for w in words:
            trie.update(w, +1, k)
        for i in range(len(words)):
            trie.update(words[i], -1, k)
            result[i] = trie.query()
            trie.update(words[i], +1, k)
        return result",# Time:  O(n * l)
"class Solution(object):
    def maximumAmount(self, coins):
        K = 2
        mn = min(len(coins), len(coins[0]))
        mx = max(len(coins), len(coins[0]))
        get = (lambda i, j: coins[i][j]) if len(coins) == mx else (lambda i, j: coins[j][i])
        dp = [[float(""-inf"")]*(K+1) for _ in range(mn)] 
        for i in range(mx):
            new_dp = [[float(""-inf"")]*(K+1) for _ in range(mn)]
            for j in range(mn):
                for k in range(K+1):
                    if i == 0 and j == 0:
                        new_dp[j][k] = max(get(i, j), 0) if k-1 >= 0 else get(i, j)
                        continue
                    if i-1 >= 0:
                        new_dp[j][k] = max(new_dp[j][k], dp[j][k]+get(i, j))
                        if k-1 >= 0:
                            new_dp[j][k] = max(new_dp[j][k], dp[j][k-1])
                    if j-1 >= 0:
                        new_dp[j][k] = max(new_dp[j][k], new_dp[j-1][k]+get(i, j))
                        if k-1 >= 0:
                            new_dp[j][k] = max(new_dp[j][k], new_dp[j-1][k-1])
            dp = new_dp
        return dp[-1][-1]

",# Time:  O(m * n * k) = O(m * n)
"class Solution2(object):
    def maximumAmount(self, coins):
        K = 2
        dp = [[float(""-inf"")]*(K+1) for _ in range(len(coins[0]))] 
        for i in range(len(coins)):
            new_dp = [[float(""-inf"")]*(K+1) for _ in range(len(coins[0]))]
            for j in range(len(coins[0])):
                for k in range((K+1)):
                    if i == 0 and j == 0:
                        new_dp[j][k] = max(coins[i][j], 0) if k-1 >= 0 else coins[i][j]
                        continue
                    if i-1 >= 0:
                        new_dp[j][k] = max(new_dp[j][k], dp[j][k]+coins[i][j])
                        if k-1 >= 0:
                            new_dp[j][k] = max(new_dp[j][k], dp[j][k-1])
                    if j-1 >= 0:
                        new_dp[j][k] = max(new_dp[j][k], new_dp[j-1][k]+coins[i][j])
                        if k-1 >= 0:
                            new_dp[j][k] = max(new_dp[j][k], new_dp[j-1][k-1])
            dp = new_dp
        return dp[-1][-1]",# Time:  O(m * n * k) = O(m * n)
"class Solution(object):

    def __init__(self, words):
        self.__trie = AhoTrie(words)

    def query(self, letter): 
        return len(self.__trie.step(letter)) > 0

","# Time:  ctor:  O(n + p^2), n is the total size of patterns"
"class Solution(object):
    def countComponents(self, n, edges):
        union_find = UnionFind(n)
        for i, j in edges:
            union_find.union_set(i, j)
        return union_find.count
","# Time:  O(nlog*n) ~= O(n), n is the length of the positions"
"class Solution(object):
    def numberOfPairs(self, nums1, nums2, diff):
        sl = SortedList()
        result = 0
        for x, y in zip(nums1, nums2):
            result += sl.bisect_right((x-y)+diff)
            sl.add(x-y)
        return result

import itertools
import bisect


class BIT(object): 
    def __init__(self, n):
        self.__bit = [0]*(n+1) 

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret


",# Time:  O(nlogn)
"class Solution2(object):
    def numberOfPairs(self, nums1, nums2, diff):
        sorted_nums = sorted(set(x-y for x, y in zip(nums1, nums2)))
        num_to_idx = {x:i for i, x in enumerate(sorted_nums)}
        result = 0
        bit = BIT(len(num_to_idx))
        for x, y in zip(nums1, nums2):
            result += bit.query(bisect.bisect_right(sorted_nums, (x-y)+diff)-1)
            bit.add(num_to_idx[x-y], 1)
        return result

",# Time:  O(nlogn)
"class Solution3(object):
    def numberOfPairs(self, nums1, nums2, diff):
        def merge_sort(nums, left, right, result):
            if left == right:
                return
            mid = left+(right-left)//2
            merge_sort(nums, left, mid, result)
            merge_sort(nums, mid+1, right, result)
            r = mid+1
            for l in range(left, mid+1):
                while r < right+1 and nums[l]-nums[r] > diff:
                    r += 1
                result[0] += right-r+1
            tmp = []
            l, r = left, mid+1
            while l < mid+1 or r < right+1:
                if r >= right+1 or (l < mid+1 and nums[l] <= nums[r]):
                    tmp.append(nums[l])
                    l += 1
                else:
                    tmp.append(nums[r])
                    r += 1
            nums[left:right+1] = tmp

        nums = [x-y for x, y in zip(nums1, nums2)]
        result = [0]
        merge_sort(nums, 0, len(nums)-1, result)
        return result[0]",# Time:  O(nlogn)
"class Solution(object):
    def minSideJumps(self, obstacles):
        result, lanes = 0, set([2])
        for i in range(len(obstacles)-1):
            lanes.discard(obstacles[i+1])
            if lanes:
                continue
            result += 1
            lanes = set(j for j in range(1, 4) if j not in [obstacles[i], obstacles[i+1]])
        return result


",# Time:  O(n)
"class Solution2(object):
    def minSideJumps(self, obstacles):
        dp = [1, 0, 1]        
        for i in obstacles:
            if i:
                dp[i-1] = float(""inf"")
            for j in range(3):
                if j+1 != i:
                    dp[j] = min(dp[0]+(j != 0), dp[1]+(j != 1), dp[2]+(j != 2))
        return min(dp)",# Time:  O(n)
"class Solution(object):
    def minimumVisitedCells(self, grid):
        m, n = len(grid), len(grid[0])
        uf1 = [UnionFind(n+1) for _ in range(m)]
        uf2 = [UnionFind(m+1) for _ in range(n)]
        d, i, j = 1, 0, 0
        q = [(i, j)]
        uf1[i].union_set(j, j+1)
        uf2[j].union_set(i, i+1)
        while q:
            new_q = []
            for i, j in q:
                if (i, j) == (m-1, n-1):
                    return d
                while uf1[i].right_set(j) <= min(j+grid[i][j], n-1):
                    k = uf1[i].right_set(j)
                    new_q.append((i, k))
                    uf2[k].union_set(i, i+1)
                    uf1[i].union_set(k, k+1)
                while uf2[j].right_set(i) <= min(i+grid[i][j], m-1):
                    k = uf2[j].right_set(i)
                    new_q.append((k, j))
                    uf1[k].union_set(j, j+1)
                    uf2[j].union_set(k, k+1)
            q = new_q
            d += 1
        return -1

",# Time:  O(m * n * alpha(m + n)) = O(m + n)
"class Solution2_TLE(object):
    def minimumVisitedCells(self, grid):
        m, n = len(grid), len(grid[0])
        sl1 = [SortedList(range(n)) for _ in range(m)]
        sl2 = [SortedList(range(m)) for _ in range(n)]
        d, i, j = 1, 0, 0
        q = [(i, j)]
        while q:
            new_q = []
            for i, j in q:
                if (i, j) == (m-1, n-1):
                    return d
                for k in list(sl1[i].irange(j+1, min(j+grid[i][j], n-1))):
                    new_q.append((i, k))
                    sl2[k].remove(i)
                    sl1[i].remove(k)
                for k in list(sl2[j].irange(i+1, min(i+grid[i][j], m-1))):
                    new_q.append((k, j))
                    sl1[k].remove(j)
                    sl2[j].remove(k)
            q = new_q
            d += 1
        return -1",# Time:  O(m * n * log(m + n))
"class Solution(object):
    def findRoot(self, tree):
        root = 0
        for node in tree:
            root ^= id(node)
            for child in node.children:
                root ^= id(child)
        for node in tree:
            if id(node) == root:
                return node
        return None

",# Time:  O(n)
"class Solution2(object):
    def findRoot(self, tree):
        root = 0
        for node in tree:
            root ^= node.val
            for child in node.children:
                root ^= child.val
        for node in tree:
            if node.val == root:
                return node
        return None

",# Time:  O(n)
"class Solution3(object):
    def findRoot(self, tree):
        root = 0
        for node in tree:
            root += node.val-sum(child.val for child in node.children)
        for node in tree:
            if node.val == root:
                return node
        return None",# Time:  O(n)
"class Solution(object):
    def tripletCount(self, a, b, c):
        def popcount(x):
            return bin(x).count('1')

        def count(a):
            odd = sum(popcount(x)&1 for x in a)
            return [len(a)-odd, odd]
        
        cnt = list(map(count, (a, b, c)))
        return sum(cnt[0][0 if i == 0 or i == 1 else 1]*cnt[1][0 if i == 0 or i == 2 else 1]*cnt[2][0 if i == 0 or i == 3 else 1] for i in range(4))
    
    
","# Time:  O(nlogr), r = max(max(a), max(b), max(c))"
"class Solution2(object):
    def tripletCount(self, a, b, c):
        def popcount(x):
            return bin(x).count('1')

        def count(a):
            odd = sum(popcount(x)&1 for x in a)
            return [len(a)-odd, odd]
        
        even1, odd1 = count(a)
        even2, odd2 = count(b)
        even3, odd3 = count(c)
        return even1*even2*even3 + even1*odd2*odd3 + odd1*even2*odd3 + odd1*odd2*even3

","# Time:  O(nlogr), r = max(max(a), max(b), max(c))"
"class Solution3(object):
    def tripletCount(self, a, b, c):
        def popcount(x):
            return bin(x).count('1')

        return sum(popcount(x^y^z)%2 == 0 for x in a for y in b for z in c)","# Time:  O(n^3 * logr), r = max(max(a), max(b), max(c))"
"class Solution(object):
    def numberOfSets(self, n, maxDistance, roads):
        def check(mask, dist):
            return all(dist[i][j] <= maxDistance for i in range(n) if mask&(1<<i) for j in range(i+1, n) if mask&(1<<j))

        def floydWarshall(dist, k):
            for i in range(len(dist)):
                for j in range(i+1, len(dist[i])):
                    dist[j][i] = dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])

        def backtracking(i, mask, dist):
            if i == n:
                result[0] += check(mask, dist)
                return
            for j in range(2):
                new_dist = [d[:] for d in dist]
                if j:
                    floydWarshall(new_dist, i)
                backtracking(i+1, mask|(j<<i), new_dist)
    
        dist = [[0 if u == v else float(""inf"") for v in range(n)] for u in range(n)]
        for u, v, w in roads:
            dist[u][v] = min(dist[u][v], w)
            dist[v][u] = min(dist[v][u], w)
        result = [0]
        backtracking(0, 0, [d[:] for d in dist])
        return result[0]
    
",# Time:  O(r + 2^n * n^2)
"class Solution2(object):
    def numberOfSets(self, n, maxDistance, roads):
        def check(mask, dist):
            return all(dist[i][j] <= maxDistance for i in range(n) if mask&(1<<i) for j in range(i+1, n) if mask&(1<<j))

        def floydWarshall(mask, dist):
            for k in range(len(dist[0])):
                if mask&(1<<k) == 0:
                    continue
                for i in range(len(dist)):
                    if mask&(1<<i) == 0: 
                        continue
                    for j in range(i+1, len(dist[i])):
                        if mask&(1<<j) == 0: 
                             continue
                        dist[j][i] = dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])
            return check(mask, dist)

        dist = [[0 if u == v else float(""inf"") for v in range(n)] for u in range(n)]
        for u, v, w in roads:
            dist[u][v] = min(dist[u][v], w)
            dist[v][u] = min(dist[v][u], w)
        return sum(floydWarshall(mask, [d[:] for d in dist]) for mask in range(1<<n))
    ",# Time:  O(r + 2^n * n^2)
"class Solution(object):

    def __init__(self, n):
        self.__sl = SortedList((i-1, i) for i in range(1, n+1))  

    def fetch(self, k):
        last, _ = self.__sl[-1]
        _, val = self.__sl.pop(k-1)
        self.__sl.add((last+1, val))
        return val

",# Time:  ctor:  O(nlogn)
"class Solution2(object): 
    def __init__(self, n):
        MAX_CALLS = 2000
        self.__bit = [0]*(n+MAX_CALLS+1) 
        for i in range(1, len(self.__bit)):
            self.__bit[i] = (1 if i-1 < n else 0) + self.__bit[i-1]
        for i in reversed(range(1, len(self.__bit))):
            last_i = i - (i & -i)
            self.__bit[i] -= self.__bit[last_i]

    def add(self, i, val):
        i += 1 
        while i < len(self.__bit):
            self.__bit[i] += val
            i += (i & -i)

    def query(self, i):
        i += 1 
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret

    def binary_lift(self, k):
        floor_log2_n = (len(self.__bit)-1).bit_length()-1
        pow_i = 2**floor_log2_n
        total = pos = 0 
        for i in reversed(range(floor_log2_n+1)): 
            if pos+pow_i < len(self.__bit) and not (total+self.__bit[pos+pow_i] >= k):
                total += self.__bit[pos+pow_i]
                pos += pow_i
            pow_i >>= 1
        return (pos+1)-1 


","# Time:  ctor:  O(n + m), m is the max number of calls"
"class Solution3(object):

    def __init__(self, n):
        self.__bit = BIT(n)
        self.__lookup = {i:i+1 for i in range(n)}
        self.__curr = n
        
    def fetch(self, k):
        pos = self.__bit.binary_lift(k)  
        val = self.__lookup.pop(pos)
        self.__bit.add(pos, -1)
        self.__bit.add(self.__curr, 1)
        self.__lookup[self.__curr] = val     
        self.__curr += 1
        return val

","# Time:  ctor:  O(n + m), m is the max number of calls"
"class Solution4(object):

    def __init__(self, n):
        self.__buckets = [collections.deque() for _ in range(int(math.ceil(n**0.5)))]
        for i in range(n):
            self.__buckets[i//len(self.__buckets)].append(i+1)

    def fetch(self, k):
        k -= 1
        left, idx = divmod(k, len(self.__buckets))
        val = self.__buckets[left][idx]
        del self.__buckets[left][idx]
        self.__buckets[-1].append(val)
        for i in reversed(range(left, len(self.__buckets)-1)):
            x = self.__buckets[i+1].popleft()
            self.__buckets[i].append(x)
        return val",# Time:  ctor:  O(n)
"class Solution(object):
    def missingNumber(self, nums):
        return reduce(operator.xor, nums,
                      reduce(operator.xor, range(len(nums) + 1)))

",# Time:  O(n)
"class Solution2(object):
    def missingNumber(self, nums):
        return sum(range(len(nums)+1)) - sum(nums)
",# Time:  O(n)
"class Solution(object):
    def maximizeGreatness(self, nums):
        return len(nums)-max(collections.Counter(nums).values())
    
    
",# Time:  O(n)
"class Solution2(object):
    def maximizeGreatness(self, nums):
        nums.sort()
        left = 0
        for right in range(len(nums)):
            if nums[right] > nums[left]:
                left += 1
        return left",# Time:  O(n)
"class Solution(object):
    def secondMinimum(self, n, edges, time, change):
        def bi_bfs(adj, start, target):
            left, right = {start}, {target}
            lookup = set()
            result = steps = 0
            while left and (not result or result+2 > steps): 
                for u in left:
                    lookup.add(u)
                new_left = set()
                for u in left: 
                    if u in right:
                        if not result: 
                            result = steps
                        elif result < steps: 
                            return result+1
                    for v in adj[u]:
                        if v in lookup:
                            continue
                        new_left.add(v)
                left = new_left
                steps += 1
                if len(left) > len(right): 
                    left, right = right, left
            return result+2 

        def calc_time(time, change, dist):
            result = 0
            for _ in range(dist):
                if result//change%2:
                    result = (result//change+1)*change
                result += time
            return result

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        return calc_time(time, change, bi_bfs(adj, 0, n-1))

","# Time:  O(|V| + |E|) = O(|E|) since graph is connected, O(|E|) >= O(|V|) "
"class Solution2(object):
    def secondMinimum(self, n, edges, time, change):
        INF = float(""inf"")
        def bfs(adj, start):
            q = [start]
            dist = [INF]*len(adj)
            dist[start] = 0
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[v] != INF:
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                q = new_q
            return dist

        def calc_time(time, change, dist):
            result = 0
            for _ in range(dist):
                if result//change%2:
                    result = (result//change+1)*change
                result += time
            return result

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        dist_to_end, dist_to_start = bfs(adj, 0), bfs(adj, n-1)

        dist = dist_to_end[n-1]+2 
        for i in range(n): 
            if dist_to_end[i]+dist_to_start[i] == dist_to_end[n-1]:
                continue
            dist = min(dist, dist_to_end[i]+dist_to_start[i]) 
            if dist == dist_to_end[n-1]+1:
                break
        return calc_time(time, change, dist)","# Time:  O(|V| + |E|) = O(|E|) since graph is connected, O(|E|) >= O(|V|) "
"class Solution(object):
    def maxChunksToSorted(self, arr):
        result, max_i = 0, 0
        for i, v in enumerate(arr):
            max_i = max(max_i, v)
            if max_i == i:
                result += 1
        return result


",# Time:  O(n)
"class Solution2(object):
    def maxChunksToSorted(self, arr):
        result, increasing_stk = 0, []
        for num in arr:
            max_num = num if not increasing_stk else max(increasing_stk[-1], num)
            while increasing_stk and increasing_stk[-1] > num:
                increasing_stk.pop()
            increasing_stk.append(max_num)
        return len(increasing_stk)",# Time:  O(n)
"class Solution(object):
    def maximumSum(self, arr):
        result, prev, curr = float(""-inf""), float(""-inf""), float(""-inf"")
        for x in arr:
            curr = max(prev, curr+x, x)
            result = max(result, curr)
            prev = max(prev+x, x)
        return result",
"class Solution(object):
    def maximumSum(self, nums):
        return max(sum(nums[i*x**2-1] for x in range(1, int((len(nums)//i)**0.5)+1)) for i in range(1, len(nums)+1))","# Time:  O(n * (1 + 1/4 + 1/9 + ... + 1/x^2)) = O(pi^2 / 6 * n) = O(n), see https://en.wikipedia.org/wiki/Basel_problem"
"class Solution(object):
    def largestMultipleOfThree(self, digits):
        lookup = {0: [],
                  1: [(1,), (4,), (7,), (2, 2), (5, 2), (5, 5), (8, 2), (8, 5), (8, 8)],
                  2: [(2,), (5,), (8,), (1, 1), (4, 1), (4, 4), (7, 1), (7, 4), (7, 7)]}
        count = collections.Counter(digits)
        for deletes in lookup[sum(digits)%3]:
            delete_count = collections.Counter(deletes)
            if all(count[k] >= v for k, v in delete_count.items()):
                for k, v in delete_count.items():
                    count[k] -= v
                break
        result = """".join(str(d)*count[d] for d in reversed(range(10)))
        return ""0"" if result and result[0] == '0' else result
    
    ",# Time:  O(n)
"class Solution2(object):
    def largestMultipleOfThree(self, digits):
        def candidates_gen(r):
            if r == 0:
                return
            for i in range(10):
                yield [i]
            for i in range(10):
                for j in range(i+1):
                    yield [i, j]

        count, r = collections.Counter(digits), sum(digits)%3
        for deletes in candidates_gen(r):
            delete_count = collections.Counter(deletes)
            if sum(deletes)%3 == r and \
               all(count[k] >= v for k, v in delete_count.items()):
                for k, v in delete_count.items():
                    count[k] -= v
                break
        result = """".join(str(d)*count[d] for d in reversed(range(10)))
        return ""0"" if result and result[0] == '0' else result",# Time:  O(n)
"class Solution(object):
    def sumOfFlooredPairs(self, nums):
        MOD = 10**9+7
        prefix, counter = [0]*(max(nums)+1), collections.Counter(nums)
        for num, cnt in counter.items():
            for j in range(num, len(prefix), num):
                prefix[j] += counter[num]
        for i in range(len(prefix)-1):
            prefix[i+1] += prefix[i]
        return reduce(lambda total, num: (total+prefix[num])%MOD, nums, 0)","# Time:  O(n/1+n/2+...+n/n) = O(nlogn), n is the max of nums"
"class Solution(object):
    def repairCars(self, ranks, cars):
        def check(x):
            return sum(int((x//k)**0.5)*v for k, v in cnt.items()) >= cars

        cnt = collections.Counter(ranks)
        left, right = 1, min(cnt.keys())*cars**2
        while left <= right:
            mid = left+(right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return left

","# Time:  O(mx * log(mn * c^2)) = O(mx * (logc + log(mn))), c = cars, mx = max(ranks), mn = min(ranks)"
"class Solution2(object):
    def repairCars(self, ranks, cars):
        cnt = collections.Counter(ranks)
        min_heap = [(r*1**2, 1) for r in cnt.keys()]
        heapq.heapify(min_heap)
        while cars > 0:
            t, k = heapq.heappop(min_heap)
            r = t//k**2
            cars -= cnt[r]
            k += 1
            heapq.heappush(min_heap, (r*k**2, k))
        return t","# Time:  O(c * log(mx)), c = cars, mx = max(ranks)"
"class Solution(object):
    def trapRainWater(self, heightMap):
        m = len(heightMap)
        if not m:
            return 0
        n = len(heightMap[0])
        if not n:
            return 0

        is_visited = [[False for i in range(n)] for j in range(m)]

        heap = []
        for i in range(m):
            heappush(heap, [heightMap[i][0], i, 0])
            is_visited[i][0] = True
            heappush(heap, [heightMap[i][n-1], i, n-1])
            is_visited[i][n-1] = True
        for j in range(1, n-1):
            heappush(heap, [heightMap[0][j], 0, j])
            is_visited[0][j] = True
            heappush(heap, [heightMap[m-1][j], m-1, j])
            is_visited[m-1][j] = True

        trap = 0
        while heap:
            height, i, j = heappop(heap)
            for (dx, dy) in [(1,0), (-1,0), (0,1), (0,-1)]:
                x, y = i+dx, j+dy
                if 0 <= x < m and 0 <= y < n and not is_visited[x][y]:
                    trap += max(0, height - heightMap[x][y])
                    heappush(heap, [max(height, heightMap[x][y]), x, y])
                    is_visited[x][y] = True

        return trap
",# Time:  O(m * n * log(m + n)) ~ O(m * n * log(m * n))
"class Solution(object):

    def __init__(self):
        self.__books = [[-1, 0]]
        self.__count = 0

    def book(self, start, end):
        i = bisect.bisect_right(self.__books, [start, float(""inf"")])
        if self.__books[i-1][0] == start:
            i -= 1
        else:
            self.__books.insert(i, [start, self.__books[i-1][1]])
        j = bisect.bisect_right(self.__books, [end, float(""inf"")])
        if self.__books[j-1][0] == end:
            j -= 1
        else:
            self.__books.insert(j, [end, self.__books[j-1][1]])            
        for k in range(i, j):
            self.__books[k][1] += 1
            self.__count = max(self.__count, self.__books[k][1])
        return self.__count

",# Time:  O(nlogn) ~ O(n^2)
"class Solution2(object):

    def __init__(self):
        self.__books = []


    def book(self, start, end):
        i = bisect.bisect_left(self.__books, (start, 1))
        if i < len(self.__books) and self.__books[i][0] == start:
            self.__books[i] = (self.__books[i][0], self.__books[i][1]+1)
        else:
            self.__books.insert(i, (start, 1))

        j = bisect.bisect_left(self.__books, (end, 1))
        if j < len(self.__books) and self.__books[j][0] == end:
            self.__books[j] = (self.__books[j][0], self.__books[j][1]-1)
        else:
            self.__books.insert(j, (end, -1))

        result, cnt = 0, 0
        for book in self.__books:
            cnt += book[1]
            result = max(result, cnt)
        return result
",# Time:  O(n^2)
"class Solution(object):
    def minimumSubarrayLength(self, nums, k):
        def update(x, d, curr):
            for i in range(len(cnt)):
                if x < (1<<i):
                    break
                if not (x&(1<<i)):
                    continue
                if cnt[i] == 0:
                    curr ^= 1<<i
                cnt[i] += d
                if cnt[i] == 0:
                    curr ^= 1<<i
            return curr

        total = reduce(lambda x, y: x|y, nums)
        if total < k:
            return -1
        cnt = [0]*total.bit_length()
        result = len(nums)
        left = curr = 0
        for right in range(len(nums)):
            curr = update(nums[right], +1, curr)
            while left <= right and curr >= k:
                result = min(result, right-left+1)
                curr = update(nums[left], -1, curr)
                left += 1
        return result ",# Time:  O(nlogr) = O(n * 30)
"class Solution(object):
    def countOfPairs(self, nums):
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD
    
        def nHr(n, r):
            return nCr(n+r-1, r)

        MOD = 10**9+7
        cnt = nums[-1]-sum(max(nums[i]-nums[i-1], 0) for i in range(1, len(nums)))
        return nHr(len(nums)+1, cnt) if cnt >= 0 else 0
    
    
","# Time:  O(n + r), r = max(nums)"
"class Solution2(object):
    def countOfPairs(self, nums):
        MOD = 10**9+7
        dp = [int(i <= nums[0]) for i in range(max(nums)+1)] 
        for i in range(1, len(nums)):
            new_dp = [0]*len(dp)
            diff = max(nums[i]-nums[i-1], 0)
            for j in range(diff, nums[i]+1):
                new_dp[j] = (new_dp[j-1]+dp[j-diff])%MOD
            dp = new_dp
        return reduce(lambda accu, x: (accu+x)%MOD, dp, 0)
    

","# Time:  O(n + r), r = max(nums)"
"class Solution3(object):
    def countOfPairs(self, nums):
        MOD = 10**9+7
        dp = [int(i <= nums[0]) for i in range(max(nums)+1)] 
        for i in range(1, len(nums)):
            new_dp = [0]*len(dp)
            diff = max(nums[i]-nums[i-1], 0)
            for j in range(diff, nums[i]+1):
                for k in range(diff, j+1):
                    new_dp[j] = (new_dp[j]+dp[k-diff])%MOD
            dp = new_dp
        return reduce(lambda accu, x: (accu+x)%MOD, dp, 0)","# Time:  O(n + r), r = max(nums)"
"class Solution(object):
    def minimumChanges(self, s, k):
        divisors = [[] for _ in range(len(s)+1)]
        for i in range(1, len(divisors)): 
            for j in range(i, len(divisors), i):
                divisors[j].append(i)
        dp = [[{} for _ in range(len(s))] for _ in range(len(s))]
        for l in range(1, len(s)+1): 
            for left in range(len(s)-l+1):
                right = left+l-1
                for d in divisors[l]:
                    dp[left][right][d] = (dp[left+d][right-d][d] if left+d < right-d else 0)+sum(s[left+i] != s[(right-(d-1))+i] for i in range(d))
        dp2 = [[min(dp[i][j][d] for d in divisors[j-i+1] if d != j-i+1) if i < j else 0 for j in range(len(s))] for i in range(len(s))] 
        dp3 = [len(s)]*(len(s)+1)
        dp3[0] = 0
        for l in range(k): 
            new_dp3 = [len(s)]*(len(s)+1)
            for i in range(len(s)):
                for j in range(l*2, i): 
                    new_dp3[i+1]= min(new_dp3[i+1], dp3[j]+dp2[j][i])
            dp3 = new_dp3
        return dp3[len(s)]

",# Time:  O(n * nlogn + n^3 + n^2 * k) = O(n^3)
"class Solution2(object):
    def minimumChanges(self, s, k):
        divisors = [[] for _ in range(len(s)+1)]
        for i in range(1, len(divisors)): 
            for j in range(i, len(divisors), i):
                divisors[j].append(i)
        dp = [[{} for _ in range(len(s))] for _ in range(len(s))]
        for l in range(1, len(s)+1): 
            for left in range(len(s)-l+1):
                right = left+l-1
                for d in divisors[l]:
                    dp[left][right][d] = (dp[left+d][right-d][d] if left+d < right-d else 0)+sum(s[left+i] != s[(right-(d-1))+i] for i in range(d))
        dp2 = [[len(s)]*(k+1) for _ in range(len(s)+1)]
        dp2[0][0] = 0
        for i in range(len(s)): 
            for j in range(i):
                c = min(dp[j][i][d] for d in divisors[i-j+1] if d != i-j+1)
                for l in range(k):
                    dp2[i+1][l+1] = min(dp2[i+1][l+1], dp2[j][l]+c)
        return dp2[len(s)][k]

",# Time:  O(n * nlogn + n^3 + n^2 * k) = O(n^3)
"class Solution3(object):
    def minimumChanges(self, s, k):
        def min_dist(left, right): 
            return min(sum(s[left+i] != s[right-((i//d+1)*d-1)+(i%d)] for i in range((right-left+1)//2))
 for d in divisors[right-left+1])

        divisors = [[] for _ in range(len(s)+1)]
        for i in range(1, len(divisors)): 
            for j in range(i+i, len(divisors), i):
                divisors[j].append(i)
        dp = [[len(s)]*(k+1) for _ in range(len(s)+1)]
        dp[0][0] = 0
        for i in range(len(s)): 
            for j in range(i):
                c = min_dist(j, i)
                for l in range(k):
                    dp[i+1][l+1] = min(dp[i+1][l+1], dp[j][l]+c)
        return dp[len(s)][k]",# Time:  O(n^2 * nlogn + n^2 * k) = O(n^3 * logn)
"class Solution(object):
    def countDifferentSubsequenceGCDs(self, nums):
        max_num, nums_set = max(nums), set(nums)
        result = 0
        for i in range(1, max_num+1):
            d = 0
            for x in range(i, max_num+1, i):
                if x not in nums_set:
                    continue
                d = fractions.gcd(d, x) 
                if d == i:
                    result += 1
                    break
        return result","# Time:  O(n + m * (1 + 1/2 + 1/3 + ... + 1/m)) = O(n + mlogm), m is max of nums"
"class Solution(object):
    def alienOrder(self, words):
        result, in_degree, out_degree = [], {}, {}
        zero_in_degree_queue = collections.deque()
        nodes = set()
        for word in words:
            for c in word:
                nodes.add(c)

        for i in range(1, len(words)):
            if (len(words[i-1]) > len(words[i]) and
                    words[i-1][:len(words[i])] == words[i]):
                return """"
            self.findEdges(words[i - 1], words[i], in_degree, out_degree)

        for node in nodes:
            if node not in in_degree:
                zero_in_degree_queue.append(node)

        while zero_in_degree_queue:
            precedence = zero_in_degree_queue.popleft()
            result.append(precedence)

            if precedence in out_degree:
                for c in out_degree[precedence]:
                    in_degree[c].discard(precedence)
                    if not in_degree[c]:
                        zero_in_degree_queue.append(c)

                del out_degree[precedence]

        if out_degree:
            return """"

        return """".join(result)

    def findEdges(self, word1, word2, in_degree, out_degree):
        str_len = min(len(word1), len(word2))
        for i in range(str_len):
            if word1[i] != word2[i]:
                if word2[i] not in in_degree:
                    in_degree[word2[i]] = set()
                if word1[i] not in out_degree:
                    out_degree[word1[i]] = set()
                in_degree[word2[i]].add(word1[i])
                out_degree[word1[i]].add(word2[i])
                break


",# Time:  O(n)
"class Solution2(object):
    def alienOrder(self, words):
        nodes, ancestors = set(), {}
        for i in range(len(words)):
            for c in words[i]:
                nodes.add(c)
        for node in nodes:
            ancestors[node] = []
        for i in range(1, len(words)):
            if (len(words[i-1]) > len(words[i]) and
                    words[i-1][:len(words[i])] == words[i]):
                return """"
            self.findEdges(words[i - 1], words[i], ancestors)

        result = []
        visited = {}
        for node in nodes:
            if self.topSortDFS(node, node, ancestors, visited, result):
                return """"

        return """".join(result)

    def findEdges(self, word1, word2, ancestors):
        min_len = min(len(word1), len(word2))
        for i in range(min_len):
            if word1[i] != word2[i]:
                ancestors[word2[i]].append(word1[i])
                break

    def topSortDFS(self, root, node, ancestors, visited, result):
        if node not in visited:
            visited[node] = root
            for ancestor in ancestors[node]:
                if self.topSortDFS(root, ancestor, ancestors, visited, result):
                    return True
            result.append(node)
        elif visited[node] == root:
            return True
        return False
",# Time:  O(n)
"class Solution(object):
    def countPairs(self, nums):
        L = 7
        POW10 = [0]*L
        POW10[0] = 1
        for i in range(L-1):
            POW10[i+1] = POW10[i]*10
        cnt1 = collections.Counter(nums)
        cnt2 = collections.Counter()
        for x, v in cnt1.items():
            for i in range(L):
                a = x//POW10[i]%10
                for j in range(i+1, L):
                    b = x//POW10[j]%10
                    if a == b or x-a*(POW10[i]-POW10[j])+b*(POW10[i]-POW10[j]) not in cnt1:
                        continue
                    cnt2[x-a*(POW10[i]-POW10[j])+b*(POW10[i]-POW10[j])] += v
        return sum(v*(v-1)//2 for v in cnt1.values())+sum(v*cnt2[x] for x, v in cnt1.items())//2

",# Time:  O(n * l^2)
"class Solution2(object):
    def countPairs(self, nums):
        L = 7
        K = 1
        POW10 = [0]*L
        POW10[0] = 1
        for i in range(L-1):
            POW10[i+1] = POW10[i]*10
        def at_most(k, x):
            lookup = {x}
            result = [x]
            u = 0
            for _ in range(k):
                for u in range(u, len(result)):
                    x = result[u]
                    for i in range(L):
                        a = x//POW10[i]%10
                        for j in range(i+1, L):
                            b = x//POW10[j]%10
                            if a == b:
                                continue
                            y = x-a*(POW10[i]-POW10[j])+b*(POW10[i]-POW10[j])
                            if y in lookup:
                                continue
                            lookup.add(y)
                            result.append(y)
            return result

        result = 0
        cnt1 = collections.Counter(nums)
        cnt2 = collections.Counter()
        for x, v in cnt1.items():
            result += cnt2[x]*v+v*(v-1)//2
            for x in at_most(K, x):
                if x not in cnt1:
                    continue
                cnt2[x] += v
        return result
",# Time:  O(n * l^(2 * k)) = O(n * l^2)
"class Solution(object):
    def findInteger(self, k, digit1, digit2):
        MAX_NUM_OF_DIGITS = 10
        INT_MAX = 2**31-1

        if digit1 < digit2:
            digit1, digit2 = digit2, digit1
        total = 2
        for l in range(1, MAX_NUM_OF_DIGITS+1):
            for mask in range(total):
                curr, bit = 0, total>>1
                while bit:
                    curr = curr*10 + (digit1 if mask&bit else digit2)
                    bit >>= 1
                if k < curr <= INT_MAX and curr%k == 0:
                    return curr
            total <<= 1
        return -1","# Time:  sum(O(l * 2^l) for l in range(1, 11)) = O(20 * 2^10) = O(1)"
"class Solution(object):
    def diagonalSort(self, mat):
        lookup = collections.defaultdict(list)
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                lookup[i-j].append(mat[i][j])
        for v in lookup.values():
            v.sort()
        for i in reversed(range(len(mat))):
            for j in reversed(range(len(mat[0]))):
                mat[i][j] = lookup[i-j].pop()
        return mat","# Time:  O(m * n * log(min(m, n))"
"class Solution(object):
    def maxKelements(self, nums, k):
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        result = 0
        for i, x in enumerate(nums):
            nums[i] = -x
        heapq.heapify(nums)
        for _ in range(k):
            if not nums:
                break
            x = -heapq.heappop(nums)
            result += x
            nx = ceil_divide(x, 3)
            if not nx:
                continue
            heapq.heappush(nums, -nx)
        return result
    


import heapq
",# Time:  O(n + klogn)
"class Solution2(object):
    def maxKelements(self, nums, k):
        def ceil_divide(a, b):
            return (a+b-1)//b
    
        result = 0
        for i, x in enumerate(nums):
            nums[i] = -x
        heapq.heapify(nums)
        for _ in range(k):
            x = -heapq.heappop(nums)
            result += x
            heapq.heappush(nums, -ceil_divide(x, 3))
        return result
  ",# Time:  O(n + klogn)
"class Solution(object):
    def countRangeSum(self, nums, lower, upper):
        def countAndMergeSort(sums, start, end, lower, upper):
            if end - start <= 1: 
                return 0
            mid = start + (end - start) / 2
            count = countAndMergeSort(sums, start, mid, lower, upper) + \
                    countAndMergeSort(sums, mid, end, lower, upper)
            j, k, r = mid, mid, mid
            tmp = []
            for i in range(start, mid):
                while k < end and sums[k] - sums[i] < lower:
                    k += 1
                while j < end and sums[j] - sums[i] <= upper:
                    j += 1
                count += j - k

                while r < end and sums[r] < sums[i]:
                    tmp.append(sums[r])
                    r += 1
                tmp.append(sums[i])
            sums[start:start+len(tmp)] = tmp
            return count

        sums = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            sums[i + 1] = sums[i] + nums[i]
        return countAndMergeSort(sums, 0, len(sums), lower, upper)


",# Time:  O(nlogn)
"class Solution2(object):
    def countRangeSum(self, nums, lower, upper):
        def countAndMergeSort(sums, start, end, lower, upper):
            if end - start <= 0: 
                return 0

            mid = start + (end - start) / 2
            count = countAndMergeSort(sums, start, mid, lower, upper) + \
                    countAndMergeSort(sums, mid + 1, end, lower, upper)
            j, k, r = mid + 1, mid + 1, mid + 1
            tmp = []
            for i in range(start, mid + 1):
                while k <= end and sums[k] - sums[i] < lower:
                    k += 1
                while j <= end and sums[j] - sums[i] <= upper:
                    j += 1
                count += j - k

                while r <= end and sums[r] < sums[i]:
                    tmp.append(sums[r])
                    r += 1
                tmp.append(sums[i])

            sums[start:start+len(tmp)] = tmp
            return count

        sums = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            sums[i + 1] = sums[i] + nums[i]
        return countAndMergeSort(sums, 0, len(sums) - 1, lower, upper)
",# Time:  O(nlogn)
"class Solution(object):
    def kthCharacter(self, k, operations):
        result = 0
        k -= 1
        for i in range(min(len(operations), k.bit_length())):
            if k&(1<<i):
                result = (result+operations[i])%26
        return chr(ord('a')+result)",# Time:  O(logr) = O(1)
"class Solution(object):
    def maxAmount(self, initialCurrency, pairs1, rates1, pairs2, rates2):
        def BellmanFord(dist, pairs, rates):
            for _ in range(len(pairs)):
                for i in range(len(pairs)):
                    dist[pairs[i][1]] = max(dist[pairs[i][1]], dist[pairs[i][0]]*rates[i])
                    dist[pairs[i][0]] = max(dist[pairs[i][0]], dist[pairs[i][1]]*(1/rates[i]))
        
        dist = collections.defaultdict(int)
        dist[initialCurrency] = 1.0
        BellmanFord(dist, pairs1, rates1)
        BellmanFord(dist, pairs2, rates2)
        return dist[initialCurrency]
import collections


",# Time:  O(n^2)
"class Solution2(object):
    def maxAmount(self, initialCurrency, pairs1, rates1, pairs2, rates2):
        def find_adj(pairs, rates):
            adj = collections.defaultdict(list)
            for i in range(len(pairs)):
                adj[pairs[i][0]].append((pairs[i][1], rates[i]))
                adj[pairs[i][1]].append((pairs[i][0], 1/rates[i]))
            return adj

        def bfs(dist, adj):
            q = list(dist.keys())
            while q:
                new_q = []
                for u in q:
                    for v, w in adj[u]:
                        if not w*dist[u] > dist[v]:
                            continue
                        dist[v] = w*dist[u]
                        new_q.append(v)
                q = new_q
            return dist
    
        dist = collections.defaultdict(int)
        dist[initialCurrency] = 1.0
        adj1 = find_adj(pairs1, rates1)
        bfs(dist, adj1) 
        adj2 = find_adj(pairs2, rates2)
        bfs(dist, adj2) 
        return dist[initialCurrency]",# Time:  O(n^2)
"class Solution(object):
    def countExcellentPairs(self, nums, k):
        def popcount(x):
            return bin(x)[2:].count('1')

        cnt = collections.Counter(popcount(x) for x in set(nums))
        return sum(cnt[i]*cnt[j] for i in cnt.keys() for j in cnt.keys() if i+j >= k)

",# Time:  O(n + (logn)^2) = O(n)
"class Solution2(object):
    def countExcellentPairs(self, nums, k):
        def popcount(x):
            return bin(x)[2:].count('1')

        sorted_cnts = sorted(popcount(x) for x in set(nums))
        result = 0
        left, right = 0, len(sorted_cnts)-1
        while left <= right:
            if sorted_cnts[left]+sorted_cnts[right] < k:
                left += 1
            else:
                result += 1+2*((right-1)-left+1)
                right -= 1
        return result",# Time:  O(nlogn)
"class Solution(object):
    def isUgly(self, num):
        if num == 0:
            return False
        for i in [2, 3, 5]:
            while num % i == 0:
                num /= i
        return num == 1
",# Time:  O(logn) = O(1)
"class Solution(object):
    def maxFrequency(self, nums, k, numOperations):
        nums.sort()
        result = 0
        left, right = 0, -1
        cnt = collections.defaultdict(int)
        for i in range(len(nums)):
            while right+1 < len(nums) and nums[right+1]-nums[i] <= k:
                cnt[nums[right+1]] += 1 
                right += 1
            while nums[i]-nums[left] > k:
                cnt[nums[left]] -= 1
                left += 1
            result = max(result, cnt[nums[i]]+min((right-left+1)-cnt[nums[i]], numOperations))
        left = 0
        for right in range(len(nums)):
            while nums[left]+k < nums[right]-k:
                left += 1
            result = max(result, min(right-left+1, numOperations))
        return result
    
import collections


",# Time:  O(nlogn)
"class Solution2(object):
    def maxFrequency(self, nums, k, numOperations):
        cnt = collections.defaultdict(int) 
        for x in nums:
            cnt[x] += 1
        diff = defaultdict(int)
        for x in nums:
            diff[x] += 0
            diff[x-k] += 1
            diff[x+k+1] -= 1
        result = curr = 0
        for x, c in sorted(diff.items()):
            curr += c
            result = max(result, cnt[x]+min(curr-cnt[x], numOperations))
        return result",# Time:  O(nlogn)
"class Solution(object):
    def divide(self, dividend, divisor):
        result, dvd, dvs = 0, abs(dividend), abs(divisor)
        while dvd >= dvs:
            inc = dvs
            i = 0
            while dvd >= inc:
                dvd -= inc
                result += 1 << i
                inc <<= 1
                i += 1
        if dividend > 0 and divisor < 0 or dividend < 0 and divisor > 0:
            return -result
        else:
            return result

    def divide2(self, dividend, divisor):
        positive = (dividend < 0) is (divisor < 0)
        dividend, divisor = abs(dividend), abs(divisor)
        res = 0
        while dividend >= divisor:
            temp, i = divisor, 1
            while dividend >= temp:
                dividend -= temp
                res += i
                i <<= 1
                temp <<= 1
        if not positive:
            res = -res
        return min(max(-2147483648, res), 2147483647)
",# Time:  O(logn) = O(1)
"class Solution(object):
    def trailingZeroes(self, n):
        result = 0
        while n > 0:
            result += n / 5
            n /= 5
        return result
",# Time:  O(logn) = O(1)
"class Solution(object):
    def maxPossibleScore(self, start, d):
        def binary_search_right(left, right, check):
            while left <= right:
                mid = left+(right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right
    
        def check(x):
            curr = float(""-inf"")
            for i in start:
                curr = max(curr+x, i)
                if curr > i+d:
                    return False
            return True

        start.sort()
        return binary_search_right(1, start[-1]+d-start[0], check)",# Time:  O(nlogn + nlogr) = O(nlogr)
"class Solution(object):
    def isUnivalTree(self, root):
        s = [root]
        while s:
            node = s.pop()
            if not node:
                continue
            if node.val != root.val:
                return False
            s.append(node.left)
            s.append(node.right)
        return True
    ",# Time:  O(n)
"class Solution2(object):
    def isUnivalTree(self, root):
        return (not root.left or (root.left.val == root.val and self.isUnivalTree(root.left))) and \
               (not root.right or (root.right.val == root.val and self.isUnivalTree(root.right)))",# Time:  O(n)
"class Solution(object):
    def permuteUnique(self, nums):
        nums.sort()
        result = []
        used = [False] * len(nums)
        self.permuteUniqueRecu(result, used, [], nums)
        return result

    def permuteUniqueRecu(self, result, used, cur, nums):
        if len(cur) == len(nums):
            result.append(cur + [])
            return
        for i in range(len(nums)):
            if used[i] or (i > 0 and nums[i-1] == nums[i] and not used[i-1]):
                continue
            used[i] = True
            cur.append(nums[i])
            self.permuteUniqueRecu(result, used, cur, nums)
            cur.pop()
            used[i] = False
",# Time:  O(n * n!)
"class Solution2(object):
    def permuteUnique(self, nums):
        solutions = [[]]

        for num in nums:
            next = []
            for solution in solutions:
                for i in range(len(solution) + 1):
                    candidate = solution[:i] + [num] + solution[i:]
                    if candidate not in next:
                        next.append(candidate)

            solutions = next

        return solutions
",# Time:  O(n * n!)
"class Solution(object):
    def __init__(self, words):
        self.wordIndex = collections.defaultdict(list)
        for i in range(len(words)):
            self.wordIndex[words[i]].append(i)

    def shortest(self, word1, word2):
        indexes1 = self.wordIndex[word1]
        indexes2 = self.wordIndex[word2]

        i, j, dist = 0, 0, float(""inf"")
        while i < len(indexes1) and j < len(indexes2):
            dist = min(dist, abs(indexes1[i] - indexes2[j]))
            if indexes1[i] < indexes2[j]:
                i += 1
            else:
                j += 1

        return dist
","# Time:  init: O(n), lookup: O(a + b), a, b is occurences of word1, word2"
"class Solution(object):
    def findKthSmallest(self, coins, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a
        
        def lcm(a, b):
            return a//gcd(a, b)*b
        
        def check(target):
            return sum((-1 if (i+1)&1 else +1)*(target//l) for i in range(1, len(coins)+1) for l in lookup[i]) >= k

        def binary_search(left, right, check):
            while left <= right:
                mid = left+(right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        lookup = [[] for _ in range(len(coins)+1)]
        for i in range(1, len(coins)+1):
            for comb in itertools.combinations(coins, i):
                lookup[i].append(reduce(lcm, comb))
        mn = min(coins)
        l = 1
        for i in range(1, 25+1):
            l = lcm(l, i)
        return binary_search(mn, k*mn, check)

","# Time:  O(n * 2^n * (log(mx) + log(k * mn))) = O(n * 2^n * logk), mn = min(coins), mx = max(coins)"
"class Solution2(object):
    def findKthSmallest(self, coins, k):
        def popcount(x):
            return bin(x).count('1')

        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a
        
        def lcm(a, b):
            return a//gcd(a, b)*b
    
        def check(target):
            return sum((-1 if (i+1)&1 else +1)*(target//l) for i in range(1, len(coins)+1) for l in lookup[i]) >= k

        def binary_search(left, right, check):
            while left <= right:
                mid = left+(right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left
    
        lookup = [[] for _ in range(len(coins)+1)]
        for mask in range(1, 1<<len(coins)):
            lookup[popcount(mask)].append(reduce(lcm, (coins[i] for i in range(len(coins)) if mask&(1<<i))))
        mn = min(coins)
        return binary_search(mn, k*mn, check)","# Time:  O(n * 2^n * (log(mx) + log(k * mn))) = O(n * 2^n * logk), mn = min(coins), mx = max(coins)"
"class Solution(object):
    def minGroupsForValidAssignment(self, nums):
        INF = float(""inf"")

        def ceil_divide(a, b):
            return (a+b-1)//b
    
        def count(x):
            result = 0
            for c in cnt.values():
                if c%x > c//x:
                    return INF
                result += ceil_divide(c, x+1)
            return result

        cnt = collections.Counter(nums)
        for i in reversed(range(1, min(cnt.values())+1)):
            c = count(i)
            if c != INF:
                return c
        return 0",# Time:  O(min(cnt.values()) * n/min(cnt.values())) = O(n)
"class Solution(object):
    def peopleIndexes(self, favoriteCompanies):
        lookup, comps = {}, []
        for cs in favoriteCompanies:
            comps.append(set())
            for c in cs:
                if c not in lookup:
                    lookup[c] = len(lookup)
                comps[-1].add(lookup[c])
        return [i for i, c1 in enumerate(comps)
                if not any(i != j and len(c1) < len(c2) and c1 < c2
                           for j, c2 in enumerate(comps))]


class UnionFind(object):
    def __init__(self, data):
        self.data = [set(d) for d in data]
        self.set = list(range(len(data)))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return
        if len(self.data[x_root]) > len(self.data[y_root]) and \
           self.data[x_root] > self.data[y_root]:
            self.set[y_root] = x_root
        elif len(self.data[x_root]) < len(self.data[y_root]) and \
           self.data[x_root] < self.data[y_root]:
            self.set[x_root] = y_root

","# Time:  O(n * m * l + n^2 * m), n is favoriteCompanies.length"
"class Solution2(object):
    def peopleIndexes(self, favoriteCompanies):
        lookup, comps = {}, []
        for cs in favoriteCompanies:
            comps.append(set())
            for c in cs:
                if c not in lookup:
                    lookup[c] = len(lookup)
                comps[-1].add(lookup[c])
        union_find = UnionFind(comps)
        for i in range(len(comps)):
            for j in range(len(comps)):
                if j == i:
                    continue
                union_find.union_set(i, j)
        return [x for i, x in enumerate(union_find.set) if x == i]","# Time:  O(n * m * l + n^2 * m), n is favoriteCompanies.length"
"class Solution(object):
    def fourSum(self, nums, target):
        nums.sort()
        result = []
        for i in range(len(nums) - 3):
            if i and nums[i] == nums[i - 1]:
                continue
            for j in range(i + 1, len(nums) - 2):
                if j != i + 1 and nums[j] == nums[j - 1]:
                    continue
                total = target - nums[i] - nums[j]
                left, right = j + 1, len(nums) - 1
                while left < right:
                    if nums[left] + nums[right] == total:
                        result.append([nums[i], nums[j], nums[left], nums[right]])
                        right -= 1
                        left += 1
                        while left < right and nums[left] == nums[left - 1]:
                            left += 1
                        while left < right and nums[right] == nums[right + 1]:
                            right -= 1
                    elif nums[left] + nums[right] > total:
                        right -= 1
                    else:
                        left += 1
        return result

",# Time:  O(n^3)
"class Solution2(object):
    def fourSum(self, nums, target):
        nums, result, lookup = sorted(nums), [], collections.defaultdict(list)
        for i in range(0, len(nums) - 1):
            for j in range(i + 1, len(nums)):
                is_duplicated = False
                for [x, y] in lookup[nums[i] + nums[j]]:
                    if nums[x] == nums[i]:
                        is_duplicated = True
                        break
                if not is_duplicated:
                    lookup[nums[i] + nums[j]].append([i, j])
        ans = {}
        for c in range(2, len(nums)):
            for d in range(c+1, len(nums)):
                if target - nums[c] - nums[d] in lookup:
                    for [a, b] in lookup[target - nums[c] - nums[d]]:
                        if b < c:
                            quad = [nums[a], nums[b], nums[c], nums[d]]
                            quad_hash = "" "".join(str(quad))
                            if quad_hash not in ans:
                                ans[quad_hash] = True
                                result.append(quad)
        return result

",# Time:  O(n^2 * p)
"class Solution3(object):
    def fourSum(self, nums, target):
        nums, result, lookup = sorted(nums), [], collections.defaultdict(list)
        for i in range(0, len(nums) - 1):
            for j in range(i + 1, len(nums)):
                lookup[nums[i] + nums[j]].append([i, j])

        for i in list(lookup.keys()):
            if target - i in lookup:
                for x in lookup[i]:
                    for y in lookup[target - i]:
                        [a, b], [c, d] = x, y
                        if a is not c and a is not d and \
                           b is not c and b is not d:
                            quad = sorted([nums[a], nums[b], nums[c], nums[d]])
                            if quad not in result:
                                result.append(quad)
        return sorted(result)
",# Time:  O(n^2 * p) ~ O(n^4)
"class Solution(object):
    def binaryGap(self, N):
        result = 0
        last = None
        for i in range(32):
            if (N >> i) & 1:
                if last is not None:
                    result = max(result, i-last)
                last = i
        return result
",# Time:  O(logn) = O(1) due to n is a 32-bit number
"class Solution(object):
    def findRedundantDirectedConnection(self, edges):
        cand1, cand2 = [], []
        parent = {}
        for edge in edges:
            if edge[1] not in parent:
                parent[edge[1]] = edge[0]
            else:
                cand1 = [parent[edge[1]], edge[1]]
                cand2 = edge

        union_find = UnionFind(len(edges)+1)
        for edge in edges:
            if edge == cand2:
                continue
            if not union_find.union_set(*edge):
                return cand1 if cand2 else edge
        return cand2
","# Time:  O(nlog*n) ~= O(n), n is the length of the positions"
"class Solution(object):
    def garbageCollection(self, garbage, travel):
        result = 0
        lookup = {}
        for i in range(len(garbage)):
            for c in garbage[i]:
                lookup[c] = i
            if i+1 < len(travel):
                travel[i+1] += travel[i]
            result += len(garbage[i])
        result += sum(travel[v-1] for _, v in lookup.items() if v-1 >= 0)
        return result

","# Time:  O(n * l), l = max(len(g) for g in garbage) = O(10)"
"class Solution2(object):
    def garbageCollection(self, garbage, travel):
        result = 0
        for t in 'MPG':
            curr = 0
            for i in range(len(garbage)):
                cnt = garbage[i].count(t) 
                if cnt:
                    result += curr+cnt
                    curr = 0
                if i < len(travel):
                    curr += travel[i]
        return result","# Time:  O(n * l), l = max(len(g) for g in garbage) = O(10)"
"class Solution(object):
    def getHint(self, secret, guess):
        A, B = 0, 0
        lookup = defaultdict(int)
        for s, g in zip(secret, guess):
            if s == g:
                A += 1
            else:
                B += int(lookup[s] < 0) + int(lookup[g] > 0)
                lookup[s] += 1
                lookup[g] -= 1
        return ""%dA%dB"" % (A, B)


",# Time:  O(n)
"class Solution2(object):
    def getHint(self, secret, guess):
        A = sum(map(operator.eq, secret, guess))
        B = sum((Counter(secret) & Counter(guess)).values()) - A
        return ""%dA%dB"" % (A, B)
",# Time:  O(n)
"class Solution(object):
    def minEdgeReversals(self, n, edges):
        def iter_dfs1():
            result = 0
            stk = [(0, -1)]
            while stk:
                u, p = stk.pop()
                for v in adj[u].keys():
                    if v == p:
                        continue
                    result += adj[u][v]
                    stk.append((v, u))
            return result

        def iter_dfs2(curr):
            result = [-1]*n
            stk = [(0, curr)]
            while stk:
                u, curr = stk.pop()
                result[u] = curr
                for v in adj[u].keys():
                    if result[v] == -1:
                        stk.append((v, curr-adj[u][v]+adj[v][u]))
            return result
    
        adj = collections.defaultdict(dict)
        for u, v in edges:
            adj[u][v] = 0
            adj[v][u] = 1
        return iter_dfs2(iter_dfs1())
",# Time:  O(n)
"class Solution2(object):
    def minEdgeReversals(self, n, edges):
        def dfs1(u, p):
            return sum(adj[u][v]+dfs1(v, u) for v in adj[u] if v != p)

        def dfs2(u, curr):
            result[u] = curr
            for v in adj[u]:
                if result[v] == -1:
                    dfs2(v, curr-adj[u][v]+adj[v][u])
    
        adj = collections.defaultdict(dict)
        for u, v in edges:
            adj[u][v] = 0
            adj[v][u] = 1
        result = [-1]*n
        dfs2(0, dfs1(0, -1))
        return result",# Time:  O(n)
"class Solution(object):
    def __init__(self):
        self.__random_length = 6
        self.__tiny_url = ""http://tinyurl.com/""
        self.__alphabet = ""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""
        self.__lookup = {}

    def encode(self, longUrl):
        def getRand():
            rand = []
            for _ in range(self.__random_length):
                rand += self.__alphabet[random.randint(0, len(self.__alphabet)-1)]
            return """".join(rand)

        key = getRand()
        while key in self.__lookup:
            key = getRand()
        self.__lookup[key] = longUrl
        return self.__tiny_url + key

    def decode(self, shortUrl):
        return self.__lookup[shortUrl[len(self.__tiny_url):]]


from hashlib import sha256

",# Time:  O(1)
"class Solution2(object):

    def __init__(self):
        self._cache = {}
        self.url = 'http://tinyurl.com/'

    def encode(self, long_url):
        key = sha256(long_url.encode()).hexdigest()[:6]
        self._cache[key] = long_url
        return self.url + key

    def decode(self, short_url):
        key = short_url.replace(self.url, '')
        return self._cache[key]

",# Time:  O(1)
"class Solution(object):
    def checkIfCanBreak(self, s1, s2):
        def is_break(count1, count2):
            curr1, curr2 = 0, 0
            for c in string.ascii_lowercase:
                curr1 += count1[c]
                curr2 += count2[c]
                if curr1 < curr2:
                    return False
            return True

        count1, count2 = collections.Counter(s1), collections.Counter(s2)
        return is_break(count1, count2) or is_break(count2, count1)
import itertools

",# Time:  O(n)
"class Solution2(object):
    def checkIfCanBreak(self, s1, s2):
        return not {1, -1}.issubset(set(cmp(a, b) for a, b in zip(sorted(s1), sorted(s2))))

",# Time:  O(n)
"class Solution3(object):
    def checkIfCanBreak(self, s1, s2):
        s1, s2 = sorted(s1), sorted(s2)
        return all(a >= b for a, b in zip(s1, s2)) or \
               all(a <= b for a, b in zip(s1, s2))",# Time:  O(nlogn)
"class Solution(object):
    def minimumLines(self, points):
        def gcd(a, b): 
            while b:
                a, b = b, a % b
            return a

        def popcount(x):
            result = 0
            while x:
                x &= (x-1)
                result += 1
            return result

        def ceil_divide(a, b):
            return (a+b-1)//b
        
        lookup = collections.defaultdict(set)               
        for i, (x1, y1) in enumerate(points):
            for j in range(i+1, len(points)):
                x2, y2 = points[j]
                a, b, c = (y2-y1), -(x2-x1), x1*(y2-y1)-y1*(x2-x1) 
                g = gcd(gcd(a, b), c)
                a, b, c = a//g, b//g, c//g
                lookup[(a, b, c)].add((x1, y1))
                lookup[(a, b, c)].add((x2, y2))
        lines = [l for l, p in lookup.items() if len(p) > 2] 
        assert(len(lines) <= (len(points))//2) 
        result = float(""inf"")
        for mask in range(1<<len(lines)):
            covered = set()
            bit, i = 1, 0
            while bit <= mask:
                if mask&bit:
                    covered.update(lookup[lines[i]])
                bit <<= 1                        
                i += 1
            result = min(result, popcount(mask) + ceil_divide(len(points)-len(covered), 2))
        return result",# Time:  O(n^2 + n*2^n) = O(n*2^n)
"class Solution(object):
    def isMatch(self, s, p):
        count = 0 
        p_ptr, s_ptr, last_s_ptr, last_p_ptr = 0, 0, -1, -1
        while s_ptr < len(s):
            if p_ptr < len(p) and (s[s_ptr] == p[p_ptr] or p[p_ptr] == '?'):
                s_ptr += 1
                p_ptr += 1
            elif p_ptr < len(p) and p[p_ptr] == '*':
                p_ptr += 1
                last_s_ptr = s_ptr
                last_p_ptr = p_ptr
            elif last_p_ptr != -1:
                last_s_ptr += 1
                s_ptr = last_s_ptr
                p_ptr = last_p_ptr
            else:
                assert(count <= (len(p)+1) * (len(s)+1))
                return False
            count += 1 
 
        while p_ptr < len(p) and p[p_ptr] == '*':
            p_ptr += 1
            count += 1 

        assert(count <= (len(p)+1) * (len(s)+1))
        return p_ptr == len(p)


",# Time:  O(m + n) ~ O(m * n)
"class Solution2(object):
    def isMatch(self, s, p):
        k = 2
        result = [[False for j in range(len(p) + 1)] for i in range(k)]

        result[0][0] = True
        for i in range(1, len(p) + 1):
            if p[i-1] == '*':
                result[0][i] = result[0][i-1]
        for i in range(1,len(s) + 1):
            result[i % k][0] = False
            for j in range(1, len(p) + 1):
                if p[j-1] != '*':
                    result[i % k][j] = result[(i-1) % k][j-1] and (s[i-1] == p[j-1] or p[j-1] == '?')
                else:
                    result[i % k][j] = result[i % k][j-1] or result[(i-1) % k][j]

        return result[len(s) % k][len(p)]


",# Time:  O(m * n)
"class Solution3(object):
    def isMatch(self, s, p):
        result = [[False for j in range(len(p) + 1)] for i in range(len(s) + 1)]

        result[0][0] = True
        for i in range(1, len(p) + 1):
            if p[i-1] == '*':
                result[0][i] = result[0][i-1]
        for i in range(1,len(s) + 1):
            result[i][0] = False
            for j in range(1, len(p) + 1):
                if p[j-1] != '*':
                    result[i][j] = result[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == '?')
                else:
                    result[i][j] = result[i][j-1] or result[i-1][j]

        return result[len(s)][len(p)]


",# Time:  O(m * n)
"class Solution4(object):
    def isMatch(self, s, p):
        if not p or not s:
            return not s and not p

        if p[0] != '*':
            if p[0] == s[0] or p[0] == '?':
                return self.isMatch(s[1:], p[1:])
            else:
                return False
        else:
            while len(s) > 0:
                if self.isMatch(s, p[1:]):
                    return True
                s = s[1:]
            return self.isMatch(s, p[1:])
",# Time:  O(m * n)
"class Solution(object):
    def lemonadeChange(self, bills):
        coins = [20, 10, 5]
        counts = collections.defaultdict(int)
        for bill in bills:
            counts[bill] += 1
            change = bill - coins[-1]
            for coin in coins:
                if change == 0:
                    break
                if change >= coin:
                    count = min(counts[coin], change//coin)
                    counts[coin] -= count
                    change -= coin * count
            if change != 0:
                return False
        return True

",# Time:  O(n)
"class Solution2(object):
    def lemonadeChange(self, bills):
        five, ten = 0, 0
        for bill in bills:
            if bill == 5:
                five += 1
            elif bill == 10:
                if not five:
                    return False
                five -= 1
                ten += 1
            else:
                if ten and five:
                    ten -= 1
                    five -= 1
                elif five >= 3:
                    five -= 3
                else:
                    return False
        return True
",# Time:  O(n)
"class Solution(object):
    def isDecomposable(self, s):
        if len(s)%3 != 2:
            return False
        for left in range(0, len(s), 3):
            if any(s[i] != s[i-1] for i in range(left+1, min(left+3, len(s)))):
                break            
        for right in reversed(range(left+1, len(s), 3)):
            if any(s[i] != s[i+1] for i in reversed(range(max(right-2, left), right))):
                break
        return right-left == 1

",# Time:  O(n)
"class Solution2(object):
    def isDecomposable(self, s):
        found, i = False, 0
        while i < len(s):
            l = 1
            for j in range(i+1, min(i+3, len(s))):
                if s[j] != s[i]:
                    break
                l += 1
            if l < 2:
                return False
            if l == 2:
                if found:
                    return False
                found = True
            i += l  
        return found",# Time:  O(n)
"class Solution3(object):
    def isDecomposable(self, s):
        found, l = False, 0
        for i, c in enumerate(s):
            if not l or c != s[i-1]:
                if l:
                    return False
                l = 1
                continue
            l += 1
            if l == 2:
                if i == len(s)-1 or s[i] != s[i+1]:
                    if found:
                        return False
                    found, l = True, 0
            elif l == 3:
                 l =  0
        return found",# Time:  O(n)
"class Solution(object):
    def restoreIpAddresses(self, s):
        result = []
        self.restoreIpAddressesRecur(result, s, 0, """", 0)
        return result

    def restoreIpAddressesRecur(self, result, s, start, current, dots):
        if (4 - dots) * 3 < len(s) - start or (4 - dots) > len(s) - start:
            return

        if start == len(s) and dots == 4:
            result.append(current[:-1])
        else:
            for i in range(start, start + 3):
                if len(s) > i and self.isValid(s[start:i + 1]):
                    current += s[start:i + 1] + '.'
                    self.restoreIpAddressesRecur(result, s, i + 1, current, dots + 1)
                    current = current[:-(i - start + 2)]

    def isValid(self, s):
        if len(s) == 0 or (s[0] == '0' and s != ""0""):
            return False
        return int(s) < 256
",# Time:  O(n^m) = O(3^4)
"class Solution(object):
    def containVirus(self, grid):
        directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]

        def dfs(grid, r, c, lookup, regions, frontiers, perimeters):
            if (r, c) in lookup:
                return
            lookup.add((r, c))
            regions[-1].add((r, c))
            for d in directions:
                nr, nc = r+d[0], c+d[1]
                if not (0 <= nr < len(grid) and \
                        0 <= nc < len(grid[r])):
                    continue
                if grid[nr][nc] == 1:
                    dfs(grid, nr, nc, lookup, regions, frontiers, perimeters)
                elif grid[nr][nc] == 0:
                    frontiers[-1].add((nr, nc))
                    perimeters[-1] += 1

        result = 0
        while True:
            lookup, regions, frontiers, perimeters = set(), [], [], []
            for r, row in enumerate(grid):
                for c, val in enumerate(row):
                    if val == 1 and (r, c) not in lookup:
                        regions.append(set())
                        frontiers.append(set())
                        perimeters.append(0)
                        dfs(grid, r, c, lookup, regions, frontiers, perimeters)

            if not regions: break

            triage_idx = frontiers.index(max(frontiers, key = len))
            for i, region in enumerate(regions):
                if i == triage_idx:
                    result += perimeters[i]
                    for r, c in region:
                        grid[r][c] = -1
                    continue
                for r, c in region:
                    for d in directions:
                        nr, nc = r+d[0], c+d[1]
                        if not (0 <= nr < len(grid) and \
                                0 <= nc < len(grid[r])):
                            continue
                        if grid[nr][nc] == 0:
                            grid[nr][nc] = 1

        return result
","# Time:  O((m * n)^(4/3)), days = O((m * n)^(1/3))"
"class Solution(object):
    def nthSuperUglyNumber(self, n, primes):
        heap, uglies, idx, ugly_by_last_prime = [], [0] * n, [0] * len(primes), [0] * n
        uglies[0] = 1

        for k, p in enumerate(primes):
            heapq.heappush(heap, (p, k))

        for i in range(1, n):
            uglies[i], k = heapq.heappop(heap)
            ugly_by_last_prime[i] = k
            idx[k] += 1
            while ugly_by_last_prime[idx[k]] > k:
                idx[k] += 1
            heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))

        return uglies[-1]
",# Time:  O(n * k)
"class Solution2(object):
    def nthSuperUglyNumber(self, n, primes):
        uglies, idx, heap, ugly_set = [0] * n, [0] * len(primes), [], set([1])
        uglies[0] = 1

        for k, p in enumerate(primes):
            heapq.heappush(heap, (p, k))
            ugly_set.add(p)

        for i in range(1, n):
            uglies[i], k = heapq.heappop(heap)
            while (primes[k] * uglies[idx[k]]) in ugly_set:
                idx[k] += 1
            heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))
            ugly_set.add(primes[k] * uglies[idx[k]])

        return uglies[-1]
",# Time:  O(n * k)
"class Solution3(object):
    def nthSuperUglyNumber(self, n, primes):
        uglies, idx, heap = [1], [0] * len(primes), []
        for k, p in enumerate(primes):
            heapq.heappush(heap, (p, k))

        for i in range(1, n):
            min_val, k = heap[0]
            uglies += [min_val]

            while heap[0][0] == min_val: 
                min_val, k = heapq.heappop(heap)
                idx[k] += 1
                heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))

        return uglies[-1]
",# Time:  O(n * logk) ~ O(n * klogk)
"class Solution4(object):
    def nthSuperUglyNumber(self, n, primes):
        uglies = [0] * n
        uglies[0] = 1
        ugly_by_prime = list(primes)
        idx = [0] * len(primes)

        for i in range(1, n):
            uglies[i] = min(ugly_by_prime)
            for k in range(len(primes)):
                if uglies[i] == ugly_by_prime[k]:
                    idx[k] += 1
                    ugly_by_prime[k] = primes[k] * uglies[idx[k]]

        return uglies[-1]
",# Time:  O(n * k)
"class Solution5(object):
    def nthSuperUglyNumber(self, n, primes):
        ugly_number = 0

        heap = []
        heapq.heappush(heap, 1)
        for p in primes:
            heapq.heappush(heap, p)
        for _ in range(n):
            ugly_number = heapq.heappop(heap)
            for i in range(len(primes)):
                if ugly_number % primes[i] == 0:
                    for j in range(i + 1):
                        heapq.heappush(heap, ugly_number * primes[j])
                    break

        return ugly_number
",# Time:  O(n * logk) ~ O(n * klogk)
"class Solution(object):
    def numberOfPermutations(self, n, requirements):
        MOD = 10**9+7
        lookup = [-1]*n
        for i, c in requirements:
            lookup[i] = c
        dp = [1]
        prev = 0
        for i in range(n):
            if lookup[i] != -1: 
                dp = [reduce(lambda total, i: (total+dp[i])%MOD, range(max((lookup[i]-i)-prev, 0), min((lookup[i]+1)-prev, len(dp))), 0)]
                prev = lookup[i]
                continue
            new_dp = [0]*min(len(dp)+((i+1)-1), (lookup[-1]+1)-prev)
            for j in range(len(new_dp)):
                new_dp[j] = dp[j] if j < len(dp) else 0
                if j-1 >= 0:
                    new_dp[j] = (new_dp[j]+new_dp[j-1])%MOD
                if j-(i+1) >= 0:
                    new_dp[j] = (new_dp[j]-dp[j-(i+1)])%MOD
            dp = new_dp
        return dp[-1]

","# Time:  O(n * k), k = max(cnt for _, cnt in requirements)"
"class Solution2(object):
    def numberOfPermutations(self, n, requirements):
        MOD = 10**9+7
        lookup = [-1]*n
        for i, c in requirements:
            lookup[i] = c
        dp = [0]*(lookup[-1]+1)
        dp[0] = 1
        for i in range(n):
            new_dp = [0]*len(dp)
            if lookup[i] != -1: 
                new_dp[lookup[i]] = reduce(lambda total, i: (total+dp[i])%MOD, range(max(lookup[i]-i, 0), lookup[i]+1), 0)
            else:
                for j in range(len(dp)):
                    new_dp[j] = dp[j]
                    if j-1 >= 0:
                        new_dp[j] = (new_dp[j]+new_dp[j-1])%MOD
                    if j-(i+1) >= 0:
                        new_dp[j] = (new_dp[j]-dp[j-(i+1)])%MOD
            dp = new_dp
        return dp[-1]

","# Time:  O(n * k), k = max(cnt for _, cnt in requirements)"
"class Solution3(object):
    def numberOfPermutations(self, n, requirements):
        MOD = 10**9+7
        lookup = [-1]*n
        for i, c in requirements:
            lookup[i] = c
        dp = [0]*(lookup[-1]+1)
        dp[0] = 1
        for i in range(n):
            new_dp = [0]*len(dp)
            curr = 0
            for j in range(len(dp)):
                curr = (curr+dp[j])%MOD
                if j-(i+1) >= 0:
                    curr = (curr-dp[j-(i+1)])%MOD
                new_dp[j] = curr if lookup[i] == -1 or lookup[i] == j else 0
            dp = new_dp
        return dp[-1]

","# Time:  O(n * k), k = max(cnt for _, cnt in requirements)"
"class Solution4(object):
    def numberOfPermutations(self, n, requirements):
        MOD = 10**9+7
        lookup = [-1]*n
        for i, c in requirements:
            lookup[i] = c
        dp = [0]*(lookup[-1]+1)
        dp[0] = 1
        for i in range(n):
            dp = [reduce(lambda total, k: (total+dp[j-k])%MOD, range(min(i+1, j+1)), 0) if lookup[i] == -1 or lookup[i] == j else 0 for j in range(len(dp))]
        return dp[-1]%MOD

","# Time:  O(n^2 * k), k = max(cnt for _, cnt in requirements)"
"class Solution_ConstructPermutation(object):
    def numberOfPermutations(self, n, requirements):
        MOD = 10**9+7
        lookup = [-1]*n
        for i, c in requirements:
            lookup[i] = c
        dp = [[] for _ in range(lookup[-1]+1)]
        dp[0].append([])
        for i in range(n):
            dp = [[[x+int(x >= i-k) for x in p]+[i-k] for k in range(min(i+1, j+1)) for p in dp[j-k]] if lookup[i] == -1 or lookup[i] == j else [] for j in range(len(dp))]
        for p in dp[-1]:
            curr = 0
            for i in range(n):
                for j in range(i):
                    curr += int(p[j] > p[i])
                if lookup[i] != -1:
                    assert(lookup[i] == curr)
        return len(dp[-1])%MOD","# Time:  O(n^2 * k), k = max(cnt for _, cnt in requirements)"
"class Solution(object):
    def isMatch(self, s, p):
        k = 3
        result = [[False for j in range(len(p) + 1)] for i in range(k)]

        result[0][0] = True
        for i in range(2, len(p) + 1):
            if p[i-1] == '*':
                result[0][i] = result[0][i-2]

        for i in range(1,len(s) + 1):
            if i > 1:
                result[0][0] = False
            for j in range(1, len(p) + 1):
                if p[j-1] != '*':
                    result[i % k][j] = result[(i-1) % k][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.')
                else:
                    result[i % k][j] = result[i % k][j-2] or (result[(i-1) % k][j] and (s[i-1] == p[j-2] or p[j-2] == '.'))

        return result[len(s) % k][len(p)]

",# Time:  O(m * n)
"class Solution2(object):
    def isMatch(self, s, p):
        result = [[False for j in range(len(p) + 1)] for i in range(len(s) + 1)]

        result[0][0] = True
        for i in range(2, len(p) + 1):
            if p[i-1] == '*':
                result[0][i] = result[0][i-2]

        for i in range(1,len(s) + 1):
            for j in range(1, len(p) + 1):
                if p[j-1] != '*':
                    result[i][j] = result[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.')
                else:
                    result[i][j] = result[i][j-2] or (result[i-1][j] and (s[i-1] == p[j-2] or p[j-2] == '.'))

        return result[len(s)][len(p)]

",# Time:  O(m * n)
"class Solution3(object):
    def isMatch(self, s, p):
        p_ptr, s_ptr, last_s_ptr, last_p_ptr = 0, 0, -1, -1
        last_ptr = []
        while s_ptr < len(s):
            if p_ptr < len(p) and (p_ptr == len(p) - 1 or p[p_ptr + 1] != '*') and \
            (s_ptr < len(s) and (p[p_ptr] == s[s_ptr] or p[p_ptr] == '.')):
                    s_ptr += 1
                    p_ptr += 1
            elif p_ptr < len(p) - 1 and (p_ptr != len(p) - 1 and p[p_ptr + 1] == '*'):
                p_ptr += 2
                last_ptr.append([s_ptr, p_ptr])
            elif  last_ptr:
                [last_s_ptr, last_p_ptr] = last_ptr.pop()
                while last_ptr and p[last_p_ptr - 2] != s[last_s_ptr] and p[last_p_ptr - 2] != '.':
                    [last_s_ptr, last_p_ptr] = last_ptr.pop()

                if p[last_p_ptr - 2] == s[last_s_ptr] or p[last_p_ptr - 2] == '.':
                    last_s_ptr += 1
                    s_ptr = last_s_ptr
                    p_ptr = last_p_ptr
                    last_ptr.append([s_ptr, p_ptr])
                else:
                    return False
            else:
                return False

        while p_ptr < len(p) - 1 and p[p_ptr] == '.' and p[p_ptr + 1] == '*':
            p_ptr += 2

        return p_ptr == len(p)

",# Time:  O(m * n)
"class Solution4(object):
    def isMatch(self, s, p):
        if not p:
            return not s

        if len(p) == 1 or p[1] != '*':
            if len(s) > 0 and (p[0] == s[0] or p[0] == '.'):
                return self.isMatch(s[1:], p[1:])
            else:
                return False
        else:
            while len(s) > 0 and (p[0] == s[0] or p[0] == '.'):
                if self.isMatch(s, p[2:]):
                    return True
                s = s[1:]
            return self.isMatch(s, p[2:])
",# Time:  O(m * n)
"class Solution(object):
    def minimumMoves(self, grid):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 

        def dist(a, b):
            return abs(a[0]-b[0])+abs(a[1]-b[1])

        src, dst = [], []
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]-1 >= 0:
                    src.extend([(i, j)]*(grid[i][j]-1))
                else:
                    dst.append((i, j))
        adj = [[dist(src[i], dst[j]) for j in range(len(dst))] for i in range(len(src))]
        return hungarian(adj)[0]

","# Time:  O(max(x^2 * y)) = O(n^3), n = len(grid)*len(grid[0]), y = len(zero), x = n-y"
"class Solution2(object):
    def minimumMoves(self, grid):
        def dist(a, b):
            return abs(a[0]-b[0])+abs(a[1]-b[1])

        src, dst = [], []
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]-1 >= 0:
                    src.extend([(i, j)]*(grid[i][j]-1))
                else:
                    dst.append((i, j))
        adj = [[dist(src[i], dst[j]) for j in range(len(dst))] for i in range(len(src))]
        return sum(adj[i][j] for i, j in zip(*hungarian(adj)))    

","# Time:  O(max(x^2 * y)) = O(n^2), n = len(grid)*len(grid[0]), y = len(zero), x = n-y"
"class Solution3(object):
    def minimumMoves(self, grid):
        def dist(a, b):
            return abs(a[0]-b[0])+abs(a[1]-b[1])

        def backtracking(curr):
            if curr == len(zero):
                return 0
            result = float(""inf"")
            i, j = zero[curr]
            for ni in range(len(grid)):
                for nj in range(len(grid[0])):
                    if not (grid[ni][nj] >= 2):
                        continue
                    grid[ni][nj] -= 1
                    result = min(result, dist((i, j), (ni, nj))+backtracking(curr+1))
                    grid[ni][nj] += 1
            return result

        zero = [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 0]
        return backtracking(0)","# Time:  O(max(x^y)) = O((n/2)^(n/2))) = O(5^5), n = len(grid)*len(grid[0]), y = len(zero), x = n-y"
"class Solution(object):
    def closestCost(self, baseCosts, toppingCosts, target):
        max_count = 2
        max_base, max_topping = max(baseCosts), max(toppingCosts)
        dp = [False]*(max(max_base, target+max_topping//2)+1)
        for b in baseCosts:
            dp[b] = True
        for t in toppingCosts:
            for _ in range(max_count):
                for i in reversed(range(len(dp)-t)):
                    if dp[i]:
                        dp[i+t] = True
        result = float(""inf"")
        for i in range(1, len(dp)):
            if not dp[i]:
                continue
            if abs(i-target) < abs(result-target):
                result = i
            if i >= target:
                break
        return result
    
    ","# Time:  O(m * max(max_base, target + max_topping / 2)) ~= O(m * t)"
"class Solution2(object):
    def closestCost(self, baseCosts, toppingCosts, target):
        max_count = 2
        def backtracking(toppingCosts, i, cost, target, lookup, result):
            if (i, cost) in lookup:
                return
            lookup.add((i, cost))
            if cost >= target or i == len(toppingCosts):
                if (abs(cost-target), cost) < (abs(result[0]-target), result[0]):
                    result[0] = cost
                return
            for j in range(max_count+1):
                backtracking(toppingCosts, i+1, cost+j*toppingCosts[i], target, lookup, result)

        result = [float(""inf"")]
        lookup = set()
        for b in baseCosts:
            backtracking(toppingCosts, 0, b, target, lookup, result)
        return result[0]

","# Time:  O(m * max(max_base, target + max_topping / 2)) ~= O(m * t)"
"class Solution3(object):
    def closestCost(self, baseCosts, toppingCosts, target):
        max_count = 2
        combs = set([0])
        for t in toppingCosts:
            combs = set([c+i*t for c in combs for i in range(max_count+1)])
        result, combs = float(""inf""), sorted(combs)
        for b in baseCosts:
            idx = bisect.bisect_left(combs, target-b)
            if idx < len(combs):
                result = min(result, b+combs[idx], key=lambda x: (abs(x-target), x))
            if idx > 0:
                result = min(result, b+combs[idx-1], key=lambda x: (abs(x-target), x))        
        return result

",# Time:  O(3^m*log(3^m)) + O(n*log(3^m)) = O(m*(3^m + n))
"class Solution4(object):
    def closestCost(self, baseCosts, toppingCosts, target):
        max_count = 2
        combs = set([0])
        for t in toppingCosts:
            combs = set([c+i*t for c in combs for i in range(max_count+1)])
        result = float(""inf"")
        for b in baseCosts:
            for c in combs:
                result = min(result, b+c, key=lambda x: (abs(x-target), x))      
        return result",# Time:  O(n * 3^m)
"class Solution(object):
    def minimumHammingDistance(self, source, target, allowedSwaps):
        def iter_flood_fill(adj, node, lookup, idxs):
            stk = [node]
            while stk:
                node = stk.pop()
                if node in lookup:
                    continue
                lookup.add(node)
                idxs.append(node)
                for child in adj[node]:
                    stk.append(child)

        adj = [set() for i in range(len(source))]
        for i, j in allowedSwaps:
            adj[i].add(j)
            adj[j].add(i)
        result = 0
        lookup = set()
        for i in range(len(source)):
            if i in lookup:
                continue
            idxs = []
            iter_flood_fill(adj, i, lookup, idxs)
            source_cnt = collections.Counter([source[i] for i in idxs])
            target_cnt = collections.Counter([target[i] for i in idxs])
            diff = source_cnt-target_cnt
            result += sum(diff.values())
        return result

",# Time:  O(n)
"class Solution2(object):
    def minimumHammingDistance(self, source, target, allowedSwaps):
        uf = UnionFind(len(source))
        for x, y in allowedSwaps: 
            uf.union_set(x, y)
        groups = collections.defaultdict(set)
        for i in range(len(source)):
            groups[uf.find_set(i)].add(i)
        result = 0
        for idxs in groups.values():
            source_cnt = collections.Counter([source[i] for i in idxs])
            target_cnt = collections.Counter([target[i] for i in idxs])
            diff = source_cnt-target_cnt
            result += sum(diff.values())
        return result",# Time:  O(n * α(n)) ~= O(n)
"class Solution(object):
    def checkMove(self, board, rMove, cMove, color):
        def check(board, color, r, c, dr, dc):
            l = 2
            while 0 <= r < len(board) and 0 <= c < len(board[0]) and board[r][c] != '.':
                if board[r][c] == color:
                    return l >= 3    
                r += dr
                c += dc
                l += 1
            return False

        directions = [(0, -1), (0, 1), (-1, 0), (1, 0),
                      (-1, -1), (1, -1), (-1, 1), (1, 1)]
        for dr, dc in directions:
            r, c = rMove+dr, cMove+dc
            if check(board, color, r, c, dr, dc):
                return True
        return False","# Time:  O(8 * n) = O(1), grid is a n x n board and n = 8"
"class Solution(object):
    def networkBecomesIdle(self, edges, patience):
        adj = [[] for _ in range(len(patience))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        q = [0]
        lookup = [False]*len(patience)
        lookup[0] = True
        step = 1
        result = 0
        while q:
            new_q = []
            for u in q:
                for v in adj[u]:
                    if lookup[v]:
                        continue
                    lookup[v] = True
                    new_q.append(v)
                    result = max(result, ((step*2)-1)//patience[v]*patience[v] + (step*2))
            q = new_q
            step += 1
        return 1+result","# Time:  O(|V| + |E|) = O(|E|) since graph is connected, O(|E|) >= O(|V|) "
"class Solution(object):
    def wiggleSort(self, nums):
        nums.sort()
        mid = (len(nums) - 1) / 2
        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]

",# Time:  O(nlogn)
"class Solution2(object):
    def wiggleSort(self, nums):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def reversedTriPartitionWithVI(nums, val):
            def idx(i, N):
                return (1 + 2 * (i)) % N

            N = len(nums) / 2 * 2 + 1
            i, j, n = 0, 0, len(nums) - 1
            while j <= n:
                if nums[idx(j, N)] > val:
                    nums[idx(i, N)], nums[idx(j, N)] = nums[idx(j, N)], nums[idx(i, N)]
                    i += 1
                    j += 1
                elif nums[idx(j, N)] < val:
                    nums[idx(j, N)], nums[idx(n, N)] = nums[idx(n, N)], nums[idx(j, N)]
                    n -= 1
                else:
                    j += 1

        mid = (len(nums)-1)//2
        nth_element(nums, mid)
        reversedTriPartitionWithVI(nums, nums[mid])",# Time:  O(n) ~ O(n^2)
"class Solution(object):
    def isSubstringPresent(self, s):
        lookup = [[False]*26 for _ in range(26)]
        for i in range(len(s)-1):
            lookup[ord(s[i])-ord('a')][ord(s[i+1])-ord('a')] = True
        return any(lookup[ord(s[i+1])-ord('a')][ord(s[i])-ord('a')]  for i in range(len(s)-1))
import collections


",# Time:  O(n)
"class Solution2(object):
    def isSubstringPresent(self, s):
        lookup = collections.defaultdict(set)
        for i in range(len(s)-1):
            lookup[s[i]].add(s[i+1])
        return any(s[i] in lookup[s[i+1]] for i in range(len(s)-1))",# Time:  O(n)
"class Solution2(object):
    def minCostII(self, costs):
        return min(reduce(self.combine, costs)) if costs else 0

    def combine(self, tmp, house):
        smallest, k, i = min(tmp), len(tmp), tmp.index(min(tmp))
        tmp, tmp[i] = [smallest] * k, min(tmp[:i] + tmp[i+1:])
        return list(map(sum, list(zip(tmp, house))))

",# Time:  O(n * k)
"class Solution2(object):
    def minCostII(self, costs):
        if not costs:
            return 0

        n = len(costs)
        k = len(costs[0])
        min_cost = [costs[0], [0] * k]
        for i in range(1, n):
            smallest, second_smallest = float(""inf""), float(""inf"")
            for j in range(k):
                if min_cost[(i - 1) % 2][j] < smallest:
                    smallest, second_smallest = min_cost[(i - 1) % 2][j], smallest
                elif min_cost[(i - 1) % 2][j] < second_smallest:
                    second_smallest = min_cost[(i - 1) % 2][j]
            for j in range(k):
                min_j = smallest if min_cost[(i - 1) % 2][j] != smallest else second_smallest
                min_cost[i % 2][j] = costs[i][j] + min_j

        return min(min_cost[(n - 1) % 2])
",# Time:  O(n * k)
"class Solution(object):
    def matrixMedian(self, grid):
        def check(x):
            return sum(bisect_right(row, x) for row in grid) > (len(grid)*len(grid[0]))//2

        left, right = min(row[0] for row in grid), max(row[-1] for row in grid)
        while left <= right:
            mid = left + (right-left)//2
            if check(mid):
                right = mid-1
            else:
                left = mid+1
        return left","# Time:  O(logr * mlogn), r = O(right-left+1) = O(10^6), O(logr) = O(20)"
"class Solution(object):
    def maximumValueSum(self, board):
        k = 3
        min_heaps = [[] for _ in range(len(board[0]))]
        for i in range(len(board)):
            min_heap = []
            for j in range(len(board[0])):
                heapq.heappush(min_heap, (board[i][j], i, j))
                if len(min_heap) == k+1:
                    heapq.heappop(min_heap)
            for v, i, j in min_heap:
                heapq.heappush(min_heaps[j], (v, i, j))
                if len(min_heaps[j]) == k+1:
                    heapq.heappop(min_heaps[j])
        min_heap = []
        for h in min_heaps:
            for x in h:
                heapq.heappush(min_heap, x)
                if len(min_heap) == ((k-1)*(2*k-1)+1)+1: 
                    heapq.heappop(min_heap)
        return max(sum(x[0] for x in c) for c in itertools.combinations(min_heap, k) if len({x[1] for x in c}) == k == len({x[2] for x in c}))

","# Time:  O(m * n * logk + nCr((k-1)*(2*k-1)+1), k) * k) = O(m * n)"
"class Solution2(object):
    def maximumValueSum(self, board):
        k = 3
        rows = [heapq.nlargest(k, [(board[i][j], i, j) for j in range(len(board[0]))]) for i in range(len(board))]
        cols = [heapq.nlargest(k, [(board[i][j], i, j) for i in range(len(board))]) for j in range(len(board[0]))]
        min_heap = heapq.nlargest((k-1)*(2*k-1)+1, set(itertools.chain(*rows)) & set(itertools.chain(*cols))) 
        return max(sum(x[0] for x in c) for c in itertools.combinations(min_heap, k) if len({x[1] for x in c}) == k == len({x[2] for x in c}))","# Time:  O(m * n * logk + nCr((k-1)*(2*k-1)+1), k) * k) = O(m * n)"
"class Solution(object):
    def maxStudents(self, seats):
        directions = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1)]
        E, count = collections.defaultdict(list), 0
        for i in range(len(seats)):
            for j in range(len(seats[0])):
                if seats[i][j] != '.':
                    continue
                count += 1
                if j%2:
                    continue
                for dx, dy in directions:
                    ni, nj = i+dx, j+dy
                    if 0 <= ni < len(seats) and \
                       0 <= nj < len(seats[0]) and \
                       seats[ni][nj] == '.':
                        E[i*len(seats[0])+j].append(ni*len(seats[0])+nj)
        return count-len(bipartiteMatch(E)[0])

",# Time:  O(m * n * sqrt(m * n)) = O(E * sqrt(V))
"class Solution2(object):
    def maxStudents(self, seats):
        directions = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1)]
        def dfs(seats, e, lookup, matching):
            i, j = e
            for dx, dy in directions:
                ni, nj = i+dx, j+dy
                if 0 <= ni < len(seats) and 0 <= nj < len(seats[0]) and \
                    seats[ni][nj] == '.' and not lookup[ni][nj]:
                    lookup[ni][nj] = True
                    if matching[ni][nj] == -1 or dfs(seats, matching[ni][nj], lookup, matching):
                        matching[ni][nj] = e
                        return True
            return False
        
        def Hungarian(seats):
            result = 0
            matching = [[-1]*len(seats[0]) for _ in range(len(seats))]
            for i in range(len(seats)):
                for j in range(0, len(seats[0]), 2):
                    if seats[i][j] != '.':
                        continue
                    lookup = [[False]*len(seats[0]) for _ in range(len(seats))]
                    if dfs(seats, (i, j), lookup, matching):
                        result += 1
            return result
          
        count = 0
        for i in range(len(seats)):
            for j in range(len(seats[0])):
                if seats[i][j] == '.':
                    count += 1
        return count-Hungarian(seats)

",# Time:  O(|V| * |E|) = O(m^2 * n^2)
"class Solution3(object):
    def maxStudents(self, seats):
        def popcount(n):
            result = 0
            while n:
                n &= n - 1
                result += 1
            return result
        
        dp = {0: 0}
        for row in seats:
            invalid_mask = sum(1 << c for c, v in enumerate(row) if v == 
            new_dp = {}
            for mask1, v1 in dp.items():
                for mask2 in range(1 << len(seats[0])):
                    if (mask2 & invalid_mask) or \
                       (mask2 & (mask1 << 1)) or (mask2 & (mask1 >> 1)) or \
                       (mask2 & (mask2 << 1)) or (mask2 & (mask2 >> 1)):
                        continue
                    new_dp[mask2] = max(new_dp.get(mask2, 0), v1+popcount(mask2))
            dp = new_dp
        return max(dp.values()) if dp else 0",# Time:  O(m * 2^n * 2^n) = O(m * 4^n)
"class Solution(object):
    def singleNumber(self, nums):
        x_xor_y = reduce(operator.xor, nums)
        bit =  x_xor_y & -x_xor_y
        result = [0, 0]
        for i in nums:
            result[bool(i & bit)] ^= i
        return result

",# Time:  O(n)
"class Solution2(object):
    def singleNumber(self, nums):
        x_xor_y = 0
        for i in nums:
            x_xor_y ^= i

        bit = x_xor_y & ~(x_xor_y - 1)

        x = 0
        for i in nums:
            if i & bit:
                x ^= i

        return [x, x ^ x_xor_y]

",# Time:  O(n)
"class Solution3(object):
    def singleNumber(self, nums):
        return [x[0] for x in sorted(list(collections.Counter(nums).items()), key=lambda i: i[1], reverse=False)[:2]]
",# Time:  O(n)
"class Solution(object):
    def numberOfWeakCharacters(self, properties):
        properties.sort(cmp=lambda a, b: cmp(b[1], a[1]) if a[0] == b[0] else cmp(a[0], b[0]))
        result = max_d = 0
        for a, d in reversed(properties):
            if d < max_d:
                result += 1
            max_d = max(max_d, d)
        return result

import collections


",# Time:  O(nlogn)
"class Solution2(object):
    def numberOfWeakCharacters(self, properties):
        lookup = collections.defaultdict(list)
        for a, d in properties:
            lookup[a].append(d)
        result = max_d = 0
        for a in sorted(iter(lookup.keys()), reverse=True):
            result += sum(d < max_d for d in lookup[a])
            max_d = max(max_d, max(lookup[a]))
        return result",# Time:  O(nlogn)
"class Solution(object):
    def getFinalState(self, nums, k, multiplier):
        EPS = 1e-15
        def count(x, target):
            return int(target-x+EPS)

        if multiplier == 1:
            return nums
        vals = sorted((log(x)/log(multiplier), i) for i, x in enumerate(nums))
        left = 0
        for right in range(1, (int(vals[-1][0])+1)+1):
            while left < len(vals) and count(vals[left][0], right) >= 1:
                left += 1
            if k-left < 0:
                right -= 1
                break
            k -= left
        for idx, (x, i) in enumerate(vals):
            c = count(x, right)
            if c <= 0:
                break
            nums[i] *= pow(multiplier, c)
        q, r = divmod(k, len(nums))
        m = pow(multiplier, q)
        result = [0]*len(nums)
        for idx, (x, i) in enumerate(sorted((x, i) for i, x in enumerate(nums))):
            result[i] = x*m*(multiplier if idx < r else 1)
        return result

","# Time:  O(n + (n + logr) + nlog(logr) + nlogn) = O(nlogn), assumed log(x) takes O(1) time"
"class Solution2(object):
    def getFinalState(self, nums, k, multiplier):
        EPS = 1e-15
        def binary_search_right(left, right, check):
            while left <= right:
                mid = left+(right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right

        def count(x, target):
            return int(target-x+EPS)

        def check(target):
            result = 0
            for x, i in vals:
                c = count(x, target)
                if c <= 0:
                    break
                result += c
            return result <= k

        if multiplier == 1:
            return nums
        vals = sorted((log(x)/log(multiplier), i) for i, x in enumerate(nums))
        target = binary_search_right(1, int(vals[-1][0])+1, check)
        for idx, (x, i) in enumerate(vals):
            c = count(x, target)
            if c <= 0:
                break
            k -= c
            nums[i] *= pow(multiplier, c)
        q, r = divmod(k, len(nums))
        m = pow(multiplier, q)
        result = [0]*len(nums)
        for idx, (x, i) in enumerate(sorted((x, i) for i, x in enumerate(nums))):
            result[i] = x*m*(multiplier if idx < r else 1)
        return result

","# Time:  O(n + min(n, k) * log(logr) + nlog(logr) + nlogn) = O(nlogr), assumed log(x) takes O(1) time"
"class Solution3(object):
    def getFinalState(self, nums, k, multiplier):
        if multiplier == 1:
            return nums
        min_heap = [(x, i) for i, x in enumerate(nums)]
        heapq.heapify(min_heap)
        mx = max(nums)
        for k in reversed(range(1, k+1)):
            if min_heap[0][0]*multiplier > mx:
                break
            x, i = heapq.heappop(min_heap)
            heapq.heappush(min_heap, (x*multiplier, i))
        else:
            k = 0
        vals = sorted(min_heap)
        q, r = divmod(k, len(nums))
        m = pow(multiplier, q)
        result = [0]*len(nums)
        for idx, (x, i) in enumerate(vals):
            result[i] = x*m*(multiplier if idx < r else 1)
        return result

","# Time:  O(min(nlogr, k) * logn + nlogn) = O(nlogn * logr)"
"class Solution4(object):
    def getFinalState(self, nums, k, multiplier):
        if multiplier == 1:
            return nums
        min_heap = [(x, i) for i, x in enumerate(nums)]
        heapq.heapify(min_heap)
        for _ in range(k):
            i = heapq.heappop(min_heap)[1]
            nums[i] *= multiplier
            heapq.heappush(min_heap, (nums[i], i))
        return nums

",# Time:  O(n + klogn)
"class Solution5(object):
    def getFinalState(self, nums, k, multiplier):
        if multiplier == 1:
            return nums
        for _ in range(k):
            i = min(range(len(nums)), key=lambda i: nums[i])
            nums[i] *= multiplier
        return nums",# Time:  O(k * n)
"class Solution(object):
    def nextPermutation(self, nums):
        k, l = -1, 0
        for i in reversed(range(len(nums)-1)):
            if nums[i] < nums[i+1]:
                k = i
                break
        else:
            nums.reverse()
            return

        for i in reversed(range(k+1, len(nums))):
            if nums[i] > nums[k]:
                l = i
                break
        nums[k], nums[l] = nums[l], nums[k]
        nums[k+1:] = nums[:k:-1]
        ",# Time:  O(n)
"class Solution2(object):
    def nextPermutation(self, nums):
        k, l = -1, 0
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                k = i

        if k == -1:
            nums.reverse()
            return

        for i in range(k+1, len(nums)):
            if nums[i] > nums[k]:
                l = i
        nums[k], nums[l] = nums[l], nums[k]
        nums[k+1:] = nums[:k:-1]",# Time:  O(n)
"class Solution(object):
    def twoCitySchedCost(self, costs):
        def kthElement(nums, k, compare):
            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == k:
                    return
                elif new_pivot_idx > k:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
                    
        kthElement(costs, len(costs)//2, lambda a, b: a[0]-a[1] < b[0]-b[1])
        result = 0
        for i in range(len(costs)):
            result += costs[i][0] if i < len(costs)//2 else costs[i][1]
        return result","# Time:  O(n) ~ O(n^2), O(n) on average."
"class Solution(object):
    def nthUglyNumber(self, n):
        ugly_number = 0

        heap = []
        heapq.heappush(heap, 1)
        for _ in range(n):
            ugly_number = heapq.heappop(heap)
            if ugly_number % 2 == 0:
                heapq.heappush(heap, ugly_number * 2)
            elif ugly_number % 3 == 0:
                heapq.heappush(heap, ugly_number * 2)
                heapq.heappush(heap, ugly_number * 3)
            else:
                heapq.heappush(heap, ugly_number * 2)
                heapq.heappush(heap, ugly_number * 3)
                heapq.heappush(heap, ugly_number * 5)

        return ugly_number

    def nthUglyNumber2(self, n):
        ugly = [1]
        i2 = i3 = i5 = 0
        while len(ugly) < n:
            while ugly[i2] * 2 <= ugly[-1]: i2 += 1
            while ugly[i3] * 3 <= ugly[-1]: i3 += 1
            while ugly[i5] * 5 <= ugly[-1]: i5 += 1
            ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))
        return ugly[-1]

    def nthUglyNumber3(self, n):
        q2, q3, q5 = [2], [3], [5]
        ugly = 1
        for u in heapq.merge(q2, q3, q5):
            if n == 1:
                return ugly
            if u > ugly:
                ugly = u
                n -= 1
                q2 += 2 * u,
                q3 += 3 * u,
                q5 += 5 * u,

",# Time:  O(n)
"class Solution2(object):
    ugly = sorted(2**a * 3**b * 5**c
                  for a in range(32) for b in range(20) for c in range(14))

    def nthUglyNumber(self, n):
        return self.ugly[n-1]
",# Time:  O(n)
"class Solution(object):
    def discountPrices(self, sentence, discount):
        result = []
        i = 0
        while i < len(sentence):
            j = sentence.find(' ', i)
            if j == -1: j = len(sentence)
            if sentence[i] == '$' and j-(i+1) > 0 and all(sentence[k].isdigit() for k in range(i+1, j)):
                cnt = reduce(lambda x, y: x*10+int(y), (sentence[k] for k in range(i+1, j)), 0)
                result.append(""${:d}.{:02d}"".format(*divmod(cnt*(100-discount), 100)))
            else:
                for k in range(i, j):
                    result.append(sentence[k])
            if j != len(sentence):
                result.append(' ')
            i = j+1
        return """".join(result)

",# Time:  O(n)
"class Solution2(object):
    def discountPrices(self, sentence, discount):
        def format(discount, x):
            return ""${:d}.{:02d}"".format(*divmod(int(x[1:])*(100-discount), 100)) if x[0] == '$' and x[1:].isdigit() else x

        return "" "".join(format(discount, x) for x in sentence.split())",# Time:  O(n)
"class Solution(object):
    def minimumOperations(self, nums):
        k = 3

        dp = [0]*k
        for x in nums:
            dp[x-1] += 1
            for i in range(x, len(dp)):
                dp[i] = max(dp[i], dp[i-1])
        return len(nums)-dp[-1]",# Time:  O(k * n) = O(n)
"class Solution(object):
    def kthSmallest(self, mat, k):
        def kSmallestPairs(nums1, nums2, k):
            result, min_heap = [], []
            for c in range(min(len(nums1), k)):
                heapq.heappush(min_heap, (nums1[c]+nums2[0], 0))
                c += 1
            while len(result) != k and min_heap:
                total, c = heapq.heappop(min_heap)
                result.append(total)
                if c+1 == len(nums2):
                    continue
                heapq.heappush(min_heap, (total-nums2[c]+nums2[c+1], c+1))
            return result

        result = mat[0]
        for r in range(1, len(mat)):
            result = kSmallestPairs(result, mat[r], k)
        return result[k-1]

",# Time:  O(m * klogk)
"class Solution2(object):
    def kthSmallest(self, mat, k):
        def countArraysHaveSumLessOrEqual(mat, k, r, target): 
            if target < 0:
                return 0
            if r == len(mat):
                return 1
            result = 0
            for c in range(len(mat[0])):
                cnt = countArraysHaveSumLessOrEqual(mat, k-result, r+1, target-mat[r][c])
                if not cnt:
                    break
                result += cnt
                if result > k:
                    break
            return result
        
        max_num = max(x for row in mat for x in row)
        left, right = len(mat), len(mat)*max_num
        while left <= right:
            mid = left + (right-left)//2
            cnt = countArraysHaveSumLessOrEqual(mat, k, 0, mid)
            if cnt >= k:
                right = mid-1
            else:
                left = mid+1
        return left
",# Time:  O((k + m) * log(m * MAX_NUM)) ~ O(k * m * log(m * MAX_NUM))
"class Solution(object):
    def subsetsWithDup(self, nums):
        nums.sort()
        result = [[]]
        previous_size = 0
        for i in range(len(nums)):
            size = len(result)
            for j in range(size):
                if i == 0 or nums[i] != nums[i - 1] or j >= previous_size:
                    result.append(list(result[j]))
                    result[-1].append(nums[i])
            previous_size = size
        return result

",# Time:  O(n * 2^n)
"class Solution2(object):
    def subsetsWithDup(self, nums):
        result = []
        i, count = 0, 1 << len(nums)
        nums.sort()

        while i < count:
            cur = []
            for j in range(len(nums)):
                if i & 1 << j:
                    cur.append(nums[j])
            if cur not in result:
                result.append(cur)
            i += 1

        return result

",# Time:  O(n * 2^n) ~ O((n * 2^n)^2)
"class Solution3(object):
    def subsetsWithDup(self, nums):
        result = []
        self.subsetsWithDupRecu(result, [], sorted(nums))
        return result

    def subsetsWithDupRecu(self, result, cur, nums):
        if not nums:
            if cur not in result:
                result.append(cur)
        else:
            self.subsetsWithDupRecu(result, cur, nums[1:])
            self.subsetsWithDupRecu(result, cur + [nums[0]], nums[1:])

",# Time:  O(n * 2^n) ~ O((n * 2^n)^2)
"class Solution(object):
    def longestSubstring(self, s, k):
        def longestSubstringHelper(s, k, start, end):
            count = [0] * 26
            for i in range(start, end):
                count[ord(s[i]) - ord('a')] += 1
            max_len = 0
            i = start
            while i < end:
                while i < end and count[ord(s[i]) - ord('a')] < k:
                    i += 1
                j = i
                while j < end and count[ord(s[j]) - ord('a')] >= k:
                    j += 1

                if i == start and j == end:
                    return end - start

                max_len = max(max_len, longestSubstringHelper(s, k, i, j))
                i = j
            return max_len

        return longestSubstringHelper(s, k, 0, len(s))
",# Time:  O(26 * n) = O(n)
"class Solution(object):
    def maxProfit(self, k, prices):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        profits = []
        v_p_stk = [] 
        v, p = -1, -1
        while p+1 < len(prices):
            for v in range(p+1, len(prices)-1):
                if prices[v] < prices[v+1]:
                    break
            else:
                v = len(prices)-1
            for p in range(v, len(prices)-1):
                if prices[p] > prices[p+1]:
                    break 
            else:
                p = len(prices)-1
            while v_p_stk and prices[v_p_stk[-1][0]] > prices[v]: 
                last_v, last_p = v_p_stk.pop()
                profits.append(prices[last_p]-prices[last_v]) 
            while v_p_stk and prices[v_p_stk[-1][1]] <= prices[p]: 
                last_v, last_p = v_p_stk.pop()
                profits.append(prices[last_p]-prices[v]) 
                v = last_v
            v_p_stk.append((v, p)) 
        while v_p_stk:
            last_v, last_p = v_p_stk.pop()
            profits.append(prices[last_p]-prices[last_v]) 
        if k > len(profits):
            k = len(profits)
        else:
            nth_element(profits, k-1, compare=lambda a, b: a > b)
        return sum(profits[i] for i in range(k)) 

","# Time:  O(n) on average, using Median of Medians could achieve O(n) (Intro Select)"
"class Solution2(object):
    def maxProfit(self, k, prices):
        def maxAtMostNPairsProfit(sprices):
            profit = 0
            for i in range(len(prices) - 1):
                profit += max(0, prices[i + 1] - prices[i])
            return profit

        def maxAtMostKPairsProfit(prices, k):
            max_buy = [float(""-inf"") for _ in range(k + 1)]
            max_sell = [0 for _ in range(k + 1)]
            for i in range(len(prices)):
                for j in range(1, k + 1):
                    max_buy[j] = max(max_buy[j], max_sell[j-1] - prices[i])
                    max_sell[j] = max(max_sell[j], max_buy[j] + prices[i])
            return max_sell[k]

        if k >= len(prices) // 2:
            return maxAtMostNPairsProfit(prices)

        return maxAtMostKPairsProfit(prices, k)",# Time:  O(k * n)
"class Solution(object):
    def beautifulSubstrings(self, s, k):
        VOWELS = set(""aeiou"")
        prefix = [0]*(len(s)+1)
        for i in range(len(s)):
            prefix[i+1] = prefix[i]+(+1 if s[i] in VOWELS else -1)
        new_k = 1
        x = k
        for i in range(2, k+1):
            if i*i > k:
                break
            cnt = 0
            while x%i == 0:
                x //= i
                cnt += 1
            if cnt:
                new_k *= i**((cnt+1)//2+int(i == 2))
        if x != 1:
            new_k *= x**((1+1)//2+int(x == 2))
        cnt = collections.Counter()
        result = 0
        for i, p in enumerate(prefix):
            result += cnt[p, i%new_k]
            cnt[p, i%new_k] += 1
        return result
    
",# Time:  O(n + sqrt(k))
"class Solution2(object):
    def beautifulSubstrings(self, s, k):
        VOWELS = set(""aeiou"")
        result = 0
        for i in range(len(s)):
            c = v = 0
            for j in range(i, len(s)):
                if s[j] in VOWELS:
                    v += 1
                else:
                    c += 1
                if c == v and (c*v)%k == 0:
                    result += 1
        return result
    ",# Time:  O(n + sqrt(k))
"class Solution(object):
    def areConnected(self, n, threshold, queries):
        union_find = UnionFind(n)
        for i in range(threshold+1, n+1):
            for j in range(2*i, n+1, i): 
                union_find.union_set(i-1, j-1)
        return [union_find.find_set(q[0]-1) == union_find.find_set(q[1]-1) for q in queries]",# Time:  O((nlogn + q) * α(n)) ~= O(nlogn + q)
"class Solution(object):
    def minCostConnectPoints(self, points):
        result, u = 0, 0 
        dist = [float(""inf"")]*len(points)
        lookup = set()
        for _ in range(len(points)-1):
            x0, y0 = points[u]
            lookup.add(u)
            for v, (x, y) in enumerate(points):
                if v in lookup:
                    continue
                dist[v] = min(dist[v], abs(x-x0) + abs(y-y0))
            val, u = min((val, v) for v, val in enumerate(dist)) 
            dist[u] = float(""inf"") 
            result += val
        return result


",# Time:  O(n^2)
"class Solution2(object):
    def minCostConnectPoints(self, points):
        edges = []
        for u in range(len(points)):
            for v in range(u+1, len(points)):
                edges.append((u, v, abs(points[v][0]-points[u][0]) + abs(points[v][1]-points[u][1])))
        edges.sort(key=lambda x: x[2])
        result = 0
        union_find = UnionFind(len(points))
        for u, v, val in edges:
            if union_find.union_set(u, v):
                result += val
        return result
",# Time:  O(eloge) = O(n^2 * logn)
"class Solution(object):
    def hasAllCodes(self, s, k):
        return 2**k <= len(s) and len({s[i:i+k] for i in range(len(s)-k+1)}) == 2**k
    ",# Time:  O(n * k)
"class Solution2(object):
    def hasAllCodes(self, s, k):
        lookup = set()
        base = 2**k
        if base > len(s):
            return False
        num = 0
        for i in range(len(s)):
            num = (num << 1) + (s[i] == '1')
            if i >= k-1:
                lookup.add(num)
                num -= (s[i-k+1] == '1') * (base//2)
        return len(lookup) == base",# Time:  O(n * k)
"class Solution(object):
    def numberOfSubstrings(self, s):
        result = 0
        idxs = [-1]+[i for i, x in enumerate(s) if x == '0']+[len(s)]
        curr = 1
        for i in range(len(s)):
            if idxs[curr] == i:
                curr += 1
            for c in range(min(int((-1+(1+4*(i+1))**0.5)/2)+1, curr)): 
                if c**2 <= (i-idxs[(curr-c)-1])-c:
                    result += min(min(idxs[curr-c], i)-idxs[(curr-c)-1], ((i-idxs[(curr-c)-1])-c)-c**2+1)
        return result

",# Time:  O(n * sqrt(n)) = O(n^(3/2))
"class Solution2(object):
    def numberOfSubstrings(self, s):
        result = 0
        idxs = [-1]+[i for i, x in enumerate(s) if x == '0']+[len(s)]
        for c in range(int((-1+(1+4*len(s))**0.5)/2)+1): 
            left = right = 1
            for i in range(len(s)):
                if idxs[right] == i:
                    right += 1
                if right-left == c+1:
                    left += 1
                if not (right-left == c and ((i-idxs[left-1])-c) >= c**2):
                    continue
                result += min(min(idxs[left], i)-idxs[left-1], ((i-idxs[left-1])-c)-c**2+1)
        return result

",# Time:  O(n * sqrt(n)) = O(n^(3/2))
"class Solution_TLE(object):
    def numberOfSubstrings(self, s):
        result = 0
        for c in range(int((-1+(1+4*len(s))**0.5)/2)+1): 
            cnt = [0]*2
            left = curr = 0
            for right in range(len(s)):
                cnt[s[right] == '1'] += 1
                while cnt[0] == c+1:
                    cnt[s[left] == '1'] -= 1
                    left += 1
                if not (cnt[0] == c and cnt[1] >= c**2):
                    continue
                for curr in range(max(curr, left), right):
                    if s[curr] == '0':
                        break
                else:
                    curr = right
                result += min(curr-left+1, cnt[1]-c**2+1)
        return result",# Time:  O(n * sqrt(n)) = O(n^(3/2))
"class Solution(object):
    def __init__(self):
        self.__root = None


    def book(self, start, end):
        if self.__root is None:
            self.__root = Node(start, end)
            return True
        return self.root.insert(Node(start, end))

","# Time:  O(nlogn) on average, O(n^2) on worst case"
"class Solution2(object):

    def __init__(self):
        self.__calendar = []


    def book(self, start, end):
        for i, j in self.__calendar:
            if start < j and end > i:
                return False
        self.__calendar.append((start, end))
        return True


",# Time:  O(n^2)
"class Solution(object):
    def removeBoxes(self, boxes):
        def dfs(boxes, l, r, k, lookup):
            if l > r: return 0
            if lookup[l][r][k]: return lookup[l][r][k]

            ll, kk = l, k
            while l < r and boxes[l+1] == boxes[l]:
                l += 1
                k += 1
            result = dfs(boxes, l+1, r, 0, lookup) + (k+1) ** 2
            for i in range(l+1, r+1):
                if boxes[i] == boxes[l]:
                    result = max(result, dfs(boxes, l+1, i-1, 0, lookup) + dfs(boxes, i, r, k+1, lookup))
            lookup[ll][r][kk] = result
            return result

        lookup = [[[0]*len(boxes) for _ in range(len(boxes)) ] for _ in range(len(boxes)) ]
        return dfs(boxes, 0, len(boxes)-1, 0, lookup)
",# Time:  O(n^3) ~ O(n^4)
"class Solution(object):

    def __init__(self):
        self.__intervals = []

    def addNum(self, val):
        def upper_bound(nums, target):
            left, right = 0, len(nums) - 1
            while left <= right:
                mid = left + (right - left) / 2
                if nums[mid].start > target:
                    right = mid - 1
                else:
                    left = mid + 1
            return left

        i = upper_bound(self.__intervals, val)
        start, end = val, val
        if i != 0 and self.__intervals[i-1].end + 1 >= val:
            i -= 1
        while i != len(self.__intervals) and \
              end + 1 >= self.__intervals[i].start:
            start = min(start, self.__intervals[i].start)
            end = max(end, self.__intervals[i].end)
            del self.__intervals[i]
        self.__intervals.insert(i, Interval(start, end))

    def getIntervals(self):
        return self.__intervals


","# Time:  addNum: O(n), getIntervals: O(n), n is the number of disjoint intervals."
"class Solution(object):
    def idealArrays(self, n, maxValue):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return primes

        def prime_factors(x):
            factors = collections.Counter()
            for p in primes:
                if p*p > x:
                    break
                while x%p == 0:
                    factors[p] += 1
                    x //= p
            if x != 1:
                factors[x] += 1
            return factors

        primes = linear_sieve_of_eratosthenes(int(maxValue**0.5))
        result = 0
        for k in range(1, maxValue+1):
            total = 1
            for c in prime_factors(k).values():
                total = (total*nCr(n+c-1, c))%MOD 
            result = (result+total)%MOD
        return result

","# Time:  O(sqrt(m) + n + m * (logm + pi(sqrt(m)))) = O(sqrt(m) + n + m * (logm + sqrt(m)/log(sqrt(m)))), pi(n) = number of primes in a range [1, n] = O(n/logn) by prime number theorem, see https://en.wikipedia.org/wiki/Prime_number_theorem"
"class Solution2(object):
    def idealArrays(self, n, maxValue):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        result = 0
        dp = collections.Counter(range(1, maxValue+1))
        for i in range(n): 
            new_dp = collections.Counter()
            total = 0
            for x, c in dp.items():
                total = (total+c)%MOD
                for y in range(x+x, maxValue+1, x): 
                    new_dp[y] += c
            result = (result+total*nCr(n-1, i))%MOD
            dp = new_dp
        return result",# Time:  O(n * mlogm)
"class Solution(object):
    def judgeCircle(self, moves):
        count = collections.Counter(moves)
        return count['L'] == count['R'] and count['U'] == count['D']
",# Time:  O(n)
"class Solution(object):
    def judgeCircle(self, moves):
        v, h = 0, 0
        for move in moves:
            if move == 'U':
                v += 1
            elif move == 'D':
                v -= 1
            elif move == 'R':
                h += 1
            elif move == 'L':
                h -= 1
        return v == 0 and h == 0",# Time:  O(n)
"class Solution(object):
    def rearrangeArray(self, nums):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def reversedTriPartitionWithVI(nums, val):
            def idx(i, N):
                return (1 + 2 * (i)) % N

            N = len(nums)//2 * 2 + 1
            i, j, n = 0, 0, len(nums) - 1
            while j <= n:
                if nums[idx(j, N)] > val:
                    nums[idx(i, N)], nums[idx(j, N)] = nums[idx(j, N)], nums[idx(i, N)]
                    i += 1
                    j += 1
                elif nums[idx(j, N)] < val:
                    nums[idx(j, N)], nums[idx(n, N)] = nums[idx(n, N)], nums[idx(j, N)]
                    n -= 1
                else:
                    j += 1

        mid = (len(nums)-1)//2
        nth_element(nums, mid)
        reversedTriPartitionWithVI(nums, nums[mid])
        return nums

","# Time:  O(n) ~ O(n^2), O(n) on average"
"class Solution2(object):
    def rearrangeArray(self, nums):
        nums.sort()
        mid = (len(nums)-1)//2
        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]
        return nums",# Time:  O(nlogn)
"class Solution(object):
    def maxGcdSum(self, nums, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        result = prefix = 0
        dp = []
        for right, x in enumerate(nums):
            dp.append((right, x, prefix))
            prefix += x
            new_dp = []
            for left, g, p in dp: 
                ng = gcd(g, x) 
                if not new_dp or new_dp[-1][1] != ng:
                    new_dp.append((left, ng, p)) 
            dp = new_dp
            for left, g, p in dp:
                if right-left+1 < k:
                    break
                result = max(result, (prefix-p)*g)
        return result

","# Time:  O(nlogr), r = max(nums)"
"class Solution2(object):
    def maxGcdSum(self, nums, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        prefix = [0]*(len(nums)+1)
        for i, x in enumerate(nums):
            prefix[i+1] = prefix[i]+x
        result = 0
        dp = []
        for right, x in enumerate(nums):
            dp.append((right, x))
            new_dp = []
            for left, g in dp: 
                ng = gcd(g, x) 
                if not new_dp or new_dp[-1][1] != ng:
                    new_dp.append((left, ng)) 
            dp = new_dp
            for left, g in dp:
                if right-left+1 < k:
                    break
                result = max(result, (prefix[right+1]-prefix[left])*g)
        return result

","# Time:  O(nlogr), r = max(nums)"
"class Solution3_TLE(object):
    def maxGcdSum(self, nums, k):
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        def binary_search_right(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if not check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return right

        class SparseTable(object):
            def __init__(self, arr, fn):
                self.fn = fn
                self.bit_length = [0]
                n = len(arr)
                k = n.bit_length()-1 
                for i in range(k+1):
                    self.bit_length.extend(i+1 for _ in range(min(1<<i, (n+1)-len(self.bit_length))))
                self.st = [[0]*n for _ in range(k+1)]
                self.st[0] = arr[:]
                for i in range(1, k+1): 
                    for j in range((n-(1<<i))+1):
                        self.st[i][j] = fn(self.st[i-1][j], self.st[i-1][j+(1<<(i-1))])
        
            def query(self, L, R): 
                i = self.bit_length[R-L+1]-1 
                return self.fn(self.st[i][L], self.st[i][R-(1<<i)+1])
        
        prefix = [0]*(len(nums)+1)
        for i, x in enumerate(nums):
            prefix[i+1] = prefix[i]+x
        result = 0
        rmq = SparseTable(nums, gcd)
        for left, x in enumerate(nums):
            right = left
            while right < len(nums): 
                g = rmq.query(left, right)
                right = binary_search_right(right, len(nums)-1, lambda x: rmq.query(left, x) >= g) 
                if right-left+1 >= k:
                    result = max(result, (prefix[right+1]-prefix[left])*g)
                right += 1
        return result","# Time:  O(n * logr * (logn * logr)) = O(n * (logr)^2 * logn), r = max(nums)"
"class Solution(object):
    def minAvailableDuration(self, slots1, slots2, duration):
        min_heap = list([slot for slot in slots1 + slots2 if slot[1] - slot[0] >= duration])
        heapq.heapify(min_heap) 
        while len(min_heap) > 1:
            left = heapq.heappop(min_heap) 
            right = min_heap[0]
            if left[1]-right[0] >= duration:
                return [right[0], right[0]+duration] 
        return []   

",# Time:  O(n) ~ O(nlogn)
"class Solution2(object):
    def minAvailableDuration(self, slots1, slots2, duration):
        slots1.sort(key = lambda x: x[0])
        slots2.sort(key = lambda x: x[0])
        i, j = 0, 0
        while i < len(slots1) and j < len(slots2):
            left = max(slots1[i][0], slots2[j][0])
            right = min(slots1[i][1], slots2[j][1])
            if left+duration <= right:
                return [left, left+duration]
            if slots1[i][1] < slots2[j][1]:
                i += 1
            else:
                j += 1
        return []",# Time:  O(nlogn)
"class Solution(object):
    def numberOfWays(self, s):
        K = 3
        dp = [[0]*2 for _ in range(K)] 
        for c in s:
            j = ord(c)-ord('0')
            dp[0][j] += 1
            for i in range(1, len(dp)):
                dp[i][j] += dp[i-1][1^j]
        return dp[-1][0]+dp[-1][1]",# Time:  O(k * n) = O(n)
"class Solution(object):
    def amountPainted(self, paint):
        points = collections.defaultdict(list)
        for i, (s, e) in enumerate(paint):
            points[s].append((True, i))
            points[e].append((False, i))
        min_heap = []
        lookup = [False]*len(paint)
        result = [0]*len(paint)
        prev = -1
        for pos in sorted(points.keys()):
            while min_heap and lookup[min_heap[0]]:
                heapq.heappop(min_heap)
            if min_heap:
                result[min_heap[0]] += pos-prev
            prev = pos
            for t, i in points[pos]:
                if t:
                    heapq.heappush(min_heap, i)
                else:
                    lookup[i] = True
        return result
from sortedcontainers import SortedList


",# Time:  O(nlogn)
"class Solution2(object):
    def amountPainted(self, paint):
        points = collections.defaultdict(list)
        for i, (s, e) in enumerate(paint):
            points[s].append((True, i))
            points[e].append((False, i))
        sl = SortedList()
        result = [0]*len(paint)
        prev = -1
        for pos in sorted(points.keys()):
            if sl:
                result[sl[0]] += pos-prev
            prev = pos
            for t, i in points[pos]:
                if t:
                    sl.add(i)
                else:
                    sl.remove(i)
        return result


class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda x: 0,
                 query_fn=lambda x, y: y if x is None else x+y,
                 update_fn=lambda x, y: y):
        self.tree = [None]*(2*N)
        self.lazy = [None]*len(self.tree)
        self.base = len(self.tree)//2
        self.H = (self.base-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in range(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(range(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])
        self.count = [1]*(2*N)
        for i in reversed(range(1, N)):
            self.count[i] = self.count[2*i] + self.count[2*i+1]

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val*self.count[x])
        if x < self.base:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def __push(self, x):
        n = 2**self.H
        while n != 1:
            y = x // n
            if self.lazy[y] is not None:
                self.__apply(y*2, self.lazy[y])
                self.__apply(y*2 + 1, self.lazy[y])
                self.lazy[y] = None
            n //= 2

    def update(self, L, R, h):
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x])

        if L > R:
            return
        L += self.base
        R += self.base
        self.__push(L) 
        self.__push(R) 
        L0, R0 = L, R
        while L <= R:
            if L & 1:
                self.__apply(L, h)
                L += 1
            if R & 1 == 0:
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R):
        result = None
        if L > R:
            return result

        L += self.base
        R += self.base
        self.__push(L)
        self.__push(R)
        while L <= R:
            if L & 1:
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0:
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result

",# Time:  O(nlogn)
"class SolutionTLE(object):
    def amountPainted(self, paint):
        result = []
        st = SegmentTree(max(e for _, e in paint))
        for s, e in paint:
            cnt = st.query(s, e-1)
            st.update(s, e-1, 1)
            result.append(st.query(s, e-1)-cnt)
        return result","# Time:  O(nlogr), r is the max position"
"class Solution(object):
    def maxEnvelopes(self, envelopes):
        def insert(target):
            left, right = 0, len(result) - 1
            while left <= right:
                mid = left + (right - left) / 2
                if result[mid] >= target:
                    right = mid - 1
                else:
                    left = mid + 1
            if left == len(result):
                result.append(target)
            else:
                result[left] = target

        result = []

        envelopes.sort(lambda x, y: y[1] - x[1] if x[0] == y[0] else \
                                    x[0] - y[0])
        for envelope in envelopes:
            insert(envelope[1])

        return len(result)
","# Time:  O(nlogn + nlogk) = O(nlogn), k is the length of the result."
"class Solution(object):
    def kClosest(self, points, K):
        def dist(point):
            return point[0]**2 + point[1]**2
        
        def kthElement(nums, k, compare):
            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == k:
                    return
                elif new_pivot_idx > k:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
                    
        kthElement(points, K-1, lambda a, b: dist(a) < dist(b))
        return points[:K]

import heapq

",# Time:  O(n) on average
"class Solution2(object):
    def kClosest(self, points, K):
        def dist(point):
            return point[0]**2 + point[1]**2
        
        max_heap = []
        for point in points:
            heapq.heappush(max_heap, (-dist(point), point))
            if len(max_heap) > K:
                heapq.heappop(max_heap)
        return [heapq.heappop(max_heap)[1] for _ in range(len(max_heap))]",# Time:  O(n) on average
"class Solution(object):
    def smallestTrimmedNumbers(self, nums, queries):
        max_t = max(t for _, t in queries)
        lookup = [[] for _ in range(max_t+1)]
        for i, (k, t) in enumerate(queries):
            lookup[t].append((k, i))
        result = [0]*len(queries)
        idxs = list(range(len(nums)))
        for l in range(1, max_t+1):
            cnt = [0]*10
            for i in idxs:
                d = int(nums[i][-l])
                cnt[d] += 1
            for d in range(9):
                cnt[d+1] += cnt[d]
            new_idxs = [0]*len(nums)
            for i in reversed(idxs):
                d = int(nums[i][-l])
                cnt[d] -= 1
                new_idxs[cnt[d]] = i
            idxs = new_idxs
            for k, i in lookup[l]:
                result[i] = idxs[k-1]
        return result

import random


",# Time:  O(q + n * t)
"class Solution2(object):
    def smallestTrimmedNumbers(self, nums, queries):
        def nth_element(nums, n, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def compare(a, b):
            for i in range(len(nums[a])-t, len(nums[a])):
                if nums[a][i] < nums[b][i]:
                    return True
                if nums[a][i] > nums[b][i]:
                    return False
            return cmp(a, b) < 0

        result = []
        idxs = list(range(len(nums)))
        for k, t in queries:
            nth_element(idxs, k-1, compare=compare)
            result.append(idxs[k-1])
        return result

",# Time:  O(q + n * t)
"class Solution3(object):
    def smallestTrimmedNumbers(self, nums, queries):
        def compare(a, b):
            for i in range(len(nums[a])-t, len(nums[a])):
                if nums[a][i] < nums[b][i]:
                    return -1
                if nums[a][i] > nums[b][i]:
                    return 1
            return cmp(a, b)

        max_t = max(t for _, t in queries)
        lookup = [[] for _ in range(max_t+1)]
        for i, (k, t) in enumerate(queries):
            lookup[t].append((k, i))
        result = [0]*len(queries)
        idxs = list(range(len(nums)))
        for t in range(1, max_t+1):
            if not lookup[t]:
                continue
            idxs.sort(cmp=compare)
            for k, i in lookup[t]:
                result[i] = idxs[k-1]
        return result",# Time:  O(q + nlogn * t)
"class Solution(object):
    def continuousSubarrays(self, nums):
        result = left = 0
        mn, mx = float(""inf""), float(""-inf"")
        for right in range(len(nums)):
            if mn <= nums[right] <= mx:
                mn, mx = max(mn, nums[right]-2), min(mx, nums[right]+2)
            else:
                mn, mx = nums[right]-2, nums[right]+2
                for left in reversed(range(right)):
                    if not mn <= nums[left] <= mx:
                        break
                    mn, mx = max(mn, nums[left]-2), min(mx, nums[left]+2)
                else:
                    left = -1
                left += 1
            result += right-left+1
        return result
import collections


",# Time:  O(n)
"class Solution2(object):
    def continuousSubarrays(self, nums):
        mn, mx = collections.deque(), collections.deque()
        result = left = 0
        for right in range(len(nums)):
            while mn and nums[mn[-1]] > nums[right]:
                mn.pop()
            mn.append(right)
            while mx and nums[mx[-1]] < nums[right]:
                mx.pop()
            mx.append(right)
            while not nums[right]-nums[mn[0]] <= 2:
                left = max(left, mn.popleft()+1)
            while not nums[mx[0]]-nums[right] <= 2:
                left = max(left, mx.popleft()+1)
            result += right-left+1
        return result

",# Time:  O(n)
"class Solution3(object):
    def continuousSubarrays(self, nums):
        result = left = 0
        lookup = SortedDict()
        for right in range(len(nums)):
            lookup[nums[right]] = right
            to_del = []
            for x, i in list(lookup.items()):
                if nums[right]-x <= 2:
                    break
                left = max(left, i+1)
                to_del.append(x)
            for x, i in reversed(list(lookup.items())):
                if x-nums[right] <= 2:
                    break
                left = max(left, i+1)
                to_del.append(x) 
            for x in to_del:
                del lookup[x]
            result += right-left+1
        return result",# Time:  O(nlogn)
"class Solution(object):
    def integerBreak(self, n):
        if n < 4:
            return n - 1


        res = 0
        if n % 3 == 0:           
            res = 3 ** (n // 3)
        elif n % 3 == 2:         
            res = 3 ** (n // 3) * 2
        else:                    
            res = 3 ** (n // 3 - 1) * 4
        return res

","# Time:  O(logn), pow is O(logn)."
"class Solution2(object):
    def integerBreak(self, n):
        if n < 4:
            return n - 1

        res = [0, 1, 2, 3]
        for i in range(4, n + 1):
            res[i % 4] = max(res[(i - 2) % 4] * 2, res[(i - 3) % 4] * 3)
        return res[n % 4]
",# Time:  O(n)
"class Solution(object):
    def isToeplitzMatrix(self, matrix):
        return all(i == 0 or j == 0 or matrix[i-1][j-1] == val
                   for i, row in enumerate(matrix)
                   for j, val in enumerate(row))

",# Time:  O(m * n)
"class Solution2(object):
    def isToeplitzMatrix(self, matrix):
        for row_index, row in enumerate(matrix):
            for digit_index, digit in enumerate(row):
                if not row_index or not digit_index:
                    continue
                if matrix[row_index - 1][digit_index - 1] != digit:
                    return False
        return True
",# Time:  O(m * n)
"class Solution(object):
    def waysToFillArray(self, queries):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def nCr(n, k):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def linear_sieve_of_eratosthenes(n): 
            primes = []
            spf = [-1]*(n+1) 
            for i in range(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p > n or p > spf[i]:
                        break
                    spf[i*p] = p
            return primes

        def prime_factors(x):
            factors = collections.Counter()
            for p in primes:
                if p*p > x:
                    break
                while x%p == 0:
                    factors[p] += 1
                    x //= p
            if x != 1:
                factors[x] += 1
            return factors

        primes = linear_sieve_of_eratosthenes(int(max(k for _, k in queries)**0.5))
        result = []
        for n, k in queries:
            total = 1
            for c in prime_factors(k).values():
                total *= nCr(n+c-1, c) 
            result.append(total % MOD)
        return result","# Time:  O(sqrt(m) + n + q * (logm + pi(sqrt(m)))) = O(sqrt(m) + n + q * (logm + sqrt(m)/log(sqrt(m)))), m is max(k for _, k in queries), pi(n) = number of primes in a range [1, n] = O(n/logn) by prime number theorem, see https://en.wikipedia.org/wiki/Prime_number_theorem"
"class Solution(object):
    def expand(self, S): 
        def form_words(options):
            words = list(map("""".join, itertools.product(*options)))
            words.sort()
            return words

        def generate_option(expr, i):
            option_set = set()
            while i[0] != len(expr) and expr[i[0]] != ""}"":
                i[0] += 1 
                for option in generate_words(expr, i):
                    option_set.add(option)
            i[0] += 1 
            option = list(option_set)
            option.sort()
            return option

        def generate_words(expr, i):
            options = []
            while i[0] != len(expr) and expr[i[0]] not in "",}"":
                tmp = []
                if expr[i[0]] not in ""{,}"":
                    tmp.append(expr[i[0]])
                    i[0] += 1 
                elif expr[i[0]] == ""{"":
                    tmp = generate_option(expr, i)
                options.append(tmp)
            return form_words(options)

        return generate_words(S, [0])

","# Time:  O(p*l * log(p*l)), p is the production of all number of options"
"class Solution2(object):
    def expand(self, S): 
        def form_words(options):
            words = []
            total = 1
            for opt in options:
                total *= len(opt)
            for i in range(total):
                tmp = []
                for opt in reversed(options):
                    i, c = divmod(i, len(opt))
                    tmp.append(opt[c])
                tmp.reverse()
                words.append("""".join(tmp))
            words.sort()
            return words

        def generate_option(expr, i):
            option_set = set()
            while i[0] != len(expr) and expr[i[0]] != ""}"":
                i[0] += 1 
                for option in generate_words(expr, i):
                    option_set.add(option)
            i[0] += 1 
            option = list(option_set)
            option.sort()
            return option

        def generate_words(expr, i):
            options = []
            while i[0] != len(expr) and expr[i[0]] not in "",}"":
                tmp = []
                if expr[i[0]] not in ""{,}"":
                    tmp.append(expr[i[0]])
                    i[0] += 1 
                elif expr[i[0]] == ""{"":
                    tmp = generate_option(expr, i)
                options.append(tmp)
            return form_words(options)

        return generate_words(S, [0])","# Time:  O(p*l * log(p*l)), p is the production of all number of options"
"class Solution(object):
    def makeStringSorted(self, s): 
        def inverse(n, m):
            i = len(inv)
            while len(inv) <= n: 
                inv.append(inv[m%i]*(m-m//i) % m) 
                i += 1
            return inv[n]
    
        MOD = 10**9+7
        count, result, comb_total = [0]*26, 0, 1
        for i in reversed(range(len(s))):
            num = ord(s[i])-ord('a') 
            count[num] += 1
            comb_total = (comb_total*(len(s)-i))*inverse(count[num], MOD)
            result = (result + (comb_total*sum(count[:num]))*inverse(len(s)-i, MOD)) % MOD
        return result",# Time:  O(26 * n) = O(n)
"class Solution(object):
    def rangeSum(self, nums, n, left, right):
        def countUntil(nums, target):
            result, curr, left = 0, 0, 0
            for right in range(len(nums)):
                curr += nums[right]
                while curr > target:
                    curr -= nums[left]
                    left += 1
                result += right-left+1
            return result
        
        def sumUntil(nums, prefix, target):
            result, curr, total, left = 0, 0, 0, 0
            for right in range(len(nums)):
                curr += nums[right]
                total += nums[right]*(right-left+1)
                while curr > target:
                    curr -= nums[left]
                    total -= prefix[right+1]-prefix[(left-1)+1]
                    left += 1
                result += total
            return result
            
        def sumLessOrEqualTo(prefix, nums, left, right, count):
            while left <= right:
                mid = left + (right-left)//2
                if countUntil(nums, mid)-count >= 0:
                    right = mid-1
                else:
                    left = mid+1
            return sumUntil(nums, prefix, left)-left*(countUntil(nums, left)-count)
    
        MOD = 10**9+7
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        m, M = min(nums), sum(nums)
        return (sumLessOrEqualTo(prefix, nums, m, M, right) -
                sumLessOrEqualTo(prefix, nums, m, M, left-1))%MOD
import heapq


",# Time:  O(nlog(sum(nums)))
"class Solution2(object):
    def rangeSum(self, nums, n, left, right):
        MOD = 10**9+7
        min_heap = []
        for i, num in enumerate(nums, 1):
            heapq.heappush(min_heap, (num, i))
        result = 0
        for i in range(1, right+1):
            total, j = heapq.heappop(min_heap)
            if i >= left:
                result = (result+total)%MOD
            if j+1 <= n:
                heapq.heappush(min_heap, (total+nums[j], j+1))
        return result",# Time:  O(nlog(sum(nums)))
"class Solution(object):
    def rootCount(self, edges, guesses, k):
        def iter_dfs():
            result = 0
            stk = [(0, -1)]
            while stk:
                u, p = stk.pop()
                result += int((p, u) in lookup)
                for v in adj[u]:
                    if v == p:
                        continue
                    stk.append((v, u))
            return result
        
        def iter_dfs2(curr):
            result = 0
            stk = [(0, -1, curr)]
            while stk:
                u, p, curr = stk.pop()
                if (p, u) in lookup:
                    curr -= 1
                if (u, p) in lookup:
                    curr += 1
                result += int(curr >= k)
                for v in adj[u]:
                    if v == p:
                        continue
                    stk.append((v, u, curr))
            return result

        adj = collections.defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        lookup = {(u, v) for u, v in guesses}
        curr = iter_dfs()
        return iter_dfs2(curr)

",# Time:  O(n) 
"class Solution2(object):
    def rootCount(self, edges, guesses, k):
        def dfs(u, p):
            cnt = int((p, u) in lookup)
            for v in adj[u]:
                if v == p:
                    continue
                cnt += dfs(v, u)
            return cnt
        
        def dfs2(u, p, curr):
            if (p, u) in lookup:
                curr -= 1
            if (u, p) in lookup:
                curr += 1
            cnt = int(curr >= k)
            for v in adj[u]:
                if v == p:
                    continue
                cnt += dfs2(v, u, curr)
            return cnt

        adj = collections.defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        lookup = {(u, v) for u, v in guesses}
        curr = dfs(0, -1)
        return dfs2(0, -1, curr)

",# Time:  O(n) 
"class Solution3(object):
    def rootCount(self, edges, guesses, k):
        cnt = [0]
        def memoization(u, p):
            if (u, p) not in memo:
                memo[u, p] = int((p, u) in lookup)
                for v in adj[u]:
                    if v == p:
                        continue
                    cnt[0] += 1
                    memo[u, p] += memoization(v, u)
            return memo[u, p]

        adj = collections.defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        lookup = {(u, v) for u, v in guesses}
        memo = {}
        return sum(memoization(i, -1) >= k for i in adj.keys())","# Time:  O(n) ~ O(n^2), worst case in star tree "
"class Solution(object):
    def countSmaller(self, nums):
        def countAndMergeSort(num_idxs, start, end, counts):
            if end - start <= 0: 
                return

            mid = start + (end - start) // 2
            countAndMergeSort(num_idxs, start, mid, counts)
            countAndMergeSort(num_idxs, mid + 1, end, counts)
            r = mid + 1
            tmp = []
            for i in range(start, mid + 1):
                while r <= end and num_idxs[r][0] < num_idxs[i][0]:
                    tmp.append(num_idxs[r])
                    r += 1
                tmp.append(num_idxs[i])
                counts[num_idxs[i][1]] += r - (mid + 1)

            num_idxs[start:start+len(tmp)] = tmp

        num_idxs = []
        counts = [0] * len(nums)
        for i, num in enumerate(nums):
            num_idxs.append((num, i))
        countAndMergeSort(num_idxs, 0, len(num_idxs) - 1, counts)
        return counts

",# Time:  O(nlogn)
"class Solution2(object):
    def countSmaller(self, nums):
        class BIT(object): 
            def __init__(self, n):
                self.__bit = [0]*(n+1) 

            def add(self, i, val):
                i += 1 
                while i < len(self.__bit):
                    self.__bit[i] += val
                    i += (i & -i)

            def query(self, i):
                i += 1 
                ret = 0
                while i > 0:
                    ret += self.__bit[i]
                    i -= (i & -i)
                return ret

        sorted_nums = sorted(zip(nums, list(range(len(nums)))))
        lookup = {i:new_i for new_i, (_, i) in enumerate(sorted_nums)}

        result, bit = [0]*len(nums), BIT(len(nums))
        for i in reversed(range(len(nums))):
            result[i] = bit.query(lookup[i]-1)
            bit.add(lookup[i], 1)
        return result

",# Time:  O(nlogn)
"class Solution3(object):
    def countSmaller(self, nums):
        res = [0] * len(nums)
        bst = self.BST()
        for i in reversed(range(len(nums))):
            bst.insertNode(nums[i])
            res[i] = bst.query(nums[i])

        return res

    class BST(object):
        class BSTreeNode(object):
            def __init__(self, val):
                self.val = val
                self.count = 0
                self.left = self.right = None

        def __init__(self):
            self.root = None

        def insertNode(self, val):
            node = self.BSTreeNode(val)
            if not self.root:
                self.root = node
                return
            curr = self.root
            while curr:
                if node.val < curr.val:
                    curr.count += 1 
                    if curr.left:
                        curr = curr.left
                    else:
                        curr.left = node
                        break
                else: 
                    if curr.right:
                        curr = curr.right
                    else:
                        curr.right = node
                        break

        def query(self, val):
            count = 0
            curr = self.root
            while curr:
                if val < curr.val:
                    curr = curr.left
                elif val > curr.val:
                    count += 1 + curr.count 
                    curr = curr.right
                else: 
                    return count + curr.count
            return 0
",# Time:  O(nlogn) ~ O(n^2)
"class Solution(object):
    def countSubgraphsForEachDiameter(self, n, edges):
        def dfs(n, adj, curr, parent, lookup, count, dp):
            for child in adj[curr]:
                if child == parent or lookup[child]:
                    continue
                dfs(n, adj, child, curr, lookup, count, dp)
            dp[curr][0][0] = 1
            for child in adj[curr]:
                if child == parent or lookup[child]:
                    continue
                new_dp_curr = [row[:] for row in dp[curr]]
                for curr_d in range(count[curr]):
                    for curr_max_d in range(curr_d, min(2*curr_d+1, count[curr])):
                        if not dp[curr][curr_d][curr_max_d]: 
                            continue
                        for child_d in range(count[child]):
                            for child_max_d in range(child_d, min(2*child_d+1, count[child])):
                                new_dp_curr[max(curr_d, child_d+1)][max(curr_max_d, child_max_d, curr_d+child_d+1)] += \
                                    dp[curr][curr_d][curr_max_d]*dp[child][child_d][child_max_d] 
                count[curr] += count[child] 
                dp[curr] = new_dp_curr

        adj = collections.defaultdict(list)
        for u, v in edges:
            u -= 1
            v -= 1
            adj[u].append(v)
            adj[v].append(u)
        lookup, result = [0]*n, [0]*(n-1)
        for i in range(n): 
            dp = [[[0]*n for _ in range(n)] for _ in range(n)]
            count = [1]*n
            dfs(n, adj, i, -1, lookup, count, dp) 
            lookup[i] = 1
            for d in range(1, n): 
                for max_d in range(d, min(2*d+1, n)): 
                    result[max_d-1] += dp[i][d][max_d]
        return result
import collections
import math

",# Time:  O(n^6)
"class Solution2(object):
    def countSubgraphsForEachDiameter(self, n, edges):
        def popcount(mask):
            count = 0
            while mask:
                mask &= mask-1
                count += 1
            return count

        def bfs(adj, mask, start):
            q = collections.deque([(start, 0)])
            lookup = 1<<start
            count = popcount(mask)-1
            u, d = None, None
            while q:
                u, d = q.popleft()
                for v in adj[u]:
                    if not (mask&(1<<v)) or (lookup&(1<<v)):
                        continue
                    lookup |= 1<<v  
                    count -= 1
                    q.append((v, d+1))
            return count == 0, u, d
        
        def max_distance(n, edges, adj, mask):
            is_valid, farthest, _ = bfs(adj, mask, int(math.log(mask&-mask, 2)))
            return bfs(adj, mask, farthest)[-1] if is_valid else 0

        adj = collections.defaultdict(list)
        for u, v in edges:
            u -= 1
            v -= 1
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*(n-1)
        for mask in range(1, 2**n):
            max_d = max_distance(n, edges, adj, mask)
            if max_d-1 >= 0:
                result[max_d-1] += 1
        return result
",# Time:  O(n^6)
"class Solution(object):
    def stringMatching(self, words):
        trie = AhoTrie(words)
        lookup = set()
        for i in range(len(words)):
            trie.reset()
            for c in words[i]:
                for j in trie.step(c):
                    if j != i:
                        lookup.add(j)
        return [words[i] for i in lookup]

","# Time:  O(n + m + z) = O(n), n is the total size of patterns"
"class Solution2(object):
    def stringMatching(self, words):
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
            
        def kmp(text, pattern, prefix):
            if not pattern:
                return 0
            if len(text) < len(pattern):
                return -1
            j = -1
            for i in range(len(text)):
                while j != -1 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1
            
        result = []
        for i, pattern in enumerate(words):
            prefix = getPrefix(pattern)
            for j, text in enumerate(words):
                if i != j and kmp(text, pattern, prefix) != -1:
                    result.append(pattern)
                    break
        return result

","# Time:  O(n^2 * l), n is the number of strings"
"class Solution3(object):
    def stringMatching(self, words):
        result = []
        for i, pattern in enumerate(words):
            for j, text in enumerate(words):
                if i != j and pattern in text:
                    result.append(pattern)
                    break
        return result","# Time:  O(n^2 * l^2), n is the number of strings"
"class Solution(object):
    def solveNQueens(self, n):
        def dfs(row):
            if row == n:
                result.append(['.'*x + ""Q"" + '.'*(n-x-1) for x in curr])
                return
            for i in range(n):
                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:
                    continue
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True
                curr.append(i)
                dfs(row+1)
                curr.pop()
                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False

        result, curr = [], []
        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)
        dfs(0)
        return result










",# Time:  O(n^2 * n!)
"class Solution2(object):
    def solveNQueens(self, n):
        def dfs(col_per_row, xy_diff, xy_sum):
            cur_row = len(col_per_row)
            if cur_row == n:
                ress.append(col_per_row)
            for col in range(n):
                if col not in col_per_row and cur_row-col not in xy_diff and cur_row+col not in xy_sum:
                    dfs(col_per_row+[col], xy_diff+[cur_row-col], xy_sum+[cur_row+col])
        ress = []
        dfs([], [], [])
        return [['.'*i + 'Q' + '.'*(n-i-1) for i in res] for res in ress]

",# Time:  O(n^2 * n!)
"class Solution(object):
    def isPowerOfTwo(self, n):
        return n > 0 and (n & (n - 1)) == 0

",# Time:  O(1)
"class Solution2(object):
    def isPowerOfTwo(self, n):
        return n > 0 and (n & ~-n) == 0
",# Time:  O(1)
"class Solution(object):
    def isPowerOfFour(self, num):
        return num > 0 and (num & (num - 1)) == 0 and \
               ((num & 0b01010101010101010101010101010101) == num)

",# Time:  O(1)
"class Solution2(object):
    def isPowerOfFour(self, num):
        while num and not (num & 0b11):
            num >>= 2
        return (num == 1)

",# Time:  O(1)
"class Solution3(object):
    def isPowerOfFour(self, num):
        num = bin(num)
        return True if num[2:].startswith('1') and len(num[2:]) == num.count('0') and num.count('0') % 2 and '-' not in num else False
",# Time:  O(1)
"class Solution(object):
    def selfDivisiblePermutationCount(self, n):
        def popcount(x):
            return bin(x).count('1')

        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        lookup = [[gcd(i+1, j+1) == 1 for j in range(n)] for i in range(n)]
        dp = [0]*(1<<n)
        dp[0] = 1
        for mask in range(1<<n):
            i = popcount(mask)
            for j in range(n):
                if mask&(1<<j) == 0 and lookup[i][j]:
                    dp[mask|(1<<j)] += dp[mask]
        return dp[-1]",# Time:  O(n^2 * logn + n * 2^n) = O(n * 2^n)
"class Solution(object):
    def bestTeamScore(self, scores, ages):
        players = sorted(zip(scores, ages))
        sorted_ages = sorted(set(ages))
        lookup = {age:i for i, age in enumerate(sorted_ages)} 
        segment_tree = SegmentTree(len(lookup))
        result = 0
        for score, age in players:
            segment_tree.update(lookup[age], lookup[age], segment_tree.query(0, lookup[age])+score)
        return segment_tree.query(0, len(lookup)-1)

",# Time:  O(nloga)
"class Solution2(object):
    def bestTeamScore(self, scores, ages):
        players = sorted(zip(ages, scores))
        sorted_scores = sorted(set(scores))
        lookup = {score:i for i, score in enumerate(sorted_scores)} 
        segment_tree = SegmentTree(len(lookup))
        result = 0
        for age, score in players:
            segment_tree.update(lookup[score], lookup[score], segment_tree.query(0, lookup[score])+score)
        return segment_tree.query(0, len(lookup)-1)
import collections


",# Time:  O(nlogs)
"class Solution3(object):
    def bestTeamScore(self, scores, ages):
        players = sorted(zip(scores, ages))
        sorted_ages = sorted(set(ages))
        dp = collections.defaultdict(int)
        result = 0
        for score, age in players:
            dp[age] = max(dp[a] for a in sorted_ages if a <= age) + score
        return max(dp.values())

",# Time:  O(nlogs)
"class Solution4(object):
    def bestTeamScore(self, scores, ages):
        players = sorted(zip(ages, scores))
        sorted_scores = sorted(set(scores))
        dp = collections.defaultdict(int)
        result = 0
        for age, score in players:
            dp[score] = max(dp[s] for s in sorted_scores if s <= score) + score
        return max(dp.values())

",# Time:  O(n * s)
"class Solution5(object):
    def bestTeamScore(self, scores, ages):
        players = sorted(zip(scores, ages))
        dp = [0]*len(players)
        result = 0
        for i in range(len(players)):
            dp[i] = players[i][0]
            for j in range(i):
                if players[j][1] <= players[i][1]:
                    dp[i] = max(dp[i], dp[j] + players[i][0])
            result = max(result, dp[i])
        return result

",# Time:  O(n^2)
"class Solution6(object):
    def bestTeamScore(self, scores, ages):
        players = sorted(zip(ages, scores))
        dp = [0]*len(players)
        result = 0
        for i in range(len(players)):
            dp[i] = players[i][1]
            for j in range(i):
                if players[j][1] <= players[i][1]:
                    dp[i] = max(dp[i], dp[j] + players[i][1])
            result = max(result, dp[i])
        return result",# Time:  O(n^2)
"class Solution(object):
    def minimumOperations(self, grid):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def iter_dfs(grid, i, j, lookup, adj):
            if lookup[i][j]:
                return
            lookup[i][j] = True
            stk = [(i, j, (i+j)%2)]
            while stk:
                i, j, color = stk.pop()
                for di, dj in directions:
                    ni, nj = i+di, j+dj
                    if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj]):
                        continue
                    if not color:
                        adj[len(grid[0])*ni+nj].append(len(grid[0])*i+j)
                    if lookup[ni][nj]:
                        continue
                    lookup[ni][nj] = True
                    stk.append((ni, nj, color^1))

        adj = collections.defaultdict(list)
        lookup = [[False]*len(grid[0]) for _ in range(len(grid))]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if not grid[i][j]:
                    continue
                iter_dfs(grid, i, j, lookup, adj)
        return len(bipartiteMatch(adj)[0])",# Time:  O(E * sqrt(V))
"class Solution(object):
    def containsCycle(self, grid):
        def index(n, i, j):
            return i*n + j
    
        union_find = UnionFind(len(grid)*len(grid[0]))
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i and j and grid[i][j] == grid[i-1][j] == grid[i][j-1] and \
                   union_find.find_set(index(len(grid[0]), i-1, j)) == \
                   union_find.find_set(index(len(grid[0]), i, j-1)):
                    return True
                if i and grid[i][j] == grid[i-1][j]:
                    union_find.union_set(index(len(grid[0]), i-1, j),
                                         index(len(grid[0]),i, j))
                if j and grid[i][j] == grid[i][j-1]:
                    union_find.union_set(index(len(grid[0]), i, j-1),
                                         index(len(grid[0]), i, j))
        return False

",# Time:  O(m * n * α(n)) ~= O(m * n)
"class Solution2(object):
    def containsCycle(self, grid):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if not grid[i][j]:
                    continue
                val = grid[i][j]
                q = [(i, j)]
                while q:
                    new_q = []
                    for r, c in q:
                        if not grid[r][c]:
                            return True
                        grid[r][c] = 0
                        for dr, dc in directions:
                            nr, nc = r+dr, c+dc
                            if not (0 <= nr < len(grid) and
                                    0 <= nc < len(grid[0]) and
                                    grid[nr][nc] == val):
                                continue
                            new_q.append((nr, nc))
                    q = new_q
        return False",# Time:  O(m * n)
"class Solution(object):
    def twoEggDrop(self, n):
        return int(math.ceil((-1+(1+8*n)**0.5)/2))",# Time:  O(1)
"class Solution2(object):
    def twoEggDrop(self, n):
        K = 2
        dp = [[float(""inf"") for j in range(n+1)] for _ in range(2)]
        dp[1] = [j for j in range(n+1)]
        for i in range(2, K+1):
            dp[i%2][0] = 0
            for j in range(1, n+1):
                for k in range(1, j+1):
                    dp[i%2][j] = min(dp[i%2][j], 1+max(dp[(i-1)%2][k-1], dp[i%2][j-k]))
        return dp[K%2][n]",# Time:  O(1)
"class Solution(object):
    def findBlackPixel(self, picture, N):
        rows, cols = [0] * len(picture),  [0] * len(picture[0])
        lookup = collections.defaultdict(int)
        for i in range(len(picture)):
            for j in range(len(picture[0])):
                if picture[i][j] == 'B':
                    rows[i] += 1
                    cols[j] += 1
            lookup[tuple(picture[i])] += 1

        result = 0
        for i in range(len(picture)):
            if rows[i] == N and lookup[tuple(picture[i])] == N:
                for j in range(len(picture[0])):
                     result += picture[i][j] == 'B' and cols[j] == N
        return result

",# Time:  O(m * n)
"class Solution2(object):
    def findBlackPixel(self, picture, N):
        lookup = collections.Counter(list(map(tuple, picture)))
        cols = [col.count('B') for col in zip(*picture)]
        return sum(N * list(zip(row, cols)).count(('B', N)) \
                   for row, cnt in lookup.items() \
                   if cnt == N == row.count('B'))
",# Time:  O(m * n)
"class Solution(object):
    def closestKValues(self, root, target, k):
        def nextNode(stack, child1, child2):
            if stack:
                if child2(stack):
                    stack.append(child2(stack))
                    while child1(stack):
                        stack.append(child1(stack))
                else:
                    child = stack.pop()
                    while stack and child is child2(stack):
                        child = stack.pop()

        backward = lambda stack: stack[-1].left
        forward = lambda stack: stack[-1].right

        stack = []
        while root:
            stack.append(root)
            root = root.left if target < root.val else root.right
        dist = lambda node: abs(node.val - target)
        forward_stack = stack[:stack.index(min(stack, key=dist))+1]

        backward_stack = list(forward_stack)
        nextNode(backward_stack, backward, forward)

        result = []
        for _ in range(k):
            if forward_stack and \
                (not backward_stack or dist(forward_stack[-1]) < dist(backward_stack[-1])):
                result.append(forward_stack[-1].val)
                nextNode(forward_stack, forward, backward)
            elif backward_stack and \
                (not forward_stack or dist(backward_stack[-1]) <= dist(forward_stack[-1])):
                result.append(backward_stack[-1].val)
                nextNode(backward_stack, backward, forward)
        return result

",# Time:  O(h + k)
"class Solution2(object):
    def closestKValues(self, root, target, k):
        class BSTIterator:
            def __init__(self, stack, child1, child2):
                self.stack = list(stack)
                self.cur = self.stack.pop()
                self.child1 = child1
                self.child2 = child2

            def __next__(self):
                node = None
                if self.cur and self.child1(self.cur):
                    self.stack.append(self.cur)
                    node = self.child1(self.cur)
                    while self.child2(node):
                        self.stack.append(node)
                        node = self.child2(node)
                elif self.stack:
                    prev = self.cur
                    node = self.stack.pop()
                    while node:
                        if self.child2(node) is prev:
                            break
                        else:
                            prev = node
                            node = self.stack.pop() if self.stack else None
                self.cur = node
                return node

        stack = []
        while root:
            stack.append(root)
            root = root.left if target < root.val else root.right
        dist = lambda node: abs(node.val - target) if node else float(""inf"")
        stack = stack[:stack.index(min(stack, key=dist))+1]

        backward = lambda node: node.left
        forward = lambda node: node.right
        smaller_it, larger_it = BSTIterator(stack, backward, forward), BSTIterator(stack, forward, backward)
        smaller_node, larger_node = next(smaller_it), next(larger_it)

        result = [stack[-1].val]
        for _ in range(k - 1):
            if dist(smaller_node) < dist(larger_node):
                result.append(smaller_node.val)
                smaller_node = next(smaller_it)
            else:
                result.append(larger_node.val)
                larger_node = next(larger_it)
        return result


",# Time:  O(h + k)
"class Solution(object):
    def printLinkedListInReverse(self, head):
        def print_nodes(head, count):
            nodes = []
            while head and len(nodes) != count:
                nodes.append(head)
                head = head.getNext()
            for node in reversed(nodes):
                node.printValue()
                   
        count = 0
        curr = head
        while curr:
            curr = curr.getNext()
            count += 1
        bucket_count = int(math.ceil(count**0.5))
        
        buckets = []
        count = 0
        curr = head
        while curr:
            if count % bucket_count == 0:
                buckets.append(curr)
            curr = curr.getNext()
            count += 1
        for node in reversed(buckets):
            print_nodes(node, bucket_count)",# Time:  O(n)
"class Solution2(object):
    def printLinkedListInReverse(self, head):
        nodes = []
        while head:
            nodes.append(head)
            head = head.getNext()
        for node in reversed(nodes):
            node.printValue()

",# Time:  O(n)
"class Solution3(object):
    def printLinkedListInReverse(self, head):
        tail = None
        while head != tail:
            curr = head
            while curr.getNext() != tail:
                curr = curr.getNext()
            curr.printValue()
            tail = curr",# Time:  O(n^2)
"class Solution(object):
    def countPairs(self, nums):
        L = 7
        POW10 = [0]*L
        POW10[0] = 1
        for i in range(L-1):
            POW10[i+1] = POW10[i]*10
        cnt1 = collections.Counter(nums)
        adj = collections.defaultdict(list)
        cnt = list(cnt1.items())
        for idx in range(len(cnt)):
            adj[cnt[idx][0]].append(idx)
            for i in range(L):
                a = cnt[idx][0]//POW10[i]%10
                for j in range(i+1, L):
                    b = cnt[idx][0]//POW10[j]%10
                    if a == b:
                        continue
                    adj[cnt[idx][0]-a*(POW10[i]-POW10[j])+b*(POW10[i]-POW10[j])].append(idx)
        result = sum(v*(v-1)//2 for v in cnt1.values())
        lookup = set()
        for u in adj.keys():
            for i in range(len(adj[u])):
                v1 = cnt[adj[u][i]][1]
                for j in range(i+1, len(adj[u])):
                    v2 = cnt[adj[u][j]][1]
                    if (adj[u][i], adj[u][j]) in lookup:
                        continue
                    lookup.add((adj[u][i], adj[u][j]))
                    result += v1*v2
        return result

",# Time:  O(n * l^4)
"class Solution2(object):
    def countPairs(self, nums):
        L = 7
        K = 2
        POW10 = [0]*L
        POW10[0] = 1
        for i in range(L-1):
            POW10[i+1] = POW10[i]*10
        def at_most(k, x):
            lookup = {x}
            result = [x]
            u = 0
            for _ in range(k):
                for u in range(u, len(result)):
                    x = result[u]
                    for i in range(L):
                        a = x//POW10[i]%10
                        for j in range(i+1, L):
                            b = x//POW10[j]%10
                            if a == b:
                                continue
                            y = x-a*(POW10[i]-POW10[j])+b*(POW10[i]-POW10[j])
                            if y in lookup:
                                continue
                            lookup.add(y)
                            result.append(y)
            return result

        result = 0
        cnt1 = collections.Counter(nums)
        cnt2 = collections.Counter()
        for x, v in cnt1.items():
            result += cnt2[x]*v+v*(v-1)//2
            for x in at_most(K, x):
                if x not in cnt1:
                    continue
                cnt2[x] += v
        return result",# Time:  O(n * l^(2 * k)) = O(n * l^4)
"class Solution(object):
    def makeAntiPalindrome(self, s):
        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        if max(cnt) > len(s)//2:
            return ""-1""
        result = [i for i, x in enumerate(cnt) for _ in range(x)]
        l = next(l for l in range((len(s)//2)//2+1) if result[len(s)//2+l] != result[len(s)//2-1])
        if l:
            for i in range(cnt[result[len(s)//2-1]]-l):
                result[len(s)//2+i], result[len(s)//2+i+l] = result[len(s)//2+i+l], result[len(s)//2+i]
        return """".join([chr(ord('a')+x) for x in result])

",# Time:  O(n + 26)
"class Solution2(object):
    def makeAntiPalindrome(self, s):
        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        if max(cnt) > len(s)//2:
            return ""-1""
        result = [i for i, x in enumerate(cnt) for _ in range(x)]
        left = len(s)//2
        right = left+1
        while right < len(s) and result[right] == result[left]:
            right += 1 
        while result[left] == result[len(s)-1-left]:
            result[left] , result[right] = result[right], result[left]
            left += 1
            right += 1
        return """".join([chr(ord('a')+x) for x in result])
",# Time:  O(n + 26)
"class Solution3(object):
    def makeAntiPalindrome(self, s):
        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        if max(cnt) > len(s)//2:
            return ""-1""
        result = [-1]*len(s)
        for i in range(len(s)//2):
            j = next(j for j in range(len(cnt)) if cnt[j])
            cnt[j] -= 1
            result[i] = j
        for i in range(len(s)//2, len(s)):
            j = next(j for j in range(len(cnt)) if cnt[j] and result[(len(s)-1)-i] != j)
            cnt[j] -= 1
            result[i] = j
        return """".join([chr(ord('a')+x) for x in result])",# Time:  O(n + 26)
"class Solution(object):
    def maxFrequency(self, nums, k, numOperations):
        nums.sort()
        result = 0
        left, right = 0, -1
        cnt = collections.defaultdict(int)
        for i in range(len(nums)):
            while right+1 < len(nums) and nums[right+1]-nums[i] <= k:
                cnt[nums[right+1]] += 1 
                right += 1
            while nums[i]-nums[left] > k:
                cnt[nums[left]] -= 1
                left += 1
            result = max(result, cnt[nums[i]]+min((right-left+1)-cnt[nums[i]], numOperations))
        left = 0
        for right in range(len(nums)):
            while nums[left]+k < nums[right]-k:
                left += 1
            result = max(result, min(right-left+1, numOperations))
        return result
    
import collections


",# Time:  O(nlogn)
"class Solution2(object):
    def maxFrequency(self, nums, k, numOperations):
        cnt = collections.defaultdict(int) 
        for x in nums:
            cnt[x] += 1
        diff = defaultdict(int)
        for x in nums:
            diff[x] += 0
            diff[x-k] += 1
            diff[x+k+1] -= 1
        result = curr = 0
        for x, c in sorted(diff.items()):
            curr += c
            result = max(result, cnt[x]+min(curr-cnt[x], numOperations))
        return result",# Time:  O(nlogn)
"class Solution(object):
    def exist(self, board, word):
        visited = [[False for j in range(len(board[0]))] for i in range(len(board))]

        for i in range(len(board)):
            for j in range(len(board[0])):
                if self.existRecu(board, word, 0, i, j, visited):
                    return True

        return False

    def existRecu(self, board, word, cur, i, j, visited):
        if cur == len(word):
            return True

        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[cur]:
            return False

        visited[i][j] = True
        result = self.existRecu(board, word, cur + 1, i + 1, j, visited) or\
                 self.existRecu(board, word, cur + 1, i - 1, j, visited) or\
                 self.existRecu(board, word, cur + 1, i, j + 1, visited) or\
                 self.existRecu(board, word, cur + 1, i, j - 1, visited)
        visited[i][j] = False

        return result
","# Time:  O(m * n * 4 * 3^(l - 1)) ~= O(m * n * 3^l), l is the length of the word"
"class Solution(object):
    def tripletCount(self, a, b, c):
        def popcount(x):
            return bin(x).count('1')

        def count(a):
            odd = sum(popcount(x)&1 for x in a)
            return [len(a)-odd, odd]
        
        cnt = list(map(count, (a, b, c)))
        return sum(cnt[0][0 if i == 0 or i == 1 else 1]*cnt[1][0 if i == 0 or i == 2 else 1]*cnt[2][0 if i == 0 or i == 3 else 1] for i in range(4))
","# Time:  O(nlogr), r = max(max(a), max(b), max(c))"
"class Solution2(object):
    def tripletCount(self, a, b, c):
        def popcount(x):
            return bin(x).count('1')

        def count(a):
            odd = sum(popcount(x)&1 for x in a)
            return [len(a)-odd, odd]
        
        even1, odd1 = count(a)
        even2, odd2 = count(b)
        even3, odd3 = count(c)
        return even1*even2*even3 + even1*odd2*odd3 + odd1*even2*odd3 + odd1*odd2*even3","# Time:  O(nlogr), r = max(max(a), max(b), max(c))"
"class Solution(object):
    def postorder(self, root):
        if not root:
            return []
        result, stack = [], [root]
        while stack:
            node = stack.pop()
            result.append(node.val)
            for child in node.children:
                if child:
                    stack.append(child)
        return result[::-1]

",# Time:  O(n)
"class Solution2(object):
    def postorder(self, root):
        def dfs(root, result):
            for child in root.children:
                if child:
                    dfs(child, result)
            result.append(root.val)
        
        result = []
        if root:
            dfs(root, result)
        return result
",# Time:  O(n)
"class Solution(object):
    def largestSumAfterKNegations(self, A, K):
        def kthElement(nums, k, compare):
            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == k:
                    return
                elif new_pivot_idx > k:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
                    
        kthElement(A, K, lambda a, b: a < b)
        remain = K
        for i in range(K):
            if A[i] < 0:
                A[i] = -A[i]
                remain -= 1
        return sum(A) - ((remain)%2)*min(A)*2

","# Time:  O(n) ~ O(n^2), O(n) on average."
"class Solution2(object):
    def largestSumAfterKNegations(self, A, K):
        A.sort()
        remain = K
        for i in range(K):
            if A[i] >= 0:
                break
            A[i] = -A[i]
            remain -= 1
        return sum(A) - (remain%2)*min(A)*2",# Time:  O(nlogn)
"class Solution(object):
    def findMin(self, nums):
        left, right = 0, len(nums)
        target = nums[-1]

        while left < right:
            mid = left + (right - left) / 2

            if nums[mid] <= target:
                right = mid
            else:
                left = mid + 1

        return nums[left]

",# Time:  O(logn)
"class Solution2(object):
    def findMin(self, nums):
        left, right = 0, len(nums) - 1
        while left < right and nums[left] >= nums[right]:
            mid = left + (right - left) / 2

            if nums[mid] < nums[left]:
                right = mid
            else:
                left = mid + 1

        return nums[left]

",# Time:  O(logn)
"class Solution(object):
    def digArtifacts(self, n, artifacts, dig):
        lookup = set(map(tuple, dig))
        return sum(all((i, j) in lookup for i in range(r1, r2+1) for j in range(c1, c2+1)) for r1, c1, r2, c2 in artifacts)
    
","# Time:  O(a + d), a is the number of grids covered by artifacts, d is the size of dig"
"class Solution2(object):
    def digArtifacts(self, n, artifacts, dig):
        lookup = {(i, j):idx for idx, (r1, c1, r2, c2) in enumerate(artifacts) for i in range(r1, r2+1) for j in range(c1, c2+1)}
        cnt = [(r2-r1+1)*(c2-c1+1) for r1, c1, r2, c2 in artifacts]
        result = 0
        for i, j in dig:
            if (i, j) not in lookup:
                continue
            cnt[lookup[i, j]] -= 1
            if not cnt[lookup[i, j]]:
                result += 1
        return result","# Time:  O(a + d), a is the number of grids covered by artifacts, d is the size of dig"
"class Solution(object):
    def findWords(self, board, words):
        visited = [[False for j in range(len(board[0]))] for i in range(len(board))]
        result = {}
        trie = TrieNode()
        for word in words:
            trie.insert(word)

        for i in range(len(board)):
            for j in range(len(board[0])):
                self.findWordsRecu(board, trie, 0, i, j, visited, [], result)

        return list(result.keys())

    def findWordsRecu(self, board, trie, cur, i, j, visited, cur_word, result):
        if not trie or i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:
            return

        if board[i][j] not in trie.leaves:
            return

        cur_word.append(board[i][j])
        next_node = trie.leaves[board[i][j]]
        if next_node.is_string:
            result["""".join(cur_word)] = True

        visited[i][j] = True
        self.findWordsRecu(board, next_node, cur + 1, i + 1, j, visited, cur_word, result)
        self.findWordsRecu(board, next_node, cur + 1, i - 1, j, visited, cur_word, result)
        self.findWordsRecu(board, next_node, cur + 1, i, j + 1, visited, cur_word, result)
        self.findWordsRecu(board, next_node, cur + 1, i, j - 1, visited, cur_word, result)
        visited[i][j] = False
        cur_word.pop()","# Time:  O(m * n * 4 * 3^(h - 1)) ~= O(m * n * 3^h), h is the height of trie"
"class Solution(object):

    def __init__(self, arr):
        Q, ERROR_RATE = 10000, 0.001
        self.__K = int(Q/ERROR_RATE).bit_length() 
        self.__arr = arr
        self.__inv_idx = collections.defaultdict(list)
        for i, x in enumerate(self.__arr):
            self.__inv_idx[x].append(i)

    def query(self, left, right, threshold):
        def count(inv_idx, m, left, right):
            return bisect.bisect_right(inv_idx[m], right) - \
                   bisect.bisect_left(inv_idx[m], left)

        for _ in range(self.__K):
            m = self.__arr[random.randint(left, right)]
            if count(self.__inv_idx, m, left, right) >= threshold:
                return m
        return -1

","# Time:  ctor:  O(n)
#        query: O(klogn), k = log2(Q/ERROR_RATE)"
"class Solution2(object):

    def __init__(self, arr):
        self.__arr = arr
        self.__inv_idx = collections.defaultdict(list)
        for i, x in enumerate(self.__arr):
            self.__inv_idx[x].append(i)
        self.__bound = int(round((len(arr)**0.5)))
        self.__majorities = [i for i, group in self.__inv_idx.items() if len(group) >= self.__bound]

    def query(self, left, right, threshold):
        def count(inv_idx, m, left, right):
            return bisect.bisect_right(inv_idx[m], right) - \
                   bisect.bisect_left(inv_idx[m], left)

        def boyer_moore_majority_vote(nums, left, right):
            m, cnt = nums[left], 1
            for i in range(left+1, right+1):
                if m == nums[i]:
                    cnt += 1
                else:
                    cnt -= 1
                    if cnt == 0:
                        m = nums[i]
                        cnt = 1
            return m

        if right-left+1 < self.__bound:
            m = boyer_moore_majority_vote(self.__arr, left, right)
            if count(self.__inv_idx, m, left, right) >= threshold:
                return m
        else:
            for m in self.__majorities:
                if count(self.__inv_idx, m, left, right) >= threshold:
                    return m
        return -1

","# Time:  ctor:  O(n)
#        query: O(sqrt(n)*logn)"
"class Solution3(object):

    def __init__(self, arr):
        def count(inv_idx, m, left, right):
            return bisect.bisect_right(inv_idx[m], right) - \
                   bisect.bisect_left(inv_idx[m], left)

        self.__arr = arr
        self.__inv_idx = collections.defaultdict(list)
        for i, x in enumerate(self.__arr):
            self.__inv_idx[x].append(i)
        self.__segment_tree = SegmentTreeRecu(arr, functools.partial(count, self.__inv_idx))

    def query(self, left, right, threshold):
        result = self.__segment_tree.query(left, right)
        if result[1] >= threshold:
            return result[0]
        return -1

","# Time:  ctor:  O(nlogn)
#        query: O((logn)^2)"
"class Solution4(object):

    def __init__(self, arr):
        self.__arr = arr
        self.__inv_idx = collections.defaultdict(list)
        for i, x in enumerate(self.__arr):
            self.__inv_idx[x].append(i)
        self.__bucket_size = int(round((len(arr)**0.5)))
        self.__bucket_majorities = []
        for left in range(0, len(self.__arr), self.__bucket_size):
            right = min(left+self.__bucket_size-1, len(self.__arr)-1)
            self.__bucket_majorities.append(self.__boyer_moore_majority_vote(self.__arr, left, right))

    def query(self, left, right, threshold):
        def count(inv_idx, m, left, right):
            return bisect.bisect_right(inv_idx[m], right) - \
                   bisect.bisect_left(inv_idx[m], left)

        l, r = left//self.__bucket_size, right//self.__bucket_size
        if l == r:
            m = self.__boyer_moore_majority_vote(self.__arr, left, right)
            if count(self.__inv_idx, m, left, right) >= threshold:
                return m
            return -1
        else:
            m = self.__boyer_moore_majority_vote(self.__arr, left, (l+1)*self.__bucket_size-1)
            if count(self.__inv_idx, m, left, right) >= threshold:
                return m
            m = self.__boyer_moore_majority_vote(self.__arr, r*self.__bucket_size, right)
            if count(self.__inv_idx, m, left, right) >= threshold:
                return m
            for i in range(l+1, r):
                if count(self.__inv_idx, self.__bucket_majorities[i], left, right) >= threshold:
                    return self.__bucket_majorities[i]
            return -1
    
    def __boyer_moore_majority_vote(self, nums, left, right):
            m, cnt = nums[left], 1
            for i in range(left+1, right+1):
                if m == nums[i]:
                    cnt += 1
                else:
                    cnt -= 1
                    if cnt == 0:
                        m = nums[i]
                        cnt = 1
            return m","# Time:  ctor:  O(n)
#        query: O(sqrt(n)*logn)"
"class Solution(object):
    def reachableNodes(self, edges, M, N):
        adj = [[] for _ in range(N)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))

        min_heap = [(0, 0)]
        best = collections.defaultdict(lambda: float(""inf""))
        best[0] = 0
        count = collections.defaultdict(lambda: collections.defaultdict(int))
        result = 0
        while min_heap:
            curr_total, u = heapq.heappop(min_heap) 
            if best[u] < curr_total:
                continue
            result += 1
            for v, w in adj[u]:
                count[u][v] = min(w, M-curr_total)
                next_total = curr_total+w+1
                if next_total <= M and next_total < best[v]:
                    best[v] = next_total
                    heapq.heappush(min_heap, (next_total, v)) 
        for u, v, w in edges:
            result += min(w, count[u][v]+count[v][u])
        return result
","# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|),
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)"
"class Solution(object):

    def __init__(self, w):
        self.__prefix_sum = list(w)
        for i in range(1, len(w)):
            self.__prefix_sum[i] += self.__prefix_sum[i-1]

    def pickIndex(self):
        target = random.randint(0, self.__prefix_sum[-1]-1)
        return bisect.bisect_right(self.__prefix_sum, target)


","# Time:  ctor: O(n)
#        pickIndex: O(logn)"
"class Solution(object):

    def __init__(self):
        self.__x_to_ys = collections.defaultdict(set)
        self.__point_counts = collections.defaultdict(int)

    def add(self, point):
        self.__x_to_ys[point[0]].add(point[1])
        self.__point_counts[tuple(point)] += 1
        

    def count(self, point):
        result = 0
        for y in self.__x_to_ys[point[0]]:
            if y == point[1]:
                continue
            dy = y-point[1]
            result += self.__point_counts[(point[0], y)]*self.__point_counts[(point[0]+dy, point[1])]*self.__point_counts[(point[0]+dy, y)]
            result += self.__point_counts[(point[0], y)]*self.__point_counts[(point[0]-dy, point[1])]*self.__point_counts[(point[0]-dy, y)]
        return result 

","# Time:  ctor:  O(1)
#        add:   O(1)
#        count: O(n)"
"class Solution2(object):

    def __init__(self):
        self.__points = []
        self.__point_counts = collections.defaultdict(int)

    def add(self, point):
        self.__points.append(point)
        self.__point_counts[tuple(point)] += 1

    def count(self, point):
        result = 0
        for x, y in self.__points:
            if not (point[0] != x and point[1] != y and (abs(point[0]-x) == abs(point[1]-y))):
                continue
            result += self.__point_counts[(point[0], y)]*self.__point_counts[(x, point[1])]
        return result","# Time:  ctor:  O(1)
#        add:   O(1)
#        count: O(n)"
"class Solution(object):

    def __init__(self, H, W):
        self.__exl = [[0 for _ in range(ord(W)-ord('A')+1)] \
                      for _ in range(H+1)]
        self.__fward = collections.defaultdict(lambda : collections.defaultdict(int))
        self.__bward = collections.defaultdict(set)


    def set(self, r, c, v):
        self.__reset_dependency(r, c)
        self.__update_others(r, c, v)


    def get(self, r, c):
        return self.__exl[r][ord(c) - ord('A')]


    def sum(self, r, c, strs):
        self.__reset_dependency(r, c)
        result = self.__calc_and_update_dependency(r, c, strs)
        self.__update_others(r, c, result)
        return result


    def __reset_dependency(self, r, c):
        key = (r, c)
        if key in list(self.__bward.keys()):
            for k in self.__bward[key]:
                self.__fward[k].pop(key, None)
            self.__bward[key] = set()


    def __calc_and_update_dependency(self, r, c, strs):
        result = 0
        for s in strs:
            s, e = s.split(':')[0], s.split(':')[1] if ':' in s else s
            left, right, top, bottom = ord(s[0])-ord('A'), ord(e[0])-ord('A'), int(s[1:]), int(e[1:])
            for i in range(top, bottom+1):
                for j in range(left, right+1):
                    result += self.__exl[i][j]
                    self.__fward[(i, chr(ord('A')+j))][(r, c)] += 1
                    self.__bward[(r, c)].add((i, chr(ord('A')+j)))
        return result


    def __update_others(self, r, c, v):
        prev = self.__exl[r][ord(c)-ord('A')]
        self.__exl[r][ord(c)-ord('A')] = v
        q = collections.deque()
        q.append(((r, c), v-prev))
        while q:
            key, diff = q.popleft()
            if key in self.__fward:
                for k, count in self.__fward[key].items():
                    q.append((k, diff*count))
                    self.__exl[k[0]][ord(k[1])-ord('A')] += diff*count


","# Time:  set: O((r * c)^2)
#        get: O(1)
#        sum: O((r * c)^2)"
"class Solution(object):

    def __init__(self):
        self.__n = 1
        self.__lookup = set()
        self.__min_heap = []

    def popSmallest(self):
        if self.__min_heap:
            result = heapq.heappop(self.__min_heap)
            self.__lookup.remove(result)
            return result
        result = self.__n
        self.__n += 1
        return result

    def addBack(self, num):
        if num >= self.__n or num in self.__lookup:
            return
        self.__lookup.add(num)
        heapq.heappush(self.__min_heap, num)","# Time:  ctor:        O(1)
#        popSmallest: O(logn)
#        addBack:     O(logn)"
"class Solution(object):

    def __init__(self, n_rows, n_cols):
        self.__n_rows = n_rows
        self.__n_cols = n_cols
        self.__n = n_rows*n_cols
        self.__lookup = {}
        

    def flip(self):
        self.__n -= 1
        target = random.randint(0, self.__n)
        x = self.__lookup.get(target, target)
        self.__lookup[target] = self.__lookup.get(self.__n, self.__n)
        return divmod(x, self.__n_cols)
        

    def reset(self):
        self.__n = self.__n_rows*self.__n_cols
        self.__lookup = {}
        

","# Time:  ctor:  O(1)
#        flip:  O(1)
#        reset: O(min(f, r * c))"
"class Solution(object):
    def mostFrequentPrime(self, mat):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))
        def numbers(i, j, di, dj):
            curr = 0
            while 0 <= i < len(mat) and 0 <= j < len(mat[0]):
                curr = curr*10+mat[i][j]
                yield curr
                i, j = i+di, j+dj

        cnt = collections.Counter(x for i in range(len(mat)) for j in range(len(mat[0])) for di, dj in DIRECTIONS for x in numbers(i, j, di, dj) if x > 10 and SPF[x] == x)
        cnt[-1] = 0
        return max(iter(cnt.keys()), key=lambda x: (cnt[x], x))

","# Time:  precompute: O(10^MAX_N_M)
#        runtime:    O(n * m * (n + m))"
"class Solution2(object):
    def mostFrequentPrime(self, mat):
        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))
        def numbers(i, j, di, dj):
            curr = 0
            while 0 <= i < len(mat) and 0 <= j < len(mat[0]):
                curr = curr*10+mat[i][j]
                yield curr
                i, j = i+di, j+dj

        cnt = collections.Counter(x for i in range(len(mat)) for j in range(len(mat[0])) for di, dj in DIRECTIONS for x in numbers(i, j, di, dj) if x > 10)
        cnt[-1] = 0
        return max((p for p in cnt.keys() if is_prime(p) or p == -1), key=lambda x: (cnt[x], x))",# Time:  O(n * m * (n + m) * sqrt(10^MAX_N_M))
"class Solution(object):

    def __init__(self):
        self.__live = {}
        self.__statistics = collections.defaultdict(lambda: [0, 0])
        

    def checkIn(self, id, stationName, t):
        self.__live[id] = (stationName, t)

    def checkOut(self, id, stationName, t):
        startStation, startTime = self.__live.pop(id)
        self.__statistics[startStation, stationName][0] += t-startTime
        self.__statistics[startStation, stationName][1] += 1
        
    def getAverageTime(self, startStation, endStation):
        total_time, cnt = self.__statistics[startStation, endStation]
        return float(total_time) / cnt","# Time:  ctor:       O(1)
#        checkin:    O(1)
#        checkout:   O(1)
#        getaverage: O(1)"
"class Solution(object):

    def __init__(self):
        self.__records = collections.defaultdict(lambda: SkipList(can_duplicated=True))
        self.__lookup = {""minute"":60, ""hour"":3600, ""day"":86400}

    def recordTweet(self, tweetName, time):
        self.__records[tweetName].add(time)

    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):
        delta = self.__lookup[freq]
        result = [0]*((endTime-startTime)//delta+1)
        it = self.__records[tweetName].lower_bound(startTime)
        while it is not None and it.val <= endTime:
            result[(it.val-startTime)//delta] += 1
            it = it.nexts[0]
        return result

","# Time:  add:   O(logn),
#        query: O(c), c is the total count of matching records"
"class Solution2(object):

    def __init__(self):
        self.__records = collections.defaultdict(list)
        self.__lookup = {""minute"":60, ""hour"":3600, ""day"":86400}

    def recordTweet(self, tweetName, time):
        bisect.insort(self.__records[tweetName], time)

    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):
        delta = self.__lookup[freq]
        i = startTime
        result = []
        while i <= endTime:
            j = min(i+delta, endTime+1)
            result.append(bisect.bisect_left(self.__records[tweetName], j) - \
                          bisect.bisect_left(self.__records[tweetName], i))
            i += delta
        return result
","# Time:  add:   O(n),
#        query: O(rlogn), r is the size of result"
"class Solution3(object):

    def __init__(self):
        self.__records = collections.defaultdict(list)
        self.__lookup = {""minute"":60, ""hour"":3600, ""day"":86400}

    def recordTweet(self, tweetName, time):
        self.__records[tweetName].append(time)

    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):
        delta = self.__lookup[freq]
        result = [0]*((endTime- startTime)//delta+1)
        for t in self.__records[tweetName]:
            if startTime <= t <= endTime:
                result[(t-startTime)//delta] += 1
        return result",#        query: O(n)
"class Solution(object):

    def __init__(self, head):
        self.__head = head


    def getRandom(self):
        reservoir = -1
        curr, n = self.__head, 0
        while curr:
            reservoir = curr.val if randint(1, n+1) == 1 else reservoir
            curr, n = curr.__next__, n+1
        return reservoir

","# Time:  ctor:      O(1)
#        getRandom: O(n)"
"class Solution2(object):

    def __init__(self, head):
        self.__lookup = []
        while head:
            self.__lookup.append(head.val)
            head = head.__next__
        

    def getRandom(self):
        return self.__lookup[randint(0, len(self.__lookup)-1)]","# Time:  ctor:      O(n)
#        getRandom: O(1)"
"class Solution(object):

    def __init__(self):
        self.__avails = []
        self.__videos = []
        self.__likes = []
        self.__dislikes = []
        self.__views = []

    def upload(self, video):
        if self.__avails:
            i = heapq.heappop(self.__avails)
        else:
            i = len(self.__videos)
            self.__videos.append(None)
            self.__likes.append(0)
            self.__dislikes.append(0)
            self.__views.append(0)
        self.__videos[i] = video
        return i
        
    def remove(self, videoId):
        if videoId >= len(self.__videos) or not self.__videos[videoId]:
            return
        heapq.heappush(self.__avails, videoId)
        self.__videos[videoId] = None
        self.__likes[videoId] = self.__dislikes[videoId] = self.__views[videoId] = 0
        
    def watch(self, videoId, startMinute, endMinute):
        if videoId >= len(self.__videos) or not self.__videos[videoId]:
            return ""-1""
        self.__views[videoId] += 1
        return self.__videos[videoId][startMinute:endMinute+1]

    def like(self, videoId):
        if videoId >= len(self.__videos) or not self.__videos[videoId]:
            return
        self.__likes[videoId] += 1

    def dislike(self, videoId):
        if videoId >= len(self.__videos) or not self.__videos[videoId]:
            return
        self.__dislikes[videoId] += 1

    def getLikesAndDislikes(self, videoId):
        if videoId >= len(self.__videos) or not self.__videos[videoId]:
            return [-1]
        return [self.__likes[videoId], self.__dislikes[videoId]]

    def getViews(self, videoId):
        if videoId >= len(self.__videos) or not self.__videos[videoId]:
            return -1
        return self.__views[videoId]","# Time:  ctor:                O(1)
#        upload:              O(logn+l)
#        remove:              O(logn)
#        like:                O(1)
#        dislike:             O(1)
#        view:                O(l)
#        getLikesAndDislikes: O(1)
#        getViews:            O(1)"
"class Solution(object):

    def __init__(self):
        self.__lookup = {"""": -1}

    def create(self, path, value):
        if path[:path.rfind('/')] not in self.__lookup:
            return False
        self.__lookup[path] = value
        return True
        
    def get(self, path):
        if path not in self.__lookup:
            return -1
        return self.__lookup[path]","# Time:  create: O(n)
#        get:    O(n)"
"class Solution(object):

    def __init__(self, homepage):
        self.__history = [homepage]
        self.__curr = 0        

    def visit(self, url):
        while len(self.__history) > self.__curr+1:
            self.__history.pop()
        self.__history.append(url)
        self.__curr += 1

    def back(self, steps):
        self.__curr = max(self.__curr-steps, 0)
        return self.__history[self.__curr]

    def forward(self, steps):
        self.__curr = min(self.__curr+steps, len(self.__history)-1)
        return self.__history[self.__curr]","# Time:  ctor  : O(1)
#        visit : O(n)
#        back  : O(1)
#        foward: O(1)"
"class Solution(object):

    def __init__(self, memoryLimit):
        self.__size = memoryLimit
        self.__q = collections.deque()
        self.__lookup = collections.defaultdict(SortedList)


    def addPacket(self, source, destination, timestamp):
        if (timestamp, source) in self.__lookup[destination]:
            return False
        self.__lookup[destination].add((timestamp, source))
        if len(self.__q) == self.__size:
            s, d, t = self.__q.popleft()
            self.__lookup[d].remove((t, s))
        self.__q.append((source, destination, timestamp))
        return True

    def forwardPacket(self):
        if not self.__q:
            return []
        s, d, t = self.__q.popleft()
        self.__lookup[d].remove((t, s))
        return [s, d, t]

    def getCount(self, destination, startTime, endTime):
        return self.__lookup[destination].bisect_left((endTime+1, 0))-self.__lookup[destination].bisect_left((startTime, 0))","# Time:  ctor:          O(1)
#        addPacket:     O(logn)
#        forwardPacket: O(logn)
#        getCount:      O(logn)"
"class Solution(object):
    def minAreaRect(self, points):
        nx = len(set(x for x, y in points))
        ny = len(set(y for x, y in points))

        p = collections.defaultdict(list)
        if nx > ny:
            for x, y in points:
                p[x].append(y)
        else:
            for x, y in points:
                p[y].append(x)

        lookup = {}
        result = float(""inf"")
        for x in sorted(p):
            p[x].sort()
            for j in range(len(p[x])):
                for i in range(j):
                    y1, y2 = p[x][i], p[x][j]
                    if (y1, y2) in lookup:
                        result = min(result, (x-lookup[y1, y2]) * (y2-y1))
                    lookup[y1, y2] = x
        return result if result != float(""inf"") else 0
    
    ","# Time:  O(n^1.5) on average
#        O(n^2) on worst"
"class Solution2(object):
    def minAreaRect(self, points):
        lookup = set()
        result = float(""inf"")
        for x1, y1 in points:
            for x2, y2 in lookup:
                if (x1, y2) in lookup and (x2, y1) in lookup:
                    result = min(result, abs(x1-x2) * abs(y1-y2))
            lookup.add((x1, y1))
        return result if result != float(""inf"") else 0","# Time:  O(n^1.5) on average
#        O(n^2) on worst"
"class Solution(object):
    def entityParser(self, text):
        patterns = [""&quot;"", ""&apos;"", ""&amp;"", ""&gt;"", ""&lt;"", ""&frasl;""]
        chars = [""\"""", ""'"", ""&"", "">"", ""<"", ""/""]
        trie = AhoTrie(patterns)
        positions = []
        for i in range(len(text)):
            for j in trie.step(text[i]):
                positions.append([i-len(patterns[j])+1, j])
        result = []
        i, j = 0, 0
        while i != len(text):
            if j == len(positions) or i != positions[j][0]:                    
                result.append(text[i])
                i += 1
            else:
                result.append(chars[positions[j][1]])
                i += len(patterns[positions[j][1]])
                j += 1
        return """".join(result)

","# Time:  O(n + m + z) = O(m), n is the total size of patterns"
"class Solution2(object):
    def entityParser(self, text):
        patterns = [""&quot;"", ""&apos;"", ""&amp;"", ""&gt;"", ""&lt;"", ""&frasl;""]
        chars = [""\"""", ""'"", ""&"", "">"", ""<"", ""/""]
        result = []
        i, j = 0, 0
        while i != len(text):
            if text[i] != '&':                    
                result.append(text[i])
                i += 1
            else:
                for j, pattern in enumerate(patterns):
                    if pattern == text[i:i+len(pattern)]:
                        result.append(chars[j])
                        i += len(pattern)
                        break
                else:
                    result.append(text[i])
                    i += 1
        return """".join(result)",# Time:  O(n)
"class Solution(object):

    def __init__(self):
        self.__accu = [1]

    def add(self, num):
        if not num:
            self.__accu = [1]
            return
        self.__accu.append(self.__accu[-1]*num)             

    def getProduct(self, k):
        if len(self.__accu) <= k:
            return 0
        return self.__accu[-1] // self.__accu[-1-k]","# Time:  ctor: O(1)
#        add : O(1)
#        get : O(1)"
"class Solution(object):

    def __init__(self, keys, values, dictionary):
        self.__lookup = {k: v for k, v in zip(keys, values)}
        self.__cnt = collections.Counter(self.encrypt(x) for x in dictionary)
        
    def encrypt(self, word1):
        if any(c not in self.__lookup for c in word1):
            return """"
        return """".join(self.__lookup[c] for c in word1)

    def decrypt(self, word2):
        return self.__cnt[word2]","# Time:  ctor:    O(m + d), m is len(keys), d is sum(len(x) for x in dictionary)
#        encrypt: O(n)
#        decrypt: O(n)"
"class Solution(object):
    def minOperations(self, nums):
        result = 0
        for i in reversed(range(len(nums)-1)):
            if nums[i] <= nums[i+1]:
                continue
            if SPF[nums[i]] > nums[i+1]:
                return -1
            nums[i] = SPF[nums[i]]
            result += 1
        return result","# Time:  precompute: O(r)
#        runtime:    O(n)"
"class Solution(object):
    def generatePossibleNextMoves(self, s):
        res = []
        i, n = 0, len(s) - 1
        while i < n:                                   
            if s[i] == '+':
                while i < n and s[i+1] == '+':         
                    res.append(s[:i] + '--' + s[i+2:]) 
                    i += 1
            i += 1
        return res

",# Time:  O(c * n + n) = O(n * (c+1))
"class Solution2(object):
  def generatePossibleNextMoves(self, s):
      return [s[:i] + ""--"" + s[i+2:] for i in range(len(s) - 1) if s[i:i+2] == ""++""]

","# Time:  O(c * m * n + n) = O(c * n + n), where m = 2 in this question
# This solution compares O(m) = O(2) times for two consecutive ""+"", where m is length of the pattern"
"class Solution(object):
    def __init__(self, dictionary):
        self.lookup_ = collections.defaultdict(set)
        for word in dictionary:
            abbr = self.abbreviation(word)
            self.lookup_[abbr].add(word)


    def isUnique(self, word):
        abbr = self.abbreviation(word)
        return self.lookup_[abbr] <= {word}


    def abbreviation(self, word):
        if len(word) <= 2:
            return word
        return word[0] + str(len(word)-2) + word[-1]


","# Time:  ctor:   O(n), n is number of words in the dictionary.
#        lookup: O(1)"
"class Solution(object):

    def __init__(self):
        self.__sl = SortedList()
        self.__i = 0

    def add(self, name, score):
        self.__sl.add((-score, name))
        
    def get(self):
        self.__i += 1
        return self.__sl[self.__i-1][1]","# Time:  add: O(logn)
#        get: O(logn)"
"class Solution(object):

    def __init__(self):
        self.__trie = Node()

    def insert(self, word):
        curr = self.__trie
        curr.pcnt += 1
        for c in word:
            if curr.children[ord(c)-ord('a')] is None:
                curr.children[ord(c)-ord('a')] = Node()
            curr = curr.children[ord(c)-ord('a')]
            curr.pcnt += 1
        curr.cnt += 1

    def countWordsEqualTo(self, word):
        curr = self.__trie
        for c in word:
            if curr.children[ord(c)-ord('a')] is None:
                return 0
            curr = curr.children[ord(c)-ord('a')]
        return curr.cnt

    def countWordsStartingWith(self, prefix):
        curr = self.__trie
        for c in prefix:
            if curr.children[ord(c)-ord('a')] is None:
                return 0
            curr = curr.children[ord(c)-ord('a')]
        return curr.pcnt

    def erase(self, word):
        cnt = self.countWordsEqualTo(word)
        if not cnt:
            return
        curr = self.__trie
        curr.pcnt -= 1
        for c in word:
            if curr.children[ord(c)-ord('a')].pcnt == 1:
                curr.children[ord(c)-ord('a')] = None 
                return
            curr = curr.children[ord(c)-ord('a')]
            curr.pcnt -= 1
        curr.cnt -= 1","# Time:  ctor:         O(1)
#        insert:       O(n)
#        count_word:   O(n)
#        count_prefix: O(n)
#        erase:        O(n)"
"class Solution(object):
    def digitSum(self, s, k):
        while len(s) > k:
            s = """".join(map(str, (sum(map(int, s[i:i+k])) for i in range(0, len(s), k))))
        return s","# Time:  O(n + n * (log10(9k)/k) + ... + k)
#      = O((n - (log10(9k)/k)*k)/(1-log10(9k)/k))
#      = O(n / (1-log10(9k)/k)) = O(n) for k >= 2"
"class Solution(object):

    def __init__(self, nums):
        self.__lookup = collections.defaultdict(list)
        for i, x in enumerate(nums):
            self.__lookup[x].append(i)

    def pick(self, target):
        return self.__lookup[target][randint(0, len(self.__lookup[target])-1)]

","# Time:  ctor: O(n)
#        pick: O(1)"
"class Solution_TLE(object):

    def __init__(self, nums):
        self.__nums = nums

    def pick(self, target):
        reservoir = -1
        n = 0
        for i in range(len(self.__nums)):
            if self.__nums[i] != target:
                continue
            reservoir = i if randint(1, n+1) == 1 else reservoir
            n += 1
        return reservoir


","# Time:  ctor: O(1)
#        pick: O(n)"
"class Solution(object):

    def __init__(self, m, k):
        self.__m = m
        self.__k = k
        self.__dq = collections.deque()
        self.__sl = SortedList()
        self.__total = self.__first_k = self.__last_k = 0

    def addElement(self, num):
        if len(self.__dq) == self.__m:
            self.__remove(self.__dq.popleft())
        self.__dq.append(num)
        self.__add(num)

    def calculateMKAverage(self):
        if len(self.__sl) < self.__m:
            return -1
        return (self.__total-self.__first_k-self.__last_k)//(self.__m-2*self.__k)

    def __add(self, num):
        self.__total += num
        idx = self.__sl.bisect_left(num)
        if idx < self.__k:
            self.__first_k += num
            if len(self.__sl) >= self.__k:
                self.__first_k -= self.__sl[self.__k-1]
        if idx > len(self.__sl)-self.__k:
            self.__last_k += num
            if len(self.__sl) >= self.__k:
                self.__last_k -= self.__sl[-self.__k]
        self.__sl.add(num)

    def __remove(self, num):
        self.__total -= num
        idx = self.__sl.index(num)
        if idx < self.__k:
            self.__first_k -= num
            self.__first_k += self.__sl[self.__k]
        elif idx > (len(self.__sl)-1)-self.__k:
            self.__last_k -= num
            self.__last_k += self.__sl[-1-self.__k]
        self.__sl.remove(num)","# Time:  ctor:           O(1)
#        add_element:    O(logn)
#        calc_mkaverage: O(1)"
"class Solution(object):

    def __init__(self):
        self.__logs = []
        self.__granularity = {'Year': 4, 'Month': 7, 'Day': 10, \
                              'Hour': 13, 'Minute': 16, 'Second': 19}


    def put(self, id, timestamp):
        self.__logs.append((id, timestamp))


    def retrieve(self, s, e, gra):
        i = self.__granularity[gra]
        begin = s[:i]
        end = e[:i]
        return sorted(id for id, timestamp in self.__logs \
                      if begin <= timestamp[:i] <= end)


","# Time:  put:      O(1)
#        retrieve: O(n + dlogd), n is the size of the total logs"
"class Solution(object):
    def nonSpecialCount(self, l, r):
        def count(x):
            return x-bisect.bisect_right(PRIMES, int(x**0.5))

        return count(r)-count(l-1)","# Time:  precompute:  O(sqrt(r))
#        runtime:     O(logr + log(sqrt(r))) = O(logr)"
"class Solution(object):
    def distanceSum(self, m, n, k):
        def sum_n(n):
            return (n+1)*n//2

        def sum_n_square(n):
            return n*(n+1)*(2*n+1)//6

        def f(n):
            return (n*sum_n(n-1)-sum_n_square(n-1))

        return (f(n)*m*m+f(m)*n*n)*nCr(m*n-2, k-2)%MOD
 ","# Time:  precompute: O(max(m * n))
#        runtime:    O(1)"
"class Solution(object):

    def __init__(self, words):
        _trie = lambda: collections.defaultdict(_trie)
        self.__trie = _trie()

        for weight, word in enumerate(words):
            word += 
            for i in range(len(word)):
                cur = self.__trie
                cur[""_weight""] = weight
                for j in range(i, 2*len(word)-1):
                    cur = cur[word[j%len(word)]]
                    cur[""_weight""] = weight

    def f(self, prefix, suffix):
        cur = self.__trie
        for letter in suffix + 
            if letter not in cur:
                return -1
            cur = cur[letter]
        return cur[""_weight""]

","# Time:  ctor:   O(w * l^2), w is the number of words, l is the word length on average
#        search: O(p + s)  , p is the length of the prefix, s is the length of the suffix,"
"class Solution2(object):

    def __init__(self, words):
        self.__prefix_trie = Trie()
        self.__suffix_trie = Trie()
        for i in reversed(range(len(words))):
            self.__prefix_trie.insert(words[i], i)
            self.__suffix_trie.insert(words[i][::-1], i)

    def f(self, prefix, suffix):
        prefix_match = self.__prefix_trie.find(prefix)
        suffix_match = self.__suffix_trie.find(suffix[::-1])
        i, j = 0, 0
        while i != len(prefix_match) and j != len(suffix_match):
            if prefix_match[i] == suffix_match[j]:
                return prefix_match[i]
            elif prefix_match[i] > suffix_match[j]:
                i += 1
            else:
                j += 1
        return -1


","# Time:  ctor:   O(w * l), w is the number of words, l is the word length on average
#        search: O(p + s + max(m, n)), p is the length of the prefix, s is the length of the suffix,"
"class Solution(object):

    def __init__(self, n, edges):
        self.__adj = [[] for _ in range(n)]
        for edge in edges:
            self.addEdge(edge)

    def addEdge(self, edge):
        u, v, w = edge
        self.__adj[u].append((v, w))

    def shortestPath(self, node1, node2):
        def dijkstra(adj, start, target):
            best = [float(""inf"")]*len(adj)
            best[start] = 0
            min_heap = [(best[start], start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if curr > best[u]:
                    continue
                for v, w in adj[u]:                
                    if not (curr+w < best[v]):
                        continue
                    best[v] = curr+w
                    heapq.heappush(min_heap, (best[v], v))
            return best[target] if best[target] != float(""inf"") else -1

        return dijkstra(self.__adj, node1, node2)","# Time:  ctor:         O(|V| + |E|)
#        addEdge:      O(1)
#        shortestPath: O((|E| + |V|) * log|V|) = O(|E| * log|V|)"
"class Solution:
    def __init__(self, nums):
        self.lookup = {i:v for i, v in enumerate(nums) if v}

    def dotProduct(self, vec):
        if len(self.lookup) > len(vec.lookup):
            self, vec = vec, self
        return sum(v*vec.lookup[i] for i, v in self.lookup.items() if i in vec.lookup)","# Time:  ctor: O(n)
#        dot_product: O(min(n, m))"
"class Solution(object):

    def __init__(self, nums):
        self.__q = collections.OrderedDict()
        self.__dup = set()
        for num in nums:
            self.add(num)

    def showFirstUnique(self):
        if self.__q:
            return next(iter(self.__q))
        return -1
    
    def add(self, value):
        if value not in self.__dup and value not in self.__q:
            self.__q[value] = None
            return
        if value in self.__q:
            self.__q.pop(value)
            self.__dup.add(value)
","# Time:  ctor: O(k)
#        add: O(1)
#        showFirstUnique: O(1)"
"class Solution(object):
    def beforeAndAfterPuzzles(self, phrases):
        lookup = collections.defaultdict(list)
        for i, phrase in enumerate(phrases):
            right = phrase.rfind(' ')
            word = phrase if right == -1 else phrase[right+1:]
            lookup[word].append(i)

        result_set = set()
        for i, phrase in enumerate(phrases):
            left = phrase.find(' ')
            word = phrase if left == -1 else phrase[:left]
            if word not in lookup:
                continue
            for j in lookup[word]:
                if j == i:
                    continue
                result_set.add(phrases[j] + phrase[len(word):])
        return sorted(result_set)","# Time:  O(l * rlogr)  , l is the max length of phrases
#                      , r is the number of result, could be up to O(n^2)"
"class Solution(object):
    def sumSubseqWidths(self, A):
        M = 10**9+7
        result, c = 0, 1
        A.sort()
        for i in range(len(A)):
            result = (result + (A[i]-A[len(A)-1-i])*c % M) % M
            c = (c<<1) % M
        return result
","# Time:  O(n)
# Spce:  O(1)"
"class Solution(object):

    def __init__(self, rectangle):
        self.__rectangle = rectangle
        self.__updates = []
        

    def updateSubrectangle(self, row1, col1, row2, col2, newValue):
        self.__updates.append((row1, col1, row2, col2, newValue))

    def getValue(self, row, col):
        for (row1, col1, row2, col2, newValue) in reversed(self.__updates):
            if row1 <= row <= row2 and col1 <= col <= col2:
                return newValue
        return self.__rectangle[row][col]

","# Time:  ctor:   O(1)
#        update: O(1)
#        get:    O(u), u is the number of updates"
"class Solution2(object):

    def __init__(self, rectangle):
        self.__rectangle = rectangle
        

    def updateSubrectangle(self, row1, col1, row2, col2, newValue):
        for r in range(row1, row2+1):
            for c in range(col1, col2+1):
                self.__rectangle[r][c] = newValue

    def getValue(self, row, col):
        return self.__rectangle[row][col]","# Time:  ctor:   O(1)
#        update: O(m * n)
#        get:    O(1)"
"class Solution(object):

    def __init__(self, parent):
        self.__parent = parent
        self.__children = [[] for _ in range(len(parent))]
        for i, x in enumerate(parent):
            if x != -1:
                self.__children[x].append(i)
        self.__locked = {}

    def lock(self, num, user):
        if num in self.__locked:
            return False
        self.__locked[num] = user
        return True

    def unlock(self, num, user):
        if self.__locked.get(num) != user:
            return False
        del self.__locked[num]
        return True

    def upgrade(self, num, user):
        node = num
        while node != -1:
            if node in self.__locked:
                return False
            node = self.__parent[node]
        result = False
        stk = [num]
        while stk:
            node = stk.pop()
            if node in self.__locked:
                del self.__locked[node]
                result = True
            for child in self.__children[node]:
                stk.append(child)
        if result:
            self.__locked[num] = user
        return result","# Time:  ctor:    O(n)
#        lock:    O(1)
#        unlock:  O(1)
#        upgrade: O(n)"
"class Solution(object):
    
    def __init__(self, N, blacklist):
        self.__n = N-len(blacklist)
        self.__lookup = {}
        white = iter(set(range(self.__n, N))-set(blacklist))
        for black in blacklist:
            if black < self.__n:
                self.__lookup[black] = next(white)
        
        
    def pick(self):
        index = random.randint(0, self.__n-1)
        return self.__lookup[index] if index in self.__lookup else index

","# Time:  ctor: O(b)
#        pick: O(1)"
"class Solution2(object):
    
    def __init__(self, N, blacklist):
        self.__n = N-len(blacklist)
        blacklist.sort()
        self.__blacklist = blacklist
        
    def pick(self):
        index = random.randint(0, self.__n-1)
        left, right = 0, len(self.__blacklist)-1
        while left <= right:
            mid = left+(right-left)//2
            if index+mid < self.__blacklist[mid]:
                right = mid-1
            else:
                left = mid+1
        return index+left


","# Time:  ctor: O(blogb)
#        pick: O(logb)"
"class Solution(object):
    def maxProbability(self, n, edges, succProb, start, end):
        adj = collections.defaultdict(list)
        for (u, v), p in zip(edges, succProb):
            adj[u].append((v, p))
            adj[v].append((u, p))
        max_heap = [(-1.0, start)]
        result, lookup = collections.defaultdict(float), set()
        result[start] = 1.0
        while max_heap and len(lookup) != len(adj):
            curr, u = heapq.heappop(max_heap)
            if u in lookup:
                continue
            lookup.add(u)
            for v, w in adj[u]:
                if v in lookup:
                    continue
                if v in result and result[v] >= -curr*w:
                    continue
                result[v] = -curr*w
                heapq.heappush(max_heap, (-result[v], v))
        return result[end]","# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)"
"class Solution(object):
    def shortestPathAllKeys(self, grid):
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def bfs(grid, source, locations):
            r, c = locations[source]
            lookup = [[False]*(len(grid[0])) for _ in range(len(grid))]
            lookup[r][c] = True
            q = collections.deque([(r, c, 0)])
            dist = {}
            while q:
                r, c, d = q.popleft()
                if source != grid[r][c] != '.':
                    dist[grid[r][c]] = d
                    continue
                for direction in directions:
                    cr, cc = r+direction[0], c+direction[1]
                    if not ((0 <= cr < len(grid)) and
                            (0 <= cc < len(grid[cr]))):
                        continue
                    if grid[cr][cc] != 
                        lookup[cr][cc] = True
                        q.append((cr, cc, d+1))
            return dist

        locations = {place: (r, c)
                     for r, row in enumerate(grid)
                     for c, place in enumerate(row)
                     if place not in '
        dists = {place: bfs(grid, place, locations) for place in locations}

        min_heap = [(0, '@', 0)]
        best = collections.defaultdict(lambda: collections.defaultdict(
                                                   lambda: float(""inf"")))
        best['@'][0] = 0
        target_state = 2**sum(place.islower() for place in locations)-1
        while min_heap:
            cur_d, place, state = heapq.heappop(min_heap)
            if best[place][state] < cur_d:
                continue
            if state == target_state:
                return cur_d
            for dest, d in dists[place].items():
                next_state = state
                if dest.islower():
                    next_state |= (1 << (ord(dest)-ord('a')))
                elif dest.isupper():
                    if not (state & (1 << (ord(dest)-ord('A')))):
                        continue
                if cur_d+d < best[dest][next_state]:
                    best[dest][next_state] = cur_d+d
                    heapq.heappush(min_heap, (cur_d+d, dest, next_state))
        return -1
","# Time:  O(k*r*c + |E|log|V|) = O(k*r*c + (k*|V|)*log|V|)
#                             = O(k*r*c + (k*(k*2^k))*log(k*2^k))
#                             = O(k*r*c + (k*(k*2^k))*(logk + k*log2))
#                             = O(k*r*c + (k*(k*2^k))*k)
#                             = O(k*r*c + k^3*2^k)"
"class Solution(object):
    def distinctPrimeFactors(self, nums):
        result = set()
        for x in set(nums): 
            for p in PRIMES:
                if p > x:
                    break
                if x%p:
                    continue
                result.add(p)
                while x%p == 0:
                    x //= p
            if x != 1: 
                result.add(x)
        return len(result)","# Time:  precompute: O(sqrt(MAX_N))
#        runtime:    O(m + nlog(logn)), m = len(nums), n = max(nums)"
"class Solution(object):

    def __init__(self, n):
        self.__n = n
        self.__matrix = set()
        self.__cnt = collections.defaultdict(int)
        self.__sl = SortedList([0])
        self.__lookup = collections.defaultdict(SortedList)
        self.__lookup[0].add(n-1)

    def setCell(self, x, y, z):
        if (x, y, z) in self.__matrix:
            return
        self.__matrix.add((x, y, z))
        if self.__cnt[x] or x == self.__n-1:
            self.__lookup[self.__cnt[x]].remove(x)
            if not self.__lookup[self.__cnt[x]]:
                del self.__lookup[self.__cnt[x]]
                self.__sl.remove(self.__cnt[x])
        self.__cnt[x] += 1
        if self.__cnt[x] not in self.__lookup:
            self.__sl.add(self.__cnt[x])
        self.__lookup[self.__cnt[x]].add(x)

    def unsetCell(self, x, y, z):
        if (x, y, z) not in self.__matrix:
            return
        self.__matrix.remove((x, y, z))
        self.__lookup[self.__cnt[x]].remove(x)
        if not self.__lookup[self.__cnt[x]]:
            del self.__lookup[self.__cnt[x]]
            self.__sl.remove(self.__cnt[x])
        self.__cnt[x] -= 1
        if self.__cnt[x] or x == self.__n-1:
            if self.__cnt[x] not in self.__lookup:
                self.__sl.add(self.__cnt[x])
            self.__lookup[self.__cnt[x]].add(x)

    def largestMatrix(self):
        return self.__lookup[self.__sl[-1]][-1]        

","# Time:  ctor:          O(1)
#        setCell:       O(logn)
#        unsetCell:     O(logn)
#        largestMatrix: O(logn)"
"class Solution2(object):

    def __init__(self, n):
        self.__matrix = {}
        self.__cnt = collections.defaultdict(int)
        self.__max_heap = [(0, -(n-1))]

    def setCell(self, x, y, z):
        if (x, y, z) in self.__matrix:
            return
        self.__matrix[x, y, z] = 1
        self.__cnt[x] += 1
        heapq.heappush(self.__max_heap, (-self.__cnt[x], -x))

    def unsetCell(self, x, y, z):
        if (x, y, z) not in self.__matrix:
            return
        del self.__matrix[x, y, z]
        self.__cnt[x] -= 1
        heapq.heappush(self.__max_heap, (-self.__cnt[x], -x))

    def largestMatrix(self):
        while self.__max_heap and -self.__max_heap[0][0] != self.__cnt[-self.__max_heap[0][1]]:
            heapq.heappop(self.__max_heap)
        return -self.__max_heap[0][1]","# Time:  ctor:          O(1)
#        setCell:       O(logn)
#        unsetCell:     O(logn)
#        largestMatrix: O(logn) on average"
"class Solution(object):

    def __init__(self, tasks):
        self.__lookup = {}
        self.__sl = SortedList()
        for userId, taskId, priority in tasks:
            self.add(userId, taskId, priority)

    def add(self, userId, taskId, priority):
        self.__sl.add((priority, taskId, userId))
        self.__lookup[taskId] = (userId, priority)

    def edit(self, taskId, newPriority):
        userId, _ = self.__lookup[taskId]
        self.rmv(taskId)
        self.add(userId, taskId, newPriority)

    def rmv(self, taskId):
        userId, priority = self.__lookup.pop(taskId)
        self.__sl.remove((priority, taskId, userId))

    def execTop(self):
        if not self.__sl:
            return -1
        _, taskId, userId = self.__sl[-1]
        self.rmv(taskId)
        return userId","# Time:  ctor:    O(tlogt)
#        add:     O(logt)
#        edit:    O(logt)
#        rmv:     O(logt)
#        execTop: O(logt)"
"class Solution(object):
    def __init__(self, nums):
        self.accu = [0]
        for num in nums:
            self.accu.append(self.accu[-1] + num),

    def sumRange(self, i, j):
        return self.accu[j + 1] - self.accu[i]


","# Time:  ctor:   O(n),
#        lookup: O(1)"
"class Solution(object):

    def __init__(self, balance):
        self.__balance = balance

    def transfer(self, account1, account2, money):
        if 1 <= account2 <= len(self.__balance) and self.withdraw(account1, money):
            return self.deposit(account2, money)
        return False

    def deposit(self, account, money):
        if 1 <= account <= len(self.__balance):
            self.__balance[account-1] += money
            return True
        return False

    def withdraw(self, account, money):
        if 1 <= account <= len(self.__balance) and self.__balance[account-1] >= money:
            self.__balance[account-1] -= money
            return True
        return False","# Time:  ctor:     O(1)
#        transer:  O(1)
#        deposit:  O(1)
#        withdraw: O(1)"
"class Solution(object):

    def __init__(self, persons, times):
        lead = -1
        self.__lookup, count = [], collections.defaultdict(int)
        for t, p in zip(times, persons):
            count[p] += 1
            if count[p] >= count[lead]:
                lead = p
                self.__lookup.append((t, lead))

    def q(self, t):
        return self.__lookup[bisect.bisect(self.__lookup,
                                           (t, float(""inf"")))-1][1]


","# Time:  ctor: O(n)
#        q:    O(logn)"
"class Solution(object):

    def __init__(self):
        self.__LAST_COUNT = 10
        self.__left = []
        self.__right = []

    def addText(self, text):
        for x in text:
            self.__left.append(x)

    def deleteText(self, k):
        return self.__move(k, self.__left, None)

    def cursorLeft(self, k):
        self.__move(k, self.__left, self.__right)
        return self.__last_characters()

    def cursorRight(self, k):
        self.__move(k, self.__right, self.__left)
        return self.__last_characters()

    def __move(self, k, src, dst):
        cnt = min(k, len(src))
        for _ in range(cnt):
            if dst is not None:
                dst.append(src[-1])
            src.pop()
        return cnt

    def __last_characters(self):
        return """".join(self.__left[-self.__LAST_COUNT:])","# Time:  ctor:        O(1)
#        addText:     O(l)
#        deleteText:  O(k)
#        cursorLeft:  O(k)
#        cursorRight: O(k)"
"class Solution(object):
    def subsequencePairCount(self, nums):
        def count(g):
            return reduce(lambda accu, x: (accu+x)%MOD, (MU[i]*MU[j]*f[i*g][j*g] for i in range(1, mx//g+1) for j in range(1, mx//g+1)), 0)
            
        mx = max(nums)
        cnt = [0]*(mx+1)
        for x in nums:
            cnt[x] += 1
        for i in range(1, mx+1):
            for j in range(i+i, mx+1, i):
                cnt[i] += cnt[j]
        f = [[0]*(mx+1) for _ in range(mx+1)]
        for g1 in range(1, mx+1):
            for g2 in range(g1, mx+1):
                l = LCM[g1][g2]
                c = cnt[l] if l < len(cnt) else 0
                c1, c2 = cnt[g1], cnt[g2]
                f[g1][g2] = f[g2][g1] = (POW3[c]*POW2[(c1-c)+(c2-c)]-POW2[c1]-POW2[c2]+1)%MOD
        return reduce(lambda accu, x: (accu+x)%MOD, (count(g) for g in range(1, mx+1)), 0) 

","# Time:  precompute: O(max_r^2 * log(max_r))
#        runtime:    O(n + r^2)"
"class Solution2(object):
    def subsequencePairCount(self, nums):
        MOD = 10**9+7
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        dp = collections.defaultdict(int)
        dp[(0, 0)] = 1
        for x in nums:
            new_dp = collections.defaultdict(int)
            for (g1, g2), cnt in list(dp.items()):
                ng1, ng2 = gcd(g1, x), gcd(g2, x)
                new_dp[(g1, g2)] = (new_dp[(g1, g2)]+cnt)%MOD
                new_dp[(ng1, g2)] = (new_dp[(ng1, g2)]+cnt)%MOD
                new_dp[(g1, ng2)] = (new_dp[(g1, ng2)]+cnt)%MOD
            dp = new_dp
        return reduce(lambda accu, x: (accu+x)%MOD, (cnt for (g1, g2), cnt in dp.items() if g1 == g2 > 0), 0)

",# Time:  O(n * r^2 * logr)
"class SolutionTLE(object):
    def subsequencePairCount(self, nums):
        MOD = 10**9+7
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        mx = max(nums)
        dp = [[0]*(mx+1) for _ in range(mx+1)]
        dp[0][0] = 1
        for x in nums:
            new_dp = [row[:] for row in dp]
            for g1 in reversed(range(mx+1)):
                for g2 in reversed(range(mx+1)):
                    ng1, ng2 = gcd(g1, x), gcd(g2, x)
                    new_dp[ng1][g2] = (new_dp[ng1][g2]+dp[g1][g2])%MOD
                    new_dp[g1][ng2] = (new_dp[g1][ng2]+dp[g1][g2])%MOD
            dp = new_dp
        return reduce(lambda accu, x: (accu+x)%MOD, (dp[g][g] for g in range(1, mx+1)), 0)",# Time:  O(n * r^2 * logr)
"class Solution(object):

    def __init__(self):
        self.__sl = SortedList()
        self.__cnt = 0

    def add(self, left, right):
        i = self.__sl.bisect_right((left,))
        if i-1 >= 0 and self.__sl[i-1][1]+1 >= left:
            i -= 1
            left = self.__sl[i][0]
        to_remove = []
        for i in range(i, len(self.__sl)):
            if not (right+1 >= self.__sl[i][0]):
                break
            right = max(right, self.__sl[i][1])
            self.__cnt -= self.__sl[i][1]-self.__sl[i][0]+1
            to_remove.append(i)
        while to_remove:
            del self.__sl[to_remove.pop()]
        self.__sl.add((left, right))
        self.__cnt += right-left+1

    def count(self):
        return self.__cnt","# Time:  ctor:  O(1)
#        add:   O(logn), amortized
#        count: O(1)"
"class Solution(object):
    def diagonalPrime(self, nums):
        result = 0
        for i in range(len(nums)):
            if nums[i][i] in PRIMES_SET:
                result = max(result, nums[i][i])
            if nums[i][~i] in PRIMES_SET:
                result = max(result, nums[i][~i])
        return result","# Time:  precompute: O(MAX_N)
#        runtime: O(n)"
"class Solution(object):
    def __init__(self, nums):
        if not nums:
            return
        self.__nums = nums
        self.__bit = [0] * (len(self.__nums) + 1)
        for i in range(1, len(self.__bit)):
            self.__bit[i] = nums[i-1] + self.__bit[i-1]

        for i in reversed(range(1, len(self.__bit))):
            last_i = i - (i & -i)
            self.__bit[i] -= self.__bit[last_i]

    def update(self, i, val):
        if val - self.__nums[i]:
            self.__add(i, val - self.__nums[i])
            self.__nums[i] = val

    def sumRange(self, i, j):
        return self.__sum(j) - self.__sum(i-1)

    def __sum(self, i):
        i += 1
        ret = 0
        while i > 0:
            ret += self.__bit[i]
            i -= (i & -i)
        return ret

    def __add(self, i, val):
        i += 1
        while i <= len(self.__nums):
            self.__bit[i] += val
            i += (i & -i)

","# Time:  ctor:   O(n),
#        update: O(logn),
#        query:  O(logn)"
"class Solution2(object):
    def __init__(self, nums,
                 query_fn=lambda x, y: x+y,
                 update_fn=lambda x, y: y,
                 default_val=0):
        N = len(nums)
        self.__original_length = N
        self.__tree_length = 2**(N.bit_length() + (N&(N-1) != 0))-1
        self.__query_fn = query_fn
        self.__update_fn = update_fn
        self.__default_val = default_val
        self.__tree = [default_val for _ in range(self.__tree_length)]
        self.__lazy = [None for _ in range(self.__tree_length)]
        self.__constructTree(nums, 0, self.__original_length-1, 0)

    def update(self, i, val):
        self.__updateTree(val, i, i, 0, self.__original_length-1, 0)

    def sumRange(self, i, j):
        return self.__queryRange(i, j, 0, self.__original_length-1, 0)

    def __constructTree(self, nums, left, right, idx):
        if left > right:
             return
        if left == right:
            self.__tree[idx] = self.__update_fn(self.__tree[idx], nums[left])
            return 
        mid = left + (right-left)//2
        self.__constructTree(nums, left, mid, idx*2 + 1)
        self.__constructTree(nums, mid+1, right, idx*2 + 2)
        self.__tree[idx] = self.__query_fn(self.__tree[idx*2 + 1], self.__tree[idx*2 + 2])

    def __apply(self, left, right, idx, val):
        self.__tree[idx] = self.__update_fn(self.__tree[idx], val)
        if left != right:
            self.__lazy[idx*2 + 1] = self.__update_fn(self.__lazy[idx*2 + 1], val)
            self.__lazy[idx*2 + 2] = self.__update_fn(self.__lazy[idx*2 + 2], val)

    def __updateTree(self, val, range_left, range_right, left, right, idx):
        if left > right:
            return
        if self.__lazy[idx] is not None:
            self.__apply(left, right, idx, self.__lazy[idx])
            self.__lazy[idx] = None
        if range_left > right or range_right < left:
            return
        if range_left <= left and right <= range_right:
            self.__apply(left, right, idx, val)
            return
        mid = left + (right-left)//2
        self.__updateTree(val, range_left, range_right, left, mid, idx*2 + 1)
        self.__updateTree(val, range_left, range_right, mid+1, right, idx*2 + 2)
        self.__tree[idx] = self.__query_fn(self.__tree[idx*2 + 1],
                                           self.__tree[idx*2 + 2])

    def __queryRange(self, range_left, range_right, left, right, idx):
        if left > right:
            return self.__default_val
        if self.__lazy[idx] is not None:
            self.__apply(left, right, idx, self.__lazy[idx])
            self.__lazy[idx] = None
        if right < range_left or left > range_right:
            return self.__default_val
        if range_left <= left and right <= range_right:
            return self.__tree[idx]
        mid = left + (right-left)//2
        return self.__query_fn(self.__queryRange(range_left, range_right, left, mid, idx*2 + 1), 
                               self.__queryRange(range_left, range_right, mid + 1, right, idx*2 + 2))","# Time:  ctor:   O(n),
#        update: O(logn),
#        query:  O(logn)"
"class Solution(object):

    def __init__(self, maxNumbers):
        self.__curr = 0
        self.__numbers = list(range(maxNumbers))
        self.__used = [False] * maxNumbers


    def get(self):
        if self.__curr == len(self.__numbers):
            return -1
        number = self.__numbers[self.__curr]
        self.__curr += 1
        self.__used[number] = True
        return number


    def check(self, number):
        return 0 <= number < len(self.__numbers) and \
               not self.__used[number]


    def release(self, number):
        if not 0 <= number < len(self.__numbers) or \
           not self.__used[number]:
            return
        self.__used[number] = False
        self.__curr -= 1
        self.__numbers[self.__curr] = number


","# init:     Time: O(n), Space: O(n)
# get:      Time: O(1), Space: O(1)
# check:    Time: O(1), Space: O(1)
# release:  Time: O(1), Space: O(1)"
"class Solution(object):
    def numberOfSequence(self, n, sick):
        MOD = 10**9+7
        def nCr(n, k):
            while len(INV) <= n: 
                FACT.append(FACT[-1]*len(INV) % MOD)
                INV.append(INV[MOD%len(INV)]*(MOD-MOD//len(INV)) % MOD) 
                INV_FACT.append(INV_FACT[-1]*INV[-1] % MOD)
            return (FACT[n]*INV_FACT[n-k] % MOD) * INV_FACT[k] % MOD
        
        result = 1
        total = cnt = 0
        for i in range(len(sick)+1):
            l = (sick[i] if i < len(sick) else n)-(sick[i-1] if i-1 >= 0 else -1)-1
            if i not in (0, len(sick)):
                cnt += max(l-1, 0)
            total += l
            result = (result*nCr(total, l))%MOD
        result = (result*pow(2, cnt, MOD))%MOD
        return result","# Time:  precompute: O(max_n)
#        runtime:    O(s + logn)"
"class Solution(object):

    def __init__(self, size):
        self.__lookup = [False]*size
        self.__flip = False
        self.__cnt = 0

    def fix(self, idx):
        if self.__lookup[idx] == self.__flip:
            self.__lookup[idx] = not self.__lookup[idx]
            self.__cnt += 1
            
    def unfix(self, idx):
        if self.__lookup[idx] != self.__flip:
            self.__lookup[idx] = not self.__lookup[idx]
            self.__cnt -= 1

    def flip(self):
        self.__flip = not self.__flip
        self.__cnt = len(self.__lookup)-self.__cnt
        

    def all(self):
        return self.__cnt == len(self.__lookup)

    def one(self):
        return self.__cnt >= 1

    def count(self):
        return self.__cnt

    def toString(self):
        result = ['']*len(self.__lookup)
        for i, x in enumerate(self.__lookup):
            result[i] = '1' if x != self.__flip else '0'
        return """".join(result)","# Time:  ctor:     O(n)
#        fix:      O(1)
#        unfix:    O(1)
#        flip:     O(1)
#        all:      O(1)
#        one:      O(1)
#        count:    O(1)
#        toString: O(n)"
"class Solution(object):

    def __init__(self, n, m):
        self.__st = SegmentTree(n,
                                build_fn=lambda _: [m]*2,
                                query_fn=lambda x, y: y if x is None else x if y is None else [max(x[0], y[0]), x[1]+y[1]])
        self.__m = m
        self.__i = 0

    def gather(self, k, maxRow):
        i = 1
        if k > self.__st.tree[i][0]:
            return []
        while i < self.__st.base:
            i = 2*i+int(self.__st.tree[2*i][0] < k)
        if i-self.__st.base > maxRow:
            return []
        cnt = self.__st.tree[i][0]
        c = self.__m-cnt
        i -= self.__st.base
        self.__st.update(i, [cnt-k]*2)
        return [i, c]

    def scatter(self, k, maxRow):
        cnt = self.__st.query(self.__i, maxRow)
        if not cnt or cnt[1] < k:
            return False
        for i in range(self.__i, maxRow+1):
            cnt = self.__st.tree[self.__st.base+i][1]
            c = min(cnt, k)
            cnt -= c
            if not cnt:
                self.__i += 1
            self.__st.update(i, [cnt]*2)
            k -= c
            if not k:
                break
        return True","# Time:  ctor:    O(n)
#        gather:  O(logn)
#        scatter: O(logn), amortized"
"class Solution(object):
    def intersect(self, nums1, nums2):
        if len(nums1) > len(nums2):
            return self.intersect(nums2, nums1)

        lookup = collections.defaultdict(int)
        for i in nums1:
            lookup[i] += 1

        res = []
        for i in nums2:
            if lookup[i] > 0:
                res += i,
                lookup[i] -= 1

        return res

    def intersect2(self, nums1, nums2):
        c = collections.Counter(nums1) & collections.Counter(nums2)
        intersect = []
        for i in c:
            intersect.extend([i] * c[i])
        return intersect


","#   - Time:  O(m + n)
#   - Space: O(min(m, n))"
"class Solution(object):
    def intersect(self, nums1, nums2):
        if len(nums1) > len(nums2):
            return self.intersect(nums2, nums1)

        def binary_search(compare, nums, left, right, target):
            while left < right:
                mid = left + (right - left) / 2
                if compare(nums[mid], target):
                    right = mid
                else:
                    left = mid + 1
            return left

        nums1.sort(), nums2.sort() 

        res = []
        left = 0
        for i in nums1:
            left = binary_search(lambda x, y: x >= y, nums2, left, len(nums2), i)
            if left != len(nums2) and nums2[left] == i:
                res += i,
                left += 1

        return res


","# Time:  O(min(m, n) * log(max(m, n)))"
"class Solution(object):
    def intersect(self, nums1, nums2):
        nums1.sort(), nums2.sort() 

        res = []

        it1, it2 = 0, 0
        while it1 < len(nums1) and it2 < len(nums2):
            if nums1[it1] < nums2[it2]:
                it1 += 1
            elif nums1[it1] > nums2[it2]:
                it2 += 1
            else:
                res += nums1[it1],
                it1 += 1
                it2 += 1

        return res


",# Time:  O(m + n)
"class Solution(object):
    def intersect(self, nums1, nums2):
        nums1.sort(), nums2.sort() 

        res = []

        it1, it2 = 0, 0
        while it1 < len(nums1) and it2 < len(nums2):
            if nums1[it1] < nums2[it2]:
                it1 += 1
            elif nums1[it1] > nums2[it2]:
                it2 += 1
            else:
                res += nums1[it1],
                it1 += 1
                it2 += 1

        return res
","# Time:  O(max(m, n) * log(max(m, n)))"
"class Solution(object):
    def minRectanglesToCoverPoints(self, points, w):
        points.sort(key=lambda x: x[0])
        result = 0
        left = -(w+1)
        for right, _ in points:
            if right-left <= w:
                continue
            left = right
            result += 1
        return result","# Time:  O(nlogn)
# Spade: O(n)"
"class Solution(object):

    def __init__(self):
        self.__idx_to_num = {}
        self.__num_to_idxs = collections.defaultdict(SortedList)

    def change(self, index, number):
        if index in self.__idx_to_num:
            self.__num_to_idxs[self.__idx_to_num[index]].remove(index)
            if not self.__num_to_idxs[self.__idx_to_num[index]]:
                del self.__num_to_idxs[self.__idx_to_num[index]]
        self.__idx_to_num[index] = number
        self.__num_to_idxs[number].add(index)

    def find(self, number):
        return self.__num_to_idxs[number][0] if number in self.__num_to_idxs else -1","# Time:  ctor:   O(1)
#        change: O(logn)
#        find:   O(1)"
"class Solution(object):

    def __init__(self, n, entries):
        self.__movie_to_ordered_price_shop = collections.defaultdict(SortedList) 
        self.__shop_movie_to_price = {}
        self.__rented_ordered_price_shop_movie = SortedList()
        for s, m, p in entries:
            self.__movie_to_ordered_price_shop[m].add((p, s))
            self.__shop_movie_to_price[s, m] = p

    def search(self, movie):
        return [s for _, s in self.__movie_to_ordered_price_shop[movie][:5]]

    def rent(self, shop, movie):
        price = self.__shop_movie_to_price[shop, movie]
        self.__movie_to_ordered_price_shop[movie].remove((price, shop))
        self.__rented_ordered_price_shop_movie.add((price, shop, movie))

    def drop(self, shop, movie):
        price = self.__shop_movie_to_price[shop, movie]
        self.__movie_to_ordered_price_shop[movie].add((price, shop))
        self.__rented_ordered_price_shop_movie.remove((price, shop, movie))

    def report(self):
        return [[s, m] for _, s, m in self.__rented_ordered_price_shop_movie[:5]]","# Time:  ctor:   O(nlogn)
#        search: O(logn)
#        rent:   O(logn)
#        drop:   O(logn)
#        report: O(logn)"
"class Solution(object):

    def __init__(self, maxSize):
        self.__max_size = maxSize
        self.__stk = []

    def push(self, x):
        if len(self.__stk) == self.__max_size:
            return
        self.__stk.append([x, 0])

    def pop(self):
        if not self.__stk:
            return -1
        x, inc = self.__stk.pop()
        if self.__stk:
            self.__stk[-1][1] += inc
        return x + inc

    def increment(self, k, val):
        i = min(len(self.__stk), k)-1
        if i >= 0:
            self.__stk[i][1] += val","# Time:  cotr:      O(1)
#        push:      O(1)
#        pop:       O(1)
#        increment: O(1)"
"class Solution(object):
    def maxLength(self, nums):
        result = 2
        lookup = collections.defaultdict(int)
        left = 0
        for right, x in enumerate(nums):
            for p in PRIME_DIVISORS[x]:
                left = max(left, lookup[p])
                lookup[p] = right+1
            result = max(result, right-left+1)
        return result","# Time:  precompute: O(r * log(logr)), r = MAX_NUM
#        runtime:    O(n * log(logr))"
"class Solution(object):

    def __init__(self, n, edgeList):
        edgeList.sort(key = lambda x:x[2])
        self.__uf = UnionFind(n)
        self.__adj = [[] for _ in range(n)]
        for index, (i, j, weight) in enumerate(edgeList):
            if not self.__uf.union_set(i, j):
                continue
            self.__adj[i].append((j, weight))
            self.__adj[j].append((i, weight))
        self.__tree_infos = TreeInfos(self.__adj)

    def query(self, p, q, limit):
        if self.__uf.find_set(p) != self.__uf.find_set(q):
            return False
        return self.__tree_infos.max_weights(p, q) < limit

","# Time:  ctor:  O(mlogm + m * α(n) + nlogn) ~= O(mlogm + nlogn)
#        query: O(α(n) + logn) ~= O(logn)"
"class Solution2(object):

    def __init__(self, n, edgeList):
        edgeList.sort(key = lambda x:x[2])
        self.__uf = VersionedUnionFind(n)
        self.__weights = []
        for index, (i, j, weight) in enumerate(edgeList):
            if not self.__uf.union_set(i, j):
                continue
            self.__uf.snap()
            self.__weights.append(weight)  

    def query(self, p, q, limit):
        snap_id = bisect.bisect_left(self.__weights, limit)-1
        if snap_id == -1:
            return False
        return self.__uf.find_set(p, snap_id) == self.__uf.find_set(q, snap_id)","# Time:  ctor:  O(mlogm + m * α(n) * logm) ~= O(mlogm)
#        query: O(logm + α(n) * logm) ~= O(logm)"
"class Solution(object):

    def __init__(self, words):
        self.__trie = AhoTrie(words)

    def query(self, letter): 
        return len(self.__trie.step(letter)) > 0

","# Time:  ctor:  O(n)    , n is the total size of patterns
#        query: O(m + z), m is the total size of query string"
"class Solution(object):

    def __init__(self, foods, cuisines, ratings):
        self.__food_to_cuisine = {}
        self.__food_to_rating = {}
        self.__cusine_to_rating_foods = collections.defaultdict(SortedList)
        for food, cuisine, rating in zip(foods, cuisines, ratings):
            self.__food_to_cuisine[food] = cuisine
            self.__food_to_rating[food] = rating
            self.__cusine_to_rating_foods[cuisine].add((-rating, food))

    def changeRating(self, food, newRating):
        old_rating = self.__food_to_rating[food]
        cuisine = self.__food_to_cuisine[food]
        self.__cusine_to_rating_foods[cuisine].remove((-old_rating, food))
        self.__food_to_rating[food] = newRating
        self.__cusine_to_rating_foods[cuisine].add((-newRating, food))

    def highestRated(self, cuisine):
        return self.__cusine_to_rating_foods[cuisine][0][1]","# Time:  ctor:         O(nlogn)
#        changeRating: O(logn)
#        highestRated: O(1)"
"class Solution(object):
    def minimumTime(self, n, edges, disappear):
        INF = float(""inf"")
        def modified_dijkstra(start):
            best = [-1]*n
            best[start] = 0
            min_heap = [(best[start], start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if curr != best[u]:
                    continue
                for v, w in adj[u]: 
                    if not curr+w < min(best[v] if best[v] != -1 else INF, disappear[v]): 
                        continue
                    best[v] = curr+w
                    heapq.heappush(min_heap, (best[v], v))
            return best
        
        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        return modified_dijkstra(0)","# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)"
"class Solution(object):

    def __init__(self):
        self.lookup = collections.defaultdict(list)

    def set(self, key, value, timestamp):
        self.lookup[key].append((timestamp, value))
        

    def get(self, key, timestamp):
        A = self.lookup.get(key, None)
        if A is None:
            return """"
        i = bisect.bisect_right(A, (timestamp+1, 0))
        return A[i-1][1] if i else """"





","# Time:  set: O(1)
#        get: O(logn)"
"class Solution(object):

    def __init__(self):
        self.__tasks = []
        self.__user_task_ids = collections.defaultdict(SortedList)

    def addTask(self, userId, taskDescription, dueDate, tags):
        self.__tasks.append([dueDate, taskDescription, set(tags)])
        self.__user_task_ids[userId].add((dueDate, len(self.__tasks)))
        return len(self.__tasks)

    def getAllTasks(self, userId):
        if userId not in self.__user_task_ids:
            return []
        return [self.__tasks[i-1][1] for _, i in self.__user_task_ids[userId]]

    def getTasksForTag(self, userId, tag):
        if userId not in self.__user_task_ids:
            return []
        return [self.__tasks[i-1][1] for _, i in self.__user_task_ids[userId] if tag in self.__tasks[i-1][-1]]

    def completeTask(self, userId, taskId):
        if not (taskId-1 < len(self.__tasks) and userId in self.__user_task_ids):
            return
        self.__user_task_ids[userId].discard((self.__tasks[taskId-1][0], taskId))

","# Time:  ctor:           O(1)
#        addTask:        O(l + logn), n is the number of user's tasks, l is the max length of a task
#        getAllTasks:    O(r), r is the length of result
#        getTasksForTag: O(r * c), r is the length of result, c is the length of the tag
#        completeTask:   O(l + logn)"
"class Solution2(object):

    def __init__(self):
        self.__tasks = []
        self.__user_task_ids = collections.defaultdict(SortedList)

    def addTask(self, userId, taskDescription, dueDate, tags):
        self.__tasks.append([dueDate, taskDescription, set(tags)])
        self.__user_task_ids[userId].add((dueDate, len(self.__tasks)))
        for tag in self.__tasks[-1][-1]:
            self.__user_task_ids[userId, tag].add((dueDate, len(self.__tasks)))
        return len(self.__tasks)

    def getAllTasks(self, userId):
        if userId not in self.__user_task_ids:
            return []
        return [self.__tasks[i-1][1] for _, i in self.__user_task_ids[userId]]

    def getTasksForTag(self, userId, tag):
        if (userId, tag) not in self.__user_task_ids:
            return []
        return [self.__tasks[i-1][1] for _, i in self.__user_task_ids[userId, tag]]

    def completeTask(self, userId, taskId):
        if not (taskId-1 < len(self.__tasks) and userId in self.__user_task_ids):
            return
        self.__user_task_ids[userId].discard((self.__tasks[taskId-1][0], taskId))
        for tag in self.__tasks[taskId-1][-1]:
            self.__user_task_ids[userId, tag].discard((self.__tasks[taskId-1][0], taskId))","# Time:  ctor:           O(1)
#        addTask:        O(l + t * logn), n is the number of user's tasks, l is the max length of a task, t is the number of tags
#        getAllTasks:    O(r), r is the length of result
#        getTasksForTag: O(r), r is the length of result
#        completeTask:   O(l + t * logn)"
"class Solution(object):

    def __init__(self, N):
        self.__num = N
        self.__seats = {-1: [-1, self.__num], self.__num: [-1, self.__num]}
        self.__max_heap = [(-self.__distance((-1, self.__num)), -1, self.__num)]

    def seat(self):
        while self.__max_heap[0][1] not in self.__seats or \
              self.__max_heap[0][2] not in self.__seats or \
              self.__seats[self.__max_heap[0][1]][1] != self.__max_heap[0][2] or \
              self.__seats[self.__max_heap[0][2]][0] !=  self.__max_heap[0][1]:
            heapq.heappop(self.__max_heap) 

        _, left, right = heapq.heappop(self.__max_heap)
        mid = 0 if left == -1 \
              else self.__num-1 if right == self.__num \
              else (left+right) // 2
        self.__seats[mid] = [left, right]
        heapq.heappush(self.__max_heap, (-self.__distance((left, mid)), left, mid))
        heapq.heappush(self.__max_heap, (-self.__distance((mid, right)), mid, right))
        self.__seats[left][1] = mid
        self.__seats[right][0] = mid
        return mid

    def leave(self, p):
        left, right = self.__seats[p]
        self.__seats.pop(p)
        self.__seats[left][1] = right
        self.__seats[right][0] = left
        heapq.heappush(self.__max_heap, (-self.__distance((left, right)), left, right))
        
    def __distance(self, segment):
        return segment[1]-segment[0]-1 if segment[0] == -1 or segment[1] == self.__num \
               else (segment[1]-segment[0]) // 2
","# Time:  seat:  O(logn), amortized
#        leave: O(logn)"
"class Solution(object):

    def __init__(self):
        self.__root = TrieNode()


    def ls(self, path):
        curr = self.__getNode(path)

        if curr.is_file:
            return [self.__split(path, '/')[-1]]

        return sorted(curr.children.keys())


    def mkdir(self, path):
        curr = self.__putNode(path)
        curr.is_file = False


    def addContentToFile(self, filePath, content):
        curr = self.__putNode(filePath)
        curr.is_file = True
        curr.content += content


    def readContentFromFile(self, filePath):
        return self.__getNode(filePath).content


    def __getNode(self, path):
        curr = self.__root
        for s in self.__split(path, '/'):
            curr = curr.children[s]
        return curr


    def __putNode(self, path):
        curr = self.__root
        for s in self.__split(path, '/'):
            if s not in curr.children:
                curr.children[s] = TrieNode()
            curr = curr.children[s]
        return curr


    def __split(self, path, delim):
        if path == '/':
            return []
        return path.split('/')[1:]

","# Time:  ls: O(l + klogk), l is the path length, k is the number of entries in the last level directory
#        mkdir: O(l)
#        addContentToFile: O(l + c), c is the content size
#        readContentFromFile: O(l + c)"
"class Solution(object):

    def __init__(self):
        self.__idx_to_val = collections.defaultdict(int)
        self.__val_to_idxs = collections.defaultdict(list)
        self.__top = None
        self.__max = None


    def push(self, x):
        idx = self.__val_to_idxs[self.__top][-1]+1 if self.__val_to_idxs else 0
        self.__idx_to_val[idx] = x
        self.__val_to_idxs[x].append(idx)
        self.__top = x
        self.__max = max(self.__max, x)


    def pop(self):
        val = self.__top
        self.__remove(val)
        return val


    def top(self):
        return self.__top


    def peekMax(self):
        return self.__max


    def popMax(self):
        val = self.__max
        self.__remove(val)
        return val


    def __remove(self, val):
        idx = self.__val_to_idxs[val][-1]
        self.__val_to_idxs[val].pop()
        if not self.__val_to_idxs[val]:
            del self.__val_to_idxs[val]
        del self.__idx_to_val[idx]
        if val == self.__top:
            self.__top = self.__idx_to_val[max(self.__idx_to_val.keys())] if self.__idx_to_val else None
        if val == self.__max:
            self.__max = max(self.__val_to_idxs.keys()) if self.__val_to_idxs else None


","# Time:  push:    O(1)
#        pop:     O(n), there is no built-in SortedDict in python. If applied, it could be reduced to O(logn)
#        popMax:  O(n)
#        top:     O(1)
#        peekMax: O(1)"
"class Solution(object):

    def __init__(self, names, columns):
        self.__table = {name:[column] for name, column in zip(names, columns)}

    def insertRow(self, name, row):
        row.append("""") 
        self.__table[name].append(row)

    def deleteRow(self, name, rowId):
        self.__table[name][rowId][-1] = ""deleted"" 

    def selectCell(self, name, rowId, columnId):
        return self.__table[name][rowId][columnId-1] if self.__table[name][rowId][-1] == """" else """"","# Time:  ctor:       O(t * max_m), t is the number of tables, max_m is the max number of columns in all tables
#        insertRow:  O(m), m is the number of columns
#        deleteRow:  O(1)
#        selectCell: O(m)"
"class Solution(object):

    def __init__(self, kingName):
        self.__king = kingName
        self.__family_tree = collections.defaultdict(list)
        self.__dead = set()
        

    def birth(self, parentName, childName):
        self.__family_tree[parentName].append(childName)


    def death(self, name):
        self.__dead.add(name)
        
    
    def getInheritanceOrder(self):
        result = []
        stk = [self.__king]
        while stk: 
            node = stk.pop()
            if node not in self.__dead:
                result.append(node)
            if node not in self.__family_tree:
                continue
            for child in reversed(self.__family_tree[node]):
                stk.append(child)
        return result
","# Time:  ctor:    O(1)
#        birth:   O(1)
#        death:   O(1)
#        inherit: O(n)"
"class Solution(object):
    def __init__(self, matrix):
        if not matrix:
            return
        self.__matrix = matrix
        self.__bit = [[0] * (len(self.__matrix[0]) + 1) \
                      for _ in range(len(self.__matrix) + 1)]
        for i in range(1, len(self.__bit)):
            for j in range(1, len(self.__bit[0])):
                self.__bit[i][j] = matrix[i-1][j-1] + self.__bit[i-1][j] + \
                                   self.__bit[i][j-1] - self.__bit[i-1][j-1]
        for i in reversed(range(1, len(self.__bit))):
            for j in reversed(range(1, len(self.__bit[0]))):
                last_i, last_j = i - (i & -i), j - (j & -j)
                self.__bit[i][j] = self.__bit[i][j] - self.__bit[i][last_j] - \
                                   self.__bit[last_i][j] + self.__bit[last_i][last_j]

    def update(self, row, col, val):
        if val - self.__matrix[row][col]:
            self.__add(row, col, val - self.__matrix[row][col])
            self.__matrix[row][col] = val

    def sumRegion(self, row1, col1, row2, col2):
        return self.__sum(row2, col2) - self.__sum(row2, col1 - 1) - \
               self.__sum(row1 - 1, col2) + self.__sum(row1 - 1, col1 - 1)

    def __sum(self, row, col):
        row += 1
        col += 1
        ret = 0
        i = row
        while i > 0:
            j = col
            while j > 0:
                ret += self.__bit[i][j]
                j -= (j & -j)
            i -= (i & -i)
        return ret

    def __add(self, row, col, val):
        row += 1
        col += 1
        i = row
        while i <= len(self.__matrix):
            j = col
            while j <= len(self.__matrix[0]):
                self.__bit[i][j] += val
                j += (j & -j)
            i += (i & -i)


","# Time:  ctor:   O(m * n)
#        update: O(logm * logn)
#        query:  O(logm * logn)"
"class Solution(object):

    def __init__(self):
        self.__cnt = collections.Counter()
        self.__freq = collections.Counter()

    def add(self, number):
        self.__freq[self.__cnt[number]] -= 1
        if self.__freq[self.__cnt[number]] == 0:
            del self.__freq[self.__cnt[number]]
        self.__cnt[number] += 1
        self.__freq[self.__cnt[number]] += 1
        

    def deleteOne(self, number):
        if self.__cnt[number] == 0:
            return
        self.__freq[self.__cnt[number]] -= 1
        if self.__freq[self.__cnt[number]] == 0:
            del self.__freq[self.__cnt[number]]
        self.__cnt[number] -= 1
        self.__freq[self.__cnt[number]] += 1
        if self.__cnt[number] == 0:
            del self.__cnt[number]
        

    def hasFrequency(self, frequency):
        return frequency in self.__freq","# Time:  ctor:         O(1)
#        add:          O(1)
#        deleteOne:    O(1)
#        hasFrequency: O(1)"
"class Solution(object):
    def minimumWeight(self, n, edges, src1, src2, dest):
        def dijkstra(adj, start):
            best = [float(""inf"")]*len(adj)
            best[start] = 0
            min_heap = [(0, start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if best[u] < curr:
                    continue
                for v, w in adj[u]:                
                    if best[v] <= curr+w:
                        continue
                    best[v] = curr+w
                    heapq.heappush(min_heap, (curr+w, v))
            return best
    
        adj1, adj2 = [[[] for _ in range(n)] for _ in range(2)]
        for u, v, w in edges:
            adj1[u].append((v, w))
            adj2[v].append((u, w))
        dist1 = dijkstra(adj1, src1)
        dist2 = dijkstra(adj1, src2)
        dist3 = dijkstra(adj2, dest)
        result = min(dist1[i]+dist2[i]+dist3[i] for i in range(n))
        return result if result != float(""inf"") else -1","# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|),
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)"
"class Solution(object):

    def __init__(self):
        self.__vals = [20, 50, 100, 200, 500]
        self.__cnt = [0]*len(self.__vals)

    def deposit(self, banknotesCount):
        for i, x in enumerate(banknotesCount):
            self.__cnt[i] += x

    def withdraw(self, amount):
        result = [0]*len(self.__cnt)
        for i in reversed(range(len(self.__vals))):
            result[i] = min(amount//self.__vals[i], self.__cnt[i])
            amount -= result[i]*self.__vals[i]
        if amount:
            return [-1]
        for i, c in enumerate(result):
            self.__cnt[i] -= c
        return result
        ","# Time:  ctor:     O(1)
#        deposit:  O(1)
#        withdraw: O(1)"
"class Solution(object):
    def canTraverseAllPairs(self, nums):
        def prime_factors(x):
            factors = collections.Counter()
            for p in PRIMES:
                if p*p > x:
                    break
                while x%p == 0:
                    factors[p] += 1
                    x //= p
            if x != 1:
                factors[x] += 1
            return factors

        def bfs():
            lookup = [False]*len(nums)
            lookup[0] = True
            q = [0]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return all(lookup)

        adj = [[] for _ in range(len(nums))]
        lookup = {}
        for i, x in enumerate(nums):
            for p in prime_factors(x):
                if p not in lookup:
                    lookup[p] = i
                    continue
                adj[i].append(lookup[p])
                adj[lookup[p]].append(i)
        return bfs()","# Time:  precompute: O(sqrt(r)), r = max(nums)
#        runtime:    O(n * (logr + pi(sqrt(r))) = O(n * (logr + sqrt(r)/log(sqrt(r)))), pi(n) = number of primes in a range [1, n] = O(n/logn) by prime number theorem, see https://en.wikipedia.org/wiki/Prime_number_theorem"
"class Solution(object):
    def hammingWeight(self, n):
        n = (n & 0x55555555) + ((n >> 1) & 0x55555555)
        n = (n & 0x33333333) + ((n >> 2) & 0x33333333)
        n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)
        n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)
        n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)
        return n

","# Time:  O(32), bit shift in python is not O(1), it's O(k), k is the number of bits shifted"
"class Solution2(object):
    def __init__(self):
        self.__popcount_tab = \
        [ \
            0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5, \
            1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6, \
            1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6, \
            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7, \
            1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6, \
            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7, \
            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7, \
            3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8 \
        ]

    def hammingWeight(self, n):
        result = 0
        while n:
            result += self.__popcount_tab[n & 0xff]
            n >>= 8
        return result
",# Time:  O(logn/4) = O(32/4 + 8*4) = O(32)
"class Solution3(object):
    def hammingWeight(self, n):
        result = 0
        while n:
            n &= n - 1
            result += 1
        return result
",# Time:  O(logn/4) = O(32/4 + 8*4) = O(32)
"class Solution4(object):
    def hammingWeight(self, n: int) -> int:
        b=""{0:b}"".format(n)
        result=b.count(""1"")
        return result",# Time:  O(logn) = O(32)
"class Solution(object):
    def lengthAfterTransformations(self, s, t):
        return reduce(lambda accu, x: (accu+x)%MOD, (DP[((ord(x)-ord('a'))+t)] for x in s), 0)

","# Time:  precompute: O(t + 26)
#        runtime:    O(n)"
"class Solution2(object):
    def lengthAfterTransformations(self, s, t):
        MOD = 10**9+7
        dp = [1]*26
        for i in range(26, (ord(max(s))-ord('a')+t)+1):
            dp[i%26] = (dp[(i-26)%26]+dp[((i-26)+1)%26])%MOD
        return reduce(lambda accu, x: (accu+x)%MOD, (dp[((ord(x)-ord('a'))+t)%26] for x in s), 0)

",# Time:  O(n + t + 26)
"class Solution3(object):
    def lengthAfterTransformations(self, s, t):
        MOD = 10**9+7
        def matrix_mult(A, B):
            ZB = list(zip(*B))
            return [[sum(a*b % MOD for a, b in zip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in range(len(A))] for i in range(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        nums = [1]*26
        nums[-1] = 2
        matrix = [[0]*26 for _ in range(26)]
        for i in range(len(nums)):
            for j in range(1, nums[i]+1):
                matrix[i][(i+j)%26] = 1
        matrix_pow_t = matrix_expo(matrix, t)
        return reduce(lambda accu, x: (accu+x)%MOD, matrix_mult([cnt], matrix_pow_t)[0], 0)

",# Time:  O(n + 26^3 * logt)
"class Solution4(object):
    def lengthAfterTransformations(self, s, t):
        MOD = 10**9+7
        cnt = [0]*26
        for x in s:
            cnt[ord(x)-ord('a')] += 1
        for _ in range(t):
            new_cnt = [0]*26
            for i in range(26):
                new_cnt[(i+1)%26] = (new_cnt[(i+1)%26]+cnt[i])%MOD
                if i == 25:
                    new_cnt[(i+2)%26] = (new_cnt[(i+2)%26]+cnt[i])%MOD
            cnt = new_cnt
        return reduce(lambda accu, x: (accu+x)%MOD, cnt, 0)",# Time:  O(n + t * 26)
"class Solution(object):

    def __init__(self, rects):
        self.__rects = list(rects)
        self.__prefix_sum = [(x[2]-x[0]+1)*(x[3]-x[1]+1) for x in rects]
        for i in range(1, len(self.__prefix_sum)):
            self.__prefix_sum[i] += self.__prefix_sum[i-1]

    def pick(self):
        target = random.randint(0, self.__prefix_sum[-1]-1)
        left = bisect.bisect_right(self.__prefix_sum, target)
        rect = self.__rects[left]
        width, height = rect[2]-rect[0]+1, rect[3]-rect[1]+1
        base = self.__prefix_sum[left]-width*height
        return [rect[0]+(target-base)%width, rect[1]+(target-base)//width]


","# Time:  ctor: O(n)
#        pick: O(logn)"
"class Solution(object):

    def __init__(self):
        self.__intervals = []

    def addRange(self, left, right):
        tmp = []
        i = 0
        for interval in self.__intervals:
            if right < interval[0]:
                tmp.append((left, right))
                break
            elif interval[1] < left:
                tmp.append(interval)
            else:
                left = min(left, interval[0])
                right = max(right, interval[1])
            i += 1
        if i == len(self.__intervals):
            tmp.append((left, right))
        while i < len(self.__intervals):
            tmp.append(self.__intervals[i])
            i += 1
        self.__intervals = tmp

    def queryRange(self, left, right):
        i = bisect.bisect_left(self.__intervals, (left, float(""inf"")))
        if i: i -= 1
        return bool(self.__intervals) and \
               self.__intervals[i][0] <= left and \
               right <= self.__intervals[i][1]

    def removeRange(self, left, right):
        tmp = []
        for interval in self.__intervals:
            if interval[1] <= left or interval[0] >= right:
                tmp.append(interval)
            else:
                if interval[0] < left:
                    tmp.append((interval[0], left))
                if right < interval[1]:
                    tmp.append((right, interval[1]))
        self.__intervals = tmp


","# Time:  addRange:    O(n)
#        removeRange: O(n)
#        queryRange:  O(logn)"
"class Solution(object):
    def isPrintable(self, targetGrid):
        VISITING, VISITED = list(range(2))
        def has_cycle(adj, color, lookup):
            stk = [(1, color)]
            while stk:
                step, color = stk.pop()
                if step == 1:
                    lookup[color] = VISITING
                    stk.append((2, color))
                    for new_color in adj[color]:
                        if new_color in lookup:
                            if lookup[new_color] == VISITED:
                                continue
                            return True 
                        stk.append((1, new_color))
                elif step == 2:
                    lookup[color] = VISITED
            return False

        boxes = collections.defaultdict(lambda:[len(targetGrid), len(targetGrid[0]), -1, -1])
        for r, row in enumerate(targetGrid):
            for c, color in enumerate(row):
                boxes[color][0] = min(boxes[color][0], r)
                boxes[color][1] = min(boxes[color][1], c)
                boxes[color][2] = max(boxes[color][2], r)
                boxes[color][3] = max(boxes[color][3], c)
        adj = collections.defaultdict(set)
        for color, (min_r, min_c, max_r, max_c) in boxes.items():
            for r in range(min_r, max_r+1):
                for c in range(min_c, max_c+1):
                    if targetGrid[r][c] != color:
                        adj[color].add(targetGrid[r][c])

        lookup = {}
        return all(color in lookup or not has_cycle(adj, color, lookup) for color in boxes.keys())","# Time:  O(c * m * n + e), c is the number of colors
#                        , e is the number of edges in adj, at most O(c^2)"
"class Solution2(object):
    def isPrintable(self, targetGrid):
        VISITING, VISITED = list(range(2))
        def has_cycle(adj, color, lookup):
            lookup[color] = VISITING
            for new_color in adj[color]:
                if (new_color not in lookup and has_cycle(adj, new_color, lookup)) or \
                   lookup[new_color] == VISITING:
                    return True
            lookup[color] = VISITED
            return False          

        MAX_COLOR = 60
        adj = collections.defaultdict(set)
        for color in range(1, MAX_COLOR+1):
            min_r = len(targetGrid)
            min_c = len(targetGrid[0])
            max_r = -1
            max_c = -1
            for r in range(len(targetGrid)):
                for c in range(len(targetGrid[r])):
                    if targetGrid[r][c] == color:
                        min_r = min(min_r, r)
                        min_c = min(min_c, c)
                        max_r = max(max_r, r)
                        max_c = max(max_c, c)
            for r in range(min_r, max_r+1):
                for c in range(min_c, max_c+1):
                    if targetGrid[r][c] != color:
                        adj[color].add(targetGrid[r][c])

        lookup = {}
        return all(color in lookup or not has_cycle(adj, color, lookup) for color in range(1, MAX_COLOR+1))","#                        , e is the number of edges in adj, at most O(c^2)"
"class Solution(object):
    def modifiedGraphEdges(self, n, edges, source, destination, target):
        def dijkstra(start, x):
            best = [target+1]*len(adj)
            best[start] = 0
            min_heap = [(0, start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if curr > best[u]:
                    continue
                for v, w in adj[u]:       
                    if w == -1:
                        w = x
                    if curr+w >= best[v]:
                        continue
                    best[v] = curr+w
                    heapq.heappush(min_heap, (best[v], v))
            return best
        
        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        left = dijkstra(source, 1)
        if not (left[destination] <= target):
            return []
        right= dijkstra(destination, target+1)
        if not (right[source] >= target):
            return []
        for e in edges:
            if e[2] == -1:
                e[2] = max(target-left[e[0]]-right[e[1]], target-left[e[1]]-right[e[0]], 1)
        return edges","# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)"
"class Solution(object):
    def maximalPathQuality(self, values, edges, maxTime):
        def iter_dfs(values, adj, maxTime):
            lookup, lookup2 = [0]*len(adj), set()
            result = 0
            stk = [(1, (0, maxTime, 0))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, time, total = args
                    lookup[u] += 1
                    if lookup[u] == 1:
                        total += values[u]
                    if not u:
                        result = max(result, total)
                    stk.append((4, (u,)))
                    for v, t in reversed(adj[u]):
                        if (u, v) in lookup2 or time < t: 
                            continue
                        stk.append((3, (u, v)))
                        stk.append((1, (v, time-t, total)))
                        stk.append((2, (u, v)))
                elif step == 2:
                    u, v = args
                    lookup2.add((u, v))
                elif step == 3:
                    u, v = args
                    lookup2.remove((u, v))
                elif step == 4:
                    u = args[0]
                    lookup[u] -= 1
            return result

        adj = [[] for _ in range(len(values))]
        for u, v, t in edges:
            adj[u].append((v, t))
            adj[v].append((u, t))
        return iter_dfs(values, adj, maxTime)

",# Time: O(|V| + |E|)
"class Solution2(object):
    def maximalPathQuality(self, values, edges, maxTime):
        def dfs(values, adj, u, time, total, lookup, lookup2, result):
            lookup[u] += 1
            if lookup[u] == 1:
                total += values[u]
            if not u:
                result[0] = max(result[0], total)
            for v, t in adj[u]:
                if (u, v) in lookup2 or time < t: 
                    continue
                lookup2.add((u, v))
                dfs(values, adj, v, time-t, total, lookup, lookup2, result)
                lookup2.remove((u, v))
            lookup[u] -= 1

        adj = [[] for _ in range(len(values))]
        for u, v, t in edges:
            adj[u].append((v, t))
            adj[v].append((u, t))
        result = [0]
        dfs(values, adj, 0, maxTime, 0, [0]*len(adj), set(), result)
        return result[0]

",# Time: O(|V| + |E|)
"class Solution3(object):
    def maximalPathQuality(self, values, edges, maxTime):
        def dfs(values, adj, u, time, total, lookup, lookup2):
            lookup[u] += 1
            if lookup[u] == 1:
                total += values[u]
            result = total if not u else 0
            for v, t in adj[u]:
                if (u, v) in lookup2 or time < t: 
                    continue
                lookup2.add((u, v))
                result = max(result, dfs(values, adj, v, time-t, total, lookup, lookup2))
                lookup2.remove((u, v))
            lookup[u] -= 1
            return result

        adj = [[] for _ in range(len(values))]
        for u, v, t in edges:
            adj[u].append((v, t))
            adj[v].append((u, t))
        return dfs(values, adj, 0, maxTime, 0, [0]*len(adj), set())",# Time: O(|V| + |E|)
"class Solution(object):
    def basicCalculatorIV(self, expression, evalvars, evalints):
        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul}
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(ops[operators.pop()](left, right))

        def parse(s):
            precedence = {'+':0, '-':0, '*':1}
            operands, operators, operand = [], [], []
            for i in range(len(s)):
                if s[i].isalnum():
                    operand.append(s[i])
                    if i == len(s)-1 or not s[i+1].isalnum():
                        operands.append(Poly("""".join(operand)))
                        operand = []
                elif s[i] == '(':
                    operators.append(s[i])
                elif s[i] == ')':
                    while operators[-1] != '(':
                        compute(operands, operators)
                    operators.pop()
                elif s[i] in precedence:
                    while operators and operators[-1] in precedence and \
                          precedence[operators[-1]] >= precedence[s[i]]:
                        compute(operands, operators)
                    operators.append(s[i])
            while operators:
                compute(operands, operators)
            return operands[-1]

        lookup = dict(zip(evalvars, evalints))
        return parse(expression).eval(lookup).to_list()

","# Time:  +:        O(d * t), t is the number of terms,"
"class Solution2(object):
    def basicCalculatorIV(self, expression, evalvars, evalints):
        def compute(operands, operators):
            left, right = operands.pop(), operands.pop()
            op = operators.pop()
            if op == '+':
                operands.append(left + right)
            elif op == '-':
                operands.append(left - right)
            elif op == '*':
                operands.append(left * right)

        def parse(s):
            if not s:
                return Poly()
            operands, operators = [], []
            operand = """"
            for i in reversed(range(len(s))):
                if s[i].isalnum():
                    operand += s[i]
                    if i == 0 or not s[i-1].isalnum():
                        operands.append(Poly(operand[::-1]))
                        operand = """"
                elif s[i] == ')' or s[i] == '*':
                    operators.append(s[i])
                elif s[i] == '+' or s[i] == '-':
                    while operators and operators[-1] == '*':
                        compute(operands, operators)
                    operators.append(s[i])
                elif s[i] == '(':
                    while operators[-1] != ')':
                        compute(operands, operators)
                    operators.pop()
            while operators:
                compute(operands, operators)
            return operands[-1]

        lookup = dict(zip(evalvars, evalints))
        return parse(expression).eval(lookup).to_list()
","# Time:  +:        O(d * t), t is the number of terms,
#        -:        O(d * t)
#        *:        O(d * t^2)
#        eval:     O(d * t)
#        to_list:  O(d * tlogt)"
"class Solution(object):

    def __init__(self, rows):
        self.__lookup = collections.defaultdict(int)


    def setCell(self, cell, value):
        self.__lookup[cell] = value


    def resetCell(self, cell):
        if cell in self.__lookup:
            del self.__lookup[cell]


    def getValue(self, formula):
        left, right = formula[1 :].split('+')
        x = self.__lookup.get(left, 0) if left[0].isalpha() else int(left)
        y = self.__lookup.get(right, 0) if right[0].isalpha() else int(right)
        return x+y","# Time:  ctor:      O(1)
#        setCell:   O(1)
#        resetCell: O(1)
#        getValue:  O(1)"
"class Solution(object):
    def countValidSelections(self, nums):
        total = sum(nums)
        result = curr = 0
        for x in nums:
            if not x:
                result += max(2-abs(curr-(total-curr)), 0)
            else:
                curr += x
        return result

",# Time:  O(n)
"class Solution2(object):
    def countValidSelections(self, nums):
        prefix = [0]*(len(nums)+1)
        for i in range(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        suffix = [0]*(len(nums)+1)
        for i in reversed(range(len(nums))):
            suffix[i] = suffix[i+1]+nums[i]
        return sum(max(2-abs(prefix[i]-suffix[i+1]), 0) for i in range(len(nums)) if nums[i] == 0)",# Time:  O(n)
"class Solution(object):

    def __init__(self, timeToLive):
        self.__time = timeToLive
        self.__lookup = collections.OrderedDict()

    def __evict(self, currentTime):
        while self.__lookup and next(iter(self.__lookup.values())) <= currentTime:
            self.__lookup.popitem(last=False)

    def generate(self, tokenId, currentTime):
        self.__evict(currentTime)
        self.__lookup[tokenId] = currentTime + self.__time


    def renew(self, tokenId, currentTime):
        self.__evict(currentTime)            
        if tokenId not in self.__lookup:
            return
        del self.__lookup[tokenId]
        self.__lookup[tokenId] = currentTime + self.__time

    def countUnexpiredTokens(self, currentTime):
        self.__evict(currentTime)
        return len(self.__lookup)","# Time:  ctor:     O(1)
#        generate: O(1), amortized
#        renew:    O(1), amortized
#        count:    O(1), amortized"
"class Solution(object):
    def countPaths(self, n, roads):
        MOD = 10**9+7

        def dijkstra(adj, start, target):
            best = collections.defaultdict(lambda:float(""inf""))
            best[start] = 0
            min_heap = [(0, start)]
            dp = [0]*(len(adj)) 
            dp[0] = 1
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if best[u] < curr:
                    continue
                if u == target: 
                    break
                for v, w in adj[u]:                
                    if v in best and best[v] <= curr+w:
                        if best[v] == curr+w: 
                            dp[v] = (dp[v]+dp[u])%MOD
                        continue
                    dp[v] = dp[u] 
                    best[v] = curr+w
                    heapq.heappush(min_heap, (curr+w, v))
            return dp[target]

        adj = [[] for i in range(n)]
        for u, v, w in roads:
            adj[u].append((v, w))
            adj[v].append((u, w))
        return dijkstra(adj, 0, n-1)","# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|),
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)"
"class Solution(object):
    def numberOfWays(self, n, x, y):
        return reduce(lambda accu, x: (accu+x)%MOD, (NCR[x][i]*DP[n][i]*POW[y][i] for i in range(1, min(n, x)+1)), 0)","# Time:  precompute: O(max_n^2 + max_y * min(max_n, max_x))
#        runtime:    O(min(n, x))"
"class Solution(object):

    def __init__(self, n, parent):
        par = [[p] if p != -1 else [] for p in parent]
        q = [par[i] for i, p in enumerate(parent) if p != -1]
        i = 0
        while q:
            new_q = []
            for p in q:
                if not (i < len(par[p[i]])):
                    continue
                p.append(par[p[i]][i])
                new_q.append(p)
            q = new_q
            i += 1
        self.__parent = par

    def getKthAncestor(self, node, k):
        par, i, pow_i_of_2 = self.__parent, 0, 1
        while pow_i_of_2 <= k:
            if k & pow_i_of_2:
                if not (i < len(par[node])):
                    return -1
                node = par[node][i]
            i += 1
            pow_i_of_2 *= 2
        return node","# Time:  ctor: O(n * logh)
#        get:  O(logh)"
"class Solution(object):
    def maxSizedArray(self, s):
        global i, area
        while vol[-1] <= s:
            area += 2*((i-1)*i+sum((((i-1)>>(bit+1))*(1<<bit))*(1<<bit) for bit in range((i-1).bit_length()) if not (i-1)&(1<<bit)))-((i-1)|(i-1))
            vol.append(((0+(i-1))*i//2)*area)
            i += 1
        return bisect.bisect_right(vol, s)-1","# Time:  precompute: O(max_s^(1/5) * log(max_s))
#        runtime:    O(log(max_s))"
"class Solution(object):

    def __init__(self):
        self.__total = 0
        self.__dq = collections.deque()
        self.__sl1 = SortedList()
        self.__sl2 = SortedList()
        self.__num_to_freq = collections.defaultdict(int)
        self.__sorted_freqs = SortedList()
        self.__freq_to_nums = collections.defaultdict(SortedList)

    def __update(self, number, d):
        if number in self.__num_to_freq:
            self.__freq_to_nums[self.__num_to_freq[number]].remove(number)
            if not self.__freq_to_nums[self.__num_to_freq[number]]:
                del self.__freq_to_nums[self.__num_to_freq[number]]
                self.__sorted_freqs.remove(self.__num_to_freq[number]) 
        self.__num_to_freq[number] += d
        if not self.__num_to_freq[number]:
            del self.__num_to_freq[number]
        else:
            if not self.__freq_to_nums[self.__num_to_freq[number]]:
                self.__sorted_freqs.add(self.__num_to_freq[number])
            self.__freq_to_nums[self.__num_to_freq[number]].add(number)

    def __rebalance(self):
        if len(self.__sl2) == len(self.__sl1)+2:
            self.__sl1.add(self.__sl2.pop(0))
        elif len(self.__sl2)+1 == len(self.__sl1):
            self.__sl2.add(self.__sl1.pop(-1))
        
    def addNumber(self, number):
        self.__total += number
        self.__dq.append(number)
        self.__update(number, +1)
        (self.__sl2 if not self.__sl2 or self.__sl2[0] <= number else self.__sl1).add(number)
        self.__rebalance()

    def removeFirstAddedNumber(self):
        number = self.__dq.popleft()
        self.__total -= number
        self.__update(number, -1)
        (self.__sl2 if number in self.__sl2 else self.__sl1).remove(number)
        self.__rebalance()

    def getMean(self):
        return self.__total//len(self.__dq)

    def getMedian(self):
        return self.__sl2[0]

    def getMode(self):
        return self.__freq_to_nums[self.__sorted_freqs[-1]][0]","# Time:  ctor:                   O(1)
#        addNumber:              O(logn)
#        removeFirstAddedNumber: O(logn)
#        getMean:                O(1)
#        getMedian:              O(1)
#        getMode:                O(1)"
"class Solution(object):

    def __init__(self, nums1, nums2):
        self.__nums2 = nums2
        self.__count1 = collections.Counter(nums1)
        self.__count2 = collections.Counter(nums2)

    def add(self, index, val):
        self.__count2[self.__nums2[index]] -= 1
        self.__nums2[index] += val
        self.__count2[self.__nums2[index]] += 1


    def count(self, tot):
        return sum(cnt * self.__count2[tot-x] for x, cnt in self.__count1.items())","# Time:  ctor:  O(n1 + n2)
#        add:   O(1)
#        count: O(n1)"
"class Solution(object):
    def __init__(self, matrix):
        if not matrix:
            return

        m, n = len(matrix), len(matrix[0])
        self.__sums = [[0 for _ in range(n+1)] for _ in range(m+1)]
        for i in range(1, m+1):
            for j in range(1, n+1):
                self.__sums[i][j] = self.__sums[i][j-1] + self.__sums[i-1][j] - \
                                    self.__sums[i-1][j-1] + matrix[i-1][j-1]

    def sumRegion(self, row1, col1, row2, col2):
        return self.__sums[row2+1][col2+1] - self.__sums[row2+1][col1] - \
               self.__sums[row1][col2+1] + self.__sums[row1][col1]


","# Time:  ctor:   O(m * n),
#        lookup: O(1)"
"class Solution(object):

    def __init__(self, n):
        self.__avails = SortedList([[0, n]])
        self.__lookup = collections.defaultdict(list)

    def allocate(self, size, mID):
        for l, s in self.__avails:
            if s < size:
                continue
            self.__avails.remove([l, s])
            self.__lookup[mID].append([l, size])
            if s-size > 0:
                self.__avails.add([l+size, s-size])
            return l
        return -1

    def free(self, mID):
        if mID not in self.__lookup:
            return 0
        result = 0
        for l, s in self.__lookup[mID]:
            self.__avails.add([l, s])
            i = self.__avails.bisect_left([l, s])
            if i+1 < len(self.__avails) and self.__avails[i][0]+self.__avails[i][1] == self.__avails[i+1][0]:
                self.__avails[i][1] += self.__avails[i+1][1]
                del self.__avails[i+1]
            if i-1 >= 0 and self.__avails[i-1][0]+self.__avails[i-1][1] == self.__avails[i][0]:
                self.__avails[i-1][1] += self.__avails[i][1]
                del self.__avails[i]            
            result += s
        del self.__lookup[mID]
        return result","# Time:  ctor:     O(1)
#        allocate: O(logn)
#        free:     O(logn)"
"class Solution(object):
    def minimumCost(self, n, highways, discounts):
        adj = [[] for _ in range(n)]
        for u, v, w in highways:
            adj[u].append((v, w))
            adj[v].append((u, w))
        src, dst = 0, n-1
        best = collections.defaultdict(lambda: collections.defaultdict(lambda: float(""inf"")))
        best[src][discounts] = 0
        min_heap = [(0, src, discounts)]
        while min_heap:
            result, u, k = heapq.heappop(min_heap)
            if best[u][k] < result:
                continue
            if u == dst:
                return result
            for v, w in adj[u]:
                if result+w < best[v][k]:
                    best[v][k] = result+w                    
                    heapq.heappush(min_heap, (result+w, v, k))
                if k > 0 and result+w//2 < best[v][k-1]:
                    best[v][k-1] = result+w//2                   
                    heapq.heappush(min_heap, (result+w//2, v, k-1))
        return -1","# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)"
"class Solution(object):
    def maximumRemovals(self, s, p, removable):
        def check(s, p, removable, x):
            lookup = set(removable[i] for i in range(x))
            j = 0
            for i in range(len(s)):
                if i in lookup or s[i] != p[j]:
                    continue
                j += 1
                if j == len(p):
                    return True
            return False

        left, right = 0, len(removable)
        while left <= right:
            mid = left + (right-left)//2
            if not check(s, p, removable, mid):
                right = mid-1
            else:
                left = mid+1
        return right

",# Time:  O(rlogn)
"class Solution2(object):
    def maximumRemovals(self, s, p, removable):
        def check(s, p, lookup, x):
            j = 0
            for i in range(len(s)):
                if lookup[i] <= x or s[i] != p[j]:
                    continue
                j += 1
                if j == len(p):
                    return True
            return False

        lookup = [float(""inf"")]*len(s)
        for i, r in enumerate(removable):
            lookup[r] = i+1
        left, right = 0, len(removable)
        while left <= right:
            mid = left + (right-left)//2
            if not check(s, p, lookup, mid):
                right = mid-1
            else:
                left = mid+1
        return right","# Time:  O(rlogn)
# if r = O(n), this is better"
"class Solution(object):

    def __init__(self):
        self.__curr = 0
        self.__lookup = {}
        self.__sl_by_price = SortedList()

    def update(self, timestamp, price):
        if timestamp > self.__curr:
            self.__curr = timestamp
        if timestamp in self.__lookup:
            self.__sl_by_price.remove(self.__lookup[timestamp])
        self.__lookup[timestamp] = price
        self.__sl_by_price.add(price)

    def current(self):
        return self.__lookup[self.__curr]

    def maximum(self):
        return next(reversed(self.__sl_by_price))

    def minimum(self):
        return next(iter(self.__sl_by_price))

","# Time:  ctor:    O(1)
#        update:  O(logn)
#        current: O(1)
#        max:     O(1)
#        min:     O(1)"
"class Solution2(object):

    def __init__(self):
        self.__curr = 0
        self.__lookup = {}
        self.__min_heap = []
        self.__max_heap = []

    def update(self, timestamp, price):
        def full_delete(heap, sign): 
            heap[:] = [x for x in set(heap) if sign*x[0] == self.__lookup[x[1]]]
            heapq.heapify(heap)

        if timestamp > self.__curr:
            self.__curr = timestamp
        self.__lookup[timestamp] = price
        heapq.heappush(self.__min_heap, (price, timestamp))
        heapq.heappush(self.__max_heap, (-price, timestamp))
        if len(self.__min_heap) > 2*len(self.__lookup): 
            full_delete(self.__min_heap, 1)
            full_delete(self.__max_heap, -1)

    def current(self):
        return self.__lookup[self.__curr]

    def maximum(self):
        while self.__max_heap and self.__lookup[self.__max_heap[0][1]] != -self.__max_heap[0][0]: 
            heapq.heappop(self.__max_heap)
        return -self.__max_heap[0][0]

    def minimum(self):
        while self.__min_heap and self.__lookup[self.__min_heap[0][1]] != self.__min_heap[0][0]: 
            heapq.heappop(self.__min_heap)
        return self.__min_heap[0][0]","# Time:  ctor:    O(1)
#        update:  O(logn)
#        current: O(1)
#        max:     O(logn) on average
#        min:     O(logn) on average"
"class Solution(object):
    def calcEquation(self, equations, values, queries):
        union_find = UnionFind()
        for (a, b), k in zip(equations, values):
            union_find.union_set(a, b, k)
        return [union_find.query_set(a, b) for a, b in queries]

","# Time:  O((e + q) * α(n)) ~= O(e + q), using either one of ""path compression"" and ""union by rank"" results in amortized O(logn)
#                                     , using  both results in α(n) ~= O(1)"
"class Solution2(object):
    def calcEquation(self, equations, values, queries):
        adj = collections.defaultdict(dict)
        for (a, b), k in zip(equations, values):
            adj[a][b] = k
            adj[b][a] = 1.0/k

        def bfs(adj, a, b, lookup):
            if a not in adj or b not in adj:
                return -1.0
            if (a, b) in lookup:
                return lookup[a, b]
            visited = {a}
            q = collections.deque([(a, 1.0)])
            while q:
                u, val = q.popleft()
                if u == b:
                    lookup[a, b] = val
                    return val
                for v, k in adj[u].items():
                    if v in visited:
                        continue                    
                    visited.add(v)
                    q.append((v, val*k))
            lookup[a, b] = -1.0
            return -1.0

        lookup = {}
        return [bfs(adj, a, b, lookup) for a, b in queries]

","# Time:  O(e + q * n), at most O(n^3 + q)"
"class Solution3(object):
    def calcEquation(self, equations, values, queries):
        adj = collections.defaultdict(dict)
        for (a, b), k in zip(equations, values):
            adj[a][a] = adj[b][b] = 1.0
            adj[a][b] = k
            adj[b][a] = 1.0/k
        for k in adj:
            for i in adj[k]:
                for j in adj[k]:
                    adj[i][j] = adj[i][k]*adj[k][j]
        return [adj[a].get(b, -1.0) for a, b in queries]

import collections

",# Time:  O(n^3 + q)
"class Solution4(object):
    def calcEquation(self, equations, values, query):
        def check(up, down, lookup, visited):
            if up in lookup and down in lookup[up]:
                return (True, lookup[up][down])
            for k, v in lookup[up].items():
                if k not in visited:
                    visited.add(k)
                    tmp = check(k, down, lookup, visited)
                    if tmp[0]:
                        return (True, v * tmp[1])
            return (False, 0)

        lookup = collections.defaultdict(dict)
        for i, e in enumerate(equations):
            lookup[e[0]][e[1]] = values[i]
            if values[i]:
                lookup[e[1]][e[0]] = 1.0 / values[i]

        result = []
        for q in query:
            visited = set()
            tmp = check(q[0], q[1], lookup, visited)
            result.append(tmp[1] if tmp[0] else -1)
        return result",# Time:  O(n^3 + q)
"class Solution(object):
    def networkDelayTime(self, times, N, K):
        adj = [[] for _ in range(N)]
        for u, v, w in times:
            adj[u-1].append((v-1, w))

        result = 0
        lookup = set()
        best = collections.defaultdict(lambda: float(""inf""))
        best[K-1] = 0
        min_heap = [(0, K-1)]
        while min_heap and len(lookup) != N:
            result, u = heapq.heappop(min_heap)
            lookup.add(u)
            if best[u] < result:
                continue
            for v, w in adj[u]:
                if v in lookup: continue
                if result+w < best[v]:
                    best[v] = result+w
                    heapq.heappush(min_heap, (result+w, v))
        return result if len(lookup) == N else -1
","# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)"
"class Solution(object):
    ADJACENTS = ((1, 0), (0, 1), (-1, 0), (0, -1))
    DIAGONALS = ((1, 1), (1, -1), (-1, 1), (-1, -1))


    def __init__(self, grid):
        self.__grid = grid
        self.__lookup = [None]*(len(grid)*len(grid[0]))
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                self.__lookup[grid[i][j]] = (i, j)


    def adjacentSum(self, value):
        return self.__sum(value, neighborSum.ADJACENTS)
    

    def diagonalSum(self, value):
        return self.__sum(value, neighborSum.DIAGONALS)


    def __sum(self, value, directions):
        i, j = self.__lookup[value]
        total = 0
        for di, dj in directions:
            ni, nj = i+di, j+dj
            if not (0 <= ni < len(self.__grid) and 0 <= nj < len(self.__grid[0])):
                continue
            total += self.__grid[ni][nj]
        return total
","# Time:  ctor:        O(n^2)
#        adjacentSum: O(1)
#.       diagonalSum: O(1)"
"class Solution(object):

    def __init__(self, m):
        self.__users = []
        self.__lookup = set()
        self.__min_heap = []

    def join(self, ownedChunks):
        if self.__min_heap:
            userID = heapq.heappop(self.__min_heap)
        else:
            userID = len(self.__users)+1
            self.__users.append(set())
        self.__users[userID-1] = set(ownedChunks)
        self.__lookup.add(userID)
        return userID

    def leave(self, userID):
        if userID not in self.__lookup:
            return
        self.__lookup.remove(userID)
        self.__users[userID-1] = []
        heapq.heappush(self.__min_heap, userID)

    def request(self, userID, chunkID):
        result = []
        for u, chunks in enumerate(self.__users, 1):
            if chunkID not in chunks:
                continue
            result.append(u)
        if not result:
            return
        self.__users[userID-1].add(chunkID)
        return result

","# Time:  ctor:    O(1)
#        join:    O(logu + c), u is the number of total joined users
#        leave:   O(logu + c), c is the number of chunks
#        request: O(u)"
"class Solution2(object):

    def __init__(self, m):
        self.__users = []
        self.__lookup = set() 
        self.__chunks = collections.defaultdict(set)
        self.__min_heap = []

    def join(self, ownedChunks):
        if self.__min_heap:
            userID = heapq.heappop(self.__min_heap)
        else:
            userID = len(self.__users)+1
            self.__users.append(set())
        self.__users[userID-1] = set(ownedChunks)
        self.__lookup.add(userID)
        for c in ownedChunks:
            self.__chunks[c].add(userID)
        return userID

    def leave(self, userID):
        if userID not in self.__lookup:
            return
        for c in self.__users[userID-1]:
            self.__chunks[c].remove(userID)
        self.__lookup.remove(userID)
        self.__users[userID-1] = []
        heapq.heappush(self.__min_heap, userID)

    def request(self, userID, chunkID):
        result = sorted(self.__chunks[chunkID])
        if not result:
            return
        self.__users[userID-1].add(chunkID)
        self.__chunks[chunkID].add(userID)
        return result","# Time:  ctor:    O(1)
#        join:    O(logu + c), u is the number of total joined users
#        leave:   O(logu + c), c is the number of chunks
#        request: O(nlogn)   , n is the average number of users who own the chunk"
"class Solution(object):

    def __init__(self, capacity):
        self.__stks = []
        self.__c = capacity
        self.__min_heap = []

    def push(self, val):
        if self.__min_heap:
            l = heapq.heappop(self.__min_heap)
            if l < len(self.__stks):
                self.__stks[l].append(val)
                return
            self.__min_heap = [] 
        if not self.__stks or len(self.__stks[-1]) == self.__c:
            self.__stks.append([])
        self.__stks[-1].append(val)

    def pop(self):
        while self.__stks and not self.__stks[-1]:
            self.__stks.pop()
        if not self.__stks:
            return -1
        return self.__stks[-1].pop()

    def popAtStack(self, index):
        if index >= len(self.__stks) or not self.__stks[index]:
            return -1
        heapq.heappush(self.__min_heap, index)
        return self.__stks[index].pop()","# Time:  push: O(logn)
#        pop:  O(1), amortized
#        popAtStack: O(logn)"
"class Solution(object):
    def closestPrimes(self, left, right):
        i = bisect.bisect_left(PRIMES, left)
        j = bisect.bisect_right(PRIMES, right)-1
        return ST.query(i, j-1)[1] if i <= j-1 else [-1]*2","# Time:  precompute:  O(MAX_N * log(MAX_N))
#        runtime:     O(log(MAX_N))"
"class Solution(object):
    def findCheapestPrice(self, n, flights, src, dst, K):
        adj = collections.defaultdict(list)
        for u, v, w in flights:
            adj[u].append((v, w))
        best = collections.defaultdict(lambda: collections.defaultdict(lambda: float(""inf"")))
        best[src][K+1] = 0
        min_heap = [(0, src, K+1)]
        while min_heap:
            result, u, k = heapq.heappop(min_heap)
            if k < 0 or best[u][k] < result:
                continue
            if u == dst:
                return result
            for v, w in adj[u]:
                if result+w < best[v][k-1]:
                    best[v][k-1] = result+w                    
                    heapq.heappush(min_heap, (result+w, v, k-1))
        return -1
","# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|),
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)"
"class Solution(object):
    def minimumDistance(self, n, edges, s, marked):
        def dijkstra(start):
            best = [float(""inf"")]*len(adj)
            best[start] = 0
            min_heap = [(0, start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if curr > best[u]:
                    continue
                if u in target:
                    return curr
                for v, w in adj[u]:     
                    if curr+w >= best[v]:
                        continue
                    best[v] = curr+w
                    heapq.heappush(min_heap, (best[v], v))
            return -1

        target = set(marked)
        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            adj[u].append((v, w))
        return dijkstra(s)","# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)"
"class Solution(object):

    def __init__(self, n):
        self.__lookup = set()
        self.__curr = 0

    def upload(self, video):
        self.__lookup.add(video-1)
        while self.__curr in self.__lookup:
            self.__lookup.remove(self.__curr)
            self.__curr += 1

    def longest(self):
        return self.__curr","# Time:  ctor:    O(1)
#        upload:  O(1), amortized
#        longest: O(1)"
"class Solution(object):

    def __init__(self, n, discount, products, prices):
        self.__n = n
        self.__discount = discount
        self.__curr = 0
        self.__lookup = {p : prices[i] for i, p in enumerate(products)}

    def getBill(self, product, amount):
        self.__curr = (self.__curr+1) % self.__n
        result = 0.0
        for i, p in enumerate(product):
            result += self.__lookup[p]*amount[i]
        return result * (1.0 - self.__discount/100.0 if self.__curr == 0 else 1.0)    ","# Time:  ctor:    O(m), m is the number of all products
#        getBill: O(p), p is the number of products to bill"
"class Solution(object):

    def __init__(self, length):
        self.__A = collections.defaultdict(lambda: [[0, 0]])
        self.__snap_id = 0


    def set(self, index, val):
        if self.__A[index][-1][0] == self.__snap_id:
            self.__A[index][-1][1] = val
        else:
            self.__A[index].append([self.__snap_id, val])


    def snap(self):
        self.__snap_id += 1
        return self.__snap_id - 1


    def get(self, index, snap_id):
        i = bisect.bisect_left(self.__A[index], [snap_id+1, float(""-inf"")]) - 1
        return self.__A[index][i][1]   ","# Time:  set: O(1)
#        get: O(logn), n is the total number of set"
"class Solution(object):
    def findAnswer(self, n, edges):
        INF = float(""inf"")
        def dijkstra(start):
            best = [INF]*len(adj)
            best[start] = 0
            min_heap = [(0, start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if curr > best[u]:
                    continue
                for v, w in adj[u]:     
                    if best[v] <= curr+w:
                        continue
                    best[v] = curr+w
                    heapq.heappush(min_heap, (best[v], v))
            return best
    
        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        dist1 = dijkstra(0)
        dist2 = dijkstra(n-1)
        return [(dist1[u] != INF != dist2[v] and dist1[u]+w+dist2[v] == dist1[n-1]) or
                (dist2[u] != INF != dist1[v] and dist2[u]+w+dist1[v] == dist2[0])
                for i, (u, v, w) in enumerate(edges)]","# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)"
"class Solution(object):

    def __init__(self):
        self.__lookup = collections.Counter()
        
    def addScore(self, playerId, score):
        self.__lookup[playerId] += score

    def top(self, K):
        def kthElement(nums, k, compare):
            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in range(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left <= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == k:
                    return
                elif new_pivot_idx > k:
                    right = new_pivot_idx - 1
                else: 
                    left = new_pivot_idx + 1
        
        scores = list(self.__lookup.values())
        kthElement(scores, K, lambda a, b: a > b)
        return sum(scores[:K])

    def reset(self, playerId):
        self.__lookup[playerId] = 0","# Time:  ctor:  O(1)
#        add:   O(1)
#        top:   O(n)
#        reset: O(1)"
"class Solution(object):
    def canWin(self, s):
        g, g_final = [0], 0
        for p in map(len, re.split('-+', s)):
            while len(g) <= p:
                g += min(set(range(p)) - {x^y for x, y in zip(g[:len(g)/2], g[-2:-len(g)/2-2:-1])}),
            g_final ^= g[p]
        return g_final > 0 

",# Time:  O(n + c^2)
"class Solution2(object):
    def canWin(self, s):
        lookup = {}

        def canWinHelper(consecutives):                                        
            consecutives = tuple(sorted(c for c in consecutives if c >= 2))    
            if consecutives not in lookup:
                lookup[consecutives] = any(not canWinHelper(consecutives[:i] + (j, c-2-j) + consecutives[i+1:]) 
                                           for i, c in enumerate(consecutives) 
                                           for j in range(c - 1))             
            return lookup[consecutives]                                        

        return canWinHelper(list(map(len, re.findall(r'\+\++', s))))

","# Time:  O(n + c^3 * 2^c * logc), n is length of string, c is count of ""++"""
"class Solution3(object):
    def canWin(self, s):
        i, n = 0, len(s) - 1
        is_win = False
        while not is_win and i < n:                                    
            if s[i] == '+':
                while not is_win and i < n and s[i+1] == '+':          
                    is_win = not self.canWin(s[:i] + '--' + s[i+2:])   
                    i += 1
            i += 1
        return is_win
","# Time:  O(c * n * c!), n is length of string, c is count of ""++"""
"class Solution(object):
    def minCost(self, maxTime, edges, passingFees):
        adj = [[] for i in range(len(passingFees))]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        best = collections.defaultdict(lambda:float(""inf""))
        best[0] = 0
        min_heap = [(passingFees[0], 0, 0)]
        while min_heap:
            result, u, w = heapq.heappop(min_heap)
            if w > maxTime: 
                continue
            if u == len(passingFees)-1:
                return result
            for v, nw in adj[u]:
                if w+nw < best[v]: 
                    best[v] = w+nw
                    heapq.heappush(min_heap, (result+passingFees[v], v, w+nw))
        return -1","# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|),
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)"
"class Solution(object):

    def __init__(self, arr):
        self.__idxs = collections.defaultdict(list)
        for i, x in enumerate(arr):
            self.__idxs[x].append(i)

    def query(self, left, right, value):
        return bisect.bisect_right(self.__idxs[value], right) - \
               bisect.bisect_left(self.__idxs[value], left)","# Time:  ctor:  O(n)
#        query: O(logn)"
"class Solution(object):

    def __init__(self, root):
        self.__tree = [root]
        for i in self.__tree:
            if i.left:
                self.__tree.append(i.left)
            if i.right:
                self.__tree.append(i.right)        

    def insert(self, v):
        n = len(self.__tree)
        self.__tree.append(TreeNode(v))
        if n % 2:
            self.__tree[(n-1)//2].left = self.__tree[-1]
        else:
            self.__tree[(n-1)//2].right = self.__tree[-1]
        return self.__tree[(n-1)//2].val

    def get_root(self):
        return self.__tree[0]


","# Time:  ctor:     O(n)
#        insert:   O(1)
#        get_root: O(1)"
"class Solution(object):

    def __init__(self, n):
        self.__min_heap = list(range(1, n+1))

    def reserve(self):
        return heapq.heappop(self.__min_heap)

    def unreserve(self, seatNumber):
        heapq.heappush(self.__min_heap, seatNumber)","# Time:  ctor:      O(n)
#        reserve:   O(logn)
#        unreserve: O(logn)"
