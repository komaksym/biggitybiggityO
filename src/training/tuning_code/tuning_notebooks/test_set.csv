code,complexity
"if __name__ == ""__main__"":
    s = input().rstrip().split()
    N = int(s[0])
    K = int(s[1])
    a = list(map(int, list(input().rstrip().split())))

    diff = []
    for i in range(1, N):
        diff.append([i, a[i] - a[i - 1]])
    diff = sorted(diff, key = lambda x: -x[1])
    res = max(a) - min(a)

    k = 0
    while (k < K - 1 and k < len(diff)):
        res -= diff[k][1]

        k += 1
    print(res)",nlogn
"from collections import deque, defaultdict, Counter
from itertools import product, groupby, permutations, combinations
from math import gcd, floor, inf, log2, sqrt, log10
from bisect import bisect_right, bisect_left
from statistics import mode
from string import ascii_uppercase

k = int(input()) -1

y = 9
x = 1
while k > x*y:
    k -= x*y
    y *= 10
    x += 1

start = 10**(x-1)
start += k//x

print(str(start)[k%x])",logn
"MOD=int(1e9+7)
n=int(input())
a=[]
for i in range(n):
    a.append(input())
a="""".join(a)
dp,s=[],[]
for i in range(n+1):
    dp.append([0]*(n+1))
    s.append([0]*(n+1))
dp[0][0]=1
s[0][0]=1
for i in range(1,n):
    for j in range(0,n):
        if a[i-1]=='f':
            dp[i][j+1]=dp[i-1][j]%MOD
        elif a[i-1]=='s':
            dp[i][j]=s[i-1][j]%MOD

    for j in reversed(range(n)):
        s[i][j]+=(dp[i][j]+s[i][j+1])%MOD
print(s[n-1][0]%MOD)",quadratic
"a, b = map(int, input().split("" ""))

a, b = min(a, b), max(a, b)

bina = str(bin(a))[2:]
binb = str(bin(b))[2:]

lena = len(bina)
lenb = len(binb)

ans = 0
if lena != lenb:
	ans = 2**lenb-1
else:
	a = '0'*(lena-lenb) + bina
	for i in range(lenb):
		if (bool(int(bina[i])) != bool(int(binb[i]))):
			ans = 2**(lenb-i) - 1
			break

print(ans)",logn
"n, k = map(int, input().split())
li = [int(num) for num in input().split("" "", n - 1)]
ans = []
for i in range(0, n):
    su = 0
    for j in range(i, n):
        su += li[j]
        if (j - i + 1 >= k):
            ans.append(su / (j - i + 1))
print(max(ans))",quadratic
"n = int(input())
a = list(map(int, input().split()))
m = int(input())
parity = 0
for i in range(n):
    for j in range(i + 1, n):
        if a[i] > a[j]:
            parity ^= 1
res = []
for _ in range(m):
    l, r = map(int, input().split())
    s = r - l + 1
    parity ^= (s * (s - 1) // 2) % 2
    res.append(""odd"" if parity else ""even"")
print(""\n"".join(res))",quadratic
"import sys
import heapq
input = sys.stdin.readline

n,x,y = map(int,input().split())
MOD_NUM = 10**9+7

events = dict()
for i in range(n):
    l,r = map(int,input().split())
    if l not in events:
        events[l] = []
    events[l].append(r)

tv = []
pq = []
cost = 0

for t in sorted(events):
    while tv and tv[0] < t:
        heapq.heappush(pq, -(x + heapq.heappop(tv)*y))

    for ri in sorted(events[t],reverse=True):
        if pq and -pq[0] > t*y:
            val = -heapq.heappop(pq)
            rj = (val-x)//y

            cost += (ri-rj)*y
            heapq.heappush(tv, ri)
        else:
            cost += x + (ri-t)*y
            heapq.heappush(tv, ri)
    cost %= MOD_NUM

print(cost)",nlogn
"from math import *
import sys

input = sys.stdin.readline

def bin_search(arr, n):

	pos = -1

	for i in range(35, -1, -1):
		jump = (1 << i)

		if (pos + jump) >= len(arr):
			continue

		if arr[pos + jump] <= n-1:
			pos += jump

	return len(arr) - pos - 1

def main():
	n, m = [int(x) for x in input().split(' ')]

	vert = []
	for i in range(n):
		vert.append(int(input()))

	hor = []
	for i in range(m):
		col1, col2, row = [int(x) for x in input().split(' ')]

		if col1 != 1:
			continue

		hor.append((col2))

	vert.append(1000000000)

	vert = sorted(vert)
	hor = sorted(hor)

	best = int(1e10)

	for i in range(len(vert)):
		cur_ans = bin_search(hor, vert[i]) + i
		best = min(best, cur_ans)

	print(best)

if __name__ == ""__main__"":
	main()",nlogn
"import os, sys
from io import BytesIO, IOBase

def main():
    n = rint()
    deg, edges = [0] * n, rints_2d(n - 1)
    for u, v in edges:
        deg[u - 1] += 1
        deg[v - 1] += 1

    coun = [0, deg.count(1), deg.count(2)]

    if n - coun[1] == 1:
        print(f'Yes\n{n - 1}')
        [print(*x) for x in edges]

    elif coun[1] + coun[2] == n:
        print(f'Yes\n1\n{deg.index(1) + 1} {n - deg[::-1].index(1)}')

    elif n - sum(coun) == 1:
        for i in range(n):
            if deg[i] > 2:
                print(f'Yes\n{deg[i]}')
                for j in range(n):
                    if deg[j] == 1:
                        print(i + 1, j + 1)
                exit()
    else:
        print('No')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()",linear
"import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
def power(a,b,z):
    if b==0:
        return 1
    temp=power(a,b//2,z)
    if b%2==0:
        return (temp*temp)%z
    return (a*temp*temp)%z
x,k=list(map(int,input().split()))
if x==0:
    print(0)
else:
    z=(10**9)+7
    n=(power(2,k+1,z)*x)%z
    m=power(2,k,z)
    print((n-m+1)%z)",logn
"read = lambda: map(int, input().split())
def sq(x):
    return int(x ** 0.5) ** 2 == x
t = int(input())
for _ in range(t):
    n = int(input())
    if (n % 2 == 0 and sq(n // 2)) or (n % 4 == 0 and sq(n // 4)):
        print('YES')
    else:
        print('NO')",constant
"import sys

def main():

    n,k=map(int,sys.stdin.readline().strip().split())
    arr=list(map(int,sys.stdin.readline().strip().split()))
    arr.sort(reverse=True)
    dic={}
    for a in arr:
        if a*k not in dic:
            dic[a]=1

    print(len(dic))

main()",nlogn
"def main():
    import sys
    input = sys.stdin.readline

    a = int(input())
    b = int(input())
    a = list(str(a))
    a.sort()
    ans = []
    while a:
        for i in range(len(a) - 1, -1, -1):
            c = ans + [a[i]] + a[:i] + a[i+1:]
            if int(''.join(c)) <= b:
                ans.append(a[i])
                a.pop(i)
                break
    print(''.join(ans))

main()",cubic
"n,m=map(int,input().split())
lock=0
for i in range(n):
    s=str(input())
    if(('B' in s) and (lock==0)):
        Rstart=s.index('B')
        cnt=s.count('B')
        Rcen=Rstart+(cnt//2)
        Cstart=i
        Ccen=Cstart+(cnt//2)
        lock=1

print(Ccen+1,Rcen+1)",quadratic
"n, t = [int(item) for item in input().split(' ')]
cont, ans = [], 2
for i in range(n):

    temp = list(map(int, input().split(' ')))
    house_center, house_len = temp[0], temp[1]
    cont.append([house_center - house_len / 2, house_center + house_len / 2])

cont.sort(key=lambda element: element[0])

for i in range(0,n - 1):
    gap = cont[i+1][0] - cont[i][1]
    if gap > t:
        ans += 2
    elif gap == t:
        ans += 1

print(ans)",nlogn
"cadena = input()
n = len(cadena)

rpta = 0

for i in range(n-1):
    tamanho_cadena = n-i-1
    for j in range(n-tamanho_cadena):
        subcadena = cadena[j:j+tamanho_cadena]
        contador = 1
        for k in range(n-tamanho_cadena-j):
            if subcadena == cadena[j+k+1:j+k+1+tamanho_cadena]:
                contador = contador + 1
        if contador >=2  and rpta == 0:
            rpta = tamanho_cadena
    if rpta !=0:
        break

print(rpta)",cubic
"n,m=map(int,input().split())
a=list(map(int,input().split()))
dic={}
for i in range(m):
  if a[i] in dic:
    dic[a[i]]+=1
  else:
    dic[a[i]]=1
for i in range(1,102):
  r=0
  for j in dic:
    r+=dic[j]//i
  if r<n:
    print(i-1)
    break",nlogn
"from bisect import bisect
n, m = map(int, input().split())
vv = sorted([int(input()) for _ in range(n)])
hh = [0] * n
rr = 0
for _ in range(m):
  one, x, _ = map(int, input().split())
  if one == 1:
    if x == 1000000000:
      rr += 1
    else:
      ind = bisect(vv, x)
      if ind:
        hh[ind-1] += 1
r = n
s = 0

for i, h in reversed(list(enumerate(hh))):
  s += h

  r = min(r, s+i)
print(r+rr)",nlogn
"def solve():
    n, l, r, x = map(int, input().split(' '))
    c = list(map(int, input().split(' ')))
    ans = 0
    for bitmask in range(2 ** n):
        if bin(bitmask).count('1') > 1:
            res, _min, _max = 0, float('+inf'), float('-inf')
            for c_i, bit_i in zip(c, (1 & int(bitmask) >> i for i in range(n))):
                if bit_i:
                    res += c_i * bit_i
                    if c_i < _min:
                        _min = c_i
                    if c_i > _max:
                        _max = c_i
            if l <= res <= r and (_max - _min) >= x:
                ans += 1
    print(ans)

if __name__ == '__main__':
    solve()",np
"import os,sys
from io import BytesIO, IOBase

def bit_count(x):
    ans = 0
    while x:
        x &= x-1
        ans += 1
    return ans

def main():
    n = input().strip()
    x = len(n)
    k = int(input())
    if n == '1':
        print(int(k==0))
        exit()
    if not k:
        print(1)
        exit()
    mod = 10**9+7
    dp = [0]*(x+1)
    dp[1] = 1
    for i in range(2,x+1):
        dp[i] = dp[bit_count(i)]+1
    dp1 = [[0]*(x+1) for _ in range(x+1)]

    for i in range(x+1):
        dp1[i][0] = 1
    for i in range(1,x+1):
        for j in range(1,i+1):
            dp1[i][j] = (dp1[i-1][j-1]+dp1[i-1][j])%mod
    ans = 0
    cou = n.count('1')
    for i in range(1,x+1):
        if dp[i] != k:
            continue
        se = i
        for j in range(x):
            if n[j] == '0':
                continue
            ans = (ans+dp1[x-1-j][se]-(se==1 and k==1))%mod
            se -= 1
            if se < 0:
                break
        if cou == i:
            ans = (ans+1)%mod
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",linear
"def rec(r,g,b):
    if(dp[r][g][b]!=-1):
        return dp[r][g][b]
    ans=0
    if r<R and g<G:
        ans=max(ans, red[r]*green[g]+rec(r+1, g+1, b))
    if r<R and b<B:
        ans=max(ans, red[r]*blue[b]+rec(r+1, g, b+1))
    if b<B and g<G:
        ans=max(ans, blue[b]*green[g]+rec(r, g+1, b+1))
    dp[r][g][b]=ans
    return ans
R,G,B=map(int,input().split())
red=sorted(list(map(int, input().split())), reverse=True)
green=sorted(list(map(int, input().split())), reverse=True)
blue=sorted(list(map(int, input().split())), reverse=True)
dp=[[[-1]*(B+1) for _ in range(G+1)] for _ in range(R+1)]
print(rec(0,0,0))",cubic
"from math import factorial as fc
def per(a,b):
    return fc(a+b)/(fc(a)*fc(b))
import sys
s=input()
s1=input()
x=s.count(""+"")
y=s.count(""-"")
x1=s1.count(""+"")
y1=s1.count(""-"")
p=x-y
p1=x1-y1
q=s1.count(""?"")
dif=p-p1
if q<abs(p1-p) or dif>q:
    print(0.0)
    sys.exit()
m=abs(y-y1)
pl=abs(x-x1)
print(per(m,pl)/(2**(m+pl)))",np
"import math

line = input().split()
N = int(line[0])
K = int(line[1])

n = (-3 + math.sqrt(9+4*(2*N+2*K)))/2

print(int(N-n))",logn
"n=int(input())
x=list(map(int,input().split()))
x.sort()
count,count2=0,0
ans=1
for i in range(n):
    count+=x[i]-i
    if i>=2 and x[i]==x[i-1]==x[i-2]: ans=0
    if i >= 2 and x[i] == x[i - 1] == x[i - 2]+1: ans = 0
    if i>=1 and x[i]==x[i-1]: count2+=1
if n>=3 and x[0]==x[1]==0: ans=0
for i in range(n):
    if x[i]>0: break
    if i==n-1: ans=0
if ans==0 or count%2==0 or count2>1: print(""cslnb"")
else: print(""sjfnb"")",nlogn
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    l=sorted(zip(lst(),range(n)))
    p=0;ans=[0]*(2*n)
    st=[0]*n;ln=0
    s=input()
    for i in range(2*n):

        ch=s[i]
        if ch=='0':
            st[ln]=p
            ans[i]=l[p][1]+1
            ln+=1
            p+=1
        else:
            ans[i]=l[st[ln-1]][1]+1
            ln-=1
    print(*ans)",nlogn
"n = int(input())
l = list(map(int, input().split()))
ansl = ['sjfnb', 'cslnb']
ans = -1
d = dict()
val = 0
if n == 1:
    ans = (l[0] + 1) % 2
else:
    l.sort()
    for elem in l:
        d[elem] = d.get(elem, 0) + 1
    hm = 0
    which = -1
    i = 0
    for elem in d.values():
        if elem >= 2:
            hm += 1
            which = i
        i += 1
    which = list(d.keys())[which]
    if max(d.values()) >= 3 or d.get(0, 0) >= 2 or hm > 1:
        ans = 1
    elif hm == 1 and d.get(which - 1, 0) > 0:
        ans = 1
    else:
        for i in range(n):
            val += l[i] - i
        ans = (val + 1) % 2
print(ansl[ans])",nlogn
"import math
n=int(input())

a=[9]
for i in range(2,20):
    a.append(10**i   - 10**(i-1) )
b=[0]
for i in range(1,20):
    b.append(b[-1]+ i*a[i-1])
for i in range(20):
    if n<=b[i]:
        break
p=b[i-1]
k=n-p

ans=10**(i-1) - 1 + math.ceil(k/(i))

if k%i==0:
    print(('0'+str(ans))[i])
else:
    print(('0'+str(ans))[k%i])",logn
"n=int(input())
c=[0]*4
for k in range(4):
 for i in range(n):
  s=input()
  for j in range(n):
   if(i+j)%2!=int(s[j]):c[k]+=1
 if k<3:input()
c.sort()
print(c[0]+c[1]+2*n*n-c[2]-c[3])",quadratic
"import sys
import math
import collections
import heapq
input=sys.stdin.readline
k1,k2,k3=(int(i) for i in input().split())
l=[k1,k2,k3]
if(1 in l):
    print(""YES"")
elif(l.count(2)>=2):
    print(""YES"")
elif(l.count(3)==3):
    print(""YES"")
elif(sorted(l)==[2,4,4]):
    print(""YES"")
else:
    print(""NO"")",constant
"import math
import sys

DEBUG = False

def inp():
    return sys.stdin.readline().rstrip()

def dprint(*value, sep=' ', end='\n'):
    if DEBUG:
        print(*value, sep=sep, end=end)

def solve(H, W, A):
    visited = [bytearray(W) for _ in range(H)]

    for y in range(H):
        for x in range(W):
            if A[y][x] == '.' or visited[y][x]:
                continue

            dprint(x, y)
            for dx, dy in [(0, 0), (-1, 0), (-2, 0),
                           (0, -1), (-2, -1),
                           (0, -2), (-1, -2), (-2, -2)]:
                tx = x + dx
                ty = y + dy
                dprint('  ', tx, ty)
                if tx < 0 or ty < 0 or tx + 2 >= W or ty + 2 >= H:
                    continue
                bad = False
                for ex, ey in [(0, 0), (1, 0), (2, 0),
                               (0, 1), (2, 1),
                               (0, 2), (1, 2), (2, 2)]:
                    nx = tx + ex
                    ny = ty + ey
                    if A[ny][nx] == '.':
                        bad = True
                        break
                if bad:
                    continue

                for ex, ey in [(0, 0), (1, 0), (2, 0),
                               (0, 1), (2, 1),
                               (0, 2), (1, 2), (2, 2)]:
                    nx = tx + ex
                    ny = ty + ey
                    visited[ny][nx] = 1

                assert visited[ny][nx] == 1
                break

            if visited[y][x] == 0:
                return False

    return True

def main():
    H, W = [int(e) for e in inp().split()]
    A = [inp() for _ in range(H)]

    print('YES' if solve(H, W, A) else 'NO')

if __name__ == '__main__':
    main()",quadratic
"n = int(input())
a = input()
zero = 0
for i in range(len(a)):
    if (a[i] == ""0""):
        zero += 1
if (""1"" in a):
    print(""1"", end="""")
    print(""0""*zero)
else:
    print(""0""*zero)",linear
"import sys
input = sys.stdin.readline

def int_array():
	return list(map(int, input().strip().split()))

def float_array():
	return list(map(float, input().strip().split()))

def str_array():
	return input().strip().split()
from collections import Counter
import math
import bisect
from collections import deque
n,m,lesson=int_array()
dp=[[250005 for i in range(lesson+2)]for j in range(n+1)]
days=[[] for i in range(n)]
for i in range(n):
	s=input()
	for  j in range(m):
		if s[j]==""1"":
			days[i].append(j+1)

m=[[250005 for i in range(lesson+2)]for j in range(n+1)]
for i in range(n):
	for j in range(lesson+1):
		if j<=len(days[i]):
			if j==len(days[i]):
				m[i][j]=0
				continue
			else:
				for k  in range(0,j+1):
					var=days[i][0+k]
					var1=days[i][-1*max(1,1+(j-k))]
					m[i][j]=min(m[i][j],var1-var+1)

for i in range(lesson+1):
	dp[0][i]=m[0][i]
for i in range(1,n):
	for j in range(lesson+1):
		for k in range(j+1):

			dp[i][j]=min(dp[i][j],dp[i-1][j-k]+m[i][k])

print(min(dp[n-1]))",cubic
"n, m, k = map(int, input().split())

h = []
for i in range(n):
  h.append(list(map(int, input().split())))

v = []
for i in range(n - 1):
  v.append(list(map(int, input().split())))

if k % 2 == 0:
  d = [[0] * m for i in range(n)]
  for t in range(k // 2):
    dt = [[0] * m for i in range(n)]
    for i in range(n):
      for j in range(m):
        x = float('inf')
        if i - 1 >= 0:
          x = min(x, d[i - 1][j] + v[i - 1][j] * 2)
        if i + 1 < n:
          x = min(x, d[i + 1][j] + v[i][j] * 2)
        if j - 1 >= 0:
          x = min(x, d[i][j - 1] + h[i][j - 1] * 2)
        if j + 1 < m:
          x = min(x, d[i][j + 1] + h[i][j] * 2)
        dt[i][j] = x
    d = dt.copy()
else:
  d = [[-1] * m for i in range(n)]
for i in d:
    print(*i)",cubic
"def nr(): return nrs()[0]
def nrs(): return [int(i) for i in input().split()]

n = 10**7
squares = [i * i for i in range(1, 3162)]

p = [i for i in range(n + 1)]
for i in range(1, n + 1):
	if p[i] == i:
		for sq in squares:
			if i * sq > n: break
			p[i * sq] = i

for _ in range(nr()):
	N, K = nrs()
	A = [p[a] for a in nrs()]
	dp = [N] * (K + 1)
	dp[0] = 1
	used = [set()] * (K + 1)
	for a in A:
		for j in range(K, -1, -1):
			if dp[j] == N: continue
			if a in used[j]:
				if j < K and dp[j + 1] > dp[j]:
					dp[j + 1] = dp[j]
					used[j + 1] = used[j]
				dp[j] += 1
				used[j] = set([a])
			else:
				used[j].add(a)
	print(min(dp))",cubic
"import sys

n, l, r, x = map(int, input().split())
temp = []
temp = list(map(int, input().split()))

temp.sort()
ans = 0

for i in range(1 << n):
    score = 0
    _min = sys.maxsize
    _max = -sys.maxsize
    for j in range(n):
        if i & (1 << j) > 0:
            _min = min(_min, temp[j])
            _max = max(_max, temp[j])
            score += temp[j]
    if score >= l and score <= r and _max-_min >= x:
        ans += 1

print(ans)",np
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

zl = getIntList()
zr = getIntList()

zt = [ (zl[i] + zr[i], i) for i in range(N) ]
zt.sort()
za = [0 for i in range(N) ]
now = N
for i in range(N):
    if i>0 and zt[i-1][0] <zt[i][0]:
        now-=1
    za[ zt[i][1] ] = now

for i in range(N):
    l = 0
    r = 0
    for j in range(i):
        if za[j] > za[i]:
            l+=1
    for j in range(i+1, N):
        if za[j] > za[i]:
            r+=1
    if zl[i] != l or zr[i] != r:
        print('NO')
        sys.exit()
print('YES')
for i in range(N):
    print(za[i],end = ' ')",quadratic
"def solve():
    from sys import stdin
    f_i = stdin

    n = int(f_i.readline())

    segments = []
    for i in range(n):
        x, w = map(int, f_i.readline().split())
        segments.append((x + w, x - w))
    segments.sort()

    ans = 0
    t = segments[0][1]
    for end, start in segments:
        if t <= start:
            ans += 1
            t = end

    print(ans)

solve()",nlogn
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush

from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect, insort
from time import perf_counter
from fractions import Fraction
import copy
from copy import deepcopy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A: print(*ele,end=""\n"")

n=L()[0]
A=L()
A.sort()
if A[-1]==1:
    A[-1]=2
else:
    A[-1]=1
    A.sort()
print(*A)",nlogn
"import sys, os
from collections import defaultdict

if os.environ['USERNAME']=='kissz':
    inp=open('in.txt','r').readline
    def debug(*args):
        print(*args,file=sys.stderr)
else:
    inp=input
    def debug(*args):
        pass

def get_hash(s):
    r=0
    for c in s:
        r*=30
        if c!='_':
            r+=ord(c)-96
    return r

def matches(s):
    R=[]
    for i in range(2**k):
        r=0
        for j in range(k):
            if i&(1<<j):
                r+=(ord(s[j])-96)*(30**(k-j-1))
        if pattern_pos[r]>=0:

            R.append(pattern_pos[r])
    return R

n,m,k=map(int,inp().split())

pattern_pos=[-1]*(30**k)

for i in range(n):
    p=get_hash(inp().strip())
    pattern_pos[p]=i+1

parents=[0]*(n+1)
edges=defaultdict(list)
failed=False
for i in range(m):
    s,l=inp().split()
    l=int(l)
    M=matches(s)
    if l in M:
        for m in M:
            if l==m: continue
            edges[l].append(m)
            parents[m]+=1
    else:
        failed=True
        break

if failed:
    print('NO')
else:
    Q=[]
    for i in range(1,n+1):
        if parents[i]==0:
            Q.append(i)

    ans=[]
    while Q:
        i=Q.pop()
        ans.append(i)
        for child in edges[i]:
            parents[child]-=1
            if parents[child]==0:
                Q.append(child)
    if len(ans)==n:
        print('YES')
        print(*ans)
    else:
        print('NO')",np
"n = int(input())
print(1+2*((n-1)*n))",constant
"import math
import sys
from collections import deque

def scan() -> list:
    return list(map(int, sys.stdin.readline().strip().split()))

def solution() -> None:

    n, k = scan()
    print(round(n+1.5-math.sqrt(2*(n+k)+2.75)))

if __name__ == '__main__':
    solution()",logn
"from collections import Counter
n, m = map(int, input().split())
c = Counter(input().split()).values()
d = 1
while sum(ci//d for ci in c) >= n:
    d += 1
print(d - 1)",nlogn
"def pow_mod(x, pwr, mod):
	res = 1
	multiplier = x
	while pwr > 0:
		if pwr%2 == 1:
			res = res*multiplier % mod
		multiplier = multiplier*multiplier % mod

		pwr //= 2

	return res

[x, k] = map(int, input().split())

MOD = 1000000007

if x == 0:
	res = 0
else:
	res = pow_mod(2, k+1, MOD)*x % MOD
	res = (res - pow_mod(2, k, MOD)) % MOD
	res = (res + 1) % MOD

print(res)",logn
"n, m = map(int, input().split())
a = [0] + list(map(int, input().split()))
a.sort()
ans = 0
h = a[-1]
for i in range(n, 0, -1):
	if a[i - 1] < h - 1:
		ans = ans + a[i] - h + a[i - 1]
		h = a[i - 1]
	else:
		ans = ans + a[i] - 1
		h = h - 1
print(ans)",nlogn
"import math
a=input()
b=input()
c=int(0)
d=int(0)
q=int(0)
for i in range(len(a)):
    if a[i]==""+"":
        c+=1
    elif a[i]==""-"":
        c-=1
for i in range(len(b)):
    if b[i]==""+"":
        d+=1
    elif b[i]==""-"":
        d-=1
    else:
        q+=1
if c == d:
    print((math.factorial(q)/(math.factorial(q/2)*math.factorial(q/2)))/(2**q))
else:
    mx=d+q
    mn=d-q
    if c>mx or c<mn:
        print(0.0)
    else:
        ans=c-d
        if ans > 0:
            print((math.factorial(q)/(math.factorial(((q-ans)/2)+ans)*math.factorial((q-ans)/2)))/(2**q))
        else:
            print((math.factorial(q)/(math.factorial((q-ans)/2)*math.factorial(((q-ans)/2)+ans)))/(2**q))",np
"import sys,math
a,b=map(int,input().split())
l=list(map(int,input().split()))
t=[[-1,0] for i in range(100001)]
for i in range(a):
    if t[l[i]][0]!=-1:print(0);sys.exit()
    t[l[i]][0]=3
s=math.inf
for i in range(a):
    if t[l[i]&b][0]!=-1:

        if l[i]&b!=l[i] and t[l[i]&b][0]!=1:
            t[l[i]&b]=[1,min(2,t[l[i]&b][1]+1)]

    else:t[l[i]&b]=[2,1]

for i in range(a):
    if t[l[i]&b][1]!=0 and t[l[i]&b][0]==1:s=min(s,t[l[i]&b][1])
if s==math.inf:
    print(-1)
else:
    print(s)",linear
"from sys import stdin
input=stdin.readline
from collections import defaultdict
def f(d,n):
    res=0
    prev=None
    ans=[0]*(n+1)
    for i in sorted(d.keys()):

        if prev==None:
            prev=i
        else:
            ans[res]+=i-prev
            prev=i
        res+=d[i]
    return ans[1:]

n=int(input())
d=defaultdict(int)
for i in range(n):
    x,y=map(int,input().strip().split())
    d[x]+=1
    d[y+1]-=1
print(*f(d,n))",nlogn
"n = int(input())
a = list(map(int, input().split()))
w = sum(a[i] == i + 1 for i in range(n))
print(""Petr"") if w >= n // 1000 else print(""Um_nik"")",nlogn
"x0, y0 = map(int, input().split())
n = int(input())
arr = [[x0, y0]]
for i in range(0, n):
    x, y = map(int, input().split())
    arr.append([x, y])
dist = [[0 for j in range(0, n+1)] for i in range(0, n+1)]
for i in range(0, n+1):
    for j in range(0, n+1):
        dist[i][j] = (arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2

def dfs(status, memo, pp):
    if memo[status] != None:
        return memo[status]
    if status < 0:
        return 1e8
    res = 1e8
    prev = []
    for i in range(1, n+1):
        if (status & (1 << (i - 1))) == 0:
            continue
        t1 = status ^ (1 << (i - 1))

        temp = dfs(t1, memo, pp) + dist[0][i]*2
        if temp < res:
            res = temp
            prev = [i, 0]
        for j in range(i+1, n+1):
            if j == i:
                continue
            if (t1 & (1 << (j - 1))) == 0:
                continue
            next = t1 ^ (1 << (j - 1))
            temp = dfs(next, memo, pp) + dist[0][j] + dist[j][i] + dist[i][0]
            if temp < res:
                res = temp
                prev = [i, j, 0]
        break
    memo[status] = res
    pp[status] = prev
    return res

memo = [None for i in range(0, 1 << n)]
pp = [None for i in range(0, 1 << n)]
memo[0] = 0
pp[0] = []
start = 0
end = 0
for i in range(0, n):
    end += (1 << i)
res = dfs(end, memo, pp)
path = [0]
cur = end
while cur > 0:
    prev = pp[cur]
    path.extend(prev)
    for i in range(len(prev) - 1):
        cur -= (1 << (prev[i] - 1))

print(res)
print(' '.join(map(str, path)))",np
"x,k=map(int,input().split())
if x==0:
  print(0)
  exit()
mod=10**9+7
p=pow(2,k,mod)
print((2*p*x-p+1)%mod)",logn
"import math
from decimal import Decimal

def sum2(s, e):
    return sum1(e) - sum1(s - Decimal(1)) - (e - s)

def sum1(i):
    return i * (i + 1) / 2

line = input()
n = Decimal(line.split()[0])
k = Decimal(line.split()[1])
if(n == 1):
    print(0)
elif(k > n):
    print(1)
elif(sum2(2,k) < n):
    print(-1)
else:
    c = 2 * n + k - k * k
    discriminant = (9 - 4 * c).sqrt()
    res1 = math.floor((3 + discriminant) / 2)
    res2 = math.floor((3 - discriminant) / 2)
    res1 = max(res1, res2)
    print(int(k - res1 + 1));",logn
"import sys
input=sys.stdin.readline
hashi=dict()
for i in range(1,10**5):
    hashi[i*i]=1
    hashi[(2*i*i)]=1
t=int(input())
for you in range(t):
    n=int(input())
    if(n%2):
        print(""NO"")
        continue
    z=n//2
    if(z in hashi):
        print(""YES"")
    else:
        print(""NO"")",constant
"def main():
    a = sorted(input(), reverse=True)
    b = int(input())
    k = """"
    while len(a) > 0:
        for i in range(len(a)):
            num = k + a[i] + """".join(sorted(a[:i] + a[i + 1:]))
            if int(num) <= b:
                k += a[i]
                a = a[:i] + a[i + 1:]
                break
    print(k)

if __name__ == ""__main__"":
    main()",cubic
"import os,sys
from io import BytesIO, IOBase

def matching(n,m,path):

    match1 = [-1]*n
    match2 = [-1]*m
    for node in range(n):
        for nei in path[node]:
            if match2[nei] == -1:
                match1[node] = nei
                match2[nei] = node
                break
    while 1:
        bfs = [node for node in range(n) if match1[node] == -1]
        depth = [-1]*n
        for node in bfs:
            depth[node] = 0

        for node in bfs:
            for nei in path[node]:
                next_node = match2[nei]
                if next_node == -1:
                    break
                if depth[next_node] == -1:
                    depth[next_node] = depth[node]+1
                    bfs.append(next_node)
            else:
                continue
            break
        else:
            break
        pointer = [len(c) for c in path]
        dfs = [node for node in range(n) if depth[node] == 0]
        while dfs:
            node = dfs[-1]
            while pointer[node]:
                pointer[node] -= 1
                nei = path[node][pointer[node]]
                next_node = match2[nei]
                if next_node == -1:
                    while nei != -1:
                        node = dfs.pop()
                        match2[nei],match1[node],nei = node,nei,match1[node]
                    break
                elif depth[node]+1 == depth[next_node]:
                    dfs.append(next_node)
                    break
            else:
                dfs.pop()
    return n-match1.count(-1)

def main():
    n,m = map(int,input().split())
    edg = [tuple(map(lambda xx:int(xx)-1,input().split())) for _ in range(m)]
    ans = float(""inf"")
    for centre in range(n):
        path = [[] for _ in range(n)]
        cost = 2*n-1
        extra = m
        for u,v in edg:
            if u == centre or v == centre:
                cost -= 1
                extra -= 1
            else:
                path[u].append(v)
        maxMatch = matching(n,n,path)
        extra -= maxMatch
        cost += n-1-maxMatch+extra
        ans = min(ans,cost)
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",cubic
"n = int(input())
ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())

if bx < ax < cx or bx > ax > cx or by < ay < cy or cy < ay < by:
    print('NO')
else:
    print('YES')
",constant
"from random import randint

mod = 10**9 + 7
d = {}
n, m, l = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
def go(i, j, k):
    val = i * 40401 + j * 201 + k
    ret = 0
    if val in d:
        return d[val]
    elif i < n and j < m and k < l:
        ret = max(a[i] * b[j] + go(i + 1, j + 1, k), b[j] * c[k] + go(i, j + 1, k + 1), c[k] * a[i] + go(i + 1, j, k + 1))
    elif i < n and j < m:
        ret = a[i] * b[j] + go(i + 1, j + 1, k)
    elif j < m and k < l:
        ret = b[j] * c[k] + go(i, j + 1, k + 1)
    elif k < l and i < n:
        ret = c[k] * a[i] + go(i + 1, j, k + 1)
    d[val] = ret
    return ret

a.sort(reverse = True)
b.sort(reverse = True)
c.sort(reverse = True)
print(go(0, 0, 0))",cubic
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n = int(input())
X = [0 for i in range(n)]
Y = [0 for i in range(n)]
for _ in range(n):
    X[_],Y[_] = mi()

def solve(n,X,Y):
    if n<=3:
        return True

    def check(i,j,k):
        return (Y[k]-Y[j])*(X[j]-X[i])==(Y[j]-Y[i])*(X[k]-X[j])

    a,b = -1,-1
    for i in range(n):
        if not check(0,1,i):
            if a==-1:
                a = i
            elif b==-1:
                b = i
            else:
                if not check(a,i,b):
                    break
    else:
        return True

    a,b = -1,-1
    for i in range(n):
        if not check(2,1,i):
            if a==-1:
                a = i
            elif b==-1:
                b = i
            else:
                if not check(a,i,b):
                    break
    else:
        return True

    a,b = -1,-1
    for i in range(n):
        if not check(0,2,i):
            if a==-1:
                a = i
            elif b==-1:
                b = i
            else:
                if not check(a,i,b):
                    break
    else:
        return True

    return False

print(""YES"" if solve(n,X,Y) else ""NO"")",nlogn
"a = list(input())
b = int(input())
a.sort(reverse=True)

ans=''
while a:
    for i in range(len(a)):
        temp=''
        x=ans+a[i]+temp.join(sorted(a[:i]+a[i+1:]))
        if int(x)<=b:
            ans+=a[i]
            a=a[:i]+a[i+1:]
            break
print(int(ans))",cubic
"import os
import heapq
import sys, threading
import math
import bisect
import operator
from collections import defaultdict

sys.setrecursionlimit(10 ** 5)
from io import BytesIO, IOBase

def gcd(a, b):
    if b == 0:

        return a
    else:
        return gcd(b, a % b)

def power(x, p, m):
    res = 1
    while p:
        if p & 1:
            res = (res * x) % m
        x = (x * x) % m
        p >>= 1
    return res

def inar():
    return [int(k) for k in input().split()]

def lcm(num1, num2):
    return (num1 * num2) // gcd(num1, num2)
rr=0
gg=0
bb=0
dp=[]
def func(x,y,z,red,green,blue):
    if (x>=rr and y>=gg) or (y>=gg and z>=bb) or (x>=rr and z>=bb):
        return 0
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    take=0
    if x<rr and y<gg:
        take=max(take,red[x]*green[y]+func(x+1,y+1,z,red,green,blue))
    if y<gg and z<bb:
        take=max(take,green[y]*blue[z]+func(x,y+1,z+1,red,green,blue))
    if x<rr and z<bb:
        take=max(take,red[x]*blue[z]+func(x+1,y,z+1,red,green,blue))
    dp[x][y][z]=take
    return take

def main():
    global rr,gg,bb,dp

    for i in range(202):
        temp=[]
        for j in range(202):
            lis=[]
            for k in range(202):
                lis.append(-1)
            temp.append(lis)
        dp.append(temp)
    rr, gg, bb = map(int, input().split())
    red = inar()
    green = inar()
    blue = inar()
    red.sort(reverse=True)
    green.sort(reverse=True)
    blue.sort(reverse=True)
    print(func(0,0,0,red,green,blue))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",cubic
"from collections import deque as de
import math
from sys import stdin, stdout
import re
from collections import Counter as cnt
from functools import  reduce

from itertools import groupby as gb

from bisect import bisect_left as bl, bisect_right as br

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))

class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def binarytodecimal(n):
    return int(n,2)

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))
    return prime_factors

def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def getProduct(n):

    product = 1

    while (n != 0):
        product = product * (n % 10)
        n = n // 10

    return product

def lcm(x,y):
   lcm = (x*y)//math.gcd(x,y)
   return lcm

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

def checkisap(list):
    d=list[1]-list[0]
    for i in range(2,len(list)):
        temp=list[i]-list[i-1]
        if temp !=d:
            return False
    return True

def ceildiv(x,y):
    return (x+y-1)//y

def di():return map(int, input().split())
def ii():return int(input())
def li():return list(map(int, input().split()))
def si():return list(map(int, input()))
def indict():
    dic = {}
    for index, value in enumerate(input().split()):
        dic[int(index)+1] = int(value)
    return dic
def frqdict():

    dic={}
    for index, value in enumerate(input().split()):
        if int(value) not in dic:
            dic[int(value)] =1
        else:
            dic[int(value)] +=1
    return dic

n,pos, l, r=di()
if l==1 and r==n:
    print(0)
else:
    if pos < l:
        ans=l-pos+1
        if r <n:
            ans+=(r-l)
            ans+=1
        print(ans)
    elif l<=pos<=r:
        if l >1 and r<n:
            ans=(r-l)
            ans+=min(pos-l,r-pos)
            ans+=2
        elif l>1 and r==n:
            ans=pos-l
            ans+=1
        else:
            ans=r-pos
            ans+=1
        print(ans)

    else:
        ans=pos-r+1
        if l>1:
            ans+=(r-l)
            ans+=1
        print(ans)",constant
"n, k = [int(i) for i in input().split()]
d = dict()
d[0] = 1
x = 0
for i in [int(i) for i in input().split()]:
    x ^= i
    v = min(x, (1 << k) - x - 1)
    if v not in d.keys():
        d[v] = 0
    d[v] += 1
ans = 0
for k, v in d.items():
    c1 = v // 2
    c2 = v - c1
    ans += c1 * (c1 - 1) // 2 + c2 * (c2 - 1) // 2
print(n * (n - 1) // 2 + n - ans)",linear
"n = int(input())
l = list(map(int,input().split()))
i = 0
p = []
while 2**i <= 10**18:
    p.append(2**i)
    i = i+1

d = {}
s = set()
for i in l:
    s.add(i)
    if i in d:
        d[i] += 1

    else:
        d[i] = 1

z = set()
for i in s:
    f = 1
    for j in p:
        e = j-i
        if e in s:
            if e == i and d[e] == 1:
                continue

            f = 0
            break

    if f:
        z.add(i)

ans = 0
for i in z:
    ans += d[i]

print(ans)",nlogn
"def solve():
    n, k = [int(x) for x in input().split(' ')]
    t = input()
    j = 0
    for i in range(1, n):
        if t[:i] == t[-i:]:
            j = i
    s = t + (k - 1) * t[-(n - j):]
    return s

print(solve())",quadratic
"s0=input()
k=int(input())
s1=s0[::-1]
lens1=len(s1)
maxnum=1005
mod=1000000007
dp=[[0]*maxnum for tmpi in range(maxnum)]
f=[0]*maxnum
c=[[0]*maxnum for tmpi in range(maxnum)]

def cntone(num):
    tmps=bin(num)[2:]
    cnt=0
    for i in range(len(tmps)):
        if(tmps[i]=='1'):
            cnt+=1
    return cnt

for i in range(1,maxnum):
    if(i==1):
        f[i]=0
    else:
        f[i]=f[cntone(i)]+1

for i in range(maxnum):
    if(i==0):
        c[i][0]=1
        continue
    for j in range(i+1):
        if(j==0):
            c[i][j]=1
        else:
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod

for i in range(lens1):
    if(i==0):
        dp[i][0] = 1
        if(s1[i]=='1'):
            dp[i][1]=1
        else:
            dp[i][1]=0
        continue
    else:
        for j in range(0,i+2):
            if(j==0):
                dp[i][j]=1
                continue
            if(s1[i]=='1'):
                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod
            else:
                dp[i][j]=dp[i-1][j]%mod

ans=0

for i in range(1,lens1+1):
    if(f[i]==k-1):
        ans=(ans+dp[lens1-1][i])%mod

if(k==0):
    ans=1
elif(k==1):
    ans-=1
else:
    ans=ans
print(ans)",linear
"k = int(input())
a = 9
for i in range(1,12):
    if k<=a*i:
        a = (a//9)+(k//i)-1
        if k%i!=0:
            b = str(a+1)
            c = (k%i)-1
            print(b[c])
        else:
            b = str(a)
            print(b[-1])
        break
    else:
        k = k-a*i
        a = a*10",logn
"def naiveSolve():

    return

def main():

    t=int(input())
    allans=[]
    for _ in range(t):
        n,m=readIntArr()
        grid=[]
        for __ in range(n):
            grid.append(readIntArr())
        columns=[]
        for col in range(m):
            temp=[grid[i][col] for i in range(n)]
            columns.append(temp)

        valCol=[]
        for i in range(n):
            for j in range(m):
                valCol.append((grid[i][j],j))
        valCol.sort(reverse=True)

        topCols=set()
        for val,col in valCol:
            topCols.add(col)
            if len(topCols)==n:
                break

        m2=len(topCols)
        grid2=[[-1 for __ in range(m2)] for ___ in range(n)]
        topColsList=list(topCols)
        for j in range(m2):
            col=topColsList[j]
            for i in range(n):
                grid2[i][j]=grid[i][col]
        ans=-inf
        for mask in range(n**m2):
            grid3=[[-1 for __ in range(m2)] for ___ in range(n)]
            for col in range(m2):
                shift=mask%n
                for row in range(n):
                    grid3[row][col]=grid2[(shift+row)%n][col]
                mask//=n
            tempAns=0
            for row in range(n):
                maxx=-inf
                for col in range(m2):
                    maxx=max(maxx,grid3[row][col])
                tempAns+=maxx
            ans=max(ans,tempAns)
        allans.append(ans)

    multiLineArrayPrint(allans)

    return

import sys
input=sys.stdin.buffer.readline

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))

def readIntArr():
    return [int(x) for x in input().split()]

def makeArr(defaultValFactory,dimensionArr):
    dv=defaultValFactory;da=dimensionArr
    if len(da)==1:return [dv() for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]

def queryInteractive(r):
    print('? {}'.format(r))
    sys.stdout.flush()
    return readIntArr()

def answerInteractive(adj,n):
    print('!')
    for u in range(1,n+1):
        for v in adj[u]:
            if v>u:
                print('{} {}'.format(u,v))
    sys.stdout.flush()

inf=float('inf')
MOD=10**9+7

from math import gcd,floor,ceil

for _abc in range(1):
    main()",np
"def read():
    return [int(v) for v in input().split()]

def main():
    mod = 10 ** 9 + 7
    x, k = read()
    if x == 0:
        print(0)
    else:
        print((pow(2, k, mod) * (2 * x - 1) + 1) % mod)

if __name__ == '__main__':
    main()",logn
"import math, sys

def mp():
    return list(map(int, input().split()))

def main():
    n, m, k, l = mp()
    ost = n - k
    need = (l + k)
    if ost < l or need > n:
        print(-1)
        return
    ans = (l + k - 1) // m + 1
    if ans * m - k >= l and ans * m <= n:
        print(ans)
    else:
        print(-1)

deb = 0
if deb:
    file = open(""input.txt"", ""r"")
    input = file.readline
else:
    input = sys.stdin.readline

main()

if deb:
    file.close()",constant
"n,k=map(int,input().split())
mod=998244353
dp=[[0,0,0,0] for _ in range(k+1)]

dp[1][0]=dp[1][3]=1
if k>1:
    dp[2][2]=dp[2][1]=1
for x in range(1,n):
    g=[[0,0,0,0] for _ in range(k+1)]

    g[1][0]=g[1][3]=1
    for i in range(2,k+1):
        g[i][0]=(dp[i][0]+dp[i][1]+dp[i][2]+dp[i-1][3])%mod
        g[i][1]=(dp[i-1][0]+dp[i][1]+dp[i-2][2]+dp[i-1][3])%mod
        g[i][2]=(dp[i-1][0]+dp[i-2][1]+dp[i][2]+dp[i-1][3])%mod
        g[i][3]=(dp[i-1][0]+dp[i][1]+dp[i][2]+dp[i][3])%mod
    dp=g
print(sum(dp[-1])%mod)",np
"yellow, blue = map(int, input().split())
x, y, z = map(int, input().split())
answer1 = x*2+y-yellow
answer2 = z*3+y - blue
if answer1 > 0:
    if answer2 > 0:
        print(answer1+answer2)
    else:
        print(answer1)
else:
    if answer2 > 0:
        print(answer2)
    else:
        print(0)",constant
"def solve():
    n, k = list(map(lambda x: int(x), input().split()))
    upper_bound = n+1
    lower_bound = -1
    while upper_bound > lower_bound + 1:
        m = (upper_bound + lower_bound) // 2
        if (n - m) * (n - m + 1) // 2 - m > k:
            lower_bound = m
        else:
            upper_bound = m
    print(upper_bound)

solve()",logn
"import math

l1 = input().split()

l1 = [int(i) for i in l1]

l2 = l1[1]
l1 = l1[0]

x=l1^l2;
y=1;
while(y<=x):
  y=y*2;

print(y-1);",logn
"def solve(n, arr):
	s = sum(arr)
	if s == 0:
		return ""cslnb""

	n_num = {}

	for item in arr:
		if item in n_num:
			n_num[item] += 1
		else:
			n_num[item] = 1

	if 0 in n_num and n_num[0] >= 2:
		return 'cslnb'

	for key in n_num.keys():
		if n_num[key] >= 3:
			return ""cslnb""

	ind_pairs = []
	for key in n_num.keys():
		if n_num[key] == 2:
			ind_pairs.append(key)

	if len(ind_pairs) >= 2:
		return ""cslnb""
	elif len(ind_pairs) == 1 and (ind_pairs[0]-1) in n_num:
		return ""cslnb""
	else:

		sum_targ = n*(n-1) // 2

		dif_sum = s - sum_targ

		if dif_sum % 2 == 0:
			return ""cslnb""
		else:
			return ""sjfnb""

n = int(input())

arr = list(map(int, input().split()))
print(solve(n, arr))",linear
"import sys, os
from io import BytesIO, IOBase
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

mod = pow(10, 9) + 7
mod2 = 998244353

def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def smp(): return map(str, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def remadd(x, y): return 1 if x%y else 0
def ceil(a,b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True

n, m, k = mp()
hor = [lmp() for i in range(n)]
ver = [lmp() for i in range(n-1)]
if k%2:
    ml = l2d(n, m, -1)
    for i in ml: print(*i)
    exit()
k//=2
dp = [l2d(n, m) for i in range(k+1)]
for f in range(1, k+1):
    for i in range(n):
        for j in range(m):
            a = inf
            if i!=0:
                a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j])
            if i!=n-1:
                a = min(a, 2*ver[i][j]+dp[f-1][i+1][j])
            if j!=0:
                a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1])
            if j!=m-1:
                a = min(a, 2*hor[i][j]+dp[f-1][i][j+1])
            dp[f][i][j] = a
for i in dp[-1]:
    outa(*i)",cubic
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp = defaultdict(lambda :-1)
M=1000001
for i in range(N):
    dp[i+M] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp[j+M*k], dp[j+k+M*(i-k)]
            if u == -1 or v == -1 or u != v:
                continue
            dp[j+M*i] = u+1;break

dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp[j+(i+1-j)*M] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])",cubic
"n = int(input())
a = sorted(list(map(int, input().split())))
duplicates = {}
d = None
delta = 0
for i, el in enumerate(a, 1):
    if el not in duplicates:
        duplicates[el] = 0
    else:
        d = el
        duplicates[el] += 1
    min_value = i-1
    delta += el - min_value
if sum(duplicates.values()) > 1 or duplicates.get(0, 0) >= 1 or (d is not None and d-1 in duplicates):
    print('cslnb')
elif delta == 0:
    print('cslnb')
elif delta % 2 == 1:
    print('sjfnb')
else:
    print('cslnb')",linear
"a,b,c,n=list(map(int,input().split()))
p=(a+b-c)
f=n-p
if p>=n or c>a or c>b:
	print(""-1"")
else:
	print(f)",constant
"N, M = map(int, input().split())

fac = [1] + [0] * N
for i in range(1, N + 1):
    fac[i] = fac[i - 1] * i % M
fac_inv = [0] * N + [pow(fac[N], M - 2, M)]
for i in range(N, 0, -1):
    fac_inv[i - 1] = fac_inv[i] * i % M
pow2 = [1] + [0] * N
for i in range(N):
    pow2[i + 1] = pow2[i] * 2 % M

DP = [[0] * N for _ in range(N + 2)]
DP[0][0] = 1
for i in range(N):
    for j in range(N):
        DP[i][j] %= M
        if DP[i][j]:
            for k in range(i + 2, N + 2):
                DP[k][j + 1] += DP[i][j] * fac_inv[k - i - 1] % M * pow2[k - i - 2] % M
ans = 0
for j in range(N):
    DP[N + 1][j] %= M
    if DP[N + 1][j]:
        ans += DP[N + 1][j] * fac[N - j + 1] % M
print(ans % M)",cubic
"import sys, os.path
if(os.path.exists('input.txt')):
	sys.stdin = open(""input.txt"",""r"")

t = int(input())
last = []
current = []

for i in range(t):
	last.append(str(input()))
for i in range(t):
	current.append(str(input()))

for i in range(len(last)):
	if last[i] in current:
		current[current.index(last[i])] = ""*""
		last[i] = ""*""

last.sort()
current.sort()

total = 0
for i in range(len(last)):
	if last[i] == current[i]:
		continue
	else:
		total+=1

print(total)",linear
"n = int(input())
lst = list(map(int,input().split()))
lst.sort()
lst.reverse()
m = 0
for i in range(n):
  if sum(lst[:i]) > sum(lst[i:]):
    break
  else:
    m+=1
print(m)",nlogn
"t=int(input())
k=set()
for i in range(1,10**5):
  k.add(4*i*i)
  k.add(2*i*i)
for _ in range(t):
  n=int(input())
  if n in k:
    print('YES')
  else:
    print('NO')",constant
"n=int(input())
s=input()
cur=0
for a in s:
    cur=max(cur,0)
    if(a=='-'):
        cur-=1
    else: cur+=1
    cur=max(cur,0)
print(cur)",linear
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp1 = defaultdict(lambda :-1)
M=1001
def ec(i,j):
    return i*M+j

for i in range(N):
    dp1[ec(i,i+1)] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp1[ec(j,j+k)], dp1[ec(j+k,j+i)]
            if u != -1 and v != -1 and u == v:
                dp1[ec(j,j+i)] = u+1
                break

dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp1[ec(j,i+1)] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])",cubic
"from sys import stdin,stdout
def main():
	n=int(stdin.readline())
	s=stdin.readline()
	sum=0
	a=[]
	for v in s:
		if v!='0' and v!='\n':
			a.append(v)
	if not a and n>1:
		return 'YES'
	n=len(a)
	s=a
	for i in range(n-1):
		sum+=int(s[i])
		j=i+1
		check=1
		while j<n:
			temp=int(s[j])
			j+=1
			while j<n:
				if temp>=sum:
					break
				temp+=int(s[j])
				j+=1
			if sum!=temp:
				check=1
				break
		if sum!=temp:
			check=0
		if check:
			return 'YES'
	return 'NO'
print(main())",quadratic
"import sys
from collections import deque
n=int(input())
visited=[False for i in range(n+1)]
dp=[0 for i in range(n+1)]
l=[[] for i in range(n+1)]
for i in range(n-1):
    a,b=map(int,input().split())
    l[a].append(b)
    l[b].append(a)
b=list(map(int,input().split()))
s=[1]
visited[1]=True
c=1
c1=0
t=True
while len(s)!=n :
    aux=0
    for i in l[s[c1]]:
        if not visited[i]:
            visited[i]=True
            dp[i]=1
            aux+=1
    for i in range(c,c+aux):
        if dp[b[i]]==1:
            s.append(b[i])
            dp[b[i]]=0
        else:
            print(""No"")
            t=False
            break
    else:
        c+=aux
        c1+=1
        continue
    break
if t:
    print(""Yes"")",nlogn
"x, k= [int(x) for x in raw_input().split()]

MOD = 10 ** 9 + 7

def modulus(a, b, m):

    if b == 0:
        return 1
    if b == 1:
        return a % m

    result = int(modulus(a, b // 2, m))

    if b % 2 == 0:
        return  int (( (result % m) * (result % m) ) % m)
    else:
        return int (( (result % m) * (result % m) * (a % m)) % m)

def pow_mod(x, y, z):
    ""Calculate (x ** y) % z efficiently.""
    number = 1
    while y:
        if y & 1:
            number = number * x % z
        y >>= 1
        x = x * x % z
    return number
if x == 0:
    print(0)
elif k != 0:
    print( int( ( (modulus(2, k + 1, MOD) * (x % MOD) ) % MOD - (modulus(2, k, MOD)) % MOD + 1 + MOD) % MOD ))
else:
    print(int((x % MOD) * 2 % MOD) )",logn
"def helper(n,m,k):

    if k % 2 == 1:
        res = [[-1] * m for i in range(n)]
        return res

    k = k // 2

    pool = [[[0]*m for i in range(n)] for j in range(k+1)]

    dx = [0,0,1,-1]
    dy = [1,-1,0,0]

    for t in range(1,k+1):
        for i in range(n):
            for j in range(m):
                tres = [9999999] * 4
                for c in range(4):
                    if 0 <= i+dx[c] < n and 0 <= j+dy[c] < m:
                        if c == 0:
                            tres[c] = hedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]
                        elif c == 1:
                            tres[c] = hedge[i][j-1]*2 + pool[t-1][i+dx[c]][j+dy[c]]
                        elif c == 2:
                            tres[c] = vedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]
                        else:
                            tres[c] = vedge[i-1][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]
                pool[t][i][j] = min(tres)

    return pool[k]

n,m,k = map(int,input().split("" ""))
hedge = []
vedge = []
for i in range(n):
    hedge.append(list(map(int,input().split("" ""))))
for i in range(n-1):
    vedge.append(list(map(int,input().split("" ""))))

res = helper(n,m,k)
for j in range(len(res)):
    print("" "".join(map(str,res[j])))",cubic
"import sys
n,m=map(int,input().split())
s=[list(input()) for i in range(n)]
u=[[-1 for i in range(m)] for j in range(n)]
d=[[-1 for i in range(m)] for j in range(n)]
l=[[-1 for i in range(m)] for j in range(n)]
r=[[-1 for i in range(m)] for j in range(n)]
for i in range(m):
    acum=0
    for j in range(n):
        if s[j][i]==""."":
            acum=0
        else:
            acum+=1
        u[j][i]=acum
for i in range(m):
    acum=0
    for j in range(n-1,-1,-1):
        if s[j][i]==""."":
            acum=0
        else:
            acum+=1
        d[j][i]=acum
for i in range(n):
    acum=0
    for j in range(m):
        if s[i][j]==""."":
            acum=0
        else:
            acum+=1
        l[i][j]=acum
for i in range(n):
    acum=0
    for j in range(m-1,-1,-1):
        if s[i][j]==""."":
            acum=0
        else:
            acum+=1
        r[i][j]=acum
ans=[]
t1=[[0 for i in range(m)] for j in range(n)]
t2=[[0 for i in range(m)] for j in range(n)]
for i in range(n):
    for j in range(m):
        d1=min(l[i][j],r[i][j],u[i][j],d[i][j])-1
        if d1>0:
            ans.append([i+1,j+1,d1])
            t1[i+d1][j]+=1
            t1[i-d1][j]-=1
            t2[i][j-d1]+=1
            t2[i][j+d1]-=1
dp=[['.' for i in range(m)] for j in range(n)]
for i in range(n):
    acum=0
    for j in range(m):
        acum+=t2[i][j]
        if acum!=0 or t2[i][j]!=0:
            dp[i][j]='*'
for i in range(m):
    acum=0
    for j in range(n):
        acum+=t1[j][i]
        if acum!=0 or t1[j][i]!=0 :
            dp[j][i]='*'
if dp!=s:
    print(-1)
    sys.exit()
print(len(ans))
for i in ans:
    print(*i)",quadratic
"from math import gcd
def t_prime(n):
    if n == 1:        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:            return False
    return True
primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))
if k == 1: print(0);exit()
for i in range(n):
    for j in range(i):
        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)
powers = set();count = 0;outLs = [];pgood = []
for p in primes:
    curr = [];    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:            v2 //= p
        if v2 == 1:   curr.append(v);   powers.add(v)
    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)
order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])
if len(order) == 0:    print(0); exit()
if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1;    need = -1;    last = []
    for v in l:
        if v in powers:            continue
        v2 = v;        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):  extra = v;     last = primesn;    need = len(last);   assert need >= 2
    if need == -1 or 2 * need + 1 > k:  print(0);   exit()
    other = [];    out = [extra]
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:   works = True;           break
        if works:       out.append(a);   out.append(b)
        else:       other.append(a);      other.append(b)
    assert len(out) == 2 * need + 1;    assert (k - 2 * need - 1) % 2 == 0; ret = out + other[:(k - 2*need - 1)];    assert len(ret) == k; print(' '.join(map(str,ret)));    exit()
out = [];need = k
for i in range(len(order)):
    assert need != 1;lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1): out += lis; need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2: out += lis[:-1];  need -= (len(lis) - 1);   assert need == 2
    else: out += lis[:need]; need = 0
assert need + len(out) == k;assert need >= 0;assert need == 0 or len(out) == count
for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1
if need == 0:    print(' '.join(map(str,out)));    exit()
else:    print(0)",np
"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        arr = []

        def dfs(node):
            if not node:
                return

            arr.append(node.val)
            dfs(node.left)
            dfs(node.right)

        dfs(root)
        arr.sort()
        return arr[k - 1]",nlogn
"N = int(input())
m1 = []
m2 = []
ms = []
for n in range(N):
    m1.append(input())
for n in range(N):
    m2.append(input())

ms = [
    m2,
    [x[::-1] for x in m2],
    [x for x in reversed(m2)],
]

a = []
for m in ms:
    a.append(m)
    a.append([x[::-1] for x in reversed(m)])
    a.append([''.join(m[j][i] for j in range(N - 1, -1, -1)) for i in range(N)])
    a.append([''.join(m[j][i] for j in range(N)) for i in range(N - 1, -1, -1)])

ms = a
print(['NO', 'YES'][m1 in ms])",quadratic
"L1=list(map(int, input().split()))
numList=list(map(int, input().split()))
length=L1[0]
targetnumber=L1[1]
pos=numList.index(targetnumber)
pos_r=pos+1
rem=0
right={0:1}
left={0:1}
while pos_r<=length-1:
    if numList[pos_r]>targetnumber:
        rem+=1
    else:
        rem-=1
    if rem not in right:
        right[rem]=1
    else:
        right[rem]+=1
    pos_r+=1
pos_l=pos-1
rem=0
while pos_l>=0:
    if numList[pos_l]>targetnumber:
        rem+=1
    else:
        rem-=1
    if rem not in left:
        left[rem]=1
    else:
        left[rem]+=1
    pos_l-=1
sum=0
for number_l in left:
    if number_l*(-1) in right:
        sum += (left[number_l] * right[(-1) * number_l])
    if 1-number_l in right:
        sum += (left[number_l] * right[1-number_l])
print(sum)",nlogn
"n, m = list(map(int, input().split()))
cl = []
for i in range(n):
  cl.append(input())

def is_squad(x, y):
  if cl[x][y]=='
    return True
  else:
    return False

def cv(x, y):
  counter = 0
  if x-2>=0 and y+2<=m-1 and is_squad(x-2, y):
    return True

  elif x-1>=0 and x+1<=n-1 and y+2<=m-1 and is_squad(x-1, y):
    return True

  elif x+2<=n-1 and y+2<=m-1 and is_squad(x, y):
    return True

  elif x+2<=n-1 and y+1<=m-1 and y-1>=0 and is_squad(x, y-1):
    return True

  elif x+2<=n-1 and y-2>=0 and is_squad(x, y-2):
    return True

  elif x+1<=n-1 and x-1>=0 and y-2>=0 and is_squad(x-1, y-2):
    return True

  elif x-2>=0 and y-2>=0 and is_squad(x-2, y-2):
    return True

  elif x-2>=0 and y-1>=0 and y+1<=m-1 and is_squad(x-2, y-1):
    return True
  else:
    return False

for i in range(n):
  for j in range(m):
    if cl[i][j]=='
      if not cv(i, j):
        print('NO')
        exit()

print('YES')",quadratic
"r,g,b=map(int,input().split())
R=list(map(int,input().split()))
R.sort()
G=list(map(int,input().split()))
G.sort()
B=list(map(int,input().split()))
B.sort()
dp=[[[0]*(b+1) for i in range(g+1)] for j in range(r+1)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i<r and j<g:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
            if i<r and k<b:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
            if j<g and k<b:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k])
print(dp[r][g][b])",cubic
"from collections import defaultdict as dd
from collections import deque, Counter
import bisect
import heapq
from math import inf

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def ri():
    return int(input())

def rl():
    return list(map(int, input().split()))

n, m = rl()
aa = rl()

bb = [-1]*n
for i in range(n):
	if aa[i] == m:
	    bb[i] = 1
	elif aa[i] < m:
	    bb[i] = -1
	else:
	    bb[i] = 1

prefix_sum= [0]*(n+1)
for i in range(1, n+1):
    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]

def mergeSortGoodOrder(arr):

    if len(arr) == 1:
        return arr, 0
    else:
        a = arr[:len(arr)//2]
        b = arr[len(arr)//2:]

        a, ai = mergeSortGoodOrder(a)
        b, bi = mergeSortGoodOrder(b)
        c = []

        i = 0
        j = 0
        good = 0 + ai + bi

    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            c.append(a[i])
            i += 1
            good += (len(b)-j)
        else:
            c.append(b[j])
            j += 1

    c += a[i:]
    c += b[j:]

    return c, good

idx = 0
for i in range(n):
    if aa[i] == m:
        idx = i

_, good = mergeSortGoodOrder(prefix_sum)

_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])

_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])

first_count = good - bad_left - bad_right

bb = [-1]*n
for i in range(n):
	if aa[i] == m + 1:
	    bb[i] = 1
	elif aa[i] < m + 1:
	    bb[i] = -1
	else:
	    bb[i] = 1

prefix_sum= [0]*(n+1)
for i in range(1, n+1):
    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]

_, good = mergeSortGoodOrder(prefix_sum)

_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])

_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])

second_count = good - bad_left - bad_right

ans   = first_count - second_count

print(ans)",nlogn
"import sys

def rl(proc=None):
    if proc is not None:
        return proc(sys.stdin.readline())
    else:
        return sys.stdin.readline().rstrip()

def srl(proc=None):
    if proc is not None:
        return list(map(proc, rl().split()))
    else:
        return rl().split()

def main():
    rl()
    a = srl(int)
    a.sort()
    cnt = 0
    for i in range(0, len(a)-1):
        if a[i] == a[i+1]:
            a[i] -= 1
            cnt += 1
            break
    if a[0] < 0:
        print('cslnb')
        return

    for i in range(0, len(a)-1):
        if a[i] == a[i+1]:
            print('cslnb')
            return

    for i, x in enumerate(a):
        cnt += x - i

    print('sjfnb' if (cnt & 1) else 'cslnb')

if __name__ == '__main__':
    main()",linear
"import sys

IS_LOCAL = False

def readMultiple(f):
    return f(map(int, input().split()))

def main():
    n = 3
    a = [1, 2, -4]

    if not IS_LOCAL:
        n = int(input())
        a = readMultiple(list)

    for i, x in enumerate(a):
        if x >= 0:
            a[i] = -x - 1

    cnt_neg = 0
    for x in a:
        if x < 0:
            cnt_neg += 1

    b = sorted([(abs(x), i) for i, x in enumerate(a)])
    if cnt_neg % 2 == 1:
        ind = b[n-1][1]
        a[ind] = -a[ind] - 1

    print(' '.join(map(str, a)))

if __name__ == ""__main__"":
    if len(sys.argv) > 1 and sys.argv[1] == 'True':
        IS_LOCAL = True
    main()",nlogn
"mod = int(1000000007)

def somaPa(nSteps):
    if nSteps == 0:
        return 0
    return (1 + nSteps) * nSteps / 2

def diminui(step):
    return (pow(2, step, mod) - 2) % mod

x, k = map(int, raw_input().split())

if x == 0:
    print(0)
else:
    pot = pow(2, k + 1, mod)
    inv = pow(2, mod - 2, mod)

    big = (x * pot) % mod
    small = (big - diminui(k + 1) ) % mod

    print(int((( ( (big + small) % mod)  * inv ) % mod)))",logn
"import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int,sys.stdin.readline().rstrip().split())
def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))
def LI2(): return list(map(int,sys.stdin.readline().rstrip()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())
def LS2(): return list(sys.stdin.readline().rstrip())

N = I()
A = LI()
mod = 10**9+7

m = 20
M = 1 << m
F = [0]*M
for a in A:
    F[a] += 1

def zeta_transform(F,n):

    N = 1 << n
    res = F[:]
    for i in range(n):
        k = 1 << i
        for j in range(N):
            if not j & k:
                res[j] += res[j^k]
    return res

G = zeta_transform(F,m)
power = [1]
for _ in range(N):
    power.append((power[-1]*2) % mod)

def bit_count(n):
    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)
    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)
    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f)
    c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff)
    c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff)
    c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff)
    return c

ans = 0
for i in range(M):
    bc = bit_count(i)
    a = power[G[i]]
    if bc % 2 == 0:
        ans += a
    else:
        ans -= a
    ans %= mod

print(ans)",np
"import sys
input = sys.stdin.readline

class sieve:
  def __init__(self, n):
    self.n = n
    self.sv = [1] * (n + 1)
    self.sv[0] = 0
    self.sv[1] = 0
    for i in range(2, n + 1):
      if self.sv[i]:
        for j in range(i * 2, n + 1, i):
          self.sv[j] = 0
  def isprime(self, x):
    if x > self.n:
      return False
    return self.sv[x] == 1
  def factorize(self, x):
    res = []
    for i in range(2, int(x ** 0.5) + 1):
      if self.sv[i]:
        while x % i == 0:
          x //= i
          res.append(i)
    if x != 1:
      res.append(x)
    return res
  def modlcm(self, a, mod):
    res = [0] * (self.n + 1)
    ex = set()
    for i in range(len(a)):
      f = self.factorize(a[i])
      for j in f:
        if j > self.n:
          ex.add(j)
          continue
        res[j] = max(f.count(j), res[j])
    rres = 1
    for i in range(self.n + 1):
      if res[i] != 0:
        rres *= pow(i, res[i], mod)
        rres %= mod
    for i in ex:
      rres *= i
      rres %= mod
    return rres

sv = sieve(10 ** 4)
for _ in range(int(input())):
  n, k = map(int, input().split())
  a = list(map(int, input().split()))
  for i in range(n):
    x = a[i]
    q = sv.factorize(x)
    s = [1]
    while len(q):
      y = q.pop()
      if y == s[-1]:
        s.pop()
        a[i] //= y ** 2
      else: s.append(y)
  s = [set() for _ in range(k + 1)]

  dp = [n] * (k + 1)
  dp[0] = 0

  for i in range(n):
    for j in range(k, -1, -1):
      if dp[j] == n: continue
      if a[i] in s[j]:
        if j + 1 <= k and dp[j + 1] > dp[j]:
          dp[j + 1] = dp[j]
          s[j + 1] = s[j]
        dp[j] += 1
        s[j] = set()
        s[j].add(a[i])
      else:
        s[j].add(a[i])

  for j in range(k + 1): dp[j] += len(s[j]) > 0
  print(min(dp))",cubic
"import sys
from collections import defaultdict

input = sys.stdin.readline

n, m = map(int, input().split())

vals = set()
locs = defaultdict(list)
for i in range(n):
    inp = map(int, input().split())
    for pos, v in enumerate(inp):
        vals.add(v)
        locs[v].append((pos, i))

masks = [0] * n
full = (1<<m) - 1
met = {0:0}
for v in sorted(vals, reverse=True):
    for pos, i in locs[v]:
        curr_mask = masks[i] = masks[i] | (1<<pos)
        met[curr_mask] = i
        complement = full ^ curr_mask
        if complement in met:
            print(i+1, met[complement]+1)
            sys.exit()",np
"n, s = map(int, input().split())
ans = s // n
s %= n
if s != 0:
    ans += 1
print(ans)",constant
"class SegmentTree:
    def __init__(self, N, A):
        self.n = N
        while (self.n & (self.n - 1)) != 0:
            self.n += 1
        self.build(N, A)

    def build(self, N, A):
        self.tree = [float('-inf')] * (2 * self.n)
        for i in range(N):
            self.tree[self.n + i] = A[i]
        for i in range(self.n - 1, 0, -1):
            self.tree[i] = max(self.tree[i << 1], self.tree[i << 1 | 1])

    def query(self, l, r):
        res = float('-inf')
        l += self.n
        r += self.n + 1
        while l < r:
            if l & 1:
                res = max(res, self.tree[l])
                l += 1
            if r & 1:
                r -= 1
                res = max(res, self.tree[r])
            l >>= 1
            r >>= 1
        return res

class Solution:
    def maxSlidingWindow(self, nums, k):
        n = len(nums)
        segTree = SegmentTree(n, nums)
        output = []
        for i in range(n - k + 1):
            output.append(segTree.query(i, i + k - 1))
        return output",nlogn
"import sys,math
input = sys.stdin.readline

out = []

t = int(input())
for _ in range(t):
    n = int(input())

    o1 = math.isqrt(n//2)
    o2 = math.isqrt(n//4)

    if 2 * o1 * o1 == n or 4 * o2 * o2 == n:
        out.append('YES')
    else:
        out.append('NO')
print('\n'.join(out))",constant
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n = int(z())
arr = set(zz())

def solve():
    for i in arr:
        for k in range(31):
            if i - (1 << k) in arr and i + (1 << k) in arr:
                return [i - (1 << k), i, i + (1 << k)]
    for i in arr:
        for k in range(31):
            if i + (1 << k) in arr:
                return [i, i + (1 << k)]

    for i in arr:
        return [i]

lst = solve()

print(len(lst))
for i in lst:
    output(i,' ')",nlogn
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i+4-4],effect[j][i+3-3],inf*inf)

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)",np
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n, m = zz()
arr = zzz()
s = sum(arr)
x = [[] for i in range(m)]
for i in range(n): x[arr[i] % m].append(i)
j = 0
for i in range(m):
    while len(x[i]) > n // m:
        while j < i or len(x[j % m]) >= n // m: j += 1
        k = x[i].pop()
        arr[k] += (j - i) % m
        x[j % m].append(k)
print(sum(arr) - s)
print(*arr)",linear
"n = int(input())
ar = [int(i) for i in input().split()]

if n == 1:
    print(1)
    exit()

if ar[1] > ar[0]:
    li = [1]
elif ar[1] < ar[0]:
    li = [5]
else:
    li = [3]

c = 1
while c != n:
    j = 0

    if ar[c] > ar[c - 1]:
        while c != n and ar[c] > ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] + 1)
            if li[-1] == 6:
                print(-1)

                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] + 1)
        else:
            li.append(5)

    elif ar[c] < ar[c - 1]:
        while c != n and ar[c] < ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] - 1)
            if li[-1] == 0:
                print(-1)

                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] - 1)
        else:
            li.append(1)

    else:
        while c != n and ar[c] == ar[c - 1]:
            c += 1
            j += 1
        for i in range(j):
            if li[-1] > 3:
                li.append(li[-1] - 1)
            else:
                li.append(li[-1] + 1)
        if c != n and ar[c] > ar[c - 1]:
            if li[-2] == 1:
                li[-1] = 2
            else:
                li[-1] = 1
        elif c != n and ar[c] < ar[c - 1]:
            if li[-2] == 5:
                li[-1] = 4
            else:
                li[-1] = 5

if max(li) > 5 or min(li) < 1:
    print(-1)
else:
    print(*li)",quadratic
"a = [0,1]
n = int(input())
i=2
r=0
while r<n:
     r = a[i-1]+a[i-2]
     a.append(r)
     i+=1
l = len(a)-1
if n>3:
    print(a[l-4],a[l-3],a[l-1])
elif n==3:
    print(1,1,1)
elif n==2:
    print(0,1,1)
elif n==1:
    print(0,0,1)
elif n==0:
    print(0,0,0)",constant
"from math import *
a,r = map(int,input().split())
x = list(map(int,input().split()))
y = [0]*a
for i in range(a):
    h = r
    for j in range(i):
        if abs(x[i]-x[j])<=2*r:
            h = max(h,sqrt((2*r)**2 - (x[i]-x[j])**2)+y[j])
    y[i] = h
    print(h, end = "" "")",quadratic
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
import bisect
T = int(input())
r = 1
prime = [2]

for i in range(3,4*10**3,2):
    flag = False
    if i%2==0: continue
    for j in range(3,int(i**0.5)+1,2):
        if i%j==0:
            flag = True
            break
    if not flag:  prime.append(i)

def primefactor(num):

    index = 0
    output = []

    while num>=prime[index]**2:

        times = 0
        while num%prime[index]==0:
            num = num // prime[index]
            times += 1
        if times&1:  output.append(prime[index])
        index += 1

    if num>1: output.append(num)

    return tuple(output)

while r<=T:
    n,k = map(int,input().split())
    arr = list(map(int,input().split()))

    seg = 1
    fact = {}
    left = [[0 for j in range(k+1)] for i in range(n)]
    dp = [[300000 for j in range(k+1)] for i in range(n)]

    stack = [0]
    for i in range(n):
        factor = primefactor(arr[i])
        if factor in fact:
            bisect.insort(stack,fact[factor]+1)

        fact[factor] = i

        for j in range(k+1):
            if j<len(stack):  left[i][j] = stack[-j-1]

    for i in range(n):
        for j in range(k+1):
            for t in range(j+1):
                l = left[i][t]
                if l>0:
                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])
                else:
                    dp[i][j] = 1

    print(dp[-1][-1])
    r += 1",cubic
"n, m, a, b = map(int, input().split())
print(min(n%m*b, (m-n%m)*a))
",linear
"l,r=map(int,input().split())
a=bin(l)
b=bin(r)
a=""0""*(len(b)-len(a))+a[2:len(a)]
b=b[2:len(b)]
c=[0 for i in range(len(a))]
flag=False
for i in range(len(a)):
    if(a[i]!=b[i]):
        flag=True
    if(flag):c[i]=1
ans=0
for j in range(len(a)):
    ans+=c[len(a)-1-j]*(2**(j))
print(ans)",logn
"k = int(input())
ch = 0
i = 0
r = 1
while k > r - 1:
    r += 9 * (i + 1) * 10 ** i
    i += 1
r -= 9 * i * 10 ** (i - 1)

print(str((k - r) // i + 10 ** (i - 1))[(k - r) % i]  )",constant
"n=int(input())
a=[*map(int,input().split())]
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   elif any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",quadratic
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []

    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)

    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)

    return powerset_orderred
def fastPlrintNextLines(a):

    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")

t = 1

for _ in range(t):
    n,m = li()
    s = list(si())
    t = list(si())
    if '*' not in s:
        if s==t:
            print(""YES"")
        else:
            print(""NO"")
        continue
    i = s.index('*')
    if s[:i]==t[:i]:
        s = s[i:]
        t = t[i:]
        s=s[::-1]
        t = t[::-1]
        i = s.index('*')

        if len(t)>=i and s[:i]==t[:i]:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")",linear
"from itertools import combinations
def out1(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==1 and b==0 and c==0:
        return 1
    return a*(out2(a-1,b,c)+out3(a-1,b,c))
def out2(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==1 and c==0:
        return 1
    return b*(out1(a,b-1,c)+out3(a,b-1,c))
def out3(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==0 and c==1:
        return 1
    return c*(out2(a,b,c-1)+out1(a,b,c-1))
def column(matrix, i):
    return [row[i] for row in matrix]

N, T = [int(x) for x in input().split()]
A = []
s = 0
for i in range(N):
    A.append([int(x) for x in input().split()])
for i in range(1,N+1):
    comb = list(combinations(A, i))
    for x in comb:
        if sum(column(x,0))==T:
            a = column(x,1).count(1)
            b = column(x,1).count(2)
            c = column(x,1).count(3)
            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))
print(s%1000000007)",np
"n,s=map(int,input().split())

def ver(i):
	t=str(i)
	ans=0
	for j in t:
		ans+=int(j)
	return(ans)
l=len(str(s))
if n<s:
	print(0)
	exit()
if s+10*(l**2+1)<=n:
	ans=n-s+1-10*(l**2+1)
	for i in range(s,s+10*(l**2+1)):
		if s+ver(i)<=i:ans+=1
else:
	ans=0
	for i in range(s,n+1):
		if s+ver(i)<=i:ans+=1
print(ans)",logn
"import bisect
from itertools import accumulate
import os
import sys
import math
from decimal import *
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
def isPrime(n) :
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
def SieveOfEratosthenes(n):
    prime=[]
    primes = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):

        if (primes[p] == True):
            prime.append(p)
            for i in range(p * p, n+1, p):
                primes[i] = False
        p += 1
    return prime
def factors(n):
    fac=[]
    while(n%2==0):
        fac.append(2)
        n=n//2
    for i in range(3,int(math.sqrt(n))+2):
        while(n%i==0):
            fac.append(i)
            n=n//i
    if n>1:
        fac.append(n)
    return fac

a = input()
b = a.count('1')
a = a.replace('1','')
c = a.find('2')
if c==-1:
    a = (a+ '1'*b)
else:
    a = a[:c]+ '1'*b + a[c:]
print(a)",linear
"name = input()
for i in range(len(name), 0, -1):
	for j in range(len(name) - i + 1):
		if name[j: j + i] in name[j + 1:]:
			print(i)
			exit()
print(0)",cubic
"from sys import stdin
from collections import deque,Counter
import sys
import math
import operator
import random
from fractions import Fraction

n,k = map(int,input().split())
arr = list(map(int,input().split()))
arr.sort()
f = arr[0]
p = n
i = 0
count = 0
while i<n:
    while i<n and arr[i] == f:
        i+=1
        count+=1
    if i<n and arr[i]<=f+k:
        p-=count
    if i<n:
        f=arr[i]
        count=0
    continue

print(p)",nlogn
"from itertools import combinations
n,l,r,x=map(int,input().split())
*a,=map(int,input().split())
print(sum([sum([max(j)-min(j)>=x and l<=sum(j)<=r for j in combinations(a,i)])for i in range(2,n+1)]))",np
"from sys import stdin, stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))

for _ in range(1):
    sa=sorted(input(), reverse=True)
    na=len(sa)
    sb=input()
    nb=len(sb)
    if nb>na:
        print(''.join(sa))
        continue
    ans=''
    while sa:
        for i in range(len(sa)):
            new=ans+sa[i]+''.join(sorted(sa[:i]+sa[i+1:]))
            if int(new)<=int(sb):
                ans+=sa[i]
                sa.pop(i)
                break
    print(ans)",cubic
"import sys
input = sys.stdin.buffer.readline

n,k=map(int,input().split())
arr=[int(x) for x in input().split()]

x=0
dp=[]
for i in range(n):
    x=x+arr[i]
    dp.append(x)

ans=0
for i in range(n):
    for j in range(i+k-1,n):
        ans=max(ans,((dp[j]-dp[i])+arr[i])/(j-i+1))
print(ans)",quadratic
"s = input().split()
s.sort()
if s[0] == s[1] == s[2]:
	print(0)
	exit()
if s[0][1] == s[1][1] == s[2][1]:
	if ord(s[0][0]) + 1 == ord(s[1][0]) == ord(s[2][0]) - 1:
		print(0)
		exit()
if s[0][1] == s[1][1] and ord(s[0][0]) + 2 >= ord(s[1][0]) or s[1][1] == s[2][1] and ord(s[1][0]) + 2 >= ord(s[2][0]) or s[0][1] == s[2][1] and ord(s[0][0]) + 2 >= ord(s[2][0]):
	print(1)
	exit()
if s[0] == s[1] or s[1] == s[2] or s[0] == s[2]:
	print(1)
	exit()
print(2)",nlogn
"from collections import Counter;

n = int(input())

a = input()
b = input()
c = input()

fa = Counter(a);
fb = Counter(b);
fc = Counter(c);

la = min(fa.most_common(1)[0][1] + n, len(a))
lb = min(fb.most_common(1)[0][1] + n, len(a))
lc = min(fc.most_common(1)[0][1] + n, len(a))

if fa.most_common(1)[0][1] == len(a) and n == 1:
    la = len(a)-1

if fb.most_common(1)[0][1] == len(b) and n == 1:
    lb = len(b)-1

if fc.most_common(1)[0][1] == len(c) and n == 1:
    lc = len(c)-1

if la > max(lb, lc):
    print(""Kuro"")
elif lb > max(la, lc):
    print(""Shiro"")
elif lc > max(la, lb):
    print(""Katie"")
else:
    print(""Draw"")",linear
"import copy
import sys

def find_loop(g, w, k, n):
    visited = [False] * n
    visited_int = [False] * n
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        visited_int[i] = True
        while stack:
            if not stack[-1]:
                stack.pop()
                visited_int[path[-1]] = False
                path.pop()
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited_int[nxt]:
                return True
            if visited[nxt]:
                continue
            visited[nxt] = True
            visited_int[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)
    return False

def top_sort(g, w, k, n):
    visited = [False] * n
    order = [-1] * n
    cnt = 0
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        while stack:
            if not stack[-1]:
                order[path[-1]] = cnt
                path.pop()
                stack.pop()
                cnt += 1
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited[nxt]:
                continue
            visited[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)

    to_reverse = []
    for a, b in w.items():
        if b > k:
            continue
        if order[a[0]] < order[a[1]]:
            to_reverse.append(a)
    return to_reverse

if __name__ == '__main__':
    n, m = map(int, input().split())
    w = {}
    g = [[] for _ in range(n)]
    w_tmp = {}
    c_m = 0
    kk = [0]
    lines = sys.stdin.readlines()
    for i, line in enumerate(lines):
        u, v, c = map(int, line.split())
        g[u - 1].append(v - 1)
        if (u - 1, v - 1) in w.keys():
            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)
        else:
            w[(u - 1, v - 1)] = c
        if (u - 1, v - 1) in w_tmp.keys():
            w_tmp[(u - 1, v - 1)].append(str(i + 1))
        else:
            w_tmp[(u - 1, v - 1)] = [str(i + 1)]
        kk.append(c)

    kk.sort()
    l, r = 0, len(kk)
    if not find_loop(g, w, kk[l], n):
        print(0, 0)
        exit(0)
    if find_loop(g, w, kk[-1], n):
        kkk = kk[-1]
    else:
        while l + 1 != r:
            m = int((l + r) / 2)
            if find_loop(g, w, kk[m], n):
                l = m
            else:
                r = m
        kkk = kk[l+1]

    to_reverse = top_sort(g, w, kkk, n)
    num = 0
    s = []
    for t in to_reverse:
        num += len(w_tmp[t])
        s.extend(w_tmp[t])

    print(kkk, num)
    print("" "".join(s))",nlogn
"n,m=map(int, input().split())
a=list(map(int, input().split()))
t=n//m
remain=[[] for i in range(m)]
for i in range(n):
    x=a[i]%m
    remain[x].append(i)
ans=0
f=[]
for i in range(2*m):
    cur=i%m
    while len(remain[cur])>t:
        elm=remain[cur].pop()
        f.append([elm,i])
    while len(remain[cur])<t and len(f)!=0:
        elm,j=f.pop()
        remain[cur].append(elm)
        a[elm]+=abs(i-j)
        ans+=abs(i-j)
print(ans)
print(*a)",linear
"def read(type = 1):
    if type:
        file = open(""input.dat"", ""r"")
        n = int(file.readline())
        a = list(map(int, file.readline().split()))
        b = file.readline()
        file.close()
    else:
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        b = input().strip()
    return n, a, b

def solve():
    sol = 0
    e = 0
    big = 0
    g = 0
    for i in range(n):
        if b[i] == ""W"":
            big = 1
            sol += 3 * a[i]
            e += a[i]
        if b[i] == ""G"":
            sol += 5 * a[i]
            e += a[i]
            g += 2*a[i]
        if b[i] == ""L"":
            sol += a[i]
            e -= a[i]
            if e < 0:
                if big:
                    sol -= 3 * e
                else:
                    sol -= 5 * e
                e = 0
        g = min(g, e)
    if e:
        sol -= 2*g
        sol -= (e-g)
    return int(sol)

n, a, b = read(0)
sol = solve()
print(sol)",linear
"l, r=map(int, input().split())
def cntbit(n):
  ans=0
  while(n):
    ans+=1
    n//=2
  return ans
c1=cntbit(l)
c2=cntbit(r)
if(c2>c1):
  print(2**c2-1)
else:
  x=l^r
  c=cntbit(x)
  print(2**c-1)",logn
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int,sys.stdin.readline().strip().split()))

for i in range (0, n):
    if a[i] >= 0:
        a[i] = - a[i] - 1

if n % 2 == 1:
    i = a.index(min(a))
    a[i] = - a[i] - 1

a = list(map(str,a))
print("" "".join(a))",linear
"x,y,z=map(int,input().split())
l=list(map(int,input().split()))
l.sort()
c=0
s=z
t=False
while s<y and c<x:
    c+=1
    s=s+l[x-c]-1
if s<y:
    print(-1)
else:
    print(c)",nlogn
"l, r = list(map(int, input().strip().split()))

if l == r:
    print(0)
    exit()

l, r = bin(l)[2:].zfill(64), bin(r)[2:].zfill(64)
i = 0
while i < len(r):
    if l[i] == r[i]:
        i += 1
    else:
        break
rslt = len(r[:i])*'0' + len(r[i:])*'1'
print(int(rslt, 2))",logn
"import math
n,r = list(map(int,input().split()))
angle = math.pi/(n)
c = math.sin(angle)
k = c/(1-c)
R = k*r
R = float(format(R,'.7f'))
print(R)",constant
"from sys import stdin
MOD = 1000000007
s = stdin.readline().strip()
n = len(s)
buc = [0] * 101
fac = [0] * (n + 1)
inv = [0] * (n + 1)
dp = [0] * (n + 1)

ans = [[0] * 55 for _ in range(55)]

def find(c: 'str') -> 'int':
    if 'A' <= c <= 'Z':
        return ord(c) - ord('A') + 26
    else:
        return ord(c) - ord('a')

for i in s:
    buc[find(i)] += 1

fac[0] = 1
for i in range(1, n + 1):
    fac[i] = (fac[i - 1] * i) % MOD
inv[n] = pow(fac[n], MOD - 2, MOD)
for i in range(n - 1, -1, -1):
    inv[i] = (inv[i + 1] * (i + 1)) % MOD

num = pow(fac[n // 2], 2, MOD)
for i in range(0, 52):
    num = (num * inv[buc[i]]) % MOD

dp[0] = 1

for i in range(0, 52):
    if not buc[i]:
        continue
    for j in range(n, buc[i] - 1, -1):
        dp[j] += dp[j - buc[i]]
        if dp[j] >= MOD:
            dp[j] -= MOD
for i in range(52):
    ans[i][i] = dp[n // 2]

for i in range(52):
    if not buc[i]:
        continue
    temp_dp = dp.copy()
    for k in range(buc[i], n + 1):
        temp_dp[k] -= temp_dp[k - buc[i]]
        if temp_dp[k] < 0:
            temp_dp[k] += MOD

    for j in range(i + 1, 52):
        if not buc[j]:
            continue
        for k in range(buc[j], n + 1):
            temp_dp[k] -= temp_dp[k - buc[j]]
            if temp_dp[k] < 0:
                temp_dp[k] += MOD
        ans[i][j] = (2 * temp_dp[n // 2]) % MOD

        for k in range(n, buc[j] - 1, -1):
            temp_dp[k] += temp_dp[k - buc[j]]
            if temp_dp[k] >= MOD:
                temp_dp[k] -= MOD

q = int(input())
l = stdin.read().splitlines()
for i in l:
    x, y = map(int, i.split())
    l, r = find(s[x - 1]), find(s[y - 1])
    if l > r:
        l, r = r, l
    print(num * ans[l][r] % MOD)",cubic
"n = input()

m = 0
for i in range(len(n)):

    for j in range(i,len(n)+1):

        if len(n[i:j])>m and n[i:j] in n[i+1:len(n)]:

            m = len(n[i:j])

print(m)",cubic
"class MinStack:
    def __init__(self):
        self.stack = []
        self.minStack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        val = min(val, self.minStack[-1] if self.minStack else val)
        self.minStack.append(val)

    def pop(self) -> None:
        self.stack.pop()
        self.minStack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minStack[-1]",constant
"n,m = map(int,input().split())
li = [[j for j in input()] for i in range(n)]
position1=0
position2=0
position3=0
position4=0
for j in range(m):
    flag = False
    for i in range(n):
        if li[i][j] == ""B"":
            flag = True
            position1 = i
            break
    if(flag == True):
        break
for j in range(m-1,-1,-1):
    flag = False
    for i in range(n-1,-1,-1):
        if li[i][j] == ""B"":
            flag = True
            position2 = i
            break
    if(flag == True):
        break
for i in range(n):
    flag = False
    for j in range(m):
        if li[i][j] == ""B"":
            flag = True
            position3 = j
            break
    if(flag == True):
        break
for i in range(n-1,-1,-1):
    flag = False
    for j in range(m-1,-1,-1):
        if li[i][j] == ""B"":
            flag = True
            position4 = j
            break
    if(flag == True):
        break

avg1 = (position1+position2)//2 + 1
avg2 = (position3 + position4)//2 + 1
print(avg1,avg2)",quadratic
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

a = {0:0}
b = [0]

for i in range(n):
    for p in b:
        d = gcd(p, l[i])
        cost = a[p] + c[i]
        if d not in a:
            a[d] = cost
            b.append(d)
        elif a[d] > cost: a[d] = cost

if 1 not in a: a[1] = -1
print(a[1])",np
"a,b,c,n=map(int,input().split())
if(c>b or c>a or c>n):
    print(-1)
else:
    k=c+(a-c)+(b-c)
    k=n-k
    if(k>0):
        print(k)
    else:
        print(-1)",constant
"N,M=map(int,input().split())
light=[0]+[int(_) for _ in input().split()]+[M]
sumlist=[]
sumlight,ans=0,-10**30
for i in range(N+1):
    sumlight+=(-1)**(i+1)*light[i]
    sumlist.append(sumlight)
for i in range(1,N+1):
    if light[i]>light[i-1]+1:
        ans=max(ans,2*sumlist[i-1]-sumlight+(-1)**(i+1)*(light[i]-1))
    if light[i]<light[i+1]-1:
        ans=max(ans,2*sumlist[i]-sumlight+(-1)**i*(light[i]+1))
if N%2==0:
    print(max(ans,sumlight+M))
else:
    print(max(ans+M,sumlight))",linear
"x, k = map(int, input().split())
ans = 0
md = 1000000007

def bpow(base, exp, md):
    if (exp == 0):
        return 1
    if (exp % 2 == 1):
        return (base * bpow(base, exp-1, md)) % md
    else:
        k = bpow(base, exp//2, md)
        return (k*k) % md

pw = bpow(2, k, md)
ans = (2 * pw * x) % md
if (x != 0):
    ans -= pw-1
ans = (ans + md) % md
print(ans)",logn
"M = 1000000007
x, k  = map(int,input().split())
if x==0:
    print(0)
else:
    print(((pow(2,k+1,M)*x)%M - pow(2,k,M) +1 ) % M)",logn
"n=int(input())
list1=list(map(int,input().split(' ')))
sum2=0
sum1=0
count=0
list1.sort(reverse=True)
for i in range(len(list1)):
    sum1=sum1+list1[i]

for i in range(len(list1)):
    if(int(sum1/2)>=sum2):
        sum2=sum2+list1[i]
        count=count+1
print(count)",nlogn
"import sys
def fi():
	return sys.stdin.readline()
if __name__ == '__main__':
	n,k = map(int, fi().split())

	l = list(map(int, fi().split()))
	d = dict()
	c = set()
	l.sort()
	for i in range (n):
		if not d.get(l[i]):
			c.add(l[i])
			d.setdefault(l[i]*k,1)
	print(len(c))",nlogn
"def bigNumber(n, s):
  for i in range(s, n + 1):
    sumVal = 0
    num = i
    while num:
      sumVal += num % 10
      num //= 10
    if i - sumVal >= s:
      print(n - i + 1)
      return
  print(0)

n, s = (int(x) for x in input().split())
bigNumber(n,s)",logn
"def binary(n,k,low,high):
    if low<=high:
        mid=(low+high)//2
        if (mid*(mid+1))//2-(n-mid)==k:
            return n-mid
        elif mid*(mid+1)//2-(n-mid)>k:
            return binary(n,k,low,mid-1)
        else:
            return binary(n,k,mid+1,high)

n,k=[int(x) for x in input().split()]
print(binary(n,k,1,n))",logn
"n=int(input())
dict1={}
dict2={}
for i in range(n):
    s=input()
    s=s.split('/')
    c=int(s[1])
    s=s[0].strip('(').strip(')').split('+')
    a=int(s[0])
    b=int(s[1])
    ans=(a+b)/c
    try:
        dict2[ans] += 1
    except:
        dict2[ans] = 1
    dict1[i] = ans
for i in range(n):
    print(dict2[dict1[i]],end=' ')",linear
"string = input().strip()
mx = 0

for i in range(len(string)):
    for j in range(i+1, len(string)):
        m = 0
        while(j+m < len(string) and string[i+m] == string[j+m]):
            m += 1
        mx = max(mx, m)

print(mx)",cubic
"s=input().split()
n=int(s[0])
arr=list(map(int,input().split()))

children=[[] for i in range(n+1)]
for i,j in enumerate(arr):
    if 1<i+2<=n:
        children[j].append(i+2)
leaves=[0]*(n+1)

for i in range(n,0,-1):
    if not children[i]:
        leaves[i]=1
    else:
        leaves[i]=sum(leaves[j] for j in children[i])

print(' '.join(map(str,sorted(leaves[1:]))))",nlogn
"import sys

def bin_ser(arr,curr):
    l=0
    r=len(arr)-1
    ans=-1
    while l<=r:
        mid=(l+r)//2
        if arr[mid]<=curr:
            ans=mid
            l=mid+1
        else:
            r=mid-1
    return ans

def main():
    n,q=map(int,sys.stdin.readline().strip().split())
    arr=list(map(int,sys.stdin.readline().strip().split()))
    brr=list(map(int,sys.stdin.readline().strip().split()))
    su=sum(arr)
    curr=0
    for i in range(1,n):
        arr[i]=arr[i]+arr[i-1]
    for b in brr:
        curr+=b
        pos=n-bin_ser(arr,curr)-1
        if pos==0:
            pos=n
        print(pos)
        if curr>=su:
            curr=0

main()",nlogn
"n,k=map(int,input().split())
a=list(map(int,input().split()))
a.sort(reverse=True)
worst=0
maxi=a[0]
a.append(0)
for i in range(n+1):
    bad=maxi-a[i]-i
    worst=max(worst,bad)
print(sum(a)-n-worst)",nlogn
"n = int(input())
A = list(map(int, input().split()))
k = 10 ** 10
for i in range(1, n - 1):
    k = min(k, min(A[0], A[i]) // i)
    k = min(k, min(A[-1], A[i]) // (n - i - 1))
k = min(k, min(A[0], A[-1]) // (n - 1))
print(k)",linear
"import math
sone= list(input())
stwo = list(input())
sum1=0
sum2=0
m=0
for i in range(len(sone)):
    if sone[i]=='+':
        sum1=sum1 + 1
        m=m+1
    else:
        sum1=sum1 - 1
k=0
for i in range(len(stwo)):
    if stwo[i]=='+':
        sum2=sum2 + 1
        k=k
    elif stwo[i]=='-':
        sum2=sum2 - 1
        k=k
    elif stwo[i]=='?':
        k=k+1
n=0
if (k-(abs(sum1-sum2)))<0:
    print(float (0))
elif (k-(abs(sum1-sum2)))==0:
    if k==0:
        print(float (1))
    else:
        print(float (pow(0.5,k)))

else:
    n=k-(abs(sum1-sum2))
    n=abs(sum1-sum2)+n/2
    if abs(sum1-sum2)==0:
        print(float ((math.factorial(k)/(math.factorial(k/2)*math.factorial(k/2))) * pow(0.5,k)))
    else:
        print(float ((math.factorial(k)/(math.factorial(k-n) * math.factorial(n))) * pow(0.5,k)))",np
"N, K= map(int, input().split())
Rcnt = N * 2
Gcnt = N * 5
Bcnt = N * 8

res = (Rcnt + K - 1) // K + (Gcnt + K - 1) //K + (Bcnt + K -1 ) // K
print(res)",constant
"import sys

if __name__ == '__main__':
    cin = sys.stdin

    n = int(next(cin))
    a = list(map(int, next(cin).split()))

    n2idx = {a[i]: i for i in range(n)}

    f = [False] * (n+1)

    for i in range(n, 0, -1):
        idx_lg = n2idx[i]

        win_flag = False
        for j in range(idx_lg%i, n, i):
            if a[j] > i and not f[a[j]]:
                win_flag = True
                break
        f[i] = win_flag

    f = ''.join(['A' if f[a_i] else 'B' for a_i in a])
    print(f, flush=True)",quadratic
"I=lambda:[*map(int,input().split())]
R=range;m=min;N,M,K=I();r=R(N)
if K&1:
	for _ in r:print(*[-1]*M)
	exit()
A=[I()for _ in r]
B=[I()for _ in R(N-1)]
X=[M*[0]for _ in r]
for k in R(1,K//2+1):
	Y=[M*[9**9]for _ in r]
	for i in r:
		for j in R(M):
			if i:Y[i][j]=X[i-1][j]+2*B[i-1][j]
			if i<N-1:Y[i][j]=m(Y[i][j],X[i+1][j]+2*B[i][j])
			if j:Y[i][j]=m(Y[i][j],X[i][j-1]+2*A[i][j-1])
			if j<M-1:Y[i][j]=m(Y[i][j],X[i][j+1]+2*A[i][j])
	X=Y
for x in X:print(*x)",cubic
"def solve(n, v):
    fuel = min(n - 1, v)
    cost = fuel
    for i in range(2, n):
        if fuel >= n - 1:
            break
        fuel += 1
        cost += i
    return cost

n, v = map(int, input().split())
print(solve(n, v))",linear
"n, m = map(int, input().split())
a = [list(map(int, input())) for i in range(n)]

ignorable = [True] * n

for i in range(m):
    cnt = 0
    for j in range(n):
        cnt += a[j][i]
    if cnt == 1:
        for j in range(n):
            if a[j][i]:
                ignorable[j] = False

if any(ignorable):
    print('YES')
else:
    print('NO')",quadratic
"l = list(map(int,input().split()))
n = 0
m=-1
while(n<14):
    c=0
    g = l.copy()
    div = l[n]//14
    h = l[n]%14
    i = n+1
    sum = div*14
    g[n]=0
    while(sum):
        if i==14:
            i=0
        g[i]+=div
        sum-=div
        i+=1
    i = n+1
    while(h):
        if i==14:
            i=0
        g[i]+=1
        h-=1
        i+=1
    for j in g:
        if j%2==0:
            c+=j

    m = max(c,m)
    n+=1
print(m)",constant
"yellow,blue = map(int,input().split())
x,y,z = map(int,input().split())
ry = x*2+y
rb =z*3+y
r1,r2 = 0,0
if ry-yellow < 0:
    r1 = 0
else:
    r1 = ry-yellow
if rb - blue < 0:
    r2 = 0
else:
    r2 = rb-blue
print(r1+r2)",constant
"n,k = map(int,input().split())
mod = 998244353
dp = [[[0,0]for j in range(2*n+1)] for i in range(n)]
dp[0][0][0] = dp[0][1][1] = 1
for i in range(1,n):
  for j in range(2*n-1):
    dp[i][j][0] +=  (dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][1]) %mod
    dp[i][j+1][0] += dp[i-1][j][0] % mod
    dp[i][j+1][1] += (dp[i-1][j][0] + dp[i-1][j][0])%mod
    dp[i][j][1] += dp[i-1][j][1] %mod
    dp[i][j+2][1] += dp[i-1][j][1] %mod
print(sum(dp[n-1][k-1])*2%mod)",np
"from collections import defaultdict
n = int(input())
a = list(map(int, input().split()))

rec = defaultdict(list)
for j in range(n):
    for k in range(j, n):
        rec[sum(a[j:k + 1])].append((j, k))

ans = []
for k in rec.keys():
    tmp = []
    rec[k] = sorted(rec[k], key=lambda x: x[1])
    pre = -1
    for a, b in rec[k]:
        if pre >= a:
            continue
        else:
            tmp.append((a + 1, b + 1))
            pre = b
    if len(tmp) > len(ans):
        ans = tmp

print(len(ans))
for a, b in ans:
    print(a, b)",cubic
"import sys
input=sys.stdin.readline
n,m,k=map(int,input().strip().split("" ""))

lr=[]
for i in range(n):
	lr.append([100000001]+list(map(int,input().strip().split("" "")))+[100000001])
ud=[[100000001]*m]
for i in range(n-1):
	ud.append(list(map(int,input().strip().split("" ""))))
ud.append([100000001]*m)
o=[[1000000001]*(m+2)]
from copy import deepcopy
if k%2:
	for i in range(n):
		sys.stdout.write("" "".join([""-1""]*m)+""\n"")
	sys.exit()
for _ in range(n):
	oo=[100000001]
	for _ in range(m):
		oo.append(0)
	oo.append(100000001)
	o.append(oo)
o.append([100000001]*(m+2))
for _ in range(k//2):
	oo=deepcopy(o)
	for i in range(1,n+1):
		for j in range(1,m+1):
			oo[i][j]=min(lr[i-1][j-1]+o[i][j-1],lr[i-1][j]+o[i][j+1],ud[i-1][j-1]+o[i-1][j],ud[i][j-1]+o[i+1][j])
	o=deepcopy(oo)
for i in o[1:n+1]:
	sys.stdout.write("" "".join(map(str,[j*2 for j in i[1:m+1]]))+""\n"")",cubic
"def get_smallest(m, l):
    res = ''
    for i in ""0123456789"":
        if m.get(i, 0):
            if i == l:
                res += i * (m[i] - 1)
            else:
                res += i * m[i]
    return res

a = input()
b = input()

if len(a) < len(b):
    a = sorted(a)
    a.reverse()
    print(''.join(a))
elif a == b:
    print(a)
else:
    cmap = dict()
    for i in a:
        cmap[i] = cmap.get(i, 0) + 1

    cur = 0
    res = ''
    gm = False

    while cur < len(a):
        for i in ""9876543210"":
            if cmap.get(i, 0):
                if cur == len(a) - 1 or i < b[cur] or gm:
                    res += i
                    cmap[i] -= 1
                    gm = True
                    break
                elif i == b[cur]:
                    if get_smallest(cmap, i) <= b[cur + 1:]:
                        res += i
                        cmap[i] -= 1
                        break
        cur += 1

    print(res)",cubic
"import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

dp = [[-1]*(N+1) for _ in range(N+1)]
for l in range(N):
    dp[l][l+1] = A[l]

for d in range(2, N+1):
    for l in range(N-d+1):
        for t in range(1, d):
            if dp[l][l+t] == dp[l+t][l+d] and dp[l][l+t] != -1:
                dp[l][l+d] = dp[l][l+t] + 1
                break

dp2 = [i for i in range(N+1)]
for r in range(1,N+1):
    if dp[0][r] != -1:
        dp2[r] = 1
for l in range(N):
    for r in range(l+2, N+1):
        if dp[l+1][r] != -1:
            dp2[r] = min(dp2[l+1]+1, dp2[r])
        else:
            dp2[r] = min(dp2[l+1]+(r-l-1), dp2[r])

print(dp2[N])",cubic
"n,s=map(int,input().split())
if s>=n:
    print(""0"")
    exit()
for i in range(s,n+2):
    cur=int(0)
    for j in str(i):
        cur+=int(j)
    if i-cur>=s:
        break
print(n-i+1)",logn
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

prime = [True for i in range(10)]
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n):

        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p):
                pp[i]+=1
                prime[i] = False
        p += 1

def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[n-1]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] >= key):
            res=arr[mid]
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[0]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=arr[mid]
            left = mid + 1
    return res

n,m=map(int,input().split())
l=[]
tot=[]
done=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    l.append(input())
colsum=[[0 for i in range(m)]for j in range(n)]
rowsum=[[0 for i in range(m)]for j in range(n)]
col=[[0 for i in range(m)]for j in range(n)]
row=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            rowsum[i][j]=1
            colsum[i][j]=1
            row[i][j]=1
            col[i][j]=1
for i in range(n):
    for j in range(1,m):
        if l[i][j]=='.':
            continue
        rowsum[i][j]+=rowsum[i][j-1]
for i in range(n):
    for j in range(m-2,-1,-1):
        if l[i][j]=='.':
            continue
        row[i][j]+=row[i][j+1]
for i in range(m):
    for j in range(n-2,-1,-1):
        if l[j][i]=='.':
            continue
        col[j][i]+=col[j+1][i]
for i in range(m):
    for j in range(1,n):
        if l[j][i]=='.':
            continue
        colsum[j][i]+=colsum[j-1][i]
def check(x,y):
    i=x
    j=y
    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1
    if ans==0:
        return []
    return [ans]
h=[[0 for i in range(m+1)]for j in range(n)]
v=[[0 for i in range(m)]for j in range(n+1)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            ans=check(i,j)
            for j1 in ans:
                tot.append([i+1,j+1,j1])
                h[i][j-j1]+=1
                h[i][j+j1+1]-=1
                v[i-j1][j]+=1
                v[i+j1+1][j]-=1
for i in range(n):
    for j in range(1,m):
        h[i][j]+=h[i][j-1]
for i in range(m):
    for j in range(1,n):
        v[j][i]+=v[j-1][i]

for i in range(n):
    for j in range(m):
        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:
            print(-1)
            sys.exit(0)
print(len(tot))
for i in tot:
    print(*i)",quadratic
"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd
from itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left, insort, insort_left
from heapq import heappush, heappop
from functools import reduce, lru_cache
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def TUPLE(): return tuple(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10 ** 9 + 7

N = INT()
xw = [LIST() for _ in range(N)]

rl = []
for x, w in xw:
    rl.append((x-w, x+w))

rl.sort(key = lambda x: (x[1], x[0]))

ans = 0
tmp = -INF

for r, l in rl:
    if r < tmp:
        continue
    ans += 1
    tmp = l

print(ans)",nlogn
"class Solution:
    def isValid(self, s: str) -> bool:
        while '()' in s or '{}' in s or '[]' in s:
            s = s.replace('()', '')
            s = s.replace('{}', '')
            s = s.replace('[]', '')
        return s == ''
",quadratic
"n = int(input())
if n == 0:
    print(0)
else:
    if n % 2 == 0:
        print(n+1)
    else:
        print((n+1)//2)",constant
"n = int(input())
x,y = map(int,input().split())
if max(x-1,y-1) > max(n-x,n-y):
    print(""Black"")
else:
    print(""White"")",constant
"n = int(input())
print(n**2+((n-1)**2))",constant
"n=int(input())
l=[int(x) for x in input().strip().split()]
l1=sorted(l)
c=0
for i in range(n):
    if(l[i]!=l1[i]):
        c+=1
if(c<=2):
    print(""YES"")
else:
    print(""NO"")",nlogn
"n=int(input())
lst = list(map(int, input().strip().split(' ')))
c=0
while(len(lst)!=0):
    p=lst[0]
    del lst[0]
    i=lst.index(p)
    c+=i
    del lst[i]
print(c)",quadratic
"from sys import stdin,stdout
def main():
	n,k=map(int,stdin.readline().split( ))
	s=stdin.readline()
	start=-1
	i=0;j=1;prev=1
	while i<n-1:
		while j<n:
			if s[i]==s[j]:
				if start==-1:
					start=j
					prev=j
				i+=1
				j+=1
			else:
				i=0
				j=prev+1
				prev=j
				start=-1
		break
	if start==-1:
		stdout.write(""%s\n""%(s[:n]*k))
	else:
		j = n - start
		stdout.write(""%s\n""%(s[:n]+s[j:n]*(k-1)))
main()",quadratic
"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        nums.sort()
        for i in range(len(nums) - 1):
            if nums[i] == nums[i + 1]:
                return nums[i]
        return -1",nlogn
"import sys
keta=29
print(""?"",0,0,flush=True)

A00=int(input())
if A00==0:
    ANS=0
    for k in range(keta,-1,-1):
        print(""?"",2**k,0,flush=True)
        if int(input())==-1:
            ANS+=2**k
    print(""!"",ANS,ANS,flush=True)
    sys.exit()

A=0
B=0
for k in range(keta,-1,-1):
    LIST=[]
    print(""?"",2**k+A,B,flush=True)
    LIST.append(int(input()))
    print(""?"",A,2**k+B,flush=True)
    LIST.append(int(input()))

    if LIST[0]!=LIST[1]:
        if LIST[0]==-1:
            A+=2**k
            B+=2**k

    else:
        if A00==1:
            A+=2**k
        else:
            B+=2**k
        A00=LIST[0]
print(""!"",A,B,flush=True)",constant
"from sys import stdin
from collections import deque

n, k = map(int, stdin.readline().split())

graph = [[] for _ in range(n)]
leaf = -1
for _ in range(n-1):
    a,b = map(int,stdin.readline().split())

    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

def bfs(G, s):

    Q = deque()
    Q.append(s)

    infinite = 10 ** 6
    d = [infinite]*n

    parent = [-1]*n
    valid = True

    d[s] = 0

    while Q:

        u = Q.popleft()

        not_visited_count = 0

        for v in G[u]:

            if d[v] == infinite:
                d[v] = d[u] + 1
                parent[v] = u
                Q.append(v)
                not_visited_count += 1

        if not_visited_count < 3 and d[u] != k:
            valid = False

    return d, parent, valid

leaf = -1
for i,v in enumerate(graph):
    if len(v) == 1:
        leaf = i
        break

d, parent, _ = bfs(graph,leaf)
center = -1
farthest_leaf = -1
path = 2*k

for i,level in enumerate(d):
    if level == path:
        farthest_leaf = i
        break

if len(graph[farthest_leaf]) != 1 or farthest_leaf == -1:
    print(""NO"")
    exit()

for _ in range(k):
    center = parent[farthest_leaf]
    farthest_leaf = center

_, _, valid = bfs(graph,center)

if valid:
    print(""YES"")
else:
    print(""NO"")",nlogn
"n,v=[int(x) for x in input().split()]
if v>=(n-1):
    print(n-1)
else:
    print(int((((n-v)*(n-v+1))/2)-1+v))",constant
"n,m=map(int, input().split())
cols=[]
for i in range(n):
    cols.append(int(input()))
rows=[]
for i in range(m):
    k=list(map(int, input().split()))
    if k[0]==1:
        rows.append(k[1])
ans=n+m
cols.sort()
rows.sort()
cols.append(int(1e9))
j=0
rem=0

for i in cols:
    while j<len(rows) and rows[j]<i:
        j+=1
    ans=min(ans, len(rows)-j+rem)
    rem+=1
print(ans)",nlogn
"import sys

input = sys.stdin.readline

a, b= map(int,input().split())

if a == b:
    print(0)

else:
    x = a ^ b
    c = 1

    while x:
        x >>= 1
        c <<= 1

    print(c-1)",logn
"n,m=[int(x) for x in input().split(' ')]
print((n-1)*'4'+'5')
print(n*'5')",constant
"import math

n,k = map(int,input().split())
l=[]
c=0
for j in range(2,n):
    p=0

    for i in range(2,int(math.sqrt(j))+1):

        if j%i==0:

            p=1
            break
        else:
            pass

    if p==0:
        l.append(j)

l+=[n]

for i in range(len(l)-1):

    if (l[i]+l[i+1]+1) in l:

        c+=1
if c>=k:
    print(""YES"")
else:
    print(""NO"")",linear
"from collections import defaultdict
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
slmii = lambda: sorted(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

def lcm(a, b): return (a * b) // gcd(a, b)

def main():

    n = ii()
    d = defaultdict(int)
    ll = defaultdict(list)
    rr = defaultdict(list)
    llst = []
    rlst = []
    lst = []
    for i in range(n):
        l, r = mii()
        lst.append([l,r])
        llst.append(l)
        rlst.append(r)
        ll[l].append(r)
        rr[r].append(l)
    left = max(llst)
    right = min(rlst)
    lleft = min(ll[left])
    lright = max(rr[right])
    lst.remove([left,lleft])
    pl = max(i[0] for i in lst)
    pr = min(i[1] for i in lst)
    mx = max(0,pr-pl)
    lst.append([left,lleft])
    lst.remove([lright,right])
    pl = max(i[0] for i in lst)
    pr = min(i[1] for i in lst)
    print(max(mx, max(0,pr-pl)))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",linear
"import math
from collections import defaultdict
ml=lambda:map(int,input().split())
ll=lambda:list(map(int,input().split()))
ii=lambda:int(input())
ip=lambda:list(input())

n,k=ml()
ans=0;
for i in range(1,1000001):
    val=(i*(i+1))//2
    if(val-(n-i)==k):
        ans=n-i
print(ans)",logn
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i],inf)

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)",np
"import sys
input = sys.stdin.buffer.readline
n,m=map(lambda x:int(x), input().split())
A = []
for _ in range(n):
    scores = list(map(lambda x:int(x), input().split()))
    A.append(scores)

def solve(n,m,A):

    ans = ()
    nstats = 2**m
    def judge(finalScore):
        nonlocal ans
        seen = {}
        for i,scores in enumerate(A):
            sta = 0
            for e in scores:
                sta=sta*2+(e>=finalScore)

            seen[sta]=i

        for i in range(nstats):
            for j in range(nstats):
                if ((i|j) == nstats-1) and i in seen and j in seen:
                    ans = (seen[i], seen[j])
                    return True

        return False

    l=0
    r=2**31-1
    while l<r:
        m=l+(r-l)//2
        if not judge(m):
            r=m
        else:
            l=m+1

    print(ans[0]+1,ans[1]+1)

solve(n,m,A)",np
"N = int(input())
first = []
second = []
for i in range(N):
    first.append([s for s in input()])
for i in range(N):
    second.append([s for s in input()])

def rotate_90(matrix):
    return list(zip(*matrix[::-1]))

def flip(matrix):
    return matrix[::-1]

def compare_matrices(first, second):
    for i in range(N):
        for j in range(N):
            if first[i][j] != second[i][j]:
                return False
    return True

def wrap(first, second):
    if compare_matrices(first, second) == True:
        return 'Yes'
    hold_first = first[::]
    for _ in range(3):
        first = rotate_90(first)
        if compare_matrices(first, second) == True:
            return 'Yes'
    first = hold_first
    first = flip(first)
    if compare_matrices(first, second) == True:
        return 'Yes'
    for _ in range(3):
        first = rotate_90(first)
        if compare_matrices(first, second) == True:
            return 'Yes'
    return 'No'

print(wrap(first, second))",quadratic
"def readline(): return tuple(map(int, input().split()))
def readlines(count): return (readline() for __ in range(count))

def main():
    n, = readline()
    segments = sorted(readline() + (idx + 1,) for idx in range(n))

    prev = (-1, -1, -1)
    for segment in segments:
        assert prev[0] <= segment[0]
        if prev[0] == segment[0]:
            assert prev[1] <= segment[1]
            print(prev[2], segment[2])
            break
        elif prev[1] >= segment[1]:
            print(segment[2],  prev[2])
            break
        prev = segment
    else:
        print(-1, -1)

main()",nlogn
"import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate

int1 = lambda x: int(x) - 1
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
ilele = lambda: map(int,input().split())
alele = lambda: list(map(int, input().split()))
ilelec = lambda: map(int1,input().split())
alelec = lambda: list(map(int1, input().split()))
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

MOD = 998244353

N,K = ilele()
if K == 1 or K == 2*N:
    print(2)
    exit(0)
dp = list3d(N+1,4,K+1,0)
dp[1][0][1] = 1
dp[1][3][1] = 1
dp[1][1][2] = 1
dp[1][2][2] = 1

for n in range(2,N+1):
    for k in range(1,K+1):
        dp[n][0][k] = ((dp[n-1][0][k]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD
        dp[n][3][k] = ((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k])%MOD)%MOD
        if k > 1:
            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k-2] +dp[n-1][3][k-1])%MOD)%MOD
            dp[n][2][k]=((dp[n-1][0][k-1]+dp[n-1][1][k-2])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD
        else:
            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][3][k-1])%MOD)%MOD
            dp[n][2][k]=((dp[n-1][0][k-1])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD

print(((dp[N][0][K]+dp[N][1][K])%MOD+(dp[N][2][K]+dp[N][3][K])%MOD)%MOD)",np
"def valid(k, mid):
    return (2*k - mid - 1) * mid // 2 + 1

def binary_search(n, k):
    l, r = 0, k-1
    while (l <= r):
        mid = l+r >> 1
        if (valid(k, mid) < n):
            l = mid+1
        else:
            r = mid-1
    return l

def main():
    n, k = map(int, input().split())
    res = binary_search(n, k)
    print(-1 if res == k else res)

main()",logn
"from bisect import bisect_left as bl
from bisect import bisect_right as br
import heapq
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

def factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))

def li():return [int(i) for i in input().rstrip('\n').split(' ')]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n').split(' ')]
def li3():return [int(i) for i in input().rstrip('\n')]

n,L = li()
l = []
for i in range(n):
    l.append(li())

index = defaultdict(list)
for ind,i in enumerate(l):
    index[tuple(i)].append(ind + 1)

l.sort(key = lambda x:x[1])
d = defaultdict(list)

ans = i = tot = currpoints = 0
anspattern = []
he = []

while i < n:

    if l[i][1] + tot <= L:
        tot += l[i][1]
        heapq.heappush(d[l[i][0]],l[i][1])
        currpoints += 1

        if len(d[l[i][0]]) == 1:
            heapq.heappush(he,l[i][0])

    while len(he) and currpoints > he[0]:
        temp = heapq.heappop(he)
        tot -= heapq.heappop(d[temp])
        currpoints -= 1
        if len(d[temp]):heapq.heappush(he,temp)

    if currpoints > ans:
        ans = currpoints

    i += 1
i = tot = currpoints = 0
he = []
d = defaultdict(list)

while i < n:

    if l[i][1] + tot <= L:
        tot += l[i][1]
        heapq.heappush(d[l[i][0]],l[i][1])
        currpoints += 1

        if len(d[l[i][0]]) == 1:
            heapq.heappush(he,l[i][0])

    while len(he) and currpoints > he[0]:
        temp = heapq.heappop(he)
        tot -= heapq.heappop(d[temp])
        currpoints -= 1
        if len(d[temp]):heapq.heappush(he,temp)

    if currpoints == ans:
        anspattern = []
        for i in he:
            for j in d[i]:
                anspattern.append(index[tuple([i,j])][-1])
                index[tuple([i,j])].pop()
        print(ans)
        print(len(anspattern))
        print(*sorted(anspattern))
        exit()
    i += 1",nlogn
"n,m=map(int,input().split())
MAP=[list(input()) for i in range(n)]

ANSMAP=[[""."" for i in range(m)] for j in range(n)]

for i in range(1,n-1):
    for j in range(1,m-1):
        if MAP[i-1][j-1]==""
            ANSMAP[i-1][j-1] =""
            ANSMAP[i-1][j]=""
            ANSMAP[i-1][j+1]=""
            ANSMAP[i][j-1]=""
            ANSMAP[i][j+1]=""
            ANSMAP[i+1][j-1]=""
            ANSMAP[i+1][j]=""
            ANSMAP[i+1][j+1]=""

if MAP==ANSMAP:
    print(""YES"")

else:
    print(""NO"")",quadratic
"import math
s1=str(input())
s2=str(input())
d1=0;d2=0;n=0
answer=0
for i in s1:
    if i=='+':d1+=1
    else:
        d1-=1
for i in s2:
    if i=='+':d2+=1
    elif i=='?':n+=1
    else:
        d2-=1
if n>=abs(d2-d1):
    y=(n-abs(d1-d2))/2
    if y%1==0:
        answer=math.factorial(n)/math.factorial(n-y)/math.factorial(y)/2**n
print('%.9f'%answer)",np
"def isValid(field, y, x):
	for i in range(3):
		for j in range(3):
			if i == 1 and j == 1:
				continue
			if field[y + i][x + j] == '.':
				return False
	return True
def fill(field, y, x):
	for i in range(3):
		for j in range(3):
			if i == 1 and j == 1:
				continue
			cur[y + i][x + j] = '
n, m = list(map(int, input().split()))
sig = []
cur = []
for i in range(n):
	sig += [list(input())]
	cur += [["".""] * m]

for i in range(n - 2):
	for j in range(m - 2):
		if isValid(sig, i, j):
			fill(cur, i, j)

if sig == cur:
	print(""YES"")
else:
	print(""NO"")",quadratic
"from collections import deque
n, d, k = map(int, input().split())
if n==1:
    print('NO')
    exit(0)
if n==2:
    if d>1:
        print('NO')
    else:
        print('YES')
        print(1, 2)
    exit(0)
if (not 2<=d<=n-1) or k==1:
    print('NO')
    exit(0)
ans = []
for i in range(d):
    ans.append((i+1, i+2))
now = d+2
for i in range(d-1):
    q = deque([(i+2, min(i, d-i-2))])
    first = True
    while q and len(ans)<n-1:
        node, depth = q.popleft()
        end = now+k-1
        if first:
            end -= 1
        for j in range(now, end):
            ans.append((node, j))
            if len(ans)==n-1:
                break
            if depth>0:
                q.append((j, depth-1))
        now = end
        first = False

if len(ans)==n-1:
    print('YES')
    for i, j in ans:
        print(i, j)
else:
    print('NO')",quadratic
"n = int(input())
b = [int(w) for w in input().split()]
a = [0]*n

l = n//2 - 1
r = n//2

a[l] = b[l] // 2
a[r] = b[l] - a[l]

while l > 0:
    if b[l-1] >= b[l]:
        a[l-1] = a[l]
        a[r+1] = b[l-1] - a[l]
    else:
        a[r+1] = a[r]
        a[l-1] = b[l-1] - a[r]
    l -= 1
    r += 1

print(*a)",linear
"def isPoss(n, arrs, nvals):
    masks = set()
    midx = {}
    for pos,arr in enumerate(arrs):
        mask = 0
        for i in range(nvals):
            if arr[i]>=n:
                mask += 1<<i
        midx[mask] = pos+1
        masks.add(mask)

    for m1 in masks:
        for m2 in masks:
            if m1|m2 == (1<<nvals)-1:
                return midx[m1], midx[m2]

    return -1, -1

narr, nvals = map(int, input().split())

arrs = []
for i in range(narr):
    arrs.append(list(map(int, input().split())))

mn = -1
mx = 10**9+1
while mn < mx-1:
    mid = (mn + mx) // 2
    a,b = isPoss(mid, arrs, nvals)
    if a != -1:
        mn = mid
    else:
        mx = mid - 1

for i in range(1,-1,-1):
    a,b = isPoss(mn+i, arrs, nvals)
    if a != -1:
        print(a,b)
        break",np
"from sys import stdin,stdout
for _ in range(1):

    moves,left=list(map(int,stdin.readline().split()))

    l=1;r=10**9+1
    while l<=r:
        mid=(l+r)>>1
        fx=(mid*(mid+1))//2-left+mid

        if fx<=moves:l=mid+1
        else:r=mid-1
    print(moves-r)",logn
"def getN():
    return int(input())
def getList():
    return list(map(int, input().split()))

n = getN()
mid = n * 2 -1
ans = -mid
while(mid > 0):
    ans += mid*2
    mid -= 2

print(ans)",linear
"candies = 0
n, k = map(int,input().split())
summ = 0
if k == 0:
    for i in range (n-1,-1,-1):
        summ = summ + 1
        candies = candies + summ
        if candies == i:
            print(i)
            break

if k != 0:
    for i in range (n-1,-1,-1):
        summ = summ + 1
        candies = candies + summ
        if candies - i == k:
            print(i)
            break",logn
"c = 0
def backtracking(actuales,restantes,l,r,x):
    global c
    if sum(actuales)<=r and sum(actuales) >= l:
        if max(actuales)- min(actuales) >= x:
            c += 1
    if restantes:
        for i in range(len(restantes)):
            backtracking(actuales+[restantes[i]], restantes[i+1:],l,r,x)
    return 0
def main():
    n,l,r,x = input().split("" "")
    n,l,r,x = int(n), int(l), int(r), int(x)
    difficulties = input().split("" "")
    for i in range(len(difficulties)):
        difficulties[i] = int(difficulties[i])
    difficulties.sort()
    backtracking([],difficulties,l,r,x)
    global c
    return c

if __name__ == ""__main__"":
    print(main())",np
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

import random
import time
random.seed( int(time.time()) )

bb = random.randint(0, 2**30-1)

hat1 = 0
hat2 = 0
lastresult = None
for i in range(29, -1, -1):
    g1 = hat1 + (1<<i)
    g2 = hat2 + (1<<i)

    if lastresult is None:
        print('?',hat1^ bb,hat2)
        t1 = int(input())
    else:
        t1 = lastresult
    if t1!=0:
        print('?',g1^ bb,g2)
        t2 = int(input())
        if t1!=t2:
            if t1==1:
                hat1+= (1<<i)
            else:
                hat2+= (1<<i)
            lastresult = None
            continue
    lastresult = t1
    print('?',g1^ bb,hat2)
    t3 = int(input())
    if t3==1:
        pass
    else:
        hat1+= (1<<i)
        hat2+= (1<<i)

print('!', hat1^bb% (2**30), hat2)",constant
"ii=lambda:int(input())
kk=lambda:map(int, input().split())
ll=lambda:list(kk())

a,b,c,d,e,f=kk()
al = [a,b,c,d,e,f]
s = sum(al)
area = a*b+c*d+e*f
side = int(area**.5)
if side**2 != area or side not in al:
	print(-1)
	exit()
if al.count(side) == 3:

	if s == 4*side:
		rest = [a for a in al if a != side]
		print(side)
		for _ in range(side):
			print("""".join([""A""*rest[0], ""B""*rest[1], ""C""*rest[2]]))
elif al.count(side) > 1:
	print(-1)
else:
	x=al.index(side)
	y=x^1
	res = al[y]
	a,b=min(x,y),max(x,y)
	s1 = ""ABC""[a//2]
	s23 = [s for s in ""ABC"" if s != s1]
	rest = al[:a]+al[b+1:]
	res = side - res
	a,b=[rest[0],rest[1]],[rest[2],rest[3]]
	if not (res in a and res in b):
		print(-1)
		exit()
	o1,o2 = a[a.index(res)^1],b[b.index(res)^1]
	print(side)
	for _ in range(al[y]):
		print(s1*side)
	for _ in range(res):
		print("""".join([s23[0]*o1,s23[1]*o2]))",np
"import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
l,r=list(map(int,input().split()))
if l==r:
    print(0)
else:
    a=bin(l)[2:]
    b=bin(r)[2:]
    x=len(a)
    y=len(b)
    if x!=y:
        ans=0
        for i in range(y):
            ans+=(2**i)
        print(ans)
    else:
        for i in range(x):
            if a[i]!=b[i]:
                ind=i
                break
        l=x-ind
        ans=0
        for i in range(l):
            ans+=(2**i)
        print(ans)",logn
"n=int(input())
S=[]
for i in range(n):
    A=[int(i) for i in input().split()]
    S.append(sum(A))
if S[0]==max(S):
    print(""1"")
    exit()
thomas=S[0]
rank=1
S.sort(reverse=True)
for i in S:
    if i == thomas:
        print(rank)
        exit()
    else:
        rank+=1",linear
"import math
def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):
	    d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
n,x,y=map(int,input().split());
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));
y+=x;
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np
"a,v=map(int,input().split())

l,d,w=map(int,input().split())

t=0

def gett(a,b,c):

    delta=b**2-4*a*c

    t1=(-b+delta**(1/2))/(2*a)

    t2=(-b-delta**(1/2))/(2*a)

    if min(t1,t2)>0:

        return min(t1,t2)

    else:

        return max(t1,t2)

if 2*a*d<=w*w or v<=w:

    if 2*a*l<=v*v:

        t=(2*l/a)**(1/2)

    else:

        t=l/v+v/a/2

else:

    tmp=d-1/2*v*v/a+1/2*(v-w)**2/a-v*(v-w)/a

    if tmp<=0:

        tmp2=l-d-(1/2*(v-w)**2/a+w*(v-w)/a)

        if tmp2>=0:

            t=tmp2/v+(v-w)/a+2*gett(a,2*w,w*w/(2*a)-d)+w/a

        else:

            t=gett(a/2,w,d-l)+2*gett(a,2*w,w*w/(2*a)-d)+w/a

    else:

        tmp2=l-d-(1/2*(v-w)**2/a+w*(v-w)/a)

        if tmp2>=0:

            t=tmp2/v+(v-w)/a+(2*v-w)/a+tmp/v

        else:

            t=gett(a/2,w,d-l)+(2*v-w)/a+tmp/v

print(""%.12f"" %(t))",constant
"n = int(input())
a = list(map(int, input().split()))
for i in range(n):
    if a[i]>=0:
        a[i] = -a[i]-1
x = min(a)

if len(a)%2==1:
    for i in range(n):
        if a[i]==x:
            a[i] = -a[i]-1
            break
print(*a)",linear
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

for _ in range(N):
    l,r = getIntList()
    n = (r-l+1)
    z = n//2
    if l%2==0:
        z*=-1
    if n%2==1:
        if r%2==0:
            z += r
        else:
            z-=r
    print(z)",constant
"l,r = map(int,input().split())
ans = l ^ r
x = bin(ans)[1:]
if ans == 0:
    print(0)
else:
    ptr = -1
    po = 0
    while True:
        if( x[ptr] == '0') :
            ans += 2**po
        po += 1
        ptr-=1
        if( ptr == -len(x)-1 ):
            break

    print(ans)",logn
"def solve():
    l, r = map(int, input().split())

    ans = l^r
    j = 0
    while 1<<j <= ans:
        ans |= 1<<j
        j += 1

    print(ans)

solve()",logn
"ans = []
import math
disks_rad = [int(x) for x in input().split("" "")]
nums = [int(x) for x in input().split("" "")]
r = disks_rad[1]
ans.append(r)
for i in range(1, disks_rad[0]):
  y_cord = r
  for j in range(i):
      if ((nums[i] - nums[j]) ** 2) <= ((r ** 2) * 4):
          y_cord = max(y_cord,
                        ans[j] +
                        math.sqrt(4 *
                                  (r ** 2) -
                                  (nums[j] - nums[i]) ** 2
                                )
                      )
  ans.append(y_cord)
print("" "".join([str(x) for x in ans]))",quadratic
"n, m = map(int, input().split())
a = []
array = []
for i in range(n):
    a.append(list(map(str, input())))
    listt = []
    for c in range(m):
        if a[i][c] == '
            listt.append(1)
        else:
            listt.append(0)
    array.append(listt)
for y in range(1, n - 1):
    for x in range(1, m - 1):
        f = a[y + 1][x] == '
        s = a[y][x + 1] == '
        th = a[y - 1][x] == '
        if f and s and th:
            array[y + 1][x] -= 1
            array[y + 1][x + 1] -= 1
            array[y + 1][x - 1] -= 1
            array[y][x + 1] -= 1
            array[y][x - 1] -= 1
            array[y - 1][x - 1] -= 1
            array[y - 1][x] -= 1
            array[y - 1][x + 1] -= 1
mb = True
for y in range(n):
    for x in range(m):
        if array[y][x] == 1:
            mb = False
            break
if mb:
    print(""YES"")
else:
    print(""NO"")",quadratic
"n ,m  = list(map(int, input().split()))
a = list(map(int, input().split()))
b = list(map(int, input().split()))
ans = 0
for i in range(len(a)):
    if (len(b) == 0):
        break
    if (b[0] >= a[i]):
        ans += 1
        del b[0]
print(ans)",linear
"n, v = map(int, input().split())
if n - 1 > v:
    print(v + (n - v + 2) * (n - v - 1) // 2)
else:
    print(n - 1)",constant
"n=int(input())
a=list(map(int,input().split()))
st=[a[0]]
for i in range(1,n):
    if len(st)>0 and st[-1]%2==a[i]%2:
        st.pop()
    else:
        st.append(a[i])
if len(st)<=1:
    print(""YES"")
else:
    print(""NO"")",linear
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    arr = list(map(int, input().split()))
    idx = arr.index(n)
    ok = 1
    for i in range(1, idx):
        if arr[i] < arr[i - 1]:
            ok = 0
    for i in reversed(range(idx, n - 1)):
        if arr[i] < arr[i + 1]:
            ok = 0
    if ok:
        print(""YES"")
    else:
        print(""NO"")

    return 0

main()",linear
"from sys import stdin
from collections import defaultdict
import heapq

n = int(stdin.readline())
a = [[] for _ in range(n)]
for _ in range(n-1):
    e = stdin.readline().split(' ')
    u, v = int(e[0]), int(e[1])
    a[u-1].append(v-1)
    a[v-1].append(u-1)

leaves = [i for i in range(n) if len(a[i]) == 1]

def dfs_from(root):
    depth = defaultdict(int)
    child = {}
    parent = defaultdict(lambda: -1)
    stack = [root]
    visited = [False for _ in range(n)]
    while len(stack) > 0:
        crt = stack[-1]
        if visited[crt]:
            stack.pop(-1)
            if len(a[crt]) > 1:
                child[crt], depth[crt] = max([(c, depth[c]+1) for c in a[crt]
                                              if c != parent[crt]],
                                             key=lambda x: x[1])
            else:
                child[crt] = -1
                depth[crt] = 0
            continue

        visited[crt] = True
        for next in a[crt]:
            if next != parent[crt]:
                stack.append(next)
                parent[next] = crt

    return depth, child

first_choice = leaves[0]
d1, child1 = dfs_from(first_choice)

root = max([(a[leaf][0], d1[a[leaf][0]]) for leaf in leaves],
           key=lambda leaf_depth: leaf_depth[1])[0]
while child1[root] != -1:
    root = child1[root]
depth, child = dfs_from(root)

solution = [1]
pq = []
for k, v in depth.items():
    heapq.heappush(pq, (-v, k))

seen = [False for _ in range(n)]
seen[root] = True

while len(pq) > 0:
    _, best = heapq.heappop(pq)
    if seen[best]:
        continue
    path = []
    c = best
    s = 0
    while c != -1:
        seen[c] = True
        c = child[c]
        s = s+1
    s = s + solution[-1]
    solution.append(s)

for _ in range(n - min(len(solution), n)):
    solution.append(n)

print(' '.join([str(s) for s in solution]))",nlogn
"n,m=map(int,input().split())
dp=[[-1 for i in range(m)] for j in range(n)]
dp2=[[-1 for i in range(m)] for j in range(n)]

for i in range(0,n):
    s=input()
    for j in range(0,m):
        if(s[j]=='.'):
            dp[i][j]=-1
        else:
            dp[i][j]=s[j]
for i in range(0,n-2):
    for j in range(0,m-2):

        p=0
        c=0
        for k in range(i,i+3):
            for h in range(j,j+3):
                p=p+1
                if(p!=5):
                    if(dp[k][h]=='
                        c=c+1

        if(c==8):
            p=0
            for k in range(i,i+3):
                for h in range(j,j+3):
                    p=p+1
                    if(p!=5):
                        dp2[k][h]='

if(dp==dp2):
    print('YES')
else:
    print('NO')",quadratic
"from math import gcd
import sys

def input():
    return sys.stdin.readline().rstrip()

DXY = [(0, -1), (1, 0), (0, 1), (-1, 0)]

def on_one_line(Points):
    n = len(Points)
    s = set([])
    for i in range(1,n):
        x,y = Points[i][0] - Points[0][0],Points[i][1] - Points[0][1]
        g = gcd(x,y)
        x //= g
        y //= g
        if (x < 0):
            x *= -1;y *= -1
        if (x == 0):
            y = abs(y)
        s.add((x,y))
    return len(s) == 1

def main():
    n = int(input())
    Ps = [tuple(map(int, input().split())) for i in range(n)]
    if n <= 2:
        print(""YES"")
        return 0
    if on_one_line(Ps):
        print(""YES"")
        return 0

    p,q = Ps[1][0] - Ps[0][0],Ps[1][1] - Ps[0][1]
    g = gcd(p,q)
    p //= g;q //= g
    if (p < 0):p *= -1;q *= -1
    elif (p == 0):q = abs(q)

    not_same = []
    for i in range(2,n):
        x,y = Ps[i][0] - Ps[0][0],Ps[i][1] - Ps[0][1]
        x,y = x//gcd(x,y),y//gcd(x,y)
        if (x < 0):x *= -1;y *= -1
        if (x == 0):y = abs(y)
        if (x,y) != (p,q):
            not_same.append(Ps[i])

    if len(not_same) <= 1:
        print(""YES"")
        return 0

    if on_one_line(not_same):
        print(""YES"")
        return 0

    p,q = not_same[0][0] - Ps[0][0],not_same[0][1] - Ps[0][1]
    P,Q = not_same[0]
    g = gcd(p,q)
    p //= g;q //= g
    if (p < 0):p *= -1;q *= -1
    elif (p == 0):q = abs(q)
    not_same = []

    for i in range(n):
        x,y = Ps[i][0] - Ps[0][0],Ps[i][1] - Ps[0][1]
        if (x == 0 and y == 0):continue
        x,y = x//gcd(x,y),y//gcd(x,y)
        if (x < 0):x *= -1;y *= -1
        if (x == 0):y = abs(y)
        if (x,y) != (p,q):
            not_same.append(Ps[i])

    if len(not_same) <= 1:
        print(""YES"")
        return 0

    if on_one_line(not_same):
        print(""YES"")
        return 0

    p,q = P - Ps[1][0],Q - Ps[1][1]
    g = gcd(p,q)
    p //= g;q //= g
    if (p < 0):p *= -1;q *= -1
    elif (p == 0):q = abs(q)

    not_same = []
    for i in range(n):
        x,y = Ps[i][0] - Ps[1][0],Ps[i][1] - Ps[1][1]
        if (x == 0 and y == 0):continue
        x,y = x//gcd(x,y),y//gcd(x,y)
        if (x < 0):x *= -1;y *= -1
        if (x == 0):y = abs(y)
        if (x,y) != (p,q):
            not_same.append(Ps[i])

    if len(not_same) <= 1:
        print(""YES"")
        return 0

    if on_one_line(not_same):
        print(""YES"")
        return 0

    print(""NO"")
    return 0

if __name__ == ""__main__"":
    main()",nlogn
"n,l,r,x = map(int,input().split())
c = [int(i) for i in input().split()]
ans = 0
for bit in range(2,1<<n):
    probs = []
    t = 0
    for i in range(n):
        if bit&(1<<i):
            probs.append(c[i])
            t += c[i]

    a = min(probs)
    b = max(probs)

    if t >= l and t <= r and abs(a-b) >= x:
        ans += 1
print(ans)",np
"n = int(input())
if n % 2 == 1:
    print((n + 2) // 2)
elif n > 0:
    print(n + 1)
else:
    print(0)",constant
"n = int(input())
u = list(map(int, input().split()))
u.sort()
ans = 0
k = 1
ok = False
for i in range(1, n):
    if u[i] == u[i - 1]:
        k += 1
        if k == 3:
            print('cslnb')
            exit()
        if k == 2:
            if ok or u[i] == 0 or u[i] - u[i - 2] == 1:
                print('cslnb')
                exit()
            ok = True
    else:
        k = 1
for i in range(n):
    ans += u[i] - i
if ans % 2 == 0:
    print('cslnb')
else:
    print('sjfnb')",nlogn
"from sys import stdin, stdout
import bisect
input = stdin.readline
t = 1
for _ in range(t):
    n,q=map(int,input().split())
    a=[int(x) for x in input().split()]
    pre=[]
    s=0
    for i in a:
        s+=i
        pre.append(s)
    lost=0
    val_lost=0
    ans=[]
    qu=[int(x) for x in input().split()]
    for i in qu:
        val=i+val_lost
        b=bisect.bisect_left(pre,val,lost,n)
        val_lost=min(val,pre[-1])
        if b==n:
            lost = 0
            val_lost = 0
            ans.append(n)
            continue
        if pre[b]==val:
            lost=b+1
        else:
            lost=b
        if lost==n:
            lost = 0
            val_lost = 0
        ans.append(n-lost)
    for i in ans:
        print(i)",nlogn
"x,y,z,t1,t2,t3 = map(int, input().split())
stairs = abs(x - y) * t1
lift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3
print('YES' if lift <= stairs else 'NO')",constant
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))

cost=[(l[i]+r[i],i) for i in range(n)]

cost.sort()

CANDIES=[None]*n
CANDIES[cost[0][1]]=n

candy=n
for i in range(1,n):
    if cost[i][0]==cost[i-1][0]:
        CANDIES[cost[i][1]]=candy
    else:
        candy-=1
        CANDIES[cost[i][1]]=candy

check=1
for i in range(n):
    lc=0
    rc=0
    for j in range(i):
        if CANDIES[j]>CANDIES[i]:
            lc+=1
    for j in range(i+1,n):
        if CANDIES[j]>CANDIES[i]:
            rc+=1

    if lc!=l[i] or rc!=r[i]:
        check=0

if check==1:
    print(""YES"")
    for c in CANDIES:
        print(c,end="" "")

else:
    print(""NO"")",quadratic
"from sys import stdin, stdout
import math,sys,heapq
from itertools import permutations, combinations
from collections import defaultdict,deque,OrderedDict
from os import path
import random
import bisect as bi
def yes():print('YES')
def no():print('NO')
if (path.exists('input.txt')):

    sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
    def I():return (int(input()))
    def In():return(map(int,input().split()))
else:

    def I():return (int(stdin.readline()))
    def In():return(map(int,stdin.readline().split()))

def dict(a):
    d={}
    for x in a:
        if d.get(x,-1)!=-1:
            d[x]+=1
        else:
            d[x]=1
    return d
def find_gt(a, x):
    'Find leftmost value greater than x'
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:
        return -1

def cal(r,g,b,dp,R,G,B,nr,ng,nb):
    if dp[r][g][b]!=-1:
        return dp[r][g][b]
    best=0
    if r<nr and g<ng:
        best=max(best,cal(r+1,g+1,b,dp,R,G,B,nr,ng,nb)+R[r]*G[g])
    if r<nr and b<nb:
        best=max(best,cal(r+1,g,b+1,dp,R,G,B,nr,ng,nb)+R[r]*B[b])
    if g<ng and b<nb:
        best=max(best,cal(r,g+1,b+1,dp,R,G,B,nr,ng,nb)+B[b]*G[g])
    dp[r][g][b]=best
    return dp[r][g][b]
def main():
    try:
        nr,ng,nb=In()
        dp=[[[-1 for x in range(201)]for y in range(201)] for z in range(201)]
        R=list(In())
        G=list(In())
        B=list(In())
        R.sort(reverse=True)
        G.sort(reverse=True)
        B.sort(reverse=True)
        print(cal(0,0,0,dp,R,G,B,nr,ng,nb))
    except:
        pass

M = 998244353
P = 1000000007

if __name__ == '__main__':

    for _ in range(1):main()",cubic
"fib = [0]*100
fib[1] = 1
for i in range(2, 100):
    fib[i] = fib[i-1] + fib[i-2]

n = int(input())

if (n in fib):
    if (n == 0):
        print(0, 0, 0)
    elif (n == 1):
        print(0, 0, 1)
    else:
        print(0, fib[fib.index(n)-2], fib[fib.index(n)-1])
else:
    print(""I'm too stupid to solve this problem"")",constant
"R, G, B = map(int, input().split())
L = [sorted(map(int, input().split())) for _ in range(3)]

DP = [0] * ((R+1) * (G+1) * (B+1))
def idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b

for r in range(R+1):
	for g in range(G+1):
		for b in range(B+1):
			best = 0

			if r:
				if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]
				if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])

			if g and b:
				best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])

			DP[idx(r, g, b)] = best

print(max(DP))",cubic
"import os
import sys
from io import BytesIO, IOBase

def main():
    n, k = map(int, input().split())
    print(n-int(((9+8*(n+k))**0.5-3)/2))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",logn
"x, k = map(int, input().split())
MOD = 1000000007
pw = pow(2, k + 1, MOD)
n = pow(2, k, MOD)
a = (pw * x) - n
a = (a + 1) % MOD
if x == 0:
    a = 0
print(int(a))",logn
"import sys
import math
import collections
import bisect
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n,m=get_ints()
    space=0
    saved=[]
    for i in range(n):
        a,b=get_ints()
        space+=a
        saved.append(a-b)
    saved.sort(reverse=True)
    if space-sum(saved)>m:
        print(-1)
        continue
    i=0
    count=0
    if space<=m:
        print(0)
        continue
    while i<n:
        count+=1
        space-=saved[i]
        if space<=m:
            print(count)
            break
        i+=1",nlogn
"t = int(input())

def getcol(x1, y1, x2, y2):
    dx = max((x2-x1+1), 0)
    dy = max((y2-y1+1), 0)
    b = w = dx*dy//2
    if dx % 2 and dy % 2:
        if (x1+y1) % 2:
            b = b + 1
        else:
            w = w + 1
    return w, b

for _ in range(t):
    n, m = map(int, input().split())
    x1, y1, x2, y2 = map(int, input().split())
    x3, y3, x4, y4 = map(int, input().split())
    w, b = getcol(1,1,n,m)
    w1, b1 = getcol(x1,y1,x2,y2)
    w2, b2 = getcol(x3,y3,x4,y4)
    w3, b3 = getcol(max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4))
    woff = w-w1-w2+w3
    boff = b-b1-b2+b3
    print(woff+w1-w3+b1-b3, boff+w3+b3+b2-b3+w2-w3)",constant
"a = []
n = int(input())
for _ in range(n):
    a.append(input())
if n==1:
    print(""YES"")
    print(a[0])
else:
    a.sort(key = len)
    for i in range(1,n):
        if a[i-1] not in a[i]:
            print(""NO"")
            break
    else:
        print(""YES"")
        for i in a:
            print(i)",nlogn
"n, m = map(int, input().split())
x1 = -1
x2 = -1
y1 = -1
y2 = -1
for i in range(n):
    s = input()
    for j in range(m):
        if s[j] == 'B':
            if x1 == -1:
                x1 = j + 1
            x2 = max(x2, j + 1)
            if y1 == -1:
                y1 = i + 1
            y2 = i + 1
print((y1 + y2) // 2, (x1 + x2) // 2)",quadratic
"from collections import deque

m, k = list(map(int, input().split()))

G = [set() for _ in range(m + 1)]

q, nq = deque(), deque()

for _ in range(m - 1):
    u, v = list(map(int, input().split()))
    G[u].add(v)
    G[v].add(u)

for u in range(1, m + 1):
    if len(G[u]) == 1:
        q.append(u)

step = 0
removed = 0
ok = True

while removed < m - 1:
    each = {}
    for u in q:
        nxt = G[u].pop()
        G[nxt].remove(u)
        each[nxt] = each.get(nxt, 0) + 1
        removed += 1
        if len(G[nxt]) == 0:
            break
        if len(G[nxt]) == 1:
            nq.append(nxt)
    if any(v < 3 for k,v in each.items()):
        ok = False
        break
    q, nq = nq, deque()
    step += 1

if ok and step == k and removed == m - 1:
    print('Yes')
else:
    print('No')",nlogn
"n=int(input())
l=list(map(int,input().split()))
ans=0
m=[]
for i in range(2*n-1,-1,-1):
    if l[i] not in m:
        m.append(l[i])

for tt in range(0,n):
    i=m[tt]
    j=l.index(i)
    l.pop(j)
    k=l.index(i)
    l.insert(k,j)
    ans+=k-j
print(ans)",quadratic
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
	print(""?"", xr + cb, cb)
	ans11 = input()
	print(""?"", xr, cb)
	if ans11 == ans00:
		ans01 = input()
		if ans01 == '1':
			a += cb
			b += cb
	else:
		ans00 = input()
		if ans11 == '1':
			b += cb
		else:
			a += cb
		xr += cb
	cb //= 2
print(""!"", a, b)",constant
"import sys
input = sys.stdin.readline

n,m,k=map(int,input().split())
P=[input().strip() for i in range(n)]
S=[input().split() for i in range(m)]

for i in range(m):
    S[i][1]=int(S[i][1])-1

PDICT=dict()
for i in range(n):
    PDICT[P[i]]=i

E=[]

for i in range(m):
    x=S[i][0]
    LIST=[]

    for j in range(1<<k):
        t=""""
        for l in range(k):
            if (1<<l) & j != 0:
                t+=""_""
            else:
                t+=x[l]

        if t in PDICT:
            LIST.append(PDICT[t])

    if not (S[i][1] in LIST):
        print(""NO"")
        exit()

    else:
        s=S[i][1]
        for l in LIST:
            if l==s:
                continue
            else:
                E.append((s,l))

EDGEIN=[0]*n
EDGEOUTLIST=[[] for i in range(n)]
for x,y in E:
    EDGEIN[y]+=1
    EDGEOUTLIST[x].append(y)

from collections import deque
QUE = deque()

for i in range(n):
    if EDGEIN[i]==0:
        QUE.append(i)

TOP_SORT=[]
while QUE:
    x=QUE.pop()
    TOP_SORT.append(x)
    for to in EDGEOUTLIST[x]:
        EDGEIN[to]-=1
        if EDGEIN[to]==0:
            QUE.appendleft(to)

if len(TOP_SORT)==n:
    print(""YES"")
    print(*[i+1 for i in TOP_SORT])
else:
    print(""NO"")",np
"from collections import Counter

def f(x):
    return max(list(Counter(x).values()))

n=int(input())
z=input()
l=len(z)
a=f(z)
b=f(input())
c=f(input())

def v(x):
    if x==l:
        return x-1
    else:
        return x+1

if n==1:
    a, b, c=v(a), v(b), v(c)
    if a>b and a>c:
        print(""Kuro"")
    elif b>a and b>c:
        print(""Shiro"")
    elif c>a and c>b:
        print(""Katie"")
    else:
        print(""Draw"")
elif (l-a<=n)+(l-b<=n)+(l-c<=n)>=2:
    print(""Draw"")
elif a>b and a>c:
    print(""Kuro"")
elif b>a and b>c:
    print(""Shiro"")
elif c>a and c>b:
    print(""Katie"")
else:
    print(""Draw"")",linear
"N = int(input())
src = [tuple(map(int,input().split() + [i])) for i in range(N)]
src.sort()

prev_l = max_r = 0
prev_i = outer = -1
for l,r,i in src:
    if prev_l == l:
        print(prev_i+1, i+1)
        exit()
    if r <= max_r:
        print(i+1, outer+1)
        exit()
    else:
        max_r = r
        outer = i
    prev_l = l
    prev_i = i
print(-1,-1)",nlogn
"def MI():
    return map(int,input().split())
def I():
    return int(input())
def LI():
    return [int(i) for i in input().split()]

n,k=MI()

b=-(2*n+3)
c=n*n+n-2*k
x=(-b-((b*b-4*c)**0.5))//2
y=(-b+((b*b-4*c)**0.5))//2
x,y=int(x),int(y)
for i in [x-1,x,x+1,y-1,y,y+1]:
    if i**2+b*i+c==0 and 0<=i<=n-1:
        print(i)
        break",constant
"n = int(input())
x,y = map(int,input().split())
num = x - 1 + y - 1
num2 = n - x + n - y
ans = num <= num2
if ans:
    print(""White"")
else:
    print(""Black"")",constant
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:

        def dfs(i, j):
            if i == len(nums):
                return 0

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            return LIS

        return dfs(0, -1)",np
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

T, = getIntList()

MAXN = 10**18 + 10
def getUpper(N):
    z = 1
    r = 0
    for i in range(N):
        r+=z
        z*=4
        if r>MAXN:
            break
    return r
for _ in range(T):
    N,K = getIntList()
    tk = K
    z = 1
    for i in range(N):
        tk -= z
        z*= 4
        if tk<0: break
    if tk>0:
        print('NO')
        continue
    nowcut =  0
    nt = 1
    nowupper = 0
    ok = False
    for i in range(N):
        nt *=2
        nowcut += nt-1

        if nowcut >K: break
        t = (nt *2 - 3)
        tu  = t * getUpper(N-1-i)
        nowupper += tu
        dprint('bound', nowcut, nowcut+nowupper)
        if nowcut<=K<= nowcut+nowupper:
            ok = True
            break
    if ok:
        print('YES', N-1-i)
    else:
        print(""NO"")",logn
"n = int(input())
a = tuple(map(int, input().split()))
if n * 2 > sum(a) + 2:
	print(""NO"")
else:
	n1 = []
	on = []
	for i in range(n):
		if a[i] != 1:
			n1.append(i)
		else:
			on.append(i)
	print(""YES"", len(n1) + min(2, len(on)) - 1)
	print(n - 1)
	n1it = iter(n1)
	next(n1it)
	for v, u in zip(n1, n1it):
		print(v + 1, u + 1)
	if on:
		print(on.pop() + 1, n1[-1] + 1)
	if on:
		print(on.pop() + 1, n1[0] + 1)
	on = iter(on)
	for n11 in n1:
		for i in range(a[n11] - 2):
			try:
				print(n11 + 1, next(on) + 1)
			except StopIteration:
				break
		else:
			continue
		break",linear
"l, r = map(int, input().split())

if l == r:
    print(0)
    exit()
binr, binl = bin(r)[2:], bin(l)[2:]
binl = '0' * (len(binr) - len(binl)) + binl

for i in range(len(binl)):
    if binl[i] != binr[i]:
        binl = '1' * len(binl[i:])
        break

print(int(binl, 2))",logn
"from itertools import*
def out1(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==1 and b==0 and c==0:
        return 1
    return a*(out2(a-1,b,c)+out3(a-1,b,c))
def out2(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==1 and c==0:
        return 1
    return b*(out1(a,b-1,c)+out3(a,b-1,c))
def out3(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==0 and c==1:
        return 1
    return c*(out2(a,b,c-1)+out1(a,b,c-1))
def column(matrix, i):
    return [row[i] for row in matrix]
N, T = [int(x) for x in raw_input().split()]
A = []
s = 0
for i in range(N):
    A.append([int(x) for x in raw_input().split()])
for i in range(1,N+1):
    comb = list(combinations(A, i))
    for x in comb:
        if sum(column(x,0))==T:
            a = column(x,1).count(1)
            b = column(x,1).count(2)
            c = column(x,1).count(3)
            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))
print(s%1000000007)",np
"class Solution:
    def longestPalindrome(self, s: str) -> str:
        res, resLen = """", 0

        for i in range(len(s)):
            for j in range(i, len(s)):
                l, r = i, j
                while l < r and s[l] == s[r]:
                    l += 1
                    r -= 1

                if l >= r and resLen < (j - i + 1):
                    res = s[i : j + 1]
                    resLen = j - i + 1
        return res",cubic
"R = lambda: map(int, input().split())
for _ in range(int(input())):
    n,k = R()
    s = input()
    p = (k+2)//2
    l = ""RGB""*p
    res = n
    for i in range(n-k+1):
        c = 0

        for j in range(0,k):
            c += (s[i+j] != l[j])
        res = min(res,c)

        c = 0

        for j in range(1,k+1):
            c += (s[i+j-1] != l[j])
        res = min(res,c)

        c = 0

        for j in range(2,k+2):
            c += (s[i+j-2] != l[j])
        res = min(res,c)

    print(res)",quadratic
"def x(a,b):
    if(a>b):
        return(1)
    else:
        return(0)
n=int(input())
a1,a2=map(int,input().split())
b1,b2=map(int,input().split())
c1,c2=map(int,input().split())
if((a1-a2)==(b1-b2)):
    print(""NO"")
elif((a1+a2)==(b1+b2)):
    print(""NO"")
elif(a1==b1):
    print(""NO"")
elif(a2==b2):
    print(""NO"")
elif((a1-a2)==(c1-c2)):
    print(""NO"")
elif((a1+a2)==(c1+c2)):
    print(""NO"")
elif(a1==c1):
    print(""NO"")
elif(a2==c2):
    print(""NO"")
else:
    if((x(a1,b1)==x(a1,c1)) and (x(a2,b2)==x(a2,c2))):
        print(""YES"")
    else:
        print(""NO"")",constant
"def f():
    b = [a[0]]
    for e in a[1:]:
        if b != []:
            if e == b[-1] or abs(e-b[-1])%2==0:
                b.pop()

            else:
                b.append(e)
        else:
            b.append(e)

    for i in range(1,len(b)):
        if abs(b[i]-b[i-1])%2:
            print('NO')
            return

    print('YES')

n=int(input())
a=[int(i) for i in input().split()]

f()",linear
"x, k = map(int, input().split())

if x == 0:
    result = 0
else:
    modulo = 10**9 + 7

    x %= modulo

    result = pow(2, k, modulo)*(2*x - 1) + 1
    result %= modulo

print(result)",logn
"import math

SPACE = ' '

def get_data(file_name):
    result = list()
    state = 0
    data = list()

    try:
        for line in open(file_name, 'r').readlines():
            line = line.strip()
            if state == 0:
                if line == 'Input':
                    data = list()
                    state = 1
                elif line == 'Answer':
                    state = 2
            elif state == 1:
                data += list(map(int, line.split(SPACE)))
                state = 11
            elif state == 11:
                data += list(map(int, line.split(SPACE)))
                state = 0
            elif state == 2:
                data.append(float(line))
                result.append(data)
                state = 0
    except FileNotFoundError:
        print(f'File {file_name} not found.')
    return result

def time(d=None, v=None, v0=0, steady=False):
    if steady:
        return d / v

    if d is None:

        return (v - v0) / ACCEL

    if v is None:
        v = vel(d=d, v0=v0)
    return (2 * d) / (v + v0)

def dist(t=None, v=None, v0=0, steady=False):
    if steady:
        return v * t

    if t is None:

        return (pow(v, 2) - pow(v0, 2)) / (2 * ACCEL)

    return (1 / 2) * (v + v0) * t

def vel(d=None, t=None, v0=0, steady=False):
    if steady:
        return d / t

    if d is None:

        return t * ACCEL - v0

    return pow(2 * d * ACCEL + v0 ** 2, 1 / 2)

def can_ignore_sign(v, w, d):
    return v <= w or d <= dist(v=w)

def ignore_sign(v, w, l):
    dmax = dist(v=v)
    if l <= dmax:
        return time(d=l)
    return time(v=v) + time(d=l - dmax, v=v, steady=True)

def get_time(a, v, l, d, w):
    global ACCEL
    ACCEL = a

    if can_ignore_sign(v, w, d):
        return ignore_sign(v, w, l)

    tmax, dmax = time(v=v), dist(v=v)
    tlim_max, dlim_max = time(v=v, v0=w), dist(v=v, v0=w)
    if dmax + dlim_max <= d:

        res = tmax + time(d=d - dmax - dlim_max, v=v, steady=True) + tlim_max
    else:

        res = time(v=w) + time(v=vel(d=(d - dist(v=w)) / 2, v0=w), v0=w) * 2

    x = d + dist(v=v) - dist(v=w)
    if x >= l:

        res += time(d=l - d, v0=w)
        return res
    return res + time(v=v, v0=w) + time(d=l - x, v=v, steady=True)

if __name__ == '__main__':
    a, v = map(int, input().split())
    l, d, w = map(int, input().split())
    print(get_time(a, v, l, d, w))",constant
"s=input()
for ln in range(len(s),0,-1):
    for L in range(len(s)-ln+1):
        if s[L:L+ln] in s[L+1:]:
            print(ln)
            exit()
print(0)",cubic
"n=int(input())
a=[]
for i in range(n+1):
    a.append(((n+1)-i)*i)
print(max(a))",linear
"n, e = map( int, input().split() )
d = (n - e) // 2
q = []
while n > 0:
    i = min(n, d)
    while i > 0:
        q.append('1')
        i -= 1
        n -= 1
    if n > 0:
        q.append('0')
        n -= 1

print( """".join(q) )",quadratic
"class Solution:
    def getSum(self, a: int, b: int) -> int:
        mask = 0xFFFFFFFF
        max_int = 0x7FFFFFFF

        while b != 0:
            carry = (a & b) << 1
            a = (a ^ b) & mask
            b = carry & mask

        return a if a <= max_int else ~(a ^ mask)",constant
"import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):

        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

re = 0
for i in range(2,N):

    t = N // i -1
    re += t * i

print(re *4)",linear
"r,g,b = map(int,input().split())
R = list(map(int,input().split()))
G = list(map(int,input().split()))
B = list(map(int,input().split()))
R.sort()
G.sort()
B.sort()
dp = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
def solve(r,g,b):
	if ((r==0 and g==0) or (g==0 and b==0) or (b==0 and r==0)):
		return 0
	if dp[r][g][b]==-1:
		if r==0:
			ans =  G[g-1]*B[b-1]+solve(r,g-1,b-1)
		elif g==0:
			ans =  R[r-1]*B[b-1]+solve(r-1,g,b-1)
		elif b==0:
			ans =  G[g-1]*R[r-1]+solve(r-1,g-1,b)
		else:
			ans =  max(G[g-1]*B[b-1]+solve(r,g-1,b-1),G[g-1]*R[r-1]+solve(r-1,g-1,b),R[r-1]*B[b-1]+solve(r-1,g,b-1))
		dp[r][g][b] = ans
	return dp[r][g][b]
ans = solve(r,g,b)
print(ans)",cubic
"l = []
n = []
sum = 0
multiply = 9
for i in range(1,12):
    s = '9' * i
    n.append(int(s))
    sum+=i*multiply
    multiply *= 10
    l.append(sum)
k = int(input())
if(k<9):
    print(k)
else:
    t = 0
    for i in range(len(l)):
        if(k < l[i]):
            t=i
            break
    temp = k-l[t-1]
    offset = temp%(t+1)
    value = temp//(t+1)
    number = n[t-1]+value
    if(offset == 0):
        print(number%10)
    else:
        number += 1
        offset -= 1
        print(str(number)[offset])",logn
"from copy import deepcopy
def sol(n,m,k,aa,bb):
    if k&1:
        return [[-1] * m] * n
    ans = [[float('inf')]*(m+2) for _ in range(n+2)]
    k >>= 1
    for i in range(1,n+1):
        for j in range(1,m+1):
            ans[i][j] = min(aa[i][j], aa[i][j-1], bb[i][j], bb[i-1][j])
    for _ in range(k-1):
        oans = deepcopy(ans)
        for i in range(1,n+1):
            for j in range(1,m+1):
                ans[i][j] = min(
                    aa[i][j]+oans[i][j+1],
                    aa[i][j-1]+oans[i][j-1],
                    bb[i][j]+oans[i+1][j],
                    bb[i-1][j]+oans[i-1][j])

    ans = ans[1:-1]
    ans = [x[1:-1] for x in ans]
    ans = [[2*x for x in a] for a in ans]
    return ans

n,m,k = map(int, input().split())
aa = [list(map(int, input().split())) for _ in range(n)]
inf = float('inf')
bb = [list(map(int, input().split())) for _ in range(n-1)]
aa = [[inf, *x, inf] for x in aa]
bb = [[inf, *x, inf] for x in bb]
pad = [inf] * (m+1)
aa = [pad, *aa, pad]
pad = [inf] * (m+2)
bb = [pad, *bb, pad]
ans = sol(n,m,k,aa,bb)
print('\n'.join(' '.join(map(str, a)) for a in ans))",cubic
"success = 0
def solve(b, freq, i, n, res):
    global success
    if i == len(b):
        success = res
    else:
        success = 0
        move = 9
        while move >= 0 and success == 0:
            m = int(b[i])
            if freq[move] > 0 and res * 10 + move <= n * 10 + m:
                res = res * 10 + move
                n = n * 10 + m
                freq[move] -= 1
                if solve(b, freq, i + 1, n, res) == 0:
                    res //= 10
                    n //= 10
                    freq[move] += 1
            move -= 1
    return success

a = input()
b = input()
freq = []
for i in range(10):
    freq.append(0)
v = []
for x in a:
    n = int(x)
    v.append(n)
    freq[n] += 1
v.sort()
ans = 0
if len(b) > len(a):
    m = 1
    for x in v:
        ans = x * m + ans
        m *= 10
else:
    ans = solve(b, freq, 0, 0, 0)
print(ans)",cubic
"import os
import re
import sys
from bisect import bisect, bisect_left, insort, insort_left
from collections import Counter, defaultdict, deque
from copy import deepcopy
from decimal import Decimal
from fractions import gcd
from io import BytesIO, IOBase
from itertools import (
    accumulate, combinations, combinations_with_replacement, groupby,
    permutations, product)
from math import (
    acos, asin, atan, ceil, cos, degrees, factorial, hypot, log2, pi, radians,
    sin, sqrt, tan)
from operator import itemgetter, mul
from string import ascii_lowercase, ascii_uppercase, digits

def inp():
    return(int(input()))

def inlist():
    return(list(map(int, input().split())))

def instr():
    s = input()
    return(list(s[:len(s)]))

def invr():
    return(map(int, input().split()))

def getSum(p, q):
    n = q - p + 1

    temp = (n * (p + q)//2) - n + 1

    return temp, n

def main():

    n, k = invr()

    l = 2
    r = k
    ans = -1

    while l <= r:
        mid = l + (r - l) // 2
        tot, count = getSum(mid, k)
        if tot >= n:
            ans = count
        if tot < n:
            r = mid - 1
        else:
            l = mid + 1
    if n == 1:
        ans = 0
    print(ans)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",logn
"from sys import stdin,stdout
import heapq
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    l=sorted(zip(lst(),lst(),range(n)))
    h=[];sm=0
    ans={}
    for i in range(n):
        pwr,cns,ind=l[i]
        sm+=cns
        if len(h)>k:
            p=0
            for i in range(len(h)):
                if h[p]>h[i]:
                    p=i
            sm-=h.pop(p)
        ans[ind]=sm
        h+=[cns]
    for i in range(n):
        stdout.write(str(ans[i])+' ')
    print()",nlogn
"n = int(input())
a = list(input())
b = list(input())

ans = 0
i = 0
while i < n:
    if a[i] != b[i]:
        ans += 1
        if i < n - 1 and a[i] == b[i + 1] and b[i] == a[i + 1]:
            i += 1
    i += 1
print(ans)",linear
"import math

n = int(input())
a = list(map(lambda x : int(x), input().split()))
q = len(a)

earliest_time = pow(10, 9) + 1000
earliest_queue = 1
for i in range(q):
    n = int(max(0, math.ceil((a[i] + 1 - (i + 1)) / q)))
    t = (i + 1) + n * q
    if t < earliest_time:
        earliest_time = t
        earliest_queue = i + 1

print(earliest_queue)",linear
"n,m = map(int, input().strip().split(' '))
lst = list(map(int, input().strip().split(' ')))
res = list(dict.fromkeys(lst))
c=[]
for i in range(len(res)):
    c.append(lst.count(res[i]))

if m<n:
    print(0)
elif m==n:
    print(1)
else:
    m1=1
    c1=0
    j=2
    f=0
    while(True):
        c1=0
        for i in range(len(c)):
            c1+=c[i]//j
        if c1>=n:
            m1=j
            j+=1
        else:
            f=1
        if f==1:
            print(m1)
            break",nlogn
"def sum_of_digits(n):
    ans = 0
    while(n):
        ans += n%10
        n//=10
    return ans

n,s = map(int,input().split())
lo = 0; hi = n
x = n+1
while(lo<=hi):
    mid = (lo+hi)//2
    if(mid - sum_of_digits(mid) >= s):
        x = min(mid,x)
        hi = mid - 1
    else:
        lo = mid + 1
print(n - x + 1)",logn
"n, l, r, x = map(int, input().split())
a = [int(i) for i in input().split()]

count = 0
for i in range(1, 2**n+1):
	temp = []
	for j in range(n):
		if i & (1 << j):
			temp.append(a[j])

	if len(temp) and max(temp) - min(temp) >= x and sum(temp) >= l and sum(temp) <= r:
		count += 1

print(count)",np
"n=int(input())+1
if n==1:
    print(0)
elif n%2:
    print(n)
else:
    print(n//2)",constant
"import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))

def modInverse(a , m):
	m0 = m
	y = 0
	x = 1
	if (m == 1):
		return 0
	while (a > 1):
		q = a // m
		t = m
		m = a % m
		a = t
		t = y
		y = x - q * y
		x = t
	if (x < 0):
		x = x + m0
	return x

def num():
	return map(int , input().split())

def nu():
	return int(input())

def find_gcd(x , y):
	while (y):
		x , y = y , x % y
	return x

n,m=num()
a=[0]*n
for i in range(n):
	a[i]=[0]*m
for i in range(n):
	s=input()
	for j in range(m):
		a[i][j]=s[j]
z=["".""]*n
for i in range(n):
	z[i]=["".""]*m
for i in range(n):
	for j in range(m):
		if(j-1>=0 and j+1 <m and i+1<n and i-1>=0):
			if(a[i-1][j]==""
				z[i-1][j]=""
				z[i + 1][j] = ""
				z[i][j - 1] = ""
				z[i][j + 1] = ""
				z[i - 1][j - 1] = ""
				z[i - 1][j + 1] = ""
				z[i + 1][j - 1] = ""
				z[i + 1][j + 1] = ""
ff=True

for i in range(n):
	for j in range(m):
		if(z[i][j]!=a[i][j]):
			ff=False
			break
if(ff):
	print(""YES"")
else:
	print(""NO"")",quadratic
"n=int(input())
m=int(input())
print(m%(1<<n))",constant
"l,r=map(int,input().split())
if(l%2==0 and r-l>1):
    print(l,l+1,l+2,end="" "")
elif(l%2!=0 and r-l>2):
    print(l+1,l+2,l+3,end="" "")
else:
    print(""-1"")",constant
"import io,os

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
n,m=map(lambda x:int(x), input().split())
A = []
for _ in range(n):
    scores = list(map(lambda x:int(x), input().split()))
    A.append(scores)

def solve(n,m,A):

    ans = ()
    nstats = 2**m
    def judge(finalScore):
        nonlocal ans
        seen = {}
        for i,scores in enumerate(A):
            sta = 0
            for e in scores:
                sta=sta*2+(e>=finalScore)

            seen[sta]=i

        for i in range(nstats):
            for j in range(nstats):
                if ((i|j) == nstats-1) and i in seen and j in seen:
                    ans = (seen[i], seen[j])
                    return True

        return False

    l=0
    r=2**31-1
    while l<r:
        m=l+(r-l)//2
        if not judge(m):
            r=m
        else:
            l=m+1

    print(ans[0]+1,ans[1]+1)

solve(n,m,A)",np
"n=int(input())
ans=[]
m=int(n**0.5)
x=n
while x-m>0:
  for i in range(1,m+1):
    ans.append(x-m+i)
  x-=m
for i in range(1,x+1):
  ans.append(i)
print(*ans)",linear
"n, = map(int,input().split())

s = input()
if s=='0':
    print(0)
else:
    print(""1""+""0""*s.count('0'))",linear
"n, k = map(int, input().split())
a = list(map(int, input().split()))
j = 0
a.sort()
n1 = n
for i in range(n):
    while a[j] < a[i]:
        if a[i] <= a[j] + k:
            n1 -= 1
        j += 1
print(n1)",nlogn
"from math import factorial
def C(m,n):
    return factorial(n) // (factorial(m) * factorial(n - m))

command_1, command_2 = input(), input()
num = command_2.count('?')
i = command_1.count('+') - command_1.count('-') -\
command_2.count('+') + command_2.count('-') + num
if i % 2 == 0 and 0 <= i//2 <= num:
    print(""%.9f""%(C(i//2, num) / 2**num))
else:
    print(""0.000000000"")",np
"n,m=map(int,input().split())
a=list(map(int,input().split()))
k=0
ans=-1
for i in range(n-1):
    while k<n-1 and a[k+1] - a[i]<=m:
        k+=1
    if i<k-1:
        ans=max(ans,(a[k]-a[i+1]) / (a[k]-a[i]))
print(ans)",nlogn
"def rotate(L):
    L1 = ['' for i in range(n)]
    for i in range(n):
        for j in range(n):
            L1[n - j - 1] += L[i][j]
    return L1

def flip_v(L):
    L1 = []
    for i in range(n):
        L1.append(L[i][::-1])
    return L1

def flip_h(L):
    L1 = []
    for i in range(n):
        L1.append(L[n - i - 1])
    return L1

n = int(input())
L = []
M = []
for i in range(n):
    L.append(input())
for i in range(n):
    M.append(input())
L1 = rotate(L)
L2 = rotate(L1)
L3 = rotate(L2)
L4 = flip_v(L)
L5 = flip_h(L)
L6 = rotate(L4)
L7 = rotate(L6)
L8 = rotate(L7)
L9 = rotate(L5)
L10 = rotate(L9)
L11 = rotate(L10)
if L == M or L1 == M or L2 == M or L3 == M or L4 == M or L5 == M or L6 == M or L7 == M or L8 == M or L9 == M or L10 == M or L11 == M:
    print('Yes')
else:
    print('No')",quadratic
"s = [list(input()), list(input())]
ans = 0
l = len(s[0])
i = 0
while i < l - 1:
    a = (s[0][i], s[0][i + 1], s[1][i], s[1][i + 1])
    if a.count(""0"") == 4:
        ans += 1
        s[0][i + 1] = ""X""
        i+=1
    elif a.count(""0"") == 3:
        ans += 1
        i += 2
    else:
        i += 1
print(ans)",constant
"from collections import deque

n, m = map(int, input().split())

arr = [int(z) for z in input().split()]

mods = [0 for i in range(m)]
placement = [[] for i in range(m)]

for i in range(n):
    mods[arr[i] % m] += 1
    placement[arr[i] % m].append(i)

cnt = 0
queue = deque()
target = n//m
for i in range(2*m):
    mod = i % m
    if mods[mod] > n//m:

        for c in range(mods[mod] - target):
            queue.append([i, placement[mod][c]])
        mods[mod] = target

    elif mods[mod] < target:
        while len(queue) > 0 and mods[mod] < target:
            elem, indice = queue.popleft()
            mods[mod] += 1
            cnt += (mod - elem) % m
            arr[indice] += (mod - elem) % m

print(cnt)
print(' '.join([str(i) for i in arr]))",linear
"from math import factorial as fact

s=input()
t=input()

pos=s.count('+')-t.count('+')
neg=s.count('-')-t.count('-')
que=t.count('?')
if pos<0 or neg<0:
    print(0)
else:
    print((fact(que)/(fact(pos)*fact(neg)))/(2**que))",np
"import sys

def input():
    return sys.stdin.readline().rstrip()

def slv():
    k = int(input())

    def cnt_special(N):
        if N == 0:
            return 0
        return cnt_special(N - 1) + N * (pow(10, N) - pow(10, N - 1))

    def cnt_digit(N):
        ord = len(str(N))
        bound = ord - 1
        return cnt_special(bound) + ord * (N + 1 - 10 ** bound)

    if k < 10:
        print(k)
    else:
        l = 1
        r = int(1e12)
        while r - l > 1:
            med = (r + l)//2
            if cnt_digit(med) >= k:
                r = med
            else:
                l = med

        rep = k - cnt_digit(l)
        print(str(r)[rep - 1])
        return

def main():
    t = 1
    for i in range(t):
        slv()
    return

if __name__ == ""__main__"":
    main()",logn
"import sys
input = sys.stdin.readline
def main():
    n,m,k = map(int,input().split())
    if k%2==1:
        for i in range(n):
            for j in  range(m):
                print(-1,end="" "")
            print()
        return 0
    kk=k
    maps= [[[0 for i in range(4)] for j in range(m)] for ii in range(n)]

    dp=[[[1e9 for i in range(k//2+1)] for j in range(m)] for ii in range(n)]
    for i in range(n):
            for j in range(m):
                dp[i][j][0]=0
    for i in range(n):
        s=list(map(int,input().split()))
        for j in range(m-1):
            maps[i][j][0]=s[j]
            maps[i][j+1][1]=s[j]
    for i in range(n-1):
        s=list(map(int,input().split()))
        for j in range(m):
            maps[i][j][2]=s[j]
            maps[i+1][j][3]=s[j]
    for k in range(1,kk//2+1):
        for i in range(n):
            for j in range(m):
                if j<m-1:
                    dp[i][j+1][k]=min(dp[i][j+1][k],dp[i][j][k-1]+maps[i][j][0])
                if i<n-1:
                    dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k-1]+maps[i][j][2])
                if i>0:
                    dp[i-1][j][k]=min(dp[i-1][j][k],dp[i][j][k-1]+maps[i][j][3])
                if j>0:
                    dp[i][j-1][k]=min(dp[i][j-1][k],dp[i][j][k-1]+maps[i][j][1])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k]*2,end="" "")
        print()
main()",cubic
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        n, d = map(int, input().strip().split())
        x = list(map(int, input().strip().split()))
        ans = set()
        for i in range(n):
            for z in [-d, d]:
                y = x[i] + z
                dmin = min(abs(y - xi) for xi in x)
                if dmin == d:
                    ans.add(y)
        print(len(ans))

solver()",linear
"def main():
    n = int(input())
    a = list(map(int, input().split()))
    r = 0
    while a:
        c = a[0]
        del a[0]
        for i in range(len(a)):
            if c == a[i]:
                break
        del a[i]
        r += i
    print(r)

if __name__ == ""__main__"":
    main()",quadratic
"def power(x,y):
	mod=1000000007
	res = 1
	while (y > 0):
		if (y &1):
			res = (res * x)%mod
		y = y >> 1
		x = (x * x)%mod
	return res;
x,k=map(int,input().split())
mod=1000000007
factor=power(2,k)
factor%=mod
ans=((2*factor*x)%mod-(factor)%mod + 1 + mod)%mod
if x==0:
	print(""0"")
else:
	print(ans)",logn
"def solve(r, g, b, rs, gs, bs):
    rs.sort(reverse=True)
    gs.sort(reverse=True)
    bs.sort(reverse=True)
    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
    sol = 0
    for ri in range(r+1):
        for gi in range(g+1):
            for bi in range(b+1):
                if ri < r and gi < g:
                    dp[ri+1][gi+1][bi] = max(dp[ri+1][gi+1][bi], rs[ri]*gs[gi] + dp[ri][gi][bi])
                if ri < r and bi < b:
                    dp[ri+1][gi][bi+1] = max(dp[ri+1][gi][bi+1], rs[ri]*bs[bi] + dp[ri][gi][bi])
                if gi < g and bi < b:
                    dp[ri][gi+1][bi+1] = max(dp[ri][gi+1][bi+1], gs[gi]*bs[bi] + dp[ri][gi][bi])
                sol = max(sol, dp[ri][gi][bi])
    return sol

r, g, b = map(int, input().split())
rs = list(map(int, input().split()))
gs = list(map(int, input().split()))
bs = list(map(int, input().split()))
print(solve(r, g, b, rs, gs, bs))",cubic
"n, s = int(input()), input() * 2

h = s.count('H') // 2

print(h - max(s[i:i + h].count('H') for i in range(n)))",linear
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]

n=ri()
a=ris()
freq=Counter(a)
ans=0
for x in freq:
  for i in range(32):
    c=(1<<i)-x
    if c not in freq:
      continue
    if c==x and freq[x]==1:
      continue
    break
  else:
    ans+=freq[x]

print(ans)",nlogn
"class Solution:
    def lengthOfLIS(self, nums):
        n = len(nums)
        memo = [[-1] * (n + 1) for _ in range(n)]

        def dfs(i, j):
            if i == n:
                return 0
            if memo[i][j + 1] != -1:
                return memo[i][j + 1]

            LIS = dfs(i + 1, j)

            if j == -1 or nums[j] < nums[i]:
                LIS = max(LIS, 1 + dfs(i + 1, i))

            memo[i][j + 1] = LIS
            return LIS

        return dfs(0, -1)",quadratic
"import sys
input = sys.stdin.readline

R,G,B = map(int,input().split())

r = list(map(int,input().split()))
g = list(map(int,input().split()))
b = list(map(int,input().split()))

r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
r = [0] + r
g = [0] + g
b = [0] + b
R += 1
G += 1
B += 1
dp = [[[0]*B for _ in range(G)] for __ in range(R)]

res = 0

for i in range(R):
    for j in range(G):
        for k in range(B):

            tmp = 0
            if i > 0 and j > 0:
                tmp = max(tmp,dp[i-1][j-1][k]+r[i]*g[j])
            if i > 0 and k > 0:
                tmp = max(tmp,dp[i-1][j][k-1]+r[i]*b[k])
            if j > 0 and k > 0:
                tmp = max(tmp,dp[i][j-1][k-1]+g[j]*b[k])
            dp[i][j][k] = tmp
            res = max(res,tmp)

print(res)",cubic
"n = int(input())
m = ''.join(set(list(str(n))))
if m == '47' or m == '74' or m == '4' or m == '7':
  print('YES')
else:
  if n %4 == 0 or n %7== 0 or n %74== 0 or n %47== 0:
    print('YES')
  else:
    print(""NO"")",constant
"from math import *
k,n,s,p = map(int,input().split())
sheetsforone = ceil(n/s)
sheetsfork = sheetsforone*k
packs = ceil(sheetsfork/p)
print(int(packs))",constant
"a = int(input())
print((a // 2) * 3)",constant
"import sys,math
from collections import deque,defaultdict
import operator as op
from functools import reduce
from itertools import permutations

I=sys.stdin.readline

def ii():
	return int(I().strip())
def li():
	return list(map(int,I().strip().split()))
def mi():
	return map(int,I().strip().split())

def ncr(n, r, p):

    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def valid(row,col,rows,cols,rcross,lcross):
 	return rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0

def div(n):
	if n==1:
		return 1
	cnt=2
	for i in range(2,int(n**.5)+1):
		if n%i==0:
			if i!=n//i:
				cnt+=2
			else:
				cnt+=1
	return cnt

def isPrime(n):
	if n<=1:
		return False
	elif n<=2:
		return True
	else:
		flag=True
		for i in range(2,int(n**.5)+1):
			if n%i==0:
				flag=False
				break
		return flag

def s(b):
	ans=[]
	while b>0:
		tmp=b%10
		ans.append(tmp)
		b=b//10
	return ans

def main():
	n,k=mi()
	arr=[]
	for _ in range(n):
		x,y=mi()
		arr.append((x,y))

	arr=sorted(arr,key=lambda x: x[0],reverse=True)

	for i in range(n-1):
		for j in range(i+1,n):
			if arr[i][0]==arr[j][0] and arr[i][1]>arr[j][1]:
				arr[i],arr[j]=arr[j],arr[i]

	cnt=arr.count(arr[k-1])
	print(cnt)

if __name__ == '__main__':
	main()",nlogn
"import os
from sys import stdin
from math import inf

dx = [1, 0, -1, 0]
dy = [0, 1, 0, -1]

def solve(tc):
    N, M, K = map(int, stdin.readline().split())

    wx = [[] for j in range(N)]
    for i in range(N):
        wx[i] = list(map(int, stdin.readline().split()))

    wy = [[] for i in range(N-1)]
    for i in range(N-1):
        wy[i] = list(map(int, stdin.readline().split()))

    if K & 1:
        for i in range(N):
            for j in range(M):
                print(-1, end=' ')
            print()
        return

    mem = [[[0 for i in range(M)] for j in range(N)] for k in range(K+1)]

    half = K // 2
    for kk in range(1, half+1):
        for yy in range(N):
            for xx in range(M):
                mem[kk][yy][xx] = inf

                for d in range(4):
                    y = yy + dy[d]
                    x = xx + dx[d]

                    if y < 0 or y >= N or x < 0 or x >= M:
                        continue

                    if d == 0:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wx[yy][xx]*2)
                    elif d == 1:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wy[yy][xx]*2)
                    elif d == 2:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wx[yy][x]*2)
                    else:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wy[y][xx]*2)

    for yy in range(N):
        for xx in range(M):
            print(mem[half][yy][xx], end=' ')
        print()

tcs = 1

tc = 1
while tc <= tcs:
    solve(tc)
    tc += 1",cubic
"from sys import stdin
input=stdin.readline
def check(mid,a,limit):
	res=[]
	s=0
	for r,t,id in a:
		if r>=mid and t+s<=limit:
			res.append(id+1)
			s+=t
		elif t+s>limit:
			break
		if len(res)==mid:
			break

	return res

def f(a,limit):
	a.sort(key=lambda s:s[1])
	ans=None
	lo=0
	hi=10**9
	while lo<=hi:
		mid=(lo+hi)//2
		res=check(mid,a,limit)
		if len(res)>=mid:
			lo=mid+1
			ans=(res,mid)
		else:
			hi=mid-1
	print(ans[1])
	print(ans[1])
	print(*ans[0])

n,limit=map(int,input().strip().split())
q=[]
for i in range(n):
	x,y=map(int,input().strip().split())
	q.append((x,y,i))
f(q,limit)",nlogn
"one = list(map(int, input().split()))
two = list(map(int, input().split()))

one_ = sorted([(one[i], one[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))
two_ = sorted([(two[i], two[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))

ones = [one_[0], one_[2], one_[3], one_[1]]
twos = [two_[1], two_[3], two_[2], two_[0]]

L, D, U, R = ones[0][0], ones[0][1], ones[2][1], ones[2][0]

def in_one(point):
    x, y = point

    return L <= x <= R and D <= y <= U

def in_two(point):
    x_0, y_0 = twos[0]

    def U_p(x_):
        return x_ + y_0 - x_0

    def D_m(x_):
        return -x_ + y_0 + x_0

    x_1, y_1 = twos[2]

    def U_m(x_):
        return -x_ + y_1 + x_1

    def D_p(x_):
        return x_ + y_1 - x_1

    x, y = point

    return D_m(x) <= y <= U_p(x) and D_p(x) <= y <= U_m(x)

c_one = ((L + R) / 2, (U + D) / 2)
c_two = ((twos[0][0] + twos[2][0]) / 2, (twos[1][1] + twos[3][1]) / 2)

ones.append(c_one)
twos.append(c_two)

for p in ones:
    if in_two(p):
        print('YES')
        exit()

for p in twos:
    if in_one(p):
        print('YES')
        exit()

print('NO')",constant
"x,y=map(int,input().strip().split())
if(abs(x-y)<2):
    print(-1)
else:
    k=[]
    for i in range(x,y+1):
        if(i%2==0):
            k.append(i)
            if(i+1<y):
                k.append(i+1)
                k.append(i+2)
                break
    if(len(k)==3):
        print("" "".join(str(t) for t in k))
    else:
        print(-1)",constant
"get = lambda : list(map(int, input().split(' ')))
n, m, k = get()
rlist, clist = [], []
for _ in range(n):
    rlist.append(get())
for _ in range(n-1):
    clist.append(get())

dway = [[0,1],[0,-1],[1,0],[-1,0]]
if k%2:
    res = [[-1]*m for _ in range(n)]
else:
    flist = [[0]*m for _ in range(n)]
    for _ in range(k//2):
        glist = [[10**9]*m for _ in range(n)]
        for dx, dy in dway:
            klist = rlist if dx == 0 else clist
            for x in range(n):
                for y in range(m):
                    xx, yy = x+dx, y+dy
                    if not (0<=xx<n) or not (0<=yy<m):
                        continue
                    tx = xx if dx==-1 else x
                    ty = yy if dy==-1 else y
                    glist[x][y] = min(glist[x][y], flist[xx][yy] + klist[tx][ty] * 2)
        flist = glist
    res = flist
for row in res:
    print(' '.join(map(str, row)))",cubic
"from sys import stdin, stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))

for _ in range(1):
    n,m=lst()
    a=lst()
    a=[0]+a+[m]
    n=len(a)
    suf=[0]*n
    suf[n-2]=abs(a[-2]-a[-1])
    for i in range(n-3, -1, -1):
        suf[i]=a[i+1]-a[i]+suf[i+2]
    ans=suf[0]
    cost=0
    for i in range(1, n):
        if i&1:
            v=a[i]-1-a[i-1]
            if v!=0:ans=max(ans, cost+v+suf[i])
            cost+=a[i]-a[i-1]
        else:
            v=a[i-1]+1
            if v!=a[i]:ans=max(ans, cost+a[i]-v+(suf[i+1] if i+1<n else 0))
    print(ans)",linear
"n,m=map(int,input().split())
l=[]
for i in range(n):
    s=input()
    l.append(s)
minX,minY,maxX,maxY=n,m,0,0
for i in range(n):
    for j in range(m):
        if l[i][j]=='B':
            minX,minY,maxX,maxY=min(minX,i),min(minY,j),max(maxX,i),max(maxY,j)
print((minX+maxX)//2+1,(minY+maxY)//2+1)",quadratic
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

n = INT()
d = {}
sm = 0

for i in range(n):
    indx , y = MAP()
    d[indx] = [1 , [y]]

m = INT()
for i in range(m):
    indx , y = MAP()
    if indx in d :
        d[indx][0] += 1
        d[indx][1].append(y)
    else:
        d[indx] = [1 , [y]]

for i in d :
    if d[i][0] == 1 :
        sm += d[i][1][0]
    else:
        sm += max(d[i][1])

print(sm)",nlogn
"class Point:

    def __init__(self, x, y):
        self.x = x
        self.y = y

class Vector:

    def __init__(self, start, end):
        self.x = end.x - start.x
        self.y = end.y - start.y

    def mult(self, a):
        return self.y * a.x - self.x * a.y

n = int(input())
points = []
for i in range(n):
    x, y = map(int, input().split())
    points.append(Point(x, y))

if n <= 3:
    print('YES')
    exit()

def onLine(points):
    n = len(points)
    if n < 3:
        return True
    a = Vector(points[0], points[1])
    for i in range(2, n):
        b = Vector(points[0], points[i])
        if a.mult(b) != 0:
            return False
    return True

tmp = [points[0], points[1]]
oth = []
for i in range(2, n):
    tmp.append(points[i])
    if not onLine(tmp):
        oth.append(points[i])
    tmp.pop()
if onLine(oth):
    print('YES')
    exit()

tmp = [points[0], points[2]]
oth = []
for i in range(1, n):
    if i == 2:
        continue
    tmp.append(points[i])
    if not onLine(tmp):
        oth.append(points[i])
    tmp.pop()
if onLine(oth):
    print('YES')
    exit()

tmp = [points[1], points[2]]
oth = []
for i in range(0, n):
    if i == 2 or i == 1:
        continue
    tmp.append(points[i])
    if not onLine(tmp):
        oth.append(points[i])
    tmp.pop()
if onLine(oth):
    print('YES')
    exit()

print('NO')",nlogn
"from sys import stdin, stdout
from math import sin, tan, cos

n, m, k, l = map(int, stdin.readline().split())

lb, rb = 0, n // m + 1
while rb - lb > 1:
    mid = (lb + rb) >> 1

    if mid * m - k >= l:
        rb = mid
    else:
        lb = mid

if lb != n // m:
    stdout.write(str(rb))
else:
    stdout.write('-1')",logn
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
print('\n'.join(map(lambda x: ''.join(map(str, x)), r)))",quadratic
"import sys

def input():
    return sys.stdin.readline().rstrip()

def slv():
    n, m, k = map(int, input().split())
    if k % 2 != 0:
        for i in range(n):
            print(*[-1]*m)
        return

    k //= 2

    DP = [[[0]*m for i in range(n)] for _ in range(k + 1)]
    G = [[[] for i in range(m)] for j in range(n)]
    for i in range(n):
        C = list(map(int,input().split()))
        for j in range(m - 1):
            cost = C[j]
            G[i][j].append((cost,i,j + 1))
            G[i][j + 1] .append((cost,i,j))

    for i in range(n - 1):
        C = list(map(int,input().split()))
        for j in range(m):
            cost = C[j]
            G[i][j].append((cost,i + 1,j))
            G[i+1][j].append((cost,i,j))

    for p in range(1,k + 1):
        for u in range(n):
            for v in range(m):
                DP[p][u][v] = min(DP[p - 1][x][y] + cost for (cost,x,y) in G[u][v])
    for i in range(n):
        ans = [DP[k][i][j]*2 for j in range(m)]
        print(*ans)
    return
def main():
    t = 1
    for i in range(t):
        slv()
    return

if __name__ == ""__main__"":
    main()",cubic
"n=int(raw_input())

ans=[]
p=1
fin=n
while len(ans)<n-1:
	for i in range(fin-(n/(2**p))):
		ans.append(2**(p-1))
		fin-=1
	p+=1

if 2**(p-2) + 2**(p-1) <=n:
	ans.append(2**(p-1) + 2**(p-2))
else:
	ans.append(2**(p-1))

s="" "".join(str(x) for x in ans)

print(s)",nlogn
"rgb = 'RGB' * 1000
for q in range(int(input())):
    n, k = [int(s) for s in input().split()]
    s = input()
    ans = 3000
    for w in range(3):
        for e in range(n - k + 1):
            temp = 0
            for i in range(k):
                if s[e + i] != rgb[w + i]:
                    temp += 1
            ans = min(ans, temp)
    print(ans)",quadratic
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0.0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [tuple([i] + inp(dtype)) for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
get_bit = lambda x, i: (x >> i) & 1

n = int(input())
a, masks, big = inp_2ds(float, n), dict(), 2 ** n - 1

if n == 1:
    exit(print(1))

for i in range(n):
    for j in range(i + 1, n):
        masks[big ^ (1 << j)] += a[i][j]
        masks[big ^ (1 << i)] += a[j][i]

for _ in range(2, n):
    tem = dict()
    for msk in masks:
        for bit in range(18):
            if get_bit(msk, bit):
                tem[msk ^ (1 << bit)] += sum([a[i][bit] for i in range(n) if get_bit(msk, i)]) * masks[msk]
    masks = tem

su = sum(masks.values())
print(*[masks[1 << i] / su for i in range(n)])",np
"from sys import stdin

def solve(x: int) -> bool:
    global ans
    dp = {}
    for i in range(n):
        temp = 0
        for j in range(m):
            if a[i][j] >= x:
                temp = temp | (1 << j)
        dp[temp] = i
    for aa, bb in dp.items():
        for cc, dd in dp.items():
            if aa | cc == 2 ** m - 1:
                ans = (bb + 1, dd + 1)
                return True
    return False

ans = (-1, -1)
n, m = map(int, stdin.readline().split())
a = []
for i in range(n):
    a.append(list(map(int, stdin.readline().split())))
l, r = 0, 10 ** 9
while l <= r:
    mid = (l + r) // 2
    if solve(mid):
        l = mid + 1
    else:
        r = mid - 1
print(*ans)",np
"import sys

def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))

n=iinput()
print(3*n//2)",constant
"n=int(input())
l=[]
nn=n
while n :
    n-=1
    s=input()
    l.append([len(s),s])
l.sort()
ch=1
i=1

ans=[]
for i in range(nn-1):
    if l[i][1] not in l[i+1][1]:
        ch=0
        break
    else:

        ans.append(l[i][1])

if ch:
    ans.append(l[nn-1][1])
    print(""YES"")

    print(*ans, sep = ""\n"")
else:
    print(""NO"")",nlogn
"def s(k):
	if k % 2 == 0:
		return k // 2
	else:
		return - (k + 1) // 2

for i in range(int(input())):
	l, r = map(int, input().split())
	print(s(r) - s(l - 1))",constant
"x, y, z, t1, t2, t3 = map(int, raw_input().split())
elev = t3*3 + t2*(abs(z-x) + abs(x-y))
stairs = t1*abs(x - y)
if elev <= stairs:
    print('YES')
else:
    print('NO')",constant
"n, k = map(int, input().strip().split())
data = map(int, input().strip().split())
sol = []
mapping = [(-1,1000)]*256
for x in data:
    if mapping[x][0] == -1:
        for i in range(max(x-k+1,0), x+1):
            if mapping[i][0] == -1:
                if i > 0 and mapping[i-1][1]+(x-i+1) <= k:
                    p = mapping[i-1][1]+1
                    for j in range(i, x+1):
                        mapping[j] = (mapping[i-1][0], p)
                        p += 1
                else:
                    p = 1
                    for j in range(i, x+1):
                        mapping[j] = (i, p)
                        p += 1
                break
    sol.append(mapping[x][0])
print(' '.join(map(str, sol)))",quadratic
"import sys
input = sys.stdin.readline
n = int(input().strip())
a = [int(x) for x in input().strip().split()]
dp = [[0]*n for i in range(n)]
for i in range(n):
    dp[i][i] = [a[i], 1]
for i in range(1, n):
    for j in range(n-i):
        v, c = -1, i+1
        for k in range(i):
            if dp[j][j+k][0]!=-1 and dp[j][j+k][0] == dp[j+k+1][j+i][0]:
                v,c = dp[j][j+k][0]+1, 1
                break
            else:
                v, c = -1, min(c, dp[j][j+k][1] + dp[j+k+1][j+i][1])
        dp[j][j+i] = [v, c]
print(dp[0][-1][1])",cubic
"def f(k):
    res = 1
    a = 2
    while k:
        if k % 2 == 1:
            res *= a
            k -= 1
        else:
            a *= a
            k //= 2
        res = res % (1000000007)
        a = a % (1000000007)
    return res

n, k = map(int, input().split())
if n == 0:
    print(0)
elif k == 0:
    print((n * 2) % 1000000007)
else:
    first = (2 * n - 1) % 1000000007
    first *= f(k)
    first = (first + 1) % 1000000007
    print(first)",logn
"from itertools import combinations

n, l, r, x = map(int, input().split())
a = list(map(int, input().split()))

arr = []

for i in range(2, n+1):
    ar = combinations(a, i)
    for j in ar:
        arr += [(list(j))]

count = 0
for i in arr:
    dif = max(i) - min(i)
    total = sum(i)
    if dif >= x and (total >= l and total <= r):
        count +=1

print(count)",np
"import sys
from math import floor, ceil

input = sys.stdin.readline

n, k = map(int, input().split())

print(ceil((n*2)/k) + ceil((n*5)/k) + ceil((n*8)/k))",constant
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
    print(""?"", xr + cb, cb)
    ans11 = input()
    print(""?"", xr, cb)
    if ans11 == ans00:
        ans01 = input()
        if ans01 == '1':
            a += cb
            b += cb
    else:
        ans00 = input()
        if ans11 == '1':
            b += cb
        else:
            a += cb
        xr += cb
    cb //= 2
print(""!"", a, b)",logn
"from itertools import product
import itertools

import sys
import heapq
from collections import deque
MOD=1000000000007

def find(parent,i):

    if parent[i] != i:
        parent[i]=find(parent,parent[i])
    return parent[i]

def union(parent,rank,xx,yy):
    x=find(parent,xx)
    y=find(parent,yy)
    if rank[x]>rank[y]:
        parent[y]=x
    elif rank[y]>rank[x]:
        parent[x]=y
    else:
        parent[y]=x
        rank[x]+=1
ans=0

x=0
y=0

MAX=1000000000
N,M,K=list(map(int,sys.stdin.readline().strip().split()))
W=[[[MAX,MAX,MAX,MAX] for j in range(M)] for i in range(N)]
for i in range(N):
    l=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(M-1):
        W[i][j][1]=l[j]
        W[i][j+1][0]=l[j]
for i in range(N-1):
    l=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(M):

        W[i][j][3]=l[j]
        W[i+1][j][2]=l[j]

if K%2==1:
    for i in range(N):
        ans=[]
        for j in range(M):
            ans.append(""-1"")
        print("" "".join(ans))
else:

    K=K//2
    dp=[[[0 for j in range(M)] for i in range(N)] for k in range(K+1)]
    for kt in range(1,K+1):

        dl=((0,-1),(0,1),(-1,0),(1,0))
        for i in range(N):
            for j in range(M):
                ans=MAX
                for t in range(4):

                    ii,jj=dl[t]

                    if i+ii>=0 and i+ii<N and j+jj>=0 and j+jj<M:
                        ans=min(ans,dp[kt-1][i+ii][j+jj]+W[i][j][t]*2)

                dp[kt][i][j]=ans

    for i in range(N):
        ans=[]
        for j in range(M):
            ans.append(str(dp[-1][i][j]))
        print("" "".join(ans))",cubic
"import sys

def read_input(input_path=None):
    if input_path is None:
        f = sys.stdin
    else:
        f = open(input_path, 'r')

    n, m = map(int, f.readline().split())

    return n, m

def sol(n, m):
    v = [0 for _ in range(n+1)]
    left, right = 1, n
    for i in range(1, n + 1):
        if n - i - 1 <= 0:
            pw = 1
        else:
            pw = 1 << (n - i - 1)

        if m <= pw:
            v[left] = i
            left += 1
        else:
            v[right] = i
            right -= 1
            m -= pw
    return [' '.join(map(str, v[1:]))]

def solve(input_path=None):
    return sol(*read_input(input_path))

def main():
    for line in sol(*read_input()):
        print(f""{line}"")

if __name__ == '__main__':
    main()",np
"n,k = map(int, input().split())
s = input()
l = []
for i in s:
    a = ord(i)-96
    if a not in l:
        l.append(a)
l.sort()
c = l[0]
a = 1
b = l[0]
for i in range(1,len(l)):
    if a==k:
        break
    if (l[i]-b)>1:
        a += 1
        c += l[i]
        b = l[i]
if a<k:
    print(-1)
else:
    print(c)",linear
"n = int(input())
mod = 10**9+7
dp = [0]*(n+1)
dp[0] = 1
for i in range(n):
    nx = [0]*(n+1)
    s = str(input())
    if s == 'f':
        nx[0] = 0
        for j in range(1, n+1):
            nx[j] = dp[j-1]
            nx[j] %= mod
    else:
        nx[n] = dp[n]
        for j in reversed(range(n)):
            nx[j] = nx[j+1]
            nx[j] += dp[j]
            nx[j] %= mod
    if i != n-1:
        dp = nx
print(sum(dp)%mod)",quadratic
"n,m = map(int,input().split())
x = input().split()
t = input().split()
r = [0]*n
d = [0]*m
countr = 0
countd = 0
for i in range(n+m):
    if int(t[i]) == 1:
        d[countd] = int(x[i])
        countd += 1
    else:
        r[countr] = int(x[i])
        countr += 1
current = 0
count = [0]*m
for i in range(n):
    while current < m-1:
        if d[current+1] >= r[i]:
            break
        current += 1
    if current == m-1:
        count[m-1] += (n-i)
        break
    if 2*r[i] <= (d[current]+d[current+1]):
        count[current] += 1
    else:
        count[current+1] += 1
s = """"
for i in range(m):
    s += str(count[i])+"" ""
print(s[:-1])",nlogn
"import math

n,m,kk=[int(x) for x in input().split()]
right,down=[],[]
for i in range(n) :
	a=[int(x) for x in input().split()]
	right.append(a)

for i in range(n-1) :
	a=[int(x) for x in input().split()]
	down.append(a)

dp,dpCopy=[],[]
for i in range(n) :
	li,li1=[],[]
	for j in range(m) :
		li.append(math.inf)
		li1.append(math.inf)
	dp.append(li)
	dpCopy.append(li1)

for i in range(1,(kk//2)+1) :

	for j in range(n) :
		for k in range(m) :
			if i==1 :
				if j==0 :
					if k==0 :
						dp[j][k]=min(dp[j][k],down[j][k],right[j][k])
					elif k==m-1 :
						dp[j][k]=min(dp[j][k],right[j][k-1],down[j][k])
					else :
						dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j][k])
				elif j==n-1 :
					if k==0 :
						dp[j][k]=min(dp[j][k],down[j-1][k],right[j][k])
					elif k==m-1 :
						dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k])
					else :
						dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k])
				elif k==0 :
					dp[j][k]=min(dp[j][k],right[j][k],down[j-1][k],down[j][k])
				elif k==m-1 :
					dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k],down[j][k])
				else :
					dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k],down[j][k])

				continue

			if j==0 :
				if k==0 :
					dp[j][k]=min(dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])
				elif k==m-1 :
					dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j+1][k]+down[j][k])
				else :
					dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])
			elif j==n-1 :
				if k==0 :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k+1]+right[j][k])
				elif k==m-1 :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1])
				else :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])
			elif k==0 :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k+1]+right[j][k])
			elif k==m-1 :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1])
			else :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])

	for ii in range(n) :
		for jj in range(m) :
			dpCopy[ii][jj]=dp[ii][jj]

if kk%2==1 :
	for i in range(n) :
		for j in range(m) :
			print(-1,end=' ')
		print()
	exit(0)

for i in range(n) :
	for j in range(m) :
		print(2*dp[i][j],end=' ')
	print()",cubic
"n,r=list(map(int,input().split()))
x=list(map(int,input().split()))
y=[r]*n
for i in range(1,n):
    for j in range(i):
        d=abs(x[i]-x[j])
        if d<=2*r:
            y[i]=max(y[i],y[j]+(4*r*r-d*d)**(0.5))
print(*y)",quadratic
"import math

n=int(input())

s2=input()
s2=list(s2)
s=[]
for i in range(n):
    if s2[i]=='0':
        continue
    else:
        s.append(int(s2[i]))
s1=sum(s)
n=len(s)
l=[]
for i in range(2,n+1):
    if s1%i==0:
        l.append(s1//i)
f=0
if len(s)==0:
    f=1
for i in range(len(l)):
    c=0
    if f==1:
        break
    for j in range(n):
        c+=s[j]
        if c==l[i]:
            c=0
            if j==n-1:
                f=1
        elif c<l[i]:
            c=c
        else:
            break
if f==0:
    print('NO')
else:
    print('YES')",quadratic
"n = int(input())
s = list(str(input()))
t = list(str(input()))

from collections import Counter
cs = Counter(s)
ct = Counter(t)
if cs != ct:
    print(-1)
    exit()

xs = [[] for _ in range(26)]
xt = [[] for _ in range(26)]
for i in range(n):
    j = ord(s[i])-ord('a')
    xs[j].append(i)

for i in range(n):
    j = ord(t[i])-ord('a')
    xt[j].append(i)

x = [-1]*n
for i in range(26):
    for j, k in zip(xs[i], xt[i]):
        x[j] = k

ans = []
for i in range(n):
    for j in reversed(range(i+1, n)):
        if x[j-1] > x[j]:
            x[j-1], x[j] = x[j], x[j-1]
            ans.append(j)
print(len(ans))
print(*ans)",quadratic
"import sys
input = sys.stdin.readline

rr, gg, bb = map(int, input().split())
inf = 114514
r = list(map(int, input().split())) + [inf]
g = list(map(int, input().split())) + [inf]
b = list(map(int, input().split())) + [inf]
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = []
for _ in range(rr + 1):
    dp.append([[0] * (bb + 1) for _ in range(gg + 1)])
ans = 0
for i in range(rr + 1):
    ri = r[i]
    for j in range(gg + 1):
        gj = g[j]
        for k in range(bb + 1):
            bk = b[k]
            if (i + j + k) % 2:
                continue
            dpijk = 0
            if i > 0 and j > 0:
                dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk)
            if j > 0 and k > 0:
                dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk)
            if k > 0 and i > 0:
                dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk)
            dp[i][j][k] = dpijk
            if ans < dpijk:
                ans = dpijk
print(ans)",cubic
"import random

n = int(input())

vec = [list(map(int, input().rstrip('\n').split(' '))) for i in range(n)]

bo = 10**6

coef = [[1, 1, 0], [1, -1, 0], [-1, 1, 0], [-1, -1, 0],
[1, 0, 1], [1, 0, -1], [-1, 0, 1], [-1, 0, -1],
[0, 1, 1], [0, 1, -1], [0, -1, 1], [0, -1, -1]]

def lv(x):
	return (x[0]**2 + x[1]**2)**0.5

if n == 1:
	res = [1]
elif n == 2:
	if vec[0][0]*vec[1][0] + vec[0][1]*vec[1][1] <= 0:
		res = [1, 1]
	else:
		res = [1, -1]
else:
	res = [0 for i in range(n)]
	fer = [[vec[0], vec[1], vec[2]],[[0], [1], [2]]]
	for l in range(len(vec)-2):
		for j in coef:
			der = [0, 0]
			der[0] = j[0]*fer[0][0][0] + j[1]*fer[0][1][0] + j[2]*fer[0][2][0]
			der[1] = j[0]*fer[0][0][1] + j[1]*fer[0][1][1] + j[2]*fer[0][2][1]
			if lv(der) <= bo:
				ner = []
				for i in range(3):
					if j[i] != 0:
						ner.append(i)
				if len(fer[1][ner[0]]) == 1:
					res[fer[1][ner[0]][0]] = j[ner[0]]
				elif j[ner[0]] == -1:
					for k in fer[1][ner[0]]:
						res[k] *= -1
				fer[0][ner[0]] = der
				fer[1][ner[0]] += fer[1][ner[1]]
				if len(fer[1][ner[1]]) == 1:
					res[fer[1][ner[1]][0]] = j[ner[1]]
				elif j[ner[1]] == -1:
					for k in fer[1][ner[1]]:
						res[k] *= -1
				if l == len(vec)-3:
					del fer[0][ner[1]]
					del fer[1][ner[1]]
				else:
					fer[0][ner[1]] = vec[3+l]
					fer[1][ner[1]] = [3+l]
				break
	if fer[0][0][0]*fer[0][1][0] + fer[0][0][1]*fer[0][1][1] <= 0:
		if len(fer[1][0]) == 1:
			res[fer[1][0][0]] = 1
		if len(fer[1][1]) == 1:
			res[fer[1][1][0]] = 1
	else:
		if len(fer[1][0]) == 1:
			res[fer[1][0][0]] = -1
		elif len(fer[1][1]) == 1:
			res[fer[1][1][0]] = -1
		else:
			for k in fer[1][0]:
				res[k] *= -1
res1 = ''
for i in res:
	res1 += str(i)+' '
res1 = res1[:-1]
print(res1)",nlogn
"x = int('00001111', 2)
y = int('00110011', 2)
z = int('01010101', 2)
E = set()
T = set()
F = {('x', x), ('y', y), ('z', z)}
prv = (set(), set(), set())
fam = 2 ** 8
tmpl = '
ans = [tmpl] * fam
def cmpr(E):
    global ans
    ans = [tmpl] * fam
    for e in E:
        if len(ans[e[1]]) > len(e[0]) or len(ans[e[1]]) == len(e[0]) and ans[e[1]] > e[0]:
            ans[e[1]] = e[0]
    return set((j, i) for i, j in enumerate(ans) if j != tmpl)
while prv != (E, T, F):
    prv = E.copy(), T.copy(), F.copy()
    for f in prv[2]:
        F.add(('!' + f[0], ~f[1] & (fam - 1)))
        T.add(f)
        for t in prv[1]:
            T.add((t[0] + '&' + f[0], t[1] & f[1]))
    for t in prv[1]:
        E.add(t)
    for e in prv[0]:
        if e not in F:
            F.add(('(' + e[0] + ')', e[1]))
        for t in prv[1]:
            E.add((e[0] + '|' + t[0], e[1] | t[1]))
    E, T, F = cmpr(E), cmpr(T), cmpr(F)
cmpr(E)
n = int(input())
for i in range(n):
	print(ans[int(input(), 2)])",quadratic
"fast=lambda:stdin.readline().strip()
zzz=lambda:[int(i) for i in fast().split()]
z,zz=input,lambda:list(map(int,z().split()))
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from re import *
from sys import *
from math import *
from heapq import *
from queue import *
from bisect import *
from string import *
from itertools import *
from collections import *
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from collections import Counter as cc
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def output(answer):stdout.write(str(answer))

s=fast()
ans=s.replace('1','')+'2'
t=ans.find('2')
print(ans[:t]+'1'*s.count('1')+ans[t:-1])",linear
"n, k = map(int, input().split())
ps = list(map(int, input().split()))
if k == 1:
    print(' '.join([str(i) for i in ps]))
    exit()

g = [None for i in range(256)]
f = [None for i in range(256)]
ans = []
for i in range(n):
    p = ps[i]
    if g[p] is not None:
        ans.append(g[p])
        f[p] = 1
    else:
        gb= 0
        for j in range(1, k):
            ind = p - j
            if f[ind] is not None:
                gb = ind +1
                break
            if ind <= 0:
                break
            if j == k-1:
                gb = ind
        ans.append(gb)
        for j in range(k):
            if gb+j >= 256:
                break
            if f[gb + j] is None:
                g[gb+j] = gb
            else:
                break
        f[gb] = 1
        f[p] = 1
print(' '.join([str(i) for i in ans]))",quadratic
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    q = I()
    rr = []

    def f(a,b,c,d):
        if a > c or b > d:
            return (0,0)
        sa = c-a + 1
        sb = d-b + 1
        g = h = (sa * sb) // 2
        if (sa*sb) % 2 == 1:
            g += 1

        if (a+b) % 2 == 0:
            return (g,h)
        return (h,g)

    def fa(a):
        return f(a[0],a[1],a[2],a[3])

    for _ in range(q):
        n,m = LI()
        wa = LI()
        ba = LI()
        wc,bc = f(1,1,n,m)
        w1,b1 = fa(wa)
        w2,b2 = fa(ba)
        w3,b3 = f(max(wa[0],ba[0]),max(wa[1],ba[1]),min(wa[2],ba[2]),min(wa[3],ba[3]))

        wc += b1
        bc -= b1
        wc -= w2
        bc += w2
        wc -= b3
        bc += b3
        rr.append('{} {}'.format(wc,bc))

    return ""\n"".join(map(str,rr))

print(main())",constant
"import math
import heapq,bisect
import sys
from collections import deque,defaultdict
from fractions import Fraction
mod=10**9+7
mod1=998244353

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree1:
    def __init__(self, data, default=9999999, func=lambda a, b: min(a , b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por=1
    for i in range(len(l)):
        por*=l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] <= key):

            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c=0
    while(n>0):
        n//=10
        c+=1
    return c
def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)

        if (arr[m] > k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

def findmin(h,n):
    n.sort()
    h=int(h)
    ans='-1'

    for i in n:
        if int(i)>h:
            break
        ans=i

    return ans
n=list(input())
n1=list(input())
if len(n)<len(n1):
    n.sort(reverse=True)
    print(*n,sep='')
    sys.exit()
n.sort()
ans=""""
f=0
for i in range(len(n)):
    t=i-1
    c=0
    r = findmin(n1[i], n)
    if r=='-1':
        while(r=='-1'):
            n.append(ans[-c-1])
            r=findmin(int(n1[t])-1,n)
            t-=1
            c+=1
        ans=ans[:len(ans)-c]
        ans+=r
        n.remove(r)
        f=1
        break
    n.remove(r)
    if r==n1[i]:
        ans+=r
        continue
    else:
        ans+=r
        f=1
        break
if f==1:
    n.sort(reverse=True)
    for i in n:
        ans+=i
print(ans)",cubic
"import sys
def countR(ip):
    c=0
    for i in ip:
        if(i=='R'):
            c+=1
    return c

def countB(ip):
    c=0
    for i in ip:
        if(i=='B'):
            c+=1
    return c

def countG(ip):
    c=0
    for i in ip:
        if(i=='G'):
            c+=1
    return c

t=int(sys.stdin.readline())
x='RGB'*680
y='GBR'*680
z='BRG'*680
for i in range(t):
    n,k=list(map(int,sys.stdin.readline().strip().split()))
    a=sys.stdin.readline().strip()
    xk=x[:k]
    yk=y[:k]
    zk=z[:k]

    op=2001
    for j in range(n-k+1):
        b=a[j:j+k]

        xd=0
        yd=0
        zd=0

        for jj in range(len(b)):
            if(b[jj]!=xk[jj]):
                xd+=1
            if(b[jj]!=yk[jj]):
                yd+=1
            if(b[jj]!=zk[jj]):
                zd+=1

        op=min(op,xd,yd,zd)
    print(op)",quadratic
"import sys
input = lambda : sys.stdin.readline().rstrip()

sys.setrecursionlimit(2*10**5+10)
write = lambda x: sys.stdout.write(x+""\n"")
debug = lambda x: sys.stderr.write(x+""\n"")
writef = lambda x: print(""{:.12f}"".format(x))

def zeta_super(val, n):

    out = val[:]
    for i in range(n):
        for j in range(1<<n):
            if not j>>i&1:
                out[j] += out[j^(1<<i)]
    return out

n = int(input())
a = list(map(int, input().split()))
m = max(a).bit_length()
M = 10**9+7
v = [0]*(1<<m)
for item in a:
    v[item] += 1
v2 = [1]
for i in range(n+1):
    v2.append(v2[-1]*2%M)
nv = zeta_super(v, m)
ans = 0
for b in range(1<<m):
    ans += (v2[nv[b]]-1)*pow(-1, bin(b).count(""1""))
    ans %= M
print(ans%M)",np
"def detect_cycle(n,edges):
        visited = [False]*n
        stack = []
        color = [0]*n
        for v in range(n):
            if not visited[v]:
                if dfs_visit(v,edges,visited,stack,color):
                    return stack
        return None

def dfs_visit(v,edges,visited,stack,color):
        visited[v] = True
        stack.append(v)
        color[v] = 1
        for u in edges[v]:
            if not visited[u]:
               if dfs_visit(u,edges,visited,stack,color):
                   return True

            elif color[u] == 1:
                stack.append(u)
                return True

        color[v] = 2
        stack.pop(stack.index(v))
        return False

if __name__ == '__main__':
        n,m = map(int,input().split())
        edges = [[] for i in range(n)]
        for _ in range(m):
            u,v  = map(int,input().split())
            edges[u - 1].append(v - 1)

        inCycle = detect_cycle(n,edges)
        if inCycle:
            possible = False
            index = inCycle.index(inCycle[-1])
            inCycle = inCycle[index:]
            for v in range(len(inCycle) - 1):
                edges[inCycle[v]].remove(inCycle[v + 1])
                if detect_cycle(n,edges) is None:
                    possible = True
                    break
                else:
                    edges[inCycle[v]].append(inCycle[v + 1])
        else: possible = True
print('YES' if possible else 'NO')",quadratic
"import sys
from math import sqrt, gcd, ceil, log, floor
from bisect import bisect, bisect_left
from collections import defaultdict, Counter, deque
from heapq import heapify, heappush, heappop
input = sys.stdin.readline
read = lambda: list(map(int, input().strip().split()))

MOD = 10**9 + 7

def main():

	r, g, b = read()
	r_ar=sorted(read(), reverse = True); g_ar = sorted(read(), reverse = True); b_ar = sorted(read(), reverse = True)
	N = 201
	dp = [[[-1]*N for i in range(N)]for j in range(N)]

	def f(x, y, z):

		if ((x >= r) + (y >= g) + (z >= b)) >= 2:
			return(0)
		if dp[x][y][z] != -1:
			return(dp[x][y][z])
		maxi = 0
		if x < r and y < g:
			maxi = max(maxi, r_ar[x]*g_ar[y] + f(x+1, y+1, z))
		if z < b and y < g:
			maxi = max(maxi, b_ar[z]*g_ar[y] + f(x, y+1, z+1))
		if x < r and z < b:
			maxi = max(maxi, r_ar[x]*b_ar[z] + f(x+1, y, z+1))
		dp[x][y][z] = maxi
		return(maxi)
	print(f(0, 0, 0))

if __name__ == ""__main__"":
	main()",cubic
"import math
import random
import heapq,bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict
threading.stack_size(10**8)
mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase
sys.setrecursionlimit(300000)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1

class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):

        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n

class SegmentTree1:
    def __init__(self, data, default=2**51, func=lambda a, b: a & b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: max(a , b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

n=int(input())
l=list(map(int,input().split()))
cost=list(map(int,input().split()))
dp=defaultdict(int)
dp[0]=0
se=set([0])
for i in range(n):
    for j in se:
        k=int(math.gcd(j,l[i]))
        if dp[k]==0:
            dp[k]=dp[j]+cost[i]
        dp[k]=min(dp[k],dp[j]+cost[i])
    se=set(dp.keys())
if dp[1]==0:
    print(-1)
else:
    print(dp[1])",np
"def solve(a, b):
    m = max(a, b)
    n = min(a, b)
    if n == 0:
        return 0
    if m == n:
        return 1
    elif m % n == 0:
        return m // n
    k = m // n
    return k + solve(n, m - n * k)

for _ in range(int(input())):
    a, b = map(int, input().split())
    print(solve(a, b))",constant
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        A = []
        for i, num in enumerate(nums):
            A.append([num, i])

        A.sort()
        i, j = 0, len(nums) - 1
        while i < j:
            cur = A[i][0] + A[j][0]
            if cur == target:
                return [min(A[i][1], A[j][1]),
                        max(A[i][1], A[j][1])]
            elif cur < target:
                i += 1
            else:
                j -= 1
        return []",nlogn
"n,m,a,b=map(int, input().split())
print(min(n%m*b, (m-n%m)*a))",linear
"import sys
readline = sys.stdin.readline

def gcd(a, b):
    while b:
        a, b = b, a%b
    return a

def prsh(N):
    prime = [2]
    for L in range(3,N):
        for p in prime:
            if not L % p:
                break
            if p > L**(1/2):
                prime.append(L)
                break
    return prime
limit = 59
prime = prsh(limit+1)
C = set([tuple()])
Cp = []
for i in range(2, limit+1):
    if i >= 30 and i in prime:
        Cp.append(i)
        continue
    for k in C.copy():
        if all(gcd(ki, i) == 1 for ki in k):
            kn = tuple(list(k) + [i])
            C.add(kn)

INF = 10**9+7

N = int(readline())
A = list(map(int, readline().split()))
Ao = A[:]
A.sort()
ans = INF
Ans = None
for ci in C:
    tc = [1]*(N-len(ci)) + list(ci) + Cp
    for j in range(8):
        res = 0
        for a, t in zip(A, tc[j:]):
            res += abs(a-t)
        if ans > res:
            ans = res
            Ans = tc[j:j+N]
buc = [[] for _ in range(limit+1)]
for a, an in zip(A, Ans):
    buc[a].append(an)
AA = []
for ao in Ao:
    AA.append(buc[ao].pop())

print(*AA)",np
"def search(current, digits, target, idx, bulk):
    if len(current) == len(target) and int(current) <= int(target):
        print(current)
        exit(0)

    possibilities = [char for char in digits if bulk or (char <= target[idx] and char in digits)]

    if len(possibilities) == 0:
        return None

    for possible_digit in sorted(set(possibilities), reverse=True):
        tmp_digits = list(digits)
        tmp_digits.remove(possible_digit)
        if not bulk:
            bulk = True if possible_digit != target[idx] else False
        search(current + possible_digit, tmp_digits, target, idx + 1, bulk)

def main():
    digits = sorted(list(input()), reverse=True)
    target = input()

    if len(digits) < len(target):
        print(''.join(digits))
        exit(0)

    entries = [char for char in digits if char <= target[0]]

    for current in sorted(set(entries), reverse=True):
        tmp_digits = list(digits)
        tmp_digits.remove(current)
        search(current, tmp_digits, target, 1, True if current != target[0] else False)

if __name__ == ""__main__"":
    main()",cubic
"l,r=map(int,input().split())
j=r-l+1

if j==3:
	if l%2==0:
		print(l,l+1,l+2)
	else:
		print(-1)
elif j>3:
	if l%2==0:print(l,l+1,l+2)
	else:print(l+1,l+2,l+3)
else:print(-1)",constant
"n, k = map(int, raw_input().split())
a = map(int, raw_input().split())
for i in range(n):
    ai = a[i]
    nai = ((1<<k) - 1)^ai
    if nai < ai:
        a[i] = nai

from collections import Counter
C = Counter()
C[0] += 1
S = 0
cnt = 0
for j, ai in enumerate(a):
    nai = ((1<<k) - 1)^ai
    v1, v2 = C[S^ai], C[S^nai]
    if v1 <= v2:
        cnt += j + 1 - v1
        S ^= ai
        C[S] += 1
    else:
        cnt += j + 1 - v2
        S ^= nai
        C[S] += 1
print(cnt)",linear
"import math
def solve():
    words = input().split()
    people = int(words[0])
    planes_each = int(words[1])
    per = int(words[2])
    sheets = int(words[3])
    sheets_per_person = math.ceil(planes_each/per)
    needed = sheets_per_person*people
    packs = math.ceil(needed/sheets)
    print(packs)

solve()",constant
"n = int(input())
a = list(map(int, input().split()))

dp = [[505]*n for _ in range(n)]
Max = [[0]*n for _ in range(n)]

for i in range(n):
    dp[i][i] = 1
    Max[i][i] = a[i]

for len in range(1, n+1):
    for i in range(n-len+1):
        j = i + len - 1
        for k in range(i, j):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:
                dp[i][j] = 1
                Max[i][j] = Max[i][k] + 1
print(dp[0][n-1])",cubic
"n = int(input())
dis = list(map(lambda x: int(x) << 1, input().split()))
ter = input()
st, ans = 0, 0
time = {'G': 5, 'W': 3, 'L': 1}
delta = {'G':1, 'W':1, 'L':-1}
hasWater = False
convert = 0
for i in range(n):
	st += dis[i] * delta[ter[i]]
	ans += dis[i] * time[ter[i]]

	if ter[i] == 'W':
		hasWater = True
	elif ter[i] == 'G':
		convert += dis[i]
	if st < 0:
		if hasWater:
			ans += (-st) * 3
		else:
			ans += (-st) * 5
		st = 0
	convert = min(convert, st // 2)

ans -= 4 * convert
ans -= 2 * (st // 2 - convert)
print(ans // 2)",linear
"n , k = map(int, input().split())
l = list(map(int,input().split()))
l.sort()
a = 0
i = 0
while i<(n-1):
    j = i+1
    while j<n and l[j]==l[i]:
        j+=1
    if j==n:
        break
    else:
        if l[j]<=l[i]+k:
            a+=(j-i)
    i = j
print(n-a)",nlogn
"def read():
    return [c == '1' for c in input()]
n = int(input())
a, b = read(), read()

res = 0

i = 0
while i + 1 < n:
    if a[i] != b[i] and a[i] != a[i+1] and b[i] != b[i+1]:
        a[i] = b[i]
        a[i+1] = b[i+1]
        res += 1
        i += 2
    else:
        i += 1

for i in range(n):
    if a[i] != b[i]:
        res += 1

print(res)",linear
"class Solution:
    def reverseBits(self, n: int) -> int:
        res = n
        res = (res >> 16) | (res << 16) & 0xFFFFFFFF
        res = ((res & 0xff00ff00) >> 8) | ((res & 0x00ff00ff) << 8)
        res = ((res & 0xf0f0f0f0) >> 4) | ((res & 0x0f0f0f0f) << 4)
        res = ((res & 0xcccccccc) >> 2) | ((res & 0x33333333) << 2)
        res = ((res & 0xaaaaaaaa) >> 1) | ((res & 0x55555555) << 1)
        return res & 0xFFFFFFFF",constant
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,k=map(int, input().split())
kk=list(map(str, input()))
s=sorted(list(set(kk)))
if k > 13:
    print(-1)
else:
    dic={}
    for index, value in enumerate(""abcdefghijklmnopqrstuvwxyz""):
        dic[value]= index+1

    ans=0
    ans+=dic[s[0]]
    k-=1
    curr=s[0]
    for i in range(1,len(s)):
        if k:
            if dic[s[i]]>dic[curr]+1:
                ans+=dic[s[i]]
                curr=s[i]
                k-=1
            if k==0:
                break
    if k==0:
        print(ans)
    else:
        print(-1)",linear
"x = list(map(int, input().split()))

start = 0
end = x[0] -1

target = x[1]

ans = 0

while start<= end:

    mid = (start+end)//2
    sum = mid*(mid+1) //2

    ans1 = x[0] - mid

    if sum - ans1 == target:
        ans = ans1
        break
    elif sum - ans1 > target:
        end = mid - 1
    else:
        start = mid+1

print(ans)",logn
"from collections import defaultdict

n = int(raw_input())
t = defaultdict(list)
for _ in range(n - 1):
    u, v = map(int, raw_input().split())
    t[u].append(v)
    t[v].append(u)
a = list(map(int, raw_input().split()))
o = {a_: i for i, a_ in enumerate(a)}

i = 0
q = [1]
lv = {1: 0}
par = {1: 1}
while i < len(q):
    u = q[i]
    i += 1
    for v in t[u]:
        if v not in lv:
            lv[v] = lv[u] + 1
            q.append(v)
            par[v] = u

depths = defaultdict(list)
for x in a:
    depths[lv[x]].append(o[par[x]])

ans = a[0] == 1
if ans:
    for d in depths.values():
        if not all(d[i] <= d[i + 1] for i in range(len(d) - 1)):
            ans = False
            break

if ans:
    l = [lv[x] for x in a]
    ans = all(l[i] <= l[i + 1] for i in range(len(l) - 1))

print(('No', 'Yes')[ans])",linear
"def sum_from1(k):
      return (k*(k+1))//2
def sum_of_subtraction(p,k):
      if p<=1:
            return sum_from1(k)
      else:
            return sum_from1(k)-sum_from1(p-1)
n,k=map(int,input().split())
if n==1:
      print(0)
elif n<=k:
      print(1)
else:
      n-=1
      k-=1
      if n>sum_from1(k):
            print(-1)
      else:
            s=1
            e=k

            while s<e:
                  mid=(s+e)//2
                  r=sum_of_subtraction(mid,k)

                  if r==n:
                        print(k-mid+1)
                        break
                  elif r>n:
                        s=mid+1
                  else:
                        e=mid
            else:
                  print(k-s+2)",logn
"n,m,a,b=map(int,input().split())
z=(n%m)*b
x=((n//m+1)*m-n)*a
y=min(z,x)
print(y if y>0 else 0)",linear
"n,m=map(int,input().split())
listi=[]
for i in range(0,n):
    string=input()
    listi.append(string)
rownum=0
flag=False
for row in listi:

    for letter in row:
            if(""B"" in row):
                p=row.index(""B"")

                s=row[::-1]
                q=abs(m-s.index(""B"")-1)

                if(p==q):
                    print(rownum+1,row.index(row[p])+1)
                    flag=True
                    break
                mr=(q+p)/2

                length=abs(q-p+1)

                rn= rownum + length//2

                print(rn+1,int(mr+1))
                flag=True
                break

    if(flag==True):
        break

    rownum+=1",quadratic
"import sys, math, queue

MOD = 10**9+7
sys.setrecursionlimit(1000000)

def getMul(x):
    a = 1
    for xi in x:
        a *= xi
    return a

n = int(input())
a = list(map(int, input().split()))
d = {}
for ai in a:
    if ai in d: d[ai] += 1
    else: d[ai] = 1

f = [[] for i in range(max(a)+10)]
for i in range(1, len(f)):
    for j in range(i, len(f), i):
        f[j].append(i)

seq = [0 for i in range(max(a)+10)]
for ai in d:
    for fi in f[ai]:
        seq[fi] += d[ai]
for i in range(len(seq)):
    seq[i] = (pow(2, seq[i], MOD) -1 +MOD) % MOD

pf = [[] for i in range(max(a)+10)]
pf[0] = None
pf[1].append(1)
for i in range(2, len(f)):
    if len(pf[i]) == 0:
        for j in range(i, len(pf), i):
            pf[j].append(i)
for i in range(1, len(pf)):
    mul = getMul(pf[i])
    if mul == i:
        if len(pf[i])&1 == 1: pf[i] = -1
        else: pf[i] = 1
    else:
        pf[i] = 0
pf[1] = 1

ans = 0
for i in range(1, len(seq)):
    ans += seq[i]*pf[i]
    ans = (ans + MOD) % MOD
print(ans)",np
"import sys
input_file = sys.stdin
C = (10**9+7)
[n, q] = list(int(i) for i in input_file.readline().split())
temp = input_file.readline()
lst = []
for char in temp[:-1]:
    lst.append(int(char))

new_lst = [(0, 0)]
for i in lst:
    if i == 0:
        new_lst.append((new_lst[-1][0]+1, new_lst[-1][1]))
    else:
        new_lst.append((new_lst[-1][0], new_lst[-1][1]+1))

ls = [1]
for i in range(n):
    ls.append(ls[-1]*2 % C)

for line in input_file:
    [l, r] = list(int(i) for i in line[:-1].split())
    q = (new_lst[r][0] - new_lst[l-1][0], new_lst[r][1] - new_lst[l-1][1])
    print((ls[sum(q)] - ls[q[0]]) % C)",linear
"from heapq import heappush, heappop
n = int(input())
L = list(map(int, input().split()))
T = input()

ans = sum(L)

Q = []

for l, t in zip(L, T):
    if t == 'G':
        heappush(Q, (2, 2 * l))
        heappush(Q, (5, float('inf')))
    elif t == 'W':
        heappush(Q, (1, 2 * l))
        heappush(Q, (3, float('inf')))

    need_stamina = l
    while need_stamina > 0:
        cost, quantity = heappop(Q)
        if need_stamina > quantity:
            ans += quantity * cost
            need_stamina -= quantity
        else:
            ans += need_stamina * cost
            heappush(Q, (cost, quantity - need_stamina))
            need_stamina = 0

print(ans)",nlogn
"ceil1 = lambda a, b: (a + b - 1) // b
n = int(input())
sq = int(n ** .5)
sq2, ans, cur = ceil1(n, sq), [], 0

for i in range(sq2 - 1):
    cur += sq
    ans.extend([x for x in range(cur, cur - sq, -1)])

ans.extend([x for x in range(n, cur, -1)])
print(' '.join(map(str, ans)))",linear
"n=int(input())
l=list(map(int,input().split()))
m=l[:]
m.sort()
f=1
c=0
for i in range(n):
    if(l[i]!=m[i]):
        c+=1
    if(c>2):
        f=0
        break
if(f==0):
    print(""NO"")
else:
    print(""YES"")",nlogn
"x,k=map(int,input().split())
print(0 if x==0 else (x*pow(2,k+1,10**9+7)-pow(2,k,10**9+7)+1)%(10**9+7))",logn
"n=int(input())
m=int(input())
print(m%(pow(2,n)))",constant
"l = []
a, b = map(int, input().split())
l.append((a,b))
a, b = map(int, input().split())
l.append((a,b))
a, b = map(int, input().split())
l.append((a,b))
l.sort()
path = []
path.append(l[0])
x = l[0][0]
while(x<l[1][0]):
	path.append((x, l[0][1]))
	x = x + 1
up = False
if(l[0][1]<l[1][1]):

	up = True
if(up):
	y = l[0][1]
	while(y<=l[1][1]):
		path.append((l[1][0], y))
		y = y+1
else:
	y = l[0][1]
	while(y>=l[1][1]):
		path.append((l[1][0], y))
		y = y-1
up = False
if(l[1][1]<l[2][1]):
	up = True
if(up):
	y = l[1][1]
	while(y<=l[2][1]):
		path.append((l[1][0], y))
		y = y+1
else:
	y = l[1][1]
	while(y>=l[2][1]):
		path.append((l[1][0], y))
		y = y-1
x = l[1][0]
while(x<l[2][0]):
	path.append((x, l[2][1]))
	x = x + 1
path.append(l[2])
path = list(set(path))
print(len(path))
for i in range(len(path)):
	print(str(path[i][0])+"" ""+str(path[i][1]))",constant
"from math import gcd

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""right"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\right\n"")

def func(left:int, right:int):
    if left == 1:
        left += 1
    if right - left < 2:
        return -1

    if left & 1:
        if right - left > 2:
            left += 1
            return '{} {} {}'.format(left, left + 1, left + 2)
        else:
            if gcd(left, left + 2) != 1:
                return '{} {} {}'.format(left, left + 1, left + 2)
            return -1
    return '{} {} {}'.format(left, left + 1, left + 2)

def main():
    left, right = map(int, input().split())
    print(func(left, right))
    return

if __name__ == '__main__':
    main()",constant
"import math

n, d = [int(x) for x in input().split(' ')]
pos = [int(x) for x in input().split(' ')]

count = 2

for i in range(1,n):
	if math.fabs(pos[i] - pos[i-1]) > 2*d:
		count += 2
	elif math.fabs(pos[i] - pos[i-1]) == 2*d:
		count += 1
	else:
		continue;

print(count)",linear
"def whb(a,b,c,d):
    dim = (c-a+1)*(d-b+1)
    col1 = dim//2
    col2 = dim-col1
    if (a+b)%2==0:
        return [col2, col1]
    else:
        return [col1, col2]

def insegment(a, b, a1, b1):
    li = [[a,1], [b,1], [a1,2], [b1,2]]
    li.sort()
    if li[0][1] == li[1][1]:
        if li[1][0] == li[2][0]:
            return [li[1][0], li[2][0]]
        else:
            return -1
    else:
        return [li[1][0], li[2][0]]

def inrect(a,b,c,d,a1,b1,c1,d1):
    xra = insegment(a,c,a1,c1)
    yra = insegment(b,d,b1,d1)
    if xra==-1 or yra==-1:
        return -1
    else:
        return [xra[0], yra[0], xra[1], yra[1]]

q = int(input())
for quer in range(q):
    [n, m] = [int(i) for i in input().split()]
    [x1, y1, x2, y2] = [int(i) for i in input().split()]
    [x3, y3, x4, y4] = [int(i) for i in input().split()]
    [white, black] = whb(1,1,n,m)
    [w1, b1] = whb(x1, y1, x2, y2)
    [w2, b2] = whb(x3, y3, x4, y4)
    black+= w2-b1
    white+= b1-w2
    inter = inrect(x1, y1, x2, y2, x3, y3, x4, y4)
    if type(inter)==list:
        [w3, b3] = whb(inter[0], inter[1],inter[2], inter[3])
        black += b3
        white -= b3
    print(white, black)",constant
"import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

R,G,B=map(int,input().split())
r=sorted(list(map(int,input().split())))
g=sorted(list(map(int,input().split())))
b=sorted(list(map(int,input().split())))
dp=[[[0]*(B+1) for j in range(G+1)] for i in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k - 1] + g[j - 1] * b[k - 1])
print(dp[R][G][B])",cubic
"query = input().split()

n = int(query[0])
k = int(query[1])
import math

temp = 2* (k + n)

m = (-3 + math.sqrt(9 + 4*temp))/2

print(int(n-m))",logn
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,m = map(int,input().split())

A = [None]*n
lo,hi = 1<<32,-1<<32
for i in range(n):
    A[i] = list(map(int,input().split()))
    lo = min(min(A[i]), lo)
    hi = max(max(A[i]), hi)

best = -1
ans = [-1,-1]

def possible(x):
    global best, ans

    M = [-1]*(1<<m)

    for i in range(n):
        mask = 0
        for j in range(m):
            if A[i][j] >= x:
                mask += (1<<j)
        M[mask] = i

    for m0 in range(1<<m):
        if M[m0] == -1:
            continue

        for m1 in range(1<<m):
            if M[m1] == -1:
                continue

            if m0 | m1 == (1<<m) - 1:
                if best < x:
                    best = x
                    ans = [M[m0]+1, M[m1]+1]

                return True
    return False

possible(hi)
possible(lo)

while lo+1 < hi:
    mid = (lo+hi)//2
    if possible(mid):
        lo = mid
    else:
        hi = mid

print(*ans)",np
"a,b=map(int,input().split())
if b>=a-1:
    print(a-1)
else:
    summ=b
    k=a-b
    for i in range(2,k+1):
        summ+=i
    print(summ)",linear
"n , k = map(int , input().split())
lst = []
for i in range(n):
    p , t =  map(int , input().split())
    lst.append([p,-t])

tmp  = sorted(lst , key =lambda x : (x[0],x[-1]) , reverse = True)[k-1]
print(lst.count(tmp))",nlogn
"n = int(input())

d = {}

for i in range(n-1):
	a,b = map(int,input().split())

	try:
		d[a].append(b);
	except:
		d[a] = [b]
	try:
		d[b].append(a);
	except:
		d[b] = [a]

array = list(map(int,input().split()))
flag=0;

if array[0]==1:

	i = 1;
	j = 0;

	while ( j < n and i < n ):
		if ( array[j] in d[array[i]] ):
			i+=1;
		else:
			j+=1;
	if j==n and i!=n:
		flag=1;
else:
	flag=1;

if flag==1:
	print(""No"")
else:
	print(""Yes"")",linear
"from sys import stdin,stdout
from collections import Counter
nmbr=lambda:int(stdin.readline())
lst = lambda: list(map(int,stdin.readline().split()))
for _ in range(1):
    n,k=lst()
    a=lst()
    d={};r=l=-2
    for i in range(n):
        d[a[i]]=d.get(a[i],0)+1
        if len(d)==k:
            r=i
            break
    for i in range(r+1):
        if d[a[i]]==1:
            l=i
            break
        d[a[i]]-=1
    print(l+1,r+1)",linear
"class Solution:
    def climbStairs(self, n: int) -> int:

        def dfs(i):
            if i >= n:
                return i == n
            return dfs(i + 1) + dfs(i + 2)

        return dfs(0)",np
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
from decimal import Decimal
from fractions import Fraction

INF = float('inf')
mod = int(1e9)+7

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

@bootstrap
def recur(r,g,b):
    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:
        yield 0
        return
    if dp[r][g][b]:
        yield dp[r][g][b]
        return
    if r>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+(yield recur(r-1,g-1,b)))
    if r>0 and b>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+(yield recur(r-1,g,b-1)))
    if b>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+(yield recur(r,g-1,b-1)))
    yield dp[r][g][b]

r,g,b=mdata()
R=sorted(mdata())
G=sorted(mdata())
B=sorted(mdata())
dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]
out(recur(r,g,b))",cubic
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")
def seive():
    prime=[1 for i in range(10**6+1)]
    prime[0]=0
    prime[1]=0
    for i in range(10**6+1):
        if(prime[i]):
            for j in range(2*i,10**6+1,i):
                prime[j]=0
    return prime

a,b=L()
def rec(a,b):
    if b==1:
        return a
    if a>b:
        return a//b+rec(b,a%b)
    else:
        return rec(b,a)
print(rec(a,b))

endtime = time.time()",constant
"import os,io
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
n,m,k=map(int,input().split())
dist1=[]
for i in range(n):
  dist1.append(list(map(int,input().split())))
dist2=[]
for i in range(n-1):
  dist2.append(list(map(int,input().split())))
if k%2:
  print(' '.join(map(str,[-1]*(n*m))))
  exit()
k//=2
dp=[10**9]*((k+1)*n*m)
for i in range(n):
  for j in range(m):
    dp[i*m+j]=0
for t in range(k):
  r=(t+1)*n*m
  q=t*n*m
  for i in range(n):
    for j in range(m):
      if i<n-1:
        dp[r+(i+1)*m+j]=min(dp[r+(i+1)*m+j],dp[q+i*m+j]+2*dist2[i][j])
      if i>0:
        dp[r+(i-1)*m+j]=min(dp[r+(i-1)*m+j],dp[q+i*m+j]+2*dist2[i-1][j])
      if j<m-1:
        dp[r+i*m+j+1]=min(dp[r+i*m+j+1],dp[q+i*m+j]+2*dist1[i][j])
      if j>0:
        dp[r+i*m+j-1]=min(dp[r+i*m+j-1],dp[q+i*m+j]+2*dist1[i][j-1])
ans=[]
for i in range(n):
  for j in range(m):
    ans.append(dp[k*n*m+i*m+j])
print(' '.join(map(str,ans)))",cubic
"n=int(input())
l=sorted(list(map(int,raw_input().split())))
def f():
    global n
    dou=False
    for k in range(1,n):
        if l[k]==l[k-1]:
            if dou or l[k]==0 or (l[k]==l[k-2] and n!=2) or l[k]==l[k-2]+1:
                return False
            else:
                dou=True
    return (sum(l)-(n*(n-1))//2)%2
if f():
    print(""sjfnb"")
else:
    print(""cslnb"")",nlogn
"n = int(input())
if n==1:
    print(5)
else:
    print(25)",constant
"import math
def C(a, b):
	return math.factorial(a)//(math.factorial(b)*math.factorial(a-b))

a = list(input())
b = list(input())
x, y, d, ans, power = 0, 0, 0, 0, 0
for i in range(len(a)):
	if a[i] == '+':
		x += 1
	if a[i] == '-':
		x -= 1
	if b[i] == '?':
		d += 1
	if b[i] == '+':
		y += 1
	if b[i] == '-':
		y -= 1
plus, minus = d, 0
for i in range(0, d+1):
	k = C(d, plus)
	if y+(plus-minus) == x:
		ans += k
	power += k
	plus -= 1
	minus += 1
print(""{0:.12f}"".format(ans/power))",np
"def main():
    import sys
    import collections
    input = sys.stdin.readline
    n, m, K = map(int, input().split())

    A = [input().rstrip() for i in range(n)]

    B = [list(input().rstrip().split()) for i in range(m)]

    alpha = 'abcｄ'

    D = dict()
    for i, x in enumerate(A):
        D[x] = i

    G = [set() for i in range(n)]
    X = [set() for i in range(n)]

    for i in range(m):
        a, b = B[i]
        b = int(b)
        flag = False
        for j in range(2**K):
            x = []
            for k in range(K):
                if (j >> k) % 2 == 1:
                    x.append('_')
                else:
                    x.append(a[k])
            x = ''.join(x)
            if x in D:
                if D[x] == b-1:
                    flag = True
                    continue
                else:
                    G[b-1].add(D[x])
                    X[D[x]].add(b-1)
        if flag:
            continue
        else:
            print(""NO"")
            exit(0)
    X = [len(X[i]) for i in range(n)]
    ANS = []
    s = set()
    q = collections.deque()
    for i in range(n):
        if X[i] == 0:
            q.append(i)
            s.add(i)

    while(q):
        if len(ANS) == n:
            print(""NO"")
            exit(0)
        x = q.popleft()
        ANS.append(x+1)
        for y in G[x]:
            if X[y] == 0:
                continue
            else:
                X[y] -= 1
                if X[y] == 0:
                    q.append(y)
    if len(ANS) == n:
        print(""YES"")
        print(*ANS)
    else:
        print(""NO"")

main()",np
"import math;
def getIntList():
    return list(map(int, input().split()));
def getTransIntList(n):
    first=getIntList();
    m=len(first);
    result=[[0]*n for _ in range(m)];
    for i in range(m):
        result[i][0]=first[i];
    for j in range(1, n):
        curr=getIntList();
        for i in range(m):
            result[i][j]=curr[i];
    return result;
n, a, b = getIntList();
if a>1 and b>1:
    print('NO');
elif a==b==1 and (n==2 or n==3):
    print('NO');
else:
    c=max(a, b);
    m=[[0]*n for _ in range(n)];
    for i in range(n-c):
        m[i][i+1]=1;
        m[i+1][i]=1;
    if b>1:
        for i in range(n):
            for j in range(n):
                if i!=j:
                    m[i][j]=1-m[i][j];
    print('YES');
    for i in range(n):
        print(''.join(map(str, m[i])));",quadratic
"n=int(input())
if n>-1:
    print(n)
else:
    n=str(n)
    x=int(n[:len(n)-1])
    y=int(n[:len(n)-2]+n[-1])
    print(max(x,y))",constant
"n, pos, l, r = map(int,input().split())
step, dif = 0, lambda a, b : abs(a - b)

if dif(pos, l) < dif(pos, r):
	if l != 1:
		step += dif(pos, l) + 1
		pos = l
	if r != n:
		step += dif(pos, r) + 1
else:
	if r != n:
		step += dif(pos, r) + 1
		pos = r
	if l != 1:
		step += dif(pos, l) + 1
print(step)",constant
"import sys, string

n, k = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
arr.sort()
st = []
for i in arr:
    if not st:
        st.append(i)
    else:
        while st:
            if 0 < abs(st[-1] - i) <= k:
                st.pop()
            else:
                break
        st.append(i)
print(len(st))",nlogn
"k = int(input())

total_digit = 0
digit = 1

while k > total_digit + digit * (pow(10, digit) - pow(10, digit - 1)):
    total_digit += digit * (pow(10, digit) - pow(10, digit - 1))
    digit += 1

remaining = k - total_digit - 1
corr_num = str(pow(10, digit - 1) + remaining // digit)
print(corr_num[remaining % digit])",logn
"I = lambda: map(int, input().split())

n, l, r, x = I()
C, k = [*I()], 0

for i in range(2 ** n):
    W = [w for w, b in zip(C, bin(i)[2:].zfill(n)) if b == '1']
    if l <= sum(W) <= r and max(W) - min(W) >= x:
        k += 1

print(k)",np
"R,G,B = map(int,input().split())
r = sorted(list(map(int,input().split())), reverse=True)
g = sorted(list(map(int,input().split())), reverse=True)
b = sorted(list(map(int,input().split())), reverse=True)

dp = [[[0]*(B+1) for i in range(G+1)] for j in range(R+1)]
ans = 0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if j*k > 0:
                dp[i][j][k] = max(dp[i][j-1][k-1]+g[j-1]*b[k-1],dp[i][j][k])
            if i*k > 0:
                dp[i][j][k] = max(dp[i-1][j][k-1]+r[i-1]*b[k-1],dp[i][j][k])
            if i*j > 0:
                dp[i][j][k] = max(dp[i-1][j-1][k]+g[j-1]*r[i-1],dp[i][j][k])
            ans = max(ans,dp[i][j][k])
print(ans)",cubic
"actions, end_total_candies = [int(i) for i in input().split()]
candies = 1
if(actions == 1):
    print(0)
else:
    for i in range(1, actions):
        candies = candies + i + 1

        if(candies >= end_total_candies + (actions - i - 2)):
            print(candies - end_total_candies)
            exit()",logn
"from collections import defaultdict
from sys import stdin
input=stdin.readline
t=int(input())
for _ in range(t):
  n=int(input())
  a=list(map(int,input().split()))
  dd=defaultdict(int)
  for i in range(n):
    dd[a[i]]+=1
  l=[]
  for aa in a:
    if dd[aa]>=2:
      l.append(aa)
      dd[aa]-=2
  l.sort()
  ans=[-1,-1,-1,-1]
  m=10**18
  for i in range(len(l)-1):
    x=(4*(l[i]+l[i+1])**2)/(l[i]*l[i+1])
    if x<m:
      ans=[l[i],l[i],l[i+1],l[i+1]]
      m=x
  print(*ans)",nlogn
"try:
    n=int(input())
    x=list(map(int,input().split("" "")))
    x=set(x)
    x=list(x)
    x.sort()
    if len(x)!=1:
        print(x[1])
    else:
        print(""NO"")

except:
    pass",nlogn
"n = int(input())
ans = [(0, 0)]
for i in range(1, n):
    ans.append((0, i))
    ans.append((i, 0))
    ans.append((0, -i))
    ans.append((-i, 0))
for i in range(n):
    print(str(ans[i][0]) + ' ' + str(ans[i][1]))",linear
"a , b = list(map(int, input().split()))
x, y, z = list(map(int, input().split()))
ans = 0
p = a - ((x*2) + y)
q = b - ((z*3) + y)

if (p < 0 and q < 0):
    print(abs(p) + abs(q))
elif (p < 0):
    print(abs(p))
elif (q < 0):
    print(abs(q))
else:
    print(0)",constant
"n, m = map(int, input().split())

top = [-1, -1]
bottom = [-1, -1]

for i in range(n):
    s = input()
    left = s.find('B')
    if left != -1:
        right = s.rfind('B')
        c = (right - left) // 2 + 1
        print(i + c, left + c)
        break",quadratic
"def substraction(a,b):
    if a==0 or b==0:
        return 0
    else:
        if a>b:
            count=a//b
            return substraction(a%b,b)+count
        else:
            count = b//a
            return substraction(a,b%a)+count

t=int(input())
lst=[]
res=[]
for i in range(0,t):
    lst=[int(i) for i in input().split()]
    ele=substraction(lst[0],lst[1])
    res.append(ele)

for i in range(0,t):
    print(res[i])",constant
"def main():
    n = int(input())
    V = []
    for i in range(n):
        x,w = map(int,input().split())
        V.append((x-w,x+w))
    V.sort(key=lambda x: x[1])
    ans = 1
    now = V[0]
    for i in range(1,n):
        if V[i][0] >= now[1]:
            now = V[i]
            ans += 1
    print(ans)

if __name__ == ""__main__"":
    main()",nlogn
"n = int(input())
arr = list(map(int, input().split()))
pal = 1 if arr[1] > arr[0] else 3 if arr[0] == arr[1] else 5
b = True
arr_pal = [pal]
for i in range(n - 2):
    if arr[i + 1] > arr[i]:
        if pal == 5:
            b = False
            break
        if arr[i + 2] < arr[i + 1]:
            pal = 5
            arr_pal.append(pal)
        else:
            pal += 1
            arr_pal.append(pal)
    elif arr[i + 1] < arr[i]:
        if pal == 1:
            b = False
            break
        if arr[i + 2] > arr[i + 1]:
            pal = 1
            arr_pal.append(pal)
        else:
            pal -= 1
            arr_pal.append(pal)
    else:
        if arr[i + 2] > arr[i + 1]:
            pal = 2 if pal == 1 else 1
            arr_pal.append(pal)
        elif arr[i + 2] < arr[i + 1]:
            pal = 4 if pal == 5 else 5
            arr_pal.append(pal)
        else:
            pal = 4 if pal < 4 else 3
            arr_pal.append(pal)
if arr[-2] < arr[-1]:
    if pal == 5:
        b = False
    else:
        pal += 1
        arr_pal.append(pal)
elif arr[-2] > arr[-1]:
    if pal == 1:
        b = False
    else:
        pal -= 1
        arr_pal.append(pal)
else:
    pal = 3 if pal == 5 else 5
    arr_pal.append(pal)
if b:
    print(*arr_pal)
else:
    print(-1)",linear
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
def ctd(chr): return ord(chr)-ord(""a"")
mod = 998244353
INF = float('inf')

p, u = ""Petr"", ""Um_nik""

def main():
    n = N()
    arr = RLL()
    vis = [0]*(n+1)
    dic = {v: i+1 for i, v in enumerate(arr)}

    sm = 0
    for i in range(1, n+1):
        if vis[i]==0:
            now = i
            vis[now] = 1

            while dic[now]!=i:
                sm+=1
                now = dic[now]
                vis[now] = 1
    if (3*n-sm)%2==0:
        print(p)
    else:
        print(u)

if __name__ == ""__main__"":
    main()",nlogn
"MOD = int(1e9+9)

def fast_power(x, y):
    res = 1
    while y > 0:
        if y % 2 == 1:
            res = res * x%MOD
        x = x * x % MOD
        y //= 2
    return res

n, m, k = map(int, input().split())
x = max(0, m - n // k * (k - 1) - n % k)
z = (m - x * k) % MOD
res = fast_power(2, x+1)
res = (res - 2) % MOD * k % MOD
res = (res + z) % MOD
print(res)",logn
"from sys import stdin,stdout
input=stdin.readline
for _ in range(int(input())):
    x=10**5
    n,k=map(int,input().split())
    s=input()
    a=10**9
    ans=[[0]*n for i in range(3)]
    curr=['R','G','B']
    for l in range(3):
        z=l
        for j in range(n):
            if s[j]!=curr[z]:
                ans[l][j]=1
            z+=1
            z%=3
    for i in range(3):
        ans[i]=[0]+ans[i]
    for l in range(3):
        z=l
        for j in range(1,n+1):
            ans[l][j]+=ans[l][j-1]
    for l in range(3):
        for j in range(1,n-k+2):
            a=min(a,ans[l][j+k-1]-ans[l][j-1])

    print(a)",linear
"MOD = 1000000007
def fast_power(base, power):
    result = 1
    while power > 0:
        if power % 2 == 1:
            result = (result * base) % MOD

        power = power // 2
        base = (base * base) % MOD

    return result

x, k = map(int, input().split())

if x == 0 or k == 0:
    print((x * 2) % MOD)
else:
    d = ((x * 4) - 1) - (x * 2)
    print(((x * 2) + (d * (fast_power(2, k) - 1))) % MOD)",logn
"class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [0] * n

        for i in range(n):
            prod = 1
            for j in range(n):
                if i == j:
                    continue
                prod *= nums[j]

            res[i] = prod
        return res",quadratic
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []

    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)
    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)

    return powerset_orderred
def fastPlrintNextLines(a):

    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")

def solve():
    n,k = li()
    l = [['.' for i in range(n)] for j in range(4)]
    print(""YES"")
    if k%2==0:
        for i in range(1,k//2+1):
            l[1][i]='
            l[2][i]='
    else:
        if (k>n-2):

            for i in range(1,n-1):
                l[1][i]='
            k-=(n-2)
        if k>0:
            i = n//2
            if k%2==1:
                l[2][i]='
                k-=1
            i = n//2+1
            for i in range(n//2+1,n//2+1+k//2):
                l[2][i]='
            k = k//2
            for i in range(n//2-1,-1,-1):
                if k==0:
                    break
                k-=1
                l[2][i]='
    for i in l:
        print(''.join(i))

t = 1

for _ in range(t):
    solve()",linear
"import os
import sys
from io import BytesIO, IOBase
import threading
from bisect import bisect_right
from math import gcd,log
from collections import Counter,defaultdict,deque
from pprint import pprint
from itertools import permutations
from bisect import bisect_right
from random import randint as rti

n,m=0,0

def main(tnum):
    global n,m,d
    n,m,k=map(int,input().split())
    if k%2:
        ans=[[-1]*m for i in range(n)]
        for li in ans:
            print(*li)
        return
    cost=dict()
    dp=[[float('inf')]*m for i in range(n)]
    crr=[]
    rrr=[]
    for i in range(n):
        arr=list(map(int,input().split()))
        for j in range(m-1):
            dp[i][j]=min(dp[i][j],arr[j])
            dp[i][j+1]=min(dp[i][j+1],arr[j])
        crr.append(arr)

    for i in range(n-1):
        arr=list(map(int,input().split()))
        for j in range(m):
            dp[i][j]=min(dp[i][j],arr[j])
            dp[i+1][j]=min(dp[i+1][j],arr[j])

        rrr.append(arr)

    for i in range(1,k//2):
        ndp=[[float('inf')]*m for i in range(n)]
        for i in range(n):
            for j in range(m):
                x,y=i,j
                if x>0:
                    ndp[i][j]=min(ndp[i][j],dp[x-1][y]+rrr[x-1][y])
                if x<n-1:
                    ndp[i][j]=min(ndp[i][j],dp[x+1][y]+rrr[x][y])
                if y>0:
                    ndp[i][j]=min(ndp[i][j],dp[x][y-1]+crr[x][y-1])
                if y<m-1:
                    ndp[i][j]=min(ndp[i][j],dp[x][y+1]+crr[x][y])
        dp=ndp
    for li in dp:
        li=[2*x for x in li]
        print(*li)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":

    for _ in range(1):
        main(_+1)",cubic
"import sys
from collections import defaultdict

readline=sys.stdin.readline

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N,Q=map(int,readline().split())
P=Prime(5*10**5)
mebius=[0]+[P.Mebius(i) for i in range(1,5*10**5+1)]
cnt=[0]*(5*10**5+1)
ans=0
A=list(map(int,readline().split()))
used=[False]*(N)
for _ in range(Q):
    q=int(readline())-1
    prime=list(P.Factorize(A[q]).keys())
    l=len(prime)
    for bit in range(1<<l):
        s=1
        for i in range(l):
            if bit>>i&1:
                s*=prime[i]
        if used[q]:
            cnt[s]-=1
            ans-=cnt[s]*mebius[s]
        else:
            ans+=cnt[s]*mebius[s]
            cnt[s]+=1
    if used[q]:
        used[q]=False
    else:
        used[q]=True
    print(ans)",np
"import sys
from math import floor

if __name__ == '__main__':

    entrada = input()
    entrada_str = list(entrada.split("" ""))
    entrada_int = list(map(int, entrada_str))

    a = entrada_int[0]
    b = entrada_int[1]

    if a == b:
        print(0)
        sys.exit()

    string_1 = """"
    string_2 = """"
    while a:
        if a%2 == 0:
            string_1 = string_1 + ""0""
        else:
            string_1 = string_1 + ""1""
        a = floor(a/2)

    while b:
        if b%2 == 0:
            string_2 = string_2 + ""0""
        else:
            string_2 = string_2 + ""1""
        b = floor(b/2)

    lista_1 = list(string_1)
    lista_1.reverse()
    contrario_1 = """".join(lista_1)

    lista_2 = list(string_2)
    lista_2.reverse()
    contrario_2 = """".join(lista_2)

    if len(string_1) != len(string_2):
        resposta = pow(2, len(string_2)) - 1
    else:
        potencia = 0
        for i in range(len(string_1)):
            if contrario_1[i] != contrario_2[i]:
                break
            potencia += 1

        potencia = len(string_1) - potencia
        resposta = pow(2, potencia)-1

    print(resposta)",logn
"n,k=map(int,input().split())
s=[["".""]*n for i in range(4)]
if k%2==0:
  for j in range(1,n-1):
    if k==0:
      break
    s[1][j]=""
    s[2][j]=""
    k-=2
else:
  cen=n//2
  s[1][cen]=""
  k-=1
  for i in range(1,3):
    for j in range(1,cen):
      if k>0:
        k-=2
        s[i][j]=s[i][-j-1]=""
if k==0:
  print(""YES"")
  for i in range(4):
    print("""".join(s[i]))
else:
  print(""NO"")",linear
"import sys
input = sys.stdin.readline
from itertools import accumulate
import copy

n,m,k = map(int,input().split())
A = list(map(int,input().split()))
ANS = 0

for i in range(m):
    B = copy.deepcopy(A)

    for j in range(i,n,m):
        B[j] -= k

    SUM = list(accumulate(B))
    SUMMIN = [float(""inf"")]*n +[0]

    if i==0:
        SUMMIN[0] = 0

    for j in range(max(1,i),n):
        if j % m == i % m:
            SUMMIN[j] = min(SUMMIN[j-1],SUM[j-1])
        else:
            SUMMIN[j] = SUMMIN[j-1]

    for j in range(i,n):
        ANS = max(ANS,SUM[j] - SUMMIN[j])

print(ANS)",quadratic
"n = int(input())
if n==0:
    print(0)
elif n%2==1:
    print((n+1)//2)
else:
    print(n+1)",constant
"from sys import stdin,stdout
import sys

n=int(stdin.readline().strip())
arr=list(map(int,stdin.readline().strip().split(' ')))

dp_arr=[[None for i in range(n)] for i in range(n)]

for i in range(n):
	dp_arr[i][i]=(arr[i],1,arr[i])

def merge_small(c1,c2):
	if c1[1]==1 and c2[1]==1:
		if c1[0]==c2[0]:
			return (c1[0]+1,1,c1[0]+1)
		else:
			return (c1[0],2,c2[0])
	elif c1[1]==2 and c2[1]==1:
		if c1[2]==c2[0]:
			if c1[0]==c1[2]+1:
				return (c1[0]+1,1,c1[0]+1)
			else:
				return (c1[0],2,c2[2]+1)
		else:
			return (c1[0],3,c2[2])

	elif c1[1]==1 and c2[1]==2:
		if c1[2]==c2[0]:
			if c2[2]==c2[0]+1:
				return (c2[2]+1,1,c2[2]+1)
			else:
				return (c2[0]+1,2,c2[2])
		else:
			return(c1[0],3,c2[2])

	elif c1[1]==2 and c2[1]==2:
		if c1[2]==c2[0]:
			c1=(c1[0],2,c1[2]+1)
			c2=(c2[2],1,c2[2])
			if c1[1]==2 and c2[1]==1:
				if c1[2]==c2[0]:
					if c1[0]==c1[2]+1:
						return (c1[0]+1,1,c1[0]+1)
					else:
						return (c1[0],2,c2[2]+1)
				else:
					return (c1[0],3,c2[2])
		else:
			return (c1[0],4,c2[2])

def merge_main(c1,c2):

	if c1[1]>2:
		if c2[1]>2:
			if c1[2]==c2[0]:
				return (c1[0],c1[1]+c2[1]-1,c2[2])
			else:
				return (c1[0],c1[1]+c2[1],c2[2])
		else:
			if c2[1]==1:
				if c1[2]==c2[0]:
					return (c1[0],c1[1],c2[2]+1)
				else:
					return (c1[0],c1[1]+1,c2[2])
			if c2[1]==2:
				if c1[2]==c2[0]:
					if c1[2]+1==c2[2]:
						return (c1[0],c1[1],c2[2]+1)
					else:
						return (c1[0],c1[1]+1,c2[2])
				else:
					return (c1[0],c1[1]+2,c2[2])
	else:
		if c2[1]>2:
			if c1[1]==1:
				if c1[2]==c2[0]:
					return (c1[2]+1,c2[1],c2[2])
				else:
					return (c1[2],c2[1]+1,c2[2])

			if c1[1]==2:
				if c1[2]==c2[0]:
					if c1[0]==c1[2]+1:
						return (c1[0]+1,c2[1],c2[2])
					else:
						return (c1[0],c2[1]+1,c2[2])
				else:
					return (c1[0],c2[1]+2,c2[2])
		else:

			return merge_small(c1,c2)

for i1 in range(1,n):
	for j1 in range(n-i1):
		curr_pos=(j1,j1+i1)

		for k1 in range(j1,j1+i1):

			res=merge_main(dp_arr[j1][k1],dp_arr[k1+1][j1+i1])

			if dp_arr[j1][j1+i1]==None or dp_arr[j1][j1+i1][1]>res[1]:
				dp_arr[j1][j1+i1]=res

stdout.write(str(dp_arr[0][n-1][1])+""\n"")",cubic
"n,m=map(int, input().split())
out=[n]
i=n-1
m-=1
for _ in range(n-1):
    if m%2:
        out.append(i)
    else:
        out=[i]+out

    m//=2
    i-=1

for i in out:
    print(i, end="" "")
print()",np
"n = int(input())
a = list(map(int, input()))
b = list(map(int, input()))

ans = sum(q != w for q, w in zip(a, b))
i = 1
while i < n:
    aii = a[i - 1]
    ai = a[i]
    bii = b[i - 1]
    bi = b[i]
    if aii + ai == 1 and bii + bi == 1 and aii != bii and ai != bi:
        ans -= 1
        i += 1
    i += 1

print(ans)",linear
"import sys
input = sys.stdin.readline

a,b,c = list(map(int,input().split()))

x = list(map(int,input().split()))
y = list(map(int,input().split()))
z = list(map(int,input().split()))

x.sort(reverse=True)
y.sort(reverse=True)
z.sort(reverse=True)

a+=1
b+=1
c+=1

x = [0] + x
y = [0] + y
z = [0] + z

tmp = [[0]*c for _ in range(b)]
best = [tmp for _ in range(a)]

ans = 0

for i in range(a):
    for j in range(b):
        for k in range(c):
            if (i+j+k) % 2 == 0:
                aa,bb,cc = 0,0,0
                if i>0 and j>0:
                    aa = best[i-1][j-1][k] + x[i] * y[j]
                if i>0 and k>0:
                    bb = best[i-1][j][k-1] + x[i] * z[k]
                if j>0 and k>0:
                    cc = best[i][j-1][k-1] + y[j] * z[k]

                best[i][j][k] = max(aa,bb,cc)
                ans = max(ans, best[i][j][k])

print(ans)",cubic
"import math
import sys

DEBUG = False

def inp():
    return sys.stdin.readline().rstrip()

def dprint(*value, sep=' ', end='\n'):
    if DEBUG:
        print(*value, sep=sep, end=end)

def solve(N):
    ans = []

    end = N
    fac = 1

    while end >= 1:
        if end == 1:
            ans.append(fac)
            end = 0
            break

        if end == 2:
            ans.append(fac)
            ans.append(fac * 2)
            end = 0
            break

        if end == 3:
            ans.append(fac)
            ans.append(fac)
            ans.append(fac * 3)
            end = 0
            break

        ans.extend([fac] * ((end + 1) // 2))
        end //= 2
        fac *= 2

    return ans

def main():
    N = int(inp())
    print(*solve(N))

if __name__ == '__main__':
    main()",nlogn
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping
from itertools import groupby as gb
from fractions import Fraction as fr

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,m,a,b=map(int,input().split())
if n%m:
    ul=(n//m)+1
    ll=n//m
    print(min(((ul*m)-n)*a, (n-(ll*m))*b))
else:
    print(0)",linear
"n = int(input())
A = list(map(int, input().split()))

dp = [[1 for j in range(5)] for i in range(n)]
Prev = [[-1 for i in range(5)] for i in range(n)]

for i in range(1, n):
    for j in range(5):
        for finger in range(5):
            if dp[i - 1][finger] == 1:
                if (A[i - 1] < A[i] and finger < j) or (A[i - 1] > A[i] and finger > j) or (A[i - 1] == A[i] and finger != j):
                    dp[i][j] = 1
                    Prev[i][j] = finger
                    break
        else:
            dp[i][j] = 0
finger = 0
for j in range(5):
    if dp[-1][j] == 1:
        finger = j
        path = [finger]
        for i in range(n - 1, 0, -1):
            finger = Prev[i][finger]
            path.append(finger)
        path = path[::-1]
        for i in range(n):
            print(path[i] + 1, end=' ')
        break
else:
    print(-1)",quadratic
"n = [int(x) for x in input().split()]
a = []
for i in range(3):
	a.append([int(x) for x in input().split()])
	a[i].sort(reverse=True)

dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]
ans = 0
for i in range(n[0] + 1):
	for j in range(n[1] + 1):
		for k in range(n[2] + 1):
			if i < n[0] and j < n[1]:
				dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
			if i < n[0] and k < n[2]:
				dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
			if j < n[1] and k < n[2]:
				dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
			ans = max(ans, dp[i][j][k])

print(ans )",cubic
"from itertools import combinations

def findsum(comb):
    sum = 0
    for song in comb:
        sum += song[0]
    return sum

def finda(a,b,c):
    if a == 0:
        return 0
    if a == 1 and b == 0 and c == 0:
        return 1
    else:
        return (a * findb(a-1,b,c)+ a*findc(a-1,b,c))

def findb(a,b,c):
    if b == 0:
        return 0
    if b == 1 and a == 0 and c == 0:
        return 1
    else:
        return (b * finda(a,b-1,c)+ b*findc(a,b-1,c))

def findc(a,b,c):
    if c == 0:
        return 0
    if c == 1 and a == 0 and b == 0:
        return 1
    else:
        return (c * finda(a,b,c-1)+ c*findb(a,b,c-1))

n, T = map(int,input().split())
songs = []
total_combinations = 0
for i in range(n):
    t, g = map(int,input().split())
    songs.append([t,g])

for i in range(1, n+1):
    allcomb = list(combinations(songs,i))
    for comb in allcomb:
        sum = findsum(comb)

        if sum == T:
            a = 0
            b = 0
            c = 0
            for song in comb:
                if song[1] == 1:
                    a += 1
                elif song[1] == 2:
                    b += 1
                else:
                    c += 1
            total_combinations += finda(a,b,c)+findb(a,b,c)+findc(a,b,c)
total_combinations = total_combinations%1000000007
print(total_combinations)",np
"n,m,k=list(map(int,input().split()))
p=[]
for _ in range(n):
    p.append(list(map(int,input().split())))
q=[]
for _ in range(n-1):
    q.append(list(map(int,input().split())))
def f(g):
    r=[[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            l=[]
            if i-1>=0:
                l.append(g[i-1][j]+q[i-1][j])
            if i+1<n:

                l.append(g[i+1][j]+q[i][j])
            if j-1>=0:
                l.append(g[i][j-1]+p[i][j-1])
            if j+1<m:
                l.append(g[i][j+1]+p[i][j])
            r[i][j]=min(l)
    return r
g=[[0]*m for _ in range(n)]
if k%2!=0:
    for i in range(n):
        for j in range(m):
            g[i][j]=-1
        print(*g[i])
else:
    for _ in range(k//2):
       g=f(g)
    for i in range(n):
        for j in range(m):
            g[i][j]*=2
        print(*g[i])",cubic
"def prefix_func(s):
    slen, k = len(s), 0
    p = [0]*slen
    p[0] = 0
    for i in range(1, slen):
        while k>0 and s[k] != s[i]:
            k = p[k-1]
        if s[k] == s[i]:
            k += 1
        p[i] = k
    return p
n,k=map(int,input().split())
s=input()
l=prefix_func(s)[-1]
print(s+s[l:]*(k-1))",quadratic
"class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        left = self.height(root.left)
        right = self.height(root.right)
        if abs(left - right) > 1:
            return False
        return self.isBalanced(root.left) and self.isBalanced(root.right)

    def height(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        return 1 + max(self.height(root.left), self.height(root.right))",quadratic
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort

from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal

INF = 10001
mod = int(1e9) + 7

def cal(l,r):
    if l==r:
        dp1[l][r]=a[l]
        dp3[l][r] = 1
        return dp1[l][r]
    if dp1[l][r]!=-1:
        return dp1[l][r]
    for i in range(l,r):
        if cal(l,i) == cal(i+1,r) != 0:
            dp1[l][r]=dp1[l][i]+1
            dp3[l][r]=1
        dp3[l][r]=min(dp3[l][r],dp3[l][i]+dp3[i+1][r])
    if dp1[l][r] == -1:
        dp1[l][r] = 0
    return dp1[l][r]

n=int(data())
a=mdata()
ans=[n]
dp1=[[-1]*n for i in range(n)]
dp3=[[10001]*n for i in range(n)]
cal(0,n-1)
out(dp3[0][n-1])",cubic
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:
    def __init__(self):
        n, m = map(int, input().strip().split())
        segs = list()
        for i in range(m):
            segs.append(list(map(int, input().strip().split())))

        def calc(s, segs):
            res = 0
            for x in segs:
                ones = sum(s[x[0]:x[1] + 1])
                res += ones * (x[1] - x[0] + 1 - ones)
            return res

        s1 = [0 for i in range(n)]
        s2 = [1 for i in range(n)]
        for i in range(n):
            if i % 2 == 0:
                s1[i] = 1
                s2[i] = 0

        ans = s1 if calc(s1, segs) > calc(s2, segs) else s2
        print(''.join(map(str, ans)))

solver()",linear
"n = int(input())
a = list(map(int, input().split()))
dp = [ [False,False,False,False,False] for _ in range(n) ]
dp[0] = [True, True, True, True, True]
for i in range(1, n):
	for j in range(5):
		if a[i] == a[i - 1]:
			for k in range(5):
				if k != j:
					dp[i][j] = dp[i][j] or dp[i - 1][k]
		elif a[i] > a[i - 1]:
			for k in range(j):
				dp[i][j] = dp[i][j] or dp[i - 1][k]
		else:
			for k in range(j + 1, 5):
				dp[i][j] = dp[i][j] or dp[i - 1][k]
if dp[-1].count(True) == 0:
	print(-1)
	exit(0)
j = 0
for k in range(5):
	if dp[-1][k]:
		j = k
ans = []
for i in range(n - 1, -1, -1):
	ans.append(j + 1)
	if i == 0:
		break
	if a[i] == a[i - 1]:
		for k in range(5):
			if k != j and dp[i - 1][k]:
				j = k
				break
	elif a[i] > a[i - 1]:
		for k in range(j):
			if dp[i - 1][k]:
				j = k
				break
	else:
		for k in range(j + 1, 5):
			if dp[i - 1][k]:
				j = k
				break
print(*ans[::-1])",quadratic
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort

from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal

INF = 10001
mod = int(1e9) + 7

n=int(data())
a=mdata()
ans=[n]
dp1=[[0]*n for i in range(n)]
dp2=[[n]*n for i in range(n)]
for i in range(n-1,-1,-1):
    dp1[i][i]=a[i]
    dp2[i][i]=1
    for j in range(i+1,n):
        for k in range(i,j):
            if dp1[i][k] == dp1[k+1][j] != 0:
                dp1[i][j] = dp1[i][k] + 1
                dp2[i][j] = 1
            dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + 1][j])
out(dp2[0][n-1])",cubic
"n = int(input())
a = [int(x) for x in input().split()]

a_reverse = a.copy()
status = []
for i in range(n):
    a_reverse[a[i]-1] = i
    status.append(None)

pos = a_reverse[n-1]
status[pos] = False
fails = set()
fails.add(pos)
for i in range(n-1,0,-1):
    i_ = i-1
    pos = a_reverse[i_]
    for k in range((pos+1)%i-1,n,i):
        if k == pos:
            continue
        if k in fails:
            status[pos] = True
            break
    if not status[pos]:
        status[pos] = False
        fails.add(pos)

for i in status:
    if i == True:
        result=result+""A""
    else:
        result=result+""B""

print(result)",quadratic
"def digit_sum(n):
	cnt = 0
	while n:
		cnt += n % 10
		n //= 10
	return cnt

def bsearch(low, high, s):
	h = high
	ans = -1
	while low <= high:
		mid = (low + high) // 2
		if mid - digit_sum(mid) >= s:
			ans = mid
			high = mid - 1
		else:
			low = mid + 1
	if ans == -1:
		return 0
	else:
		return h - ans + 1

n, s = map(int, input().split())
st = 1
end = 10
cnt = 0
cnt += (bsearch(1, n, s))
print(cnt)",logn
"mod = 1000000000+7
def fp(x ,y):
    if y == 1:
        return x
    if y == 0:
        return 1
    t = fp(x,y//2)%mod
    if y%2 == 1:
        return (t*t*x)%mod
    else:
        return (t*t)%mod

def inv(x):
    return fp(x%mod,mod-2)%mod

n,k=list(map(int,input().split()))
if not n:
    print(0)
    exit()
if not k:
    print( (2*n)%mod )
    exit()
numberOfPro =fp(2,k)
last = n*numberOfPro
first = (n-1)*numberOfPro+1
sumOfLast = (last)*(last+1)*inv(2)
sumOfFirst = first*(first-1)*inv(2)
num = 2*(sumOfLast - sumOfFirst)*inv(numberOfPro)
print(num%mod)",logn
"from math import ceil, log
from heapq import heappop, heappush, heapify
t = 1
for test in range(t):
    n,k = map(int, input().split())
    p = list(map(int, input().split()))
    c = list(map(int, input().split()))
    arr = [i for i in sorted(enumerate(p), key=lambda x:x[1])]
    maxcoins = [0 for i in range(k)]
    heapify(maxcoins)
    ans = list(p)
    tmpSum = 0
    tmpSum2 = 0
    prev = arr[0][1]
    for ind, power in arr:
        if power>prev:
            ans[ind] = tmpSum+c[ind]
            tmpSum2 = tmpSum
        else:
            ans[ind] = tmpSum2+c[ind]
        heappush(maxcoins, c[ind])
        tmpSum+=c[ind]
        tmpSum-=heappop(maxcoins)
    print(*ans)",nlogn
"MAX=10**9
def main():

    n,m=readIntArr()
    arrs=[]
    for _ in range(n):
        arrs.append(readIntArr())

    def checkPossible(minB):
        binRepresentations=set()
        for arr in arrs:
            binRepresentations.add(convertToBinary(arr,minB))
        binList=list(binRepresentations)
        ii=jj=-1
        n=len(binList)
        for i in range(n):
            for j in range(i,n):
                if binList[i]|binList[j]==(1<<m)-1:
                    ii=binList[i]
                    jj=binList[j]
        if ii!=-1:
            ansi=ansj=-1
            for i in range(len(arrs)):
                b=convertToBinary(arrs[i],minB)
                if b==ii:
                    ansi=i
                if b==jj:
                    ansj=i

            return (ansi,ansj)
        else:
            return None

    def convertToBinary(arr,minB):
        b=0
        for i in range(m):
            if arr[i]>=minB:
                b|=(1<<i)
        return b

    minB=-1
    i=j=-1
    b=MAX
    while b>0:
        temp=checkPossible(minB+b)
        if temp==None:
            b//=2
        else:
            minB+=b
            i,j=temp
    i+=1;j+=1
    print('{} {}'.format(i,j))

    return

import sys
input=sys.stdin.buffer.readline

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))

def readIntArr():
    return [int(x) for x in input().split()]

def makeArr(*args):

    assert len(args) >= 2, ""makeArr args should be (default value, dimension 1, dimension 2,...""
    if len(args) == 2:
        return [args[0] for _ in range(args[1])]
    else:
        return [makeArr(args[0],*args[2:]) for _ in range(args[1])]

def queryInteractive(x,y):
    print('? {} {}'.format(x,y))
    sys.stdout.flush()
    return int(input())

def answerInteractive(ans):
    print('! {}'.format(ans))
    sys.stdout.flush()

inf=float('inf')
MOD=10**9+7

for _abc in range(1):
    main()",np
"import sys, heapq

n, k = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
q = []
for i in range(n):
    heapq.heappush(q, (-arr[i], i))
res = []
temp_k = k
while temp_k:
    val, idx = heapq.heappop(q)
    res.append((-val, idx))
    temp_k -= 1
res.sort(key=lambda x : x[1])
ans = 0
for i in res:
    ans += i[0]
path = []
cnt = 0
for i in range(n):
    if (arr[i], i) in res:
        path.append(cnt + 1)
        cnt = 0
    else:
        cnt += 1
path[-1] += n - sum(path)
print(ans)
print(' '.join(map(str, path)))",nlogn
"n, m = map(int, input().split())

s = [""""] * n
for i in range(n):
    s[i] = input()

for i in range(n):
    for j in range(m):
        if s[i][j] == 'B':
            cnt = 1
            for k in range(j + 1, m):
                if s[i][k] == 'B':
                    cnt += 1
                else:
                    break

            print(i + 1 + cnt // 2, j + 1 + cnt // 2)
            exit(0)",quadratic
"from collections import namedtuple
n = int(input())
vertex = namedtuple('vertex', ['degree', 'id'])
a, b, c = [], [], 0

rr = list(map(int, input().split()))

for i in range(n):
    tmp = rr[i]
    v = vertex(tmp, i + 1)
    if tmp > 1:
        a.append(v)
    else:
        b.append(v)
    c += tmp

if c < (n - 1)*2:
    print('NO')
else:
    if len(a) == 0:
        print('YES 1')
        print('1 2')
    else:
        print('YES', len(a) - 1 + min(2, len(b)))
        print(n - 1)
        for i in range(len(a)):
            if i == 0:
                continue
            print(a[i - 1].id, a[i].id)
        if len(b) > 0:
            print(b[0].id, a[0].id)
        if len(b) > 1:
            print(b[1].id, a[-1].id)
        j = 2
        for i in range(len(a)):
            if j >= len(b):
                yes = 1
                break
            k = a[i].degree - 2
            yes = 0
            for t in range(k):
                print(a[i].id, b[j].id)
                j += 1
                if j >= len(b):
                    yes = 1
                    break
            if yes == 1:
                break",linear
"from collections import deque, defaultdict, Counter
from itertools import product, groupby, permutations, combinations
from math import gcd, floor, inf, log2, sqrt, log10
from bisect import bisect_right, bisect_left
from statistics import mode
from string import ascii_uppercase

cases = int(input())
matrix1 = []
for _ in range(cases):
    matrix1.append(list(input()))

matrix2 = []
for _ in range(cases):
    matrix2.append(list(input()))

def transpose(matrix):
    return [list(x) for x in zip(*matrix)]

def reverse_row(matrix):
    return matrix[::-1]

def reverse_column(matrix):
    return [x[::-1] for x in matrix]
def rotate_90(matrix):

    return reverse_row(transpose(matrix))

def rotate_180(matrix):

    return reverse_row(reverse_column(matrix))
def rotate_270(matrix):

    return reverse_column(transpose(matrix))

if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")

    exit()

matrix2 = reverse_row(matrix2)
if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")
    exit()

matrix2 = reverse_column(matrix2)
if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")
    exit()
matrix2 = transpose(matrix2)
if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")
    exit()
else:
    print(""No"")",quadratic
"import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())

def main():
    n, a, b = [int(x) for x in input().split()]
    dc = {}
    for i in range(n):
        x, vx, vy = [int(x) for x in input().split()]
        nx = x + vx
        ny = a*x+b + vy
        dd = a*nx - ny + b
        if dd not in dc:
            dc[dd] = {}
        if (vx,vy) not in dc[dd]:
            dc[dd][(vx,vy)] = 0
        dc[dd][(vx,vy)] += 1

    tot = 0
    for v,k in dc.items():
        tt = 0
        pp =0
        for _,cc in k.items():
            tt -= cc * (cc+1) // 2
            pp += cc
        tt += pp * (pp+1) // 2
        tot += tt*2
    print(tot)

if __name__ == '__main__':
    main()",linear
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        pass

    def __call__(self):
        MOD = 998244353
        N = 1000007
        pow2 = [0] * N

        n = int(input())
        a = list(map(int, input().strip().split()))

        pow2[0] = 1
        for i in range(n):
            pow2[i + 1] = (2 * pow2[i]) % MOD

        res = 0
        for i in range(1, n):
            tmp = (a[i - 1] * (n + 2 - i)) % MOD
            res += (pow2[n - 1 - i] * tmp) % MOD
            res %= MOD
        res += a[n - 1]
        res %= MOD
        print(res)

solver()()",linear
"n, k = map(int, input().split())
a = list(map(int, input().split()))
t = list(map(int, input().split()))
p = [0] * (n + 1)
now = 0
for i in range(0, n):
    if (t[i] == 1):
        now += a[i]
    p[i + 1] = p[i]
    if (t[i] == 0):
        p[i + 1] += a[i]
s = 0
for i in range(n - k + 1):
    s = max(s, p[i + k] - p[i])
print(now + s)",linear
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
for x in r:
    print(*x, sep='')",quadratic
"import sys
n=int(input())

i=0
ANS=[]
while n>0:
    if n==3:
        ANS=ANS+[2**i,2**i,3*2**i]
        break
    x=(n+1)//2
    ANS=ANS+[2**i]*x
    n=n-x
    i+=1

for a in ANS:
    print(a,end="" "")",logn
"def lower_bound(n, k):
    low = 1
    high = k
    while low < high:
        mid = low + (high - low) // 2
        pipes = mid * k - (mid + 2) * (mid - 1) // 2
        if pipes >= n:
            high = mid
        else:
            low = mid + 1
    return low

def main():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        ans = lower_bound(n, k)
        if ans == k:
            print(-1)
        else:
            print(ans)

if __name__ == ""__main__"":
    main()",logn
"a=int(input())
b=str(a)
c=[]
for i in range(2,a+1):
    if(a%i==0):
        c.append(i)

l=0
for j in c:
    r=str(j)
    t=len(r)
    o=0
    for p in r:
        if(p==""4"" or p==""7""):
            o=o+1
    if(o==t):
        l=l+1
if(l>0):
    print(""YES"")
else:
    print(""NO"")",constant
"import sys
mod=10**9+7
n,q=map(int,sys.stdin.readline().split())
S=sys.stdin.readline().strip()
LR=[list(map(int,sys.stdin.readline().split())) for i in range(q)]

LIST=[0]
for s in S:
    if s==""1"":
        LIST.append(LIST[-1]+1)
    else:
        LIST.append(LIST[-1])

def count(m,n,mod):
    return (pow(2,m,mod)-1)*pow(2,n,mod)%mod

for l,r in LR:
    print(count(LIST[r]-LIST[l-1],r-l+1-LIST[r]+LIST[l-1],mod))",linear
"import sys
input = sys.stdin.buffer.readline
from itertools import permutations

k = list(map(int,input().split()))

worked = 0
for k1,k2,k3 in permutations(k):
    worked2 = 1
    for t in range(10000):
        if not (t % k1 == 0 or t % k2 == 1 or t % k3 == 2):
            worked2 = 0

    if worked2:
        worked = 1
        break

if worked:
    print(""YES"")
else:
    print(""NO"")",constant
"inp = input().split()
totNums, mod = int(inp[0]), int(inp[1])

def Exp(b,exp):
	if exp==0: return 1
	temp = Exp(b,exp>>1)**2
	if exp%2==1: temp*=b
	return temp%mod

n = 410

fact, inv = [0 for i in range(n)],[0 for i in range(n)]
fact[0] = inv[0] = 1;
for i in range(1,totNums+1):
	fact[i] = fact[i-1]*i%mod
	inv[i] = Exp(fact[i],mod-2)

dp, choose = [[0 for i in range(n)] for j in range(n)], [[0 for i in range(n)] for j in range(n)]
for i in range(0,totNums+1):
	for j in range(0,i+1):
		choose[i][j] = fact[i]*inv[j]*inv[i-j]%mod
pow2 = [Exp(2,i) for i in range(n)]

dp[0][0] = 1
for i in range(totNums):
	for j in range(i+1):
		for k in range(1,totNums-i+1):
			dp[i+k+1][j+k] += dp[i][j]*pow2[k-1]*choose[j+k][k]
			dp[i+k+1][j+k] %= mod

ans = 0
for i in range(0,totNums+1):
	ans = (ans+dp[totNums+1][i])%mod
print(ans)",cubic
"n = int(input())
a = list(map(int, input().strip().split()))

amin = min(a)
for i in range(n):
    a[i] -= amin
ans = amin % n
cnt = 0
while True:
    if a[ans] <= cnt:
        break
    ans = (ans + 1) % n
    cnt += 1
print(ans + 1)",linear
"n=int(input())
for i in range(n):
	a,b = map( int, input().split() )
	if a>b:
	    a,b=b,a
	ans=0
	while a>0:
		ans+=b//a
		b%=a
		a,b=b,a
	print(ans)",constant
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n,m = inpl()
s = [inpsl(m) for _ in range(n)]
lampcnt = [0]*m
for i in range(n):
    for j in range(m):
        if s[i][j] == '1':
            lampcnt[j] += 1
res = False
for i in range(n):
    only = False
    for j in range(m):
        if s[i][j] == '1' and lampcnt[j] == 1:
            only = True
    if not only: res = True
print('YES' if res else 'NO')",quadratic
"def isValid(k):
    last=a[0]
    count=1
    step=0
    i=1
    if count==k and step+1==n:
        return True
    elif count==k:
        step+=1
        count=1

    while i<m:

        if step==n:
            return True
        if count==k:
            step+=1
            count=1
            if step==n:
                return True
            last=a[i]
        elif a[i]==last:
            count+=1

            if count==k and step+1==n:
                return True
        elif a[i]!=last:
            last=a[i]
            count=1
        i+=1
    return False

n,m=map(int,input().split())
a=list(map(int,input().split()))
a.sort()
l=1
h=m
ans=0

while l<=h:
    mid=(l+h)//2

    if isValid(mid)==True:
        ans=mid
        l=mid+1
    else:
        h=mid-1
print(ans)",nlogn
"from sys import stdout
N,M=map(int,input().split())
if M%2==0 and N%2==0:
    for m in range (1,M//2+1):
        for n in range (1,N+1):
            stdout.write(str(n)+' '+str(m)+'\n')
            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n')
elif M%2==0 and N%2==1:
    for m in range (1,M//2+1):
        for i in range (1,N+1):
            stdout.write(str(i)+' '+str(m)+'\n')
            stdout.write(str(N+1-i)+' '+str(M+1-m)+'\n')
else:
    for m in range (1,(M+1)//2):
        for n in range (1,N+1):
            stdout.write(str(n)+' '+str(m)+'\n')
            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n')
    if N%2==0:
        for i in range (1,N//2+1):
            stdout.write(str(i)+' '+str((M+1)//2)+'\n')
            stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n')
    else:
        for i in range (1,(N+1)//2):
            stdout.write(str(i)+' '+str((M+1)//2)+'\n')
            stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n')
        stdout.write(str((N+1)//2)+' '+str((M+1)//2)+'\n')",quadratic
"def req_num(a, b, x, y, z):
    req_a = (x * 2) + y
    req_b = (z * 3) + y
    if (req_a - a) <= 0:
        ans_a = 0
    else:
        ans_a = req_a - a
    if (req_b - b) <= 0:
        ans_b = 0
    else:
        ans_b = req_b - b
    return ans_a + ans_b

a, b = list(map(int, input().strip().split()))
x, y, z = list(map(int, input().strip().split()))
print(req_num(a, b, x, y, z))",constant
"t = int(input())

while t>0:
    n, k = input().split()
    n, k = int(n), int(k)

    if n >= 32:
        print(""YES"", n-1)
        t -= 1
        continue

    possibleSize = -1
    sz = 1

    while sz <= n:

        req_cuts = 2**(sz+1) - 2 - sz

        tot_cuts = ((4**sz) - 1) // 3 + (((2**sz) -1)**2) * (((4**(n-sz)) - 1) // 3)

        if (req_cuts > k):
            break
        if (tot_cuts >= k):
            possibleSize = sz
            break

        sz+=1

    if (possibleSize != -1):
        print(""YES"", n - possibleSize)
    else:
        print(""NO"")

    t-=1",logn
"a = int(input())
s = {}
ans = 0
for i in range(a - 1):
    v, c = map(int, input().split())
    if v in s:
        s[v].append(c)
    else:
        s[v] = [c]
    if c in s:
        s[c].append(v)
    else:
        s[c] = [v]
c = 0
for i in range(1, a + 1):
    if len(s[i]) > 2:
        c += 1
        ans = i
if c > 1:
    print(""No"")
elif c == 0:
    print(""Yes"")
    print(1)
    for i in s:
        if len(s[i]) == 1:
            print(i, end="" "")
else:
    print(""Yes"")
    print(len(s[ans]))
    k = []
    for i in s:
        if len(s[i]) == 1:
            k.append(i)
    for i in k:
        print(min(ans, i), max(ans, i))",linear
"n, s = map(int, input().split())

def binsearch(n, s):
    left = 0
    right = n
    while left <= right:
        mid = (left + right) // 2
        digits = sum([int(i) for i in list(str(mid))])
        if mid - digits >= s:
            right = mid - 1
        else:
            left = mid + 1

    return right

print(max(0, n - binsearch(n, s)))",logn
"if __name__ == '__main__':
    n, m, k = map(int, input().split())
    aa = list(map(int,input().split()))
    ans = 0
    for start in range(m):
        ac = aa[:]
        for i in range(start, n, m):
            ac[i] -= k
        cur = 0
        for i in range(start, n):
            if i%m == start:
                cur = max(ac[i] + cur, ac[i])
            else:
                cur += ac[i]
            ans = max(cur, ans)
    print(ans)",quadratic
"s = input()
res = 0
solve = 0
for pos in range(1,len(s)):
    for i in range(len(s) - pos):
        if s[i:i+pos] in s[i+1:]:
            if solve < pos:
                solve = pos
print(solve)",cubic
"n = int(input())
map1 = [list(input()) for i in range(n)]
map2 = [list(input()) for i in range(n)]

def vFlip (m):
    return([list(reversed(i)) for i in m])

def hFlip(m):
    return(list(reversed(m)))

def rotate(m):
    return(list(zip(*reversed(m))))

def check():
    global map1
    for i in range(4):
        if map1 == map2:
            return(True)
        if vFlip(map1)==map2:
            return(True)
        if hFlip(map1)==map2:
            return(True)
        if vFlip(hFlip(map1))==map2:
            return(True)
        map1 = rotate(map1)
    return(False)

print('YES' if check() else 'NO')",quadratic
"n = int(input())
a = list(map(int, input().split()))
a.sort()
k = 0
for i in range(n) :
    if a[i] :
        k += 1
        for j in range(i + 1, n) :
            if a[j] and a[j] % a[i] == 0 :
                a[j] = 0
print(k)",quadratic
"R = lambda: map(int, input().split())

n = int(input())
arr1 = tuple(R())
arr2 = tuple(R())

d = dict()
ans = [0]*n

for i in range(n):
    d[i] = [arr1[i], arr2[i]]

def run():
    for nn in range(n, 0, -1):
        s = list()
        for i in d:
            if d[i][0] == d[i][1] == 0:
                s.append(i)
                ans[i] = nn

        if s:
            for i in s: del d[i]
            for i in d:
                l = r = 0
                for j in s:
                    if j < i:
                        l += 1
                    else:
                        r += 1
                if d[i][0] >= l:
                    d[i][0] -= l
                else:
                    return
                if d[i][1] >= r:
                    d[i][1] -= r
                else:
                    return

        else:
            return

run()

if 0 in ans:
    print('NO')

else:
    print('YES')
    print(*ans, sep=' ')",quadratic
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=999999999999999999999999
alphabets=""abcdefghijklmnopqrstuvwxyz""
class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

class SegTree:

    def __init__(self, n):
        self.N = 1 << n.bit_length()
        self.tree = [0] * (self.N<<1)

    def update(self, i, j, v):
        i += self.N
        j += self.N
        while i <= j:
            if i%2==1: self.tree[i] += v
            if j%2==0: self.tree[j] += v
            i, j = (i+1) >> 1, (j-1) >> 1

    def query(self, i):
        v = 0
        i += self.N
        while i > 0:
            v += self.tree[i]
            i >>= 1
        return v

def SieveOfEratosthenes(limit):

    isPrime = [True]*(limit+1)
    isPrime[0] = isPrime[1] = False
    primes = []
    for i in range(2, limit+1):
        if not isPrime[i]:continue
        primes += [i]
        for j in range(i*i, limit+1, i):
            isPrime[j] = False
    return primes

def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        a,b=ria()

        op=0
        while min(a,b):
            if a>b:
                op+=a//b
                a%=b
            else:
                op+=b//a
                b%=a

        wi(op)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()",constant
"n,k = input().split()
n,k = int(n),int(k)

ini,fin = 1,k-1
if n == 1:
	print(""0"")
	exit(0)

if 1 + (k*(k-1) )//2 < n:
	print(""-1"")
	exit(0)

while ini < fin:
	mid = (ini+fin)//2
	s = 1 + (k-1)*mid - (mid*(mid-1))//2
	if s>=n:
		fin = mid
	else:
		ini = mid+1

print(ini)",logn
"t1, t2, t3 = input().split()
ans = 2
if t1 == t2 or t2 == t3 or t3 == t1:
    if t1 == t2 == t3:
        ans = 0
    else:
        ans = 1
aaa = []
for i in range(10):
    for j in range(10):
        for k in range(10):
            if k - j == j - i == 1:
                aaa.append({i, j, k})
if t1[1] == t2[1] == t3[1] and {int(t1[0]), int(t2[0]), int(t3[0])} in aaa:
    ans = 0
elif (t1[1] == t2[1] and (abs(int(t1[0]) - int(t2[0])) == 1 or abs(int(t1[0]) - int(t2[0])) == 2)) or (t1[1] == t3[1] and (abs(int(t1[0]) - int(t3[0])) == 1 or abs(int(t1[0]) - int(t3[0])) == 2)) or (t3[1] == t2[1] and (abs(int(t3[0]) - int(t2[0])) == 1 or abs(int(t3[0]) - int(t2[0])) == 2)):
    ans = min(1, ans)
print(ans)",constant
"MAX = 1000
f = [0]
for i in range(1, MAX):
    f.append(f[i - 1] + (1 << (2 * i - 2)))

g = [0]
for i in range(1, MAX):
    g.append(g[i - 1] + (1 << i) - 1)

t = int(input())
for _ in range(t):
    n, k = map(int, input().split(' '))
    ans = False
    for i in range(1, n + 1):
        if k >= g[i]:
            if n >= MAX:
                print(""YES %d"" % (n - i))
                ans = True
            elif k <= f[n] - ((1 << (i + 1)) - 1) * f[n - i]:
                print(""YES %d"" % (n - i))
                ans = True
        if ans == True:
            break
    if ans == False:
        print(""NO"")",linear
"from sys import stdin,stdout,setrecursionlimit
stdin.readline
def mp(): return list(map(int, stdin.readline().strip().split()))
def it():return int(stdin.readline().strip())
from collections import defaultdict as dd,Counter as C,deque
from math import ceil,gcd,sqrt,factorial,log2,floor
from bisect import bisect_right as br,bisect_left as bl
import heapq

def solve(a,b):
	if a == 0:
		return 0
	return b//a + solve(b%a,a)
print(solve(*mp()))",constant
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
	print(""?"", xr + cb, cb)
	ans11 = input()
	print(""?"", xr, cb)
	if ans11 == ans00:
		ans01 = input()
		if ans01 == '1':
			a += cb
			b += cb
	else:
		ans00 = input()
		if ans11 == '1':
			b += cb
		else:
			a += cb
		xr += cb
	cb //= 2
print(""!"", a, b)",logn
"n = int(input())
i = 0
s = 0
while True:
	temp = (i+1)*9*(10**i)
	if s + temp <= n:
		s += temp
		i += 1
	else:
		break
tc = n - s

nd = tc//(i+1) - 1
tc -= (nd+1)*(i+1)
f = 10**i + nd
if tc != 0:
	print(str(10**i+nd+1)[tc-1])
else:
	print(str(10**i+nd)[-1])",logn
"n,p = map(int,input().split())
a  = list(map(int,input().split()))
forward = [a[0]]
for i in range(1,n):
    forward.append(forward[-1] + a[i])
sm = sum(a)
mx = -float('inf')
for i in range(n-1):
    mx = max(mx,(forward[i]%p) + ((sm -forward[i] )%p))
print(mx)",linear
"from sys import stdin

line = stdin.readline().rstrip().split()
x = int(line[0])
k = int(line[1])

if x == 0:
    print(0)
else:
    nn = pow(2, k, 1000000007)
    result = (nn*2*x - nn + 1) % 1000000007
    print(result)",logn
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

def main():
    for _ in range(N()):
        n, m = RL()
        arr = []
        for _ in range(n): arr.append(RLL())

        larr = [list(i) for i in zip(*arr)]
        larr.sort(key = lambda a: max(a), reverse=1)
        larr = larr[:n]

        res = 0

        def dfs(lst, pos=0):
            nonlocal res
            if pos==min(n, len(larr)):
                res = max(res, sum(lst))
                return

            for i in range(n):
                now = larr[pos][i:n]+larr[pos][0:i]
                nex = [max(now[j], lst[j]) for j in range(n)]
                dfs(nex, pos+1)

        dfs([0]*n)
        print(res)

if __name__ == ""__main__"":
    main()",np
"import os,sys
from io import BytesIO,IOBase

def main():
    n,c = map(int,input().split())
    a = list(map(int,input().split()))
    nums = [[0] for _ in range(500001)]
    freq,minus = [0]*500001,0
    for i in a:
        if i == c:
            minus += 1
        else:
            freq[i] += 1
            nums[i].append(freq[i]-minus)
    tot = minus
    suff = [i[:] for i in nums]
    for i in range(500001):
        for j in range(len(nums[i])-2,0,-1):
            suff[i][j] = max(suff[i][j],suff[i][j+1])
    freq,ans = [0]*500001,tot
    for i in a:
        if i == c:
            continue
        freq[i] += 1
        ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot)
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",linear
"a,b=input().split()
if(a==b):
    print(""0"")
else:
    xor=bin(int(a)^int(b))[2:]
    a=bin(int(a))[2:]
    b=bin(int(b))[2:]
    ans=""""
    if a[0]==b[0]:
        ans+=""0""
    else:
        ans+=""1""
    for i in range(len(xor)):
        ans+=""1""
    print(int(ans,2))",logn
"import bisect

tmp = input().split()
n = int(tmp[0])
k = int(tmp[1])

scores = list()
times = list()
for i in range(n):
    tmp = input().split()
    scores.append(int(tmp[0]))
    times.append(int(tmp[1]))

sorted_scores = sorted(zip(scores, times), key=lambda y : (y[0], -y[1]), reverse=True)

ans = 1
i = k-2
while i>=0 and (sorted_scores[i] == sorted_scores[k-1]):
    ans = ans + 1
    i = i - 1

i = k
while i < n and (sorted_scores[i] == sorted_scores[k-1]):
    ans = ans + 1
    i = i + 1

print(ans)",nlogn
"q = int(input())
a,s = map(int,input().split())
if ((a+s-2)<=(q+q-a-s)):
    print(""White"")
else:
    print('Black')",constant
"s1, s2 = input().split()
ans = s1[0]
for i in range(1, len(s1)):
    if s1[i] < s2[0]:ans += s1[i]
    else:break
print(ans + s2[0])",linear
"import sys, math, queue

MOD = 998244353
sys.setrecursionlimit(1000000)

n, m, k = map(int, input().split())
a = list(map(int, input().split()))

dp = [[-10**20 for i in range(m)] for i in range(n)]
dp[0][0] = a[0]-k

for i in range(1, n):
	for j in range(m):
		if j == 0:
			dp[i][j] = max(dp[i-1][m-1]+a[i], a[i])-k
		else:
			dp[i][j] = dp[i-1][j-1]+a[i]

ans = 0
for i in range(n):
	ans = max(ans, max(dp[i]))
print(ans)",quadratic
"from collections import deque
from collections import OrderedDict
import math

import sys
import os
import threading
import bisect

import operator

import heapq

from atexit import register
from io import BytesIO

import io

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

r,g,b = map(int, input().split())
a = []
for i in range(3):
    a.append([int(x) for x in input().split()])
    a[i].sort(reverse=True)

dp = [[[0 for i in range(205)] for j in range(205)] for k in range(205)]
answer = 0

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i<r and j<g:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k], dp[i][j][k]+a[0][i]*a[1][j])
            if i<r and k<b:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1], dp[i][j][k]+a[0][i]*a[2][k])
            if j<g and k<b:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1], dp[i][j][k]+a[1][j]*a[2][k])
            answer=max(answer, dp[i][j][k])
print(answer)

sys.exit(0)

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person(""heelo"", 27)

print(help(Person))

age = 26
name = 'Swaroop'
print('Возрас {} -- {} лет'.format(name, age))
print(help(object))",cubic
"import sys

import random

n = int(input())
if n<=3:
    print('YES')
    sys.exit()
coord = [int(x) for line in sys.stdin for x in line.split()]

X = [coord[2*i] for i in range(n)]
Y = [coord[2*i+1] for i in range(n)]

for i in range(13):
    a = random.randint(0,n-1)
    b = random.randint(0,n-2)

    if a==b:
        b+=1

    x0,y0 = X[a],Y[a]
    x1,y1 = X[b],Y[b]

    dx = x1-x0
    dy = y1-y0
    not_on_line = []
    for c in range(n):
        if c==a or c==b:
            continue
        x2,y2 = X[c],Y[c]
        Dx = x2-x0
        Dy = y2-y0
        if dx*Dy-dy*Dx!=0:
            not_on_line.append(c)
    if len(not_on_line)<=1:
        print('YES')
        sys.exit()

    a = not_on_line[0]
    b = not_on_line[1]
    x0,y0 = X[a],Y[a]
    x1,y1 = X[b],Y[b]

    dx = x1-x0
    dy = y1-y0
    can = True
    for c in not_on_line:
        if c==a or c==b:
            continue
        x2,y2 = X[c],Y[c]
        Dx = x2-x0
        Dy = y2-y0
        if dx*Dy-dy*Dx!=0:
            can = False
            break
    if can:
        print('YES')
        sys.exit()
print('NO')",nlogn
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:

    sys.stdin = open(""input.txt"", ""r"")

except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")

x=L()[0]
if x<=2:
    print(x)
    exit()
if x%2:
    n=x
    lcm=n*(n-1)//gcd(n,n-1)
    lcm=lcm*(n-2)//gcd(lcm,n-2)
    print(lcm)
else:
    ans=1
    for n1 in range(max(1,x-50),x+1):
        for n2 in range(max(1,x-50),x+1):
            for n3 in range(max(1,x-50),x+1):
                lcm=(n1*n2)//(gcd(n1,n2))
                lcm=(lcm*n3)//gcd(lcm,n3)
                ans=max(ans,lcm)
    print(ans)

endtime = time.time()",constant
"from sys import stdin

def f(lst, num):
    new = lst[num:] + lst[:num]
    return new

t = int(stdin.readline())
for i in range(t):
    row, col = tuple(int(x) for x in stdin.readline().split())
    lst = list([int(x)] for x in stdin.readline().split())

    for j in range(row-1):
        line = tuple(int(x) for x in stdin.readline().split())
        for k in range(len(line)):
            lst[k].append(line[k])

    lst.sort(key=lambda x: max(x), reverse = True)

    ans = float('-inf')
    for a in range(4):
        for b in range(4):
            for c in range(4):
                for d in range(4):
                    if col >= 1:
                        aa = f(lst[0], a)
                    else:
                        aa = (0,)*row
                    if col >= 2:
                        bb = f(lst[1], b)
                    else:
                        bb = (0,)*row
                    if col >= 3:
                        cc = f(lst[2], c)
                    else:
                        cc = (0,)*row
                    if col >= 4:
                        dd = f(lst[3], d)
                    else:
                        dd = (0,)*row

                    ans = max(ans,
                              sum(max(x[j] for x in (aa, bb, cc, dd))
                                  for j in range(row)))
    print(ans)",np
"def if_spruce(n,l,m):
    d=[0]*(n+1)
    for i in range(1,n+1):
        if m[i]==0:
            d[l[i]]+=1
    for i in range(1,n+1):
        if m[i]>0 and d[i]<3:
            return ""No""
    return ""Yes""

n=int(input())
l,m,a=[0]*2,[0]*(n+1),0
for _ in range(n-1):
    a=int(input())
    l.append(a)
    m[a]+=1
print(if_spruce(n,l,m))",linear
"from math import ceil
def test(f):
    for i in range(n):
        if (r1+ f) > f * lift[i]:
            return 0
        f -= (r1 + f) / lift[i]
        if (r1+ f) > f * land[i + 1]:
            return 0
        f -= (r1 + f) / land[i + 1]
    return 1
p=int(input())
total_wgt=int(input());r1=total_wgt
lift=list(map(int,input().split()))
land=list(map(int,input().split()));n=len(land);ans=1e20
lift+=[lift[0]];land+=[land[0]]
l=0.0;r=1e20
for i in range(1000):
  mid=(l+r)/2.0

  if test(mid):r=mid
  else:l=mid
if r<1e19:
    print('%.17f' %r)
else:
    print(-1)",linear
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

n = INT()
l  = []
d = {}
sm = 0

for i in range(n):
    indx , y  = MAP()

    d[indx] = y
    sm += y

m = INT()
for i in range(m):
    indx , y = MAP()
    if indx in d :
        sm -= d[indx]
        sm += max(y , d[indx])
    else:
        sm += y

print(sm)",nlogn
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

n,m = map(int, input().split())
a = []
for i in range(n):
    ai = list(map(int, input().split()))
    a.append(ai)

def check(mid):
    mask = (1<<m)-1
    s = set()
    d = dict()
    for i in range(n):
        state = 0
        for j in range(m):
            if a[i][j] >= mid:
                state += 1<<j

        if state in s:
            continue
        s.add(state)
        k = state
        while k>=0:

            k &= state
            d[k] = i
            k -= 1
        need = mask^state

        if need in d:
            q1, q2 = d[need], i
            if q1 > q2:
                q1, q2 = q2, q1
            return True, (q1, q2)

    return False, (-1, -1)

left = 0
right = 10**9+1
i,j = 0, 0
while right-left>1:
    mid = (right+left)//2
    flag, (q1, q2) = check(mid)

    if flag:
        left = mid
        i,j = q1, q2
    else:
        right = mid
print(i+1, j+1)",np
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=None):
        self.BIT=[0]*(n+1)
        self.num=n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        self.mod = mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res

    def bisect_l(self,l,r,x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l<r:
            if l & 1:
                if self.tree[l] <= x and Lmin==-1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r-1] <=x:
                    Rmin = r-1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        elif Rmin != -1:
            pos = Rmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        else:
            return -1

from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        forward = [to, cap, cost, None]
        backward = forward[3] = [fr, 0, -cost, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [None]*N

        d0 = [INF]*N
        dist = [INF]*N

        while f:
            dist[:] = d0
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                r0 = dist[v] + H[v]
                for e in G[v]:
                    w, cap, cost, _ = e
                    if cap > 0 and r0 + cost - H[w] < dist[w]:
                        dist[w] = r = r0 + cost - H[w]
                        prv_v[w] = v; prv_e[w] = e
                        heappush(que, (r, w))
            if dist[t] == INF:
                return None

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, prv_e[v][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = prv_e[v]
                e[1] -= d
                e[3][1] += d
                v = prv_v[v]
        return res

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.buffer.readline()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

k = li()
k.sort()
k = tuple(k)

ans = [(2,4,4),(3,3,3)]
if k.count(1)>=1:
    print(""YES"")
elif k.count(2)>=2:
    print(""YES"")
elif k.count(3)>=3:
    print(""YES"")
elif k in ans:
    print(""YES"")
else:
    print(""NO"")",constant
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        nums.sort()
        i = 0
        while i < len(nums) - 1:
            if nums[i] == nums[i + 1]:
                i += 2
            else:
                return nums[i]
        return nums[i]",nlogn
"n = int(input())
a = [int(i) for i in input().split()]
a.sort()
count = 0
for i in range(n):
    cur_c = a[i]
    if not cur_c:
        continue
    count += 1
    for j in range(i+1,n):
        if a[j]%cur_c == 0:
            a[j] = 0
print(count)",quadratic
"n,m=map(int,input().split())
lst=list(map(int,input().split()))
maxx=0
arr=[0]*(n+1)
for i in range(n):
    summ=0
    for j in range(i,n):
        summ+=lst[j]
        arr[j-i]=max(arr[j-i], summ/(j-i+1))
print(max(arr[m-1:]))",quadratic
"n, m = (int(x) for x in input().split())
boys_out = sorted([int(x) for x in input().split()], reverse=True)
girls_in = sorted([int(x) for x in input().split()])
max_boy = max(boys_out)
ans = 0
for boy in boys_out:
    ans += boy * m

count = 0
i = 0
for girl in girls_in:
    if girl < max_boy:
        print(-1)
        quit()

    if girl > max_boy:
        if count == m - 1:
            count = 0
            i += 1
        if i >= n:
            print(-1)
            quit()
        ans += girl - boys_out[i]
        count += 1

print(ans)",nlogn
"import math

n=int(input())

for _ in range(n):
    a,b=map(int,input().split())
    ans=0
    while a>0 and b>0:
        if a>=b:
            ans+=a//b
            a=a%b
        else:
            ans+=b//a
            b=b%a
    print(ans)",constant
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]
ans = []

def check(mid: int) -> bool:
    global ans
    dic = {}
    for i in range(n):
        bit = 0
        for j in range(m):
            if a[i][j] >= mid:
                bit += 1
            bit <<= 1
        dic[bit >> 1] = i
    for x, idx in dic.items():
        for y, idy in dic.items():
            if x | y == 2**m-1:
                ans = idx + 1, idy + 1
                return True
    return False

le = 0
ri = int(1e9)
while le <= ri:
    mid = (le + ri) >> 1
    if check(mid):
        le = mid + 1
    else:
        ri = mid - 1
print(ans[0], ans[1])",np
"import sys
from collections import defaultdict

exist_num,new_width = map(int,sys.stdin.readline().strip().split())
buildings = []
for _ in range(exist_num):
    center, width = map(int,sys.stdin.readline().strip().split())
    buildings.append((center-width/2,center+width/2))
buildings.sort()
possible_loc = 2
for left,right in zip(buildings,buildings[1:]):
    gap=right[0] - left[1]
    if gap == new_width:
        possible_loc += 1
    elif gap > new_width:
        possible_loc += 2

print(possible_loc)",nlogn
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

for t in range(ii()):
    n, k = mi()
    if n == 1:
        ans = 'YES 0' if k == 1 else 'NO'
    elif n == 2:
        if k <= 2:
            ans = 'YES 1'
        elif k == 3 or k > 5:
            ans = 'NO'
        else:
            ans = 'YES 0'
    elif n <= 32 and k > (4 ** n - 1) // 3:
        ans = 'NO'
    else:
        c, x = 0, n
        p2 = 2
        while x > 0:
            if c + p2 - 1 > k:
                break
            c += p2 - 1
            x -= 1
            p2 *= 2
        ans = 'YES %d' % (x,)
    print(ans)",logn
"import sys,io,os
try:Z=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
except:Z=lambda:sys.stdin.readline().encode()
Y=lambda:[*map(int,Z().split())]
n,m,k=Y();H=[Y()for i in range(n)];V=[Y()for i in range(n-1)]
if k&1:print('\n'.join(' '.join(['-1']*m)for i in range(n)));quit()
d=[0]*n*m
for _ in range(k//2):
    nd=[0]*n*m
    for x in range(n):
        for y in range(m):
            v=x*m+y;w=[]
            if x:w.append(d[v-m]+V[x-1][y])
            if y:w.append(d[v-1]+H[x][y-1])
            if x<n-1:w.append(d[v+m]+V[x][y])
            if y<m-1:w.append(d[v+1]+H[x][y])
            nd[v]=min(w)
    d=nd
print('\n'.join(' '.join(map(lambda x:str(2*x),d[i*m:i*m+m]))for i in range(n)))",cubic
"n , m = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
diff = [0] * n
for i in range(n):
	if a[i] < m:
		diff[i] = -1
	if a[i] > m:
		diff[i] = 1

aim = a.index(m)
left = {}
right = {}
suml = 0
for i in reversed(range(aim + 1)):
	suml += diff[i]
	if not suml in left:
		left[suml] = 0
	left[suml] += 1

sumr = 0
for i in range(aim, n):
	sumr += diff[i]
	if not sumr in right:
		right[sumr] = 0
	right[sumr] += 1

ans = 0
for i in left:
	wk1 = -i
	if wk1 in right:
		ans += left[i] * right[wk1]
	wk1 = 1 - i
	if wk1 in right:
		ans += left[i] * right[wk1]

print(ans)",nlogn
"def operations(a, b):
    less = min(a, b)
    more = max(a, b)
    ops = 0
    while less > 0 and more > 0:
        ops += more // less
        more -= less * (more // less)
        less, more = more, less
    return ops

n = int(input())
for i in range(n):
    a, b = map(int, input().split())
    print(operations(a, b))",constant
"x,k = map(int,input().split())
if x==0:
    print(0)
    exit()
mod = 10**9+7
print((pow(2,k+1,mod)*x%mod - (pow(2,k,mod) - 1)) % mod )",logn
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
left = 0
right = 10**9+1
ans = (0, 0)
while left < right:
    mid = (left + right) // 2
    masks = {}
    for i in range(n):
        mask = 0
        for j in a[i]:
            mask <<= 1
            if j >= mid:
                mask += 1
        masks[mask] = i
    ok = False
    for m1 in masks:
        for m2 in masks:
            if m1 | m2 == ((1 << m) - 1):
                ok = True
                ans = (masks[m1]+1, masks[m2]+1)
                break
        if ok:
            break
    if ok:
        left = mid+1
    else:
        right = mid
print(ans[0], ans[1])",np
"pri=998244353
dp=[[[0 for i in range(2001)] for i in range(1001)] for i in range(2)]
n,k=map(int,input().split())

for i in range(1,n+1):
    if(i==1):
        dp[0][i][1]=2
        dp[1][i][2]=2

        continue;
    for j in range(1,(2*i)+1):
        dp[0][i][j]=(dp[0][i-1][j])+(dp[0][i-1][j-1])+(2*(dp[1][i-1][j]))

        dp[0][i][j]%=pri
        dp[1][i][j]=(2*dp[0][i-1][j-1])+(dp[1][i-1][j])+(dp[1][i-1][j-2])
        dp[0][i][j]%=pri
        dp[1][i][j]%=pri
y=dp[0][n][k]+dp[1][n][k]
y%=pri
print(y)",np
"def maxlen():
    string = input()
    maxi = 0;
    for x in range(len(string)):
        substring = """"
        for y in string[x:]:
            substring +=y;
            if string[x:].rfind(substring) != string[x:].find(substring):
                maxi = max(maxi, len(substring))
                continue
    print(maxi)

maxlen()",cubic
"import sys
from array import array
from typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def main():
    n, m = map(int, input().split())
    mat = [array('i', map(int, input().split())) for _ in range(n)]
    bit = array('h', [1 << i for i in range(m)])
    max_bit = 1 << m
    fullbit = max_bit - 1

    def solve(x: int) -> Tuple[int, int]:
        dp = array('i', [-1]) * max_bit
        for i in range(n):
            dp[sum(bit[j] for j in range(m) if mat[i][j] >= x)] = i

        for i in range(max_bit):
            if dp[i] == -1:
                continue
            for j in range(i, max_bit):
                if dp[j] != -1 and i | j == fullbit:
                    return dp[i], dp[j]

        return -1, -1

    ok, ng = 0, 10**9 + 1
    ans_i, ans_j = 1, 1

    while abs(ok - ng) > 1:
        mid = (ok + ng) >> 1
        x, y = solve(mid)
        if x == -1:
            ng = mid
        else:
            ok = mid
            ans_i, ans_j = x + 1, y + 1

    print(ans_i, ans_j)

if __name__ == '__main__':
    main()",np
"from sys import stdin
a, b, c, n = map(int, stdin.readline().split())
if c > a or c > b:
    print(-1)
else:
    val = n - ((a - c) + (b - c)) - c
    print(val if val <= n and val > 0 else -1)",constant
"fac = [1] * 500
finv = [1] * 500
p2 = [1] * 500

n, MOD = map(int, input().split())

for i in range(len(fac) - 1):
    fac[i + 1] = fac[i] * (i + 1) % MOD
    finv[i + 1] = pow(fac[i + 1], MOD - 2, MOD)
    p2[i + 1] = p2[i] * 2 % MOD

ans = 0
dp = [[0] * (n // 2 + 2) for _ in range(n + 2)]
dp[0][0] = 1
for i in range(n):
    for j in range(i + 2, n + 2):
        for k in range(n // 2 + 1):
            dp[j][k + 1] += dp[i][k] % MOD * finv[j - i - 1] * p2[j - i - 2]
ans = 0
for i in range(1, n // 2 + 2):
    ans += dp[n + 1][i] * fac[n - i + 1]
print(ans % MOD)",cubic
"def m():
	[x, y, k] = [int(i) for i in input().split()]
	d=min(x, y)
	x-=d
	y-=d
	k-=d

	if k-x-y<0:
		print(-1)
	else:
		x+=y
		if x%2 > 0 and k%2>0:
			print(d+k-1)
		elif x%2 >0:
			print(d+k-1)
		elif k%2>0:
			print(d+k-2)
		else:
			print(d+k)

n=int(input())
for i in range(n):
	m()",constant
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        LIS = [1] * len(nums)

        for i in range(len(nums) - 1, -1, -1):
            for j in range(i + 1, len(nums)):
                if nums[i] < nums[j]:
                    LIS[i] = max(LIS[i], 1 + LIS[j])
        return max(LIS)",quadratic
"import sys
N, M = map(int, input().split())

Ans = [(0, 0) for  _ in range(N*M)]
for i in range(1, N*M+1):
    if i % 2:
        a, b = divmod(i//2, M)
    else:
        a, b = divmod(N*M - i//2, M)
    Ans[i-1] = ' '.join((str(a+1), str(b+1)))

for a in Ans:
    sys.stdout.write(f'{a}\n')",quadratic
"rr = lambda: input().rstrip()
rri = lambda: int(rr())
rrm = lambda: list(map(int, rr().split()))

from functools import lru_cache;memo=lru_cache(None)
from sys import setrecursionlimit as srl;srl(10**5)

def solve(N, A):
    @memo
    def dp(i, j, left=0):
        if i == j:
            if left == 0:
                return 1
            if A[i] == left:
                return 1
            return 2
        if i > j:
            return 0 if left == 0 else 1

        ans = 1 + dp(i+1, j, A[i])
        if left >= 1:
            stack = []
            for k in range(i, j+1):
                stack.append(A[k])

                while len(stack) >= 2 and stack[-1] == stack[-2]:
                    stack.pop()
                    stack[-1] += 1
                if len(stack) == 1 and left == stack[-1]:
                    cand = dp(k+1, j, left+1)
                    if cand < ans:
                        ans = cand
        return ans

    return dp(1, N-1, A[0])

print(solve(rri(), rrm()))",cubic
"from sys import stdin,stdout
def count(audrey,imba,banget):
    return((imba-audrey-1)%(banget-1))

n,q=map(int,input().split())
L=list(map(int,input().split()))
maxi=max(L)
indexmax=L.index(maxi)
P=[]
for i in range(indexmax):
    P.append((L[0],L[1]))
    if L[0]<L[1]:
        L.append(L.pop(0))
    else:
        L.append(L.pop(1))
Y=tuple(L[1:])
for p in range(q):
    m=int(stdin.readline())
    if m<=indexmax:
        print(str(P[m-1][0])+' '+str(P[m-1][1]))
    else:
        stdout.write(str(maxi)+' '+str(Y[count(indexmax,m,n)])+'\n')",linear
"a, b, c, n = map(int, input().split())
t = a + b - c
if a >= n or b >= n or c > a or c > b or t >= n:
    print(-1)
else:
    print(n - t)",constant
"n = int(input())
arr = list(map(int, input().split()))
codd = 0
ceven = 0
ptodd = -1
pteven = -1
for i in range(n):
    if arr[i]%2 == 0:
        ceven += 1
        pteven = i
    else:
        codd += 1
        ptodd = i

if ceven == 1:
    print(pteven+1)
else:
    print(ptodd+1)",linear
"n = int(input())
for i in range(n):
    a,b = map(int, input().split())
    a1 = a
    if a % 2 == 0:
        a1 += 1
    b1 = b
    if b % 2 == 0:
        b1 -= 1
    n = 0
    if a1 <= b1:
        num = (b1 - a1) // 2 + 1
        n = num * (b1 + a1) // 2
        n *= -1
    b2 = b
    a2 = a
    if a % 2 == 1:
        a2 += 1
    if b % 2 == 1:
        b2 -= 1
    n2 = 0
    if a2 <= b2:
        num = (b2 - a2) // 2 + 1
        n2 = num * (b2 + a2) // 2
    print(n + n2)",constant
"import sys
input = lambda: sys.stdin.readline().rstrip()

from collections import deque, defaultdict
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = ''
            for j in range(k):
                if i>>j&1:
                    ans = ''.join([ans, s[j]])
                else:
                    ans = ''.join([ans, '_'])
            Ans.add(ans)
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = 1
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = 0
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag == 0 or not T:
        print('NO')
    else:
        print('YES')
        print(*[t+1 for t in T], sep = ' ')

main()",np
"import os,sys
from io import BytesIO,IOBase
from math import inf,isinf

def solve(s,t):
    if len(t) == 1:
        if s.count(t[0]):
            return 'YES'
        return 'NO'
    for i in range(1,len(t)):
        dp = [[-inf]*(i+1) for _ in range(len(s)+1)]
        dp[0][0] = 0
        for j in range(len(s)):
            dp[j+1] = dp[j][:]
            for k in range(i+1):
                if k != i and s[j] == t[k]:
                    dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k])
                if dp[j][k]+i != len(t) and not isinf(dp[j][k]) and s[j] == t[dp[j][k]+i]:
                    dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1)

        for l in range(len(s)+1):
            if dp[l][-1] == len(t)-i:
                return 'YES'
    return 'NO'

def main():
    for _ in range(int(input())):
        s = input().strip()
        t = input().strip()
        print(solve(s,t))

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",cubic
"n,a,b = map(int,input().split())
c = []
c = list(map(int,input().split()))
c.sort()
l = c[b-1]
r = 0
ok = False
for i in range (b,n-a+1):
  if c[i] > l:
    ok = True
    r = c[i]
    break
if ok == True: print(r-l)
else: print(0)",nlogn
"import sys,math
class Node:
    def __init__(self,u=math.inf,d=math.inf,l=math.inf,r=math.inf):
        self.up=u
        self.dn=d
        self.lt=l
        self.rt=r
    def __str__(self):
        return 'U:{},D:{},L:{},R:{}'.format(self.up,self.dn,self.lt,self.rt)

n,m,k=list(map(int,sys.stdin.readline().strip().split()))
graph=[[Node() for j in range(m)]for i in range(n)]
for i in range(n):
    wts=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(m-1):
        graph[i][j].rt=wts[j]
        graph[i][j+1].lt=wts[j]

for i in range(n-1):
    wts=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(m):
        graph[i][j].dn=wts[j]
        graph[i+1][j].up=wts[j]

ans=[[math.inf for j in range(m)]for i in range(n)]

if k%2:
    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]

else:
    def bfs(prsnt,stps):

        if stps==0:
            return 0
        else:
            if dp[prsnt[0]][prsnt[1]][stps]==math.inf:
                min_cost=math.inf
                for x,y,c in [(0,1,graph[prsnt[0]][prsnt[1]].dn),(1,0,graph[prsnt[0]][prsnt[1]].rt),(0,-1,graph[prsnt[0]][prsnt[1]].up),(-1,0,graph[prsnt[0]][prsnt[1]].lt)]:
                    if -1<prsnt[1]+x<m and -1<prsnt[0]+y<n:
                        min_cost=min(bfs((prsnt[0]+y,prsnt[1]+x),stps-1)+c,min_cost)
                dp[prsnt[0]][prsnt[1]][stps]=min_cost
                return min_cost
            else:
                return dp[prsnt[0]][prsnt[1]][stps]

    dp=[[[math.inf for k in range(k+1)] for j in range(m)]for i in range(n)]
    for i in range(n):
        for j in range(m):
            ans[i][j]=bfs((i,j),k//2)*2
    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]",cubic
"list1=list(input())
list2=list(input())
plus1=list1.count('+')
plus2=list2.count('+')
minus1=list1.count('-')
minus2=list2.count('-')
wths=list2.count('?')
def giveFactorial(n,x):
    if x==0 or x==n or x>n or n==0:
        return 1
    else:
        return giveFactorial(n-1,x-1)+giveFactorial(n-1,x)
a=(giveFactorial(wths,plus1-plus2))

if plus1==plus2 and wths==0:
    print(1)
elif wths==0 :
    print(0)
elif plus1-plus2>wths or minus1-minus2>wths:
    print(0)
else:
    print((0.5**(plus1-plus2+minus1-minus2))*a)",np
"def getArray():
    return list(map(int, input().split()))
def createDP(R, G, B):
    dp = []
    for i in range(R):
        temp1 = []
        for j in range(G):
            temp2 = []
            for k in range(B):
                temp2.append(-1)
            temp1.append(temp2)
        dp.append(temp1)
    return dp
def go(r, g, b, R, G, B, ri, gi, bi, state):
    if state[ri][gi][bi] != -1 :
        return state[ri][gi][bi]
    best = 0
    if ri < R and gi < G:
        best = max(best, r[ri]*g[gi] + go(r, g, b, R, G, B, ri+1, gi+1, bi, state))
    if ri < R and bi < B:
        best = max(best, r[ri]*b[bi] + go(r, g, b, R, G, B, ri+1, gi, bi+1, state))
    if gi < G and bi < B:
        best = max(best, g[gi]*b[bi] + go(r, g, b, R, G, B, ri, gi+1, bi+1, state))

    state[ri][gi][bi] = best
    return best

R,G,B = map(int, input().split())
r = getArray()
g = getArray()
b = getArray()
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = createDP(201,201,201)
print(go(r, g, b, R, G, B, 0, 0, 0, dp))",cubic
"import sys

SIZE = 105
a = SIZE * [0]
b = SIZE * [0]

lr = input().split()
l = int(lr.pop(0))
r = int(lr.pop(0))

if l == r:
    print(0)

else:
    len1 = 0
    len2 = 0
    while l != 0:
        a[len1] = l % 2
        l = int(l/2)
        len1 += 1

    while r != 0:
        b[len2] = r % 2
        r = int(r/2)
        len2 += 1

    tag = 0
    for i in range(max(len1, len2)-1, 0, -1):
        if b[i] == 1 and a[i] == 0:
            tag = i
            break

    print(pow(2, tag+1)-1)",logn
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)

def getN():
    return int(input())
def getList():
    return list(map(int, input().split()))
import math

def validation(n, k, x):
    if (x*(x+1)) // 2 - (n-x) == k:
        return 0
    if (x * (x + 1)) // 2 - (n - x) > k:
        return 1
    return 2

n, k = getList()

l = 0
r = 1000000001
while(True):
    mid = (l+r)//2
    flag = validation(n, k, mid)
    if flag == 0:
        ans = mid
        break
    elif flag == 1:
        r = mid
    else:
        l = mid

print(n - ans)",logn
"def problem(s, p):
    for i in range(len(p)):
        l = p[:i] + ' '
        r = p[i:] + ' '

        dp = [0] + [None] * i

        for x in s:
            for j in range(i, -1, -1):
                if dp[j] is None:
                    continue

                if l[j] == x:
                    dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1])

                temp = r[dp[j]]
                if r[dp[j]] == x:
                    dp[j] += 1

        if dp[-1] == len(r) - 1:
            return 'YES'

    return 'NO'

for _ in range(int(input())):
    print(problem(input(), input()))",cubic
"import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())

def main():
    n, a, b = [int(x) for x in input().split()]
    dc = {}
    for i in range(n):
        x, vx, vy = [int(x) for x in input().split()]
        nx = x + vx
        ny = a * x + b + vy
        dd = a * nx - ny + b
        if dd not in dc:
            dc[dd] = {}
        if (vx, vy) not in dc[dd]:
            dc[dd][(vx, vy)] = 0
        dc[dd][(vx, vy)] += 1

    tot = 0
    for v, k in dc.items():
        tt = 0
        pp = 0
        for _, cc in k.items():
            tt -= cc * (cc + 1) // 2
            pp += cc
        tt += pp * (pp + 1) // 2
        tot += tt * 2
    print(tot)

if __name__ == '__main__':
    main()",linear
"import math
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a + b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

n,m=map(int,input().split())
l=[]
tot=[]
done=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    l.append(input())
colsum=[[0 for i in range(m)]for j in range(n)]
rowsum=[[0 for i in range(m)]for j in range(n)]
col=[[0 for i in range(m)]for j in range(n)]
row=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            rowsum[i][j]=1
            colsum[i][j]=1
            row[i][j]=1
            col[i][j]=1
for i in range(n):
    for j in range(1,m):
        if l[i][j]=='.':
            continue
        rowsum[i][j]+=rowsum[i][j-1]
for i in range(n):
    for j in range(m-2,-1,-1):
        if l[i][j]=='.':
            continue
        row[i][j]+=row[i][j+1]
for i in range(m):
    for j in range(n-2,-1,-1):
        if l[j][i]=='.':
            continue
        col[j][i]+=col[j+1][i]
for i in range(m):
    for j in range(1,n):
        if l[j][i]=='.':
            continue
        colsum[j][i]+=colsum[j-1][i]
def check(x,y):
    i=x
    j=y
    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1
    if ans==0:
        return []
    return [ans]
h=[[0 for i in range(m+1)]for j in range(n)]
v=[[0 for i in range(m)]for j in range(n+1)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            ans=check(i,j)
            for j1 in ans:
                tot.append([i+1,j+1,j1])
                h[i][j-j1]+=1
                h[i][j+j1+1]-=1
                v[i-j1][j]+=1
                v[i+j1+1][j]-=1
for i in range(n):
    for j in range(1,m):
        h[i][j]+=h[i][j-1]
for i in range(m):
    for j in range(1,n):
        v[j][i]+=v[j-1][i]

for i in range(n):
    for j in range(m):
        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:
            print(-1)
            sys.exit(0)
print(len(tot))
for i in tot:
    print(*i)",quadratic
"n, k = [int(x) for x in input().split()]

ans = """"
while len(ans) < n:
    ans += '1' * ((n - k) // 2) + '0';
ans = ans[:n]
print(ans)",linear
"n=int(input())
l1=list(map(int,input().split()))
if len(list(set(l1)))==1 and l1[0]>0:
    print(1)
else:
    l2=list(set(l1))
    x=l1.count(0)
    if x==0:
        print(len(l2))
    else:
        print(len(l2)-1)",linear
"def binar(a,st,d):
    if st==0:
        return 1

    elif st==1:
        return a%d

    return (   binar(a**2%d,st//2,d) *  binar(a, st%2,d)   )%d

x,k=map(int,input().split())

if x==0:
	print(0)
	exit()

res= ((x*binar(2,k+1,1000000007)) - (binar(2,k,1000000007))+1)% 1000000007
print(res)",logn
"n, k = list(map(int, input().split()))
p = list(map(int, input().split()))
processed = set()
color = {}
length = {}
ans = []

def exists(p, elt, d):
    for e in p:
        if e > elt:
            if e <= elt + d:
                return True
            elif e - d <= elt + d:
                return False
    return False

def exists2(p, elt, d):
    for e in p:
        if e > elt:
            if e <= elt + d:
                return False
            elif e - d <= elt + d:
                return [True, e - d]
    return False

for i in range(n):
    elt = p[i]
    if elt in processed:
        ans.append(color[elt])
    else:
        processed.add(elt)
        new = 1
        run = True
        for j in range(1, k):
            if elt - j < 0:
                break
            elif (elt - j) not in processed:
                processed.add(elt - j)
                new += 1
            elif length[elt - j] + new <= k:
                for i2 in range(length[elt - j] + new):
                    color[elt - i2] = color[elt - j]
                length[elt] = length[elt - j] + new
                run = False
                break
            else:
                break
        if run:
            for j in range(new):
                color[elt - j] = elt - new + 1
            length[elt] = new
s = str(color[p[0]])
for elt in p[1:]:
    s += ' ' + str(color[elt])
print(s)",quadratic
"import sys
import math as mt
import bisect
input=sys.stdin.readline

t=1
def ncr_util():
    inv[0]=inv[1]=1
    fact[0]=fact[1]=1
    for i in range(2,300001):
        inv[i]=(inv[i%p]*(p-p//i))%p
    for i in range(1,300001):
        inv[i]=(inv[i-1]*inv[i])%p
        fact[i]=(fact[i-1]*i)%p
def solve():
    a=1
    b=2*n+3
    c=n+n**2-2*k
    x1=b+int(mt.sqrt(b**2-4*a*c))
    x2=b-int(mt.sqrt(b**2-4*a*c))
    if x1%2==0 and x1//2<=n:
        return x1//2
    return x2//2

for _ in range(t):

    n,k=(map(int,input().split()))

    print(solve())",logn
"n=int(input())
print(int(n/2+1))",constant
"class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = set()
        nums.sort()
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                for k in range(j + 1, len(nums)):
                    if nums[i] + nums[j] + nums[k] == 0:
                        tmp = [nums[i], nums[j], nums[k]]
                        res.add(tuple(tmp))
        return [list(i) for i in res]",cubic
"n,k=map(int,input().split())

if k==(n*(n+1))//2:
    print(0)
else:
    left=0
    right=n
    while left<right:
        mid=(left+right)//2
        candies=(mid*(mid+1))//2
        if candies + mid < k + n:
            left=mid+1
        else:
            right=mid
    print(n-left)",logn
"n = int(input())
a = list(map(int, input().split()))
if n == 1:
	print(a[0])
else:
	prod_minus = False
	for i in range(n - 1):
		if a[i] * a[i + 1] <= 0:
			prod_minus = True
			break
	Min_abs = float(""inf"")
	Sum = 0
	for num in a:
		Sum += abs(num)
		if abs(num) < Min_abs:
			Min_abs = abs(num)

	if prod_minus:
		print(Sum)
	else:
		print(Sum - 2 * Min_abs)",linear
"s = input()
if int(s) < 0:
    k = int(s)/10
    m = s[:len(s)-2]+s[-1]
    print(max(int(k),int(m)))

else:
    print(s)",constant
"tmp = input().split()
n = int(tmp[0])
m = int(tmp[1])

a = list()
b = list()
diff = list()
for i in range(n):
    tmp = input().split()
    a.append(int(tmp[0]))
    b.append(int(tmp[1]))
    diff.append(a[i] - b[i])

diff.sort(reverse=True)

sum_a = sum(a)
i = 0
while sum_a > m and i < n:
    sum_a = sum_a - diff[i]
    i = i + 1

if i >= n and sum_a > m:
    print(-1)
else:
    print(i)",nlogn
"def main():
	n, pos, l, r=tuple(map(int,input().split()))
	time=0
	if l!=1 and r!=n:
		if abs(pos-l)<abs(pos-r):
			time+=abs(pos-l)+abs(l-r)+2
		else:
			time+=abs(pos-r)+abs(l-r)+2
	elif l==1 and r!=n:
		time+=abs(pos-r)+1
	elif r==n and l!=1:
		time+=abs(pos-l)+1
	else:
		time+=0
	print(time)
if __name__=='__main__':
	main()",constant
"class Solution:
    def isHappy(self, n: int) -> bool:
        slow, fast = n, self.sumOfSquares(n)
        power = lam = 1

        while slow != fast:
            if power == lam:
                slow = fast
                power *= 2
                lam = 0
            fast = self.sumOfSquares(fast)
            lam += 1
        return True if fast == 1 else False

    def sumOfSquares(self, n: int) -> int:
        output = 0

        while n:
            digit = n % 10
            digit = digit ** 2
            output += digit
            n = n // 10
        return output",logn
"n,K=map(int,input().split())
b=sorted([int(x)for x in input().split()])
l=cur=0
for i in range(1,n):
    if b[i]==b[i-1]:continue
    if b[i]>b[i-1]+K:l=i
    else:cur+=(i-l);l=i
print(n-cur)",nlogn
"import math

def getdt():
    return map(int,input().split())
def calc(v0,v,a,x):
    t = (v - v0)/a
    x0 = v0 * t + 0.5*a*t*t
    if x0>=x:
        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a)
    return (x0,t)
def go(v0,v,a,x):
    x0,t = calc(v0,v,a,x)
    return t + (x-x0)/v

a,v = getdt()
l,d,w = getdt()
if w>v:
    w = v
x,t = calc(0,w,a,d)
if x==d:
    print(go(0,v,a,l))
else:
    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))",constant
"from os import path
import sys,time

from math import ceil, floor,gcd,log,log2 ,factorial
from collections import *

maxx = float('inf')

I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().replace('\n', '').strip()
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');

n , k= tup()
s = S()

fl =0
l = None
for i in range(1, n):
	x =s[i:n]
	for j in range(n):
		if x == s[:j+1]:
			l = j+1
			fl = 1
			break
	if fl :
		break
if fl :
	ans = s + s[l:n]*(k-1)
	print(ans)
else:
	print(s*k)

if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")",quadratic
"n=int(input())
a=[]
b=[]
for i in range(n):
    a.append(input())
for i in range(n):
    b.append(input())

def h(d):
    c=[]
    for i in range(n):
        c.append(d[n-i-1])
    return c
def r(d):
    c=[]
    for i in range(n):
        temp=""""
        for j in range(n):
            temp+=d[j][n-i-1]
        c.append(temp)
    return c
yes=0
for i in range(4):
    if a==b:
        print('YES')
        yes=1
        break
    a=r(a)
if yes==0:
    a=h(a)
    for i in range(4):
        if a==b:
            print('YES')
            yes=1
            break
        a=r(a)
if yes==0:
    print('NO')",quadratic
"n, k = map(int, input().split())

def prod(n):
	if n%2:
		return n*((n+1)//2)
	else:
		return (n//2)*(n+1)

def total_count(n, k):
	if k >= n:
		return (0, 0, 1)
	else:
		count = 0
		l = 1; r = k
		s = prod(k)
		while l <= r:
			mid = (l+r)//2
			if n > s - prod(mid) + mid:
				r = mid-1
			else:
				l = mid+1

		n = n - (s - prod(l) + l)
		count += (k-l+1)
		k = l-1
		return (n, k, count)

if prod(k) - (k-1) < n:
	print(-1)
elif n == 1:
	print(0)
elif k >= n:
	print(1)
else:
	n = n-k
	k = k-2
	(n, k, count) = total_count(n, k)
	if n:
		print(count+2)
	else:
		print(count+1)",logn
"import sys
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, sys.stdin.readline().strip().split())
def listinput(): return list(map(int, sys.stdin.readline().strip().split()))
n=iinput()
color=['purple','green','blue','orange','red','yellow']
gem=['Power','Time','Space','Soul','Reality','Mind']
for _ in range(n):
    s=input()
    indexofcolor=color.index(s)
    color.remove(s)
    gem.pop(indexofcolor)
print(len(gem))
for i in gem:
    print(i)",constant
"n = int(input())
x, y = list(map(int, input().split()))
d0 = max(x - 1, y - 1)
d1 = max(n - x, n - y)
print('White' if d0 <= d1 else 'Black')",constant
"N, M, K = map(int, input().split())
A = [int(a) for a in input().split()]
S = [0]
for a in A:
    S.append(S[-1]+M*a-K)
MI = [(10**50)] * M
ans = 0
for i in range(N+1):
    MI[i%M] = min(MI[i%M], S[i])
    for j in range(M):
        ans = max(ans, (S[i]-MI[(i-j)%M] - K*((-j)%M))//M)
print(ans)",quadratic
"def main():

    def num(left, right, dp, rev, revI):
        if left > right:
            return 1

        key = left, rev, revI
        if key in dp:
            return dp[key]
        nonlocal ans

        acc = 0

        for x in ('01' if ans[left]=='

            temp = None
            if left == right:
                tmp = x
            elif ans[right]=='
                tmp = '01'
            else:
                tmp = ans[right]

            for y in tmp:
                if not ((rev and x>y) or (revI and x==y=='1')):
                    acc += num(
                        left+1,
                        right-1,
                        dp,
                        rev and x==y,
                        revI and x!=y
                    )
        dp[key] = acc
        return acc

    n, k = map(int, input().split())
    k += 1

    ans = ['

    for i in range(n):
        ans[i] = '0'
        tmp = num(0, n-1, {}, True, True)

        if k > tmp:
            k -= tmp
            ans[i] = '1'

    if ans[0] == '0':
        print(''.join(ans))
    else:
        print(-1)

if __name__ == '__main__':
    import sys, os
    from time import time
    if len(sys.argv)>1 and os.path.exists(sys.argv[1]):
        sys.stdin = open(sys.argv[1], 'rb')
    st = time()
    main()
    print('----- Run {:.6f} seconds. -----'.format(time()-st), file=sys.stderr)",cubic
"k, n, s, p = map(int, input().split())
L = (n - 1) // s + 1
L *= k
print((L - 1) // p + 1)",constant
"def func():
    N = 520
    K = 12
    C = 100 * 1000 + 11
    n, k = [int(x) for x in list(raw_input().split(' '))]
    c = [0 for _ in range(C)]
    f = [0 for _ in range(C)]

    dp = [[0 for _ in range(K*(N))] for _ in range(N)]

    a = [int(x) for x in list(raw_input().split(' '))]
    for x in a:
        c[x] += 1

    b = [int(x) for x in list(raw_input().split(' '))]
    for x in b:
        f[x] += 1

    h = [0]+[int(x) for x in list(raw_input().split(' '))]

    for i in range(n):
        for j in range(n*k + 1):
            for cur in range(k+1):
                dp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur])

    ans = 0
    for i in range(C):
        if f[i] != 0:
            ans += dp[f[i]][c[i]]

    return ans

if __name__ == ""__main__"":
    print(func())",cubic
"import os,sys,math
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192

def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:
        return len(a)

def solve():
    n,m,k=In()
    rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)]
    for i in range(n):
        z=list(In())
        for j in range(m-1):
            rt[i][j]=z[j]
    for i in range(n-1):
        z=list(In())
        for j in range(m):
            do[i][j]=z[j]

    dp=[[0]*m for i in range(n)]
    if k%2==1:
        for i in range(n):
            print(*[-1]*m)
        return
    k//=2
    dp_next=[[P]*m for i in range(n)]
    for op in range(k):
        for i in range(n):
            for j in range(m):
                ans=Inf
                if i!=0:
                    ans=min(ans,dp[i-1][j]+do[i-1][j])
                if j!=0:
                    ans=min(ans,dp[i][j-1]+rt[i][j-1])
                if i!=n-1:
                    ans = min( ans , dp[i+1][j]+do[i][j])
                if j!=m-1 :
                    ans=min( ans , dp[i][j+1]+rt[i][j])
                dp_next[i][j]=ans

        for i in range(n):
            for j in range(m):
                dp[i][j]=dp_next[i][j]

    for i in range(n):
        for j in range(m):
            print(2*dp[i][j],end=' ')
        print()

def main():
    T=1
    for i in range(T):
        solve()

M = 998244353
P = 1000000007
Inf=float('inf')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

def print(*args, **kwargs):

    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",cubic
"a=[int(x) for x in input().split()]
n=a[0]^a[1]
x=bin(n)[2:]

f=0
for i in range(len(x)):
    if x[i]=='1':
        f=1
        break
l=len(x)-i
sum=0
for i in range(l):
   sum+=2**i
if f==0:
    sum=0
print(sum)",logn
"import sys
if __name__=='__main__':

    numCases = int(sys.stdin.readline())
    for i in range(numCases):
        a, b = sys.stdin.readline().split()
        a = int(a)
        b = int(b)
        total = 0
        largerNum = max(a,b)
        smallerNum = min(a,b)
        while True:
            div = int(largerNum/smallerNum)
            total += div
            rem = int(largerNum%(smallerNum*div))
            if rem == 0:
                break
            else:
                largerNum = smallerNum
                smallerNum = rem

        print(total)",constant
"n, m = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))

if max(b) > min(g):
    print(-1)
else:
    total = m*sum(b)
    b.sort()
    g.sort()
    while len(g) > 0:
        current = 0
        count = 1
        if len(b) > 0:
            current = b.pop()
        while len(g) > 0 and g[-1] > current and count < m:
            total += g[-1] - current
            g.pop()
            count += 1
        while len(g) > 0 and g[-1] == current:
            g.pop()
    print(total)",nlogn
"n=int(input())
a=list(map(int,input().split()))
grip=[[-1]*(n-i) for i in range(n)]
grip[0]=a.copy()
for level in range(1,n):
    for left in range(n-level):
        for split in range(level):
            pl=grip[level-split-1][left]
            pr=grip[split][left+level-split]
            if pl==pr!=-1:
                grip[level][left]=pl+1
pref=[0]*(n+1)
for p in range(1,n+1):
    x=n
    for j in range(p):
        l=pref[j]
        r=grip[p-j-1][j]
        if r==-1:
            r=p-j
        else:
            r=1
        x=min(x,l+r)
    pref[p]=x
print(pref[-1])",cubic
"lst = list()

lst.append(0)
lst.append(1)

now = 1
while now <= 1e25 :
	now = now * 4 + 1

	lst.append(now)

t = int(input())

for i in range(t):
	s = input().split()
	n = int(s[0])
	k = int(s[1])
	if(n >= 34):
		print(""YES "" + str(n - 1))
		continue

	sek = 0
	ambil = 1
	nyak = 0
	cnt = 0

	sudah = False
	while (sek < n):
		cnt = cnt + (1 << (sek + 1)) - 1

		if cnt > k:
			print(""NO"")
			sudah = True
			break

		next_ambil = (ambil + 1) * 2 - 1
		sisa = 4 * ambil - next_ambil
		ambil = next_ambil

		sek += 1
		nyak = nyak + sisa * lst[n - sek]
		if (nyak + cnt) >= k :
			print(""YES "" + str(n - sek))
			sudah = True
			break

	if sudah == False:
		print(""NO"")",linear
"n = int(input())
arr = [int(x) for x in input().split()]
x = arr.index(max(arr))
cur = max(arr)
l = x - 1
r = x + 1
ok = 1
for i in range(n - 1):
    if l < 0:
        ok *= (arr[r] < cur)
        cur = arr[r]
        r += 1
    elif r >= n:
        ok *= (arr[l] < cur)
        cur = arr[l]
        l -= 1
    else:
        if arr[l] > arr[r]:
            ok *= (arr[l] < cur)
            cur = arr[l]
            l -= 1
        else:
            ok *= (arr[r] < cur)
            cur = arr[r]
            r += 1
print(""YES"" if ok else ""NO"")",linear
"import os
import sys

from collections import *

from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

def ok(here):

    have = defaultdict(lambda : -1)
    for j in range(n):
        b = a[j]
        s = ''
        for i in b:
            if(i>=here): s+='1'
            else: s+='0'
        have[int(s,2)] = j

    for i in range(300):
        for j in range(300):
            if(i|j == 2**m-1 and have[i]!=-1 and have[j]!=-1): return (have[i]+1,have[j]+1)

    return -1

n,m = value()
a = []

for i in range(n): a.append(array())

low = 0
high = 10**9

while(low<=high):

    mid = low + (high - low)//2
    here = ok(mid)

    if(here != -1):
        ans = here
        low = mid+1
    else:
        high = mid - 1

print(*ans)",np
"n,m,k = [int(y) for y in input().split()]
a = [int(y) for y in input().split()]
a.sort(reverse=True)
no = 0
while k < m and no < n:
    k += a[no]-1
    no += 1
if k < m:
    print(-1)
else:
    print(no)",nlogn
"n = int(input())
print([""YES"", ""NO""][all(n % i for i in [4, 7, 47, 744, 477])])",constant
"import sys
input = sys.stdin.readline

MAXN = 202

def main():
    R, G, B = list(map(int, input().split()))
    r = list(map(int, input().split()))
    g = list(map(int, input().split()))
    b = list(map(int, input().split()))
    r.sort()
    g.sort()
    b.sort()
    dp = [[[0]*MAXN for _ in range(MAXN)] for _ in range(MAXN)]
    for i in range(1, R+1):
        for j in range(1, G+1):
            dp[i][j][0] = r[i-1]*g[j-1]+dp[i-1][j-1][0]
    for i in range(1, R+1):
        for k in range(1, B+1):
            dp[i][0][k] = r[i-1]*b[k-1]+dp[i-1][0][k-1]
    for j in range(1, G+1):
        for k in range(1, B+1):
            dp[0][j][k] = g[j-1]*b[k-1]+dp[0][j-1][k-1]
    for i in range(1, R+1):
        for j in range(1, G+1):
            for k in range(1, B+1):
                dp[i][j][k] = max(r[i-1]*g[j-1]+dp[i-1][j-1][k], r[i-1]*b[k-1]+dp[i-1][j][k-1], g[j-1]*b[k-1]+dp[i][j-1][k-1])
    print(dp[R][G][B])

main()",cubic
"import sys
input = sys.stdin.readline
n,k=map(int,input().split())
A=[int(i) for i in input().split()]
B=[]
for i in range(1,n):
  B.append(A[i]-A[i-1])
B.sort()
print(sum(B[:n-k]))",nlogn
"n,q = map(int, raw_input().split())
nums = list(map(int, raw_input().split()))

m = max(nums)

ab = []
while nums[0] < m:
    ab.append([nums[0], nums[1]])
    nums.append(nums.pop(1)) if nums[0]>nums[1] else nums.append(nums.pop(0))

for i in range(q):
    mj = int(input())
    a, b = map(str, ab[mj-1] if mj <= len(ab) else (m, nums[(mj-len(ab)-1)%(len(nums)-1) +1]))
    print(a + "" "" + b)",linear
"import sys
input = sys.stdin.readline

def main():
    n = int(input())
    alst = [int(input()) for _ in range(n)]
    ans = []
    for a in alst:
        if a == 1:
            ans.append(""1"")
            print(""."".join(ans))
            continue
        while ans and int(ans[-1]) != a - 1:
            ans.pop()
        if not ans:
            ans.append(str(a))
        else:
            ans.pop()
            ans.append(str(a))

        print(""."".join(ans))

for _ in range(int(input())):
    main()",quadratic
"from sys import stdin

add = lambda a, b: (a % mod + b % mod) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, i * 2 + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])

print(sum(mem[-1][k]) % mod)",np
"ma = {0:1}
n, m = [int(x) for x in input().split()]
arr  = [int(x) for x in input().split()]
s, fla, ans=0,False,0
for v in arr:
    if v == m: fla = True
    elif v < m: s-= 1
    elif v > m: s+= 1
    if fla:
        ans += ma.get(s, 0) + ma.get(s-1, 0)
    else:
            ma[s] = ma.get(s, 0) + 1
print(ans)",nlogn
"import sys

f = sys.stdin

def line():
    return f.readline().strip().split()

def powers(limit):
    size = limit+1
    p = [1]*size
    for n in range(1,size):
        p[n] = (2*p[n-1]) % M

    return p

def binomials(limit):
    size = limit+1
    bc = [[0 for k in range(size)] for n in range(size)]
    for n in range(size):
        bc[n][0]=1

    for n in range(1,size):
        for k in range(1,n+1):
            bc[n][k] = bc[n-1][k-1] + bc[n-1][k]
            bc[n][k] %= M

    return bc

def solve():

    size = N+1
    dp = [[0 for _ in range(size)] for _ in range(size)]
    dp[1][0]=1

    for i in range(2,size):
        for k in range(1,i):
            for j in range(1,k):
                dp[i][j] += BC[i-j][k-j] * dp[k-1][j-1] * POW[i-k-1]
                dp[i][j] %= M
        dp[i][0] = POW[i-1]

    res=0
    for j in range(0,N-1):
        res = (res + dp[N][j]) % M

    return str(res)

T = 1
for test in range(1,T+1):
    N,M = map(int,line())

    BC = binomials(N)
    POW = powers(N)

    print(solve())

f.close()",cubic
"def formula(n, x):
    return x*(x + 1)//2 - (n-x)

def solve():
    n, k = map(int, input().split())
    l = 1
    r = n
    x = 0
    while l <= r:
        x = (l+r)//2
        res = formula(n, x)
        if res == k:
            break
        elif res < k:
            l = x + 1
        else:
            r = x - 1
    print(n-x)
    return

solve()",logn
"def f(a, ind):
    if a[ind] == 0:
        return -1
    k = a[ind] // 14
    x = a[ind] % 14
    b = a[:]
    b[ind] = 0
    for j in range(14):
        b[j] += k
    for j in range(ind + 1, ind + x + 1):
        j1 = j % 14
        b[j1] += 1
    res = 0
    for j in range(14):
        if b[j] % 2 == 0:
            res += b[j]
    return res
a = list(map(int, input().split()))
ans = 0
for i in range(14):
    cur = f(a, i)
    ans = max(ans, cur)
print(ans)",constant
"n = int(input())
rang = list(range(2,n//2+1))
a = [i*(n//i-1) for i in rang]
print(sum(a)*4)",linear
"n = int(input())

t = list(map(int,input().split()))

p = sum(t)
import math

a = math.ceil(p/2)

u=0
for j in range(n):
    u+=t[j]
    if u>=a:
        print(j+1)
        break",linear
"import sys
N, M = map(int, input().split())

Ans = [None]*(N*M)
for i in range(1, N*M+1):
    if i % 2:
        a, b = divmod(i//2, M)
    else:
        a, b = divmod(N*M - i//2, M)
    Ans[i-1] = (a+1, b+1)
for a in Ans:
    sys.stdout.write('{} {}\n'.format(*a))",quadratic
"def find(A):
    from collections import defaultdict
    A=sorted(A)
    N=len(A)
    dic=defaultdict(int)
    for i in range(N):
        dic[A[i]]+=1

    checked=[]
    count=set([])
    for x in A:
        if dic[x]>2:
            return ""cslnb""
        if dic[x]==2:
            count.add(x)
            y=x-1
            if y in dic:
                return ""cslnb""
    if len(count)>1:
        return ""cslnb""

    if 0 in count:
        return ""cslnb""

    temp=0
    for i in range(N):
        temp+=A[i]-i
    if temp%2==1:
        return ""sjfnb""
    return ""cslnb""
input()
A=list(map(int,input().strip().split(' ')))
print(find(A))",nlogn
"line = input().split()
l = int(line[0])
r = int(line[1])

diff = (r ^ l)
print(pow(2, diff.bit_length()) - 1)",logn
"n = int(input())
x, y = map(int, input().split())
na = abs(x - 1) + abs(y - 1)
nb = abs(n - x) + abs(n - y)
if na <= nb:
    print(""white"")
else:
    print(""black"")",constant
"n = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
k = n[2]
ans = 0
dele = 1
i = 0
while(i<n[1]):
	count = 1
	while(((i+count)<n[1]) and (a[(i+count)]-dele)//k == (a[i]-dele)//k):
		count += 1

	ans += 1
	dele += count
	i += count
print(ans)",linear
"n, k = map(int, input().split())
a = list(map(int, input().split()))
ans = a[-1] - a[0]
delta = [-a[i] + a[i - 1] for i in range(1, n)]
delta.sort()
ans += sum(delta[:(k-1)])
print(ans)",nlogn
"def f(n):
    return n + n//2

n = int(input())
print(f(n))",constant
"import sys
readline = sys.stdin.readline

k = list(map(int, readline().split()))

ans = 'NO'
if min(k) == 1 or k.count(2) >= 2 or k.count(3) >= 3 or (k.count(4) == 2 and k.count(2) == 1):
    ans = 'YES'

print(ans)",constant
"n, p = map(int, input().split())

arr = [int(b) for b in input().split()]

res = []

prefsums = [arr[0]]

for i in range(1, n):
    prefsums.append(prefsums[i - 1] + arr[i])

allsum = sum(arr)

if len(arr) == 2:
    print(arr[0] % p + arr[1] % p)
    exit()

for i in range(1, n - 1):
    res.append((prefsums[i] % p) + ((allsum - prefsums[i]) % p))

print(max(res))",linear
"a=input()
b=int(a)+1
if b==1 :
    print(""0"")
elif b%2==0 :
    print(b//2)
elif b%2!=0 :
    print(b)",constant
"x, y, z, t1, t2, t3 = map(int, input().split())
stair = t1 * abs(x - y)
lift = t2 * (abs(z - x) + abs(x - y)) + t3 * 3
print(""YES"" if lift <= stair else ""NO"")",constant
"n = int(input())
ar = []
for i in range(n):
    ar.append(input())
sortedAr = sorted(ar,key=len)
flag = False
for i in range(n-1):
    if sortedAr[i+1].find(sortedAr[i]) == -1:
        print('NO')
        flag = True
        break
if not flag:
    print('YES')
    for i in sortedAr:
        print(i)",nlogn
"n, m, k = list(map(int, input().split()))
a = list(map(int, input().split()))
ret = 0
for i in range(m):
	cur = 0
	for j in range(i, n):
		if j % m == i:
			cur = max(0, cur)
			cur -= k
		cur += a[j]
		ret = max(ret, cur)
print(ret)",quadratic
"from collections import deque as de
import math
from collections import Counter as cnt
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()

def isPrime(n) :

	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):

    prime_factors = []

    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2

    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic

n=int(input())
pp=n
nn=n

pl=[]
nl=[]
while pp:
    pp-=1
    pl.append(input())
while nn:
    nn-=1
    nl.append(input())
ans=0
pmc=pl.count(""M"")
mc=nl.count(""M"")
if pmc < mc:
    ans+=mc -pmc
psc=pl.count(""S"")
sc=nl.count(""S"")
if psc < sc:
    ans+=sc -psc

plc=pl.count(""L"")
lc=nl.count(""L"")
if plc < lc:
    ans+=lc -plc

pxlc=pl.count(""XL"")
xlc=nl.count(""XL"")
if pxlc < xlc:
    ans+=xlc -pxlc

pxxlc=pl.count(""XXL"")
xxlc=nl.count(""XXL"")
if pxxlc < xxlc:
    ans+=xxlc -pxxlc

pxxxlc=pl.count(""XXXL"")
xxxlc=nl.count(""XXXL"")
if pxxxlc < xxxlc:
    ans+=xxxlc -pxxxlc

pxsc=pl.count(""XS"")
xsc=nl.count(""XS"")
if pxsc < xsc:
    ans+=xsc -pxsc

pxxsc=pl.count(""XXS"")
xxsc=nl.count(""XXS"")
if pxxsc < xxsc:
    ans+=xxsc -pxxsc

pxxxsc=pl.count(""XXXS"")
xxxsc=nl.count(""XXXS"")
if pxxxsc < xxxsc:
    ans+=xxxsc -pxxxsc
print(ans)",linear
"from sys import stdin, stdout
import sys
input=sys.stdin.readline

def solve(n, t, tasks):
    lo = 0
    hi = n

    res = []
    curr_res = 0

    tasks.sort(key=lambda x: x[1])

    while lo <= hi:
        mid = lo + (hi - lo) // 2

        valid_tasks = []
        for i in tasks:
            if i[0] >= mid:
                valid_tasks.append(i)

        can_do = False

        curr_sum = 0
        total_used = 0
        r = []
        for i in valid_tasks:
            curr_sum += i[1]
            total_used += 1
            r.append(i[2])
            if curr_sum > t:
                break
            elif total_used >= mid:
                can_do = True
                curr_res = mid
                res = r
                break
        if can_do:
            lo = mid + 1
        else:
            hi = mid - 1
    return curr_res, res

def main():
    n, t = (int(x) for x in input().split("" ""))
    tasks = []
    nums = n
    idx = 1
    while n:
        a_i, t_i = (int(x) for x in input().split("" ""))
        tasks.append((a_i, t_i, idx))
        idx += 1
        n -= 1

    res, res_arry = solve(nums, t, tasks)
    print(res)
    print(res)
    stdout.write("" "".join(map(str, res_arry)))
    stdout.write(""\n"")

if __name__ == ""__main__"":
    main()",nlogn
"import sys
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

n, m = map(int, input().split())

MAX = 0
MIN = 10**18
for i in range(n):
    l = i*(i+1)//2
    r = (n-1-i)*(n-1-i+1)//2
    MAX= max(MAX, l+r)
    MIN = min(MIN, l+r)

ans = 0
for i in range(m):
    x, d = map(int, input().split())
    ans += n*x
    if d  >= 0:
        ans += d*MAX
    else:
        ans += d*MIN
print(ans/n)",linear
"import os
import sys
from io import BytesIO, IOBase

def main():
    n,k = map(int, input().split())
    l = list(map(int, input().split()))
    d = dict()
    c = set()
    l.sort()
    for i in range (n):
        if not d.get(l[i]):
            c.add(l[i])
            d.setdefault(l[i]*k,1)
    print(len(c))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",nlogn
"def solve():
    n = int(input())
    for d in [2,4]:
        if n % d != 0:
            continue
        temp = int((n//d) ** (0.5))
        temp -= 1
        while temp*temp < n//d:
            temp += 1
        if temp*temp == n//d:
            print(""YES"")
            return
    print(""NO"")
for _ in range(int(input())):
    solve()",constant
"import sys

sys.setrecursionlimit(10**5)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
inf = 10**16
md = 10**9+7

trie = [{}]

def push(s, val):
    now = 0
    for c in s:
        if c not in trie[now]:
            trie[now][c] = len(trie)
            trie.append({})
        now = trie[now][c]
    trie[now][""end""] = val

def match(s):
    res = []
    stack = [(0, 0)]
    while stack:
        u, i = stack.pop()
        if i == k:
            res.append(trie[u][""end""])
            continue
        if s[i] in trie[u]:
            stack.append((trie[u][s[i]], i+1))
        if ""_"" in trie[u]:
            stack.append((trie[u][""_""], i+1))
    return res

n, m, k = MI()
for i in range(n):
    push(SI(), i)

to = [[] for _ in range(n)]
for _ in range(m):
    s, u = SI().split()
    u = int(u)-1
    vv = match(s)

    notmatch = True
    for v in vv:
        if u == v: notmatch = False
        else: to[u].append(v)
    if notmatch:
        print(""NO"")
        exit()

vis=[-1]*n
topo=[]
for u in range(n):
    if vis[u]==1:continue
    stack=[u]
    while stack:
        u=stack.pop()
        if vis[u]==-1:
            vis[u]=0
            stack.append(u)
            for v in to[u]:
                if vis[v]==0:
                    print(""NO"")
                    exit()
                if vis[v]==-1:
                    stack.append(v)
        elif vis[u]==0:
            topo.append(u+1)
            vis[u]=1

print(""YES"")
print(*topo[::-1])",np
"cs = int(input())

for c in range(cs):
    l, r = map(int, input().split())

    if l%2 == 0 and r%2 == 0:
        print((r - l) // 2 + l)
    if l%2 == 1 and r%2 == 0:
        print((r - l + 1) // 2)
    if l%2 == 0 and r%2 == 1:
        print(-(r - l + 1) // 2)
    if l%2 == 1 and r%2 == 1:
        print(-(r - l) // 2 - l)",constant
"from sys import stdin,stdout
from math import gcd,sqrt,factorial,pi,inf
from collections import deque,defaultdict
from bisect import bisect,bisect_left
from time import time
from itertools import permutations as per
from heapq import heapify,heappush,heappop,heappushpop
input=stdin.readline
R=lambda:map(int,input().split())
I=lambda:int(input())
S=lambda:input().rstrip('\r\n')
L=lambda:list(R())
P=lambda x:stdout.write(str(x)+'\n')
lcm=lambda x,y:(x*y)//gcd(x,y)
nCr=lambda x,y:(f[x]*inv((f[y]*f[x-y])%N))%N
inv=lambda x:pow(x,N-2,N)
sm=lambda x:(x**2+x)//2
N=10**9+7

n,k=R()
s=0
for i in range(k):
	x,d=R()
	s+=n*x
	if d<0:
		s+=sm(n//2)*d+sm(n//2-(n+1)%2)*d
	else:
		s+=sm(n-1)*d
print(s/n)",linear
"import os
import sys
from io import BytesIO, IOBase

def main():
    n, m = map(int, input().split())
    a = [list(map(int, input().split())) for i in range(n)]
    ans = []
    le = 0
    ri = int(1e9)

    def check(mid: int) -> bool:
        nonlocal ans
        dic = {}
        for i in range(n):
            bit = 0
            for j in range(m):
                if a[i][j] >= mid:
                    bit += 1
                bit <<= 1
            dic[bit >> 1] = i
        for x, idx in dic.items():
            for y, idy in dic.items():
                if x | y == 2**m-1:
                    ans = idx + 1, idy + 1
                    return True
        return False
    while le <= ri:
        mid = (le + ri) >> 1
        if check(mid):
            le = mid + 1
        else:
            ri = mid - 1
    print(ans[0], ans[1])

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",np
"import bisect
import copy
import decimal
import fractions
import heapq
import itertools
import math
import random
import sys
from collections import deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap,0,len(heap)-1)
from math import gcd as Gcd
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,readline().split())
S=[readline().rstrip() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",quadratic
"def main():
    n, k = map(int, input().split(' '))

    if(k > 2*n):
        return(0)
    if(k == 2*n or k==1):
        return(2)

    iguales = [0]*(k+1)
    diferentes = [0]*(k+1)

    iguales[1] = 2
    diferentes[2] = 2

    modulo = 998244353

    for i in range(1, n):
        auxigual, auxdiff = [0]*(k+1), [0]*(k+1)
        for j in range(k):
            auxigual[j+1] = (iguales[j+1] + iguales[j] + 2*diferentes[j+1]) % modulo
            if(j >= 1):
                auxdiff[j+1] = (diferentes[j+1] + diferentes[j-1] + 2*iguales[j]) % modulo

        iguales = auxigual
        diferentes = auxdiff

    return((iguales[-1] + diferentes[-1]) % modulo)

print(main())",np
"def main():
    def calc(x):
        if x & 1:
            return -x + calc(x - 1)
        return x // 2
    n = int(input())
    for i in range(n):
        a, b = map(int, input().split())
        print(calc(b) - calc(a - 1))

main()",constant
"import sys,math

def read_int():
	return int(sys.stdin.readline().strip())

def read_int_list():
	return list(map(int,sys.stdin.readline().strip().split()))

def read_string():
	return sys.stdin.readline().strip()

def read_string_list(delim="" ""):
	return sys.stdin.readline().strip().split(delim)

k = read_int()

base_digit_number = 1; expo = 0

while k >= base_digit_number:
	base_digit_number += 9*(expo+1)*(10**expo)
	expo += 1

base_digit_number -= 9*(expo)*(10**(expo-1))

ans_number = (k - base_digit_number)//expo + 10**(expo-1)

ans_digit = str(ans_number)[(k - base_digit_number)%expo]

print(ans_digit)",logn
"a, b = sorted(input()), int(input())
for i in range(len(a)):
	for j in range(i+1, len(a)):
		c = int(str.join('', a))
		a[i], a[j] = a[j], a[i]
		d = int(str.join('', a))
		if c <= d <= b:
		    continue
		else:
		    a[i], a[j] = a[j], a[i]
print(str.join('', a))",cubic
"print(""? 0 0"")
t = int(input())
A=[]
B=[]
a=0
b=0
for i in range(30):
    A.append(-1)
    B.append(-1)
i = 29
d = 2**i
while i>=0:
    a+=d
    b+=d
    print(""?"", end=' ')
    print(a, end=' ')
    print(b)
    s=int(input())
    if s == -t:
        if s==1:
            A[i]=0
            B[i]=1
            b-=d
            print(""?"", end=' ')
            print(a, end=' ')
            print(b)
            t=int(input())
        elif s==-1:
            A[i]=1
            a-=d
            B[i]=0
            print(""?"", end=' ')
            print(a, end=' ')
            print(b)
            t=int(input())
    i-=1
    d//=2
d=1
for j in range(30):
    if A[j]==-1:
        a = a^d
        print(""?"", end=' ')
        print(a, end=' ')
        print(b)
        s = int(input())
        if s==1:
            A[j]=1
            B[j]=1
        else:
            A[j]=0
            B[j]=0
        a = a^d
    d*=2
d=1
a=0
b=0
for i in range(30):
    a+=d*A[i]
    b+=d*B[i]
    d*=2
print(""!"", end=' ')
print(a, end=' ')
print(b)",constant
"n = int(input())

a = input().split()

for i in range(n):
    a[i] = int(a[i])

if(n==1):
    print(a[0])
else:
    sm = 0
    havePositive = False
    haveNegative = False

    for c in a:
        if(c==0):
            haveNegative = True
            havePositive = True
        elif(c>0):
            havePositive = True
            sm += c
        else:
            haveNegative = True
            sm -= c

    if(haveNegative and havePositive):
        print(sm)
    else:
        for i in range(n):
            a[i] = abs(a[i])

        ans = sum(a)
        low = a[0]
        for c in a:
            low = min(low,c)

        print(ans-2*low)",linear
"n = int(input())+1
print(0 if not (n-1) else n//2 if not n&1 else n)",constant
"d = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"",""orange"":""Soul"", ""red"":""Reality"",""yellow"":""Mind""}

i = int(input())
l = []
for x in range(i):
    d.pop(input())

print(len(d))
for i in d.values() : print(i)",constant
"n=int(input())
a=list(map(int,input().split()))
a.sort()

total_money=sum(a)
i_have=0
reaming=total_money-i_have
cnt=0
for i in range(n-1,-1,-1):
    reaming=total_money-i_have
    if i_have>reaming:
        break
    i_have+=a[i]
    cnt+=1
print(cnt)",nlogn
"n = int(raw_input())
a = list(raw_input())
b = list(raw_input())

ans = 0

for i in range(n - 1):
    if a[i] == b[i]:
        continue
    if a[i + 1] == b[i + 1]:
        continue

    if a[i] == b[i + 1] and a[i + 1] == b[i]:
        a[i], a[i + 1] = a[i + 1], a[i]
        ans += 1

for i in range(n):
    ans += a[i] != b[i]

print(ans)",linear
"n,a,b,c,T=map(int,input().split())
arr=list(map(int,input().split()))
Tcnt=arr.count(T);l=n-Tcnt;ans=0;a1=0
for i in range(1,T):
  for j in range(n):
    if arr[j]<=i:a1+=1

  ans+=a1*c;a1=0
b1=0

for i in range(n):
  b1=a-((T-arr[i])*b)
  if b1<=0:ans+=b1;
  else:ans+=b1
ans1=n*a
print(max(ans,ans1))",linear
"n = int(input())
a = list(map(int,input().split()))
cost = list(map(int,input().split()))
ans  = float(""inf"")
for i in range(n):
    m,r = float(""inf""),float(""inf"")
    for j in range(i):
        if a[j]<a[i]:
            m = min(m,cost[j])
    for k in range(i+1,n):
        if a[k]>a[i]:
            r = min(r,cost[k])
    ans = min(ans,cost[i]+m+r)
print(ans if ans!=float(""inf"") else -1)",quadratic
"import math
from decimal import Decimal, ROUND_FLOOR

def sum2(s, e):
    return sum1(e) - sum1(s - 1) - (e - s)

def sum1(i):
    return i * (i + 1) / 2

n, k = map(Decimal, input().split())

if(n == 1):
    print(0)
elif(k > n):
    print(1)
elif(sum2(Decimal(2),k) < n):
    print(-1)
else:
    c = 2 * n + k - k * k
    discriminant = (9 - 4 * c).sqrt()
    res1 = int(((3 + discriminant) / 2).to_integral_exact(rounding=ROUND_FLOOR))
    res2 = int(((3 - discriminant) / 2).to_integral_exact(rounding=ROUND_FLOOR))
    res1 = max(res1, res2)
    print(k - res1 + 1);",logn
"dic = {'purple':'Power', 'green':'Time','blue':'Space','orange':'Soul','red':'Reality','yellow':'Mind'}
n = int(input())
a = []
for i in range(n):
    a.append(input())
print(6-len(a))
for i in dic:
    if i not in a:
        print(dic[i])",constant
"import os, sys
from io import BytesIO, IOBase

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class dict(dict):
    def __missing__(self, key):
        return 0

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
valid = lambda x, y: -1 < x < n and -1 < y < m
dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)

n, m, k = inp(int)
if k & 1:
    [print(*([-1] * m)) for _ in range(n)]
    exit()

right, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]
mem = [[[float('inf')] * (k // 2 + 1) for _ in range(m + 1)] for _ in range(n + 1)]

for _ in range(n):
    for i, j in enumerate(inp(int)):
        right[_][i] = j

for _ in range(n - 1):
    for i, j in enumerate(inp(int)):
        down[_][i] = j

for i in range(n):
    for j in range(m):
        mem[i][j][0] = 0

for k1 in range(1, k // 2 + 1):
    for i in range(n):
        for j in range(m):
            ans = []
            ans.append(mem[i - 1][j][k1 - 1] + down[i - 1][j])
            ans.append(mem[i + 1][j][k1 - 1] + down[i][j])
            ans.append(mem[i][j - 1][k1 - 1] + right[i][j - 1])
            ans.append(mem[i][j + 1][k1 - 1] + right[i][j])
            mem[i][j][k1] = min(ans)

[print(*[mem[i][x][-1] * 2 for x in range(m)]) for i in range(n)]",cubic
"n,l,r,d=[int(i) for i in input().split()]
op=[int(i) for i in input().split()]
c=0
for i in range(2,2**n):
    s=0
    k=0
    maxx=0
    minn=1000001
    x=bin(i)[2:]
    x='0'*(n-len(x))+x
    for j in range(n):
        if x[j]=='1':
            s+=op[j]
            k+=1
            if maxx<op[j]:
                maxx=op[j]
            if op[j]<minn:
                minn=op[j]
    if l<=s<=r and maxx-minn>=d and k>=2:
        c+=1
print(c)",np
"n = int(input())
n = n + n//2

print(n)",constant
"n,m=[int(x) for x in input().split()]
a=[int(x) for x in input().split()]
s=sum(a)
need=0
a.sort()
j=1
flag=0
k=max(a)
if n==1:
    print(0)
else:
    for i in range(n):
        if a[i]<j:
            flag=1
        else:
            flag=0
        if a[i]==1:
            need+=1
        elif a[i]>=j and i!=n-1:
            need+=1
        elif a[i]>=j and i==n-1 and j<=k:
            need+=k-j+1
        else:
            need+=1
        if flag!=1:
            j+=1
    print(s-need)",nlogn
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

n,m = map(int, input().split())
a = []
for i in range(n):
    ai = list(map(int, input().split()))
    a.append(ai)

def check(mid):
    mask = (1<<m)-1
    s = set()
    d = dict()
    for i in range(n):
        state = 0
        for j in range(m):
            if a[i][j] >= mid:
                state += 1<<j
        if state in s:
            continue
        s.add(state)
        k = state
        while k>=0:
            k &= state
            d[k] = i
            k -= 1
        need = mask^state
        if need in d:
            q1, q2 = d[need], i
            if q1 > q2:
                q1, q2 = q2, q1
            return True, (q1, q2)
    return False, (-1, -1)

left = 0
right = 10**9+1
i,j = 0, 0
while right-left>1:
    mid = (right+left)//2
    flag, (q1, q2) = check(mid)
    if flag:
        left = mid
        i,j = q1, q2
    else:
        right = mid
print(i+1, j+1)",np
"def maximum_candies_after_n_movies(n):
    return n * (n + 1) // 2

def solve1():
    n,k = list(map(lambda x: int(x), input().split()))
    m = maximum_candies_after_n_movies(n)
    current_candies = n
    eaten_candies = 0
    while m != k:
        m = m - current_candies - 1
        current_candies -= 1
        eaten_candies += 1

    print(eaten_candies)

def solve():
    n, k = list(map(lambda x: int(x), input().split()))
    upper_bound = n
    lower_bound = 0
    while upper_bound > lower_bound:
        if upper_bound == lower_bound + 1:
            u_c = maximum_candies_after_n_movies(upper_bound)
            if u_c == k:
                print(n - upper_bound)
                break

        middle = (upper_bound + lower_bound) // 2
        m_candies = maximum_candies_after_n_movies(middle) - (n - middle)
        if m_candies == k:
            print(n - middle)
            break
        elif m_candies < k:
            lower_bound = middle
        else :
            upper_bound = middle

solve()",logn
"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        for i in range(len(numbers)):
            l, r = i + 1, len(numbers) - 1
            tmp = target - numbers[i]
            while l <= r:
                mid = l + (r - l)//2
                if numbers[mid] == tmp:
                    return [i + 1, mid + 1]
                elif numbers[mid] < tmp:
                    l = mid + 1
                else:
                    r = mid - 1
        return []",nlogn
"import os
import sys
from io import BytesIO, IOBase
import heapq as h
from bisect import bisect_left

from types import GeneratorType
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

import time
start_time = time.time()

import collections as col
import math, string
from functools import reduce

def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())

def solve():
    L, R = getInts()
    if L == R:
        return 0
    l = len(bin(L)[2:])
    r = len(bin(R)[2:])
    while l == r:
        L -= pow(2,r-1)
        R -= pow(2,r-1)
        l = len(bin(L)[2:])
        r = len(bin(R)[2:])
    return pow(2,r)-1

print(solve())",logn
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        dp = [False] * n
        dp[-1] = True

        for i in range(n - 2, -1, -1):
            end = min(n, i + nums[i] + 1)
            for j in range(i + 1, end):
                if dp[j]:
                    dp[i] = True
                    break
        return dp[0]",quadratic
"n=int(input())
ans=0
for i in range(2,n+1):
	for j in range(2*i,n+1,i):
		ans+=(4*(j//i))
print(ans)",nlogn
"n, m = map(int, input().split())
sun, su, ans = 0, 0, 0
dif = []
for i in range(n):
    a, b = map(int, input().split())
    sun += a; su += b
    dif.append(a - b)
if(su > m):print(-1)
elif(sun == m):print(0)
else:
    dif.sort()
    j = n - 1
    while(sun > m):
        sun -= dif[j]
        ans += 1
        j -= 1
    print(ans)",nlogn
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc=ri()
    for _ in range(tc):
        n=ri()
        a=ria()
        d=Counter(a)
        a=sorted(list(set(a)))
        s=[]
        c=0
        for i in a:
            if d[i]>=4:
                c=1
                print(i,i,i,i)
                break
            if d[i]>=2:
                s.append(i)
        if c==0:
            lx=9999999999999999999999999999999
            bx=1
            for i in range(len(s)-1):
                l=s[i+1]
                b=s[i]
                if l*bx<lx*b:
                    lx=l
                    bx=b
            print(lx,lx,bx,bx)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()",nlogn
"import math
def nCr(n,r):
	f = math.factorial
	return f(n) / f(r) / f(n-r)
dict1 = {'+':0,'-':0,'?':0}
for i in input():
	dict1[i]+=1
for i in input():
	if(i=='?'):
		dict1[i]+=1
	else:
		dict1[i]-=1
if dict1['+']<0 or dict1['-']<0:
	print(0.000000000000)
elif dict1['+']==0 and dict1['-']==0:
	print(1.000000000000)
elif dict1['+'] and dict1['-']:
	ans = (nCr(dict1['?'], dict1['+'])/(2**dict1['?']))
	print(""%.12f"" %ans)
else:
	ans = (1 / (2 ** dict1['?']))
	print(""%.12f"" % ans)",np
"n = int(input())
b = list(map(int, input().split(' ')))

a = [0] * n

minV = 0
maxV = b[0]

m = n //2

a[n - 1] = b[0]

i = 1
j = n - 2

while(i < m):
  if(b[i] - minV > 0 and b[i] - minV <= maxV):
    a[i] = minV
    a[j] = b[i] - minV
    maxV = min(maxV, b[i] - minV)
  else:
    a[i] = b[i] - maxV
    a[j] = maxV
    minV = max(minV, b[i] - maxV)

  i += 1
  j -= 1

print(' '.join(map(str, a)))",linear
"from collections import defaultdict
from sys import stdin

input = stdin.readline

dct = defaultdict(int)
n = int(input())
lst = [0] * n
for i in range(n):
    t = input().strip()
    a, b, c = map(int, (t[1:t.index('+')], t[t.index('+') + 1:t.index(')')], t[t.index('/') + 1:]))
    x = (a + b) / c
    lst[i] = x
    dct[x] += 1
for i in lst:
    print(dct[i], end=' ')",linear
"from sys import stdin

add = lambda a, b: (a % mod + b % mod) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, k + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])

print(sum(mem[-1][k]) % mod)",np
"n, m = int(input()), int(input())
value = False
for j in range(n + 1):
    if pow(2, j) > m:
        value = True
        break
if value:
    print(m)
else:
    print(m % pow(2, n))",constant
"n=int(input())
arr=list(map(int,input().split()))
arr=sorted(arr)
if arr[-1]==1:arr[-1]=2
else:arr=[1]+arr[:n-1]
print(*arr)",nlogn
"t = int(input())

for i in range(0, t) :
    n, k = [int(x) for x in input().split()]
    if (n >= 32) :
        print(""YES %d"" % (n-1))
    else :
        low=0
        co=-1
        md = [0]
        for j in range(1, n):
            md.append(md[-1]*4 + 1)
        kk = 0
        found=0
        for cut in range(1,n+1) :
            low += (1<<cut)-1
            co = 2*co + 3
            kk += co*md[n-cut]
            if (k>=low and k<=low+kk) :
                print(""YES %d"" % (n-cut))
                found=1
                break
        if (found == 0) : print(""NO"")",logn
"from collections import Counter
import sys
readline = sys.stdin.readline

def check(A):
    CA = Counter(A)
    if CA[0] >= 2:
        return False
    cnt = 0
    for k, v in CA.items():
        if v > 2:
            return False
        if v == 2 and CA[k-1] >= 1:
            return False
        if v >= 2:
            cnt += 1
    if cnt >= 2:
        return False
    L = len(A)
    if (sum(A) - L*(L-1)//2) % 2 == 0:
        return False
    return True

N = int(readline())
if check(list(map(int, readline().split()))):
    print('sjfnb')
else:
    print('cslnb')",linear
"n,k=map(int,input().split())
same=[0]*(k+1)
diff=[0]*(k+1)
same[1]=2
if k>1:
    diff[2]=2
for i in range(n-1):
    newsame=[0]*(k+1)
    newdiff=[0]*(k+1)
    for i in range(1,k+1):
        newsame[i]=(same[i]+same[i-1]+2*diff[i])%998244353
    for i in range(2,k+1):
        newdiff[i]=(2*same[i-1]+diff[i]+diff[i-2])%998244353
    same=newsame
    diff=newdiff
print((same[-1]+diff[-1])%998244353)",np
"n, m = map( int, input().split() )
a = list( map( int, input().split() ) )

ans = sum( a )
a.sort()
lastlevel = 0
level = 0
got = 0

for i in a:
    got = max( got, i )
    level = min( level + 1, got )
    if i > 0:
        ans -= 1
        lastlevel = level

ans -= ( got - level )
print( ans )",nlogn
"def solve(mat1: list, mat2: list, K: int) -> list:
    if K % 2 == 1:
        res = [[-1] * n for _ in range(m)]
    else:

        dp = [[[-1] * (K // 2 + 1) for _ in range(n)] for _ in range(m)]
        for k in range(K // 2 + 1):
            for i in range(m):
                for j in range(n):
                    if k == 0:
                        dp[i][j][k] = 0
                    else:
                        if i > 0 and (dp[i][j][k] == -1 or dp[i - 1][j][k - 1] + mat2[i - 1][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i - 1][j][k - 1] + mat2[i - 1][j]
                        if i < m - 1 and (dp[i][j][k] == -1 or dp[i + 1][j][k - 1] + mat2[i][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i + 1][j][k - 1] + mat2[i][j]
                        if j > 0 and (dp[i][j][k] == -1 or dp[i][j - 1][k - 1] + mat1[i][j - 1] < dp[i][j][k]):
                            dp[i][j][k] = dp[i][j - 1][k - 1] + mat1[i][j - 1]
                        if j < n - 1 and (dp[i][j][k] == -1 or dp[i][j + 1][k - 1] + mat1[i][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i][j + 1][k - 1] + mat1[i][j]
        res = [[-1] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                res[i][j] = 2 * dp[i][j][-1]
    for i in range(m):
        for j in range(n):
            if j < n - 1:
                print(res[i][j], end = ' ')
            else:
                print(res[i][j])
    return

m, n, K = map(int, input().split())
mat1 = []
mat2 = []
for _ in range(m):
    mat1.append(list(map(int, input().split())))
for _ in range(m - 1):
    mat2.append(list(map(int, input().split())))
solve(mat1, mat2, K)",cubic
"DR = [1,0,-1,0]
DC = [0,1,0,-1]

n, m, k = map(int, input().split())
w = [[[0] * m for _ in range(n)] for _ in range(4)]
for r in range(n):
    for c, e in enumerate(map(int, input().split())):
        w[1][r][c] = w[3][r][c + 1] = e
for r in range(n - 1):
    for c, e in enumerate(map(int, input().split())):
        w[0][r][c] = w[2][r + 1][c] = e

INF = 10 ** 9

def solve():
    global k
    global w
    if k % 2 == 1:
        return [[-1] * m] * n
    k //= 2
    best = [[[0] * m for _ in range(n)] for _ in range(k + 1)]
    for steps in range(1, k + 1):
        for r in range(n):
            for c in range(m):
                best[steps][r][c] = INF
                for d in range(4):
                    r2, c2 = r + DR[d], c + DC[d]
                    if 0 <= r2 < n and 0 <= c2 < m:
                        best[steps][r][c] = min(best[steps][r][c], 2 * w[d][r][c] + best[steps - 1][r2][c2])
    return best[k]

res = solve()
for e in res:
    print(*e)",cubic
"n=int(input())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
ha={}
for i in range(n):
    ha[a[i]]=i
removed=0
out=""""
for i in range(n):
    if ha[b[i]]<removed:
        out+=""0 ""
    else:
        out+=str(ha[b[i]]-removed+1)+"" ""
        removed=ha[b[i]]+1
print(out[:-1])",linear
"from sys import stdin,stdout
n,q=map(int,input().split())
mod=1000000007
o=[]
s=[]
r=m=0
a=input()
for i in a:
    if i=='0':
        r+=1
    else:
        m+=1
    o.append(r)
    s.append(m)
z=[1]

for i in range(100000):
    z.append((z[-1]*2)%mod)
for j in range(q):
    l,r=(int(j) for j in stdin.readline().split())
    m=r-l+1
    zs=o[r-1]-o[l-1]+(a[l-1]=='0')
    os=m-zs

    if zs!=0:
        print((((z[os]-1)%mod)*((z[zs])%mod))%mod)
    else:
        print(((z[os]-1)%mod))",linear
"f=input
D,E=dict(),[eval(f())for i in range(int(f()))]
for e in E:D[e]=D.get(e,0)+1
for e in E:print(D[e])",linear
"from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class MDArray(object):

  def __init__(self, dimensions, initial_value=0):

    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):

    return self.arr[self._index(indexes)]

  def set(self, indexes, value):

    self.arr[self._index(indexes)] = value
    return value

def encode(row, col, n, m):
  return row * m + col

def solve(node, remain, adj, dp, n, m):
  if remain == 0:
    return 0

  key = (node + remain * n * m)
  mem = dp[key]
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1,
            adj, dp, n, m) + x[1], adj[node]))
  dp[key] = ans
  return ans

def main(inp, out):

  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = [-1] * (n*m*(k/2+1))

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2, adj, dp, n, m) * 2)
    out.writeLine(' '.join(map(str, ans)))

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()",cubic
"def f_pow(a, n):
    if n < 0:
        return 0
    if n == 0:
        return 1
    if n % 2 == 0:
        return f_pow(a * a, n // 2)
    else:
        return a * f_pow(a, n - 1)

def get_c(n):
    if(n > 68):
        return int(1e40)
    return (f_pow(4, n) - 4) // 12

def get_cc(n):
    if(n > 51):
        return int(1e30)
    return (f_pow(4, n) - 4) // 12

def ans(n, k):
    side = n - 1
    way = 4
    cnt_all = get_c(n + 1)
    c = 2
    op = 1
    while (True):
        if k < op or side < 0:
            break
        way_blocks = way - 1
        if(get_cc(side - 1) > k):
            return side
        per_block = get_cc(side + 1)
        kk = k - op
        if cnt_all - way_blocks * per_block - op >= kk:
            return side

        side -= 1
        op += (1 << c) - 1
        c += 1
        way *= 2
    return -1

def read():
    return [int(i) for i in input().split()]

t = int(input())

for i in range(t):
    n, k = read()
    a = ans(n, k)
    if(a == -1):
        print(""NO"")
    else:
        print(""YES {}"".format(a))",logn
"def l(a):
    b=bin(a)[2:]
    b=""0""*(e-len(b))+b
    d=len(b)
    for i in range(d-1,-1,-1):
        if b[i]==""1"":
            c=d-1-i
            break
    if c==0:
        return -1
    return (a-2**(c-1))

def r(a):
    b=bin(a)[2:]
    b=""0""*(e-len(b))+b
    d=len(b)
    for i in range(d-1,-1,-1):
        if b[i]==""1"":
            c=d-1-i
            break
    if c==0:
        return -1
    return (a+2**(c-1))

def u(a):
    b=bin(a)[2:]
    b=""0""*(e-len(b))+b
    d=len(b)
    for i in range(d-1,-1,-1):
        if b[i]==""1"":
            c=d-1-i
            break
    if c==d-1:
        return -1
    else:
        if b[d-1-c-1]==""0"":
            return a+(2**c)
        else:
            return a-(2**c)

n,q=list(map(int,input().split()))
e=len(bin(n)[2:])
for i in range(q):
    a=int(input())
    b=input()
    for i in range(len(b)):
        if b[i]==""U"":
            c=u(a)
            if c!=-1:
                a=c
        elif b[i]==""R"":
            c=r(a)
            if c!=-1:
                a=c
        elif b[i]==""L"":
            c=l(a)
            if c!=-1:
                a=c
    print(a)",np
"import math
n=int(input())
if(n==3):
    print('1 1 3')

else:
    t=1
    while(t<=n):
        ct=math.ceil((n//t)/2)
        for i in range(0,ct):
            print(t,end="" "")

        if(ct==2 and (n//t)%2!=0):
            t=t*3
        else:
            t=t*2
    print("" "")",nlogn
"from sys import stdin,stdout

mod=10**9+7
t=1
for _ in range(t):
    a=input()
    b=input()
    n=len(a)
    m=len(b)
    dp=[[0 for i in range(2)] for j in range(m+1)]
    dp[1][0]=int(b[0])^1
    dp[1][1]=int(b[0])
    for i in range(2,m+1):
        dp[i][0]=dp[i-1][0]+(int(b[i-1])^1)
        dp[i][1]=dp[i-1][1]+int(b[i-1])
    ans=0
    for i in range(n):
        count0=dp[m-n+i+1][0]-dp[i][0]
        count1=dp[m-n+i+1][1]-dp[i][1]
        ans+=count0*int(a[i])+count1*(int(a[i])^1)
    print(ans)",linear
"def main():
    high = 10 ** 12
    n, m, k = map(int, input().split())
    hozs = []
    for i in range(n):
        hozs.append(list(map(int, input().split())))
    verts = []
    for i in range(n - 1):
        verts.append(list(map(int, input().split())))
    if k % 2:
        for i in range(n):
            print(""-1 "" * m)
        return
    k //= 2
    dp = []
    for i in range(n):
        dp.append([])
        for j in range(m):
            dp[-1].append([])
            for kay in range(k + 1):
                dp[-1][-1].append(0)
    for depth in range(1, k + 1):
        for i in range(n):
            for j in range(m):
                if i == 0:
                    up = high
                else:
                    up = verts[i - 1][j] + dp[i - 1][j][depth - 1]
                if i == n - 1:
                    down = high
                else:
                    down = verts[i][j] + dp[i + 1][j][depth - 1]
                if j == 0:
                    left = high
                else:
                    left = hozs[i][j - 1] + dp[i][j - 1][depth - 1]
                if j == m - 1:
                    right = high
                else:
                    right = hozs[i][j] + dp[i][j + 1][depth - 1]
                min_cost = min(up, down, left, right)

                dp[i][j][depth] += min_cost
    for i in range(n):
        print(*[2 * dp[i][j][k] for j in range(m)])
main()",cubic
"MOD=1000000007

x,k=map(int,raw_input().split())

if x>0:
	ans=(pow(2,k+1,MOD)*x)%MOD
	ans=(ans-pow(2,k,MOD))%MOD
	ans=(ans+1)%MOD
else:
	ans=0

print(ans)",logn
"from collections import deque
N,M=map(int,input().split())
table=[]

for i in range(M):
    s,t,c=map(int,input().split())
    s,t=s-1,t-1
    table.append((s,t,c))

def check(k):
    Lin=[0]*N
    edge=[[] for i in range(N)]
    for s,t,c in table:
        if c>k:
            Lin[t]+=1
            edge[s].append(t)
    Haco=deque()
    ans=[]
    for i in range(N):
        if Lin[i]==0:
            ans.append(i)
            Haco.append(i)
    while Haco:
        x = Haco.pop()
        for y in edge[x]:
            Lin[y]-=1
            if Lin[y]==0:
                ans.append(y)
                Haco.append(y)
    return ans
ma=10**9+7
mi=-1
while ma-mi>1:
    mid=(ma+mi)//2
    if len(check(mid))==N:
        ma=mid
    else:
        mi=mid
ans=check(ma)

dd={}
for i in ans:
    dd[ans[i]]=i
num=0
answer=[]

for i in range(M):
    s, t, c=table[i]
    if dd[s]>dd[t] and c<=ma:
        answer.append(i+1)
        num+=1
print(ma,num)
print(' '.join(map(str,answer)))",nlogn
"from sys import stdin
s=stdin.readline()
for ln in range(len(s),0,-1):
    for L in range(len(s)-ln+1):
        if s[L:L+ln] in s[L+1:]:
            print(ln)
            exit()
print(0)",cubic
"l, r = map(int, input().split())
target, final = l ^ r, 1
while target:
    target >>= 1
    final <<= 1
print(final - 1)",logn
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp=[[[-1]*(B+1) for i in range(G+1)] for j in range(R+1)]
def calc(nr,ng,nb):
  if dp[nr][ng][nb]!=-1:
    return dp[nr][ng][nb]
  res=0
  if nr<R and ng<G:
    res=max(res,calc(nr+1,ng+1,nb)+r[nr]*g[ng])
  if nr<R and nb<B:
    res=max(res,calc(nr+1,ng,nb+1)+r[nr]*b[nb])
  if ng<G and nb<B:
    res=max(res,calc(nr,ng+1,nb+1)+g[ng]*b[nb])
  dp[nr][ng][nb]=res
  return res
print(calc(0,0,0))",cubic
"import sys
def power(x, y, p) :
    res = 1

    x = x % p

    while (y > 0) :

        if ((y & 1) == 1) :
            res = (res * x) % p

        y = y >> 1
        x = (x * x) % p

    return res
mod=(10**9)+7
r,k=map(int,input().split())
if r==0:
    print(0)
    sys.exit()
print((((((power(2,k+1,mod)%mod)*(r%mod))%mod)-power(2,k,mod)+1))%mod)",logn
"k=int(input())
i=0
r=1
while(k>=r):
    r+=9*(i+1)*10**i
    i+=1
r=r-(9*i*10**(i-1))
ans=str(((k-r)//i)+10**(i-1))[(k-r)%i]
print(ans)",logn
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    a = list(map(int, input().split()))
    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[i] > a[j]:
                cnt += 1
    even = cnt % 2 == 0
    q = int(input())
    ans = []
    for _ in range(q):
        l, r = map(int, input().split())
        len = r - l + 1
        pairs = len * (len-1) // 2
        if pairs % 2 == 1:
            even = not even
        if even:
            ans.append('even')
        else:
            ans.append('odd')
    print('\n'.join(ans))

main()",quadratic
"from math import ceil

n, k = list(map(int, input().strip().split()))
r = 2*n
g = 5*n
b = 8*n

print(ceil(r/k)+ceil(g/k)+ceil(b/k))",constant
"pw = [1, 4]
for i in range(2, 32):
    pw.append(pw[i - 1] * 4)
t = int(input())
for cas in range(t):
    n, k = map(int, input().split())
    last = 1
    path = 1
    ans = n
    i = 0
    while True:
        if((pw[i + 1] - 1) // 3 > k):
            ans -= i
            last = k - (pw[i] - 1) // 3
            break
        i = i + 1
        path *= 2
    sp = path * 2 - 1
    if((ans < 0) or ((ans == 0) and (last > 0))):
        print(""No"")
        continue
    sq = path * path - sp
    if (ans == 1) and (last > sq) and (last < sp):
        print(""No"")
        continue
    elif (ans == 1) and (last >= sp):
        ans = ans - 1
    print(""Yes"", ans)",logn
"N = int(input())
s1 = [list(input()) for i in range(N)]
s2 = [list(input()) for i in range(N)]

def rotate(s):
    ret = [[None for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            ret[i][j] = s[j][N-1-i]
    return ret

def v_mirror(s):
    return list(reversed(s))

def h_mirror(s):
    return [list(reversed(row)) for row in s]

def solve():
    global s1
    for i in range(4):
        if s1 == s2: return True
        if v_mirror(s1) == s2: return True
        if h_mirror(s1) == s2: return True
        if v_mirror(h_mirror(s1)) == s2: return True
        s1 = rotate(s1)
    return False

print('Yes' if solve() else 'No')",quadratic
"n=int(input())

x=1

while n>(10**(len(str(x))-1)*9*len(str(x))):
    n-=10**(len(str(x))-1)*9*len(str(x))

    x*=10

t=len(str(x))
nadighe=False
while nadighe==False:
    qw=1
    nadighe=True
    while n>(10**(len(str(qw))-1)*9*t):
        n-=10**(len(str(qw))-1)*9*t
        nadighe=False
        qw*=10
    x+=qw-1

while n>len(str(x)):
    n-=len(str(x))
    x+=1
for i in range(len(str(x))):
    if n!=0:
        s=str(x)[i]
        n-=1
print(s)",logn
"n = int(input())
a = []
for i in map(int, input().split()):
    if abs(-i-1)>abs(i):
        a.append(-i-1)
    else:
        a.append(i)

c = 0
for i in a:
    if i<0:
        c+=1
if c%2:
    me=0
    for i in range(len(a)):
        if a[i]<a[me]:
            me=i
    a[me]=-a[me]-1
print(*a)",linear
"import sys
from collections import defaultdict

def main():
    n, k = map(int, input().split())
    cand = 0
    tot = 0
    p = 0
    while tot < k or tot-(n-p) != k:
        cand += 1
        tot += cand
        p += 1

    print(tot-k)

if __name__ == '__main__':
    main()",logn
"from math import *
from cmath import *
from itertools import *
from decimal import *
from fractions import *
from sys import *
from types import CodeType, new_class

a = []
n, m = map(int, input().split())
minx, miny, maxx, maxy = n, m, 0, 0
for x in range(n):
    a.append(input())
    for y in range(m):
        if a[x][y] == 'B':
            minx = min(minx, x + 1)
            miny = min(miny, y + 1)
            maxx = max(maxx, x + 1)
            maxy = max(maxy, y + 1)
print((maxx + minx) // 2 , (maxy + miny) // 2)",quadratic
"import bisect
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        index = bisect.bisect_left(nums, target)
        return index if index < len(nums) and nums[index] == target else -1",logn
"import os
import heapq
import sys
import math
import operator
from collections import defaultdict
from io import BytesIO, IOBase

def inpt():
    return [int(k) for k in input().split()]

def main():
    n1, n2, n3 = map(int, input().split())
    ar = [int(x) for x in input().split()]
    br = [int(x) for x in input().split()]
    cr = [int(x) for x in input().split()]
    ar.sort()
    br.sort()
    cr.sort()
    dp = [[[0 for x in range(201)] for y in range(201)] for z in range(201)]
    for i in range(n1 + 1):
        for j in range(n2 + 1):
            for k in range(n3 + 1):
                if (i and j):
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + (ar[i - 1] * br[j - 1]))
                if (i and k):
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + (ar[i - 1] * cr[k - 1]))
                if (k and j):
                    dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + (cr[k - 1] * br[j - 1]))
    print(dp[n1][n2][n3])

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",cubic
"x, k = (int(x) for x in input().split())
mod = 10 ** 9 + 7
if x == 0:
    print(0)
    exit()
if k == 0:
    print(2 * x % mod)
    exit()

ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod)
ans += 1
ans %= mod
ans += mod
ans %= mod

print(ans)",logn
"n,k = map(int,input().split())
print((2*n + k - 1) // k + (5*n+k-1) // k + (8*n+k-1)//k)",constant
"s = input().split(' ')
s1 = s[0]
s2 = s[1]
res = s1[0]
flag = 0
for i in range(1, len(s1)):
    if(s1[i]>=s2[0]):
        res+=s2[0]
        flag = 1
        break
    else:
        res+=s1[i]
if(flag == 0):
    res+=s2[0]
print(res)",linear
"a = int(input())
s = input()
d = s.count('H')
p = []
for i in range(len(s)):
	if i+d > len(s):
		n = d+i - len(s)
		m = d - n
		h = s[:m] + s[-n:]
		k = h.count(""T"")
		p.append(k)
	else:
		h = s[i:d+i]
		k = h.count(""T"")
		p.append(k)
mi = a
for i in range(len(p)):
	if p[i] < mi:
		mi = p[i]
if s.count(""H"") == 1 or s.count(""T"") == 0:
	print(0)
else:
	print(mi)",linear
"n,k=map(int,input().split())
mod=int(1e9+7)

if n>0:
    ans=pow(2,k+1,mod)*n-pow(2,k,mod)+1
else:
    ans=0
print(ans%mod)",logn
"import math

def main():
    buf = input()
    n = int(buf)
    buf = input()
    buflist = buf.split()
    a = []
    for i, item in enumerate(buflist):
        a.append([i+1, int(item)])
    a = list(reversed(list(sorted(a, key = lambda x:x[1]))))
    one_deg_count = 0
    for i in a:
        if i[1] == 1:
            one_deg_count += 1
    if one_deg_count == len(a):
        if one_deg_count == 2:
            print(""YES"", 1)
            print(1)
            print(1, 2)
        else:
            print(""NO"")
        return
    elif one_deg_count == len(a) - 1:
        if one_deg_count <= a[0][1]:
            print(""YES"", 2)
            print(one_deg_count)
            for i in range(one_deg_count):
                print(a[0][0], a[-i-1][0])
        else:
            print(""NO"")
        return
    else:
        spare_edges = 2
        for i in range(len(a) - one_deg_count):
            spare_edges += a[i][1] - 2
        if spare_edges >= one_deg_count:
            diameter = len(a) - 1 - one_deg_count + min(one_deg_count, 2)
            edge_count = 0
            edge_list = []
            for i in range(len(a) - one_deg_count - 1):
                edge_list.append((a[i][0], a[i+1][0]))
            for i in range(len(a) - one_deg_count):
                a[i][1] -= 2
            if one_deg_count > 0:
                edge_list.append((a[0][0], a[-1][0]))
                one_deg_count -= 1
            if one_deg_count > 0:
                edge_list.append((a[-one_deg_count-2][0], a[-2][0]))
                one_deg_count -= 1
            idx = 0
            for i in range(one_deg_count):
                edge_list.append((a[idx][0], a[-i-3][0]))
                a[idx][1] -= 1
                if a[idx][1] <= 0:
                    idx += 1
            print(""YES"", diameter)
            print(len(edge_list))
            for i in edge_list:
                print(i[0], i[1])
        else:
            print(""NO"")

if __name__ == '__main__':
    main()",nlogn
"n,m=map(int,raw_input().split())

l=[]
for i in range(n):
	s=raw_input()
	l.append([])
	for j in range(m):
		l[-1].append(s[j])

ans=[]
for i in range(n):

	ans.append([])
	for j in range(m):
		ans[-1].append(""."")

for i in range(n-2):
	for j in range(m-2):
		if l[i][j]==""
			if l[i][j]==l[i][j+1] and l[i][j]==l[i][j+2] and l[i][j]==l[i+1][j] and l[i][j]==l[i+1][j+2] and l[i][j]==l[i+2][j] and l[i][j]==l[i+2][j+1] and l[i][j]==l[i+2][j+2]:
				ans[i][j]=""
				ans[i][j+1]=""
				ans[i][j+2]=""
				ans[i+1][j]=""
				ans[i+1][j+2]=""
				ans[i+2][j]=""
				ans[i+2][j+1]=""
				ans[i+2][j+2]=""

flag = True
for i in range(n):
	for j in range(m):
		if l[i][j]!=ans[i][j]:
			flag = False
			break
	if flag==False:
		break

if flag==True:
	print(""YES"")
else:
	print(""NO"")",quadratic
"from bisect import bisect,bisect_left

from collections import *
from math import gcd,ceil,sqrt,floor,inf
from heapq import *
from itertools import *
from operator import add,mul,sub,xor,truediv,floordiv
from functools import *

import os
import sys

from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def RL(): return map(int, sys.stdin.readline().split())
def RLL(): return list(map(int, sys.stdin.readline().split()))
def N(): return int(input())
def A(n):return [0]*n
def AI(n,x): return [x]*n
def A2(n,m): return [[0]*m for i in range(n)]
def G(n): return [[] for i in range(n)]
def GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

mod=10**9+7
farr=[1]
ifa=[]

def fact(x,mod=0):
    if mod:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr)%mod)
    else:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr))
    return farr[x]

def ifact(x,mod):
    global ifa
    fact(x,mod)
    ifa.append(pow(farr[-1],mod-2,mod))
    for i in range(x,0,-1):
        ifa.append(ifa[-1]*i%mod)
    ifa.reverse()

def per(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return fact(i)//fact(i-j)
    return farr[i]*ifa[i-j]%mod

def com(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return per(i,j)//fact(j)
    return per(i,j,mod)*ifa[j]%mod

def catalan(n):
    return com(2*n,n)//(n+1)

def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True

def floorsum(a,b,c,n):
    if a==0:return b//c*(n+1)
    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2
    m=(a*n+b)//c
    return n*m-floorsum(c,c-b-1,a,m-1)

def inverse(a,m):
    a%=m
    if a<=1: return a
    return ((1-inverse(m,a)*m)//a)%m

def lowbit(n):
    return n&-n

class BIT:
    def __init__(self,arr):
        self.arr=arr
        self.n=len(arr)-1

    def update(self,x,v):
        while x<=self.n:
            self.arr[x]+=v
            x+=x&-x

    def query(self,x):
        ans=0
        while x:
            ans+=self.arr[x]
            x&=x-1
        return ans

class ST:
    def __init__(self,arr):
        n=len(arr)
        mx=n.bit_length()
        self.st=[[0]*mx for i in range(n)]
        for i in range(n):
            self.st[i][0]=arr[i]
        for j in range(1,mx):
            for i in range(n-(1<<j)+1):
                self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])
    def query(self,l,r):
        if l>r:return -inf
        s=(r+1-l).bit_length()-1
        return max(self.st[l][s],self.st[r-(1<<s)+1][s])

class DSU:
    def __init__(self,n):
        self.c=[-1]*n

    def same(self,x,y):
        return self.find(x)==self.find(y)

    def find(self,x):
        if self.c[x]<0:
            return x
        self.c[x]=self.find(self.c[x])
        return self.c[x]

    def union(self,u,v):
        u,v=self.find(u),self.find(v)
        if u==v:
            return False
        if self.c[u]>self.c[v]:
            u,v=v,u
        self.c[u]+=self.c[v]
        self.c[v]=u
        return True

    def size(self,x): return -self.c[self.find(x)]

class UFS:
    def __init__(self,n):
        self.parent=[i for i in range(n)]
        self.ranks=[0]*n

    def find(self,x):
        if x!=self.parent[x]:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]

    def union(self,u,v):
        pu,pv=self.find(u),self.find(v)
        if pu==pv:
            return False
        if self.ranks[pu]>=self.ranks[pv]:
            self.parent[pv]=pu
            if self.ranks[pv]==self.ranks[pu]:
                self.ranks[pu]+=1
        else:
            self.parent[pu]=pv

def Prime(n):
    c=0
    prime=[]
    flag=[0]*(n+1)
    for i in range(2,n+1):
        if not flag[i]:
            prime.append(i)
            c+=1
        for j in range(c):
            if i*prime[j]>n: break
            flag[i*prime[j]]=prime[j]
            if i%prime[j]==0: break
    return flag

def dij(s,graph):
    d={}
    d[s]=0
    heap=[(0,s)]
    seen=set()
    while heap:
        dis,u=heappop(heap)
        if u in seen:
            continue
        seen.add(u)
        for v,w in graph[u]:
            if v not in d or d[v]>d[u]+w:
                d[v]=d[u]+w
                heappush(heap,(d[v],v))
    return d

def bell(s,g):
    dis=AI(n,inf)
    dis[s]=0
    for i in range(n-1):
        for u,v,w in edge:
            if dis[v]>dis[u]+w:
                dis[v]=dis[u]+w
    change=A(n)
    for i in range(n):
        for u,v,w in edge:
            if dis[v]>dis[u]+w:
                dis[v]=dis[u]+w
                change[v]=1
    return dis

def lcm(a,b): return a*b//gcd(a,b)
def lis(nums):
    res=[]
    for k in nums:
        i=bisect.bisect_left(res,k)
        if i==len(res):
            res.append(k)
        else:
            res[i]=k
    return len(res)

def RP(nums):
    n = len(nums)
    s=set(nums)
    d={}
    for i,k in enumerate(sorted(s),1):
        d[k]=i
    bi=BIT([0]*(len(s)+1))
    ans=0
    for i in range(n-1,-1,-1):
        ans+=bi.query(d[nums[i]]-1)
        bi.update(d[nums[i]],1)
    return ans

class DLN:
    def __init__(self,val):
        self.val=val
        self.pre=None
        self.next=None

def nb(i,j,n,m):
    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:
        if 0<=ni<n and 0<=nj<m:
            yield ni,nj

def topo(n):
    q=deque()
    res=[]
    for i in range(1,n+1):
        if ind[i]==0:
            q.append(i)
            res.append(i)
    while q:
        u=q.popleft()
        for v in g[u]:
            ind[v]-=1
            if ind[v]==0:
                q.append(v)
                res.append(v)
    return res

@bootstrap
def gdfs(r,p):
    for ch in g[r]:
        if ch!=p:
            yield gdfs(ch,r)
    yield None

t=1
for i in range(t):
    n,m,k=RL()
    h=[]
    v=[]
    for i in range(n):
        h.append(RLL())
    for i in range(n-1):
        v.append(RLL())
    if k&1:
        for i in range(n):
            print(*AI(m,-1))
        exit()
    k//=2
    dp=[[[inf]*m for i in range(n)]for j in range(k+1)]
    for i in range(n):
        for j in range(m):
            dp[0][i][j]=0
    for i in range(1,k+1):
        for j in range(n):
            for a in range(m):
                if j:
                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j-1][a]+2*v[j-1][a])
                if j+1<n:
                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j+1][a]+2*v[j][a])
                if a:
                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j][a-1]+2*h[j][a-1])
                if a+1<m:
                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j][a+1]+2*h[j][a])
    for i in range(n):
        res=[]
        for j in range(m):
            res.append(dp[k][i][j])
        print(*res)",cubic
"import math
from math import factorial

def combination(n,r):
    return float(factorial(n)) / float(factorial(r)) / float(factorial(n-r))

a = input()
ap = a.count('+')
am = a.count('-')
b = input()
bp = b.count('+')
bm = b.count('-')
n = b.count('?')
x = float(ap - bp)
y = float(am - bm)
if (x < 0 or y < 0 or x+y != n):
    print(0.0)
else:
    print(combination(n,x)/(1<<n))",np
"dp=[]
n,k=map(int,input().split())
for _ in range(n):
    p,t=map(int,input().split())
    dp.append((p,-t))
dp.sort(reverse=True)
print(dp.count(dp[k-1]))",nlogn
"n,k=[int(x)for x in input().split()]
ns=[int(x) for x in input().split()]
done=[None]*256
ans=[None]*n
for i in range(n):
    c=ns[i]
    if done[c]==None:
        j=c
        while True:
            if j<0 or c-j>=k or (done[j]!=None and done[j]!=-1):
                break
            j-=1
        j+=1
        for kk in range(k):
            if kk+j>=256 or (done[kk+j]!=None and done[kk+j]!=-1):
                break
            if kk+j<=c:
                done[kk+j]=j
            else:
                done[kk+j]=-1
    elif done[c]==-1:
        j=c
        while True:
            if done[j]!=None and done[j]!=-1:
                break
            j-=1
        a=done[j]
        for kk in range(j,c+1):
            done[kk]=a
    else:
        pass
    ans[i]=done[c]

ans=[str(x)for x in ans]
print(' '.join(ans))",quadratic
"n,k=map(int,input().split())
if n>=k:
    print((k-1)//2)
elif n*2>k:
    print(n-k//2)
else: print(0)",constant
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=999999999999999999999999
alphabets=""abcdefghijklmnopqrstuvwxyz""
class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

class SegTree:

    def __init__(self, n):
        self.N = 1 << n.bit_length()
        self.tree = [0] * (self.N<<1)

    def update(self, i, j, v):
        i += self.N
        j += self.N
        while i <= j:
            if i%2==1: self.tree[i] += v
            if j%2==0: self.tree[j] += v
            i, j = (i+1) >> 1, (j-1) >> 1

    def query(self, i):
        v = 0
        i += self.N
        while i > 0:
            v += self.tree[i]
            i >>= 1
        return v

def SieveOfEratosthenes(limit):

    isPrime = [True]*(limit+1)
    isPrime[0] = isPrime[1] = False
    primes = []
    for i in range(2, limit+1):
        if not isPrime[i]:continue
        primes += [i]
        for j in range(i*i, limit+1, i):
            isPrime[j] = False
    return primes

def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        a,b=ria()
        op=0
        while True:
            if b:
                op+=a//b
                a%=b
                a,b=b,a
            else:
                break
        wi(op)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()",constant
"from math import inf

if True:
    n,m,k = map(int,input().split())
    cosp = [[int(x) for x in input().split()]+[inf] for _ in range(n)]
    cosv = [[int(x) for x in input().split()]for _ in range(n-1)]+[[inf]*m]
    if k%2==1:
        for _ in range(n):
            print(*[-1]*m)

    else:
        dp = [[0]*m for i in range(n)]
        xx,yy = [0,0,1,-1],[1,-1,0,0]
        for _ in range(k//2):
            dp1 = [[inf]*m for _ in range(n)]
            for i in range(n):
                for j in range(m):
                    for kk in range(4):
                        x1,y1 = i+xx[kk],j+yy[kk]
                        if kk < 2:
                            if kk==1:
                                edge = cosp[i][j-1]
                            else:
                                edge=cosp[i][j]
                        else:
                            if kk==3 :
                                edge = cosv[i-1][j]
                            else:
                                edge = cosv[i][j]
                        if edge != inf:
                            dp1[i][j] = min(dp1[i][j],2*edge+dp[x1][y1])
            dp = dp1[:]
        for i in dp:
            print(*i)",cubic
"k = int(input())
x = [0,9]
i = 2
y = 90
while x[-1] < 10**12:
    x.append(x[-1]+y*i)
    y *= 10
    i += 1
if k in x:
    print(9)
else:
    for t in range(len(x)):
        if k < x[t]:
            break
    e = k-x[t-1]
    if t == 1:q=str(e)
    else:q =str(10**(t-1)+e//t-1)
    if e%t == 0:
        print(q[-1])
    else:
        q = str(int(q)+1)
        print(q[e%t-1])",logn
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed
            effect[j][i] = index

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)",np
"def solve(i, j, k):
    if dp[i][j][k]!=-1:
        return dp[i][j][k]
    call = 0
    if i>0 and j>0:
        call = max(call, R[i]*G[j]+solve(i-1, j-1, k))
    if j>0 and k>0:
        call = max(call, G[j]*B[k]+solve(i, j-1, k-1))
    if k>0 and i>0:
        call = max(call, B[k]*R[i]+solve(i-1, j, k-1))
    dp[i][j][k] = call
    return call

nr, ng, nb = map(int,input().split())
R = [0]+list(map(int,input().split()))
G = [0]+list(map(int,input().split()))
B = [0]+list(map(int,input().split()))
R.sort()
G.sort()
B.sort()
dp = [[[-1]*(nb+1) for j in range(ng+1)] for i in range(nr+1)]
ans = solve(nr, ng, nb)
print(ans)",cubic
"import math
mod=10**9 + 7

def calcpower(num,power,mod):

    if(power==0):
        return 1

    a=[num,]
    temp=num
    for i in range(int(math.log(power,2))):

        temp*=temp
        temp=temp%mod
        a.append(temp%mod)

    power=bin(power)[2:]

    power=power[::-1]
    res=1
    for i in range(len(power)):
        if(int(power[i])):
            res=(res*a[i])%mod
    return res%mod
import sys

x,k=map(int,input().split())

if(x==0):
    print(0)
    sys.exit()
if(k==0):
    print(2*x%mod)
    sys.exit()
ans=(2*x-1)*calcpower(2,k,mod)+1

print(ans%mod)",logn
"import copy

def rotate90(n, f):
    return [[f[n - j - 1][i] for j in range(n)] for i in range(n)]

def fliphor(n, f):
    return [[f[i][n - j - 1] for j in range(n)] for i in range(n)]

def flipver(n, f):
    return [[f[n - i - 1][j] for j in range(n)] for i in range(n)]

def eq(n, f, g):
    for i in range(n):
        for j in range(n):
            if f[i][j] != g[i][j]:
                return False
    return True

n = int(input())
f = [list(input()) for i in range(n)]
g = [list(input()) for i in range(n)]

for doflipv in range(2):
    for dofliph in range(2):
        for nrot in range(4):
            h = copy.deepcopy(f)
            if dofliph == 1:
                h = fliphor(n, h)
            if doflipv == 1:
                h = flipver(n, h)
            for i in range(nrot):
                h = rotate90(n, h)
            if eq(n, h, g):
                print(""Yes"")
                exit(0)

print(""No"")",quadratic
"import sys

def read():
	return sys.stdin.readline()

def main():
	n = int(read())
	a = list(map(int, read().split()))
	a.sort()
	k = 0
	used = [0] * n
	for i in range(n):
		if used[i]:
			continue
		k += 1
		for j in range(i, n):
			if a[j] % a[i] == 0:
				used[j] = True
	print(k)

if __name__ == '__main__':
	main()",quadratic
"n,k=map(int,input().split())
arr=list(map(int,input().split()))
d={}
for i in arr:
	if i in d:
		d[i]+=1
	else:
		d[i]=1
flag=True
for i in range(100,0,-1):
	t2=0
	for j in d.values():
		t2+=j//i
	if(t2>=n):
		print(i)
		flag=False
		break
if(flag):
	print(0)",nlogn
"kk=lambda:map(int, input().split())
ll=lambda:list(kk())
n,l,r,d=kk()
p,t=ll(),0
for v in range(2**n):
	s = []
	for i in range(n):
		if v&(2**i):
			s.append(p[i])
	if l <= sum(s)<=r and max(s)-min(s) >= d: t+=1
print(t)",np
"n, k = [int(i) for i in input().split()]
a, j = sorted([int(i) for i in input().split()]), 0
for i in a:
    while i > a[j]:
        if i <= a[j] + k:
            n -= 1
        j += 1
print(n)",nlogn
"from collections import Counter
from collections import defaultdict
import math
import random
import heapq as hq
from math import sqrt
import sys
from functools import reduce

def input():
    return sys.stdin.readline().strip()

def iinput():
    return int(input())

def tinput():
    return input().split()

def rinput():
    return map(int, tinput())

def rlinput():
    return list(rinput())

mod = int(1e9)+7

def factors(n):
    return set(reduce(list.__add__,
                      ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))

if __name__ == ""__main__"":
    n = iinput()
    a = rlinput()
    dp = [[0 for i in range(n)] for j in range(n)]
    for i in range(n):
        dp[i][i] = a[i]

    for l in range(n-2, -1, -1):
        for r in range(l+1, n):
            for k in range(l, r):
                if dp[l][k] == dp[k+1][r] and dp[l][k] != 0:

                    dp[l][r] = dp[l][k]+1

    squeeze = [float('inf')]*(n+1)
    squeeze[0] = 0
    for i in range(1, n+1):
        for j in range(i):
            if dp[j][i-1] != 0:
                squeeze[i] = min(squeeze[i], squeeze[j]+1)

    print(squeeze[n])",cubic
"import os,sys
from io import BytesIO,IOBase

def count(x):
    ans = 0
    while x:
        x &= x-1
        ans += 1
    return ans

def main():
    n = int(input())
    a = [list(map(float,input().split())) for _ in range(n)]
    y = 1<<n
    dp = [0]*(y-1)+[1]
    powe = [1<<i for i in range(n)]
    for i in range(y-1,0,-1):
        bit = count(i)
        prob = bit*(bit-1)//2
        for j in range(n):
            if not i&powe[j]:
                continue
            for x in range(n):
                if not i&powe[x]:
                    continue
                dp[i-powe[x]] += dp[i]*a[j][x]*prob
                dp[i-powe[j]] += dp[i]*a[x][j]*prob
    z = sum(dp[1<<i] for i in range(n))
    for i in range(n):
        print(dp[1<<i]/z,end=' ')
    print()

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",np
"import sys

n, m, k = list(map(int, sys.stdin.readline().strip().split()))
a = list(map(int, sys.stdin.readline().strip().split()))
b = [0] * (n+1)
for i in range (1, n+1):
    b[i] = b[i-1] + m * a[i-1] - k
M = [10 ** 20] * m
ans = 0
for i in range (0, n+1):
    M[i % m] = min([M[i % m], b[i]])
    for j in range (0, m):
        if i > j:
            ans = max([ans, b[i]-M[j]-k*((m*i+m-(i-j))%m)])

print(ans // m)",quadratic
"n = int(input())
a = list(set(map(int, input().split())))
n = len(a)

cnt = 0
for i in range(n):
    f = True
    for j in range(n):
        if i == j:
            continue
        if a[i] % a[j] == 0:
            f = False
    if f:
        cnt += 1

print(cnt)",quadratic
"import math

str1 = input()
str2 = input()
value = 0
value_2 = 0
unknown = 0
for x in str1:
    if x == '+':
        value += 1
    else:
        value -= 1
for x in str2:
    if x == '+':
        value_2 += 1
    elif x == '-':
        value_2 -= 1
    else:
        unknown += 1
plus_count = 0
minus_count = 0
rav = 0
x = value - value_2
if abs(x)<= unknown:
    if x >= 0:
        plus_count += x
        rav = unknown - plus_count
    else:
        minus_count += x
        rav = unknown - minus_count

    if plus_count == 0 and minus_count == 0 and rav == 0:
        print('1.000000000000')
    else:
        if rav % 2 == 0:
            rav = int(rav / 2)
            plus_count += rav
            minus_count += rav

            k = max(plus_count, minus_count)
            C = math.factorial(unknown) / (math.factorial(unknown - k) * math.factorial(k))
            O = math.pow(2, unknown)
            res = C / O
            print(f'{res:.12f}')
        else:
            print('0.000000000000')
else:
    print('0.000000000000')",np
"def some_random_function():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function5():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

import os,sys
from io import BytesIO,IOBase

def main():
    n,m,k = map(int,input().split())
    hor = [list(map(int,input().split()))+[10**20+1] for _ in range(n)]
    ver = [list(map(int,input().split())) for _ in range(n-1)]+[[10**20+1]*m]
    if k&1:
        for _ in range(n):
            print(*[-1]*m)
        exit()
    dp = [[0]*m for _ in range(n)]
    dx,dy = [0,0,1,-1],[1,-1,0,0]
    for _ in range(k//2):
        dp1 = [[10**20]*m for _ in range(n)]
        for i in range(n):
            for j in range(m):
                for kk in range(4):
                    x1,y1 = i+dx[kk],j+dy[kk]
                    if kk < 2:
                        ed = hor[i][j-(kk==1)]
                    else:
                        ed = ver[i-(kk==3)][j]
                    if ed != 10**20+1:
                        dp1[i][j] = min(dp1[i][j],2*ed+dp[x1][y1])
        dp = dp1
    for i in dp:
        print(*i)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def some_random_function1():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function2():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function3():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function4():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function6():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function7():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function8():

    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

if __name__ == '__main__':
    main()",cubic
"mass = list(input())
b = int(input())
mass.sort()
mass = mass[::-1]
p = ''
while(len(mass)>0):
	for i in range(len(mass)):
		n = p + mass[i] + ''.join(sorted(mass[:i] + mass[i + 1:]))
		if int(n) <= b:
			p += mass[i]
			mass = mass[:i] + mass[i + 1:]
			break
print(p)",cubic
"import sys

Ri = lambda : [int(x) for x in sys.stdin.readline().split()]
ri = lambda : sys.stdin.readline().strip()

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
INF = 10 ** 18
MOD = 10**8
N = 5*10**6

def solve(n):
    arr = []
    while n> 0:
        arr.append(n%2)
        n=n//2
    return arr

l,r = Ri()
arrl = solve(l)
arrr = solve(r)
if len(arrr) > len(arrl):
    ans = (1<<len(arrr))-1
    print(ans)
else:
    ind = -1
    for i in range(len(arrr)-1,-1,-1):
        if arrr[i] != arrl[i]:
            ind = i
            break
    if ind == -1:
        print(0)
    else:
        ans = (1 << (ind+1)) -1
        print(ans)",logn
"n, k = map(int, input().split())
a = [int(x) for x in input().split()]
rda = []
for j in range(12):
    rd = dict()
    x = pow(10, j)
    for i in range(n):
        r = (a[i]*x)%k
        rd[r] = rd.setdefault(r, 0) + 1
    rda.append(rd)
ans = 0
for i in range(n):
    r = a[i]%k
    ln = len(str(a[i]))
    x = pow(10, ln)
    if r == 0: r = k
    if k-r in rda[ln]:
        ans += rda[ln][k-r]
        if (a[i]*x)%k == k-r:
            ans -= 1
print(ans)",nlogn
"import sys

def input():
    return sys.stdin.readline().strip()

def dinput():
    return int(input())

def tinput():
    return input().split()

def rinput():
    return map(int, tinput())

def rt(x1, x2, y3):
    print(0.5 * (x2 + x1) * y3)

def main():
    n, k = rinput()
    i = 0
    t = 0
    while k > i:
        t += 1
        i += t
    c = n - t
    i -= c
    while i != k:
        t += 1
        i += t + 1
        c -= 1
    print(c)
main()",linear
"n=int(input())
a=(n//2)*3
print(a)",constant
"class BIT:

    __all__ = ['add', 'sumrange', 'lower_left']

    def __init__(self, maxsize=10**7):
        assert (maxsize > 0)

        self._n = maxsize+1
        self._bitdata = [0]*(maxsize+1)

    def add(self, i, x):

        assert(0 <= i < self._n)

        pos = i+1
        while pos < self._n:
            self._bitdata[pos] += x
            pos += pos&(-pos)

    def running_total(self, i):

        assert (-1<= i < self._n)

        if i == -1:
            return 0
        returnval = 0
        pos = i+1
        while pos:
            returnval += self._bitdata[pos]
            pos -= pos & (-pos)
        return returnval

    def sumrange(self, lo=0, hi=None):

        if lo < 0:
            raise ValueError('lo must be non-negative')
        if hi is None:
            hi = self._n

        return self.running_total(hi) - self.running_total(lo-1)

    def lower_left(self, total):

        if total < 0:
            return -1
        pos = 0
        k = 1<<(self._n.bit_length()-1)
        while k > 0:
            if pos+k < self._n and self._bitdata[pos+k] < total:
                total -= self._bitdata[pos+k]
                pos += k
            k //= 2
        return pos
def tentousu(lis):
  bit = BIT()
  ans = 0
  for i in range(len(lis)):
      bit.add(lis[i], 1)
      ans += i + 1 - bit.running_total(lis[i])
  return ans
N=int(input())
L=list(map(int,input().split()))
a=tentousu(L)
a%=2
if N%2==0 and a%2==0:
  print(""Petr"")
if N%2==0 and a%2==1:
  print(""Um_nik"")
if N%2==1 and a%2==0:
  print(""Um_nik"")
if N%2==1 and a%2==1:
  print(""Petr"")",nlogn
"def main():
    mod=1000000007

    tc=1
    for _ in range(tc):
        a=list(rs())
        b=list(rs())

        if len(a)<len(b):
            ws(''.join(sorted(a)[::-1]))
        else:
            a=sorted(a)
            ans=[]
            sa=SortedList(a)
            for i in range(len(a)-1):
                for j in range(len(sa)-1,-1,-1):
                    temp=ans+[sa[j]]
                    sa.discard(sa[j])
                    for k in sa:
                        temp.append(k)

                    if temp<=b:
                        ans.append(temp[i])
                        break
                    else:
                        sa.add(temp[i])
            ans.append(sa[-1])
            ws("""".join(ans))

def rant():

    return ""AAAAAAAAAAAAAAAAARRRGHHHHHHHHHHHHHHHHHHHHHHHH""

def SieveOfEratosthenes(limit):

    isPrime = [True]*(limit+1)
    isPrime[0] = isPrime[1] = False
    primes = []
    for i in range(2, limit+1):
        if not isPrime[i]:continue
        primes += [i]
        for j in range(i*i, limit+1, i):
            isPrime[j] = False
    return primes

def memodict(f):

    class memodict(dict):
        def __missing__(self, key):
            ret = self[key] = f(key)
            return ret

    return memodict().__getitem__

def pollard_rho(n):

    if n & 1 == 0:
        return 2
    if n % 3 == 0:
        return 3

    s = ((n - 1) & (1 - n)).bit_length() - 1
    d = n >> s
    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
        p = pow(a, d, n)
        if p == 1 or p == n - 1 or a % n == 0:
            continue
        for _ in range(s):
            prev = p
            p = (p * p) % n
            if p == 1:
                return math.gcd(prev - 1, n)
            if p == n - 1:
                break
        else:
            for i in range(2, n):
                x, y = i, (i * i + 1) % n
                f = math.gcd(abs(x - y), n)
                while f == 1:
                    x, y = (x * x + 1) % n, (y * y + 1) % n
                    y = (y * y + 1) % n
                    f = math.gcd(abs(x - y), n)
                if f != n:
                    return f
    return n

@memodict
def prime_factors(n):

    if n <= 1:
        return Counter()
    f = pollard_rho(n)
    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)

def distinct_factors(n):

    factors = [1]
    for p, exp in prime_factors(n).items():
        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]
    return factors

def all_factors(n):

    small, large = [], []
    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):
        if not n % i:
            small.append(i)
            large.append(n // i)
    if small[-1] == large[-1]:
        large.pop()
    large.reverse()
    small.extend(large)
    return small

def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):
    max_n = min(max_n, mod - 1)

    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
    fact[0] = 1
    for i in range(max_n):
        fact[i + 1] = fact[i] * (i + 1) % mod

    inv_fact[-1] = pow(fact[-1], mod - 2, mod)
    for i in reversed(range(max_n)):
        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

    def nCr_mod(n, r):
        res = 1
        while n or r:
            a, b = n % mod, r % mod
            if a < b:
                return 0
            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
            n //= mod
            r //= mod
        return res

    return nCr_mod

class DisjointSetUnion:
    def __init__(self, n):
        self.parent = [*range(n+1)]
        self.size = [1]*(n+1)
        self.min, self.max = [*range(n+1)], [*range(n+1)]
        self.count = n

    def get(self, a):

        if self.parent[a] == a:
            return a
        x = a
        while a != self.parent[a]:
            a = self.parent[a]
        while x != self.parent[x]:
            self.parent[x], x = a, self.parent[x]
        return a

    def union(self, a, b):

        a, b = self.get(a), self.get(b)
        if a != b:
            if self.size[a] > self.size[b]:
                a, b = b, a
            self.parent[a] = b
            self.size[b] += self.size[a]
            self.min[b] = min(self.min[a], self.min[b])
            self.max[b] = max(self.max[a], self.max[b])
            self.count -= 1

    def count_sets(self):

        return self.count

class SegmentTree:

    def __init__(self, data, default=0, func=max):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):

        stop+=1
        start += self._size
        stop += self._size

        res_left = res_right = self._default
        while start < stop:
            if start & 1:
                res_left = self._func(res_left, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res_right = self._func(self.data[stop], res_right)
            start >>= 1
            stop >>= 1

        return self._func(res_left, res_right)

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SparseTable:
    def __init__(self, data, func=min):
        self.func = func
        self._data = _data = [list(data)]
        i, n = 1, len(_data[0])
        while 2 * i <= n:
            prev = _data[-1]
            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])
            i <<= 1

    def query(self, start, stop):

        depth = (stop + 1 - start).bit_length() - 1
        return self.func(self._data[depth][start], self._data[depth][stop + 1 - (1 << depth)])

    def __getitem__(self, idx):
        return self._data[0][idx]

class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from math import log2
from bisect import bisect_left,bisect_right
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=999999999999999999999999
alphabets=""abcdefghijklmnopqrstuvwxyz""

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    main()
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")",cubic
"n,m=map(int,input().split())
arr=[]
for i in range(m):
    arr.append(list(map(int,input().split())))
count=0
for i in range(m):
    count +=arr[i][0] *(n)
    if n %2==1 and arr[i][1] <0:
        count +=(n//2)*(n//2 +1)*arr[i][1]
    if n %2==1 and arr[i][1] >0:
        count +=(n) *(n-1) *arr[i][1]//2
    if n %2==0 and arr[i][1] <0:
        count +=(n//2)*(n//2 -1)*arr[i][1]
        count +=(n//2) *arr[i][1]
    if n %2==0 and arr[i][1] >0:
        count +=(n) *(n-1) *arr[i][1] //2
print(count /n)",linear
"import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    n, m, k = map(int, input().split())
    a = []
    b = []
    for i in range(n):
        a.append(list(map(int, input().split())))
    for i in range(n-1):
        b.append(list(map(int, input().split())))
    if k % 2:
        ans = [-1] * m
        for i in range(n):
            print(*ans)
        return
    k //= 2
    pre = [[0]*m for i in range(n)]
    cur = [[10**9]*m for i in range(n)]
    for _ in range(k):
        cur = [[10**9] * m for i in range(n)]
        for i in range(n):
            for j in range(m):
                if i:
                    cur[i][j] = min(cur[i][j], pre[i-1][j]+b[i-1][j])
                if i < n - 1:
                    cur[i][j] = min(cur[i][j], pre[i+1][j]+b[i][j])
                if j:
                    cur[i][j] = min(cur[i][j], pre[i][j-1]+a[i][j-1])
                if j < m - 1:
                    cur[i][j] = min(cur[i][j], pre[i][j+1]+a[i][j])
        pre = cur
    for i in range(n):
        cur[i] = [cur[i][j]*2 for j in range(m)]
        print(*cur[i])

solve()",cubic
"n,d,k=map(int,input().split())
if n==1:
  print(""NO"")
  exit()
if k==1:
  if n==2 and d==1:
    print(""YES"")
    print(1,2)
  else:
    print(""NO"")
  exit()
if n<d+1:
  print(""NO"")
  exit()
co=1
ans=[]
for i in range(1,d+1):
  ans.append((i,i+1))
  co+=1
def dfs(r,dist,co):
  if 2<=r<=d:
    t=k-2
  else:
    t=k-1
  if co==n:
    return co
  for _ in range(t):
    if dist==d:
      return co
    if co==n:
      return co
    co+=1
    ans.append((r,co))
    co=dfs(co,dist+1,co)
  return co
for i in range(2,d+1):
  co=dfs(i,max(i-1,d-i+1),co)
if co==n:
  print(""YES"")
  for j in ans:
    print(*j)
else:
  print(""NO"")",quadratic
"from collections import defaultdict
n,k = map(int,input().split())
arr = list(map(int,input().split()))
xors = defaultdict(int)
xors[0]=1
comp = (1<<k)-1
ans = n*(n+1)//2
xor = 0
for a in arr:
	xor^=a
	if xors[xor]>xors[comp^xor]:
		xor^=comp
	ans-=xors[xor]
	xors[xor]+=1
print(ans)",linear
"import sys
import bisect
from bisect import bisect_left as lb
from bisect import bisect_right as rb
input_=lambda: sys.stdin.readline().strip(""\r\n"")
from math import log
from math import gcd
from math import atan2,acos
from random import randint
sa=lambda :input_()
sb=lambda:int(input_())
sc=lambda:input_().split()
sd=lambda:list(map(int,input_().split()))
sflo=lambda:list(map(float,input_().split()))
se=lambda:float(input_())
sf=lambda:list(input_())
flsh=lambda: sys.stdout.flush()

mod=10**9+7
mod1=998244353
gp=[]
cost=[]
dp=[]
mx=[]
ans1=[]
ans2=[]
special=[]
specnode=[]
a=0
kthpar=[]
def dfs(root,par):
    if par!=-1:
        dp[root]=dp[par]+1
    for i in range(1,20):
        if kthpar[root][i-1]!=-1:
            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]
    for child in gp[root]:
        if child==par:continue
        kthpar[child][0]=root
        dfs(child,root)

ans=0
b=[]

def dfs2(root,par,d):
    global gp,dp
    dp[root]=d
    for child in gp[root]:
        if child==par:continue
        dfs2(child,root,d+1)
def hnbhai(tc):
    n,s=sd()
    low=s
    high=n+1
    ans=n+1
    while(low<=high):
        mid=(low+high)//2
        ss=sum(list(map(int,list(str(mid)))))
        if mid-ss<s:
            low=mid+1
        else:
            ans=mid
            high=mid-1
    print(n-ans+1)
for _ in range(1):
    hnbhai(_+1)",logn
"import re
import string
import math

letter_number_pattern = ""[a-zA-Z]*[0-9]*""

alpha = dict(zip(range(1,28), string.ascii_uppercase))
decimals = dict(zip(string.ascii_uppercase, range(1,27)))

alpha_len = len(alpha)

def letter_to_decimal(n):
    exponents = []
    pow_i = 0
    while True:
        if n // (26**pow_i) > 26:
            exponents.append(1)
            n = n - (26**pow_i)
            pow_i += 1
        else:
            exponents.append(n // (26**pow_i))
            n = n - ((n // (26**pow_i)) * (26**pow_i))
            break
    pow_i = pow_i - 1
    while n != 0:
        t = n // (26**pow_i)
        n = n - (t * (26 ** pow_i))
        exponents[pow_i] = exponents[pow_i] + t
        pow_i = pow_i - 1
    result = ''.join(list(map(lambda x: alpha[x], reversed(exponents))))
    return result

def letters_to_deci(letters):
    total_sum = 0
    pows = list(reversed(range(len(letters))))
    for i in range(len(letters)):
        total_sum += decimals[letters[i]] * (26**pows[i])
    return total_sum

input_cells = []

n_lines = input()
for i in range(int(n_lines)):
    input_cells.append(input())

for cell in input_cells:
    all_matches = re.findall(letter_number_pattern, cell)[:-1]
    if len(all_matches) == 2:
        rows = int(re.search(""[0-9]*$"", all_matches[0]).group())
        cols = int(re.search(""[0-9]*$"", all_matches[1]).group())
        converted_cols = letter_to_decimal(cols)
        print(""%s%s"" % (converted_cols, rows))
    elif len(all_matches) == 1:
        rows = re.match(""[A-Z]*"", all_matches[0]).group()
        cols = re.search(""[0-9]*$"", all_matches[0]).group()
        converted_rows = letters_to_deci(rows)
        print(""R%sC%s"" % (cols, converted_rows))
    else:
        pass",linear
"from collections import deque

def top_sort():
    global dag, top, g, n
    q = deque()
    cnt = 0

    for i in range(1, n+1):
        if not dag[i]:
            q.append(i)

    while len(q):
        u = q.popleft()
        cnt += 1
        top[u] = cnt
        for to in g[u]:
            dag[to] -= 1
            if dag[to] == 0:
                q.append(to)
    return cnt == n

def check(mid):
    global n, m, g, u, v, c, dag
    for i in range(1, n+1):
        g[i].clear()
        dag[i] = 0
    for i in range(1, m+1):
        if c[i] > mid:
            g[u[i]].append(v[i])
            dag[v[i]] += 1
    return top_sort()

def input_t():
    return [int(x) for x in input().split()]

MAX = int(10e5 + 42)
n, m = input_t()
r = 0
u, v, c = [0] * MAX, [0] * MAX, [0] * MAX
g, dag, top = [[]  for _ in range(MAX)], [0] * MAX, [0] * MAX
cnt = 0

for i in range(1, m + 1):
    u[i], v[i], c[i] = input_t()
    r = max(r, c[i])

l = 0

while l < r:
    mid = (l+r) >> 1
    if check(mid):
        r = mid
    else:
        l = mid + 1

check(l)
for i in range(1, m+1):
    if c[i] <= l and top[v[i]] < top[u[i]]:
        cnt += 1
print(f""{l} {cnt}"")
for i in range(1, m+1):
    if c[i] <= l and top[v[i]] < top[u[i]]:
        print(i, end="" "")",nlogn
"n, s = map(int, input().rstrip().split())
if n <= s:
    print(0)
    exit()
for i in range(s, n + 2):
    l = 0
    for j in str(i):
        l += int(j)
    if i - l >= s:
        break
print(max(n - i + 1, 0))",logn
"from sys import stdin, stdout

def check(k, b, T):
	c = [e for e in b if e[0] >= k]

	if len(c) < k:
		return False, None

	first_k_probs = c[:k]
	s = sum([e[1] for e in first_k_probs])

	if s > T:
		return False, None

	return True, first_k_probs

def solve(n, T, a, t):
	b = []

	for i in range(n):
		b.append((a[i], t[i], i + 1))

	b.sort(key=lambda x: x[1])

	low, high = 0, n
	result = 0
	final_probs = []

	while low <= high:
		mid = (low + high) // 2

		(possible, probs) = check(mid, b, T)
		if possible:
			result, final_probs = mid, probs
			low = mid + 1
		else:
			high = mid - 1

	return (result, [e[2] for e in final_probs])

n, T = (int(x) for x in stdin.readline().split())

a = [0] * n
t = [0] * n

for i in range(n):
	a[i], t[i] = (int(x) for x in stdin.readline().split())

point, probs = solve(n, T, a, t)
stdout.write(""%s\n"" % point)
stdout.write(""%s\n"" % len(probs))
if len(probs) > 0:
	stdout.write(""%s\n"" % "" "".join([str(x) for x in probs]))",nlogn
"from math import *
from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 2**j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)",nlogn
"t=int(input())
for _ in range(t):
	n,k=list(map(int,input().split()))
	if n>=32:
		print(""YES ""+str(n-1))
	else:
		ans=-1
		for i in range(1,n+1):
			p=(4**i)-(2**(i+1))+1
			p*=(((4**(n-i))-1)//3)
			g=(((4**i)-1)//3)
			p+=(((4**i)-1)//3)
			g=(((4**i)-1)//3)-(((4**(i-1))-1)//3)
			if g<=k and p>=k:
				ans=n-i
				break
		if ans!=-1:
			print(""YES ""+str(ans))
		else:
			print(""NO"")",logn
"n, a, b = [int(i) for i in input().split()]
lst = sorted([int(i) for i in input().split()])
print(lst[b]-lst[b-1])",nlogn
"a=int(input())
if a>0:
    print(a)
else:
    a=a-2*a
    k=a//10
    b=a%10
    c=(a//100)*10+b
    if k<c:
        if k!=0:
            print('-%d' %k)
        else:
            print(k)
    else:
        if c!=0:
            print('-%d' %c)
        else:
            print(c)",constant
"n = int(input())
d = []
for i in range(n):
    xx, ww = [int(i) for i in input().split()]
    d.append([xx-ww, xx+ww])
d.sort(key=lambda x:x[0])
last = -100000000000
ans = 0
for i in range(n):
    if last <= d[i][0]:
        last = d[i][1]
        ans += 1
    elif last > d[i][1]:
        last = d[i][1]
print(ans)",nlogn
"import math
import sys
from decimal import Decimal

def main(l,r):

  if l==r:
    return 0

  val=1

  while val*2<=r:
    val*=2

  if val<=l:
    return main(l-val,r-val)
  else:
    return 2*val-1

l,r=list(map(int,input().split()))
print(main(l,r))",logn
"for _ in range(int(input())):
    n = int(input())
    li = sorted(list(map(int, input().split())))
    print(min(li[n - 2] - 1, n - 2))",nlogn
"a=list(map(int, input().split()))
h=0
for i in range(14):
    b=a[:]
    if i==13:
        j=0
    else:
        j=i+1
    if a[i]>0:
        c=0
        t=b[i]%14
        x=b[i]//14
        b[i]=0

        for i in range(14):
            b[i]+=x

        while t>0:
            b[j]+=1
            j+=1
            if j==14:
                j=0
            t-=1
        for i in range(14):
            if b[i]%2==0:
                c+=b[i]

        if c>h:
            h=c
print(h)",constant
"import sys
input=sys.stdin.readline

mod=10**9+7
n,t=map(int,input().split())
a=[]
for i in range(n):
    time,genre=map(int,input().split())
    genre-=1
    a.append((time,genre))
dp=[[0 for j in range(3)] for i in range(1<<n)]
for i in range(n):
    dp[1<<i][a[i][1]]=1
for i in range(1<<n):
    for j in range(3):
        if(dp[i][j]==0):
            continue
        mask=1
        for k in range(n):
            if(i&mask or a[k][1]==j):
                mask<<=1
                continue
            dp[i|mask][a[k][1]]=(dp[i|mask][a[k][1]]+dp[i][j])%mod
            mask<<=1
ans=0
for i in range(1<<n):
    mask=1
    duration=0
    for j in range(n):
        if(i&mask):
            duration+=a[j][0]
        mask<<=1
    if(duration==t):
        ans=(ans+sum(dp[i]))%mod
print(ans)",np
"input()
l=[int(x)%2 for x in input().split()]
print(l.index(sum(l)==1)+1)",linear
"from sys import stdin,stdout
from math import ceil,log
def main():
	d={}
	n=int(stdin.readline())
	a=list(map(int,stdin.readline().split( )))
	m=-1;mm=10**10
	for v in a:
		if v not in d:
			d[v]=1
		else:
			d[v]+=1
		m=max(m,v)
		mm=min(mm,v)
	ans=0

	for v in a:

		exponent=ceil(log(v,2))
		power=2**exponent
		find=0
		while power-v>=0:
			if power-v>mm and power-v>m:
				break

			element=power-v
			if element in d and element==v and d[element]>1:
				find=1
				break
			elif element in d and element!=v:
				find=1
				break
			power=power*2
		if find==0:
			ans+=1
	stdout.write(""%d\n""%(ans))

main()",nlogn
"lst = []
ans = {'purple' : 'Power', 'green' : 'Time', 'blue': 'Space', ""orange"" : ""Soul"", ""red"" : ""Reality"", ""yellow"" : ""Mind""}
for i in range(int(input())):
    lst.append(input())
a = []
for i in ans.keys():
    if i not in lst:
        a.append(ans[i])
print(len(a))
for i in a:
    print(i)",constant
"k = int(input().split()[1])
l = sorted(list(map(int,input().split())))

res = set()
for i in l:
    if i//k  not in res or i%k!=0:
        res.add(i)

print(len(res))",nlogn
"n = int(input())
a = list(map(int, input().split()))
d = set(a)
if (0 in a):
    print(len(d)-1)
else:
    print(len(d))",linear
"R, G, B = list(map(lambda x: int(x), input().split()))
r = list(map(lambda x: int(x), input().split()))
g = list(map(lambda x: int(x), input().split()))
b = list(map(lambda x: int(x), input().split()))

def f(t):
    i, j, k = t
    return (i+1)*(G+1)*(B+1) + (j+1)*(B+1) + (k+1)

max_area = [None]*((R+1)*(G+1)*(B+1)+1)

def get_max_area(i, j, k):
    temp = f((i,j,k))
    if max_area[temp] != None:
        return max_area[temp]
    x1=x2=x3=0
    if i >= 0 and j>=0:
        x1 = get_max_area(i-1, j-1, k) + r[i]*g[j]
    if i >= 0 and k >= 0:
        x2 = get_max_area(i-1, j, k-1) + r[i]*b[k]
    if j >= 0 and k >= 0:
        x3 = get_max_area(i, j-1, k-1) + g[j]*b[k]

    max_area[temp] = max(x1, x2, x3)
    return max_area[temp]

r.sort()
g.sort()
b.sort()
print(get_max_area(R-1, G-1, B-1))",cubic
"def numtostr(a):
    var=[]
    while a>0:

       if a%26==0:
          var.append(""Z"")
          a=a//26-1
       else:
          var.append(chr(a%26-1+ord(""A"")))
          a=a//26
    var.reverse()
    return """".join(var)

def strtonum(b):
    par=len(b)
    result=0
    for i in range(1,par):
        result+=(26**i)
    par=len(b)-1
    for elem in b:
        if par!=0:
             result+=((ord(elem)-ord(""A""))*((26)**par))
        else:
            result += ((ord(elem) - ord(""A""))+1)

        if par==0:
            break
        par -= 1
    return result

def method1(par1):
    C=par1.index(""C"")
    result=numtostr(int(par1[C+1:]))+str(par1[1:C])
    return result

def method2(par2):
    c=0
    for elem in par2:
        try:
            if int(elem):
                break
        except:
            c+=1
    return ""R""+par2[c:]+""C""+str(strtonum(par2[:c]))

i=input()
inp=[]
for j in range(int(i)):
     x=input()
     inp.append(x)
for key in range(len(inp)):
    if ""R"" in inp[key] and ""C"" in inp[key]:
        try:
            if int(inp[key][1:inp[key].index(""C"")]) and int(inp[key][inp[key].index(""C"")+1:]):
                print(method1(inp[key]))
        except:
            print(method2(inp[key]))
    else:
        print(method2(inp[key]))",linear
"n = int(input())
arr = list(map(int,input().split()))
arr.sort()
if n>=2 and  arr[0]==arr[1]==0:
	print(""cslnb"")
else:
	flag=0
	for i in range(n-2):
		if arr[i]==arr[i+1]==arr[i+2]:
			flag=1
			break
	if flag==1:
		print(""cslnb"")
	else:
		flag=0
		ind=0
		for i in range(n-1):
			if arr[i]==arr[i+1]:
				ind = i
				flag+=1
		if flag==1 and ind>0 and arr[ind-1]==arr[ind]-1:
			print(""cslnb"")

		elif flag>=2:
			print(""cslnb"")
		else:
			safe = 0
			for i in range(n):

				if arr[i]-i>=0:
					safe+=arr[i]-i

			if safe%2==0:
				print(""cslnb"")
			else:
				print(""sjfnb"")",nlogn
"n=int(input())
a=list(map(int,input().split()))
l=list(set(a))
l.sort()
if len(l) >=2:
    print(l[1])
else:
    print(""NO"")",nlogn
"n=input();print(max(map(int,(n,n[:-1],n[:-2]+n[-1]))))",constant
"def balance(x1, y1, x2, y2):
    return min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)

def get_lr():
    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 2:
            l = m
        else:
            r = m
    r2 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = n, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res == 2:
            l = m
        else:
            r = m
    l2 = l

    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 1:
            l = m
        else:
            r = m
    r1 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = n, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res >= 1:
            l = m
        else:
            r = m
    l1 = l
    return r1, r2, l2, l1

def get_ud():
    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 2:
            l = m
        else:
            r = m
    r2 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, n, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res == 2:
            l = m
        else:
            r = m
    l2 = l

    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 1:
            l = m
        else:
            r = m
    r1 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, n, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res >= 1:
            l = m
        else:
            r = m
    l1 = l
    return r1, r2, l2, l1

n = int(input())
lr = get_lr()
ud = get_ud()
rr = [lr[0], lr[1]]
ll = [lr[2], lr[3]]
uu = [ud[0], ud[1]]
dd = [ud[2], ud[3]]
for r1 in rr:
    r2 = rr[0] if rr[0] != r1 else rr[1]
    for l1 in ll:
        l2 = ll[0] if ll[0] != l1 else ll[1]
        for u1 in uu:
            u2 = uu[0] if uu[0] != u1 else uu[1]
            for d1 in dd:
                d2 = dd[0] if dd[0] != d1 else dd[1]
                if r1 < l1 or r2 < l2 or u1 < d1 or u2 < d2:
                    continue
                print('?', l1, d1, r1, u1)
                res1 = int(input())
                print('?', l2, d2, r2, u2)
                res2 = int(input())
                if res1 == res2 == 1:
                    print('!', l1, d1, r1, u1, l2, d2, r2, u2)
                    __import__('sys').exit(0)",logn
"n = int(input())
a = list(map(int, input().split()))

s = a[0] % 998244353
y = a[0]
for x in a[1:]:

	s = s * 2 + y + x
	y = y * 2 + x

	s %= 998244353
	y %= 998244353

print(s)",linear
"money=input()
initi=money

if int(money)<0:
    lst_dig=money[-1]
    lsec_dig=money[-2]
    if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-2]
    else:money=money[:-2]+money[-1]
    print(int(money))
else:
    lst_dig=money[-1]
    lsec_dig=money[-2]
    if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-1]
    else:money=money[:-2]+money[-2]
    if int(initi)>=int(money):
        print(initi)
    else:
        print(money)",constant
"import sys

num_riders, _ = map(int, next(sys.stdin).split())

houses = map(int, next(sys.stdin).split())
is_rider = map(int, next(sys.stdin).split())

current_left_driver = None
current_citizens = []

result = []

for house, is_rider in zip(houses, is_rider):
    if is_rider:
        if current_left_driver is None:
            result.append(len(current_citizens))
        else:
            result.append(0)
            for citizen in current_citizens:
                if abs(citizen - current_left_driver) <= abs(citizen - house):
                    result[-2] += 1
                else:
                    result[-1] += 1

        current_citizens = []
        current_left_driver = house
    else:
        current_citizens.append(house)

result[-1] += len(current_citizens)

print(' '.join(map(str, result)))",linear
"a,b,c,n = map(int,input().split())
if c > a or c > b or (a+b) - c >=n:
    print(-1)
else:
    print(n -((a+b)-c))",constant
"from math import floor
from sys import stdin

CONST = 9

def solve(k):
    i = 0
    while k > CONST * (10 ** i) * (i + 1):
        k -= floor(CONST * (10 ** i)) * (i + 1)
        i += 1
    num_digits = i + 1
    num = floor((k - 1) / num_digits)
    num += floor(10 ** (i))
    print(('{}'.format(num))[(k - 1) % num_digits])

if __name__ == '__main__':
    for line in stdin:
        solve(int(line.rstrip()))",logn
"n,m,k=map(int,input().split())
x=list(map(int,input().split()))
x.sort(reverse=True)
i=-1
if k>=m:
    print(0)
else:
    for i in range(n):
        k-=1
        k+=x[i]
        if k>=m:
            break
    if k>=m:
        print(i+1)
    else:print(-1)",nlogn
"import sys
import math
import itertools
import functools
import collections
import operator

def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def wr(arr): return ' '.join(map(str, arr))
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=1):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)

n, k = mi()
t = math.ceil(math.sqrt(2 * (n + k) + 2.25) - 1.5)
print(n - t)",logn
"import sys
input=sys.stdin.readline
n=int(input())
a=list(map(int,input().split()))
INF=10**9
dp=[[INF]*(n+1) for i in range(n+1)]
val=[[-1]*(n+1) for i in range(n+1)]
for i in range(n):
  dp[i][i+1]=1
  val[i][i+1]=a[i]
for l in range(2,n+1):
  for i in range(n-l+1):
    j=i+l
    for k in range(i+1,j):
      if dp[i][k]==dp[k][j]==1 and val[i][k]==val[k][j]:
        dp[i][j]=1
        val[i][j]=val[i][k]+1
      else:
        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])
print(dp[0][n])",cubic
"from collections import defaultdict
from collections import deque
import sys
input = sys.stdin.readline

def bfs(s):
    q = deque()
    q.append(s)
    dist = [-1] * (n + 1)
    dist[s] = 0
    p = []
    parent = [1] * (n + 1)
    ok = [0] * (n + 1)
    while q:
        i = q.popleft()
        d = dist[i]
        if d < 3:
            ok[i] = 1
        p.append(i)
        for j in G[i]:
            if dist[j] == -1:
                q.append(j)
                dist[j] = d + 1
                parent[j] = i
    ans = 0
    while p:
        i = p.pop()
        j = parent[i]
        if not ok[i]:
            ok[j] = 1
            ans += 1
            for k in G[j]:
                ok[k] = 1
    return ans

n = int(input())
G = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    u, v = map(int, input().split())
    G[u].append(v)
    G[v].append(u)
ans = bfs(1)
print(ans)",linear
"from collections import defaultdict,deque
from heapq import heappush, heappop
from bisect import bisect_left, bisect_right
import sys, itertools, math
sys.setrecursionlimit(10**5)
input = sys.stdin.readline
sqrt = math.sqrt
def LI(): return list(map(int, input().split()))
def LF(): return list(map(float, input().split()))
def LI_(): return list(map(lambda x: int(x)-1, input().split()))
def II(): return int(input())
def IF(): return float(input())
def S(): return input().rstrip()
def LS(): return S().split()
def IR(n):
    res = [None] * n
    for i in range(n):
        res[i] = II()
    return res
def LIR(n):
    res = [None] * n
    for i in range(n):
        res[i] = LI()
    return res
def FR(n):
    res = [None] * n
    for i in range(n):
        res[i] = IF()
    return res
def LIR(n):
    res = [None] * n
    for i in range(n):
        res[i] = IF()
    return res
def LIR_(n):
    res = [None] * n
    for i in range(n):
        res[i] = LI_()
    return res
def SR(n):
    res = [None] * n
    for i in range(n):
        res[i] = S()
    return res
def LSR(n):
    res = [None] * n
    for i in range(n):
        res[i] = LS()
    return res
mod = 1000000007
inf = float('INF')

def solve():
    n = II()
    a = LI()
    dp = [[None for i in range(n + 1)] for i in range(n + 1)]
    for i in range(n):
        dp[i][i + 1] = [a[i], a[i], 1]
        dp[i + 1][i] = [a[i], a[i], 1]
    for i in range(2, n + 1):
        for l in range(n - i + 1):
            tmp = [-inf, inf, inf]
            r = l + i
            dpl = dp[l]
            dpr = dp[r]
            for m in range(l + 1, r):
                lm = dpl[m]
                mr = dpr[m]
                lr = lm[2] + mr[2] - (lm[1] == mr[0])
                if lr < tmp[2]:
                    tmp[2] = lr
                    if lm[1] == mr[0]:
                        if lm[2] == 1:
                            tmp[0] = lm[0] + 1
                        else:
                            tmp[0] = lm[0]
                        if mr[2] == 1:
                            tmp[1] = mr[1] + 1
                        else:
                            tmp[1] = mr[1]
                    else:
                        tmp[0] = lm[0]
                        tmp[1] = mr[1]
            dp[l][r] = tmp
            dp[r][l] = tmp
    print(dp[0][n][2])
    return

if __name__ == '__main__':
    solve()",cubic
"class Solution:
    def reverseBits(self, n: int) -> int:
        binary = """"
        for i in range(32):
            if n & (1 << i):
                binary += ""1""
            else:
                binary += ""0""

        res = 0
        for i, bit in enumerate(binary[::-1]):
            if bit == ""1"":
                res |= (1 << i)

        return res",constant
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))
def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def fastPrintNextLines(a):

    print('\n'.join(map(str,a)))

if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"")
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
t = 1

for _ in range(t):
    n = ii()
    a = li()
    s = sum(a)
    cur = 0
    for i in range(n):
        cur+=a[i]
        if cur>=s/2:
            print(i+1)
            break",linear
"from math import ceil
n = int(input())
if n == 1:
    print(1)
    exit(0)
if n == 2:
	print('1 2')
	exit(0)
elif n == 3:
	print('1 1 3')
	exit(0)
o = 0
if n&1:
	n -= 1
	o = 1
ans, i, t = '1 ' * ceil(n / 2), 1, n
n = ceil(n/2)
j = 2
while n > 1:
	ans += (str(j) + ' ') * ((n // 2) if t&1 else ceil(n/2))
	i += 1
	j = pow(2, i)
	n //= 2
print(('1 ' if o else '') + ans + str((j//2)*(t//(j//2))))",nlogn
"import sys
input = sys.stdin.readline
import math
import copy
import collections
from collections import deque
import heapq
import itertools
from collections import defaultdict
from collections import Counter

n,k = map(int,input().split())
mod = 998244353
dp = [[[0 for z in range(2)] for j in range(k+1)] for i in range(n)]

dp[0][1][0] = 1
if k>=2:
    dp[0][2][1] = 1
for i in range(1,n):
    for j in range(1,k+1):
        dp[i][j][0] += dp[i-1][j-1][0]+dp[i-1][j][0]+2*dp[i-1][j][1]
        dp[i][j][0]%=mod
        if j-2>=0:
            dp[i][j][1] += 2*dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i-1][j-2][1]
        else:
            dp[i][j][1] += dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i][j-1][0]
        dp[i][j][1]%=mod
ans = 0
for z in range(2):
    ans+=dp[n-1][k][z]
ans*=2
print(ans%mod)",np
"n=int(input())
a=list(map(int,input().split()))
d=set()
t={}
rep=set()
if a.count(0)>=2:
	print(""cslnb"")
	exit()

for i in a:
	if i in d:
		if t[i]+1==3:
			print(""cslnb"")
			exit()
		else:
			t[i]+=1
			rep.add(i)
			if len(rep)>=2:
				print(""cslnb"")
				exit()
	else:
		t[i]=1
		d.add(i)
if rep:
	for c in rep:
		if c-1 in d:
			print(""cslnb"")
			exit()
s=0
a.sort()
for i in range(n):
	s+=a[i]-i
if s%2==1:print(""sjfnb"")
else:print(""cslnb"")",nlogn
"t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if n == 1:
        print(0)
    else:
        max1 = max2 = -1
        for q in a:
            if q > max1:
                max1, max2 = q, max1
            elif q > max2:
                max2 = q
        print(max(0, min(max2-1, len(a)-2)))",linear
"n, d = map(int, input().split())
lst = list(map(int, input().split()))
lst.sort()
Ans = 2
for i in range(1, n):
    if lst[i] - lst[i - 1] > 2 * d:
        Ans += 2
    elif lst[i] - lst[i - 1] == 2 * d:
        Ans += 1
print(Ans)",linear
"def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

n = INT()
arr = LIST()

i = 0
p = []
while 2**i <= 10**18:
    p.append(2**i)
    i = i+1

d = {}
s1= set()
for i in arr:
    s1.add(i)
    if i not in d :
        d[i] = 1
    else:
        d[i]+=1

s2 = set()
for i in s1 :
    flag = False
    for j in p :
        x = j - i
        k = -1
        try:
            k = d[x]
        except :
            k = -1
        if k != -1:
            if x == i and d[i] == 1 :
                continue
            else:
                flag = True
                break
    if flag == False:
        s2.add(i)

res = 0
for i in s2 :
    res+=d[i]
print(res)",nlogn
"import sys

N, M, K, L = map(int, sys.stdin.readline().split())

if M * (N / M) - K < L:
  print(""-1"")
  sys.exit(0)

def solve(curr):
  return curr * M - K >= L

l = 0
r = N / M
while r - l > 1:
  mid = (r + l) / 2
  if solve(mid):
    r = mid
  else:
    l = mid

print(r)",logn
"import bisect
import collections
import copy
import functools
import heapq
import itertools
import math
import random
import re
import sys
import time
import string
from time import time_ns
from typing import List
sys.setrecursionlimit(99999)

def II():return int(sys.stdin.readline().strip())
def IIs():return list(map(int,sys.stdin.readline().strip().split()))
def SI():return sys.stdin.readline().strip()

n=II()
if n&1:
    print(9,n-9)
else:
    print(8,n-8)",constant
"def main():
    n = int(input())
    piles = list(map(int,input().split()))
    piles.sort()
    num = piles[0]
    count = 1
    two = 0
    two_num = 0
    for i in range(1,n):
        if piles[i] == num:
            count += 1
        else:

            if count > 2:
                print('cslnb')
                return
            elif count == 2:
                two_num = num
                two += 1
            num = piles[i]
            count = 1

    if count == 2:
        two_num = num
        two += 1
    if count > 2:
        print('cslnb')
        return
    if two > 1:
        print('cslnb')
        return

    if two == 1:
        if (two_num-1) in piles:
            print('cslnb')
            return

    if n >= 2:
        if piles[0] == piles[1] and piles[0] == 0:
            print('cslnb')
            return
    moves = 0
    curr = 0
    for i in range(n):
        if piles[i] >= curr:
            moves += piles[i]-curr
            piles[i] = curr
            curr += 1

    for i in piles:
        if i > 0:
            moves += 1
            break

    if n == 1:
        moves += 1
    if moves%2 != 0:
        print('cslnb')
    else:
        print('sjfnb')

main()",nlogn
"from sys import stdin, stdout

s = input()

s = s.split(' ')

M = [0]*9
P = [0]*9
S = [0]*9

for pile in s:
    pile = list(pile)

    num = int(pile[0])
    tile = pile[1]

    if tile=='s':
        S[num-1] += 1
    elif tile=='p':
        P[num-1] += 1
    elif tile=='m':
        M[num-1] += 1

for i in range(9):
    if M[i]==3:
        print(0)
        quit()
    if P[i]==3:
        print(0)
        quit()
    if S[i]==3:
        print(0)
        quit()

for i in range(7):
    if M[i]==1 and M[i+1]==1 and M[i+2]==1:
        print(0)
        quit()
    if P[i]==1 and P[i+1]==1 and P[i+2]==1:
        print(0)
        quit()
    if S[i]==1 and S[i+1]==1 and S[i+2]==1:
        print(0)
        quit()

for i in range(9):
    if M[i]==2:
        print(1)
        quit()
    if P[i]==2:
        print(1)
        quit()
    if S[i]==2:
        print(1)
        quit()

for i in range(8):
    if M[i]==1 and M[i+1]==1:
        print(1)
        quit()
    if P[i]==1 and P[i+1]==1:
        print(1)
        quit()
    if S[i]==1 and S[i+1]==1:
        print(1)
        quit()

for i in range(7):
    if M[i]==1 and M[i+2]==1:
        print(1)
        quit()
    if P[i]==1 and P[i+2]==1:
        print(1)
        quit()
    if S[i]==1 and S[i+2]==1:
        print(1)
        quit()

print(2)",linear
"import sys,io,os,math
try:yash=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
except:yash=lambda:sys.stdin.readline().encode()
I=lambda:[*map(int,yash().split())]
import __pypy__;an=__pypy__.builders.StringBuilder()
n,=I();lis=I();N=22;dp=[-1]*(1<<22)
for i in range(n):
    dp[lis[i]]=lis[i]
    for j in range(22):
        lis[i]^=(1<<j)
for mask in range(1<<22):
    for i in range(22):
        if (mask&(1<<i)) and dp[mask^(1<<i)]!=-1:dp[mask]=dp[mask^(1<<i)]
for num in lis:
    an.append(""%s ""%(dp[num]))
an.append(""\n"")
os.write(1, an.build().encode())",np
"n, m = map(int, input().split())
sun, su, ans = 0, 0, 0
arr, brr, dif = [], [], []
for i in range(n):
    a, b = map(int, input().split())

    sun += a; su += b
    dif.append(a - b)
if(su > m):print(-1)
elif(sun == m):print(0)
else:
    dif.sort()
    j = n - 1
    while(sun > m):
        sun -= dif[j]
        ans += 1
        j -= 1
    print(ans)",nlogn
"n = int(input())
l = [int(i) for i in input().split()]
r = [int(i) for i in input().split()]

items = [(-l[i]-r[i],i) for i in range(n)]
items.sort()
vals = [1] * n
m = 1
for i in range(1, n):
    if items[i-1][0] != items[i][0]:
        m += 1
    vals[items[i][1]] = m

for i in range(n):
    ln = sum(map(lambda x: x-vals[i] > 0, vals[:i]))
    lr = sum(map(lambda x: x-vals[i] > 0, vals[i:]))
    if ln != l[i] or lr != r[i]:
        print('NO')
        break
else:
    print('YES')
    print(' '.join(str(i) for i in vals))",quadratic
"n, m, k =map(int, input().split())
horizontal = [list(map(int, input().split())) for i in range(n)]
vertical = [list(map(int, input().split())) for i in range(n-1)]
if k%2 or max(n, m)==1:print(*["" "".join(['-1']*m) for i in range(n)], sep='\n');exit()
dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]
for length in range(1, k//2+1):
    for i in range(n):
        for j in range(m):
            left_path = 10e7 if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]
            right_path = 10e7 if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]
            top_path = 10e7 if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]
            bottom_path = 10e7 if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]
            dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])
for i in range(n):print(*[dp[i][j][k//2]*2 for j in range(m)])",cubic
"def bin(num):
    i=9*num*11
    count=0
    add=0
    for j in range(100):
        add=0
        a=str(i)
        for k in range(10):
            add+=(a.count(str(k))*k)
        if i-add>=s:
            return i
        i+=1
    return -1

n,s=map(int,input().split())
i=0
j=10**30
limit=0
while i<j:
    m=(i+j)//2
    if bin(m) == -1:
        i=m+1
    else:
        j=m
print(max(0,n-bin(i)+1))",logn
"from collections import Counter
import math

i1 = list(input())
i2 = list(input())

a = Counter(i1)
b = Counter(i2)

c = b-a
d = a-b

c1 = list(c.elements())
d1 = list(d.elements())

count = 0
for i in c1:
  if i == ""?"":
    count = count+1
if count != len(d1):
  print(0)
else:
  x = len(c1)
  that = 0
  for i in d1:
    if i == ""+"":
      that = that + 1
  out = math.factorial(x)/((math.factorial(that))*math.factorial(x-that))
  print(out/math.pow(2,x))",np
"x,k = map(int, input().strip().split())

MOD = 1000000007

if x > 0:
	r = (pow(2, k+1, MOD) * x - pow(2, k, MOD) + 1 + MOD * 10) % MOD
else:
	r = 0

print(r)",logn
"n = int(input())
x, y = [int(i) for i in input().split()]

d1 = abs(x - 1) + abs(y - 1)
d2 = abs(n - x) + abs(n - y)

print(""White"" if d1 <= d2 else ""Black"")",constant
"n, m = map(int, input().split())
tc = [0]*m
ps = []
for _ in range(n):
    temp = input()
    psa = [0]*m
    for i in range(m):
        if temp[i] == '1':
            psa[i] += 1
            tc[i] += 1
    ps.append(psa)
ans = 'NO'

for i in ps:
    c = 0
    for j in range(m):
        if tc[j]-i[j] > 0:
            c += 1
    if c == m:
        ans = 'YES'
        break

print(ans)",quadratic
"x, k = map(int, input().split())
mod = 10**9+7
if x==0:
    print(0)
else:
    p = pow(2, k, mod)
    res = (((2*x)%mod + mod - 1)%mod)
    res = ((res*p)%mod + 1)%mod
    print(res)",logn
"import sys
input_file = sys.stdin

[n,m] = list(int(x) for x in input_file.readline().split())
stacks = list(int(x) for x in input_file.readline().split())
stacks.sort()

ans = 0
cur_stack = 0
cur_h = 0

while cur_stack < n:
    ans += 1
    if stacks[cur_stack] >= cur_h + 1:
        cur_h += 1
    cur_stack += 1
ans += stacks[-1] - cur_h

print(sum(stacks) - ans)",nlogn
"s0=input()
k=int(input())
s1=s0[::-1]
lens1=len(s1)
maxnum=1005
mod=1000000007
dp=[[0]*maxnum for tmpi in range(maxnum)]
f=[0]*maxnum
c=[[0]*maxnum for tmpi in range(maxnum)]

def cntone(num):
    tmps=bin(num)[2:]
    cnt=0
    for i in range(len(tmps)):
        if(tmps[i]=='1'):
            cnt+=1
    return cnt

for i in range(1,maxnum):
    if(i==1):
        f[i]=0
    else:
        f[i]=f[cntone(i)]+1

for i in range(maxnum):
    if(i==0):
        c[i][0]=1
        continue
    for j in range(i+1):
        if(j==0):
            c[i][j]=1
        else:
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod

for i in range(lens1):
    if(i==0):
        dp[i][0] = 1
        if(s1[i]=='1'):
            dp[i][1]=1
        else:
            dp[i][1]=0
        continue
    else:
        for j in range(0,i+2):
            if(j==0):
                dp[i][j]=1
                continue
            if(s1[i]=='1'):
                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod
            else:
                dp[i][j]=dp[i-1][j]%mod

ans=0

for i in range(1,lens1+1):
    if(f[i]==k-1):
        ans=(ans+dp[lens1-1][i])%mod

if(k==0):
    ans=1
elif(k==1):
    ans-=1
else:
    ans=ans
print(ans)",linear
"import bisect as bi
n,q = map(int,input().split())
a = list(map(int,input().split()))
l = list(map(int,input().split()))
som = sum(a)
e = 0
p = []
for i in a:
    e += i
    p.append(e)

e = 0
s = set(p)
for i in l:
    e += i
    if e >= som:
        e = 0

    x = bi.bisect(p,e)
    print(n-x)",nlogn
"from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):
    return set(reduce(list.__add__,
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()
def decimalToBinary(n):
    return bin(n).replace(""0b"", """")

def isPrime(n) :
	if (n <= 1) :
		return False
	if (n <= 3) :
		return True

	if (n % 2 == 0 or n % 3 == 0) :
		return False

	i = 5
	while(i * i <= n) :
		if (n % i == 0 or n % (i + 2) == 0) :
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x):
    return (math.log10(x) /
            math.log10(2));

def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) == math.floor(Log2(n)));

n,k=map(int,input().split())
a=list(map(int,input().split()))
dic=get_frequency(a)
ss=sorted(list(set(a)))
tobesubtracttion=0
for i in range(len(ss)-1):
    if ss[i+1] <= ss[i]+k:
        tobesubtracttion+=dic[ss[i]]
print(n-tobesubtracttion)",nlogn
"import sys
sys.stderr = sys.stdout

from math import inf

def explorer(n, m, k, R, C):
    if k % 2:
        return None

    G = [[0] * m for _ in range(n)]
    G_ = [[0] * m for _ in range(n)]
    for _ in range(k // 2):
        for i in range(n):
            for j in range(m):
                x = inf
                if i > 0:
                    x = min(x, G[i-1][j] + 2*C[i-1][j])
                if i + 1 < n:
                    x = min(x, G[i+1][j] + 2*C[i][j])
                if j > 0:
                    x = min(x, G[i][j-1] + 2*R[i][j-1])
                if j + 1 < m:
                    x = min(x, G[i][j+1] + 2*R[i][j])
                G_[i][j] = x
        G, G_ = G_, G
    return G

def main():
    n, m, k = readinti()
    R = readintll(n)
    C = readintll(n-1)
    G = explorer(n, m, k, R, C)
    if G:
        print(llstr(G))
    else:
        s = ' '.join('-1' for _ in range(m))
        print('\n'.join(s for _ in range(n)))

def readint():
    return int(input())

def readinti():
   return map(int, input().split())

def readintt():
   return tuple(readinti())

def readintl():
   return list(readinti())

def readinttl(k):
    return [readintt() for _ in range(k)]

def readintll(k):
    return [readintl() for _ in range(k)]

def lstr(l):
    return ' '.join(map(str, l))

def llstr(ll):
    return '\n'.join(map(lstr, ll))

def log(*args, **kwargs):
    print(*args, **kwargs, file=sys.__stderr__)

if __name__ == '__main__':
    main()",cubic
"n,s = input().split()

i = int(s)
d_sum = sum(list(map(int,str(i))))
while i - d_sum < int(s):
    i += 1
    d_sum = sum(list(map(int,str(i))))

print((max(0,int(n)-i+1)))",logn
"n=int(input())
li=list(map(int,input().split("" "")))
dp1=[]
for i in range(n):
  lis=[-1]*n
  dp1.append(lis)
dp2=[0]*n
for i in range(n):
  dp1[i][i]=li[i]

for i in range(n):
  dp2[i]=i+1
size=2

while size<=n:
  i=0
  while i<n-size+1:
    j=i+size-1
    k=i
    while k<j:
      if dp1[i][k]!=-1:
        if dp1[i][k]==dp1[k+1][j]:
          dp1[i][j]=dp1[i][k]+1
      k+=1
    i+=1
  size+=1

i=0
while i<n:
  k=0
  while k<=i:
    if dp1[k][i]!=-1:
      if k==0:
        dp2[i]=1
      else:
        dp2[i]=min(dp2[i],dp2[k-1]+1)
    k+=1
  i+=1

print(dp2[n-1])",cubic
"n = int(input())

arr = list(map(int, input().split(' ')))
arr.sort()

stop = 0
equal = -1
tempcounter = 0

for i in range(1, n):
    if arr[i] == arr[i-1]:
        equal = arr[i]
        tempcounter += 1
        if tempcounter == 2:
            break

if tempcounter == 1 and equal != 0:
    for j in range(n):
        if arr[j] == equal-1:
            print(""cslnb"")
            stop = 1

if tempcounter == 1 and equal == 0:
    print(""cslnb"")

elif tempcounter < 2 and stop == 0:
    moves = arr[0]
    counter = 0

    for i in range(1, n):
        moves += arr[i] - i

    if counter == 0:
        if moves%2 == 0:
            print(""cslnb"")

        else:
            print(""sjfnb"")

elif stop == 0:
    print(""cslnb"")",nlogn
"n=int(input())
a=list(map(int,input().split()))
c=0
po=[0]*1000000
ne=[0]*1000000
for i in range(n):
    if(a[i]<0 and ne[a[i]]!=1):
        c+=1
        ne[a[i]]=1
    elif(a[i]>0 and po[a[i]]!=1):
        c+=1
        po[a[i]]=1
print(c)",linear
"n = int(input())
f0= 0
f1 = 1
li = [0,1]
for i in range(45):
	t = f1
	f1 += f0
	f0 = t
	li.append(f1)
x = []
for i in range(3):
	for i in range(len(li)-1, -1, -1):
		if li[i] <= n:
			n -= li[i]
			x.append(li[i])
			break
if n == 0:
	print(*x, sep = "" "")
else:
	print(""I'm too stupid to solve this problem"")",constant
"r=input()
t1=int(r)
t2=int(r[:len(r)-1])
t3=int(r[:len(r)-2]+r[-1])
print(max(t1,t2,t3))",constant
"n,m,a,b=[int(x)for x in input().split()]
if n<m:print(min(a*(m-n),b*n))
else:print(min(b*(n%m),a*(m-(n%m)) ))",linear
"import sys
from itertools import accumulate

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
INF = 10 ** 18
MOD = 10 ** 9 + 7

def build_grid(H, W, intv, _type, space=True, padding=False):
    if space:
        _input = lambda: input().split()
    else:
        _input = lambda: input()
    _list = lambda: list(map(_type, _input()))
    if padding:
        offset = 1
    else:
        offset = 0
    grid = list2d(H+offset*2, W+offset*2, intv)
    for i in range(offset, H+offset):
        row = _list()
        for j in range(offset, W+offset):
            grid[i][j] = row[j-offset]
    return grid

H, W = MAP()
grid = build_grid(H, W, '

ans = []
imosw = list2d(H+2, W+2, 0)
imosh = list2d(H+2, W+2, 0)
def check(i, j):
    sz = min(L[i][j], R[i][j], U[i][j], D[i][j])
    if sz > 1:
        imosw[i][j-sz+1] += 1
        imosw[i][j+sz] -= 1
        imosh[i-sz+1][j] += 1
        imosh[i+sz][j] -= 1
        ans.append((i, j, sz-1))

def check2():
    for i in range(1, H+1):
        for j in range(1, W+1):
            if grid[i][j] == '*' and not imosw[i][j] and not imosh[i][j]:
                return False
    return True

L = list2d(H+2, W+2, 0)
R = list2d(H+2, W+2, 0)
U = list2d(H+2, W+2, 0)
D = list2d(H+2, W+2, 0)
for i in range(1, H+1):
    for j in range(1, W+1):
        if grid[i][j] == '.':
            L[i][j] = 0
        else:
            L[i][j] = L[i][j-1] + 1
for i in range(1, H+1):
    for j in range(W, 0, -1):
        if grid[i][j] == '.':
            R[i][j] = 0
        else:
            R[i][j] = R[i][j+1] + 1
for j in range(1, W+1):
    for i in range(1, H+1):
        if grid[i][j] == '.':
            U[i][j] = 0
        else:
            U[i][j] = U[i-1][j] + 1
for j in range(1, W+1):
    for i in range(H, 0, -1):
        if grid[i][j] == '.':
            D[i][j] = 0
        else:
            D[i][j] = D[i+1][j] + 1

for i in range(1, H+1):
    for j in range(1, W+1):
        if grid[i][j] == '*':
            check(i, j)
for i in range(1, H+1):
    for j in range(W+1):
        imosw[i][j+1] += imosw[i][j]
for j in range(1, W+1):
    for i in range(H+1):
        imosh[i+1][j] += imosh[i][j]

if check2():
    print(len(ans))
    [print(h, w, sz) for h, w, sz in ans]
else:
    print(-1)",quadratic
"n, q = map(int, input().split())
for _ in range(q):
    u = int(input())
    s = input()
    for comm in s:
        k = 1
        while True:
            if k & u:
                break
            k <<= 1
        if comm == 'L':
            if k != 1:
                u -= k
                u += (k>>1)
        elif comm == 'R':
            if k != 1:
                u += (k>>1)
        elif comm == 'U':
            nu = u - k
            nu |= (k<<1)
            if nu <= n:
                u = nu
    print(u)",np
"import bisect
import copy
import decimal
import fractions
import heapq
import itertools
import math
import random
import sys
from collections import Counter,deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap)-1)
def _heappushpop_max(heap, item):
    if heap and item < heap[0]:
        item, heap[0] = heap[0], item
        heapq._siftup_max(heap, 0)
    return item
from math import gcd as GCD
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N=int(readline())
A=list(map(int,readline().split()))
mod=10**9+7
m=max(A)
cnt=[0]*(m+1)
P=Prime(m)
for a,c in Counter(A).items():
    for aa in P.Divisors(a):
        cnt[aa]+=c
for i in range(1,m+1):
    cnt[i]=pow(2,cnt[i],mod)-1
    cnt[i]%=mod
for p in P.primes:
    for i in range(p,m+1,p):
        cnt[i//p]-=cnt[i]
        cnt[i//p]%=mod
ans=cnt[1]
print(ans)",np
"n = int(input())
rng = []
for _ in range(n):
    x, w = map(int, input().split())
    rng.append((x-w, x+w))
rng.sort(key=lambda x: (x[1], x[0]))

ans = 0
tmp = - 10 ** 10
for l, r in rng:
    if tmp <= l:
        ans += 1
        tmp = r

print(ans)",nlogn
"from sys import stdin
from bisect import bisect_right as br

from collections import deque
n,m,k=map(int,stdin.readline().strip().split())
s=deque(map(int,stdin.readline().strip().split()))
lim=k
ans=0
while len(s)!=0:
    x=br(s,lim)
    for i in range(x):
        s.popleft()
    if x!=0:
        ans+=1
        lim+=x
    else:
        if len(s)>0:
            x=s[0]-lim
            if x%k==0:
                x=x//k
            else:
                x=(x//k)+1
            lim+=x*k

print(ans)",linear
"a = list(input())
b = int(input())
a = sorted(a, reverse=True)
ans = ''
while len(a) > 0:
    for i in range(len(a)):
        tmp = ans + a[i] + ''.join(sorted(a[:i] + a[i + 1:]))
        if int(tmp) <= b:
            ans += a[i]
            a = a[:i] + a[i + 1:]
            break
print(ans)",cubic
"n=int(input())

x=1

while n>(10**(len(str(x))-1)*9*len(str(x))):
    n-=10**(len(str(x))-1)*9*len(str(x))

    x*=10

t=len(str(x))
nadighe=False
while nadighe==False:
    qw=1
    nadighe=True
    while n>(10**(len(str(qw))-1)*9*t):
        n-=10**(len(str(qw))-1)*9*t
        nadighe=False
        qw*=10
    x+=qw-1

while n>len(str(x)):
    n-=len(str(x))
    x+=1
for i in range(len(str(x))):
    if n!=0:
        s=str(x)[i]
        n-=1
print(s)",constant
"n=int(input())
l=[input() for i in range(n)]

s=sorted(l,key=len)
for i in range(1,n):
    if s[i-1] not in s[i]:
        print(""NO"")
        exit()

print(""YES"")
for i in s:
    print(i)",nlogn
"l=list(map(int,input().split()))
ans=0
for i in range(14):
	a=[]
	m=0
	a.extend(l)
	c=a[i]//14
	d=a[i]%14
	a[i]=0
	j=1
	while(j<=d):
		k=(i+j)%14
		a[k]+=1
		j+=1
	for j in range(14):
		a[j]+=c
		if a[j]%2==0:
			m+=a[j]
	ans=max(ans, m)
print(ans)",constant
"import sys
readline = sys.stdin.buffer.readline

N = int(readline())
A = list(map(int, readline().split()))

dp = [[0]*N for _ in range(N)]
for j in range(N):
    dp[j][0] = A[j]

for l in range(1, N):
    for j in range(l, N):
        for k in range(j-l, j):
            if dp[k][k-j+l] == dp[j][j-k-1] > 0:
                dp[j][l] = 1+dp[j][j-k-1]
                break

dp = [None] + dp
Dp = [0]*(N+1)
for j in range(1, N+1):
    res = N
    for l in range(j):
        if dp[j][l]:
            res = min(res, 1+Dp[j-l-1])
    Dp[j] = res
print(Dp[N])",cubic
"import os, sys
from io import BytesIO, IOBase

def main():
    n = rint()
    deg = [0] * n
    if n == 2:
        exit(print(f'Yes\n1\n1 2'))

    for i in range(n - 1):
        u, v = rints()
        deg[u - 1] += 1
        deg[v - 1] += 1

    ix = deg.index(max(deg))

    if deg[ix] < 3 or deg.count(1) + deg.count(2) == n - 1:
        print(f'Yes\n{deg.count(1)}')

        for i in range(n):
            if deg[i] == 1:
                print(i + 1, ix + 1)
    else:
        print('No')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()",linear
"import sys
import string
from math import gcd
import getpass
import math
from decimal import Decimal
import pprint

def ria():
    return [int(i) for i in input().split()]

if getpass.getuser() != 'frohenk':
    filename = 'half'

else:
    sys.stdin = open('input.txt')

n = ria()[0]
x, y = ria()
d1 = abs(1 - x) + abs(1 - y)
d2 = abs(n - x) + abs(n - y)
if d1<=d2:
    print('White')
else:
    print('Black')",constant
"if __name__ == '__main__':
		n,m = map(int, input().split())
		l = list(map(int, input().split()))
		d = dict()
		if len(set(l)) < n:
			print(0)
		else:
			for i in range (m):
				d.setdefault(l[i],0)
				d[l[i]]+=1
			min1 = 999999999
			for i in d.values():
				if i < min1 :
					min1 = i
			print(min1)",quadratic
"from heapq import *
import sys

int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def SI(): return sys.stdin.readline()[:-1]

def main():
    inf=10**9
    n=II()
    aa=LI()
    dp1=[[-1]*(n+1) for _ in range(n)]
    to=[[i+1] for i in range(n)]
    for i in range(n):dp1[i][i+1]=aa[i]
    for w in range(2,n+1):
        for l in range(n-w+1):
            r=l+w
            for m in range(l+1,r):
                if dp1[l][m]!=-1 and dp1[l][m]==dp1[m][r]:
                    dp1[l][r]=dp1[l][m]+1
                    to[l].append(r)
    hp=[]
    heappush(hp,(0,0))
    dist=[-1]*(n+1)
    while hp:
        d,i=heappop(hp)
        if i==n:
            print(d)
            break
        if dist[i]!=-1:continue
        dist[i]=d
        for j in to[i]:
            if dist[j]!=-1:continue
            heappush(hp,(d+1,j))

main()",cubic
"a = [int(i) for i in list(input())]
b = [int(i) for i in list(input())]

if (len(a)<len(b)):
	a.sort(reverse=True)
	ans = 0
	for i in range(len(a)):
		ans = ans*10+a[i]
	print(ans)
else:

	ans = 0
	n = len(a)
	count = [0]*10
	for i in range(n):
		count[a[i]] += 1
	i = 0
	while (i<n):
		x = b[i]
		if (count[x]>0):
			ans = ans*10+x
			count[x] -= 1
			i += 1
		else:
			break
	if (i==n):
		print(ans)
		exit(0)
	x = b[i]
	flag = False
	for j in range(x-1,-1,-1):
		if (count[j]>0):
			ans = ans*10+j
			count[j] -= 1
			flag = True
			break
	if (flag) :
		for j in range(9,-1,-1):
			while (count[j]>0):
				ans = ans*10+j
				count[j] -= 1
	else:
		while (not flag):
			t = ans%10
			ans = ans//10
			count[t] += 1
			for i in range(t-1,-1,-1):
				if (count[i]>0):
					count[i] -= 1
					flag = True
					ans = ans*10 + i
					break
		for j in range(9,-1,-1):
			while (count[j]>0):
				ans = ans*10+j
				count[j] -= 1
	print(ans)",cubic
"def binary(n,k):
    lower=1
    upper=n
    while(lower<upper):
        mid=(lower+upper)//2
        total=(mid*(mid+1))//2
        if n-mid==total-k:
            print(n-mid)
            break
        else:
            if n-mid>total-k:
                lower=mid+1
            else:
                upper=mid

n,k=map(int,input().split())
if n==1 and k==1:
    print(0)
else:
    binary(n,k)",logn
"import sys
from enum import Enum

class flag(Enum):
    UNVISITED = -1
    EXPLORED = -2
    VISITED = -3

def match(p, s):
    for i in range(len(p)):
        if p[i] != ""_"" and p[i] != s[i]:
            return False
    return True

def cycleCheck(u):
    global AL
    global dfs_num
    global dfs_parent
    global sol

    dfs_num[u] = flag.EXPLORED.value
    for v in AL[u]:
        if dfs_num[v] == flag.UNVISITED.value:
            dfs_parent[v] = u
            cycleCheck(v)
        elif dfs_num[v] == flag.EXPLORED.value:
            sol = False
    dfs_num[u] = flag.VISITED.value

def toposort(u):
    global AL
    global dfs_num
    global ts

    dfs_num[u] = flag.VISITED.value
    for v in AL[u]:
        if dfs_num[v] == flag.UNVISITED.value:
            toposort(v)
    ts.append(u)

sol = True
n, m, k = map(int, sys.stdin.readline().strip().split())
pd = {}
ps = set()
pa = []
for i in range(n):
    p = sys.stdin.readline().strip()
    pd[p] = i + 1
    ps.add(p)
    pa.append(p)

AL = [[] for _ in range(n)]

for _ in range(m):
    s, fn = sys.stdin.readline().strip().split()
    fn = int(fn)
    if not match(pa[fn-1], s):
        sol = False

    mm = [""""]
    for i in s:
        mm = list(map(lambda x: x + ""_"", mm)) + list(map(lambda x: x + i, mm))
    for i in mm:
        if i in ps:
            if pd[i] != fn:
                AL[fn-1].append(pd[i]-1)

try:
    if not sol:
        print(""NO"")
    else:
        dfs_num = [flag.UNVISITED.value] * n
        dfs_parent = [-1] * n
        for u in range(n):
            if dfs_num[u] == flag.UNVISITED.value:
                cycleCheck(u)
        if not sol:
            print(""NO"")
        else:
            dfs_num = [flag.UNVISITED.value] * n
            ts = []
            for u in range(n):
                if dfs_num[u] == flag.UNVISITED.value:
                    toposort(u)
            ts = ts[::-1]
            print(""YES"")
            print(' '.join(map(lambda x: str(x+1), ts)))
except:
    print(""NO"")",np
"vals=list(map(int,input().split()))
l=vals[0]
r=vals[1]

if l==r:
    print(""0"")
else:
    i=0
    j=0
    while l>0 or r>0:
        i+=1
        if (l&1)^(r&1)==1:
            j=i
        l=l>>1
        r=r>>1
    ans=1
    for i in range(0,j):
        ans=ans*2
    ans-=1
    print(ans)",logn
"n = input()
ans = 0
j = 2
for i in range(2,n/2 + 1):
    while i * j <= n:
        ans += j * 4

        j += 1
    else :j = 2
print(ans)",nlogn
"import sys
n = int(input().strip())
sizes = list(map(int, input().strip().split()))
cost = list(map(int, input().strip().split()))
tot = []
for i in range(n):
    tot.append([sizes[i], cost[i]])
ret = False
lcomp = []
for j in range(len(tot)):
    if j > 0 and j < len(tot)-1:
        temp1 = tot[:j]
        temp2 = tot[j+1:]
        mi_1 = sys.maxsize
        ret1 = False
        for i in range(len(temp1)):
            if temp1[i][0] < tot[j][0]:
                mi_1 = min(mi_1, temp1[i][1])
                ret1 = True
        mi_2 = sys.maxsize
        ret2 = False
        for k in range(len(temp2)):
            if temp2[k][0] > tot[j][0]:
                mi_2 = min(mi_2, temp2[k][1])
                ret2 = True
        if ret1 and ret2:
            ret = True
            lcomp.append(mi_1+tot[j][1]+mi_2)

if ret:
    print(min(lcomp))
else:
    print(-1)",quadratic
"for _ in range(int(input())):
	a, b = map(int, input().split())
	result = 0
	while min(a, b)!=0:
		x = max(a, b)
		y = min(a, b)
		a = x
		b = y
		result+=a//b
		a%=b
	print(result)",constant
"class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        res = []

        for i in range(n):
            count = 1
            j = i + 1
            while j < n:
                if temperatures[j] > temperatures[i]:
                    break
                j += 1
                count += 1
            count = 0 if j == n else count
            res.append(count)
        return res",quadratic
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()
dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
ans = 0
for i in dp:
       for j in i:
              ans = max(ans, max(j))

print(ans)",cubic
"def getIntList():
    return list(map(int, input().split()));
n, k = getIntList();
p=getIntList();
choosed=[False]*256;
left=[i for i in range(256)];
for i, x in enumerate(p):
    if not choosed[x]:
        best=x;

        for j in range(x-1, max(-1, x-k), -1):

            if not choosed[j]:
                best=j;
            else:
                if x-left[j]<k:
                    best=left[j];
                break;

        for j in range(best, x+1):
            choosed[j]=True;
            left[j]=best;
    p[i]=left[x];
print(' '.join(map(str, p)));",quadratic
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

count = [[0] * m for _ in range(m)]
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        count[c1][c2] += 1

sum_of_subset = [[0] * (1 << m) for _ in range(m)]
for i in range(m):
    for j in range(1 << m):
        if j == 0:
            continue
        lsb = j & -j
        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]

adj_in_subset = [0] * (1 << m)
for i in range(1 << m):
    for j in range(m):
        if i & (1 << j):
            adj_in_subset[i] += sum_of_subset[j][i]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]
        dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost)
print(dp[-1])",np
"import math
import collections

def func(a, k):
    if a % k != 0:
        mod = 1
    else:
        mod = 0
    return math.floor(a / k) * k + mod * k

n, m, k = input().split()
list = input().split()
k = int(k)
temp = k
size = 0
answer = 0
c = 0
c2 = 0
check = 'false'
used = 0

temp = func(int(list[0]), k)
for i in range(len(list)):
    list[i] = int(list[i])
    used = 0
    if list[i] <= temp:
        c += 1
        check = 'true'
        used = 1
    if list[i] >= temp:
        if check is 'true':
            answer += 1
            check = 'false'
            temp += c
            c = 0
            if list[i] - c <= temp and used == 0:
                c += 1
                check = 'true'
                used = 1
            else:
                temp = temp + func(int(list[i]) - temp, k)
                if list[i] - c <= temp and used == 0:
                    c += 1
                    check = 'true'
                    used = 1
        elif check is 'false':
            temp = temp + func(int(list[i]) - temp, k)
            if list[i] - c <= temp and used == 0:
                c += 1
                check = 'true'
                used = 1

print(answer if check is 'false' else answer + 1)",linear
"N = int(input())

arr = list(map(int, input().split()))

dp = [[-1 for x in range(N)] for y in range(N)]

for size in range(1, N + 1):
    for i in range(N - size + 1):
        j = i + size - 1
        if (i == j):
            dp[i][j] = arr[i]
        else:
            for k in range(i, j):
                if (dp[i][k] != -1 and dp[i][k] == dp[k + 1][j]):
                    dp[i][j] = dp[i][k] + 1

dp2 = [x+1 for x in range(N)]

for i in range(N):
    for k in range(i + 1):
        if (dp[k][i] != -1):
            if (k == 0):
                dp2[i] = 1
            else:
                dp2[i] = min(dp2[i], dp2[k - 1] + 1)

print(dp2[N - 1])",cubic
"M = {}

N = int(input())
S = input().strip()

s = set()
for c in S:
    s.add(c)
    M[c] = 0

i = 0; j = -1; aux = 0; ans = 1e10
while j < N - 1:
    j += 1

    M[S[j]] += 1
    if M[S[j]] == 1:
        aux += 1
    while M[S[i]] > 1:
        M[S[i]] -= 1
        i += 1

    if aux == len(s):
        ans = min(ans, j - i + 1)

print(ans)",linear
"k1, k2, k3  = sorted(map(int, input().split()))

if 1 == k1 or (2 == k1 and 2 == k2) or (3 == k1 and 3 == k2 and 3 == k3) \
    or (k1 == 2 and k2 == 4 and k3 == 4):
    print(""YES"")
else:
    print(""NO"")",constant
"x,k = map(int,input().split())
mod = 10**9 + 7
if x == 0:
    print(0)
else:
    print(((2*x-1)*pow(2,k,mod) + 1)%mod)",logn
"import os,sys
from io import BytesIO, IOBase

def main():
    n = int(input())
    p = [list(map(float,input().split())) for _ in range(n)]
    y = 1<<n
    dp = [[0]*y for _ in range(n)]

    dp[0][y-1] = 1
    for i in range(y-2,-1,-1):
        mask = 1
        for j in range(n):
            if not mask&i:
                mask <<= 1
                continue
            mask1 = 1
            for k in range(n):
                if i&mask1:
                    mask1 <<= 1
                    continue
                dp[j][i] = max(dp[j][i],
                    dp[j][i|mask1]*p[j][k]+dp[k][i|mask1]*p[k][j])
                mask1 <<= 1
            mask <<= 1
    print(max(dp[i][1<<i] for i in range(n)))

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",np
"from itertools import combinations

p, minn, maxn, dif = map(int, input().split())
(*lst,) = map(int, input().split())
c = 0
for i in range(2, p + 2):
    for j in combinations(lst, i):
        if (maxn >= sum(j) >= minn) and (max(j) - min(j) >= dif):
            c += 1
print(c)",np
"from math import gcd

def t_prime(n):
    if n == 1:
        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:
            return False
    return True

primes = [i for i in range(2,10**5) if t_prime(i)]
pset = set(primes)

n, k = map(int, input().split())
l = list(map(int, input().split()))

if k == 1:
    print(0)
    exit()

for i in range(n):
    for j in range(i):
        u, v = l[i], l[j]
        poss = gcd(u,v)
        poss2 = max(u,v)//poss
        smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:
            primes.append(smol)
            pset.add(smol)

powers = set()

count = 0
outLs = []
pgood = []
for p in primes:
    curr = []
    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:
            v2 //= p
        if v2 == 1:
            curr.append(v)
            powers.add(v)
    if len(curr) > 1:
        count += len(curr)
        outLs.append(curr)
        pgood.append(p)

order = [(len(lis), lis) for lis in outLs]
order.sort(key = lambda x: x[0])

if len(order) == 0:
    print(0)
    exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []

    for v in l:
        if v in powers:
            continue

        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2

    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()

    other = []
    out = [extra]

    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k

    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1

    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0

assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",np
"n, s = map(int, input().split())

a, b, c = 0, n + 1, 0

while a < b:
    c = (a + b) // 2
    if c - sum([int(x) for x in str(c)]) < s:
        a = c + 1
    else:
        b = c

print(n - b + 1)",logn
"N, mod = map(int, input().split())

two = [1] * (N+1)
fact = [1] * (N+1)
inv = [1] * (N+1)
for i in range(1, N+1):
    two[i] = two[i-1]*2 % mod
for i in range(2, N+1):
    fact[i] = fact[i-1] * i % mod
inv[N] = pow(fact[N], mod-2, mod)
for i in range(N, 0, -1):
    inv[i-1] = inv[i] * i % mod

dp = [[0] * (N+2) for _ in range(N+2)]
dp[0][0] = 1
for i in range(N):
    for j in range(i+1):
        for k in range(1, N+1):
            if i+k > N:
                break
            dp[i+k+1][j+1] += dp[i][j] * two[k-1] * inv[k] % mod
            dp[i+k+1][j+1] %= mod

ans = 0
for j in range(1, N+1):
    ans += dp[N+1][j] * fact[N-j+1] % mod
    ans %= mod
print(ans)",cubic
"n = list(map(int, input().split()))
u = []
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u[0].sort(reverse=True)
u[1].sort(reverse=True)
u[2].sort(reverse=True)
res = 0
dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]
for i in range(n[0]+1):
    for j in range(n[1]+1):
        for k in range(n[2]+1):
            x0 = (dp[i-1][j-1][k] + u[0][i-1]*u[1][j-1]) if i and j else 0
            x1 = (dp[i][j-1][k-1] + u[1][j-1]*u[2][k-1]) if j and k else 0
            x2 = (dp[i-1][j][k-1] + u[0][i-1]*u[2][k-1]) if i and k else 0
            dp[i][j][k] = max(x0, x1, x2)
            res = max(res, dp[i][j][k])
print(res)",cubic
"n,m,a,b=[int(x) for x in input().split()]
if n>m:
	if n%m==0:
		print(0)
	else:
		t1=n%m
		print(min(t1*b,(m-t1)*a))
elif n==m:
	print(0)
else:
	print(min(n*b,(m-n)*a))",linear
"l,r = map(int,input().split())

x = 64
while x>=0 and  (l&(1<<x)) == (r&(1<<x)):
    x-=1
print((1<<(x+1))-1)",logn
"import sys

rd = lambda : sys.stdin.readline().rstrip()

n = int(rd())
c = list(map(int, rd().split()))
a = list(map(lambda x: int(x)-1, rd().split()))

visited = [-1] * (n)
res = 0

for i in range(n):
    trace = []

    t = i
    mn = 1e9
    while visited[t] == -1:
        visited[t] = i
        trace.append(t)
        t = a[t]

    if visited[t] != i:
        continue

    while len(trace) > 0:
        v = trace.pop()
        mn = min(mn, c[v])

        if t == v: break

    res += mn

print(res)",linear
"a,b=map(int,input().split())
ans=0
while a and b:
  ans+=a//b
  a,b=b,a%b
print(ans)",constant
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int, sys.stdin.readline().strip().split()))
i = a.index(max(a))
v = True
for j in range (0, i):
    if a[j] > a[j+1]:
        v = False
for j in range (i, n-1):
    if a[j] < a[j+1]:
        v = False
if v == True:
    print(""YES"")
else:
    print(""NO"")",linear
"n=int(input())
a=input().split(' ')
for i in range(len(a)):
    a[i]=int(a[i])
khat=n*[0]
ted=0
assl=0
khat[0]=1
lol=[0,0]
for i in range(1,len(khat)):
    khat[i]=max([khat[i-1],a[i]+1])
for i in range(len(khat)-2,-1,-1):
    if khat[i]<khat[i+1]-1:
        khat[i]=khat[i+1]-1
    ted=ted+(khat[i]-(a[i]+1))
ted=ted+(khat[n-1]-(a[n-1]+1))
print(ted)",linear
"n, m = map(int, input().split())

a = []

def is_center(a, y, x):
    count1 = count2 = count3 = count4 = 0

    y1 = y
    x1 = x
    while True:
        y2 = y1 - 1
        if y2 < 0:
            break
        c = a[y2][x]
        if c == ""W"":
            break
        count1 += 1
        y1 = y2

    y1 = y
    x1 = x
    while True:
        y2 = y1 + 1
        if y2 == n:
            break
        c = a[y2][x]
        if c == ""W"":
            break
        count2 += 1
        y1 = y2

    y1 = y
    x1 = x
    while True:
        x2 = x1 - 1
        if x2 < 0:
            break
        c = a[y1][x2]
        if c == ""W"":
            break
        count3 += 1
        x1 = x2

    y1 = y
    x1 = x
    while True:
        x2 = x1 + 1
        if x2 == m:
            break
        c = a[y1][x2]
        if c == ""W"":
            break
        count4 += 1
        x1 = x2

    return count1 == count2 == count3 == count4 and a[y][x] == ""B""

for k in range(n):
    s = input()
    a.append(s)

for y in range(n):
    c = False
    for x in range(m):
        if is_center(a, y, x):
            print(y+1, x+1)
            c = True
            break
    if c:
        break",quadratic
"from math import log
n,k=map(int,input().split())
s=list(map(int,input().split()))
ans=0
for j in range(11):
    d=dict()
    z=10**j
    for i in s:
        y=i*z
        u=y%k
        if u in d:
            d[u]+=1
        else:
            d.update({u:1})
    for i in s:
        y=i
        lg=int(log(i,10))+1
        lg=10**lg
        if lg==z:
            d[(y*z)%k]-=1
            x=(k-y%k)
            if y%k==0:
                x=0
            if x in d:
                ans+=d[x]
            d[(y*z)%k]+=1
print(ans)",nlogn
"n = int(input())
li1 = []
s=""""
li2 = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""red"":""Reality"",""yellow"":""Mind""}
for i in range(n):
    s = input()
    li1.append(s)
print(6-n)
for key in li2:
    if key in li1:
        continue
    else:
        li1.append(key)
        print(li2[key])",constant
"n, q = map(int, raw_input().split())
l = raw_input()
cnt1, cnt0 = [0]*(n+1), [0]*(n+1)
mod = 10**9 + 7
for i in range(len(l)):
	if l[i] == '1':
		cnt1[i+1] = cnt1[i] + 1
		cnt0[i+1] = cnt0[i]
	else:
		cnt0[i+1] = cnt0[i] + 1
		cnt1[i+1] = cnt1[i]
pow2 = [1]
for i in range(1, 10**5 + 10):
	pow2.append((2*pow2[-1])%mod)
for i in range(q):
	l, r = map(int, raw_input().split())
	ones = cnt1[r] - cnt1[l-1]
	zeroes = cnt0[r] - cnt0[l-1]
	t1 = (pow2[ones] - 1)%mod
	t2 = (((pow2[ones] - 1)%mod)*(pow2[zeroes] - 1))%mod
	print((t1+t2)%mod)",linear
"n,m=map(int,input().split())
x=list(map(int,input().split()))
y=list(map(int,input().split()))
l=[]
for i in range(m):
    if y[i] in x:
        l.append(x.index(y[i]))
l.sort()
for i in l:
    print(x[i],end="" "")",quadratic
"import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

class Node:
    val = None

    def __init__(self, val):
        self.val = val
        self.left = Node
        self.right = None

def solve(W, H, N, A):
    xs = [0] + [v for t, v in A if t == 0] + [W]
    ys = [0] + [v for t, v in A if t == 1] + [H]
    xs.sort()
    ys.sort()

    xlist = Node(0)
    h = xlist
    xnodes = {0: h}
    maxw = max([xs[i+1] - xs[i] for i in range(len(xs)-1)] or [0])
    maxh = max([ys[i+1] - ys[i] for i in range(len(ys)-1)] or [0])
    for v in xs[1:]:
        n = Node(v)
        xnodes[v] = n
        h.right = n
        n.left = h
        h = n

    ylist =  Node(0)
    h = ylist
    ynodes = {0: h}
    for v in ys[1:]:
        n = Node(v)
        ynodes[v] = n
        h.right = n
        n.left = h
        h = n

    ans = []
    maxarea = maxh * maxw
    for t, v in reversed(A):
        ans.append(maxarea)
        if t == 0:
            node = xnodes[v]
            w = node.right.val - node.left.val
            maxw = max(maxw, w)
        else:
            node = ynodes[v]
            h = node.right.val - node.left.val
            maxh = max(maxh, h)
        node.left.right = node.right
        node.right.left = node.left
        maxarea = maxh * maxw

    return ans[::-1]

def solve2(W, H, N, A):
    ws = [(-W, 0, W)]
    hs = [(-H, 0, H)]
    iw, ih = set(), set()
    ans = []

    xs, ys = [0, W], [0, H]
    for t, v in A:
        if t == 0:
            bisect.insort_left(xs, v)
            i = bisect.bisect_left(xs, v)
            l, m, r = xs[i-1], xs[i], xs[i+1]
            iw.add((l-r, l, r))
            heapq.heappush(ws, (l - m, l, m))
            heapq.heappush(ws, (m - r, m, r))
            while ws[0] in iw:
                heapq.heappop(ws)
        else:
            bisect.insort(ys, v)
            i = bisect.bisect_left(ys, v)
            l, m, r = ys[i-1], ys[i], ys[i+1]
            ih.add((l-r, l, r))
            heapq.heappush(hs, (l - m, l, m))
            heapq.heappush(hs, (m - r, m, r))
            while hs[0] in ih:
                heapq.heappop(hs)
        w, h = ws[0], hs[0]
        ans.append(w[0] * h[0])

    return ans

W, H, N = map(int,input().split())
A = []
for i in range(N):
    a, b = input().split()
    c = 0 if a == 'V' else 1
    A.append((c, int(b)))

print('\n'.join(map(str, solve(W, H, N, A))))",nlogn
"s = input()
trgt = 0
for c in s:
    trgt += (1 if c == '+' else -1)

cmd = input()

queue = [[0, 0]]
dests = []

while queue:
    nextqueue = []
    for pos, cmdi in queue:
        if cmdi == len(cmd):
            dests.append(pos)
            continue
        nextcmd = cmd[cmdi]
        if nextcmd == '+':
            nextqueue.append([pos+1, cmdi+1])
        elif nextcmd == '-':
            nextqueue.append([pos-1, cmdi+1])
        else:
            nextqueue.append([pos + 1, cmdi + 1])
            nextqueue.append([pos - 1, cmdi + 1])
    queue = nextqueue

occurs = 0
for x in dests:
    if x == trgt:
        occurs+=1
print(occurs / len(dests))",np
"n = int(input())
m = int(input())
print(m%2**n)",constant
"N = 1030
MOD = int(1e9+7)
c = [[0] * N for i in range(N)]
for i in range(N):
    c[i][0] = 1
for i in range(1, N):
    for j in range(1, N):
        c[i][j] = (c[i-1][j] + c[i-1][j-1]) % MOD

arr = list(map(int, list(input())))
cnt = int(input())
if cnt == 0:
    print(1)
    exit()

dp = [0] * N
for i in range(2, N):
    dp[i] = dp[bin(i).count('1')] + 1
res = 0
for i in range(1, N):
    if dp[i] != cnt - 1:
        continue
    n, k = len(arr)-1, i
    for pos in range(len(arr)):
        if arr[pos] == 1:
            res = (res + c[n][k]) % MOD
            k -= 1
        n -= 1
    if n == -1 and k == 0:
        res += 1
if cnt == 1:
    res -= 1
print(res)",linear
"def bin(n):
    if n == 0:
        return 1
    else:
        if n % 2 == 1:
            return bin(n - 1) * 2
        else:
            b = (bin(n // 2)) % 1000000007
            return b * b;
x, k = map(int,input().split())
if x == 0:
    print(0)
else:
    z = bin(k + 1) % 1000000007
    z = z * (x - 1)
    z = z % 1000000007
    z += bin(k)
    z += 1
    while(z < 0):
        z += 1000000007
    print(z % 1000000007)",logn
"import random

n = int(input())
v = []
a = []
for i in range(n):
    a.append(i)

for _ in range(0, n):
    x, y = map(int, input().split())
    v.append([x, y, x*x+y*y])

while 1>0:
    x = 0
    y = 0
    ans = [0]*n
    random.shuffle(a)
    for i in range(n):
        if (x+v[a[i]][0])**2+(y+v[a[i]][1])**2 <= (x-v[a[i]][0])**2+(y-v[a[i]][1])**2:
            x += v[a[i]][0]
            y += v[a[i]][1]
            ans[a[i]] = 1
        else:
            x -= v[a[i]][0]
            y -= v[a[i]][1]
            ans[a[i]] = -1
    if x*x+y*y <= 1500000**2:
        print(*ans)
        break",nlogn
"n = int(input())
queen = list(map(int,input().split("" "")))
king = list(map(int,input().split("" "")))
target = list(map(int,input().split("" "")))

def done():
	print(""NO"")
	exit()

def complete():
	print(""YES"")
	exit()

if king[0] < queen[0]:
	if target[0] > queen[0]:
		done()

	if king[1] > queen[1]:
		if target[1] < queen[1]:
			done()
		complete()
	else:
		if target[1] > queen[1]:
			done()
		complete()
else:
	if target[0] < queen[0]:
		done()
	if king[1] > queen[1]:
		if target[1] < queen[1]:
			done()
		complete()
	else:
		if target[1] > queen[1]:
			done()
		complete()",constant
"N = int(input())
L = [int(s) for s in input().split("" "")]
R = [int(s) for s in input().split("" "")]

C = [N - L[i] - R[i] for i in range(0, N)]

for i, x in enumerate(C):
    if C[i] <= 0:
        print(""NO"")
        exit()

    l = 0
    r = 0

    j = i-1
    while j >= 0:
        if C[j] > C[i]:
            l = l + 1

        j = j - 1

    j = i+1
    while j < N:
        if C[j] > C[i]:
            r = r + 1

        j = j + 1

    if L[i] != l or R[i] != r:
        print(""NO"")
        exit()

print(""YES"")
for i in range(0, N-1):
    print(C[i], end="" "")

print(C[N-1])",quadratic
"def number(pos):
    ans = 0
    for i in range(pos + 1):
        ans += 2**(i)
    return ans

l, r = input().split()
l = int(l)
r = int(r)

if(l == r):
    print(0)
else:
    b_pos = 0
    i = 0
    while(l > 0 or r > 0):
        if(l%2 != r%2):
            b_pos = i
        l >>= 1
        r >>= 1
        i += 1
    print(number(b_pos))",logn
"import sys
import os
from io import IOBase, BytesIO

def main():
    n = int(input())
    arr = get_array()
    arr.sort()
    tmp = [-1] * n
    c = 1
    for i in range(n):
        if tmp[i] != -1:
            continue
        x = arr[i]
        for j in range(i, n):
            if arr[j] % x == 0:
                tmp[j] = c
        c += 1

    print(c - 1)

BUFSIZE = 8192

class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        py2 = round(0.5)
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2 == 1:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode(""ascii""))
            self.read = lambda: self.buffer.read().decode(""ascii"")
            self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def get_array():
    return list(map(int, sys.stdin.readline().split()))

def get_ints():
    return map(int, sys.stdin.readline().split())

def input():
    return sys.stdin.readline().strip()

if __name__ == ""__main__"":
    main()",quadratic
"import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort

from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal

INF = float('inf')
mod = int(1e9) + 7

def cal(l,r):
    if l==r:
        dp1[l][r]=1
        dp2[l][r]=a[l]
    if dp1[l][r]:
        return dp1[l][r]
    for i in range(l,r):
        if cal(l,i)==1 and cal(i+1,r)==1 and dp2[l][i]==dp2[i+1][r]:
            dp1[l][r]=1
            dp2[l][r]=dp2[l][i]+1
    if not dp2[l][r]:
        dp1[l][r]=2
    return dp1[l][r]

def cal2(l,r):
    if dp1[l][r]==1:
        dp3[l][r]=1
        return 1
    elif dp3[l][r]:
        return dp3[l][r]
    ans=INF
    for i in range(l,r):
        ans=min(cal2(l,i)+cal2(i+1,r),ans)
    dp3[l][r]=ans
    return ans

n=int(data())
a=mdata()
ans=[n]
dp1=[[0]*n for i in range(n)]
dp2=[[0]*n for i in range(n)]
dp3=[[0]*n for i in range(n)]
cal(0,n-1)
cal2(0,n-1)
out(dp3[0][n-1])",cubic
"import os,sys
from io import BytesIO,IOBase

def check(n,mid,path,cost,num):
    ans,poi,visi = [],[0]*n,[0]*n
    for i in range(n):
        if visi[i]:
            continue
        visi[i],st,st1 = 2,[i],[]
        while len(st):
            x,y = st[-1],path[st[-1]]
            if poi[x] == len(y):
                visi[x] = 1
                st1.append(st.pop())
            else:
                i,j = y[poi[x]],cost[st[-1]][poi[x]]
                poi[x] += 1
                if j <= mid:
                    continue
                if visi[i] == 2:
                    return -1
                if not visi[i]:
                    st.append(i)
                    visi[i] = 2
        ans += st1
    start = [0]*n
    for ind,i in enumerate(reversed(ans)):
        start[i] = ind
    poi,visi,fin = [0]*n,[0]*n,[]
    for i in range(n):
        if visi[i]:
            continue
        visi[i],st = 1,[i]
        while len(st):
            x,y = st[-1],path[st[-1]]
            if poi[x] == len(y):
                st.pop()
            else:
                i,j,k = y[poi[x]],cost[st[-1]][poi[x]],num[st[-1]][poi[x]]
                poi[x] += 1
                visi[i] = 1
                st.append(i)
                if start[i] < start[x] and j <= mid:
                    fin.append(k)
    return fin

def main():
    n,m = map(int,input().split())
    path = [[] for _ in range(n)]
    cost = [[] for _ in range(n)]
    num = [[] for _ in range(n)]
    for _ in range(m):
        u1,v1,c1 = map(int,input().split())
        path[u1-1].append(v1-1)
        cost[u1-1].append(c1)
        num[u1-1].append(_+1)
    hi,lo = 10**9,0
    while hi >= lo:
        mid = (hi+lo)//2
        z = check(n,mid,path,cost,num)
        if z == -1:
            lo = mid+1
        else:
            hi = mid-1
            ans = mid
            an = z
    print(ans,len(an))
    print(*an)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",nlogn
"class Solution:
    def canAttendMeetings(self, intervals: List[Interval]) -> bool:
        intervals.sort(key=lambda i: i.start)

        for i in range(1, len(intervals)):
            i1 = intervals[i - 1]
            i2 = intervals[i]

            if i1.end > i2.start:
                return False
        return True",nlogn
"import math

t = int(input())

def eval_(n, k):
    level = 0.5*math.log2(3*k+1)
    if n > 30:
        cond = (level - n) > 0
    else:
        cond = (3*k+1) > 4**n
    if cond:
        return ""NO""
    elif n == 2 and k == 3:
        return ""NO""
    else:
        level = math.floor(level)

        if n > 5:

            temp = 1 + 0.5*math.log2(3*(k-1) + 1)
            if n > temp:
                return ""YES "" + str(n - 1)
            else:
                return ""YES  0""
        else:
            delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)//3
            start = (4**(level)-1)//3
            if k <=(start+delta):
                return ""YES "" + str(n - level)
            else:
                return ""YES "" + str(n - level-1)

for i in range(t):
    (n, k) = [int(i) for i in input().split()]
    print(eval_(n, k))",logn
"a,b=map(int,input().split())
x,y,z=map(int,input().split())
if a < x*2+y:
    ry=x*2+y-a
else:
    ry=0
if b < y+z*3:
    rb=y+z*3-b
else:
    rb=0
print(ry+rb)",constant
"from sys import stdin,stdout,setrecursionlimit
stdin.readline
def mp(): return list(map(int, stdin.readline().strip().split()))
def it():return int(stdin.readline().strip())
from collections import defaultdict as dd,Counter as C,deque
from math import ceil,gcd,sqrt,factorial,log2,floor
from bisect import bisect_right as br,bisect_left as bl
from heapq import *
mod = 10**9+7

def solve():
	n = it()
	v=[0]*(n+1)
	for i in range(1,n+1):
		v[i] = input()

	dp=[[0]*(n+2) for _ in range(n+1)]

	for l in range(n+2):
		dp[n][l] = 1

	for i in range(n-1,0,-1):
		curr_sum = 0
		for l in range(n):
			curr_sum += dp[i+1][l]
			curr_sum%=mod
			if v[i] == 'f':
				dp[i][l] = dp[i+1][l+1]
			else:
				dp[i][l]= curr_sum

	print(dp[1][0])

solve()",quadratic
"import math

n, r = map(int, input().split())
x = list(map(int, input().split()))
y = [r]

for i in range(1, n):
    _y = r
    for j in range(i):
        if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]):
            _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j])))
    y.append(round(_y, 6))

print(' '.join(map(str, y)))",quadratic
"def main():
    def calc(x1, y1, x2, y2):
        if x1 > x2 or y1 > y2:
            return 0
        if (x2 - x1 + 1) * (y2 - y1 + 1) % 2 == 0:
            return (x2 - x1 + 1) * (y2 - y1 + 1) // 2
        if (x1 + y1) % 2 == 1:
            return (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + 1
        return (x2 - x1 + 1) * (y2 - y1 + 1) // 2
    T = int(input())
    for t in range(T):
        n, m = map(int, input().split())
        a, b, c, d = map(int, input().split())
        e, f, g, h = map(int, input().split())
        j, k, l, q = max(a, e), max(b, f), min(c, g), min(d, h)
        black = calc(1, 1, n, m) - calc(a, b, c, d) - calc(e, f, g, h) + (h - f + 1) * (g - e + 1) + calc(j,k,l,q)
        print(n * m - black, black)

main()",constant
"n, m = map(int, input().split())
a = []
b = []
while n >= 0:
    a.append(4)
    n -= 4
    b.append(5)

a.append(5)
b.append(5)

print(*a, sep = """")
print(*b, sep = """")",constant
"n,k = map(int,input().split())
l = [int(x) for x in input().split()]
maps = []
for _ in range(256):
	maps.append(['empty',0])
output = []
for innum in l:
	if maps[innum][0] == 'chosen':
		outnum = maps[innum][1]
	elif maps[innum][0] == 'potential':
		outnum = maps[innum][1]
		i = innum
		while i >= 0 and maps[i][0] == 'potential':
			maps[i] = ['chosen',outnum]
			i -= 1
	else:
		i = innum
		while i >= 0 and i >= innum - (k-1) and maps[i][0] != 'chosen':
			i -= 1
		i += 1
		outnum = i
		for j in range(outnum,innum+1):
			maps[j] = ['chosen',outnum]
		if innum < 255:
			for j in range(innum+1,min(256,outnum+k)):
				if maps[j][0] != 'chosen':
					maps[j] = ['potential',outnum]
	output.append(str(outnum))
print(' '.join(output))",quadratic
"string=input()
n=len(string)
count1=[]
long=0
for s_i in range(n):
    for end_i in range(s_i+1,n+1):
        sub=string[s_i:end_i]
        if sub not in count1:
            count1.append(sub)
        else:
            if len(sub)>long:
                long=len(sub)

print(long)",cubic
"n, m = map(int, input().split())
a = input()
b = input()
flag = 0
for c in a:
    if(c == '*'):
        flag = 1
if(flag == 1):
    a1, a2 = a.split('*')
    Len1 = len(a1)
    Len2 = len(a2)
    b1 = b[:Len1]
    b2 = ''
    if(Len2):
        b2 = b[-Len2:]

    if(a1 == b1 and a2 == b2 and Len1 + Len2 <= len(b)):
        print('YES')
    else:
        print('NO')
else:
    if(a == b):
        print('YES')
    else:
        print('NO')",linear
"def f(l,r,g,b,op):
    if (r==0 and g==0) or (r==0 and b==0) or (b==0 and g==0):
        return 0
    else:
        if op[r][g][b]!=-1:
            return op[r][g][b]
        if r==0:
           op[r][g][b]=l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op)
           return op[r][g][b]
        if g==0:
           op[r][g][b]=l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op)
           return op[r][g][b]
        if b==0:
         op[r][g][b]=l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op)
         return op[r][g][b]
        op[r][g][b]=max(l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op),l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op),l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op))
        return op[r][g][b]

r,g,b=list(map(int,input().split()))
l=[]
l.append(sorted(list(map(int,input().split()))))
l.append(sorted(list(map(int,input().split()))))
l.append(sorted(list(map(int,input().split()))))
op=[[[-1 for i in range(b+1)]for j in range(g+1)]for k in range(r+1)]

print(f(l,r,g,b,op))",cubic
"class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if t == """":
            return """"

        countT = {}
        for c in t:
            countT[c] = 1 + countT.get(c, 0)

        res, resLen = [-1, -1], float(""infinity"")
        for i in range(len(s)):
            countS = {}
            for j in range(i, len(s)):
                countS[s[j]] = 1 + countS.get(s[j], 0)

                flag = True
                for c in countT:
                    if countT[c] > countS.get(c, 0):
                        flag = False
                        break

                if flag and (j - i + 1) < resLen:
                    resLen = j - i + 1
                    res = [i, j]

        l, r = res
        return s[l : r + 1] if resLen != float(""infinity"") else """"",quadratic
"from sys import stdin
n,m=map(int,stdin.readline().strip().split())
s=list(map(int,stdin.readline().strip().split()))
s1=list(map(int,stdin.readline().strip().split()))
if min(s1)<max(s):
    print(-1)
    exit(0)
s.sort()
s1.sort()

ans=0
if s1[0]!=s[-1]:
    ans+=s1[0]
    ans+=s[-2]*(m-1)
    ans+=sum(s1[1::])
    ans+=s[-1]
    for i in range(n-2):
        ans+=s[i]*m
else:
    ans+=sum(s1)
    for i in range(n-1):
        ans+=s[i]*m
print(ans)",nlogn
"n, v = list(map(int, input().split()))
f = lambda x: x*(x+1)//2
print(min(n-1, v)+f(n-min(n-1, v))-1)",constant
"def solve():
    n = int(input())
    max_degs = [int(x) for x in input().split()]

    B = [[i+1, x] for i, x in enumerate(max_degs) if x >= 2]
    S = [[i+1, x] for i, x in enumerate(max_degs) if x < 2]

    if 2 + sum(b - 2 for _, b in B) < len(S):
        print('NO')
        return

    print('YES', len(B) + min(len(S), 2) - 1)
    print(n-1)

    for k in range(len(B) - 1):
        i, x = B[k]
        i_n, _ = B[k+1]
        print(i, i_n)
        B[k][1] -= 1
        B[k+1][1] -= 1

    k = 0
    for i, (s_idx, _) in enumerate(S):
        if i == 0:
            print(B[0][0], s_idx)
            B[0][1] -= 1
        elif i == 1:
            print(B[-1][0], s_idx)
            B[-1][1] -= 1
        else:
            while B[k][1] == 0:
                k += 1
            print(B[k][0], s_idx)
            B[k][1] -= 1

solve()",linear
"n,m,k = map(int,input().split())
right = [[9999999 for i in range(m-1)] for j in range(n)]
down =  [[9999999 for i in range(m)] for j in range(n-1)]
for i in range(n):
    right[i] = list(map(int,input().split()))
for i in range(n-1):
    down[i] = list(map(int,input().split()))

if(k%2==1):
    for i in range(n):
        for j in range(m):
            print(""-1"",end="" "")
        print()
else:
    k = k//2
    row = n
    col = m
    dp  = [[[9999999 for i in range(m)] for j in range(n)] for ii in range(k+1)]
    for steps in range(k+1):
        for i in range(row):
            for j in range(col):
                if(steps==0):
                    dp[steps][i][j] = 0
                    continue
                ans = 99999999999
                if(i>0):
                    ans = min(ans,dp[steps-1][i-1][j]+down[i-1][j])
                if(i<n-1):
                    ans = min(ans,dp[steps-1][i+1][j]+down[i][j])
                if(j<m-1):
                    ans = min(ans,dp[steps-1][i][j+1]+right[i][j])
                if(j>0):
                    ans = min(ans,dp[steps-1][i][j-1]+right[i][j-1])
                dp[steps][i][j] = ans

    for i in range(n):
        for j in range(m):
            print(2*dp[k][i][j],end="" "")
        print()",cubic
"MOD = 1000000007

def main():
    buf = input()
    buflist = buf.split()
    n = int(buflist[0])
    q = int(buflist[1])
    buf = input()
    x = buf
    sum_list = [0]
    for i, deliciousness in enumerate(x):
        sum_list.append(int(deliciousness) + sum_list[i])
    enjoyment_list = [0]
    for i in range(n):
        enjoyment_list.append((enjoyment_list[i] * 2 + 1) % MOD)
    query_list = []
    for i in range(q):
        buf = input()
        buflist = buf.split()
        l = int(buflist[0])
        r = int(buflist[1])
        query_list.append((l, r))
    for i, query in enumerate(query_list):
        l = query[0]
        r = query[1]
        banhmi_count = r - l + 1
        delicious_count = sum_list[r] - sum_list[l - 1]
        non_delicious_count = banhmi_count - delicious_count
        enjoyment = 0

        if delicious_count == 0:
            enjoyment = 0
        else:
            enjoyment += enjoyment_list[delicious_count]
            enjoyment += (enjoyment_list[banhmi_count] - enjoyment_list[delicious_count] - enjoyment_list[non_delicious_count])
            enjoyment = enjoyment % MOD
        print(enjoyment)

if __name__ == '__main__':
    main()",linear
"from math import ceil

k, n, s, p = map(int, input().split())
n_sheets = ceil(n / s)* k
n_p = ceil(n_sheets / p)
print(n_p)",constant
"n=int(input())
x,y=map(int,input().split())
val1=max(x,y)-1
val2=n-min(x,y)
if(val1<=val2):
    print('White')
else:
    print('Black')",constant
"from collections import deque
def bfs(n):
    global c,nd,ans,s
    while len(b)>0 and len(s)>0:
        aux=0
        for i in l[s[0]]:
            if not visited[i]:
                visited[i]=True
                dp[i]=1
                aux+=1
        for i in range(aux):
            x=b.popleft()
            if dp[x]==1:
                s.append(x)
                dp[x]=-1
            else:
                ans=""No""
                return
        s.popleft()

n=int(input())
visited=[False for i in range(n+2)]
dp=[-1 for i in range(n+2)]
l=[[] for i in range(n+2)]
for i in range(n-1):
    a,b=map(int,input().split())
    l[a].append(b)
    l[b].append(a)
b=deque(map(int,input().split()))
b.popleft()
s=deque([1])
ans=""Yes""
visited[1]=True
bfs(1)
print(ans)",nlogn
"n, m = map(int, input().split())
a = []
b = []
check = True
while n >= 0:
    if check == True:
        a.append(5)
        n -= 5
        b.append(4)
        check = False
    else:
         check = True
         a.append(4)
         n -= 4
         b.append(5)

if m != 1:
    a.append(5)
    b.append(6)
else:
    a.append(5)
    b.append(5)

print(*a, sep = """")
print(*b, sep = """")",constant
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    if n==1:
        return 0
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[digit[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[digit[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):

    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matridigit[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matridigit[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matridigit[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]+other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]-other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matridigit[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matridigit[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matridigit[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

from collections import deque
class Dinic:
    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap):
        forward = [to, cap, None]
        forward[2] = backward = [fr, 0, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def add_multi_edge(self, v1, v2, cap1, cap2):
        edge1 = [v2, cap1, None]
        edge1[2] = edge2 = [v1, cap2, edge1]
        self.G[v1].append(edge1)
        self.G[v2].append(edge2)

    def bfs(self, s, t):
        self.level = level = [None]*self.N
        deq = deque([s])
        level[s] = 0
        G = self.G
        while deq:
            v = deq.popleft()
            lv = level[v] + 1
            for w, cap, _ in G[v]:
                if cap and level[w] is None:
                    level[w] = lv
                    deq.append(w)
        return level[t] is not None

    def dfs(self, v, t, f):
        if v == t:
            return f
        level = self.level
        for e in self.it[v]:
            w, cap, rev = e
            if cap and level[v] < level[w]:
                d = self.dfs(w, t, min(f, cap))
                if d:
                    e[1] -= d
                    rev[1] += d
                    return d
        return 0

    def flow(self, s, t):
        flow = 0
        INF = 10**9 + 7
        G = self.G
        while self.bfs(s, t):
            *self.it, = map(iter, self.G)
            f = INF
            while f:
                f = self.dfs(s, t, INF)
                flow += f
        return flow

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n,mod = mi()

N = 1000
g1 = [1]*(N+1)
g2 = [1]*(N+1)
inverse = [1]*(N+1)

for i in range( 2, N + 1 ):
    g1[i]=( ( g1[i-1] * i ) % mod )
    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )
    g2[i]=( (g2[i-1] * inverse[i]) % mod )
inverse[0]=0

pow_2 = [1 for i in range(1001)]
for i in range(1,1001):
    pow_2[i] = (pow_2[i-1] * 2) % mod

dp = [[1]]

for i in range(n):
    ndp = [[0] + [dp[s][k] for k in range(i+1)] for s in range(i+1)] + [[0 for k in range(i+2)]]
    for s in range(i+1):
        for k in range(i+1):
            if not dp[s][k]:
                continue

            if k!=0:
                ndp[s+k][0] += (dp[s][k] * g2[k] % mod) * pow_2[k-1] % mod
                ndp[s+k][0] %= mod

    dp = ndp

res = 0
for s in range(n+1):
    for k in range(1,n+1):
        res += (pow_2[k-1] * g1[s+k] % mod) * (dp[s][k] * g2[k] % mod) % mod
        res %= mod

print(res)",cubic
"if __name__ == '__main__':
    nums = input().split()
    n = int(nums[0])
    v = int(nums[1])

    if n < v+2:
        print(n - 1)
    else:
        print(int(v-1 + (n-v)*(n-v+1)/2))",constant
"import sys
input = sys.stdin.readline

from collections import deque
N, Q = map(int, input().split())
que = deque([int(a) for a in input().split()])
ma = max(que)

X = []
k = -1
c = 0
while c <= k+N+5:
    a = deque.popleft(que)
    b = deque.popleft(que)

    X.append((a, b))
    c += 1
    if a > b:
        a, b = b, a
    if k < 0 and b == ma:
        k = c
    deque.appendleft(que, b)
    deque.append(que, a)

for _ in range(Q):
    i = int(input()) - 1
    if i <= k:
        print(*X[i])
    else:
        i = (i-k)%(N-1)+k
        print(*X[i])",linear
"if __name__ == ""__main__"":
    n = int(input())
    nums = [int(a) for a in input().strip().split()]
    counts = 0

    for i in range(n-1):
        for j in range(i + 1, n):
            if nums[i] > nums[j]:
                counts += 1

    ans = counts % 2
    ans_tmp = []
    m = int(input())
    for i in range(m):
        l, r = [int(a) for a in input().strip().split()]

        tmp = r - l + 1
        tmp_count = (tmp * (tmp - 1) // 2)
        if tmp_count % 2 == 1:
            ans = (ans + 1) % 2
        ans_tmp.append(ans)

    for i in range(m):
        ans = ans_tmp[i]
        if ans % 2 == 1:
            print(""odd"")
        else:
            print(""even"")",quadratic
"import os, sys, atexit
from cStringIO import StringIO as BytesIO

sys.stdout = BytesIO()
atexit.register(lambda: os.write(1, sys.stdout.getvalue()))
input = BytesIO(os.read(0, os.fstat(0).st_size)).readline

rints = lambda: [int(x) for x in input().split()]
rstr = lambda: input().strip()
rstr_2d = lambda n: [rstr() for _ in range(n)]

n, m = rints()
grid = rstr_2d(n)
row = [[[] for _ in range(m)] for _ in range(n)]
col = [[[] for _ in range(m)] for _ in range(n)]
visr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0
visc = [[-1 for _ in range(m)] for _ in range(n)]

for i in range(n):
    be, en = -1, -1
    for j in range(m):
        if grid[i][j] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    row[i][k] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            row[i][k] = [be, en]

for i in range(m):
    be, en = -1, -1
    for j in range(n):
        if grid[j][i] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    col[k][i] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            col[k][i] = [be, en]

for i in range(n):
    for j in range(m):
        if grid[i][j] == '*':
            all += 1
            hor = min(row[i][j][1] - j, j - row[i][j][0])
            ver = min(col[i][j][1] - i, i - col[i][j][0])
            if hor <= ver:
                ver = hor
            else:
                hor = ver

            if hor > 0 and ver > 0:
                out.append('%d %d %d' % (i + 1, j + 1, hor))
                visr[i][j - ver] = j + ver
                visc[i - hor][j] = i + hor

dis = set()
for i in range(n):
    j, ma = 0, -1
    while j < m:
        ma = max(ma, visr[i][j])
        if ma >= j:
            dis.add((i, j))

        j += 1

for i in range(m):
    j, ma = 0, -1
    while j < n:
        ma = max(ma, visc[j][i])
        if ma >= j:
            dis.add((j, i))

        j += 1

if len(dis) != all:
    print(-1)
else:
    sys.stdout.write('%d\n%s' % (len(out), '\n'.join(out)))",quadratic
"def nr(): return nrs()[0]
def nrs(): return [int(i) for i in input().split()]

def get_prime(n):
	res = []
	for i in range(2,n):
		is_prime = True
		for x in res:
			if i % x == 0:
				is_prime = False
				break
		if is_prime: res.append(i)
	return res

prime = get_prime(3162)

def get_mask (num):

	dv = []
	for p in prime:
		c = 0
		while num % p == 0:
			c += 1
			num = num // p
		if c % 2 == 1:
			dv.append(p)
		if num < p * p:
			break

	for x in dv:
		num *= x

	return num

for _ in range(nr()):
	N, K = nrs()
	A = nrs()
	dp = [N] * (K + 1)
	dp[0] = 1
	used = [{}] * (K + 1)
	for a in A:
		a = get_mask(a)
		for j in range(K, -1, -1):
			if dp[j] == N: continue
			if a in used[j]:
				if j < K and dp[j + 1] > dp[j]:
					dp[j + 1] = dp[j]
					used[j + 1] = used[j]
				dp[j] += 1
				used[j] = {}
			used[j][a] = 1
	print(min(dp))",cubic
"n = int(input())
ar = []
for i in range(n):
    ar.append(input())
sortedAr = sorted(ar,key=len)
flag = False
for i in range(n-1):
    if sortedAr[i+1].find(sortedAr[i]) == -1:
        print('NO')
        flag = True
        break
if not flag:
    print('YES')
    for i in sortedAr:
        print(i)",nlogn
"a = input()
b = input()

if len(a) < len(b):
    a = sorted(a)[::-1]
    print(''.join(a))
    exit(0)

def check(res, j, a):
    added = False
    tmp = """"
    for i in a:
        if i == j and not added:
            added = True
        else:
            tmp += i
    tmp = res + j + tmp[::-1]
    return tmp <= b

res = """"
n = len(a)
a = sorted(list(a))[::-1]
for i in range(n):
    for j in a:
        if check(res, j, a):
            res += j
            a.remove(j)
            break
print(res)",cubic
"def gns():
    return  list(map(int,input().split()))
n=int(input())
ns=gns()
a='cslnb'
b='sjfnb'
ns.sort()
ans=[]
for i in range(1,n):
    if ns[i]==ns[i-1]:
        ans.append(i)
if len(ans)>=2 or sum(ns)==0:
    print(a)
    quit()
if len(ans)==1:
    i=ans[0]
    if ns[i]==0 or ns[i]-1 in ns:
        print(a)
        quit()
    r=sum(ns)-n*(n-1)//2
    if r%2==0:
        print(a)
        quit()
    else:
        print(b)
        quit()
else:
    r=sum(ns)-n*(n-1)//2
    if r%2==0:
        print(a)
        quit()
    else:
        print(b)",nlogn
"from collections import defaultdict
import sys
input = sys.stdin.readline
n = int(input())
a = map(int, input().split())
mod = 998244353
d = defaultdict(int)
for x in a:
    d[x] += 1
d[0] = 0
b = list(d.items())
b.sort()
m = len(b)
ba = [0] * m
cn = [0] * (m + 1)
k = h = 0
for i, x in enumerate(b):
    while h < m and x[0] >= b[h][0] * 2:
        h += 1
    ba[i] = h - 1
    while k < m and x[0] * 2 > b[k][0]:
        k += 1
    cn[k] += x[1]
for i in range(m):
    cn[i+1] += cn[i]
dp = [0] * m
dp[0] = 1
b = [x[1] for x in b]
for i in range(n):
    ndp = [0] * m
    for j in range(1, m):
        if cn[j] >= i - 1:
            ndp[j] = dp[j] * (cn[j] - i + 1) % mod
        dp[j] += dp[j-1]
        if dp[j] >= mod:
            dp[j] -= mod
    for j in range(1, m):
        ndp[j] += dp[ba[j]] * b[j]
        ndp[j] %= mod
    dp = ndp
print(sum(dp) % mod)",cubic
"def main():
    pieces_Dimension = int(input())
    piece1 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece2 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece3 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece4 = ''.join(input() for _ in range(pieces_Dimension))

    brokenPieces = (piece1, piece2, piece3, piece4)
    nSquares = pieces_Dimension*pieces_Dimension
    squares = '01'*(nSquares//2) + '0'

    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)

def nSquaresToRecolorIn(brokenPieces, nSquares, squares):
    possible_nSquares = [sum(piece[i] != squares[i] for i in range(nSquares)) for piece in brokenPieces]
    possible_nSquares.sort()

    return 2*nSquares + possible_nSquares[0] + possible_nSquares[1] - possible_nSquares[2] - possible_nSquares[3]

if __name__ == '__main__':
    print(main())",quadratic
"n, k = map(int, input().split())
print((k + n - 1) // n)",constant
"from sys import stdin, stdout, maxsize
from math import inf

R = lambda : stdin.readline().strip()
RL = lambda f=None: list(map(f, R().split(' '))) if f else list(R().split(' '))

output = lambda x: stdout.write(str(x) + '\n')
output_list = lambda x: output(' '.join(map(str, x)))

n, m, K = RL(int)

if K%2:
    for i in range(n):
        print( *(m*[-1]) )
    exit()

hor = [ RL(int) +[inf] for i in range(n) ]
vert = [ RL(int) for i in range(n-1) ] + [ m*[inf] ]

K = K//2
dp = [ [m*[inf] for i in range(n)] for j in range(0, K+1)]

dp[0] = [m*[0] for i in range(n)]

def valid(i, j):
    if -1 < i < n and  -1 < j < m:
        return True
    return False

for k in range(1, K+1):
    for i in range(n):
        for j in range(m):
            if valid(i, j+1):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j+1] + 2*hor[i][j])
            if valid(i+1, j):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i+1][j] + 2*vert[i][j])
            if valid(i-1, j):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i-1][j] + 2*vert[i-1][j])
            if valid(i, j-1):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j-1] + 2*hor[i][j-1])

for i in dp[-1]:
    print(*i)",cubic
"from sys import stdin
t = int(stdin.readline())
for _ in range(t):
    n = int(stdin.readline())
    a = round((n / 2) ** 0.5)
    b = round((n / 4) ** 0.5)
    if 2*a**2 == n or 4*b**2 == n:
        print(""YES"")
    else:
        print(""NO"")",constant
"i = int(input())
s = input().split()

l = []
for j in s:
    if not l or  int(j)%2 != l[-1]:
        l.append(int(j)%2)
    else:
        l.pop()

if len(l) < 2:
    print('YES')
else:
    print('NO')",linear
"n, m, k = map(int, input().strip().split())

a = list(map(int, input().strip().split()))
a = [0] + a
dp = [0] * 300005
ans = 0
for i in range(1, n + 1):
    a[i] += a[i - 1]
    for j in range(1, m + 1):
        if i - j >= 0:
            dp[i] = max(dp[i], a[i] - a[i - j] - k)
    if i - m >= 0:
        dp[i] = max(dp[i], a[i] - a[i - m] + dp[i - m] - k)
    ans = max(ans, dp[i])

print(ans)",quadratic
"from sys import stdin
input = stdin.readline

n = int(input())
a = []
for i in range(4):
    a.append([[int(x) for x in list(input().rstrip())] for _ in range(n)])
    if i < 3: input()
b = []
for i in range(4):
    b.append([])
    for j in range(2):
        c = 0
        for y in range(n):
            for x in range(n):
                if j == 1:
                    z = (x + y) % 2
                else:
                    z = 1 - (x + y) % 2
                c += a[i][y][x] != z
        b[-1].append(c)
ans = float(""inf"")
for i in (3, 5, 6, 9, 10, 12):
    ans = min(ans, b[0][i & 1] + b[1][i >> 1 & 1] + b[2][i >> 2 & 1] + b[3][i >> 3 & 1])
print(ans)",quadratic
"import sys, math
debug = 0
if debug:
    f = open(""input.txt"", ""r"")
    input = f.readline
def mp():
    return list(map(int,input().split()))

m = 1000000007

def pow(k):
    if k == 0:
        return 1;
    z = pow(k // 2)
    if k % 2 == 1:
        return (2 * z * z) % m
    else:
        return (z * z) % m

def _main():
    x, k = mp()
    if(x == 0):
        print(0)
        return
    t = pow(k)
    a = x * t
    b = a - t + 1;
    print((a + b) % m)

_main()",logn
"n, capacity = map(int,input().split())
a = [(0, 0)]*n

for i in range(n):
    x, y = map(int,input().split())
    a[i] = (x, y)

a.sort(key=lambda x: max(0, x[0] - x[1]))

current_sum = 0; i = n - 1; ans = 0
for x in a:
    current_sum += x[0]

while i >= 0 and current_sum > capacity:
    ans += 1
    current_sum -= max(0, a[i][0] - a[i][1])
    i -= 1

if current_sum <= capacity:
    print(ans)
else:
    print(-1)",nlogn
"n = int(input())
import math
print(math.ceil(n/2) * (math.floor(n/2)+1))",linear
"n=int(input())
l=list(map(int,input().split()))
s=input()
water=0
grass=0
cgrass=0
time=0
seen=False
for i in range(n):
    if s[i]==""G"":
        dist=l[i]
        if water>=dist:
            water-=dist
            time+=2*dist
            cgrass+=dist
        else:
            dist-=water
            time+=2*water
            cgrass+=water
            water=0
            time+=3*dist
            grass+=dist
    elif s[i]==""W"":
        water+=l[i]
        time+=2*l[i]
        seen=True
    else:
        dist=l[i]
        if water>=dist:
            water-=dist
            time+=2*dist
        else:
            dist-=water
            time+=2*water
            water=0
            if cgrass>=dist:
                cgrass-=dist
                grass+=dist
                time+=3*dist
            else:
                dist-=cgrass
                grass+=cgrass
                time+=3*cgrass
                cgrass=0
                if grass>=dist:
                    grass-=dist
                    time+=3*dist
                else:
                    dist-=grass
                    time+=3*grass
                    grass=0
                    if seen:
                        time+=4*dist
                    else:
                        time+=6*dist
print(time)",linear
"def check(x, y):
    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])

re = int(input())
a = [list(input()) for i in range(re)]
b = [list(input()) for i in range(re)]
for i in range(4):
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = b[::-1]
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = [s[::-1] for s in b]
    c = [['' for t in range(re)] for u in range(re)]
    for t in range(re):
        for u in range(re):
            c[t][u] = b[u][re - t - 1]
    b = c[:]
    if check(a, b):
        print('Yes')
        exit(0)
print('No')",quadratic
"from sys import stdin, stdout

n = int(stdin.readline())
values = list(map(int, stdin.readline().split()))

cnt = 0
for i in range(n):
    for j in range(i + 1, n):
        if values[i] > values[j]:
            cnt += 1

m = int(stdin.readline())
for i in range(m):
    l, r = map(int, stdin.readline().split())
    n = r - l + 1

    cnt += n * (n - 1) // 2
    cnt &= 1

    if cnt == 1:
        stdout.write('odd\n')
    else:
        stdout.write('even\n')",quadratic
"def check(j):
    if sum(j)>=l and sum(j)<=r and (max(j)-min(j))>=x:
        return 1
    return 0

from itertools import combinations
n,l,r,x=list(map(int,input().split()))
c=list(map(int,input().rstrip().split()))
count=0
for i in range(2,n+1):
    a=list(combinations(c,i))
    for j in a:

        if check(j):
            count+=1
print(count)",np
"from collections import deque
n = int(input())
graph = [set() for i in range(n + 1)]
graph[0].add(1)
graph[1].add(0)
for i in range(n - 1):
    x, y = map(int, input().split())
    graph[x].add(y)
    graph[y].add(x)
a = list(map(int, input().split()))
q = deque()
q.append(0)
i = 0
par = [0] * (n + 1)
while len(q):
    v = q.popleft()
    graph[v].discard(par[v])
    l = len(graph[v])
    if graph[v] != set(a[i:i + l]):
        print(""No"")
        break
    for j in range(i, i + l):
        q.append(a[j])
        par[a[j]] = v
    i += l
else:
    print(""Yes"")",linear
"import sys, string

n, m = map(int, sys.stdin.readline().split())
s = list(sys.stdin.readline().rstrip())
t = list(sys.stdin.readline().rstrip())
idx = -1
for i in range(n):
    if s[i] == '*':
        idx = i
if idx == -1:
    if s == t:
        print('YES')
    else:
        print('NO')
else:
    if m < n - 1:
        print('NO')
    else:
        s_left = s[0 : idx]
        s_right = s[idx + 1 : n]
        a = len(s_left)
        b = len(s_right)
        t_left = []
        t_right = []
        for i in range(a):
            t_left.append(t[i])
            t[i] = ''
        for i in range(b):
            t_right.append(t[m - i - 1])
        if s_left == t_left and s_right == t_right[::-1]:
            print('YES')
        else:
            print('NO')",linear
"n,m,k,l=map(int,input().split())
c=(k+l)//m
if (k+l)%m!=0:
    c+=1
if n>=m*c:
    print(c)
else :
    print(-1)",constant
"import sys
input=sys.stdin.readline
n,m=map(int,input().split())
a=[]
def bs(a,mid,ans):
    global n,m
    can=[0 for i in range(1<<m)]
    for i in range(n):
        t=0
        for j in range(m):
            t=(t<<1)|(a[i][j]>=mid)

        can[t]=i+1

    for i in range(1<<m):
        if(not can[i]):
            continue
        for j in range(1<<m):
            if not can[j]:
                continue
            if i|j==(1<<m)-1:

                ans[0]=can[i]
                ans[1]=can[j]
                return 1
    return 0

for i in range(n):
    p=[int(x) for x in input().split()]
    a.append(p)
l=0
r=100000000000
ans=[1,1]
while l<=r:
    mid=(l+r)//2
    if bs(a,mid,ans):
        l=mid+1
    else:
        r=mid-1

print(*ans)",np
"def check_combos(diff,n,size,start,picked,total,l,r,x,combination = []):
    if picked == size:
        if max(combination) - min(combination) >= x and l <= sum(combination) <= r:
            total += 1
    else:
        for i in range(start,n-(size-picked-1)):
            combination.append(diff[i])
            picked += 1
            total = check_combos(diff,n,size,i+1,picked,total,l,r,x,combination)
            picked -= 1
            combination.pop()
    return total

def prog():
    n,l,r,x = map(int,input().split())
    diff = list(map(int,input().split()))
    suitable_problemsets = 0
    for size in range(1,n+1):
        suitable_problemsets += check_combos(diff,n,size,0,0,0,l,r,x)
    print(suitable_problemsets)
prog()",np
"n,m = input().split()
n=int(n)
m=int(m)

songs=list()

for i in range(n):
    songs.append([int(c) for c in input().split()])

def sumList(lista,inx):
    sum=0
    for i in range(len(lista)):
        sum+=lista[i][inx]
    return sum

songs=sorted(songs,key=lambda x: x[1]-x[0])

suma = sumList(songs,0)

for i in range(n):
    if(suma<=m):
        print(i)
        exit()
    suma-= songs[i][0]-songs[i][1]

if(suma<=m):
    print(n)
else:
    print(-1)",nlogn
"T = int(input())
for ti in range(T):
    s, t = input().strip(), input().strip()
    N = len(t)
    for i in range(1, N+1):
        dp = [0]+[-1]*i
        for l, c in enumerate(s):
            for j in range(i, -1, -1):
                tmp = dp[j]
                if dp[j] != -1 and i + dp[j] < N and \
                   t[i + dp[j]] == c:
                    tmp = dp[j] + 1
                if j != 0 and t[j-1] == c:
                    tmp = max(tmp, dp[j-1])
                dp[j] = tmp
        if dp[i] == N-i:
            print(""YES"")
            break
    else:
        print(""NO"")",cubic
"def sum(num):

    return (num * (num + 1)) // 2

def sum_from_to(fromm, to):
    if fromm <= 1:
        return sum(to)
    return sum(to) - sum(fromm)

def min_splitters():
    start = 1
    end = k
    while start < end:
        mid = (start + end) // 2
        mid_val = sum_from_to(mid, k)
        if mid_val == n:
            return k - mid + 1
        elif mid_val > n:
            start = mid + 1
        else:
            end = mid
    return k - start + 1

n, k = (int(i) for i in input().split())

if n == 1:
    print(0)

elif n <= k:
    print(1)
else:
    k -= 1
    n -= 1

    if sum(k) < n:
        print(-1)
    else:
        print(min_splitters())",logn
"Q = int(input())
for _ in range(Q):
    N, K = map(int, input().split())
    S = input()
    X = [{""R"":0, ""G"":1, ""B"":2}[s] for s in S]
    mi = K
    for i in range(3):
        d = 0
        for j in range(N):
            if X[j] != (i+j) % 3:
                d += 1
            if j >= K and X[j-K] != (i+j-K) % 3:
                d -= 1
            if j >= K-1:
                mi = min(mi, d)
    print(mi)",linear
"if __name__ == ""__main__"":
    x,k = map(int, input().split())

    if x==0:
    else:
        y=pow(2,k,1000000007)*(2*x-1)+1
        result=int(y%(1000000007))",logn
"N, K = map(int, input().split())

print((K+N-1)//N)",constant
"def fastio():
	import sys
	from io import StringIO
	from atexit import register
	global input
	sys.stdin = StringIO(sys.stdin.read())
	input = lambda : sys.stdin.readline().rstrip('\r\n')
	sys.stdout = StringIO()
	register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))
fastio()

MOD = 10**9 + 7
I = lambda:list(map(int,input().split()))

t, = I()
while t:
	t -= 1
	n, = I()
	a = I()
	a.sort()
	if n == 2:
		print(0)
	else:
		print(min(n-2, a[-2]-1))",nlogn
"import sys, os
from io import BytesIO, IOBase
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

mod = pow(10, 9) + 7
mod2 = 998244353

def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def ceil(a, b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True

n, k = mp()
if n==0:
    print(0)
    exit()
x = (n*pow(2, k+1, mod))%mod
print((x-pow(2, k, mod)+1)%mod)",logn
"from collections import namedtuple

Point = namedtuple(""Point"", ""x y"")
Square = namedtuple(""Square"", ""left right top bottom"")
Triangle = namedtuple(""Triangle"", ""left top"")

a = [int(v) for v in input().split()]
b = [int(v) for v in input().split()]

a = [Point(a[i], a[i + 1]) for i in range(0, 8, 2)]
b = [Point(b[i], b[i + 1]) for i in range(0, 8, 2)]

bc = Point(sum(p.x for p in b) // 4, sum(p.y for p in b) // 4)
bb = [None] * 4
for p in b:
    if p.x < bc.x:
        bb[0] = p
    elif p.y > bc.y:
        bb[1] = p
    elif p.x > bc.x:
        bb[2] = p
    elif p.y < bc.y:
        bb[3] = p
    else:
        assert False

def in_sqr(sqr, pt):
    return sqr.left <= pt.x <= sqr.right and sqr.bottom <= pt.y <= sqr.top

def in_tri(tri, pt):
    return (
        tri.left.x <= pt.x <= tri.top.x and
        tri.left.y <= pt.y <= tri.top.y and
        pt.y - tri.left.y <= pt.x - tri.left.x
    )

def solve_sqr_tri(sqr, tri):
    return (
        in_sqr(sqr, tri.left) or
        in_sqr(sqr, tri.top) or
        in_sqr(sqr, Point(tri.top.x, tri.left.y)) or
        in_tri(tri, Point(sqr.left, sqr.top)) or
        in_tri(tri, Point(sqr.right, sqr.top)) or
        in_tri(tri, Point(sqr.right, sqr.bottom)) or
        in_tri(tri, Point(sqr.left, sqr.bottom))
    )

def rotate90(pt):
    return Point(-pt.y, pt.x)

def iterate_rot(pt, times):
    for _ in range(times):
        pt = rotate90(pt)
    return pt

def solve_sqr_sqr45(sqr_pts, sqr45):
    for i in range(4):
        tri_pts = sqr45[i], sqr45[(i + 1) % 4]
        left, top = [iterate_rot(pt, i) for pt in tri_pts]

        assert left.x < top.x
        assert left.y < top.y

        tri = Triangle(left=left, top=top)

        sqr = Square(
            left=min(p.x for p in sqr_pts),
            right=max(p.x for p in sqr_pts),
            top=max(p.y for p in sqr_pts),
            bottom=min(p.y for p in sqr_pts),
        )

        if solve_sqr_tri(sqr, tri):
            return True

        sqr_pts = [rotate90(pt) for pt in sqr_pts]

    return False

print([""NO"", ""YES""][solve_sqr_sqr45(a, bb)])",constant
"n = int(input())
a = list(map(int, input().split()))

mex = -1
for i in range(n):
    if a[i] <= mex:
        continue
    elif a[i] == mex + 1:
        mex += 1
    else:
        print(i+1)
        exit()
print(-1)",linear
"import bisect
import collections
import copy
import functools
import heapq
import itertools
import math
import random
import re
import sys
import time
import string
from typing import List

n,k = map(int,input().split())
t = []
for _ in [0]*n:
    t.append(list(map(int,input().split())))
t.sort(key=lambda x:(-x[0],x[1]))

pt = t[k-1]

print(t.count(pt))",nlogn
"from queue import Queue
import datetime

with open(""input.txt"", 'r') as in_file:
    n, m = (int(i) for i in in_file.readline().split("" ""))
    k = int(in_file.readline())
    ints = [int(i) for i in in_file.readline().split("" "")]

pairs = []
for i in range(0, len(ints), 2):
    x = ints[i]
    y = ints[i+1]
    pairs.append((x, y))

last_tree = (1, 1)
maxd = 0
mult = m * n
for i in range(1, n+1):
    for j in range(1, m+1):
        md = mult

        for pair in pairs:
            x, y = pair
            d = abs(i-x)+abs(j-y)

            md = min(md, d)

        if md > maxd:

            last_tree = (i, j)
            maxd = md

with open(""output.txt"", 'w') as out_file:
    out_file.write(f""{last_tree[0]} {last_tree[1]}"")",cubic
"import math
a,b=map(int,input().split())
c=[]
e=[]
f=0
for i in range(a):
    d=str(input())
    for j in range(b):
        if d[j]==""B"":
            c=c+[i]
            e=e+[j]
p=min(c)
p1=min(e)
p2=max(c)
plus=(max(c)-min(c))//2
p3=p+plus+1
p4=p1+plus+1
print(p3,p4)",quadratic
"n = int(input().strip())
a = list(map(int,input().strip().split()))
b = list(map(int,input().strip().split()))
pos_of = [-1 for i in range(2*10**5+1)]

for i,ele in enumerate(a):
    pos_of[ele]=i+1

current_pos = 0
ans=[]
for i in b:
    if(pos_of[i]>current_pos):
        ans.append(pos_of[i]-current_pos)
        current_pos=pos_of[i]
    else:
        ans.append(0)

print(' '.join(list(map(str,ans))))",linear
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from math import ceil

def prod(a, mod=10 ** 9 + 7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

from math import inf

for _ in range(int(input()) if not True else 1):

    n, m = map(int, input().split())

    a = []
    for i in range(n):
        a += [list(map(int, input().split()))]

    alpha, omega = 0, 10**9
    def solve(mid):
        index = [-1] * (1 << m)
        for i in range(n):
            val = 0
            for j in range(m):
                if a[i][j] >= mid:
                    val += (1 << j)
            index[val] = i + 1
        is_subset = list(index)
        for i in range(m):
            for mask in range(1 << m):
                if mask & (1 << i):
                    is_subset[mask^(1<<i)] = max(is_subset[mask], is_subset[mask ^ (1 << i)])
        pos = False
        for mask in range(1 << m):
            if index[mask] == -1: continue
            mask2 = ((1 << m) - 1) ^ mask
            if is_subset[mask2] != -1:
                pos = (index[mask], is_subset[mask2])
                break
        return pos
    while alpha < omega:
        mid = (alpha + omega + 1) // 2
        if solve(mid):
            alpha = mid
        else:
            omega = mid - 1
    print(*solve(alpha))",np
"n = int(input())
queen_x, queen_y = list(map(int, input().strip().split()))
king_x, king_y = list(map(int, input().strip().split()))
tar_x, tar_y = list(map(int, input().strip().split()))

min_x, max_x = sorted([king_x, tar_x])
min_y, max_y = sorted([king_y, tar_y])

if max_x > queen_x > min_x or max_y > queen_y > min_y:
    print(""NO"")
else:
    print(""YES"")
",nlogn
"n=int(input())
f=[input().strip()==""f"" for ii in range(n)]
mod=10**9+7
def summ(a,b):
 return (a+b)%mod
dp=[1]
for ii in range(1,n):
 pf=f[ii-1]
 if pf:
  dp.insert(0,0)
 else:
  for jj in reversed(range(1,len(dp))):
   dp[jj-1]=summ(dp[jj-1],dp[jj])
ans=0
for vv in dp:
 ans=summ(ans,vv)
print(ans)",quadratic
"def valid(k, mid):
    return (2*k - mid - 1) * mid // 2 + 1

def binary_search(n, k):
    l, r = 0, k-1
    while (l <= r):
        mid = l+r >> 1
        if (valid(k, mid) < n):
            l = mid+1
        else:
            r = mid-1
    return r+1

def main():
    n, k = map(int, input().split())
    res = binary_search(n, k)
    print(-1 if res == k else res)

main()",logn
"a = list(input())
a = [int(x) for x in a]

b = list(input())
b = [int(x) for x in b]

n = len(a)
m = len(b)

ans = 0
for i in range(n):
    ans+=a[i]^b[i]
ones = [0 for i in range(m)]
zeros = [0 for i in range(m)]

for i in range(m):
    if b[i]:
        ones[i]=1
    else:
        zeros[i]=1

for i in range(1,m):
    ones[i]+=ones[i-1]
    zeros[i]+=zeros[i-1]

for i in range(n):
    if a[i]==1:
        ans+=zeros[m-n+i]-zeros[i]
    else:
        ans+=ones[m-n+i]-ones[i]
print(ans)",linear
"import itertools

n , l , r , x = map(int,input().split())

problems = list(map(int,input().split()))

ans = 0

for i in range(2 , n + 1 ):
    for j in itertools.combinations(problems ,i):
        if (l <= sum(j) <= r and max(j) - min(j) >= x):
            ans +=1

print(ans)",np
"s=input()

while(1):
        if(len(s)==1):
                print(0)
                break

        elif(s==s[::-1]):

            s=s[1:]

        else:
            print(len(s))
            break",linear
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]

z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())

def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]

n,m=zzz()
arr = zzz()
s = sum(arr)
idx = [[] for i in range(m)]
for i in range(n):
    idx[arr[i]%m].append(i)
j=0
for i in range(m):
    while len(idx[i])>n//m:
        while j<i or len(idx[j%m])>=n//m:j+=1
        last = idx[i].pop()
        arr[last]+=(j-i)%m
        idx[j%m].append(last)
print(sum(arr)-s)
print(*arr)",linear
"import sys

def set(mask, pos):
    return mask | (1 << pos)

def isOn(mask, pos):
    return mask & ( 1 << pos) > 0

n, l, r, x = map(int, input().split(' '))
dif = list(map(int, input().split(' ')))

count, mask = 0, 0

while mask <= 2**n:
    summ, bit = [], 0

    while bit < n:

        if isOn(mask, bit):
            summ.append(dif[bit])

        bit += 1

    if sum(summ) <= r and sum(summ) >= l and max(summ) - min(summ) >= x:
        count += 1

    mask += 1

print(count)",np
"n,s=map(int,input().split())
x=s//n
if x*n<s:
    x+=1
print(x)",constant
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))
PLACE=[None]*(n+1)
for i in range(n):
    PLACE[A[i]]=i

al=n

WINLIST=[None]*(n+1)

def move(n,al):
    place=PLACE[n]
    for i in range(place,-1,-n):
        if A[i]>n and WINLIST[A[i]]==""B"":
            WINLIST[n]=""A""
            return

    for i in range(place,al,n):
        if A[i]>n and WINLIST[A[i]]==""B"":
            WINLIST[n]=""A""
            return

    else:
        WINLIST[n]=""B""
        return

for j in range(n,0,-1):
    move(j,al)

ANS=""""
for i in A:
    ANS+=WINLIST[i]

print(ANS)",linear
"from sys import *
n = int(stdin.readline())
ans = 0
for i in range(2,n+1):
    for j in range(i*2,n+1,i):
        ans += 4 * (j // i)
print(ans)",nlogn
"i = input()
i = int(i)
v = 0
g = 2
s = 4
while g <= i:
	while s <= i:
		v = v + int(s / g * 4)
		s = s + g
	g = g + 1
	s = g * 2
print(str(v))",linear
"n , m=map(int,input().split())
l1=list(map(int,input().split()))
l2=list(map(int,input().split()))
l3=[]
for i in range(n):
    for j in range(m):
        if l1[i]==l2[j]:
            if l1[i] is not l3:
                l3.append(l1[i])
print(*l3)",quadratic
"class edge(object):
	def __init__(self,ne,to,fl):
		self.ne=ne
		self.to=to
		self.fl=fl

def add(x,y,z):
	global tot
	tot+=1
	e.append(edge(he[x],y,z))
	he[x]=tot

def addedge(x,y,z):
	add(x,y,z)
	add(y,x,0)

def bfs():
	global deep
	deep=[0 for i in range(T+1)]
	q=[]
	q.append(S)
	deep[S]=1
	while (len(q)>0):
		x=q[0]
		del(q[0])
		i=he[x]
		while (i):
			y=e[i].to
			if ((deep[y]==0)and(e[i].fl!=0)):
				deep[y]=deep[x]+1
				q.append(y)
			i=e[i].ne
	return deep[T]!=0

def dfs(x,flow):
	global deep
	if ((x==T)or(flow==0)):
		return flow
	used=0
	i=he[x]
	while (i):
		y=e[i].to
		if ((deep[y]==deep[x]+1)and(e[i].fl!=0)):
			now=dfs(y,min(flow-used,e[i].fl))
			used+=now
			e[i].fl-=now
			e[i^1].fl+=now
			if (flow==used):
				break;
		i=e[i].ne
	if (used==0):
		deep[x]=-1
	return used

def dinic():
	res=0
	while (bfs()):
		res+=dfs(S,INF)
	return res

n,m=map(int,input().split())
ans=0
weight=[0]+list(map(int,input().split()))

e=[0,0]
tot=1
S=n+m+1
T=S+1
he=[0 for i in range(T+1)]
INF=1000000007

for i in range(1,n+1):
	addedge(S,i,weight[i]);
for i in range(1,m+1):
	x,y,w=map(int,input().split())
	addedge(n+i,T,w)
	addedge(x,n+i,INF)
	addedge(y,n+i,INF)
	ans+=w
ans-=dinic()
print(ans)",cubic
"def solution():
    n = int(input())
    for _ in range(n):
        s = input()
        p = s.find('C')

        if s[0] == 'R' and s[1].isdigit() and p > 1:
            r = int(s[1:p])
            c = int(s[(p + 1):])

            v = list()
            while c > 0:
                if c % 26 == 0:
                    v.append('Z')
                    c = (c - 1) // 26
                else:
                    v.append(chr(ord('A') + (c % 26 - 1)))
                    c //= 26

            v.reverse()
            print(""%s%d"" % ("""".join(v), r))

        else:
            p = 0
            while p < len(s):
                if s[p].isdigit():
                    break
                p += 1

            sr = s[:p]
            sc = s[p:]

            c = 0
            for x in sr:
                c = c * 26 + (ord(x) - ord('A') + 1)

            print(""R%sC%d"" % (sc, c))

if __name__ == ""__main__"":
    solution()",linear
"import sys
input = sys.stdin.readline
from collections import *

def judge(x):
    ins = [0]*n
    outs = defaultdict(list)

    for u, v, c in edges:
        if c>x:
            ins[v] += 1
            outs[u].append(v)

    q = deque([v for v in range(n) if ins[v]==0])
    cnt = 0

    while q:
        v = q.popleft()
        cnt += 1

        for nv in outs[v]:
            ins[nv] -= 1

            if ins[nv]==0:
                q.append(nv)

    return cnt==n

def binary_search():
    l, r = 0, 10**9+10

    while l<=r:
        m = (l+r)//2

        if judge(m):
            r = m-1
        else:
            l = m+1

    return l

n, m = map(int, input().split())
edges = []
idx = defaultdict(lambda : deque([]))

for i in range(m):
    u, v, c = map(int, input().split())
    u -= 1
    v -= 1
    edges.append((u, v, c))
    idx[10**6*u+v].append(i+1)

k = binary_search()
ins = [0]*n
outs = defaultdict(list)
removed = []

for u, v, c in edges:
    if c>k:
        ins[v] += 1
        outs[u].append(v)
    else:
        removed.append((u, v))

q = deque([v for v in range(n) if ins[v]==0])
order = [-1]*n
cnt = 0

while q:
    v = q.popleft()
    order[v] = cnt
    cnt += 1

    for nv in outs[v]:
        ins[nv] -= 1

        if ins[nv]==0:
            q.append(nv)

change = []

for u, v in removed:
    if order[v]<order[u]:
        change.append(idx[10**6*u+v].popleft())

print(k, len(change))
print(*change)",nlogn
"from collections import defaultdict as di

n = int(input())
a = list(map(int, input().split()))
d = di(int)
res, sum = 0, 0
for i in range(n):
	res += a[i] * i - sum - d[a[i]-1] + d[a[i]+1]
	sum += a[i]
	d[a[i]] += 1
print(res)",nlogn
"k1,k2,k3=map(int,input().split())
a=[k1,k2,k3];a=sorted(a)
if a[0]==1 or a.count(2)>=2 or a.count(3)==3:print(""YES"")
elif a.count(4)==2 and a.count(2)==1:print(""YES"")
else:print(""NO"")",constant
"import os,sys;from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno();self.buffer = BytesIO();self.writable = ""x"" in file.mode or ""r"" not in file.mode;self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:break
            ptr = self.buffer.tell();self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE));self.newlines = b.count(b""\n"") + (not b);ptr = self.buffer.tell();self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:os.write(self._fd, self.buffer.getvalue());self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file);self.flush = self.buffer.flush;self.writable = self.buffer.writable;self.write = lambda s: self.buffer.write(s.encode(""ascii""));self.read = lambda: self.buffer.read().decode(""ascii"");self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
try:sys.stdin,sys.stdout=open('in.txt','r'),open('out.txt','w')
except:pass
ii1=lambda:int(sys.stdin.readline().strip())
is1=lambda:sys.stdin.readline().strip()
iia=lambda:list(map(int,sys.stdin.readline().strip().split()))
isa=lambda:sys.stdin.readline().strip().split()

from functools import lru_cache
from collections import defaultdict
from math import inf

n,m,k = iia()
A = [[0] * (m) for _ in range(n)]
B = [[0] * (m) for _ in range(n)]
for i in range(n):
    tmp = iia()
    for j in range(m - 1):
        A[i][j + 1] = tmp[j]
for i in range(n - 1):
    tmp = iia()
    for j in range(m):
        B[i + 1][j] = tmp[j]

if k%2:
    [print(*[-1]*m) for i in range(n)]
    sys.exit()
ans = [[0] * m for _ in range(n)]
lim = k // 2
dp = [[[inf] * (lim + 1) for _ in range(m)] for _ in range(n)]
for i in range(n):
    for j in range(m):
        dp[i][j][0] = 0

for k in range(1, lim + 1):
    for i in range(n):
        for j in range(m):
            if i: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + B[i][j])
            if j: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + A[i][j])
            if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + B[i + 1][j])
            if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + A[i][j + 1])
for i in range(n):
    for j in range(m):
        ans[i][j] = dp[i][j][-1] * 2
[print(*a) for a in ans]",cubic
"def possible(a,index,a1,b):
    rem = []
    for i in range(len(a)):
        if i != index:
            rem.append(a[i])

    a3 = a1[:]
    rem.sort()
    a3.append(a[index])
    a3.extend(rem)
    a2 = ''
    for i in a3:
        a2 += str(i)

    if int(a2) <= b:
        return True

    return False

def main():
    a = list(map(int,input()))
    b = int(input())

    a.sort(reverse = True)
    a1 = []
    for pos in range(len(a)):
        for i in range(len(a)):
            if possible(a,i,a1,b):
                a1.append(a[i])
                a.pop(i)
                break

    for i in a1:
        print(i,end = '')

main()",cubic
"import math
from decimal import Decimal

def sum2(s, e):
    return sum1(e) - sum1(s - 1) - (e - s)

def sum1(i):
    return i * (i + 1) / 2

line = input().split()
n = Decimal(line[0])
k = Decimal(line[1])
if(n == 1):
    print(0)
elif(k > n):
    print(1)
elif(sum2(Decimal(2),k) < n):
    print(-1)
else:
    c = 2 * n + k - k * k
    discriminant = (9 - 4 * c).sqrt()
    tmp = discriminant / 2
    const = Decimal(3/2)
    res1 = math.floor(const + tmp)
    res2 = math.floor(const - tmp)
    res1 = max(res1, res2)
    print(k - res1 + 1);",logn
"from sys import stdin
input = stdin.readline

n=int(input())
arr=[int(x) for x in input().split()]

arr.sort(reverse=True)

d={}
for i in range(n):
    if arr[i] in d:
        d[arr[i]].append(i)
    else:
        d[arr[i]]=[i]

cnt=0
vis=[-1]*n
for i in range(n):
    s=bin(arr[i])
    s=s[2:]
    s=s[::-1]
    l=len(s)
    x=0
    for j in range(l):
        if s[j]==""0"":
            x=x+(2**j)
    x=x+1

    if x in d:
        if x==arr[i] and len(d[x])==1:
            if vis[i]==-1:
                cnt=cnt+1
        else:
            if vis[d[x][0]]==-1:
                for j in d[x]:
                    vis[j]=1
    else:
        if vis[i]==-1:
            cnt=cnt+1
    vis[i]=1

print(cnt)",nlogn
"import time
from decimal import Decimal
n,k = map(int,raw_input().split())

computeSum = lambda x: Decimal(((Decimal(x)/Decimal(2)) * Decimal(k-x+1 + k)) - (x-1))

def minSplitters():
    if n == 1:
        return 0
    elif n <= k:
        return 1
    max_sum = computeSum(k)
    if n > max_sum:
        return -1
    else:
        low = 0
        high = k
        while low < high:
            mid = (low+high)/2
            previousSum = computeSum(mid-1)
            currentSum = computeSum(mid)
            if currentSum == n:
                return mid
            elif currentSum < n:
                low = mid + 1
            elif currentSum > n:
                if previousSum >= n:
                    high = mid-1
                else:
                    return mid
        return low
print(minSplitters())",logn
"n, M = map(int, input().split())
A = list(map(int, input().split()))
A = [0]+A+[M]
D = []
for i in range(n+1):
    D.append(A[i+1]-A[i])

E = []
O = []
for i, d in enumerate(D):
    if i%2 == 0:
        E.append(d)
        O.append(0)
    else:
        O.append(d)
        E.append(0)
from itertools import accumulate
CE = [0]+E
CE = list(accumulate(CE))
CO = [0]+O
CO = list(accumulate(CO))

ans = CE[-1]
for i in range(n+1):
    if D[i] == 1:
        continue
    temp = CE[i]+(D[i]-1)+CO[-1]-CO[i+1]

    ans = max(ans, temp)
print(ans)",linear
"I = lambda: map(int,input().split())
n,l,r,x=I()
C,k=[*I()],0
for i in range(2**n):
    W = [w for w,b in zip(C, bin(i)[2:].zfill(n)) if b=='1']

    if l <= sum(W) <= r and max(W)-min(W) >= x:
        k += 1
print(k)",np
"from sys import stdin, stdout, setrecursionlimit
from collections import deque, defaultdict
from bisect import bisect_left

def check(temp):
	if len(temp) < 2:
		return False
	else:
		s = sum(temp)
		if s >= l and s <= r:
			if temp[-1] - temp[0] >= x:
				return True
			else:
				return False
		else:
			return False

def brute(index, temp):
	global count

	if index == n:
		if check(temp):
			count += 1

	else:
		temp.append(arr[index])
		brute(index + 1, temp)
		temp.pop()
		brute(index + 1, temp)

n, l, r, x = list(map(int, stdin.readline().split()))
arr = list(map(int, stdin.readline().split()))
arr.sort()
count = 0
temp = []
brute(0, temp)
print(count)",np
"def get_kth_digit(i):
    if i < 10:
        return i

    batch = 9
    count = 9
    width = 1

    while i >  10 * batch * (width + 1) + count:
        batch *= 10
        width += 1
        count += batch * width

    k = i - count - 1
    num = 10 ** width + k// (width + 1)
    return str(num)[k % (width + 1)]

def main():
    i = int(input())

    print(get_kth_digit(i))

if __name__ == '__main__':
    main()",logn
"import sys
import math
from collections import defaultdict,deque
import heapq
n,k=map(int,sys.stdin.readline().split())

mod=998244353
dp=[[0,0,0,0] for x in range(k+3)]
dp[1][0]=1
dp[1][1]=1
dp[2][2]=1
dp[2][3]=1
newdp=[[0,0,0,0] for x in range(k+3)]
for i in range(n-1):

    for j in range(k+1):
        newdp[j+1][1]+=dp[j][0]
        newdp[j+1][3]+=dp[j][0]
        newdp[j+1][2]+=dp[j][0]
        newdp[j][0]+=dp[j][0]
        newdp[j][1]+=dp[j][1]
        newdp[j+1][3]+=dp[j][1]
        newdp[j+1][2]+=dp[j][1]
        newdp[j+1][0]+=dp[j][1]
        newdp[j][1]+=dp[j][2]
        newdp[j+2][3]+=dp[j][2]
        newdp[j][2]+=dp[j][2]
        newdp[j][0]+=dp[j][2]
        newdp[j][1]+=dp[j][3]
        newdp[j][3]+=dp[j][3]
        newdp[j+2][2]+=dp[j][3]
        newdp[j][0]+=dp[j][3]

        for a in range(3):
            for b in range(4):
                newdp[a+j][b]%=mod
    for a in range(k+3):
        for b in range(4):
            dp[a][b]=newdp[a][b]
            newdp[a][b]=0

ans=sum(dp[k])
ans%=mod
print(ans)",np
"from collections import defaultdict
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
p = list(map(int, input().split()))
x = [0] * (n + 1)
for i in range(n):
    if p[i] < m:
        x[i + 1] = -1
    elif p[i] > m:
        x[i + 1] = 1
    else:
        l = i
for i in range(1, n + 1):
    x[i] += x[i - 1]
cnt = [defaultdict(lambda : 0) for _ in range(2)]
for i in range(l + 1):
    cnt[i % 2][x[i]] += 1
ans = 0
for i in range(l + 1, n + 1):
    xi = x[i]
    ans += cnt[i % 2][xi - 1]
    ans += cnt[i % 2 ^ 1][xi]
print(ans)",nlogn
"from math import inf

a=[0,0]
a[0]=[str(c)for c in list(input().strip()) ]
a[1]=[str(X) for X in list(input().strip())]

an = [-inf,-inf,-inf]
if a[0][0]==a[1][0]=='0':
    an[0]=0
elif  a[0][0]!=a[1][0]:
    an[1]=0
x=0
for i in range(1,len(a[0])) :

    if an[0]==0:
        if a[0][i]==a[1][i]=='0':
            x+=1

            an=[-inf,0 ,-inf]
        elif a[0][i]!=a[1][i]:
            x+=1
            an=[-inf]*3
        else:
            an = [-inf, -inf, -inf]
    elif an[1]==0:
        if a[0][i]==a[1][i]=='0':
            x+=1
            an=[-inf,-inf ,-inf]
        elif a[0][i]!=a[1][i]:
            pass
        else:
            an=[-inf,-inf ,-inf]
    else:
        if a[0][i]==a[1][i]=='0':

            an=[0,-inf ,-inf]
        elif a[0][i]!=a[1][i]:
            an=[-inf,0,-inf]
        else:
            an=[-inf,-inf ,-inf]

print(x)",constant
"n, k = map(int, input().split())
values, single, l, r = [int(i) for i in input().split()], set(), -1, -1
for i in range(n):
    single.add(values[i])
    if len(single) == k:
        l, r = 1, i + 1
        break
single = set()
for i in range(r - 1, max(-1, l - 2), -1):
    single.add(values[i])
    if len(single) == k:
        l = i + 1
        break

if len(single) < k:
    print(-1, -1)
else:
    print(l, r)",linear
"class node:
    def __init__(self,l,r,u,d):
        self.u = u
        self.d = d
        self.l = l
        self.r = r
        if l == 20000001 and r ==20000001 and u == 20000001 and d == 20000001:
            self.marr = [20000001 for i in range(11)]
        else:
            self.marr = [0 for i in range(11)]
            self.marr[1] = min(l,r,u,d)
    def mo(self,st):
        return self.marr[st-1]

n,m,s = (int(i) for i in input().split())
hor = [[20000001 for i in range(m+3)] for j in range(n+2)]
ver = [[20000001 for i in range(m+2)] for j in range(n+3)]
for i in range(1,n+1):
    hor[i][2:1+m] = [int(i) for i in input().split()]
for i in range(2,1+n):
    ver[i][1:m+1] = [int(i) for i in input().split()]
if s%2 == 0 :
    nds = [[node(hor[i][j],hor[i][j+1],ver[i][j],ver[i+1][j]) for j in range(m+2)] for i in range(n+2)]
    for st in range(2,s//2+1):
        for i in range(1,n+1):
            for j in range(1,m+1):
                x = nds[i][j].marr[1]
                l = nds[i][j].l
                r = nds[i][j].r
                u = nds[i][j].u
                d = nds[i][j].d
                nds[i][j].marr[st] = min(x*st,r+nds[i][j+1].mo(st),l+nds[i][j-1].mo(st),u+nds[i-1][j].mo(st),d+nds[i+1][j].mo(st))
    ans = [[nds[i][j].marr[s//2]*2 for j in range(1,m+1)] for i in range(1,n+1)]
    for i in range(n):
        print(*tuple(ans[i]))
else :
    a = [[-1 for i in range(m)] for j in range(n)]
    for i in range(n):
        print(*tuple(a[i]))",cubic
"from collections import defaultdict
import sys
import bisect
input=sys.stdin.readline

n,m=map(int,input().split())
a=[int(i) for i in input().split()if i!='\n']
rem=[[] for i in range(m)]
req=n//m
ans=0
for i in range(n):
    rem[a[i]%m].append([a[i],i])
ind=m-1
for i in range(m):
    size=len(rem[i])
    if size>req:
        ind=i
    if size<req:
        ok=False
        for j in range(ind,-1,-1):
            while len(rem[j])>req:
                pop,_=rem[j].pop()
                rem[i].append([pop+(i-j)%m,_])
                if len(rem[i])==req:
                    ok=True
                    break
            if ok:
                break
            ind-=1
        else:
            ind=m-1
            for j in range(ind,-1,-1):
                while len(rem[j])>req:
                    pop,_=rem[j].pop()
                    rem[i].append([pop+(i-j)%m,_])
                    if len(rem[i])==req:
                        ok=True
                        break
                if ok:
                    break
                ind-=1

out=[0]*(n)
for i in rem:
    for j in i:
        out[j[1]]=j[0]
print(sum(out)-sum(a))
out=' '.join(map(str,out))
print(out)",linear
"import sys

a, b = input(), input()

if len(a) < len(b):
    print(*sorted(a, reverse=True), sep='')
    exit()

cnt = [0]*10

for x in a:
    cnt[int(x)] += 1

def rec(res, digit, rem):
    if digit == len(b):
        return res
    if rem[int(b[digit])]:
        r = rem[:]
        r[int(b[digit])] -= 1
        x = rec(res + b[digit], digit+1, r)
        if x:
            return x
    for d in range(int(b[digit])-1, -1, -1):
        if rem[d]:
            res += str(d)
            rem[d] -= 1
            suf = []
            for i in range(10):
                suf += [str(i)] * rem[i]
            return res + ''.join(sorted(suf, reverse=True))
    return ''

ans = rec('', 0, cnt[:])
print(ans)",cubic
"n = int(input())
k = set(""47"")
p = False
for i in range(1, n+1):
    if n%i == 0:
        if set(str(i)) <= k:
            p = bool(set(str(i)))
            break
if p == True:
    print(""YES"")
else:
    print(""NO"")",constant
"from sys import  stdin
input=stdin.readline
from  collections import defaultdict
def num(s):
    l,r=0,0
    for i in s:
        if l==0 and i=="")"":
            r+=1
        elif i==""("":
            l+=1
        elif l and i=="")"":
            l-=1
    return (l,r)

def f(mp,cnt):
    ans=0
    for l in cnt:
        if l.count(0)<1:
            continue
        t=mp[l[::-1]]
        ans+=t
        if t and l!=l[::-1]:
            mp[l]-=1
    return ans

cnt=[]
mp=defaultdict(int)
for i in range(int(input())):
    s=input()
    l=num(s)
    cnt.append(l)
    mp[l]+=1
print(f(mp,cnt))",linear
"from collections import defaultdict, Counter
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
slmii = lambda: sorted(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

def lcm(a, b): return (a * b) // gcd(a, b)

def main():

    s = li()
    n = len(s)
    cnt = 0
    sm = 0
    for i in range(n):
        s[i] = int(s[i]) % 3
    i = 0
    while i < n:
        if s[i] == 0:
            cnt += 1
            sm = 0
            i += 1
        else:
            sm += s[i]
            if sm % 3 == 0:
                sm = 0
                cnt += 1
                i += 1
            else:
                if i + 1 < n and s[i] + s[i + 1] == 3:
                    i += 2
                    cnt += 1
                    sm = 0
                else:
                    i += 1
    print(cnt)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",linear
"n,m=map(int,input().split())
seq=[int(i) for i in input().split()][:n]
f=[int(i) for i in input().split()][:m]
a=[]
for i in range(n):
    for j in range(m):
        if(seq[i]==f[j]):
            a.append(seq[i])

for i in range(len(a)):
    print(a[i],end=' ')",quadratic
"def check(x: int) -> (int, int):
    vis = {}
    for i, array in enumerate(a):
        t = 0
        for j, val in enumerate(array):
            if val >= x:
                t |= 1 << j
        vis[t] = i
    if (1 << m) - 1 in vis:
        return vis[(1 << m) - 1], vis[(1 << m) - 1]
    for i in range(1, (1 << m) - 1):
        for j in range(1, (1 << m) - 1):
            if i in vis and j in vis and i | j == (1 << m) - 1:
                return vis[i], vis[j]
    return -1, -1

if __name__ == '__main__':
    n, m = map(int, input().split())
    a = []
    for i in range(n):
        a.append(list(map(int, input().split())))
    l = 0
    r = int(1e9)
    while l <= r:
        mid = l + r >> 1
        if check(mid) != (-1, -1):
            l = mid + 1
        else:
            r = mid - 1
    ans = check(r)
    print(""%d %d"" % (ans[0] + 1, ans[1] + 1))",np
"n, m = map(int,input().split())
X = []
for i in range(n):
    a = input()
    U = [char for char in a]
    X.append(U)
nums = []
for i in range(m):
    t = 0
    for j in range(n):
        t += int(X[j][i])
    nums.append(t)

for i in range(n):
    ok = True
    for j in range(m):
        if X[i][j] == '1':
            if nums[j]>1:
                continue
            else:
                ok = False
    if ok == True:
        print(""YES"")
        quit()
print(""NO"")",quadratic
"from sys import stdin
input = stdin.buffer.readline

n,m=map(int,input().split())
arr=[int(x) for x in input().split()]

dp=[[] for i in range(m)]
for i in range(n):
    dp[arr[i]%m].append(i)

res=0
k=n//m
ans=arr.copy()
s=[]
for t in range(2):
    for i in range(m):
        if len(dp[i])<k:
            while len(s)!=0 and len(dp[i])<k:
                x=s.pop()
                y=arr[x]%m
                if i>y:
                    ans[x]=ans[x]+(i-y)
                    res=res+(i-y)
                else:
                    ans[x]=ans[x]+(m-1-y)+(i+1)
                    res=res+(m-1-y)+(i+1)
                dp[i].append(""xxx"")
        if len(dp[i])>k:
            while len(dp[i])>k:
                s.append(dp[i].pop())

print(res)
print(*ans)",linear
"import sys
LI=lambda:list(map(int, sys.stdin.readline().split()))
MI=lambda:map(int, sys.stdin.readline().split())
SI=lambda:sys.stdin.readline().strip('\n')
II=lambda:int(sys.stdin.readline())

n=II()
s=SI()
c=set(s)
ln=[0]*n
for d in c:
	last=-1

	for i, v in enumerate(s):
		if v==d:
			last=i
		if last==-1:
			ln[i]=int(1e9)
		else:
			ln[i]=max(ln[i], i-last+1)

print(min(ln))",linear
"R=lambda:map(int,input().split())
a,b=R()
x,y,z=R()
print(max(0,2*x+y-a)+max(0,y+3*z-b))",constant
"M = 10**9 + 7
R = lambda: map(int, input().split())
x,k = R()
if x == 0:
    print(0)
    quit()
print(((pow(2,k+1,M)*x)%M - pow(2,k,M) +1 ) % M)",logn
"from sys import stdout

ask_count = 0

n = int(input())

def ask(num):
    global ask_count
    print(""? "" + str(num))
    stdout.flush()
    ask_count += 1
    return int(input())

def ans(num):
    print(""! "" + str(num))
    stdout.flush()

def opposite(num):
    return num + n // 2

low = 1
high = opposite(low)
lval = ask(low)
hval = ask(high)
prev_l_less_h = (lval < hval)

while high - low > 1:

    mid = (low + high) // 2

    lval = ask(mid)
    hval = ask(opposite(mid))
    l_less_h = (lval < hval)

    if abs(lval - hval) % 2 == 1:
        ans(-1)
        exit(0)
    elif hval == lval:
        ans(mid)
        exit(0)
    else:
        if l_less_h == prev_l_less_h:
            low = mid
        else:
            high = mid
ans(-1)",logn
"a,b = list(input()),int(input())
ans = """"
a.sort(reverse=True)
while len(a)>0:
    for i in range(len(a)):
        num = ans+a[i]+"""".join(sorted(a[:i]+a[i+1:]))
        if int(num)<=b:
            ans += a[i]
            a = a[:i]+a[i+1:]
            break
print(ans)",cubic
"from sys import exit
N, M = map(int, input().split())
B = list(map(int, input().split()))
G = list(map(int, input().split()))
B.sort()
mB = B[-1]
m2B = B[-2]
mG = min(G)
if mB > mG:
    print(-1)
    exit()
if mB == mG:
    print(sum(B)*M + sum(G) - mB * M)
    exit()
print(sum(B)*M + sum(G) - mB * M + mB - m2B)",nlogn
"n,k=map(int,input().split())

ar=[-1 for i in range(256)]
ls=list(map(int,input().split()))

for e in ls:
    if ar[e]==-1:
        tmp=max(0,e-k+1)
        for i in range(tmp,e+1):
            if ar[i]!=-1 and ar[i]!=i:
                tmp+=1
                continue
            else:
                while i<=e:
                    ar[i]=tmp
                    i+=1
    print(ar[e],end="" "")",quadratic
"n = int(input())-1
x = 1
y = 9
while n > x * y:
    n -= x * y
    y *= 10
    x += 1
a = 10 ** (x - 1)
a += n // x
print(str(a)[n % x])",logn
"n = int(input())
arr = list(map(int,input().strip().split()))[:n]

new = sorted(arr)
count = 0

for i in range(n):
    if arr[i] != new[i]:
        count += 1

if count <= 2:
    print('YES')
else:
    print('NO')",nlogn
"import bisect
xzy=[10,190,2890,38890,488890,5888890,68888890,788888890,8888888890,98888888890,1088888888890,11888888888890]
k=int(input())
digits=bisect.bisect_left(xzy,k)
if k==10:
    print(1)
elif k>10:
    apu=k-xzy[digits-1]
    modulo=apu%(digits+1)
    dlj=apu//(digits+1)
    output=10**(digits)+dlj
    list1=[i for i in str(output)]
    print(list1[modulo])
else:
    print(k)",logn
"from math import floor
import re

z = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""

def convert_num(x):
    output = """"
    row, col = [int(x) for x in re.split(""(\d+)"", x) if x.isnumeric()]
    while col > 0:
        y = (col - 1) % 26
        output += z[y]
        col = floor((col - 1) / 26)
    return f""{output[::-1]}{row}""

def convert_alpha(x):
    output = 0
    word = ("""".join([i for i in x if i.isalpha()]))[::-1]
    for i in range(0, len(word)):
        output += (z.index(word[i]) + 1) * 26 ** i
    ending = x[len(word) :]

    return f""R{ending}C{output}""

i = int(input())
output = """"
for x in range(i):
    hehexd = input()
    if hehexd.startswith(""R"") and hehexd[1].isnumeric() and ""C"" in hehexd:
        output += f""{convert_num(hehexd)}\n""
    else:
        output += f""{convert_alpha(hehexd)}\n""
print(output)",linear
"import sys, os

numbs = [int(x) for x in sys.stdin.buffer.read().split()]
n = numbs.pop(0)

base = []
out = []

for i in range(n):
    x = numbs[i]
    how = 0

    for b,rep in base:
        if x.bit_length() == b.bit_length():
            x ^= b
            how ^= rep

    if x:
        how |= 1 << i

        a = 0
        b = len(base)
        while a < b:
            c = a + b >> 1
            if base[c][0] > x:
                a = c + 1
            else:
                b = c
        base.insert(a, (x, how))

        out.append(0)
    else:
        outind = len(out)
        out.append(-1)

        y = bin(how).encode('ascii')
        ylen = len(y)
        for i in range(2,len(y)):
            if y[i] == 49:
                out.append(ylen - 1 - i)
        out[outind] = len(out) - 1 - outind

os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))",np
"import sys
input=sys.stdin.readline

def count_bits(x):
    cnt=0
    for i in range(n):
        if((1<<i)&x):
            cnt+=1
    return(cnt)

n=int(input())
a=[list(map(float,input().split())) for i in range(n)]
dp=[0 for i in range(1<<n)]
dp[-1]=1

for mask in range((1<<n)-1,-1,-1):
    val=count_bits(mask)
    total=val*(val-1)//2
    for i in range(n):
        if(mask&(1<<i)==0):
            continue
        for j in range(n):
            if(mask&(1<<j)==0 or i==j):
                continue
            dp[mask^(1<<j)]+=dp[mask]*a[i][j]/total
for i in range(n):
    print(dp[1<<i])",np
"a, b= list(map(int, input().split()))
c = 1
result = a^b
while c <= result:
    c *= 2
c -= 1

print(c)",logn
"from collections import deque
import sys
input = sys.stdin.readline

n, d, k = map(int, input().split())
if n == 1 or n <= d:
    ans = ""NO""
elif k == 1:
    ans = ""YES"" if n == 2 and d == 1 else ""NO""
    e = [(1, 2)]
else:
    e = [(i + 1, i + 2) for i in range(d)]
    q = deque()
    l, r = 1, d + 1
    if k > 2:
        for i in range(2, d + 1):
            q.append((i, 2, min(i - l, r - i)))
    ans = ""YES""
    for i in range(d + 2, n + 1):
        if not q:
            ans = ""NO""
            break
        j, k0, d0 = q.popleft()
        e.append((j, i))
        if k0 + 1 < k:
            q.append((j, k0 + 1, d0))
        if d0 - 1 > 0:
            q.append((i, 1, d0 - 1))
print(ans)
if ans == ""YES"":
    for u, v in e:
        print(u, v)",quadratic
"n,k = map(int,input().split())
a = list(map(int,input().split()))

count = 0
b = {}
for i in range(n):
    if a[i] in b:
        b[a[i]] += 1
    else:
        b[a[i]] =1
    if b[a[i]] == 1:
        count += 1
    if count == k:
        break

for j in range(n):
  if a[j] in b:
    b[a[j]] -= 1

  if b[a[j]] == 0:
    break

if count != k:
    print(""-1 -1"")
else:
  if n == 1:
    print(1,1)
  elif n == 2 and count == 2:
    print(1,2)
  else:
    print(j+1,i+1)",linear
"from itertools import groupby

n = int(input())
l = list(map(int, input().split()))
r = list(map(int, input().split()))
sums = [(a + b, ind) for (ind, (a, b)) in enumerate(zip(l, r))]
sums.sort()
answer = [None] * n
curr_candies = n
for key, group in groupby(sums, key=lambda i: i[0]):
    for elem in group:
        answer[elem[1]] = curr_candies
    curr_candies -= 1
tl = []
for i in range(n):
    cnt = 0
    for j in range(i):
        if answer[j] > answer[i]:
            cnt += 1
    tl.append(cnt)
tr = []
for i in range(n):
    cnt = 0
    for j in range(i + 1, n):
        if answer[j] > answer[i]:
            cnt += 1
    tr.append(cnt)
if tl != l or tr != r:
    print(""NO"")
else:
    print(""YES"")
    print(' '.join(map(str, answer)))",quadratic
"import sys, copy

n, m = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
res = [0] * (max(arr) + 1)
for i in arr:
    res[i] += 1
ans = 0
for d in range(1, m + 1):
    temp = copy.deepcopy(res)
    cnt = 0
    for i in range(len(temp)):
        while temp[i] >= d:
            temp[i] -= d
            cnt += 1
    if cnt >= n:
        ans = max(ans, d)
print(ans)",nlogn
"def mp():
    return map(int, input().split())

def f(i):
    return (10 ** i - 10 ** (i - 1)) * i

n = int(input())

i = 1
sum = 0
while n - f(i) >= 0:
    n -= f(i)
    sum += f(i) // i
    i += 1

print(str(sum + (n + i - 1) // i)[n % i - 1])",constant
"n, k = map(int, input().split())
p = (k - 1) // n + 1
print(p)",constant
"from sys import stdin
from collections import Counter

class Node:
    def __init__(self,val):
        self.val=val
        self.forw=set()
        self.cou=0

    def __str__(self):
        return f'{self.val} {self.forw} {self.cou}'

n=int(stdin.readline())
arr=[Node(i) for i in range(1,n+1)]
c=2
for x in map(int,stdin.readline().split()):
    arr[x-1].forw.add(c)
    c+=1

dct=Counter()
lst = [1]
while len(lst):
    fl = 0
    for i in arr[lst[-1]-1].forw:
        lst.append(i)
        fl = 1
        break
    if fl:
        arr[lst[-2]-1].forw.remove(i)
    if not fl:
        if arr[lst[-1]-1].cou ==0:
            arr[lst[-1]-1].cou=1
        dct[arr[lst[-1]-1].cou]+=1
        k=arr[lst.pop()-1].cou
        if len(lst):arr[lst[-1]-1].cou+=k

y=1
for _ in range(n):
    while not dct[y]:
        y+=1
    dct[y]-=1
    print(y,end=' ')",linear
"n = int(input())
A = [int(a) for a in input().split()]
B = A.copy()
B.sort()
c = 0
for i in range(n):
    a = A[i]
    b = B[i]
    if a == b:
        continue
    else:
        c += 1
if c == 0 or c == 2:
    print(""YES"")
else:
    print(""NO"")",nlogn
"n = int(input())

if(n>=0):
    print(n)
    exit()
else:
    n=str(abs(n))
    n1=int(n[:len(n)-1])

    temp=n[len(n)-1]

    n2=n[:len(n)-2]

    n2=int(n2+temp)

if(n1<=n2):
    if(n1!=0):
        print('-'+str(n1))
    else:
        print(0)
else:
    if(n2!=0):
        print('-'+str(n2))
    else:
        print(0)",constant
"import collections,sys,functools,heapq,bisect,math

def binary(s):
    ans = set()
    for i in range(2**len(s)):
        x = []
        for j in range(len(s)):
            if (i>>j) & 1:
                x.append(s[j])
            else:
                x.append('_')
        ans.add(''.join(x))
    return ans

seen = set()
visited = set()
ans = []
def dfs(i):
    visited.add(i)
    seen.add(i)
    for j in graph[i]:
        if j in visited:
            return True
        if j in seen:
            continue
        if dfs(j):
            return True
    ans.append(str(i))
    visited.remove(i)
    return False

def topo(graph):
    seen.clear()
    for i in range(1,n+1):
        if i in seen:
            continue
        if dfs(i):
            return False
    return True

input = sys.stdin.readline
mod = 10**9 + 7

for _ in range(1):
    n,m,k = map(int,input().strip().split())
    d = {}
    dop = {}
    for i in range(1,n+1):
        d[i] = input().strip()
        dop[d[i]] = i

    graph = collections.defaultdict(list)
    for i in range(m):
        s = input().strip().split()
        ind = int(s[1])
        sset = binary(s[0])

        if d[ind] not in sset:
            print('NO')
            break
        for i in sset:
            if i in dop and dop[i] != ind :
                graph[dop[i]].append(ind)
    else:

        if topo(graph):
            print('YES')
            print(' '.join(ans))
        else:
            print('NO')",np
"import sys
import math
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, sys.stdin.readline().strip().split())
def listinput(): return list(map(int, sys.stdin.readline().strip().split()))
n,m=minput()
x=listinput()
y=listinput()
xx=set(x)
yy=set(y)
common=xx.intersection(yy)
for i in x:
    if i in common:
        print(i,end=' ')",quadratic
"def suma_o_resta(a, b):
	return (a & (1<<b))

def diferencia(s1, d):
	if s1:
		s1.sort()

		if s1[-1] - s1[0] >= d:

			return s1
		else:
			return diferencia(s1.remove(s1[-1]), d)
	return s1

def no_sets(v, n, l, r, d):
	s = []
	cont = 0
	for x in range(1<<n):
		for i in range(n):

			if suma_o_resta(x, i) > 0:

				s.append(v[i])
		s = diferencia(s, d)
		if s:
			if sum(s) >= l and sum(s) <= r:
				cont += 1
		s = []
	return cont;

n, l, r, x = map(int, input().split())

v = list(map(int, input().split()))

print(str(no_sets(v, n, l, r, x)))",np
"from math import factorial
s1 = input()
s2 = input()
p = 0
m = 0
blank = 0
for i in range(len(s1)):
    if (s1[i] == ""+""):
        p += 1
    else:
        m += 1
    if (s2[i] == ""+""):
        p -= 1
    elif (s2[i]==""-""):
        m -= 1
    else:
        blank += 1
if (m<0 or p<0):
    print(0)
else:
    if (m==0):
        print(0.5 ** p)
    elif (p==0):
        print(0.5 ** m)
    else:
        b = blank
        print((factorial(b)/factorial(p)/factorial(m))*(0.5**b))",np
"n_extnson, n_dvics, n_sokts = list(map(int, input().split()))
extensions = list(map(int, input().split()))
extensions.sort(reverse=True)
devices_left = n_dvics - n_sokts
extnson_used = 0
i = 0
while devices_left > 0 and n_extnson > 0:
    devices_left += 1
    extnson_siez = extensions[i]
    devices_left -= extnson_siez
    extnson_used += 1
    n_extnson -= 1
    i += 1

if devices_left > 0:
    print(-1)
else:
    print(extnson_used)",nlogn
"n, s = map(int, input().split())
l = [0 for i in range(n)]
for i in range(n-1):
	a, b = map(int, input().split())
	l[a-1]+=1
	l[b-1]+=1
count = 0
for i in range(n):
	if(l[i]==1):
		count+=1
print((s/count)*2)",linear
"import functools
import time
from collections import Counter

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:

    def __init__(self):
        pass

    def __call__(self):
        n = int(input())
        minv = n + 1
        mini = n
        for l in range(1, n + 1):
            v = l + (n + l - 1) // l
            if v < minv:
                minv = v
                mini = l

        ref = [i + 1 for i in range(n)]
        l = mini
        res = list()
        p = n - 1
        while p >= 0:
            pp = max(0, p - l + 1)
            res.extend(ref[pp:p + 1])
            p = pp - 1
        print(' '.join(map(str, res)))

solver()()",linear
"r,g,b = map(int,input().split())
l1 = list(map(int,input().split()))
l2 = list(map(int,input().split()))
l3 = list(map(int,input().split()))
l1.sort(reverse=True)
l2.sort(reverse=True)
l3.sort(reverse=True)
dp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]
ans = 0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i == 0 and j == 0:
                dp[i][j][k] = 0
            if j == 0 and k == 0:
                dp[i][j][k] = 0
            if i == 0 and k == 0:
                dp[i][j][k] = 0
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])
            else:
                if i>0 and j>0:
                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]
                elif i>0 and k>0:
                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]
                elif j>0 and k>0:
                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]
            ans = max(ans,dp[i][j][k])

print(ans)",cubic
"n,m,k=map(int,input().split())
arr=list(map(int,input().split()))
arr.sort()
arr=arr+[k]
ans=0
s=0
while ans<n+1:
    s+=arr[-ans-1]
    if s>=m:
        break
    ans+=1
    s-=1
if s>=m:
    print(ans)
else:
    print(""-1"")",nlogn
"l,r=map(int,input().split())
x=l^r
a=2
if(l==r):
    print(0)
else:
    while(a<=x):
        a=a*2

    print(a-1)",logn
"n, m = map(int, input().split())

l=[]
s1 = s2 = 0
for i in range(n):
    a, b = map(int, input().split())
    s1+=a
    s2+=b
    l.append(a-b)

if s1<=m: print(0)
elif s2>m: print(-1)
else:
    r=0
    l.sort(reverse=True)
    for i in l:
        r+=1
        s1-=i
        if s1<=m:
            print(r)
            break",nlogn
"import sys
import os.path
from collections import *
import math
import bisect

if (os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")
else:
    input = sys.stdin.readline

n = int(input())

if(n == 2 or n == 3 or n == 4 or n == 5):
    print(-1)
else:
    print(1,2)
    print(2,3)
    print(2,4)
    for i in range(5,n + 1):
        print(4,i)

for i in range(2,n + 1):
    print(1,i)",linear
"import sys
import io, os
input = sys.stdin.buffer.readline

from collections import defaultdict

n, a, b = map(int, input().split())
XV = []
for i in range(n):
    x, vx, vy = map(int, input().split())
    XV.append((x, vx, vy))
if a != 0:
    ans = 0
    d = defaultdict(lambda:0)
    dvx = defaultdict(lambda:0)
    for x, vx, vy in XV:
        k = -a*vx+vy
        ans += max(0, d[k]-dvx[(k, vx)])
        d[k] += 1
        dvx[(k, vx)] += 1
    print(ans*2)
else:
    ans = 0
    d = defaultdict(lambda:defaultdict(lambda:0))
    ds = defaultdict(lambda:0)
    for x, vx, vy in XV:
        ans += max(0, ds[vy]-d[vy][vx])
        d[vy][vx] += 1
        ds[vy] += 1
    print(ans*2)",linear
"import sys,os,io,time,copy
if os.path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

import math

def main():

    n=int(input())
    print(0,0,n)

main()",constant
"input()
a=list(map(int,input().split()))
n=len(a)
u=n
for i in range(n):
	j=i
	k=0
	while a[j]>0:
		k+=1
		t=j
		j=a[j]-1
		a[t]=0
	if k>0:
		u+=1-k%2
s='Petr'
if u%2>0:
	s='Um_nik'
print(s)",nlogn
"r,g,b=map(int,input().split())
s1=[int(x) for x in input().split()]
s2=[int(x) for x in input().split()]
s3=[int(x) for x in input().split()]
s1.sort()
s2.sort()
s3.sort()
s1=s1[::-1]
s2=s2[::-1]
s3=s3[::-1]
s1=[0]+s1
s2=[0]+s2
s3=[0]+s3

dp=[]
for i in range(r+5):
    H=[]
    for j in range(g+5):
        h=[]
        for k in range(b+5):
            h.append(0)
        H.append(h)
    dp.append(H)

for i in range(0,r+1):
    for j in range(0,g+1):
        for k in range(0,b+1):
            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0
            if(i-1>=0 and j-1>=0):
                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])
            if(i-1>=0 and k-1>=0):
                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])
            if(k-1>=0 and j-1>=0):
                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])
            if(i-1>=0):
                t4 = dp[i-1][j][k]
            if(j-1>=0):
                t5 = dp[i][j-1][k]
            if(k-1>=0):
                t6 = dp[i][j][k-1]

            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)

print(dp[r][g][b])",cubic
"n = int(input())
ans = []
mult = 1
while n > 3:
    ans += [mult]*(n-n//2)
    n //= 2
    mult *= 2
if n == 3:
    ans += [mult, mult, mult*3]
elif n == 2:
    ans += [mult, mult*2]
else:
    ans += [mult]
print(*ans)",logn
"n,U=list(map(int, input().split(' ')))
a=list(map(int, input().split(' ')))

import bisect
def max_eligible(a,x):
    ind=bisect.bisect_right(a,x)
    if ind <= len(a):
        return a[ind-1]
    else:
        return -1

max_val=-1
for i in range(n-2):
    x = a[i]+U
    val1 = max_eligible(a,x)

    if val1!=-1 and val1!=a[i+1] and val1!=a[i]:

        val = (val1-a[i+1]) / (val1-a[i])

        max_val=max(max_val,val)

print(max_val)",nlogn
