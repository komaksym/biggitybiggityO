code,complexity
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution3(object):

    def __init__(self):
        self.stack = []

    def push(self, x):
        if self.stack:
            current_min = min(x, self.stack[-1][0])
            self.stack.append((current_min, x))
        else:
            self.stack.append((x, x))

    def pop(self):
        return self.stack.pop()[1]

    def top(self):
        return self.stack[-1][1]

    def getMin(self):
        return self.stack[-1][0]",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]

def solve(x , arr ):

    n = len(arr)
    flag = True
    k = []
    i = 0
    while flag:
        sm = 0
        while n > 0 and sm < x :
            sm += int(arr[i])
            i +=1
            n -=1
            if n <= 0 :
                flag = False
                break
        if sm>0:
            k.append(sm)

    return k

n = INT()
s = STR()

if len(set(s)) == 1 :
    print('YES');exit(0)

l = []
t = 0
for i in range(n-1):
    t += int(s[i])
    l.append(t)

v = []
for i in l :
    if i > 0 :
        r = solve(i , s)
        if len(r) > 1 and len(set(r)) == 1 :
            print('YES')
            break
else:
    print('NO')
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maximumGap(self, nums):
        if len(nums) < 2:
            return 0

        max_val, min_val = max(nums), min(nums)
        gap = max(1, (max_val - min_val) / (len(nums) - 1))
        bucket_size = (max_val - min_val) / gap + 1
        bucket = [{'min':float(""inf""), 'max':float(""-inf"")} \
                    for _ in range(bucket_size)]

        for n in nums:
            if n in (max_val, min_val):
                continue
            i = (n - min_val) / gap
            bucket[i]['min'] = min(bucket[i]['min'], n)
            bucket[i]['max'] = max(bucket[i]['max'], n)

        max_gap, pre_bucket_max = 0, min_val
        for i in range(bucket_size):
            if bucket[i]['min'] == float(""inf"") and \
                bucket[i]['max'] == float(""-inf""):
                continue
            max_gap = max(max_gap, bucket[i]['min'] - pre_bucket_max)
            pre_bucket_max = bucket[i]['max']
        max_gap = max(max_gap, max_val - pre_bucket_max)

        return max_gap",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import *
mod=1000000007
n,q=map(int,stdin.readline().split())
s=str(stdin.readline())
arr=[]
count=0
for i in s:
	if(i=='1'):
		count+=1
	arr.append(count)

ansarr=[]
for i in range(q):
	x,y=map(int,input().split())
	if(x==1):
		total1=arr[y-1]
	else:
		total1=arr[y-1]-arr[x-2]
	total0=(y-x+1-total1)
	ans=pow(2,y-x+1,mod)%mod
	ans=((((ans%mod)-(pow(2,total0,mod)%mod))%mod)+mod)%mod
	ansarr.append(ans)
stdout.write('\n'.join(map(str, ansarr)))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def solve():
    n, k = map(int, input().split())
    c = list(map(int, input().split()))
    f = list(map(int, input().split()))
    h = list(map(int, input().split()))
    cnt = {}
    for i in c:
        cnt[i] = cnt.get(i, 0) + 1
    likecolor = {}
    for i in range(n):
        likecolor.setdefault(f[i], []).append(i)
        cnt[f[i]] = cnt.get(f[i], 0)
    ans = 0
    for key, v in likecolor.items():
        n1 = len(v)
        if cnt[key] >= n1 * k:
            ans += n1 * h[k - 1]
            continue
        dp = [[-float(""INF"")] * (cnt[key]+1) for _ in range(n1 + 1)]
        dp[0][0] = 0
        for i in range(n1):
            j = i + 1
            for e in range(cnt[key] + 1):
                dp[j][e] = max(dp[j][e], dp[i][e])
                for w in range(e + 1, min(cnt[key] + 1, e + k + 1)):
                    dp[j][w] = max(dp[i][e] + h[w - e - 1], dp[j][w])
        ans += dp[n1][cnt[key]]
    print(ans)

solve()
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,m=[int(i) for i in input().split("" "")]
arrmv=[]
for i in range(n):
    arrmv.append([int(i) for i in input().split("" "")])
x=0
y=int(1e9+1)
sucls=[0,0]

tols=[]
mstr=""""

powls=[int(pow(2,i)) for i in range(10)]
twodarray=[0  for i in range(257)]
while x+1<y:
    mid = x+(y-x)//2

    for idx,ele in enumerate(twodarray):twodarray[idx]=0
    tols.clear()
    for topidx, eletop in enumerate(arrmv):
        tmp=0
        for idx,ele in enumerate(eletop):
            if ele>=mid:tmp+=powls[idx]

        if not twodarray[tmp]:

            twodarray[tmp]=1
            tols.append((tmp,topidx))
    sz=len(tols)
    suc=0
    no=int(pow(2,m))
    for i in range(sz):
        for j in range(i,sz):
            if tols[i][0] | tols[j][0] == no-1:
                sucls[0],sucls[1]=tols[i][1],tols[j][1]

                suc=1;
                break;
        if suc:break
    if suc:x=mid
    else:y=mid

print(sucls[0]+1,sucls[1]+1)
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: length = int(input())
start = []
end = []
for i in range(length):
    a, b = map(int, input().split("" ""))
    e, s = a - b, a + b
    end.append([e, i])
    start.append([s, i])
end.sort(key = lambda x:x[0])
start.sort(key = lambda x:x[0])
cant_visit = set()
answer = 0
end_index = 0
for s, i in start:
    if i not in cant_visit:
        answer += 1
        while end_index < length and end[end_index][0] < s:
            cant_visit |= {end[end_index][1]}
            end_index += 1
print(answer)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        stones.sort()
        n = len(stones)

        while n > 1:
            cur = stones.pop() - stones.pop()
            n -= 2
            if cur > 0:
                l, r = 0, n
                while l < r:
                    mid = (l + r) // 2
                    if stones[mid] < cur:
                        l = mid + 1
                    else:
                        r = mid
                pos = l
                n += 1
                stones.append(0)
                for i in range(n - 1, pos, -1):
                    stones[i] = stones[i - 1]
                stones[pos] = cur

        return stones[0] if n > 0 else 0
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def findTheWinner(self, n, k):
        return reduce(lambda idx, n:(idx+k)%(n+1), range(1, n), 0)+1",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
a = sorted(list(map(int, input().split())))

win = None
first = True

if n == 1:
    win = a[0] % 2 == 1
elif a[1] == 0:
    win = False

if n > 2:
    for i in range(n-1):
        if a[i] == a[i+1]:
            if i > 0:
                if a[i-1] == a[i]-1:
                    win = False
                    break
            if not first:
                win = False
                break
            first = False

if win is None:
    win = (sum(a) - (n*(n-1)//2)) % 2 == 1

if win:
    print('sjfnb')
else:
    print('cslnb')
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: 
import itertools


class Solution(object):
    def minMovesToSeat(self, seats, students):
        seats.sort()
        students.sort()
        return sum(abs(a-b) for a, b in zip(seats, students))
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
arr = [int(x) for x in input().split()]
x = arr.index(max(arr))
cur = max(arr)
l = x - 1
r = x + 1
ok = 1
for i in range(n - 1):
    if l < 0:
        ok *= (arr[r] < cur)
        cur = arr[r]
        r += 1
    elif r >= n:
        ok *= (arr[l] < cur)
        cur = arr[l]
        l -= 1
    else:
        if arr[l] > arr[r]:
            ok *= (arr[l] < cur)
            cur = arr[l]
            l -= 1
        else:
            ok *= (arr[r] < cur)
            cur = arr[r]
            r += 1
print(""YES"" if ok else ""NO"")",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin
from collections import deque,Counter
import sys
import math
import operator
import random
from fractions import Fraction

n,k = map(int,input().split())
arr = list(map(int,input().split()))
arr.sort()
f = arr[0]
p = n
i = 0
count = 0
while i<n:
    while i<n and arr[i] == f:
        i+=1
        count+=1
    if i<n and arr[i]<=f+k:
        p-=count
    if i<n:
        f=arr[i]
        count=0
    continue

print(p)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,m=[int(x) for x in input().split(' ')]
print((n-1)*'4'+'5')
print(n*'5')
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution3(object):
    def longestPath(self, parent, s):
        def dfs(s, adj, u, result):
            top2 = [0]*2
            for v in adj[u]:
                l = dfs(s, adj, v, result)
                if s[v] == s[u]:
                    continue
                if l > top2[0]:
                    top2[0], top2[1] = l, top2[0]
                elif l > top2[1]:
                    top2[1] = l
            result[0] = max(result[0], top2[0]+top2[1]+1)
            return top2[0]+1
    
        
        adj = [[] for _ in range(len(s))]
        for i in range(1, len(parent)):
            adj[parent[i]].append(i)
        result = [0]
        dfs(s, adj, 0, result)
        return result[0]",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def maxRepeating(self, sequence, word):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in range(1, len(pattern)):
                while j > -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if len(sequence) < len(word):
            return 0

        new_word = word*(len(sequence)//len(word))
        prefix = getPrefix(new_word)
        result, j = 0, -1
        for i in range(len(sequence)):
            while j > -1 and new_word[j+1] != sequence[i]:
                j = prefix[j]
            if new_word[j+1] == sequence[i]:
                j += 1
            result = max(result, j+1)
            if j+1 == len(new_word):     
                break
        return result//len(word)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort

from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal

INF = 10001
mod = int(1e9) + 7

def cal(l,r):
    if l==r:
        dp1[l][r]=a[l]
        dp3[l][r] = 1
        return dp1[l][r]
    if dp1[l][r]!=-1:
        return dp1[l][r]
    for i in range(l,r):
        if cal(l,i) == cal(i+1,r) != 0:
            dp1[l][r]=dp1[l][i]+1
            dp3[l][r]=1
        dp3[l][r]=min(dp3[l][r],dp3[l][i]+dp3[i+1][r])
    if dp1[l][r] == -1:
        dp1[l][r] = 0
    return dp1[l][r]

n=int(data())
a=mdata()
ans=[n]
dp1=[[-1]*n for i in range(n)]
dp3=[[10001]*n for i in range(n)]
cal(0,n-1)
out(dp3[0][n-1])",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def examA():
    T = I()
    ans = []
    for _ in range(T):
        N, M = LI()
        if N%M!=0:
            ans.append(""NO"")
        else:
            ans.append(""YES"")
    for v in ans:
        print(v)
    return

def examB():
    T = I()
    ans = []
    for _ in range(T):
        N = I()
        A = LI()
        A.sort()
        ans.append(A[::-1])
    for v in ans:
        print("" "".join(map(str,v)))
    return

def examC():
    T = I()
    ans = []
    for _ in range(T):
        N, K = LI()
        A = LI()
        sumA = sum(A)
        if sumA==0:
            ans.append(""YES"")
            continue
        cur = 0
        L = []
        for i in range(100):
            now = K**i
            L.append(now)
            cur += now
            if cur>=sumA:
                break
        for i in range(N):
            A[i] *= (-1)
        heapify(A)

        for l in L[::-1]:
            if not A:
                break
            a = -heappop(A)
            if a<l:
                heappush(A, -a)
            elif a>l:
                heappush(A,-(a-l))
        if not A or heappop(A)==0:
            ans.append(""YES"")
        else:
            ans.append(""NO"")
    for v in ans:
        print(v)
    return

def examD():
    class combination():

        def __init__(self, n, mod):
            self.n = n
            self.fac = [1] * (n + 1)
            self.inv = [1] * (n + 1)
            for j in range(1, n + 1):
                self.fac[j] = self.fac[j - 1] * j % mod

            self.inv[n] = pow(self.fac[n], mod - 2, mod)
            for j in range(n - 1, -1, -1):
                self.inv[j] = self.inv[j + 1] * (j + 1) % mod

        def comb(self, n, r, mod):
            if r > n or n < 0 or r < 0:
                return 0
            return self.fac[n] * self.inv[n - r] * self.inv[r] % mod
    N, M = LI()
    ans = 0
    if N==2:
        print(ans)
        return
    C = combination(M,mod2)
    for i in range(N-1,M+1):
        cur = pow(2,N-3,mod2) * (i-1) * C.comb(i-2,N-3,mod2)

        ans += cur
        ans %= mod2
    print(ans)
    return

def examE():
    N = I()
    A = LI()
    dp = [[-1]*(N+1) for _ in range(N+1)]
    for i in range(N):
        dp[i][i+1] = A[i]
    for l in range(2, N + 1):
        for i in range(N - l + 1):
            for k in range(i + 1, i + l):
                if dp[i][k] >= 1 and dp[i][k] == dp[k][i+l]:
                    dp[i][i + l] = dp[i][k] + 1

    L = [inf]*(N+1)
    for i in range(1,N+1):
        if dp[0][i]>=1:
            L[i] = 1
    for i in range(N):
        for k in range(1, N - i + 1):
            if dp[i][i + k] >= 1:
                L[i + k] = min(L[i + k], L[i] + 1)

    ans = L[N]
    print(ans)
    return

def examF():
    ans = 0
    print(ans)
    return

import sys,copy,bisect,itertools,heapq,math,random
from heapq import heappop,heappush,heapify
from collections import Counter,defaultdict,deque
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int,sys.stdin.readline().split()))
def LSI(): return list(map(str,sys.stdin.readline().split()))
def LS(): return sys.stdin.readline().split()
def SI(): return sys.stdin.readline().strip()
global mod,mod2,inf,alphabet,_ep
mod = 10**9 + 7
mod2 = 998244353
inf = 10**18
_ep = 10**(-12)
alphabet = [chr(ord('a') + i) for i in range(26)]

if __name__ == '__main__':
    examE()
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def sm(n):
    return int(int(n*(n+1))/int(2));
def summ(en, st):
    if(st <= 1):
        return sm(en);
    return sm(en) - sm(st-1);

def bs(n, k):
    st = 1;
    en = k;
    while (st < en):
        md = int(int((st+en)) /int(2));
        s = summ(k,md);
        if(s == n):
            return k - md + 1;
        elif (s>n):
            st = md + 1;
        else :
            en = md;
    return k - st + 2;
n, k = input().split();
n = int(n);
k = int(k);

if(n == 1):
    print(0);
elif (n <= k):
    print(1);
else:
    n -= 1;
    k -= 1;
    if(sm(k) < n ):
        print(-1);
    else:
        print(int(bs(n,k)));
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from math import *
a, vm = map(int, input().split())
l, d, vd = map(int, input().split())
if vm <= vd or sqrt(2 * a * d) <= vd:
    if vm ** 2 / (2 * a) >= l:
        ans = sqrt(2 * l / a)
    else:
        ans = vm / a + (l - vm ** 2 / (2 * a)) / vm
else:
    s1 = (vm ** 2 - vd ** 2) / (2 * a)
    if s1 >= (l - d):
        ans = (sqrt(4 * (vd ** 2) + 8 * a * (l - d)) - 2 * vd) / (2 * a)
    else:
        ans = (vm - vd) / a + (l - d - s1) / vm
    v1 = sqrt((2 * a * d + vd ** 2) / 2)
    if v1 <= vm:
        ans = ans + v1 / a + (v1 - vd) / a
    else:
        s1 = d - (vm ** 2 - vd ** 2) / (2 * a) - (vm ** 2) / (2 * a)
        ans = ans + vm / a + (vm - vd) / a + s1 / vm
print('%.12f' % ans)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)

def getN():
    return int(input())
def getList():
    return list(map(int, input().split()))
import math

n, k = getList()
nums = getList()

diff = []

for i, j in zip(nums, nums[1:]):
    diff.append(j - i)

diff.sort()
print(sum(diff[:(n-k)]))",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: if __name__ == '__main__':
    a = [int(i) for i in input().split()]

    mx = -1

    for i in range(14):
        b = a.copy()
        if a[i]:
            b[i], d, ans = 0, i + 1, 0
            r = (a[i] + d) // 14
            l = (a[i] + d) % 14

            if d + a[i] < 14:
                ans = sum([j + 1 for j in a[d:d + a[i]] if not (j + 1) % 2])
            else:
                for j in range(14):
                    b[j] += r
                if d > l:
                    for j in range(l, d):
                        b[j] -= 1
                else:
                    for j in range(d, d + abs(d - l)):
                        b[j] += 1
                ans = sum([p for p in b if not p % 2])
            mx = max(mx, ans)

    print(mx)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def solve(n, a):
    a = sorted(a)
    if n == 1:
        return a[0] > 0 and a[0] % 2 == 1
    same_count = 0
    for i in range(n - 1):
        if a[i] == a[i + 1] == 0:
            return False
        if i < n - 2 and a[i] + 1 == a[i + 1] == a[i + 2]:
            return False
        if a[i] == a[i + 1]:
            same_count += 1
    if same_count > 1:
        return False
    return (sum(a) - n * (n - 1) // 2) % 2 == 1

assert not solve(1, [0])
assert not solve(2, [1, 0])
assert solve(2, [2, 2])
assert solve(3, [2, 3, 1])
assert not solve(4, [1, 1, 2, 2])
assert solve(4, [1, 1, 2, 3])
assert not solve(4, [1, 2, 3, 4])
assert solve(4, [0, 1, 2, 4])
assert solve(5, [0, 1, 2, 3, 5])

n = int(input())
a = map(int, input().split())

r = solve(n, a)
if r:

    print('sjfnb')
else:
    print('cslnb')
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,m=map(int, input().split())
a=list(map(int, input().split()))
t=n//m
remain=[[] for i in range(m)]
for i in range(n):
    x=a[i]%m
    remain[x].append(i)
ans=0
f=[]
for i in range(2*m):
    cur=i%m
    while len(remain[cur])>t:
        elm=remain[cur].pop()
        f.append([elm,i])
    while len(remain[cur])<t and len(f)!=0:
        elm,j=f.pop()
        remain[cur].append(elm)
        a[elm]+=abs(i-j)
        ans+=abs(i-j)
print(ans)
print(*a)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdout
m = 30
a, b = 0, 0
fle = 1
for i in range(m):
    if fle:
        print('? {} {}'.format(a, b))
        stdout.flush()
        resp1 = int(raw_input())
        fle = 0
    print('? {} {}'.format(a + 2**(m-1-i),b + 2**(m-1-i)))
    stdout.flush()
    resp2 = int(raw_input())

    if resp1 == -1 and resp2 == 1:
        b += 2**(m-1-i)
        fle = 1
    elif resp1 == 1 and resp2 == -1:
        a += 2**(m-1-i)
        fle = 1
    else:
        fle = 0
        print('? {} {}'.format(a + 2**(m-1-i), b))
        stdout.flush()
        resp3 = int(raw_input())
        if resp3 == -1:
            b += 2**(m-1-i)
            a += 2**(m-1-i)

print('! {} {}'.format(a,b))
stdout.flush()",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: T=int(input())
for _ in range(T):
    n,k=map(int,input().split())
    s=input()
    rq1=''
    rq2=''
    rq3=''

    for i in range(k):
        if(i%3==0):
            rq1=rq1+'R'
            rq2=rq2+'G'
            rq3=rq3+'B'
        elif(i%3==1):
            rq1=rq1+'G'
            rq2=rq2+'B'
            rq3=rq3+'R'
        elif(i%3==2):
            rq1=rq1+'B'
            rq2=rq2+'R'
            rq3=rq3+'G'

    ans=1000000000000000000

    for i in range(0,len(s)-k+1):

        a1=0
        a2=0
        a3=0

        for j in range(i,i+k):

            if(s[j]!=rq1[j-i]):
                a1+=1
            if(s[j]!=rq2[j-i]):
                a2+=1
            if(s[j]!=rq3[j-i]):
                a3+=1

        ans=min(ans,min(a1,a2,a3))

    print(ans)
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys

input=sys.stdin.readline
inf = 1e10
mod = int(1e9 + 7)
t=1;

for _ in range(t):

    s=input()
    c=s.count('1')
    c1, i=0, 0
    while(i<len(s) and s[i]!='2'):
        if(s[i]=='0'):c1+=1
        i+=1
    print('0'*c1, end="""")
    print('1'*c, end="""")
    while(i<len(s)):
        if(s[i]!='1'):
            print(s[i], end="""")
        i+=1",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys

import random

n = int(input())
if n<=3:
    print('YES')
    sys.exit()
coord = [int(x) for line in sys.stdin for x in line.split()]

X = [coord[2*i] for i in range(n)]
Y = [coord[2*i+1] for i in range(n)]

for i in range(13):
    a = random.randint(0,n-1)
    b = random.randint(0,n-2)

    if a==b:
        b+=1

    x0,y0 = X[a],Y[a]
    x1,y1 = X[b],Y[b]

    dx = x1-x0
    dy = y1-y0
    not_on_line = []
    for c in range(n):
        if c==a or c==b:
            continue
        x2,y2 = X[c],Y[c]
        Dx = x2-x0
        Dy = y2-y0
        if dx*Dy-dy*Dx!=0:
            not_on_line.append(c)
    if len(not_on_line)<=1:
        print('YES')
        sys.exit()

    a = not_on_line[0]
    b = not_on_line[1]
    x0,y0 = X[a],Y[a]
    x1,y1 = X[b],Y[b]

    dx = x1-x0
    dy = y1-y0
    can = True
    for c in not_on_line:
        if c==a or c==b:
            continue
        x2,y2 = X[c],Y[c]
        Dx = x2-x0
        Dy = y2-y0
        if dx*Dy-dy*Dx!=0:
            can = False
            break
    if can:
        print('YES')
        sys.exit()
print('NO')",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def optimalDivision(self, nums):
        if len(nums) == 1:
            return str(nums[0])
        if len(nums) == 2:
            return str(nums[0]) + ""/"" + str(nums[1])
        result = [str(nums[0]) + ""/("" + str(nums[1])]
        for i in range(2, len(nums)):
            result += ""/"" + str(nums[i])
        result += "")""
        return """".join(result)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, m = map(int, input().split(' '))

distances = list(map(int, input().split(' ')))
taxiDriver = list(map(int, input().split(' ')))

people = []
drivers = []
result = [0] * m

for i in range(len(distances)):
  if(taxiDriver[i]):
    drivers.append(distances[i])
  else:
    people.append(distances[i])

j = 0

for person in people:
  if (j + 1) < len(drivers):
    while (j + 1) < len(drivers) and (drivers[j] - person) < (person - drivers[j + 1]) :
      j += 1

    result[j] += 1
  else:
    result[j] += 1

print(' '.join(map(str, result)))
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: q = int(input())

for i in range(q):
    n,k = map(int,input().split())
    if n > 31:
        print(""YES"",n-1)
        continue
    a = [0]
    for i in range(1,n+1):
        a.append(a[i-1]*4+1)
    if a[n] < k:
        print(""NO"")
        continue
    if n == 2 and k == 3:
        print(""NO"")
        continue
    p = 0
    q = 2
    while p+q-1 <= k and n > 0:
        p += q-1
        q *= 2
        n -= 1
    print(""YES"",n)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import defaultdict
from collections import deque
import sys
input = sys.stdin.readline

def bfs(s):
    q = deque()
    q.append(s)
    dist = [-1] * (n + 1)
    dist[s] = 0
    p = []
    parent = [1] * (n + 1)
    ok = [0] * (n + 1)
    while q:
        i = q.popleft()
        d = dist[i]
        if d < 3:
            ok[i] = 1
        p.append(i)
        for j in G[i]:
            if dist[j] == -1:
                q.append(j)
                dist[j] = d + 1
                parent[j] = i
    ans = 0
    while p:
        i = p.pop()
        j = parent[i]
        if not ok[i]:
            ok[j] = 1
            ans += 1
            for k in G[j]:
                ok[k] = 1
    return ans

n = int(input())
G = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    u, v = map(int, input().split())
    G[u].append(v)
    G[v].append(u)
ans = bfs(1)
print(ans)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
import functools
import random
from atexit import register
from io import BytesIO
import __pypy__

EPS = 10**-12

class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):

    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):

    self.out.append(str(text))

  def writeLine(self, text):

    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

def bootstrap(f, stack=[]):

  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc

class CycleFindDirected(object):

  def __init__(self, n):

    self.n = n
    self.adj = [[] for _ in range(n)]

  def add_edge(self, u, v):

    assert 0 <= u < self.n
    assert 0 <= v < self.n
    self.adj[u].append(v)

  @bootstrap
  def dfs(self, node):
    self.color[node] = 1
    for i in self.adj[node]:
      if self.color[i] == 0:

        self.parent[i] = node
        if (yield self.dfs(i)):
          yield True

      elif self.color[i] == 1:
        self.cycle_end = node
        self.cycle_start = i
        yield True

    self.color[node] = 2
    yield False

  def find(self):
    self.color = [0] * self.n
    self.parent = [-1] * self.n
    self.cycle_end = -1
    self.cycle_start = -1

    for i in range(self.n):
      if not self.color[i] and self.dfs(i):
        answer = []
        node_begin = self.cycle_start
        node_end = self.cycle_end
        answer.append(node_begin)
        while node_end != node_begin:
          answer.append(node_end)
          node_end = self.parent[node_end]

        answer.reverse()
        if len(answer) == 1:

          return [node_begin, node_begin]
        return answer

    return None

def main(inp, out):

  n, m = map(int, inp.rawInput().split())
  edges = []
  base = CycleFindDirected(n)
  for _ in range(m):
    u, v = map(int, inp.rawInput().split())
    u -= 1
    v -= 1
    edges.append((u, v))
    base.add_edge(u, v)

  cycle = base.find()
  if not cycle:
    out.writeLine(""YES"")
    return

  cycle.append(cycle[0])

  bad_edges = set()
  cycle_edges = []
  for u, v in zip(cycle[:-1], cycle[1:]):
    bad_edges.add((u, v))
    cycle_edges.append((u, v))

  cf = CycleFindDirected(n)
  for edge in edges:
    if edge not in bad_edges:
      cf.add_edge(edge[0], edge[1])

  for edge in cycle_edges:
    for toadd in cycle_edges:
      if toadd != edge:
        cf.adj[toadd[0]].append(toadd[1])

    if not cf.find():
      out.writeLine('YES')
      return

    for toadd in cycle_edges:
      if toadd != edge:
        cf.adj[toadd[0]].pop()

  out.writeLine('NO')

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution3(object):
    def longestMonotonicSubarray(self, nums):
        def f(compare):
            result = l = 0
            for i in range(len(nums)):
                l += 1
                if i+1 == len(nums) or not compare(nums[i], nums[i+1]):
                    result = max(result, l)
                    l = 0
            return result

        return max(f(lambda x, y: x < y), f(lambda x, y: x > y))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math
def factorial(num):
    if num == 1:
        return num
    else:
        return num * factorial(num - 1)

s1=input()
s2=input()
ans=0
for i in range(0,len(s1)):
    if(s1[i]=='+'):
        ans+=1
    else:
        ans-=1
t=0
qm=0
for i in range(0,len(s2)):
    if(s2[i]=='+'):
        t+=1
    elif(s2[i]=='-'):
        t-=1
    else:
        qm+=1
if(qm==0):
    if(ans==t):
        print(1.000000000000)
    else:
        print(0.000000000000)
else:
    k=ans-t
    if(abs(k)==qm):
        na=1/pow(2,qm)
        print(na)
    elif(abs(k)>qm):
        print(0.000000000000)
    else:
        if(k%2==0 and qm%2==1):
            print(0.000000000000)
        elif(k%2==1 and qm%2==0):
            print(0.000000000000)
        else:
            a=abs((qm+k)/2)
            b=abs((qm-k)/2)
            nu=factorial(qm)/(factorial(a)*factorial(b))
            ans=nu/(pow(2,qm))
            print(ans)",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from __pypy__.intop import int_mulmod

n_, MOD = [int(t) for t in input().split()]

def mul(a, b):
    return int_mulmod(a, b, MOD)

N = 410
dp = [[0] * (N+1) for _ in range(N+1)]

fact = [1]
for x in range(1, N):
    fact.append(fact[-1] * x % MOD)

inv_fact = [0] * N
inv_fact[-1] = pow(fact[-1], MOD - 2, MOD)
for x in reversed(range(1, N)):
    inv_fact[x - 1] = inv_fact[x] * x % MOD

def nCr(n, r):
    return mul(fact[n], mul(inv_fact[n-r], inv_fact[r]))

for n in range(1, N+1):
    dp[n][n] = pow(2, n-1, MOD)
    for i in range(1, n-1):
        j = n-i-1
        for k in range(1, i+1):
            dp[n][k+j] = (dp[n][k+j]
                          + mul(nCr(k+j, k), mul(dp[i][k], dp[j][j]))) % MOD

print(sum(dp[n_]) % MOD)
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: I = lambda: map(int, input().split())

n, k = I()
A = sorted((tuple(I()) for _ in range(n)), key=lambda x: (-x[0], x[1]))

print(A.count(A[k-1]))",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: case = int(input())
for i in range(case):
	f = [0] * 32
	g = [0] * 32
	success = False
	n,k = map(int,input().split())
	ans = n
	for i in range(1,n):
		f[i] = f[i - 1] * 4 + 1
		if f[i] >= k:
			success = True
			break
	for i in range(1,n + 1):
		if k < (1 << i) - 1:
			break
		k = k - (1 << i) + 1
		ans = ans - 1
	for i in range(n - 1,ans - 1,-1):
		if i >= 32 or (i and f[i] == 0):
			success = True
			break
		g[i] = 1 if i == n - 1 else g[i + 1] * 2 + 3
		k = k - f[i] * g[i]
		if k <= 0:
			success = True
			break
	print(""YES %d""%ans if success else ""NO"");",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os
import sys
import math
from io import BytesIO, IOBase
import io
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353

class LazySegTree:
    def __init__(self, _op, _e, _mapping, _composition, _id, v):
        def set(p, x):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            _d[p] = x
            for i in range(1, _log + 1):
                _update(p >> i)

        def get(p):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            return _d[p]

        def prod(l, r):
            assert 0 <= l <= r <= _n

            if l == r:
                return _e

            l += _size
            r += _size

            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push(r >> i)

            sml = _e
            smr = _e
            while l < r:
                if l & 1:
                    sml = _op(sml, _d[l])
                    l += 1
                if r & 1:
                    r -= 1
                    smr = _op(_d[r], smr)
                l >>= 1
                r >>= 1

            return _op(sml, smr)

        def apply(l, r, f):
            assert 0 <= l <= r <= _n
            if l == r:
                return

            l += _size
            r += _size

            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push((r - 1) >> i)

            l2 = l
            r2 = r
            while l < r:
                if l & 1:
                    _all_apply(l, f)
                    l += 1
                if r & 1:
                    r -= 1
                    _all_apply(r, f)
                l >>= 1
                r >>= 1
            l = l2
            r = r2

            for i in range(1, _log + 1):
                if ((l >> i) << i) != l:
                    _update(l >> i)
                if ((r >> i) << i) != r:
                    _update((r - 1) >> i)

        def _update(k):
            _d[k] = _op(_d[2 * k], _d[2 * k + 1])

        def _all_apply(k, f):
            _d[k] = _mapping(f, _d[k])
            if k < _size:
                _lz[k] = _composition(f, _lz[k])

        def _push(k):
            _all_apply(2 * k, _lz[k])
            _all_apply(2 * k + 1, _lz[k])
            _lz[k] = _id

        _n = len(v)
        _log = _n.bit_length()
        _size = 1 << _log
        _d = [_e] * (2 * _size)
        _lz = [_id] * _size
        for i in range(_n):
            _d[_size + i] = v[i]
        for i in range(_size - 1, 0, -1):
            _update(i)

        self.set = set
        self.get = get
        self.prod = prod
        self.apply = apply

MIL = 1 << 20

def makeNode(total, count):

    return (total * MIL) + count

def getTotal(node):
    return math.floor(node / MIL)

def getCount(node):
    return node - getTotal(node) * MIL

nodeIdentity = makeNode(0.0, 0.0)

def nodeOp(node1, node2):
    return node1 + node2

    return makeNode(
        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)
    )

identityMapping = -1

def mapping(tag, node):
    if tag == identityMapping:
        return node

    count = getCount(node)
    return makeNode(tag * count, count)

def composition(mapping1, mapping2):

    return mapping1 if mapping1 != identityMapping else mapping2

prime = [True for i in range(10)]
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n):

        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p):
                pp[i]+=1
                prime[i] = False
        p += 1

def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[n-1]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] >= key):
            res=arr[mid]
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[0]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=arr[mid]
            left = mid + 1
    return res

n = int(input())
a = list(map(int, input().split()))
difficulty = a[0]
expectation = a[0] % 998244353
for i in range(1, n):
    expectation = expectation * 2 + difficulty + a[i]
    difficulty = difficulty * 2 + a[i]
    expectation %= 998244353
    difficulty %= 998244353
print(expectation)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def numberOfWays(self, n, x):
        MOD = 10**9+7

        dp = [0]*(n+1)
        dp[0] = 1
        for i in range(1, n+1):
            i_pow_x = i**x
            if i_pow_x > n:
                break
            for j in reversed(range(i_pow_x, n+1)):
                dp[j] = (dp[j]+dp[j-i_pow_x])%MOD
        return dp[-1]",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys, math, queue

MOD = 998244353
sys.setrecursionlimit(1000000)

n, m, k = map(int, input().split())
a = list(map(int, input().split()))

dp = [[-10**20 for i in range(m)] for i in range(n)]

for i in range(n):
    for j in range(min(m, i+1)):
        if j == 0:
            dp[i][j] = max(dp[i-1][m-1]+a[i], a[i])-k
        else:
            dp[i][j] = dp[i-1][j-1]+a[i]

ans = 0
for i in range(n):
	ans = max(ans, max(dp[i]))
print(ans)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def leftRigthDifference(self, nums):
        total = sum(nums)
        result = []
        curr = 0
        for x in nums:
            curr += x
            result.append(abs((curr-x)-(total-curr)))
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections
from functools import reduce



class Solution(object):
    def countWinningSequences(self, s):
        MOD = 10**9+7
        lookup = {x:i for i, x in enumerate(""FWE"")}
        dp = [collections.defaultdict(int) for _ in range(3)]
        for i, c in enumerate(s):
            new_dp = [collections.defaultdict(int) for _ in range(3)]
            x = lookup[c]
            for j in range(3):
                diff = (j-x+1)%3-1
                if i == 0:
                    new_dp[j][diff] = 1
                    continue
                for k in range(3):
                    if k == j:
                        continue
                    for v, c in dp[k].items():
                        new_dp[j][v+diff] = (new_dp[j][v+diff]+c)%MOD
            dp = new_dp
        return reduce(lambda accu, x: (accu+x)%MOD, (c for j in range(3) for v, c in dp[j].items() if v >= 1), 0)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def singleNumber(self, nums):
        x_xor_y = 0
        for i in nums:
            x_xor_y ^= i

        bit = x_xor_y & ~(x_xor_y - 1)

        x = 0
        for i in nums:
            if i & bit:
                x ^= i

        return [x, x ^ x_xor_y]",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from itertools import combinations

p, minn, maxn, dif = map(int, input().split())
(*lst,) = map(int, input().split())
print(sum([sum([(maxn>=sum(j)>=minn)and((max(j)-min(j))>=dif) for j in combinations(lst,i)]) for i in range(2,p+1)]))
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def check(j):
    if sum(j)>=l and sum(j)<=r and (max(j)-min(j))>=x:
        return 1
    return 0

from itertools import combinations
n,l,r,x=list(map(int,input().split()))
c=list(map(int,input().rstrip().split()))
count=0
for i in range(2,n+1):
    a=list(combinations(c,i))
    for j in a:

        if check(j):
            count+=1
print(count)
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: 
import itertools


class Solution(object):
    def shortestToChar(self, S, C):
        result = [len(S)] * len(S)
        prev = -len(S)
        for i in itertools.chain(range(len(S)),
                                 reversed(range(len(S)))):
            if S[i] == C:
                prev = i
            result[i] = min(result[i], abs(i-prev))
        return result

",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def countPairs(self, nums1, nums2):
        for i in range(len(nums1)):
            nums1[i] -= nums2[i]
        nums1.sort()
        result = 0
        left, right = 0, len(nums1)-1
        while left < right:
            if nums1[left] > 0 or -nums1[left] < nums1[right]:
                result += right-left
                right -= 1
            else:
                left += 1
        return result",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections


class Solution(object):
    def findLHS(self, nums):
        lookup = collections.defaultdict(int)
        result = 0
        for num in nums:
            lookup[num] += 1
            for diff in [-1, 1]:
                if (num + diff) in lookup:
                    result = max(result, lookup[num] + lookup[num + diff])
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def goodIndices(self, nums, k):
        left = [1]*len(nums)
        for i in range(1, len(nums)-1):
            if nums[i] <= nums[i-1]:
                left[i] = left[i-1]+1
        right = [1]*len(nums)
        for i in reversed(range(1, len(nums)-1)):
            if nums[i] <= nums[i+1]:
                right[i] = right[i+1]+1
        return [i for i in range(k, len(nums)-k) if min(left[i-1], right[i+1]) >= k]",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def semiOrderedPermutation(self, nums):
        i, j = nums.index(1), nums.index(len(nums))
        return i+((len(nums)-1)-j)-int(i > j)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: yellow, blue = map(int, input().split())
x, y, z = map(int, input().split())
answer1 = x*2+y-yellow
answer2 = z*3+y - blue
if answer1 > 0:
    if answer2 > 0:
        print(answer1+answer2)
    else:
        print(answer1)
else:
    if answer2 > 0:
        print(answer2)
    else:
        print(0)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
f=[input().strip()==""f"" for ii in range(n)]
mod=10**9+7
def summ(a,b):
 return (a+b)%mod
dp=[1]
for ii in range(1,n):
 pf=f[ii-1]
 if pf:
  dp.insert(0,0)
 else:
  for jj in reversed(range(1,len(dp))):
   dp[jj-1]=summ(dp[jj-1],dp[jj])
ans=0
for vv in dp:
 ans=summ(ans,vv)
print(ans)
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def removePalindromeSub(self, s):
        def is_palindrome(s):
            for i in range(len(s)//2):
                if s[i] != s[-1-i]:
                    return False
            return True
        
        return 2 - is_palindrome(s) - (s == """")",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def pow_mod(x, pwr, mod):
	res = 1
	multiplier = x
	while pwr > 0:
		if pwr%2 == 1:
			res = res*multiplier % mod
		multiplier = multiplier*multiplier % mod

		pwr //= 2

	return res

[x, k] = map(int, input().split())

MOD = 1000000007

if x == 0:
	res = 0
else:
	res = pow_mod(2, k+1, MOD)*x % MOD
	res = (res - pow_mod(2, k, MOD)) % MOD
	res = (res + 1) % MOD

print(res)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maxDiff(self, num):
        digits = str(num)
        for b in digits:
            if b < '9':
                break
        if digits[0] != '1':
            a = digits[0]
        else:
            for a in digits:
                if a > '1':
                    break
        return int(digits.replace(b, '9')) - \
               int(digits.replace(a, '1' if digits[0] != '1' else '0'))",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from bisect import bisect_left as bl
from bisect import bisect_right as br
import heapq
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

def factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))

def li():return [int(i) for i in input().rstrip('\n').split(' ')]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n').split(' ')]
def li3():return [int(i) for i in input().rstrip('\n')]

n,L = li()
l = []
for i in range(n):
    l.append(li())

index = defaultdict(list)
for ind,i in enumerate(l):
    index[tuple(i)].append(ind + 1)

l.sort(key = lambda x:x[1])
d = defaultdict(list)

ans = i = tot = currpoints = 0
anspattern = []
he = []

while i < n:

    if l[i][1] + tot <= L:
        tot += l[i][1]
        heapq.heappush(d[l[i][0]],l[i][1])
        currpoints += 1

        if len(d[l[i][0]]) == 1:
            heapq.heappush(he,l[i][0])

    while len(he) and currpoints > he[0]:
        temp = heapq.heappop(he)
        tot -= heapq.heappop(d[temp])
        currpoints -= 1
        if len(d[temp]):heapq.heappush(he,temp)

    if currpoints > ans:

        ans = currpoints

    i += 1
i = tot = currpoints = 0
he = []
d = defaultdict(list)

while i < n:

    if l[i][1] + tot <= L:
        tot += l[i][1]
        heapq.heappush(d[l[i][0]],l[i][1])
        currpoints += 1

        if len(d[l[i][0]]) == 1:
            heapq.heappush(he,l[i][0])

    while len(he) and currpoints > he[0]:
        temp = heapq.heappop(he)
        tot -= heapq.heappop(d[temp])
        currpoints -= 1
        if len(d[temp]):heapq.heappush(he,temp)

    if currpoints == ans:
        anspattern = []
        for i in he:
            for j in d[i]:
                anspattern.append(index[tuple([i,j])][-1])
                index[tuple([i,j])].pop()
        print(ans)
        print(len(anspattern))
        print(*sorted(anspattern))
        exit()

        ans = currpoints

    i += 1",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math
a=input()
b=input()
x=a.count('+')-b.count('+')
y=a.count('-')-b.count('-')
c=a.count('+')-a.count('-')
d=b.count('+')-b.count('-')
e=c-d
f=b.count('?')
if x==0 and y==0:
    print(1)
elif f==0 and (x!=0 or y!=0):
    print(0)
elif x!=0 and y==0:
    print(1/2**f)
elif y!=0 and x==0:
    print(1/2**f)
elif abs(e)>f:
    print(0)
else:
    print(math.factorial(f)/(math.factorial(y)*math.factorial(x)*2**f))",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,k=[int(x) for x in input().split("" "")]
a=[int(x) for x in input().split("" "")]
mark,b=[],[]
for x in a:
    b.append(x)
    mark.append(False)
b.sort(reverse=True)
idx,profit=0,0
while idx<k:
    profit+=b[idx]
    for i in range(n):
        if not mark[i] and a[i]==b[idx]:
            mark[i]=True
            break
    idx+=1
print(profit)
prev,counter=-1,0
for i in range(n):
    if counter==(k-1):
        break
    if mark[i]:
        print(i-prev,end=' ')
        prev=i
        counter+=1
print(n-prev-1)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections



class Solution2(object):
    def divisibleTripletCount(self, nums, d):
        result = 0
        cnt = collections.Counter()
        for i in range(len(nums)):
            if nums[i]%d in cnt:
                result += cnt[nums[i]%d]
            for j in range(i):
                cnt[-(nums[i]+nums[j])%d] += 1
        return result",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, v = map(int, input().split())
cur = 0
total = 0
for i in range(n):
    while cur < n - i - 1:
        cur += 1
        total += (i + 1)
        if cur == v:
            break
    cur -= 1
print(total)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
k = set(""47"")
p = False
for i in range(1, n+1):
    if n%i == 0:
        if set(str(i)) <= k:
            p = bool(set(str(i)))
            break
if p == True:
    print(""YES"")
else:
    print(""NO"")",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: val=10**9
n,m=map(int,input().split())
arr1=[]
for i in range(n):
    x=int(input())
    arr1.append(x)
arr1.append(val)
arr2=[]
ans=val
finalval=0
arr1.sort()
for i in range(m):
    x1,x2,y=map(int,input().split())
    if(x1==1):
        if(x2==val):
            finalval+=1
        else:
            if(len(arr1)>0 and x2>=arr1[0]):
                arr2.append(x2)
arr2.sort()
i=0
j=0
while(i<len(arr1) and j<len(arr2)):
    if(arr1[i]>arr2[j]):
        j+=1
    elif(arr1[i]==arr2[j]):
        temp1=len(arr2)-j

        ans=min(i+temp1,ans)
        i+=1
    else:
        temp1=len(arr2)-j

        ans=min(i+temp1,ans)
        i+=1

ans=min(i,ans)
print(ans+finalval)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import threading


class Solution(object):
    def __init__(self):
        self.__l = threading.Lock()
        self.__nH = 0
        self.__nO = 0
        self.__releaseHydrogen = None
        self.__releaseOxygen = None

    def hydrogen(self, releaseHydrogen):
        with self.__l:
            self.__releaseHydrogen = releaseHydrogen
            self.__nH += 1
            self.__output()

    def oxygen(self, releaseOxygen):
        with self.__l:
            self.__releaseOxygen = releaseOxygen
            self.__nO += 1
            self.__output()

    def __output(self):
        while self.__nH >= 2 and \
              self.__nO >= 1:
            self.__nH -= 2
            self.__nO -= 1
            self.__releaseHydrogen()
            self.__releaseHydrogen()
            self.__releaseOxygen()",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin
input=stdin.readline
rn=lambda:int(input())
rns=lambda:map(int,input().split())
rl=lambda:list(map(int,input().split()))
rs=lambda:input()
YN=lambda x:print('YES') if x else print('NO')
mod=10**9+7

n,m,k=rns()
rows=[rl() for i in range(n)]
cols=[rl() for i in range(n-1)]
def solve():
    if k%2==1:
        return [m*[-1] for i in range(n)]
    dp=[[[0 for i in range(k//2+1)] for j in range(m)] for l in range(n)]
    for i in range(1,k//2+1):
        for a in range(n):
            for b in range(m):
                mins=[]
                if b>0:
                    mins.append(dp[a][b-1][i-1] + 2*rows[a][b-1])
                if b<m-1:
                    mins.append(dp[a][b + 1][i - 1] + 2 * rows[a][b])
                if a>0:
                    mins.append(dp[a-1][b][i - 1] + 2 * cols[a-1][b])
                if a<n-1:
                    mins.append(dp[a+1][b][i - 1] + 2 * cols[a][b])
                dp[a][b][i]=min(mins)
    ans=[[dp[i][j][-1] for j in range(m)] for i in range(n)]
    return ans

ans = solve()
for i in ans:
    print(*i)",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def solve():
    l, r = map(int, input().split())

    ans = l^r
    j = 0
    while 1<<j <= ans:
        ans |= 1<<j
        j += 1

    print(ans)

solve()
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def power(x,y):
	mod=1000000007
	res = 1
	while (y > 0):
		if (y &1):
			res = (res * x)%mod
		y = y >> 1
		x = (x * x)%mod
	return res;
x,k=map(int,input().split())
mod=1000000007
factor=power(2,k)
factor%=mod
ans=((2*factor*x)%mod-(factor)%mod + 1 + mod)%mod
if x==0:
	print(""0"")
else:
	print(ans)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import itertools
class Solution_TLE(object):
    def createSortedArray(self, instructions):
        MOD = 10**9 + 7
        def smallerMergeSort(idxs, start, end, counts):
            if end - start <= 0: 
                return 0

            mid = start + (end - start) // 2
            smallerMergeSort(idxs, start, mid, counts)
            smallerMergeSort(idxs, mid + 1, end, counts)
            r = start
            tmp = []
            for i in range(mid+1, end + 1):
                while r <= mid and idxs[r][0] < idxs[i][0]:
                    tmp.append(idxs[r])
                    r += 1
                tmp.append(idxs[i])
                counts[idxs[i][1]] += r - start
            while r <= mid:
                tmp.append(idxs[r])
                r += 1
            idxs[start:start+len(tmp)] = tmp
        
        def largerMergeSort(idxs, start, end, counts):
            if end - start <= 0: 
                return 0

            mid = start + (end - start) // 2
            largerMergeSort(idxs, start, mid, counts)
            largerMergeSort(idxs, mid + 1, end, counts)
            r = start
            tmp = []
            for i in range(mid+1, end + 1):
                while r <= mid and idxs[r][0] <= idxs[i][0]:
                    tmp.append(idxs[r])
                    r += 1
                if r <= mid:
                    tmp.append(idxs[i])
                counts[idxs[i][1]] += mid - r + 1
            while r <= mid:
                tmp.append(idxs[r])
                r += 1
            idxs[start:start+len(tmp)] = tmp

        idxs = []
        smaller_counts, larger_counts = [[0] * len(instructions) for _ in range(2)]
        for i, inst in enumerate(instructions):
            idxs.append((inst, i))
        smallerMergeSort(idxs[:], 0, len(idxs)-1, smaller_counts)
        largerMergeSort(idxs, 0, len(idxs)-1, larger_counts)
        return sum(min(s, l) for s, l in zip(smaller_counts, larger_counts)) % MOD",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = map(int, input().split())

print((k + n - 1) // n)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
a = []

for i in range(1, n+1):
    l, r = map(int, input().split())
    a.append((l, r, i))

a.sort()

for i in range(n-1):
    if (a[i][0] == a[i+1][0]):
        print(str(a[i][2]) + ' ' + str(a[i+1][2]))
        break

    if (a[i][1] >= a[i+1][1]):
        print(str(a[i+1][2]) + ' ' + str(a[i][2]))
        break
else:
    print('-1 -1')
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from math import pow
n=int(int(input())-1)
x=1
y=9
while n>x*y:
    n-=x*y
    x+=1
    y*=10
a=int(pow(10,x-1))+int(n/x)
z=str(a)
which=n%x
print(z[which])",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections
n = int(input())
s = input()
t = input()
if collections.Counter(s) != collections.Counter(t):
    print(-1)
    exit()
sl = list(s)
st = list(t)
ans = []
p = 0
while sl:
    if sl[0] != st[0]:
        k = sl.index(st[0])
        ans.extend(list(range(k + p, p, -1)))
        sl.pop(k)
        st.pop(0)

    else:
        sl.pop(0)
        st.pop(0)
    p += 1
print(len(ans))
print(*ans)
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: 

class Solution(object):
    def isStrictlyPalindromic(self, n):
        return False
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
a=list(map(int,input().split()))
leaf=[i+1 for i in range(n) if a[i]==1]
root_w=[i+1 for i in range(n) if a[i]!=1]
root_r=[a[i-1]-2 for i in root_w]
l_path=root_w
if(len(leaf)!=0):
    l_path=[leaf[0]]+l_path
    leaf=leaf[1:]
if(len(leaf)!=0):
    l_path=l_path+[leaf[0]]
    leaf=leaf[1:]

if sum(root_r)<len(leaf):
    print(""NO"")
else:
    print(""YES {}"".format(len(l_path)-1))
    print(n-1)
    for i in range(len(l_path)-1):
        print(""{} {}"".format(l_path[i],l_path[i+1]))
    for l in leaf:
        while(len(root_r)>0 and root_r[0]==0):
            root_w = root_w[1:]
            root_r = root_r[1:]
        print(""{} {}"".format(l,root_w[0]))
        root_r[0] = root_r[0]-1
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())

print('0 0')
n-=1
k = n // 2
p = n - k
x = -k//2
while k > 0:
    if x != 0:
        print(x, 0)
        k -= 1
    x += 1
y = -p//2
while p > 0:
    if y != 0:
        print(0, y)
        p -= 1
    y += 1",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import random

class Solution2(object):
    def sortArray(self, nums):
        def nth_element(nums, left, n, right, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target):
                i = left
                while i <= right:
                    if compare(nums[i], target):
                        nums[i], nums[left] = nums[left], nums[i]
                        left += 1
                        i += 1
                    elif compare(target, nums[i]):
                        nums[i], nums[right] = nums[right], nums[i]
                        right -= 1
                    else:
                        i += 1
                return left, right

            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1

        def quickSort(left, right, nums):
            if left > right:
                return
            mid = left + (right-left)//2
            nth_element(nums, left, mid, right)
            quickSort(left, mid-1, nums)
            quickSort(mid+1, right, nums)

        quickSort(0, len(nums)-1, nums)
        return nums",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def canAttendMeetings(self, intervals):
        intervals.sort(key=lambda x: x[0])

        for i in range(1, len(intervals)):
            if intervals[i][0] < intervals[i-1][1]:
                return False
        return True",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def longestPalindrome(self, s: str) -> str:
        res, resLen = """", 0

        for i in range(len(s)):
            for j in range(i, len(s)):
                l, r = i, j
                while l < r and s[l] == s[r]:
                    l += 1
                    r -= 1

                if l >= r and resLen < (j - i + 1):
                    res = s[i : j + 1]
                    resLen = j - i + 1
        return res
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def coloredCells(self, n):
        return (1+(1+2*(n-1)))*n//2*2-(2*n-1)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:

        def rec(root: ListNode, cur: ListNode) -> ListNode:
            if not cur:
                return root
            root = rec(root, cur.next)

            if not root:
                return None
            tmp = None
            if root == cur or root.next == cur:
                cur.next = None
            else:
                tmp = root.next
                root.next = cur
                cur.next = tmp
            return tmp

        head = rec(head, head.next)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def trap(self, height):
        result, left, right, level = 0, 0, len(height)-1, 0
        while left < right:
            if height[left] < height[right]:
                lower = height[left]
                left += 1
            else:
                lower = height[right]
                right -= 1
            level = max(level, lower)
            result += level-lower
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,m=map(int,input().split())
g=[[*input()] for _ in range(n)]
c=[[0 for _ in range(m)] for _ in range(n)]
for i in range(n):
 v=0
 for j in range(m):
  v=(v+1)*(g[i][j]=='*')
  c[i][j]=v
 v=0
 for j in range(m-1,-1,-1):
  v=(v+1)*(g[i][j]=='*')
  c[i][j]=min(c[i][j],v)
for j in range(m):
 v=0
 for i in range(n):
  v=(v+1)*(g[i][j]=='*')
  c[i][j]=min(c[i][j],v)
 v=0
 for i in range(n-1,-1,-1):
  v=(v+1)*(g[i][j]=='*')
  c[i][j]=min(c[i][j],v)
for i in range(n):
 for j in range(m):
  if c[i][j]==1: c[i][j]=0
for i in range(n):
 v=0
 for j in range(m):
  v=max(v-1,c[i][j])
  if v:g[i][j]='.'
 v=0
 for j in range(m-1,-1,-1):
  v=max(v-1,c[i][j])
  if v:g[i][j]='.'
for j in range(m):
 v=0
 for i in range(n):
  v=max(v-1,c[i][j])
  if v:g[i][j]='.'
 for i in range(n-1,-1,-1):
  v=max(v-1,c[i][j])
  if v:g[i][j]='.'
if all(g[i][j]=='.' for i in range(n) for j in range(m)):
 r=[(i+1,j+1,c[i][j]-1) for i in range(n) for j in range(m) if c[i][j]]
 print(len(r))
 for t in r: print(*t)
else:
 print(-1)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
l=[input() for i in range(n)]

s=sorted(l,key=len)
for i in range(1,n):
    if s[i-1] not in s[i]:
        print(""NO"")
        exit()

print(""YES"")
for i in s:
    print(i)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def splitLoopedString(self, strs):
        tmp = []
        for s in strs:
            tmp += max(s, s[::-1])
        s = """".join(tmp)

        result, st = ""a"", 0
        for i in range(len(strs)):
            body = """".join([s[st + len(strs[i]):], s[0:st]])
            for p in strs[i], strs[i][::-1]:
                for j in range(len(strs[i])):
                    if p[j] >= result[0]:
                        result = max(result, """".join([p[j:], body, p[:j]]))
            st += len(strs[i])
        return result",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: xs,ys = map(float,input().split())

n = int(input())

dist = [[0]*(n+1) for i in range(n+1)]
dist2 = [[0]*(n) for i in range(n)]

objects = [list(map(float,input().split())) for i in range(n)] + [[xs,ys]]

for i in range(n+1):
    for j in range(n+1):
        dist[i][j] = (objects[i][0] - objects[j][0])**2 + (objects[i][1] - objects[j][1])**2

for i in range(n):
    for j in range(n):
        dist2[i][j] = dist[n][i] + dist[i][j] + dist[j][n]

dp = [1e6]*(1<<n)
vis = set([0])
dp[0] = 0

for i in range((1<<n)-1):
    if i in vis:

        for j in range(n):
            if i&(1<<j) == 0:

                newi = i + (1 << j)
                dp[newi] = min(dp[newi], dp[i] + 2*dist[n][j])
                vis.add(newi)

                for k in range(j+1,n):

                    if i&(1<<k) == 0:
                        newi |= 1<<k
                        dp[newi] = min(dp[newi], dp[i] + dist2[j][k])
                        vis.add(newi)
                        newi ^= 1<<k

                break

curr = (1<<n) - 1
path = [0]
while curr:
    for i in range(n):
        if curr & (1<<i):

            if dp[curr] == dp[curr - (1<<i)] + 2*dist[n][i]:
                path.extend([i+1,0])
                curr ^= (1<<i)

            for j in range(i+1,n):
                if curr & (1<<j):
                    if dp[curr] == dp[curr - (1<<i) - (1<<j)] + dist2[i][j]:
                        path.extend([j+1,i+1,0])
                        curr ^= (1<<i) + (1<<j)

print(int(dp[(1<<n)-1]))
print(*path[::-1])",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def construct_tree(n,d, k):
    nodes = []
    edges = []

    if d > n - 1:
        return None

    if k == 1 and n > 2:
        return None

    for i in range(1, d+2):
        current_deg = k - 1 if i == 1 or i == d + 1 else k - 2
        current_depth =  min(i-1, d-i+1)
        if current_depth and current_deg:
            nodes.append([i, min(i-1, d-i+1), current_deg])
        if i < d + 1:
            edges.append([i, i+1])

    current_nodes_count = d + 2
    pos = 0
    while current_nodes_count < n + 1:

        if pos >= len(nodes):
            return None

        current = nodes[pos]

        if not current[2]:
            pos += 1
            if pos == len(nodes):
                break
            continue

        if current[1] - 1 and k - 1:
            nodes.append([current_nodes_count, current[1] - 1, k - 1])
        edges.append([current[0], current_nodes_count])
        current[2] -= 1
        current_nodes_count += 1

    if current_nodes_count == n + 1:
        return edges
    return None

n, d, k = [int(val) for val in input().split()]
edges = construct_tree(n, d, k)
if edges:
    print('YES')
    print('\n'.join(['{0} {1}'.format(e[0], e[1]) for e in edges]))
else:
    print('NO')
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math

def solutions(a,b,c):
    d = (b**2) - (4*a*c)
    sol1 = (-b-math.sqrt(d))/(2*a)
    sol2 = (-b+math.sqrt(d))/(2*a)
    if sol1<0 and sol2>0:
        return sol2
    elif sol1>0 and sol2<0:
        return sol1
    else:
        return 0

x = input()
x=x.split("" "")
c = int(x[0])
m = int(x[1])

print(int(c-solutions(1,3,-(2*c+2*m))))
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
if n == 1:
    print(1)
else:
    adj = [[] for i in range(n+10)]
    s = input().split()
    for i in range(2,n+1):
        pi = int(s[i-2])
        adj[i].append(pi)
        adj[pi].append(i)

    num = 1
    curr = [1]
    nextcurr = []
    disco = [1]
    visited = {1:True}
    while num < n:
        for v in curr:
            for w in adj[v]:
                if w not in visited:
                    nextcurr.append(w)
                    visited[w] = True
                    disco.append(w)
                    num += 1
        curr = nextcurr
        nextcurr = []

    nl = {}
    nlvals = {}
    for v in disco[::-1]:
        nl[v] = max(sum(nl.get(w,0) for w in adj[v]),1)
        nlvals[nl[v]] = nlvals.get(nl[v],0)+1
    colors = {}
    leaves = nlvals[1]
    colors[1] = leaves
    for c in range(2, leaves+1):
        colors[c] = colors[c-1] + nlvals.get(c,0)

    ans = """"
    j = 1
    for i in range(1, n+1):
        while colors[j] < i:
            j += 1
        ans += str(j) + ' '
    print(ans.strip())
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
import math
from itertools import product

n,m,k = [int(i) for i in sys.stdin.readline().split()]

horiz_costs = [[]]*n
vert_costs = [[]]*(n-1)

for i in range(n):
    horiz_costs[i] = [int(i) for i in sys.stdin.readline().split()]
for i in range(n-1):
    vert_costs[i] = [int(i) for i in sys.stdin.readline().split()]

if k%2 == 1:
    for _ in range(n):
        print("" "".join([""-1""]*m))
    quit()

ans = [[[0]*m for _ in range(n)] for _ in range(k//2+1)]

def costs(i,j,ans,time):
    r = []
    if j<m-1:
        r += [2*horiz_costs[i][j] + ans[time-1][i][j+1]]
    if j>0:
        r += [2*horiz_costs[i][j-1] + ans[time-1][i][j-1]]
    if i<n-1:
        r += [2*vert_costs[i][j] + ans[time-1][i+1][j]]
    if i>0:
        r += [2*vert_costs[i-1][j] + ans[time-1][i-1][j]]
    return r

for time in range(1, k//2+1):
    for i in range(n):
        for j in range(m):
            cost = costs(i,j,ans, time)
            for c in cost:
                if ans[time][i][j] == 0 or c < ans[time][i][j]:
                    ans[time][i][j] = c

for i in range(n):
    print("" "".join([str(s) for s in ans[-1][i]]))
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):

    def __init__(self):
        self.__calendar = []


    def book(self, start, end):
        for i, j in self.__calendar:
            if start < j and end > i:
                return False
        self.__calendar.append((start, end))
        return True",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin,stdout
from math import gcd,sqrt,factorial,pi,inf
from collections import deque,defaultdict
from bisect import bisect,bisect_left
from time import time
from itertools import permutations as per
input=stdin.readline
R=lambda:map(int,input().split())
I=lambda:int(input())
S=lambda:input().rstrip('\r\n')
L=lambda:list(R())
P=lambda x:stdout.write(str(x)+'\n')
lcm=lambda x,y:(x*y)//gcd(x,y)
nCr=lambda x,y:(f[x]*inv((f[y]*f[x-y])%N))%N
inv=lambda x:pow(x,N-2,N)
sm=lambda x:(x**2+x)//2
N=10**9+7

n,m,k=R()
A=[L() for i in range(n)]
B=[L() for i in range(n-1)]
if k&1:
	for i in range(n):
		print('-1 '*m)
	exit()
X=[[0]*m for i in range(n)]
for _ in range(k//2):
	Y=[[inf]*m for i in range(n)]
	for i in range(n):
		for j in range(m):
			if i:
				Y[i][j]=X[i-1][j]+2*B[i-1][j]
			if i<n-1:
				Y[i][j]=min(Y[i][j],X[i+1][j]+2*B[i][j])
			if j:
				Y[i][j]=min(Y[i][j],X[i][j-1]+2*A[i][j-1])
			if j<m-1:
				Y[i][j]=min(Y[i][j],X[i][j+1]+2*A[i][j])
	X=Y
for i in X:
	print(*i)",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
arr = list(map(int, input().split()))
arr1 = [arr[0]]
m = -1
for i, v in enumerate(arr):
    if v > m + 1:
        print(i+1)
        break
    m = max(m, v)
else:
    print(-1)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: mod = int(1000000007)

def somaPa(nSteps):
    if nSteps == 0:
        return 0
    return (1 + nSteps) * nSteps / 2

def diminui(step):
    return (pow(2, step, mod) - 2) % mod

x, k = map(int, raw_input().split())

if x == 0:
    print(0)
else:
    pot = pow(2, k + 1, mod)
    inv = pow(2, mod - 2, mod)

    big = (x * pot) % mod
    small = (big - diminui(k + 1) ) % mod

    print(int((( ( (big + small) % mod)  * inv ) % mod)))
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections


class Solution(object):
    def longestSubarray(self, nums, limit):
        max_dq, min_dq = collections.deque(), collections.deque()
        left = 0
        for right, num in enumerate(nums):
            while max_dq and nums[max_dq[-1]] <= num:
                max_dq.pop()
            max_dq.append(right)
            while min_dq and nums[min_dq[-1]] >= num:
                min_dq.pop()
            min_dq.append(right)
            if nums[max_dq[0]]-nums[min_dq[0]] > limit:
                if max_dq[0] == left:
                    max_dq.popleft()
                if min_dq[0] == left:
                    min_dq.popleft()
                left += 1 
        return len(nums)-left",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        n,k=ria()
        a=1
        b=-(2*n+3)
        c=n*(n+1)-2*k
        x=(-b-int(math.sqrt(b**2-4*a*c)))//(2*a)
        print(x)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def twoSum(self, nums, target):
        start, end = 0, len(nums) - 1

        while start != end:
            sum = nums[start] + nums[end]
            if sum > target:
                end -= 1
            elif sum < target:
                start += 1
            else:
                return [start + 1, end + 1]",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def inn1(s1):
    t=False
    for i in s1:
        if i[0]>=xmi1 and i[0]<=xma1 and i[1]>=ymi1 and i[1]<=yma1:
            t=True
            break
    if c2[0]>=xmi1 and c2[0]<=xma1 and c2[1]>=ymi1 and c2[1]<=yma1:
            t=True
    return t
def inn2(s):
    t=False
    for i in s:
        if i[0]>=xmi2 and i[0]<=xma2 and i[1]>=ymi2 and i[1]<=yma2:
            t=True
            break
    if c1[0]>=xmi2 and c1[0]<=xma2 and c1[1]>=ymi2 and c1[1]<=yma2:
            t=True
    return t
def conv(s):
    for i in range(4):
        x=s[i][0]
        y=s[i][1]
        s[i][0]=x+y
        s[i][1]=x-y
    return s
aux=list(map(int,input().split()))
s=[]
for i in range(0,8,2):
    s.append([aux[i],aux[i+1]])
aux=list(map(int,input().split()))
s1=[]
for i in range(0,8,2):
    s1.append([aux[i],aux[i+1]])
st=set()
for i in s:
    st.add(i[1])
xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1]
for i in range(4):
    xma1=max(xma1,s[i][0])
    xma2=max(xma2,s1[i][0])
    xmi1=min(xmi1,s[i][0])
    xmi2=min(xmi2,s1[i][0])
    yma1=max(yma1,s[i][1])
    yma2=max(yma2,s1[i][1])
    ymi1=min(ymi1,s[i][1])
    ymi2=min(ymi2,s1[i][1])
c1=[(xma1+xmi1)/2,(yma1+ymi1)/2]
c2=[(xma2+xmi2)/2,(yma2+ymi2)/2]
t=False
if len(st)==2:
    t=True
if t:
    t1=inn1(s1)
    s=conv(s)
    s1=conv(s1)
    xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1]
    for i in range(4):
        xma1=max(xma1,s[i][0])
        xma2=max(xma2,s1[i][0])
        xmi1=min(xmi1,s[i][0])
        xmi2=min(xmi2,s1[i][0])
        yma1=max(yma1,s[i][1])
        yma2=max(yma2,s1[i][1])
        ymi1=min(ymi1,s[i][1])
        ymi2=min(ymi2,s1[i][1])
    c1=[(xma1+xmi1)/2,(yma1+ymi1)/2]
    c2=[(xma2+xmi2)/2,(yma2+ymi2)/2]
    t2=inn2(s)
else:
    t1=inn2(s)
    s=conv(s)
    s1=conv(s1)
    xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1]
    for i in range(4):
        xma1=max(xma1,s[i][0])
        xma2=max(xma2,s1[i][0])
        xmi1=min(xmi1,s[i][0])
        xmi2=min(xmi2,s1[i][0])
        yma1=max(yma1,s[i][1])
        yma2=max(yma2,s1[i][1])
        ymi1=min(ymi1,s[i][1])
        ymi2=min(ymi2,s1[i][1])
    c1=[(xma1+xmi1)/2,(yma1+ymi1)/2]
    c2=[(xma2+xmi2)/2,(yma2+ymi2)/2]
    t2=inn1(s1)

if t1 or t2:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def bfs():
            lookup = [False]*len(circles)
            q = []
            dst = [False]*len(circles)
            for u in range(len(circles)):
                x, y, r = circles[u]
                if x-r <= 0 or y+r >= Y:
                    lookup[u] = True
                    q.append(u)
                if x+r >= X or y-r <= 0:
                    dst[u] = True
            while q:
                new_q = []
                for u in q:
                    if dst[u]:
                        return True
                    x1, y1, r1 = circles[u]
                    for v in range(len(circles)):
                        x2, y2, r2 = circles[v]
                        if lookup[v] or not check(x1, y1, r1, x2, y2, r2):
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return False

        return not bfs()",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def minSwaps(self, nums):
        result = cnt = w = nums.count(1)
        for i in range(len(nums)+(w-1)):
            if i >= w:
                cnt += nums[(i-w)%len(nums)]
            cnt -= nums[i%len(nums)]
            result = min(result, cnt)
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: print(""? 0 0"", flush=True)
res = input()
i = 1
a = 0
b = 0
for i in range(29,-1,-1):
	print(""?"",(a^(1<<i)), b, flush=True)
	res1 = input()
	print(""?"",a, (b^(1<<i)), flush=True)
	res2 = input()
	if res1 == res2:
		if res == '1':
			a ^= (1<<i)
		else:
			b ^= (1<<i)
		res = res1
	elif res1 == '-1':
		a ^= (1<<i)
		b ^= (1<<i)
print(""!"", a, b, flush=True)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def wiggleMaxLength(self, nums):
        if len(nums) < 2:
            return len(nums)

        length, up = 1, None

        for i in range(1, len(nums)):
            if nums[i - 1] < nums[i] and (up is None or up is False):
                length += 1
                up = True
            elif nums[i - 1] > nums[i] and (up is None or up is True):
                length += 1
                up = False

        return length",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
L = []
for i in range(n):
    L.append(list(map(int, input().split()))+[i+1])

L.sort(key=lambda X:(X[0],-X[1],X[2]))

X = 0
for i in range(1,n):
    if L[i][1]<=L[i-1][1]:
        print(L[i][2],L[i-1][2])
        X = 1
        break
if X == 0:
    print(-1,-1)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def solve():
    n, k = [int(x) for x in input().split(' ')]
    a = [int(x) for x in input().split(' ')]
    a_pows = []
    a_pow_dict = [{} for u in range(11)]
    for j in range(n):
        x = a[j] % k
        i = 0
        while i < 11:
            if x in a_pow_dict[i]:
                a_pow_dict[i][x] += 1
            else:
                a_pow_dict[i][x] = 1
            i += 1
            x = (x * 10) % k

    c = 0

    for x in a:
        m = len(str(x))
        if (-x) % k in a_pow_dict[m]:
            c += a_pow_dict[m][(-x) % k]
            c -= int(int(str(x) * 2) % k == 0)

    return c

print(solve())",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def cic(my_string):
	my_hash=set();
	max_v=-1<<256;
	for i in range(len(my_string)):
		empty=my_string[i]+''
		if empty in my_hash:
			max_v=max(max_v,len(empty))
		else:
			my_hash.add(empty)
		for j in range(i+1,len(my_string)):
			empty+=my_string[j]
			if empty not in my_hash:
				my_hash.add(empty)
			else:
				max_v=max(max_v,len(empty))
	return 0 if max_v<0 else max_v

def main():
	my_string=input()
	print(cic(my_string))

if __name__=='__main__':
	main()
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
from array import array
from typing import List, Tuple, TypeVar, Generic, Sequence, Union

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def solve(i, n, delta, delta2):
    inf = 2 * 10**9
    dp = [[-1] * n for _ in range(1 << n)]
    dp[(1 << i)][i] = inf
    stack = [(1 << i, i)]

    for t in range(1, n + 1):
        next_s = []
        for bit, v in stack:
            for dest in range(n):
                if (1 << dest) & bit:
                    continue
                if dp[bit | (1 << dest)][dest] == -1:
                    next_s.append((bit | (1 << dest), dest))
                dp[bit | (1 << dest)][dest] = max(dp[bit | (1 << dest)][dest], min(dp[bit][v], delta[v][dest]))

        stack = next_s

    return max(min(delta2[j][i], dp[-1][j]) for j in range(n) if i != j)

def main():
    n, m = map(int, input().split())
    matrix = [tuple(map(int, input().split())) for _ in range(n)]

    if n == 1:
        print(min(abs(x - y) for x, y in zip(matrix[0], matrix[0][1:])))
        exit()

    delta = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(i + 1, n):
            delta[i][j] = delta[j][i] = min(abs(x - y) for x, y in zip(matrix[i], matrix[j]))
    delta2 = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            delta2[i][j] = min((abs(x - y) for x, y in zip(matrix[i], matrix[j][1:])), default=2 * 10**9)

    print(max(solve(i, n, delta, delta2) for i in range(n)))

if __name__ == '__main__':
    main()
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: l,r=map(int,input().split())
ls=str(bin(l))[2:]
rs=str(bin(r))[2:]
llog=len(ls)
rlog=len(rs)
ans=0
if llog<rlog:
    z=rlog-1
    while z>-1:
        ans+=2**z
        z-=1
else:
    ct=0
    stringa=""""
    for i in range(len(ls)):
        if ls[i]==rs[i] and ct==0:
            stringa+=ls[i]
        if ls[i]==""0"" and rs[i]==""1"":
            ct+=1
            stringa+=ls[i]
        if ls[i]==""1"" and rs[i]==""0"":
            stringa+=ls[i]
        if ls[i]==rs[i] and ct>0:
            stringa+=str((int(rs[i])+1)%2)
    ans=(int(stringa,2)^r)
print(ans)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from math import gcd

n = int(input())
d = dict()
qs = []
for i in range(n):
    s = input()
    a = int(s[1:s.index('+')])
    b = int(s[s.index('+') + 1: s.index(')')])
    c = int(s[s.index(')') + 2:])
    a = a + b
    gc = gcd(a, c)
    res = (a // gc, c // gc)
    qs.append(res)
    if res in d:
        d[res] += 1
    else:
        d[res] = 1
for q in qs:
    print(d[q], end=' ')
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import random


class Solution(object):

    def __init__(self, nums):
        self.__nums = nums


    def reset(self):
        return self.__nums


    def shuffle(self):
        nums = list(self.__nums)
        for i in range(len(nums)):
            j = random.randint(i, len(nums)-1)
            nums[i], nums[j] = nums[j], nums[i]
        return nums",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = map(int, input().split())
a = list(map(int, input().split()))
diff = []
if n == 1:
    print(0)
else:
    for i in range(n-1):
        diff.append(a[i+1]-a[i])

    diff.sort(reverse = True)
    ans = a[-1] - a[0]
    for i in range(min(k-1, len(diff))):
        ans -= diff[i]

    print(ans)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys,math
input = sys.stdin.readline

out = []

t = int(input())
for _ in range(t):
    n = int(input())

    o1 = math.isqrt(n//2)
    o2 = math.isqrt(n//4)

    if 2 * o1 * o1 == n or 4 * o2 * o2 == n:
        out.append('YES')
    else:
        out.append('NO')
print('\n'.join(out))
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import Counter
import string
import math
import sys

from fractions import Fraction
def array_int():
    return [int(i) for i in sys.stdin.readline().split()]
def vary(arrber_of_variables):
    if arrber_of_variables==1:
        return int(sys.stdin.readline())
    if arrber_of_variables>=2:
        return map(int,sys.stdin.readline().split())
def makedict(var):
    return dict(Counter(var))
testcases=1
for _ in range(testcases):
    n,k=vary(2)
    num=array_int()
    maxi=0.0
    for i in range(n):
        count=1
        sumt=num[i]

        for j in range(i+1,n):
            sumt+=num[j]
            count+=1
            if count>=k:

                maxi=max(maxi,sumt/count)

    if k==1:
        print(max(maxi,max(num)))
    else:
        print(maxi)
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def continuousSubarrays(self, nums):
        result = left = 0
        mn, mx = float(""inf""), float(""-inf"")
        for right in range(len(nums)):
            if mn <= nums[right] <= mx:
                mn, mx = max(mn, nums[right]-2), min(mx, nums[right]+2)
            else:
                mn, mx = nums[right]-2, nums[right]+2
                for left in reversed(range(right)):
                    if not mn <= nums[left] <= mx:
                        break
                    mn, mx = max(mn, nums[left]-2), min(mx, nums[left]+2)
                else:
                    left = -1
                left += 1
            result += right-left+1
        return result
import collections",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from math import ceil
n, k = map(int, input().split())
print(ceil(n*2/k) + ceil(n*5/k) + ceil(n*8/k))",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def countSteppingNumbers(self, low, high):
        MOD = 10**9+7
        def f(s):
            dp = [[0]*10 for _ in range(2)]
            for j in range(1, ord(s[0])-ord('0')+1):
                dp[0][j] = 1
            prefix = True
            for i in range(1, len(s)):
                for j in range(10):
                    dp[i%2][j] = int(j != 0)
                    if j-1 >= 0:
                        dp[i%2][j] = (dp[i%2][j]+(dp[(i-1)%2][j-1]-int(prefix and (ord(s[i-1])-ord('0')) == j-1 and j > (ord(s[i])-ord('0')))))%MOD
                    if j+1 < 10:
                        dp[i%2][j] = (dp[i%2][j]+(dp[(i-1)%2][j+1]-int(prefix and (ord(s[i-1])-ord('0')) == j+1 and j > (ord(s[i])-ord('0')))))%MOD
                if abs(ord(s[i])-ord(s[i-1])) != 1:
                    prefix = False
            return reduce(lambda x, y: (x+y)%MOD, dp[(len(s)-1)%2])

        return (f(high)-f(str(int(low)-1)))%MOD",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input(""""))
if n==1 or n==2:
    print(n)
elif n&1:
    print((n)*(n-1)*(n-2))
else:
    if n%3==0:
        print((n-2)*(n-1)*(n-3))
    else :
         print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3),(n*(n-1)*(n-2))/2))",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def findMinimumTime(self, strength, K):
        def hungarian(a): 
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in range(1, n):
                p[0] = i
                j0 = 0 
                dist, pre = [float(""inf"")]*m, [-1]*m
                done = [False]*(m+1)
                while True: 
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float(""inf"")
                    for j in range(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur < dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] < delta:
                            delta, j1 = dist[j], j
                    for j in range(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0: 
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in range(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans 

        def ceil_divide(a, b):
            return (a+b-1)//b
    
        adj = [[ceil_divide(strength[i], 1+j*K) for j in range(len(strength))] for i in range(len(strength))]
        return hungarian(adj)[0]",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def pow(x, p):
    ret = 1
    for i in range(p): ret=ret*x
    return ret

def rate(p):
    ret = 0
    now = 1
    for i in range(p):
        ret = ret + now
        now = now * 4
    return ret

def solve():
    n, k = map(int, input().split())
    if (n>35):
        print(""YES %d"" % (n-1))
        return
    mSplit = 1
    cnt1 = 0
    cnt3 = 1
    for i in range(1, n+1):
        now = pow(4, i) - pow(2, i+1) + 1
        now = now * rate(n-i) + rate(i)

        if (k<=now):
            print(""YES %d"" % (n-i))
            return
        mSplit = mSplit + cnt1 + cnt3 * 3
        cnt1 = cnt1 + cnt3
        cnt3 = cnt3 + cnt3
        if (mSplit>k): break
    print(""NO"")

def main():
    T = int(input())
    for i in range(T):
        solve()

if __name__ == ""__main__"":
    main()
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
l=list(map(int,input().split()))
l.sort()
vis=[0]*n
ans=0
for i in range(n):
    if(vis[i]==0):
        ans+=1
        x=l[i]
        for j in range(n):
            if l[j]%x==0:
                vis[j]=1
print(ans)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def suma(n):
    return n*(n+1)//2

def sumaij(i, j):
    if i <= 1:
        return suma(j)
    return suma(j) - suma(i-1)

def bin_search_solution(n, k):
    st, end = 1, k
    while st < end:
        mid = (st+end)//2
        s = sumaij(mid, k)
        if s == n:
            return k - mid + 1
        if s > n:
            st = mid + 1
        else:
            end = mid
    return k - st + 2

def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    elif k >= n:
        print(1)
    else:
        n -= 1
        k -= 1

        if suma(k) < n:
            print(-1)
        else:
            res = bin_search_solution(n, k)
            print(res)

if __name__ == '__main__':
    solve()
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: t = int(input())
for _ in range(t):
    n = int(input())
    a = sorted(map(int, input().split()), reverse=True)
    print(min(n - 2, a[1] - 1))
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,a,b=list(map(int,input().split()))
d=[]
for i in range(n):
    d.append([""1""]*n)
    d[i][i]=""0""
if [n,a,b]==[2,1,1]:
    print(""NO"")
elif [n,a,b]==[3,1,1]:
    print(""NO"")
elif a==1:
    c=n-b
    for i in range(c):
        d[i][i+1]=""0""
        d[i+1][i]=""0""
    print(""YES"")
    for i in range(n):
        print("""".join(d[i]))
elif a!=1 and b!=1:
    print(""NO"")
else:
    print(""YES"")
    for i in range(a-1):
        for j in range(n):
            d[i][j]=""0""
        for j in range(n):
            d[j][i]=""0""
    for i in range(n):
        print("""".join(d[i]))",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())

x, y = map(int, input().split())

ans = (x - 1) + (y - 1) <= (n - x) + (n - y)
print('White' if ans else 'Black')
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: f=input
D,E=dict(),[eval(f())for i in range(int(f()))]
for e in E:D[e]=D.get(e,0)+1
for e in E:print(D[e])",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def solve():
  r, g, b = map(int, input().split());R,G,B = sorted(list(map(int, input().split()))),sorted(list(map(int, input().split()))),sorted(list(map(int, input().split())));dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
  for i in range(r+1):
    for j in range(g+1):
      for k in range(b+1):
        if i+j+k<2:continue
        if i>0 and j>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
        if i>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
        if j>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
  return dp[r][g][b]
print(solve())",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def rotate(L):
    L1 = ['' for i in range(n)]
    for i in range(n):
        for j in range(n):
            L1[n - j - 1] += L[i][j]
    return L1

def flip_v(L):
    L1 = []
    for i in range(n):
        L1.append(L[i][::-1])
    return L1

def flip_h(L):
    L1 = []
    for i in range(n):
        L1.append(L[n - i - 1])
    return L1

n = int(input())
L = []
M = []
for i in range(n):
    L.append(input())
for i in range(n):
    M.append(input())
L1 = rotate(L)
L2 = rotate(L1)
L3 = rotate(L2)
L4 = flip_v(L)
L5 = flip_h(L)
L6 = rotate(L4)
L7 = rotate(L6)
L8 = rotate(L7)
L9 = rotate(L5)
L10 = rotate(L9)
L11 = rotate(L10)
if L == M or L1 == M or L2 == M or L3 == M or L4 == M or L5 == M or L6 == M or L7 == M or L8 == M or L9 == M or L10 == M or L11 == M:
    print('Yes')
else:
    print('No')",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: M = {}

N = int(input())
S = input().strip()

s = set()
for c in S:
    s.add(c)
    M[c] = 0

i = 0; j = -1; aux = 0; ans = 1e10
while j < N - 1:
    j += 1

    M[S[j]] += 1
    if M[S[j]] == 1:
        aux += 1
    while M[S[i]] > 1:
        M[S[i]] -= 1
        i += 1

    if aux == len(s):
        ans = min(ans, j - i + 1)

print(ans)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
t = list(map(int, input().split()))

sw = 0

while t != []:
	pr = 1 + t[1:].index(t[0])

	sw += pr-1

	t = t[1:pr] + t[pr+1:]

print(sw)
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: x, k= [int(x) for x in raw_input().split()]

MOD = 10 ** 9 + 7

def modulus(a, b, m):

    if b == 0:
        return 1
    if b == 1:
        return a % m

    result = int(modulus(a, b // 2, m))

    if b % 2 == 0:
        return  int (( (result % m) * (result % m) ) % m)
    else:
        return int (( (result % m) * (result % m) * (a % m)) % m)

def pow_mod(x, y, z):
    ""Calculate (x ** y) % z efficiently.""
    number = 1
    while y:
        if y & 1:
            number = number * x % z
        y >>= 1
        x = x * x % z
    return number
if x == 0:
    print(0)
elif k != 0:
    print( int( ( (modulus(2, k + 1, MOD) * (x % MOD) ) % MOD - (modulus(2, k, MOD)) % MOD + 1 + MOD) % MOD ))
else:
    print(int((x % MOD) * 2 % MOD) )",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def nextLargerNodes(self, head):
        result, stk = [], []
        while head:
            while stk and stk[-1][1] < head.val:
                result[stk.pop()[0]] = head.val
            stk.append([len(result), head.val])
            result.append(0)
            head = head.__next__
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: N, T = map(int, input().split())

def read_houses():
  for _ in range(N):
    yield tuple(map(int, input().split()))

houses = list(read_houses())

houses.sort()

count = 2

for (a, x), (b, y) in zip(houses, houses[1:]):
  if b-a - (x/2+y/2) > T:
    count += 2
  if b-a - (x/2+y/2) == T:
    count += 1

print(count)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def largestRectangleArea(self, heights):
        stk, result = [-1], 0
        for i in range(len(heights)+1):
            while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):
                result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))
            stk.append(i) 
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def gns():
    return  list(map(int,input().split()))
n=int(input())
ns=gns()
a='cslnb'
b='sjfnb'
ns.sort()
ans=[]
for i in range(1,n):
    if ns[i]==ns[i-1]:
        ans.append(i)
if len(ans)>=2 or sum(ns)==0:
    print(a)
    quit()
if len(ans)==1:
    i=ans[0]
    if ns[i]==0 or ns[i]-1 in ns:
        print(a)
        quit()
    r=sum(ns)-n*(n-1)//2
    if r%2==0:
        print(a)
        quit()
    else:
        print(b)
        quit()
else:
    r=sum(ns)-n*(n-1)//2
    if r%2==0:
        print(a)
        quit()
    else:
        print(b)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
Ab = input().split()
Un = []
Al = [0]
r = 0
for i in range(n):
    Ab[i] = int(Ab[i])
    Al.append(max(Ab[i]+1,Al[i]))
for i in range(n,-1,-1):
    if Al[i-1] < Al[i] - 1:
        Al[i-1] = Al[i] - 1
for i in range(n):
    Un.append(Al[i+1]-Ab[i]-1)
    r += Un[-1]
print(r)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
ans = 0
for i in range(2, n + 1):
    for j in range(i + i, n + 1, i):
        ans += 4 * j // i
print(ans)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maxNumOfMarkedIndices(self, nums):
        nums.sort()
        left = 0
        for right in range((len(nums)+1)//2, len(nums)):
            if nums[right] >= 2*nums[left]:
                left += 1
        return left*2",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

def main():
	n, m = mints()
	res = []
	a = [None]*n
	l = [None]*n
	r = [None]*n
	s = [0]*n
	for i in range(n):
		a[i] = list(minp())
		l[i] = [i for i in range(m)]
		r[i] = [i for i in range(m)]
		s[i] = [0]*m
	for i in range(n):
		j = 0
		b = a[i]
		ll = l[i]
		rr = r[i]
		while j < m:
			if b[j] == '*':
				jj = j+1
				while jj < m and b[jj] == '*':
					jj += 1
				jj -= 1
				for k in range(j,jj+1):
					ll[k] = j
					rr[k] = jj
				j = jj + 1
			else:
				j += 1
	for i in range(m):
		j = 0
		while j < n:
			if a[j][i] == '*':
				jj = j+1
				while jj < n and a[jj][i] == '*':
					jj += 1
				jj -= 1
				for k in range(j,jj+1):
					x = min(i-l[k][i],r[k][i]-i,k-j,jj-k)
					s[k][i] = x
					if x > 0:
						res.append((k+1,i+1,x))
				j = jj + 1
			else:
				j += 1
	for i in range(n):
		j = 0
		ss = s[i]
		rr = r[i]
		c = -1
		while j < m:
			if ss[j] > 0 and c < ss[j]:
				c = ss[j]
			if c >= 0:
				rr[j] = '*'
			else:
				rr[j] = '.'
			j += 1
			c -= 1
		j = m-1
		c = -1
		while j >=0:
			if ss[j] > 0 and c < ss[j]:
				c = ss[j]
			if c >= 0:
				rr[j] = '*'
			c -= 1
			j -= 1
	for i in range(m):
		j = 0
		c = -1
		while j < n:
			x = s[j][i]
			if x > 0 and c < x:
				c = x
			if c >= 0:
				r[j][i] = '*'
			j += 1
			c -= 1
		j = n-1
		c = -1
		while j >=0:
			x = s[j][i]
			if x > 0 and c < x:
				c = x
			if c >= 0:
				r[j][i] = '*'
			if r[j][i] != a[j][i]:
				print(-1)
				exit(0)
			c -= 1
			j -= 1
	print(len(res))
	for i in res:
		print(*i)
main()",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections



class Point(object):
    def __init__(self, a=0, b=0):
        self.x = a
        self.y = b

class Solution(object):
    def maxPoints(self, points):
        max_points = 0
        for i, start in enumerate(points):
            slope_count, same = collections.defaultdict(int), 1
            for j in range(i + 1, len(points)):
                end = points[j]
                if start.x == end.x and start.y == end.y:
                    same += 1
                else:
                    slope = float(""inf"")
                    if start.x - end.x != 0:
                        slope = (start.y - end.y) * 1.0 / (start.x - end.x)
                    slope_count[slope] += 1

            current_max = same
            for slope in slope_count:
                current_max = max(current_max, slope_count[slope] + same)

            max_points = max(max_points, current_max)

        return max_points",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import defaultdict

mod_v = 1000000007

temp_arr = [[1]]
for i in range(1,1010):
    a = [1]
    for k in range(1,i):
        a.append((temp_arr[i-1][k-1]+temp_arr[i-1][k]) % mod_v)
    a.append(1)
    temp_arr.append(a)

ans_arr = [1]
for i in range(1,1010):
    res = 0
    for j in range(i):
        res += ans_arr[j] * temp_arr[i-1][j]
        res %= mod_v
    ans_arr.append(res)

n_list=list(map(int, input().split()))

n = n_list[0]
lines = n_list[1]

new_list = [0 for __ in range(n)]

for i in range(lines):
    input1 = list(map(int, input()))
    for k in range(n):
        new_list[k] |= input1[k] << i

default_d = defaultdict(int)
for k in new_list:
    default_d[k] += 1

answer = 1
for n in default_d.values():
    answer = answer * ans_arr[n] % mod_v

print(answer)
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math
x, k = list(map(int, input().split()))
mod = 10**9 + 7
print((pow(2, k+1, mod)*x - pow(2, k, mod) + 1) % mod if x > 0 else 0)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
arr = list(map(int, input().split()))
ab = sorted(arr)
t = [i for i in range(n) if arr[i] != ab[i]]
if len(t) < 3:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections



class Solution(object):
    def countAnagrams(self, s):
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in range(3)]
        def lazy_init(n):
            while len(inv) <= n: 
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) 
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)

        def factorial(n):
            lazy_init(n)
            return fact[n]

        def inv_factorial(n):
            lazy_init(n)
            return inv_fact[n]

        def count(j, i):
            result = 1
            cnt = collections.Counter()
            for k in  range(j, i+1):
                cnt[s[k]] += 1
            result = factorial(sum(cnt.values()))
            for c in cnt.values():
                result = (result*inv_factorial(c))%MOD
            return result

        result = 1
        j = 0
        for i in range(len(s)):
            if i+1 != len(s) and s[i+1] != ' ':
                continue
            result = (result*count(j, i))%MOD
            j = i+2
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def gcd(a,b):
    if b==0:
        return a
    else:
        return gcd(b,a%b)

if __name__ == ""__main__"":
    n = int(input())
    ans = 0
    if n==1:
        ans = 1
    elif n==2:
        ans = 2
    else:
        if n%2!=0:
            ans = n*(n-1)*(n-2)
        else:
            if gcd(n,(n-3)) ==1:
                ans = n*(n-1)*(n-3)
            else:
                ans = (n-1)*(n-2)*(n-3)
    print(ans)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin,stdout,setrecursionlimit
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush,nlargest
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm , accumulate
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
setrecursionlimit(10**9)
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return input()
def num():return int(input())
def L(): return list(sp())
def LF(): return list(spf())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def spf(): return map(int, input.readline().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")
def pmat2(A):
    for ele in A:
        for j in ele:
            print(j,end='')
        print()
def iseven(n):
    return n%2==0

def seive(r):
    prime=[1 for i in range(r+1)]
    prime[0]=0
    prime[1]=0
    for i in range(r+1):
        if(prime[i]):
            for j in range(2*i,r+1,i):
                prime[j]=0
    return prime

n = int(input())
s = list(input())
t = list(input())
ans = []
for i in range(n):
    for j in range(i,n):
        if s[j] == t[i]:
            for k in range(j, i, -1):
                s[k], s[k-1] = s[k-1], s[k]
                ans.append(k)
            break
if s==t:
    print(len(ans))
    print(' '.join(map(str, ans)))
else:
    print(-1)

endtime = time.time()
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def getBW(x1, y1, x2, y2):
    if (x2 - x1) % 2 == 1 or (y2 - y1) % 2 == 1:
        return [(y2 + 1 - y1) * (x2 + 1 - x1) // 2, (y2 + 1 - y1) * (x2 + 1 - x1) // 2]
    else:
        if (x1 % 2 == 0 and y1 % 2 == 0) or (x1 % 2 == 1 and y1 % 2 == 1):
            return [(y2 + 1 - y1) * (x2 + 1 - x1) // 2, 1 + (y2 + 1 - y1) * (x2 + 1 - x1) // 2]
        else:
            return [1 + (y2 + 1 - y1) * (x2 + 1 - x1) // 2, (y2 + 1 - y1) * (x2 + 1 - x1) // 2]

cs = int(input())

for c in range(cs):
    m, n = map(int, input().split())
    BW = getBW(1, 1, n, m)
    x1, y1, x2, y2 = map(int, input().split())

    x3, y3, x4, y4 = map(int, input().split())

    BW1 = getBW(x1, y1, x2, y2)
    BW2 = getBW(x3, y3, x4, y4)
    BWO =[0, 0]

    xo1 = max(x1, x3)
    xo2 = min(x2, x4)
    yo1 = max(y1, y3)
    yo2 = min(y2, y4)
    if (xo2 >= xo1 and yo2 >= yo1):
        BWO = getBW(xo1, yo1, xo2, yo2)

    B = BW[0] - BW1[0] + BW2[1] + BWO[0]
    W = BW[1] + BW1[0] - BW2[1] - BWO[0]

    print(W, end = "" "")
    print(B)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def getWordsInLongestSubsequence(self, n, words, groups):
        return [words[i] for i in range(n) if i == 0 or groups[i-1] != groups[i]]",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        one = 1
        i = 0
        digits = digits[::-1]

        while one:
            if i < len(digits):
                if digits[i] == 9:
                    digits[i] = 0
                else:
                    digits[i] += 1
                    one = 0
            else:
                digits.append(one)
                one = 0
            i += 1
        return digits[::-1]
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l, r = 0, len(numbers) - 1

        while l < r:
            curSum = numbers[l] + numbers[r]

            if curSum > target:
                r -= 1
            elif curSum < target:
                l += 1
            else:
                return [l + 1, r + 1]
        return []
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: l, r = map(int, input().split())

ans = 0
for i in range(63, -1, -1):
    if r & (1 << i) > 0 and l & (1 << i) == 0:
        ans = (1 << (i + 1)) - 1
        break
print(ans)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def divisorSubstrings(self, num, k):
        result = curr = 0
        s = list(map(int, str(num)))
        base = 10**(k-1)
        for i, x in enumerate(s):
            if i-k >= 0:
                curr -= s[i-k]*base
            curr = curr*10+x
            if i+1 >= k:
                result += int(curr and num%curr == 0)
        return result",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = list(map(int, input().strip().split()))
arr = list(map(int, input().strip().split()))
k -= 1
arr_new = sorted([arr[i+1]-arr[i] for i in range(n-1)], reverse=True)
print(arr[-1]-arr[0]-sum(arr_new[:k]))
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,k = [int(x) for x in input().split()]
dp = [[[0 for _ in range(4)] for _ in range(k+2)] for _ in range(2)]
dp[1][2][0] = 1
dp[1][2][1] = 1
dp[1][1][2] = 1
dp[1][1][3] = 1

for n1 in range(1,n):
    for k1 in range(1,k+1):

        dp[0][k1][0] = dp[1][k1][0]
        dp[0][k1][1] = dp[1][k1][1]
        dp[0][k1][2] = dp[1][k1][2]
        dp[0][k1][3] = dp[1][k1][3]

        dp[1][k1][0] = (dp[0][k1][0] + (dp[0][k1-2][1] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353

        dp[1][k1][1] = (dp[0][k1][1] + (dp[0][k1-2][0] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353

        dp[1][k1][2] = (dp[0][k1][2] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][3])% 998244353

        dp[1][k1][3] = (dp[0][k1][3] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][2])% 998244353
total = 0

for i in range(4):
    total += dp[1][k][i] % 998244353

print(total% 998244353 )
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
arr = list(map(int, input().split()))

for i in range(n):
    arr[i] = (arr[i]-i)//n + (1 if (arr[i]-i)%n>0 else 0)
print(arr.index(min(arr))+1)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin
import time

r,g,b = map(int,stdin.readline().split())

red = list(map(int,stdin.readline().split()))
green = list(map(int,stdin.readline().split()))
blue = list(map(int,stdin.readline().split()))
red.sort()
green.sort()
blue.sort()

dp = [[[0 for _ in range(b+1)] for _ in range(g+1)] for _ in range(r+1)]

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i>0 and j>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+red[i-1]*green[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+red[i-1]*blue[k-1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+green[j-1]*blue[k-1])

print(dp[-1][-1][-1])
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import defaultdict as dd, deque
n = int(input())
A = [int(x) for x in input().split()]
n = len(A)

C = dd(int)
for a in A:
    C[a] += 1

thedup = None
ndup = 0
screwed = False
for c in C:
    if C[c] > 2:
        screwed = True
    elif C[c] == 2:
        if c == 0:
            screwed = True
        thedup = c
        ndup += 1

import sys
if screwed or ndup > 1:
    print('cslnb')
else:
    if ndup == 1:
        if C[thedup-1] != 0:
            print('cslnb')
            sys.exit()

    target = sum(range(n))
    cur = sum(A)
    togo = cur - target

    if togo%2 == 0:
        print('cslnb')
    else:
        print('sjfnb')
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,s=map(int,input().split())
mins=s
my_dict={}
mylist=[]
while(n):
	person,floor=map(int,input().split())
	mylist.append(person+floor)
	n-=1
val=max(mylist)
if(val<mins):
	print(mins)
else:
	print(val)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def PredictTheWinner(self, nums):
        if len(nums) % 2 == 0 or len(nums) == 1:
            return True

        dp = [0] * len(nums)
        for i in reversed(range(len(nums))):
            dp[i] = nums[i]
            for j in range(i+1, len(nums)):
                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1])

        return dp[-1] >= 0",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
n = n + n//2

print(n)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: DR = [1,0,-1,0]
DC = [0,1,0,-1]

n, m, k = map(int, input().split())
w = [[[0] * m for _ in range(n)] for _ in range(4)]
for r in range(n):
    for c, e in enumerate(map(int, input().split())):
        w[1][r][c] = w[3][r][c + 1] = e
for r in range(n - 1):
    for c, e in enumerate(map(int, input().split())):
        w[0][r][c] = w[2][r + 1][c] = e

INF = 10 ** 9

def solve():
    global k
    global w
    if k % 2 == 1:
        return [[-1] * m] * n
    k //= 2
    best = [[[0] * m for _ in range(n)] for _ in range(k + 1)]
    for steps in range(1, k + 1):
        for r in range(n):
            for c in range(m):
                best[steps][r][c] = INF
                for d in range(4):
                    r2, c2 = r + DR[d], c + DC[d]
                    if 0 <= r2 < n and 0 <= c2 < m:
                        best[steps][r][c] = min(best[steps][r][c], 2 * w[d][r][c] + best[steps - 1][r2][c2])
    return best[k]

res = solve()
for e in res:
    print(*e)",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from random import randint

class Solution(object):

    def __init__(self):
        self.__set = []
        self.__used = {}


    def insert(self, val):
        if val in self.__used:
            return False

        self.__set += val,
        self.__used[val] = len(self.__set)-1

        return True


    def remove(self, val):
        if val not in self.__used:
            return False

        self.__used[self.__set[-1]] = self.__used[val]
        self.__set[self.__used[val]], self.__set[-1] = self.__set[-1], self.__set[self.__used[val]]

        self.__used.pop(val)
        self.__set.pop()

        return True

    def getRandom(self):
        return self.__set[randint(0, len(self.__set)-1)]",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
a = list(map(int, input().split()))
res = []
if n == 1:
    print(1)
    exit(0)

i = 0
if a[0] < a[1]:

    if i >= n - 2:
        res = [1]
        cur = 2
    else:
        if a[i + 1] < a[i + 2]:
            res = [1]
            cur = 2
        elif a[i + 1] > a[i + 2]:
            res = [1]
            cur = 5
        else:
            res = [1]
            cur = 2

elif a[0] > a[1]:

    if i >= n - 2:
        res = [5]
        cur = 4
    else:
        if a[i + 1] < a[i + 2]:
            res = [5]
            cur = 1
        elif a[i + 1] > a[i + 2]:
            res = [5]
            cur = 4
        else:
            res = [5]
            cur = 4

else:
    if i >= n - 2:
        res.append(1)
        cur = 2
    else:
        if a[i + 1] < a[i + 2]:
            res.append(2)
            cur = 1
        elif a[i + 1] > a[i + 2]:
            res.append(4)
            cur = 5
        else:
            res.append(2)
            cur = 3

for i in range(1, n - 1):
    if not (1 <= cur <= 5):
        print(-1)
        exit(0)
    res.append(cur)
    if a[i] > a[i + 1]:

        if i >= n - 2:
            cur -= 1
        else:
            if a[i + 1] < a[i + 2]:
                cur = min(cur - 1, 1)
            elif a[i + 1] > a[i + 2]:
                cur -= 1
            else:
                cur -= 1

    elif a[i] < a[i + 1]:

        if i >= n - 2:
            cur += 1
        else:
            if a[i + 1] < a[i + 2]:
                cur += 1
            elif a[i + 1] > a[i + 2]:
                cur = max(cur + 1, 5)
            else:
                cur += 1
    else:
        if i >= n - 2:
            if cur != 3:
                cur = 3
            else:
                cur = 2
        else:
            if a[i + 1] < a[i + 2]:
                if cur == 1:
                    cur = 2
                else:
                    cur = 1
            elif a[i + 1] > a[i + 2]:
                if cur == 5:
                    cur = 4
                else:
                    cur = 5
            else:
                if cur != 3:
                    cur = 3
                else:
                    cur = 2
if not (1 <= cur <= 5):
    print(-1)
    exit(0)
res.append(cur)
print(*res)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
def fastio():
    from io import StringIO
    from atexit import register
    global input
    sys.stdin = StringIO(sys.stdin.read())
    input = lambda : sys.stdin.readline().rstrip('\r\n')
    sys.stdout = StringIO()
    register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))
fastio()

def debug(*var, sep = ' ', end = '\n'):
    print(*var, file=sys.stderr, end = end, sep = sep)

INF = 10**20
MOD = 10**9 + 7
I = lambda:list(map(int,input().split()))
from math import gcd
from math import ceil
from collections import defaultdict as dd, Counter
from bisect import bisect_left as bl, bisect_right as br

n, l, r, x = I()
a = I()
ans = 0
for i in range(1, 2 ** n):
    if i & (i - 1) == 0:
        continue
    mn, mx, total = INF, -INF, 0
    for j in range(n):
        if (i >> j) & 1:
            mn = min(mn, a[j])
            mx = max(mx, a[j])
            total += a[j]
    if l <= total <= r and mx - mn >= x:
        ans += 1
print(ans)",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def minimizeResult(self, expression):
        best = None
        min_val = float(""inf"")
        pos = expression.index('+')
        left, right = int(expression[0:pos]), int(expression[pos+1:]) 
        base1, base2_init = 10**pos, 10**(len(expression)-(pos+1)-1)
        for i in range(pos):
            base2 = base2_init
            for j in range(pos+1, len(expression)):
                a, b = divmod(left, base1)
                c, d = divmod(right, base2)
                val = max(a, 1)*(b+c)*max(d, 1)
                if val < min_val:
                    min_val = val
                    best = (i, j)
                base2 //= 10
            base1 //= 10
        return """".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]])",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,m = map(int,input().split())
x = [0]*(n+1)
for i in range(n):
    x[i] = int(input())
x[n] = 1000000000
vert = []
for i in range(m):
    x1,x2,y = map(int,input().split())
    if x1 == 1:
        vert.append(x2)
vert.sort()
x.sort()
cur = 0
minicount = n+m
k = len(vert)
for i in range(n+1):
    while cur < k:
        if x[i] <= vert[cur]:
            break
        cur += 1
    minicount = min(minicount,k-cur+i)
print(minicount)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k=[int(v) for v in input().split()]
if n==1:
    print(0)
elif n-1>(1+k-1)*(k-1)//2:
    print(-1)
else:
    n-=1
    k-=1
    l, r=0, k+1
    while r-l>1:
        m=(l+r)//2
        if (m+k)*(k-m+1)//2>=n:
            l=m
        else:
            r=m
    print(k-l+1)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def main():
    n, m = map(int, input().split())
    a = []
    for i in range(n):
        a.append(input())
    ans = ""NO""
    count = [0] * m
    for i in range(n):
        for j in range(m):
            if (a[i][j] == '1'):
                count[j] += 1
    for i in range(n):
        ans = ""YES""
        for j in range(m):
            if (count[j] == 1 and a[i][j] == '1'):
                ans = ""NO""
                break
        if (ans == ""YES""):
            break
    print(ans)
main()",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def minDepth(self, root):
        if root is None:
            return 0

        if root.left and root.right:
            return min(self.minDepth(root.left), self.minDepth(root.right)) + 1
        else:
            return max(self.minDepth(root.left), self.minDepth(root.right)) + 1",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

r,g,b = map(int,input().split())
l1 = list(map(int,input().split()))
l2 = list(map(int,input().split()))
l3 = list(map(int,input().split()))
l1.sort(reverse=True)
l2.sort(reverse=True)
l3.sort(reverse=True)
dp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]
ans = 0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i == 0 and j == 0:
                dp[i][j][k] = 0
            if j == 0 and k == 0:
                dp[i][j][k] = 0
            if i == 0 and k == 0:
                dp[i][j][k] = 0
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])
            else:
                if i>0 and j>0:
                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]
                elif i>0 and k>0:
                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]
                elif j>0 and k>0:
                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]
            ans = max(ans,dp[i][j][k])

print(ans)
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maximumSubsequenceCount(self, text, pattern):
        result = cnt1 = cnt2 = 0
        for c in text:
            if c == pattern[1]:
                result += cnt1
                cnt2 += 1
            if c == pattern[0]:
                cnt1 += 1
        return result + max(cnt1, cnt2)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
l=sorted(list(map(int,raw_input().split())))
def f():
    global n
    dou=False
    for k in range(1,n):
        if l[k]==l[k-1]:
            if dou or l[k]==0 or (l[k]==l[k-2] and n!=2) or l[k]==l[k-2]+1:
                return False
            else:
                dou=True
    return (sum(l)-(n*(n-1))//2)%2
if f():
    print(""sjfnb"")
else:
    print(""cslnb"")
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, m = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))
Sum = 0
for j in range(n):
    Sum+=b[j]*m
b.sort()
for i in range(m):
    Sum+=max(0, g[i]-b[-1])
if min(g)<max(b): print(-1)
elif min(g)==max(b): print(Sum)
else: Sum+=b[-1]-b[-2]; print(Sum)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from math import log
from collections import deque
n,k=map(int,input().split())
s=list(map(int,input().split()))
ans=0
s.sort()
s1=deque(s)
for j in range(11):
    d=dict()
    z=10**j
    for i in s:
        y=i*z
        u=y%k
        if u in d:
            d[u]+=1
        else:
            d.update({u:1})
    aux=0
    for i in s1:
        y=i
        lg=int(log(i,10))+1
        lg=10**lg
        if lg==z:
            d[(y*z)%k]-=1
            x=(k-y%k)
            if y%k==0:
                x=0
            if x in d:
                ans+=d[x]
            d[(y*z)%k]+=1
            aux+=1
        else:
            break
    for i in range(aux):
        s1.popleft()

print(ans)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: for ctr in range(1):
    s=input().strip()
    for l in range(len(s),0,-1):
        k=[]
        for i in range(0,len(s)-l+1):
            k.append(s[i:i+l])
        if len(k)!=len(list(set(k))):
            print(l)
            exit()
    print(0)
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: x, y, z, t1, t2, t3 = map(int, input().split())
stair = t1 * abs(x - y)
lift = t2 * (abs(z - x) + abs(x - y)) + t3 * 3
print(""YES"" if lift <= stair else ""NO"")
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math
k,n,s,p=[int(x) for x in input().split()]
x=math.ceil(n/s)
y=math.ceil(x*k/p)
print(y)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from heapq import heappush, heappop


class Solution3(object):
    def minMeetingRooms(self, intervals):
        if not intervals:
            return 0
        
        intervals.sort(key=lambda x: x[0])
        free_rooms = []
        
        heappush(free_rooms, intervals[0][1])
        for interval in intervals[1:]:
            if free_rooms[0] <= interval[0]:
                heappop(free_rooms)
            
            heappush(free_rooms, interval[1])
        
        return len(free_rooms)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: left, right = [int(x) for x in input().split(' ')]

if left == right:
    print(0)
else:
    x = 1
    while x <= right:
        x *= 2
    x //= 2
    y = x
    while y > 0 and x <= left or x > right:
        if x <= left:
            x += y
        else:
            x -= y
        y //= 2
    print(x^(x-1))
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: S = [str(input()) for i in range(2)]
S[0] = S[0].replace('X','1')
S[1] = S[1].replace('X','1')

n = len(S[0])
if n == 1:
    print(0)
    exit()

INF = 10**18
from collections import defaultdict
dp = defaultdict(lambda: -INF)
for i in range(0, 2):
    for j in range(0, 2):
        dp[(i, j)] = -INF
dp[(int(S[0][0]), int(S[1][0]))] = 0

for i in range(1, n):
    nx = defaultdict(lambda: -INF)
    for j in range(0, 2):
        for k in range(0, 2):
            nx[(int(S[0][i]), int(S[1][i]))] = max(nx[(int(S[0][i]), int(S[1][i]))], dp[(j, k)])
    for j in range(0, 2):
        for k in range(0, 2):
            if dp[(j, k)] == -INF:
                continue
            if j == 0 and k == 0:
                if S[0][i] == '1' and S[1][i] != '1':
                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)
                if S[0][i] != '1' and S[1][i] == '1':
                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)
                if S[0][i] != '1' and S[1][i] != '1':
                    nx[(1, 0)] = max(nx[(1, 0)], dp[(j, k)]+1)
                    nx[(0, 1)] = max(nx[(0, 1)], dp[(j, k)]+1)
                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)
            if j == 0 and k == 1:
                if S[0][i] != '1' and S[1][i] != '1':
                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)
            if j == 1 and k == 0:
                if S[0][i] != '1' and S[1][i] != '1':
                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)
    dp = nx
ans = -INF
for k, v in dp.items():
    ans = max(ans, v)
print(ans)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys;input = sys.stdin.readline

def topological_sorted(digraph):
    n = len(digraph)
    indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:
            indegree[nxt_v] += 1

    tp_order = [i for i in range(n) if indegree[i] == 0]
    stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:
                stack.append(nxt_v)
                tp_order.append(nxt_v)

    return len(tp_order) == n, tp_order

n, m, k = map(int, input().split())
p = [input()[:-1] for i in range(n)]
s = [list(input().split()) for i in range(m)]

memo = {}
for idx, ptn in enumerate(p):
    val = 0
    for i in range(k):
        if ptn[i] == ""_"":
            continue
        val += (ord(ptn[i]) - 96) * (27 ** i)
    memo[val] = idx

for i, (string, idx) in enumerate(s):
    s[i] = tuple(map(ord, string)), int(idx)

graph = [[] for i in range(n)]
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:
        print(""NO"")
        exit()

    for idx_to in idxs:
        if idx == idx_to:
            continue
        graph[idx].append(idx_to)

flag, res = topological_sorted(graph)
if flag:print(""YES"");print(*[i + 1 for i in res])
else:print(""NO"")",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: c = [[0 for i in range(5205)] for j in range(5205)]
K = 998244353
inv = [0 for i in range(5205)]

def mu(a, n):
	if n == 0: return 1
	q = mu(a, n // 2)
	if n % 2 == 0:
		return q * q % K
	else: return q * q % K * a % K

def calc(m, d, S):
	res = 0
	if m == 0:
		if S == 0: return 1
		return 0

	for u in range(0, m + 1):
		if (u * d > S): break
		U = c[m][u] * c[S - u * d + m - 1][m - 1] % K
		if u % 2 == 0:
			res = (res + U) % K
		else: res = (res - U + K) % K
	return res

c[0][0] = 1
inv[0] = 1
for i in range(1, 5101):
	inv[i] = mu(i, K - 2)

for i in range(1, 5101):
	c[i][0] = 1
	for j in range (1, i):
		c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % K
	c[i][i] = 1

p, s, r = map(int, input().split())

res = 0
den = 0

for i in range(1, p + 1):
	A = 0
	for d in range(r, s // i + 1):
		if (i < p): A = (A + calc(p - i, d, s - d * i)) % K
		else:
			if (s - i * d == 0): A += 1
	A = A * inv[i] % K
	res = (res + A * c[p - 1][i - 1] % K) % K

den = c[s - r + p - 1][p - 1]
res = res * mu(den, K - 2) % K
print(res)
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os
import sys

def log(*args, **kwargs):
    if os.environ.get('CODEFR'):
        print(*args, **kwargs)

n, k = tuple(map(int, input().split()))

s = '0'*((n-k)//2) + '1'

for i in range(n):
    print(s[i % len(s)], end='')
print()
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import heapq
from functools import reduce


class Solution(object):
    def getNumberOfBacklogOrders(self, orders):
        MOD = 10**9 + 7
        buy, sell  = [], [] 
        for p, a, t in orders:
            if t == 0:
                heapq.heappush(buy, [-p, a])
            else:
                heapq.heappush(sell, [p, a])
            while sell and buy and sell[0][0] <= -buy[0][0]:
                k = min(buy[0][1], sell[0][1])
                tmp = heapq.heappop(buy)
                tmp[1] -= k
                if tmp[1]:
                    heapq.heappush(buy, tmp)
                tmp = heapq.heappop(sell)
                tmp[1] -= k
                if tmp[1]:
                    heapq.heappush(sell, tmp)
        return reduce(lambda x, y: (x+y) % MOD, (a for _, a in buy + sell))",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
import math
from collections import OrderedDict
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, input().split())
def listinput(): return list(map(int, input().split()))
n,k=minput()
if n==k:print(math.ceil(n/2)-1)
elif k>2*n:print(0)
else:print(min(n,k-1)-k//2)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def isPrefixOfWord(self, sentence, searchWord):
        def KMP(text, pattern):
            def getPrefix(pattern):
                prefix = [-1] * len(pattern)
                j = -1
                for i in range(1, len(pattern)):
                    while j > -1 and pattern[j + 1] != pattern[i]:
                        j = prefix[j]
                    if pattern[j + 1] == pattern[i]:
                        j += 1
                    prefix[i] = j
                return prefix
    
            prefix = getPrefix(pattern)
            j = -1
            for i in range(len(text)):
                while j != -1 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1
        
        if sentence.startswith(searchWord):
            return 1
        p = KMP(sentence, ' ' + searchWord)
        if p == -1:
            return -1
        return 1+sum(sentence[i] == ' ' for i in range(p+1))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: MOD=int(1e9+7)
n=int(input())
a=[]
for i in range(n):
    a.append(input())
a="""".join(a)
dp,s=[],[]
for i in range(n+1):
    dp.append([0]*(n+1))
    s.append([0]*(n+1))
dp[0][0]=1
s[0][0]=1
for i in range(1,n):
    for j in range(0,n):
        if a[i-1]=='f':
            dp[i][j+1]=dp[i-1][j]%MOD
        elif a[i-1]=='s':
            dp[i][j]=s[i-1][j]%MOD

    for j in reversed(range(n)):
        s[i][j]+=(dp[i][j]+s[i][j+1])%MOD
print(s[n-1][0]%MOD)
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin, stdout, exit

n, m, k = map(int, stdin.readline().split())
a = list(map(int, stdin.readline().split()))

def bf(a):
    best = 0
    best_arg = (-1, -1)
    for i in range(n):
        for j in range(i, n):
            cur = sum(a[i:j+1]) - k*((j - i) // m + 1)
            if cur > best:
                best = max(best, cur)
                best_arg = (i,j)
    return best, best_arg

def max_sum(a):
    if len(a) == 0:
        return 0
    elif len(a) == 1:
        return max(0, a[0] - k)
    mid = len(a) // 2
    l_rec = max_sum(a[:mid])
    r_rec = max_sum(a[mid:])
    l_bests = [0]*m
    r_bests = [0]*m
    l_sum = 0
    for idx in range(1,mid+1):
        l_sum += a[mid-idx]
        if idx % m == 0:
            l_sum -= k
        l_bests[idx%m] = max(l_bests[idx%m], l_sum)
    r_sum = 0
    for idx in range(0, len(a)-mid):
        r_sum += a[idx+mid]
        if (idx+1) % m == 0:
            r_sum -= k
        r_bests[(idx+1)%m] = max(r_bests[(idx+1)%m], r_sum)

    best_acr = 0
    for i in range(m):
        for j in range(m):
            best_acr = max(best_acr, l_bests[i] + r_bests[j] - (k if i+j>0 else 0) - (k if i+j>m else 0))
    ans = max(l_rec,r_rec, best_acr)

    return ans

ans = max_sum(a)
stdout.write(str(ans) + ""\n"")
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def isFascinating(self, n):
        lookup = [0]
        def check(x):
            while x:
                x, d = divmod(x, 10)
                if d == 0 or lookup[0]&(1<<d):
                    return False
                lookup[0] |= (1<<d)
            return True
    
        return check(n) and check(2*n) and check(3*n)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp1 = defaultdict(lambda :-1)
M=1001
def ec(i,j):
    return i*M+j

for i in range(N):
    dp1[ec(i,i+1)] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp1[ec(j,j+k)], dp1[ec(j+k,j+i)]
            if u != -1 and v != -1 and u == v:
                dp1[ec(j,j+i)] = u+1
                break

dp2 = [10**18]*(N+1)
dp2[0] = 0
for i in range(N):
    for j in range(i+1):
        if dp1[ec(j,i+1)] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
a = list(map(int, input().split(' ')))

new_a = [[0] * 600 for i in range(600)]
dp = [[0x7fffffff] * 600 for i in range(600)]

for i in range(n):
	new_a[i+1][i+1] = a[i]
	dp[i+1][i+1] = 1

for i in range(1, n + 1):
	for j in range(i + 1, n + 1):
		dp[i][j] = j - i + 1

for llen in range(2, n + 1):
	for left in range(1, n - llen + 2):
		right = left + llen - 1
		for middle in range(left, right):
			dp[left][right] = min(dp[left][right], dp[left][middle] + dp[middle+1][right])
			if dp[left][middle] == 1 and dp[middle+1][right] == 1 and new_a[left][middle] == new_a[middle+1][right]:
				dp[left][right] = 1
				new_a[left][right] = new_a[left][middle] + 1

print(dp[1][n])",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: x, k = map(int, input().split())
mod = 10**9+7
e = (x * pow(2, k, mod)) % mod
s = (e - pow(2, k, mod)) % mod
f = lambda x: (x*(x+1))%mod
ans = ((f(e) - f(s)) * pow(2, k*(mod-2), mod))%mod
print(ans if x != 0 else 0)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate

int1 = lambda x: int(x) - 1
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
ilele = lambda: map(int,input().split())
alele = lambda: list(map(int, input().split()))
ilelec = lambda: map(int1,input().split())
alelec = lambda: list(map(int1, input().split()))
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

from functools import lru_cache

n,l,r,x = ilele()
A = alele()
A.sort()

@lru_cache(None)
def fun(pos = 0,sm = -1,la = -1,tot = 0):
    if pos == n:
        if tot >= l and tot <= r and la  > 0 and  (la - sm) >= x:
            return 1
        return 0
    if sm == -1:
        return fun(pos+1,A[pos],-1,A[pos]) + fun(pos+1,sm,la,tot)
    elif la == -1:
        return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot)
    else:
        return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot)

print(fun())
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def countSubstrings(self, s: str) -> int:
        res = 0

        for i in range(len(s)):

            l, r = i, i
            while l >= 0 and r < len(s) and s[l] == s[r]:
                res += 1
                l -= 1
                r += 1

            l, r = i, i + 1
            while l >= 0 and r < len(s) and s[l] == s[r]:
                res += 1
                l -= 1
                r += 1

        return res
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maskPII(self, S):
        if '@' in S:
            first, after = S.split('@')
            return ""{}*****{}@{}"".format(first[0], first[-1], after).lower()

        digits = [x for x in S if x.isdigit()]
        local = ""***-***-{}"".format(digits[-4:])
        if len(digits) == 10:
            return local
        return ""+{}-{}"".format('*' * (len(digits) - 10), local)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import exit
x, k = map(int, input().split())
if x == 0:
    print(0)
    exit(0)
x = 2 * x - 1
mod = 10**9 + 7

def pot(r, k):
    if k == 0: return 1
    if k % 2 == 1:
        return r * pot(r, k - 1) % mod
    y = pot(r, k // 2)
    return y * y % mod

print((pot(2, k) * x + 1) % mod)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def minSideJumps(self, obstacles):
        result, lanes = 0, set([2])
        for i in range(len(obstacles)-1):
            lanes.discard(obstacles[i+1])
            if lanes:
                continue
            result += 1
            lanes = set(j for j in range(1, 4) if j not in [obstacles[i], obstacles[i+1]])
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=2*int(input())
a=list(map(int,input().split()))
z=0
for i in range(0,n-1,2):
    if a[i]!=a[i+1]:
        for j in range(i+1,n):
            if a[j]==a[i]:
                z+=j-i-1
                a.pop(j)
                a.insert(i+1,a[i])
print(z)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def containsPattern(self, arr, m, k):
        cnt = 0
        for i in range(len(arr)-m):
            if arr[i] != arr[i+m]:
                cnt = 0
                continue
            cnt += 1
            if cnt == (k-1)*m:
                return True
        return False",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque

n, k = map(int,input().split())
s = input()

def judge(needed):

    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0

    effect = [[inf]*(n+1) for j in range(k)]

    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

            if accu>=needed:
                index = i + needed

            effect[j][i] = index

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index])

        minstate[state] = minimum

    if minstate[-1]<=n:  return True
    return False

front = 0
rear = n//k+1

while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)

    if flag:
        front = mid + 1
    else:
        rear = mid

print(front-1)
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import bisect



class Solution3(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        tiles.sort()
        prefix = [0]*(len(tiles)+1)
        for i, (l, r) in enumerate(tiles):
            prefix[i+1] = prefix[i]+(r-l+1)
        result = 0
        for left, (l, _) in enumerate(tiles):
            r = l+carpetLen-1
            right = bisect.bisect_right(tiles, [r+1])-1
            extra = max(tiles[right][1]-r, 0)
            result = max(result, (prefix[right+1]-prefix[left])-extra)
        return result",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
s = list(input())
d = list(input())
if(sorted(s) != sorted(d)):
    print(-1)
else:
    ans = []
    for i in range(n):
        if(s[i] != d[i]):
            for u in range(i+1,n):
                if(s[u] == d[i]):
                    ind = u
                    break
                else:ind = -1
            if(ind == -1):print(-1);exit()
            cnt = abs(ind - i)
            s.pop(ind)
            s.insert(i,d[i])

            for k in range(cnt):
                if(ind > 0):
                    ans.append(ind)
                else:
                    ans.append(1)
                ind -= 1
    print(len(ans))
    print(*ans)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def main():
    t = int(input())
    for i in range(t):
        n, k = input().split(' ')
        n = int(n)
        k = int(k)
        if n > 35:
            m = n - 1
            print('YES ' + m.__str__())
            continue
        if k > (4 ** n - 1) // 3:
            print('NO')
            continue
        ans = None
        for a in range(n):
            can = (2 ** (n - a + 1) - 1) * (4 ** a - 1) // 3
            total = (4 ** n - 1) // 3
            min = 2 ** (n - a + 1) - 2 - n + a
            if k <= total - can and k >= min:
                ans = a
                break
        if ans is not None:
            print(""YES "" + ans.__str__())
        else:
            print('NO')

if __name__ == ""__main__"":
    main()",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys

try:

    def check(n):
        count1=0
        s=""""
        while(n!=0):
            if n%2:
                count1+=1
                s=""1""+s
            else:
                s=""0""+s
            n//=2
        return s

    def solve(flag,n,l):
        temp_ans=0
        for i in range(n):
            y=(z[flag]^int(l[i],2) )
            b=bin(y)
            temp_ans+=b.count(""1"")
            flag=not(flag)

        return temp_ans

    n=int(input())
    l1 = [input() for y in range(n)]
    temp=input()
    l2 = [input() for y in range(n)]
    temp=input()
    l3 = [input() for y in range(n)]
    temp=input()
    l4 = [input() for y in range(n)]

    z=[]
    s=0
    for i in range(n):
       if i%2==1:
           s+=(2**i)
    z.append(s)
    z.append( z[0] ^ (2**n-1) )
    ans=m=sys.maxsize
    for i in range(2,17):
        s=check(i)
        if s.count(""1"")==2:
            s=(4-len(s))*""0""+s
            res=sys.maxsize
            for i in range(4):
                if i==0:
                    x=l1
                elif i==1:
                    x=l2
                elif i==2:
                    x=l3
                else:
                    x=l4

                if s[i]==""1"":
                    res+=min(res,solve(1,n,x))
                else:
                    res+=min(res,solve(0,n,x))
            ans=min(ans,res-m)
    print(ans)

except EOFError:
    pass",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):

    def distributeCandies(self, candies):
        lookup = set(candies)
        return min(len(lookup), len(candies)/2)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math
for _ in range (int(input())):
    n=int(input())
    s=1
    ch=0
    for i in range (1,31):
        s*=2
        d=math.sqrt(n//s)
        if n%s==0 and d==int(d):
            ch=1
            break
    if ch:
        print(""YES"")
    else:
        print(""NO"")",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
ai = list(map(int,input().split()))
ai.sort()
num = 0
num2 = 0
for i in range(1,n):
    if ai[i-1] == ai[i]:
        num += 1
        num2 = i
if num == 0:
    num3 = sum(ai)
    num4 = n * (n-1) // 2
    ans = (num3 - num4) % 2
    if ans == 1:
        print(""sjfnb"")
    else:
        print(""cslnb"")
elif num == 1:
    if (num2 > 1 and ai[num2-2] == ai[num2] - 1) or ai[num2] == 0:
        print(""cslnb"")
    else:
        num3 = sum(ai)
        num4 = n * (n-1) // 2
        ans = (num3 - num4) % 2
        if ans == 1:
            print(""sjfnb"")
        else:
            print(""cslnb"")
else:
    print(""cslnb"")
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def numberOfWeakCharacters(self, properties):
        properties.sort(cmp=lambda a, b: cmp(b[1], a[1]) if a[0] == b[0] else cmp(a[0], b[0]))
        result = max_d = 0
        for a, d in reversed(properties):
            if d < max_d:
                result += 1
            max_d = max(max_d, d)
        return result

import collections",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def pruneTree(self, root):
        if not root:
            return None
        root.left = self.pruneTree(root.left)
        root.right = self.pruneTree(root.right)
        if not root.left and not root.right and root.val == 0:
            return None
        return root",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def mergeTrees(self, t1, t2):
        if t1 is None:
            return t2
        if t2 is None:
            return t1
        t1.val += t2.val
        t1.left = self.mergeTrees(t1.left, t2.left)
        t1.right = self.mergeTrees(t1.right, t2.right)
        return t1",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class UnionFind(object): 
    def __init__(self, n):
        self.set = list(range(n))
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x: 
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] > self.rank[y]: 
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True

    def reset(self, x):
        self.set[x] = x
        self.rank[x] = 0


class Solution3(object):
    def findAllPeople(self, n, meetings, firstPerson):
        meetings.sort(key=lambda x: x[2])
        uf = UnionFind(n)
        uf.union_set(0, firstPerson)
        group = set()
        for i, (x, y, _) in enumerate(meetings):
            group.add(x)
            group.add(y)
            uf.union_set(x, y)
            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:
                continue
            while group:
                x = group.pop()
                if uf.find_set(x) != uf.find_set(0):
                    uf.reset(x)
        return [i for i in range(n) if uf.find_set(i) == uf.find_set(0)]",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import Counter

class Solution(object):
    def originalDigits(self, s):
        cnts = [Counter(_) for _ in [""zero"", ""one"", ""two"", ""three"", \
                                     ""four"", ""five"", ""six"", ""seven"", \
                                     ""eight"", ""nine""]]

        order = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]

        unique_chars = ['z', 'o', 'w', 't', 'u', \
                        'f', 'x', 's', 'g', 'n']

        cnt = Counter(list(s))
        res = []
        for i in order:
            while cnt[unique_chars[i]] > 0:
                cnt -= cnts[i]
                res.append(i)
        res.sort()

        return """".join(map(str, res))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def minimumLength(self, s):
        left, right = 0, len(s)-1
        while left < right:
            if s[left] != s[right]:
                break
            c = s[left]
            while left <= right:
                if s[left] != c:
                    break
                left += 1
            while left <= right:
                if s[right] != c:
                    break
                right -= 1
        return right-left+1",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections

import sys

N = int(input())
p = [int(x) for x in input().split()]

G = collections.defaultdict(list)

for i, v in enumerate(p):
    u = i + 2
    G[u].append(v)
    G[v].append(u)

root = 1

colors = [0] * (N + 1)
counts = [0] * (N + 1)

q = [root]
parents = [0] * (N+1)
vis = [0] * (N+1)
while q:
    u = q.pop()
    if vis[u]:
        colors[parents[u]] += colors[u]
        continue
    children = [v for v in G[u] if v != parents[u]]
    for v in children:
        parents[v] = u

    if children:
        vis[u] = True
        q.append(u)
        q.extend(children)
    else:
        vis[u] = True
        colors[u] = 1
        colors[parents[u]] += 1

colors.sort()
print(' '.join(map(str, colors)))
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, m, k, l = [int(x) for x in input().split()]
if (l + k) % m == 0:
    c = (l + k)//m
else:
    c = (l + k)//m + 1
if m * c > n:
    print(-1)
else:
    print(c)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: s = input()
trgt = 0
for c in s:
    trgt += (1 if c == '+' else -1)

cmd = input()

queue = [[0, 0]]
dests = []

while queue:
    nextqueue = []
    for pos, cmdi in queue:
        if cmdi == len(cmd):
            dests.append(pos)
            continue
        nextcmd = cmd[cmdi]
        if nextcmd == '+':
            nextqueue.append([pos+1, cmdi+1])
        elif nextcmd == '-':
            nextqueue.append([pos-1, cmdi+1])
        else:
            nextqueue.append([pos + 1, cmdi + 1])
            nextqueue.append([pos - 1, cmdi + 1])
    queue = nextqueue

occurs = 0
for x in dests:
    if x == trgt:
        occurs+=1
print(occurs / len(dests))",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
input = sys.stdin.readline
from collections import defaultdict, Counter, deque

n, m, k = map(int, input().split())
P = [input()[:-1] for _ in range(n)]
S = [list(input().split()) for _ in range(m)]
idx = {p: i for i, p in enumerate(P, 1)}
G = defaultdict(list)
deg = Counter()
for s, i in S:
    i = int(i)
    cand = set()
    for mask in range(1 << k):
        cur = ['_'] * k
        for j in range(k):
            if mask >> j & 1: cur[j] = s[j]
        cur = """".join(cur)
        if cur in idx:
            cand.add(idx[cur])
    if i not in cand:
        print(""NO"")
        break
    for c in cand:
        if c == i: continue
        G[i].append(c)
        deg[c] += 1
else:
    ans = []
    q = deque([i for i in range(1, n + 1) if not deg[i]])
    while q:
        i = q.popleft()
        ans.append(i)
        for j in G[i]:
            deg[j] -= 1
            if not deg[j]:
                q.append(j)
    if len(ans) < n:
        print(""NO"")
    else:
        print(""YES"")
        print(*ans)",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def get_path_hv(A, B):
	x, y = A

	path = [(x, y)]

	while x < B[0]:
		x += 1
		path.append((x, y))

	while x > B[0]:
		x -= 1
		path.append((x, y))

	while y < B[1]:
		y += 1
		path.append((x, y))

	while y > B[1]:
		y -= 1
		path.append((x, y))

	return path

def get_path_vh(A, B):
	x, y = A

	path = [(x, y)]

	while y < B[1]:
		y += 1
		path.append((x, y))

	while y > B[1]:
		y -= 1
		path.append((x, y))

	while x < B[0]:
		x += 1
		path.append((x, y))

	while x > B[0]:
		x -= 1
		path.append((x, y))

	return path

A = tuple(map(int, input().split()))
B = tuple(map(int, input().split()))
C = tuple(map(int, input().split()))

paths = []
paths.append([get_path_vh(A, B), get_path_hv(A, B)])
paths.append([get_path_vh(C, B), get_path_hv(C, B)])
paths.append([get_path_vh(A, C), get_path_hv(A, C)])

ans = 10 ** 8
ans_path = []

for i in range(3):
	for j in range(3):
		if i != j:
			for a in paths[i]:
				for b in paths[j]:
					X = list(set([*a, *b]))

					if len(X) < ans:
						ans = len(X)
						ans_path = X

print(ans)
for p in ans_path:
	print(*p)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: N=int(input())
intervals = []
for i in range(N):
    x,w = map(int,input().split())
    left = x-w
    right = x+w
    intervals.append((left,right))
intervals.sort(key=lambda x: x[1])

left = -1000000007
ans = 0
for i in range(N):
    if intervals[i][0] >= left:
        ans += 1
        left = intervals[i][1]
print(ans)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, m = list(map(int,input().split()))
x = list(map(int,input().split()))
t = list(map(int,input().split()))
arr = []
pep = {}
for i in range(n+m):
    if t[i] == 0:
        arr.append(i)
        pep[x[i]] = 0
    else:
        for j in arr:
            pep[x[j]] = i
        arr = []
for i in range(n+m-1, -1, -1):
    if t[i] == 0:
        arr.append(i)
    else:
        for j in arr:
            if abs(x[j] - x[i]) <= abs(x[pep[x[j]]] - x[j]):
                pep[x[j]] = i
        arr = []
ans = []
for i in range(n+m):
    if t[i]:
        ans.append(1)
    else:
        ans.append(0)
for i in pep:
    ans[pep[i]] += 1
for i in ans:
    if i:
        print(i-1, end = ' ')
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
input=sys.stdin.readline

t=1
for i in range(t):

    n,m,k = map(int,input().split())
    b=[]
    horizontal_edges=[]
    vertical_edges=[]
    for i in range(n):
        temp=[int(x) for x in input().split()]
        horizontal_edges.append(temp)
    for i in range(n-1):
        temp=[int(x) for x in input().split()]
        vertical_edges.append(temp)

    if k%2==1:
        for i in range(n):
            for j in range(m):
                print(-1,end=' ')
            print()
        continue

    dp=[[[10**9 for x in range(k+1)] for x in range(m)] for x in range(n)]

    for i in range(n):
        for j in range(m):
            dp[i][j][0]=0

    for z in range(2,k+1,2):
        for i in range(n):
            for j in range(m):
                    if i>0:
                        if i<n-1:
                            dp[i][j][z]=min(dp[i-1][j][z-2]+2*vertical_edges[i-1][j],dp[i+1][j][z-2]+2*vertical_edges[i][j])
                        else:
                            dp[i][j][z]=dp[i-1][j][z-2]+2*vertical_edges[i-1][j]
                    else:
                        dp[i][j][z]=dp[i+1][j][z-2]+2*vertical_edges[i][j]
                    if j>0:
                        if j<m-1:
                            dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*horizontal_edges[i][j-1],dp[i][j+1][z-2]+2*horizontal_edges[i][j])
                        else:
                            dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*horizontal_edges[i][j-1])
                    else:
                        dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-2]+2*horizontal_edges[i][j])

    for i in range(n):
            for j in range(m):
                print(dp[i][j][k],end=' ')
            print()",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = map(int, input().split())
print((n*2)//k + bool((n*2)%k) + (n*5)//k + bool((n*5)%k) + (n*8)//k + bool((n*8)%k))",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
ar = [int(i) for i in input().split()]

if n == 1:
    print(1)
    exit()

if ar[1] > ar[0]:
    li = [1]
elif ar[1] < ar[0]:
    li = [5]
else:
    li = [3]

c = 1
while c != n:
    j = 0

    if ar[c] > ar[c - 1]:
        while c != n and ar[c] > ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] + 1)
            if li[-1] == 6:
                print(-1)

                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] + 1)
        else:
            li.append(5)

    elif ar[c] < ar[c - 1]:
        while c != n and ar[c] < ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] - 1)
            if li[-1] == 0:
                print(-1)

                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] - 1)
        else:
            li.append(1)

    else:
        while c != n and ar[c] == ar[c - 1]:
            c += 1
            j += 1
        for i in range(j):
            if li[-1] > 3:
                li.append(li[-1] - 1)
            else:
                li.append(li[-1] + 1)
        if c != n and ar[c] > ar[c - 1]:
            if li[-2] == 1:
                li[-1] = 2
            else:
                li[-1] = 1
        elif c != n and ar[c] < ar[c - 1]:
            if li[-2] == 5:
                li[-1] = 4
            else:
                li[-1] = 5

if max(li) > 5 or min(li) < 1:
    print(-1)
else:
    print(*li)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,a,b,c,T=map(int,input().split())
arr=list(map(int,input().split()))
Tcnt=arr.count(T);l=n-Tcnt;ans=0;a1=0
for i in range(1,T):
  for j in range(n):
    if arr[j]<=i:a1+=1

  ans+=a1*c;a1=0
b1=0

for i in range(n):
  b1=a-((T-arr[i])*b)
  if b1<=0:ans+=b1;
  else:ans+=b1
ans1=n*a
print(max(ans,ans1))
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: t=int(input())
g=list(map(int,input().split()))
k=max(g)
flag=True
i=0
while g[i]!=k:
    if i!=0 and g[i]<g[i-1]:
        print(""NO"")
        exit()
    i+=1
i+=1
while i<t and g[i]!=k:
    if i!=0 and g[i]>g[i-1]:
        print(""NO"")
        exit()
    i+=1
print(""YES"")",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
input = sys.stdin.readline

n, m, k = map(int, input().split())
A = [[0] * (m) for _ in range(n)]
B = [[0] * (m) for _ in range(n)]
for i in range(n):
    tmp = list(map(int, input().split()))
    for j in range(m - 1):
        A[i][j + 1] = tmp[j]
for i in range(n - 1):
    tmp = list(map(int, input().split()))
    for j in range(m):
        B[i + 1][j] = tmp[j]

if k % 2:
    ans = [[-1] * m for _ in range(n)]
    for a in ans:
        print(*a)
    sys.exit()
ans = [[0] * m for _ in range(n)]
lim = k // 2
dp = [[[float(""inf"")] * (lim + 1) for _ in range(m)] for _ in range(n)]
for i in range(n):
    for j in range(m):
        dp[i][j][0] = 0

for k in range(1, lim + 1):
    for i in range(n):
        for j in range(m):
            if i: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + B[i][j])
            if j: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + A[i][j])
            if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + B[i + 1][j])
            if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + A[i][j + 1])
for i in range(n):
    for j in range(m):
        ans[i][j] = dp[i][j][-1] * 2
for a in ans:
    print(*a)",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def findMinMoves(self, machines):
        total = sum(machines)
        if total % len(machines): return -1

        result, target, curr = 0, total / len(machines), 0
        for n in machines:
            curr += n - target
            result = max(result, max(n - target, abs(curr)))
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def placedCoins(self, edges, cost):
        def iter_dfs():
            result = [0]*len(cost)
            stk = [(1, (0, -1, [cost[0]]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    stk.append((4, (u, ret)))
                    stk.append((2, (u, p, 0, ret)))
                elif step == 2:
                    u, p, i, ret = args
                    if i == len(adj[u]):
                        continue
                    v = adj[u][i]
                    stk.append((2, (u, p, i+1, ret)))
                    if v == p:
                        continue
                    new_ret = [cost[v]]
                    stk.append((3, (new_ret, ret)))
                    stk.append((1, (v, u, new_ret)))
                elif step == 3:
                    new_ret, ret = args
                    ret.extend(new_ret)
                    ret.sort()
                    if len(ret) > 5:
                        ret = ret[:2]+ret[-3:]
                elif step == 4:
                    u, ret = args
                    result[u] = 1 if len(ret) < 3 else max(ret[0]*ret[1]*ret[-1], ret[-3]*ret[-2]*ret[-1], 0)
            return result
                
        adj = [[] for _ in range(len(cost))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs()",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: a=[]
n=int(input())
for i in range(n):
    l,r=map(int,input().split())
    a.append([l,r,i+1])
a.sort(key=lambda x:(x[0],-x[1]))
r=0
iid=0
f=1
for i in range(n):
    if(r>=a[i][1]):
        f=0
        print(a[i][2],a[iid][2])
        break;
    else:
        r=a[i][1]
        iid=i;
if(f):
    print(""-1 -1"")
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import io
import os

from collections import Counter, defaultdict, deque

def solve(N, M, K, right, down):
    if K % 2 == 1:
        return ((""-1 "" * N) + ""\n"") * M

    K //= 2

    inf = float(""inf"")
    R = N
    C = M

    for row in right:
        row.append(inf)
        row.append(inf)
        row.append(inf)
    right.append([inf] * (C + 2))
    right.append([inf] * (C + 2))
    for row in down:
        row.append(inf)
        row.append(inf)
    down.append([inf] * (C + 2))
    down.append([inf] * (C + 2))
    down.append([inf] * (C + 2))

    def right_(r, c):
        return right[r][c - 1]

    def down_(r, c):
        return down[r - 1][c]

    def left(r, c):
        return right[r][c]

    def up(r, c):
        return down[r][c]

    dist = [[inf for i in range(C + 2)] for j in range(R + 2)]
    for r in range(R):
        for c in range(C):
            dist[r][c] = 0
    for k in range(K):
        nextDist = [[inf for i in range(C + 2)] for j in range(R + 2)]
        for r in range(R):
            for c in range(C):
                nextDist[r][c] = min(
                    dist[r][c - 1] + right_(r, c),
                    dist[r][c + 1] + left(r, c),
                    dist[r - 1][c] + down_(r, c),
                    dist[r + 1][c] + up(r, c),
                )
        dist = nextDist
    return ""\n"".join("" "".join(str(2 * dist[r][c]) for c in range(C)) for r in range(R))

DEBUG = False
if DEBUG:
    import random

    random.seed(0)
    for _ in range(1):
        N = 500
        M = 500
        K = 20

        def pack(i, j):
            return i * M + j

        def unpack(ij):
            return divmod(ij, M)

        graph = [[] for i in range(N * M)]

        right = [[random.randint(1, 10 ** 6) for j in range(M - 1)] for i in range(N)]
        down = [[random.randint(1, 10 ** 6) for j in range(M)] for i in range(N - 1)]
        print(""tc"" + str(_))
        ans = solve(N, M, K, right, down)

    exit()

if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    def pack(i, j):
        return i * M + j

    def unpack(ij):
        return divmod(ij, M)

    N, M, K = [int(x) for x in input().split()]

    right = [[int(x) for x in input().split()] for i in range(N)]
    down = [[int(x) for x in input().split()] for i in range(N - 1)]

    ans = solve(N, M, K, right, down)
    print(ans)
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def encode(self, num):
        result = []
        while num:
            result.append('0' if num%2 else '1')
            num = (num-1)//2
        return """".join(reversed(result))",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: l, r = map(int, input().split())

if l == r:
    print(0)
    exit()
binr, binl = list(bin(r)[2:]), list(bin(l)[2:])
binl = ['0'] * (len(binr) - len(binl)) + binl

for i in range(len(binl)):
    if binl[i] != binr[i]:
        del (binl[0:i])
        del (binr[0:i])
        break

x = '1' * len(binl)

l = int(x, 2)
print(l)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import re
import string
import math

letter_number_pattern = ""[a-zA-Z]*[0-9]*""

alpha = dict(zip(range(1,28), string.ascii_uppercase))
decimals = dict(zip(string.ascii_uppercase, range(1,27)))

alpha_len = len(alpha)

def letter_to_decimal(n):
    exponents = []
    pow_i = 0
    while True:
        if n // (26**pow_i) > 26:
            exponents.append(1)
            n = n - (26**pow_i)
            pow_i += 1
        else:
            exponents.append(n // (26**pow_i))
            n = n - ((n // (26**pow_i)) * (26**pow_i))
            break
    pow_i = pow_i - 1
    while n != 0:
        t = n // (26**pow_i)
        n = n - (t * (26 ** pow_i))
        exponents[pow_i] = exponents[pow_i] + t
        pow_i = pow_i - 1
    result = ''.join(list(map(lambda x: alpha[x], reversed(exponents))))
    return result

def letters_to_deci(letters):
    total_sum = 0
    pows = list(reversed(range(len(letters))))
    for i in range(len(letters)):
        total_sum += decimals[letters[i]] * (26**pows[i])
    return total_sum

input_cells = []

n_lines = input()
for i in range(int(n_lines)):
    input_cells.append(input())

for cell in input_cells:
    all_matches = re.findall(letter_number_pattern, cell)[:-1]
    if len(all_matches) == 2:
        rows = int(re.search(""[0-9]*$"", all_matches[0]).group())
        cols = int(re.search(""[0-9]*$"", all_matches[1]).group())
        converted_cols = letter_to_decimal(cols)
        print(""%s%s"" % (converted_cols, rows))
    elif len(all_matches) == 1:
        rows = re.match(""[A-Z]*"", all_matches[0]).group()
        cols = re.search(""[0-9]*$"", all_matches[0]).group()
        converted_rows = letters_to_deci(rows)
        print(""R%sC%s"" % (cols, converted_rows))
    else:
        pass",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def reconstructQueue(self, people):
        people.sort(key=lambda h_k1: (-h_k1[0], h_k1[1]))
        result = []
        for p in people:
            result.insert(p[1], p)
        return result",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,m,k=map(int,raw_input().split())
l=list(map(int,raw_input().split()))
ma=0
for deb in range(n-1,n-m-1,-1):
    cumi=0
    scu=0
    for i in range(deb,-1,-1):
        scu+=l[i]
        ma=max(ma,scu-cumi-k)
        if (deb-i+1)%m==0:
            scu-=k
        if scu<cumi:
            cumi=scu

print(ma)
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,k=map(int,input().split())
arr=list(map(int,input().split()))
d={}
for i in arr:
	if i in d:
		d[i]+=1
	else:
		d[i]=1
flag=True
for i in range(100,0,-1):
	t2=0
	for j in d.values():
		t2+=j//i
	if(t2>=n):
		print(i)
		flag=False
		break
if(flag):
	print(0)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections



class Solution(object):
    def largestInteger(self, nums, k):
        if k == len(nums):
            return max(nums)
        cnt = collections.defaultdict(int)
        for x in nums:
            cnt[x] += 1
        if k == 1:
            return max(x for x, v in cnt.items() if v == 1) if any(v == 1 for v in cnt.values()) else -1
        result = -1
        if cnt[nums[0]] == 1:
            result = max(result, nums[0])
        if cnt[nums[-1]] == 1:
            result = max(result, nums[-1])
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def num_sq(x,y,x2,y2):

    a = (abs(x2-x)+1)
    b = (abs(y2-y)+1)
    if a % 2 == 0 or b % 2 == 0:
        return (a*b // 2, a*b // 2)
    if (x+y) % 2 == 0:
        num_b = a * b // 2
        return (num_b, a * b - num_b)
    num_w = a * b // 2
    return (a * b - num_w, num_w)
def pt_in(p1, r1, r2):
    return r1[0] <= p1[0] <= r2[0] and r1[1] <= p1[1] <= r2[1]
def intc(p1, p2, p3, p4):
    x1 = max(p1[0], p3[0])
    x2 = min(p2[0], p4[0])
    y1 = max(p1[1], p3[1])
    y2 = min(p2[1], p4[1])
    if x1 <= x2 and y1 <= y2:
        return ((x1, y1), (x2, y2))
    return None

num_ = int(input())
for _ in range(num_):
    n, m = map(int, input().split())
    x1,y1,x2,y2 = map(int,input().split())
    x3,y3,x4,y4 = map(int,input().split())
    p1 = (x1,y1)
    p2 = (x2,y2)
    p3 = (x3,y3)
    p4 = (x4,y4)
    all_b, all_w = num_sq(1, 1, n, m)
    tmp = intc(p1, p2, p3, p4)
    if tmp:
        intc_1, intc_2 = tmp
        t_b, t_w = num_sq(intc_1[0], intc_1[1], intc_2[0], intc_2[1])
    b,w = num_sq(x1,y1,x2,y2)
    if tmp:
        b -= t_b
        w -= t_w
    b2,w2 = num_sq(x3,y3,x4,y4)
    if tmp:
        b2 -= t_b
        w2 -= t_w
    w_tot, b_tot = (all_w + b - w2, all_b - b + w2)
    if tmp:
        w_tot -= t_w
        b_tot += t_w
    print(w_tot, b_tot)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys, copy

n, m = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
res = [0] * (max(arr) + 1)
for i in arr:
    res[i] += 1
ans = 0
for d in range(1, m + 1):
    temp = copy.deepcopy(res)
    cnt = 0
    for i in range(len(temp)):
        while temp[i] >= d:
            temp[i] -= d
            cnt += 1
    if cnt >= n:
        ans = max(ans, d)
print(ans)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n, res = len(nums), nums[0]
        for i in range(n):
            cur = 0
            for j in range(i, n):
                cur += nums[j]
                res = max(res, cur)
        return res
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maxSubArrayLen(self, nums, k):
        sums = {}
        cur_sum, max_len = 0, 0
        for i in range(len(nums)):
            cur_sum += nums[i]
            if cur_sum == k:
                max_len = i + 1
            elif cur_sum - k in sums:
                max_len = max(max_len, i - sums[cur_sum - k])
            if cur_sum not in sums:
                sums[cur_sum] = i 
        return max_len",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

    def __repr__(self):
        if self:
            serial = []
            queue = [self]

            while queue:
                cur = queue[0]

                if cur:
                    serial.append(cur.val)
                    queue.append(cur.left)
                    queue.append(cur.right)
                else:
                    serial.append(

                queue = queue[1:]

            while serial[-1] == 
                serial.pop()

            return repr(serial)

        else:
            return None

class Solution(object):
    def recoverTree(self, root):
        return self.MorrisTraversal(root)

    def MorrisTraversal(self, root):
        if root is None:
            return
        broken = [None, None]
        pre, cur = None, root

        while cur:
            if cur.left is None:
                self.detectBroken(broken, pre, cur)
                pre = cur
                cur = cur.right
            else:
                node = cur.left
                while node.right and node.right != cur:
                    node = node.right

                if node.right is None:
                    node.right =cur
                    cur = cur.left
                else:
                    self.detectBroken(broken, pre, cur)
                    node.right = None
                    pre = cur
                    cur = cur.right

        broken[0].val, broken[1].val = broken[1].val, broken[0].val

        return root

    def detectBroken(self, broken, pre, cur):
        if pre and pre.val > cur.val:
            if broken[0] is None:
                broken[0] = pre
            broken[1] = cur",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: citys,cap=map(int,input().split())
if citys-1<=cap:
	print(citys-1)
else:
	n=citys-cap
	print(n*(n+1)//2+cap-1)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,k=map(int,input().split())
a=list(map(int,input().split()))
d={}
for chr in a:
     if chr not in d:
        d[chr]=1
     else:
        d[chr]+=1
p=list(d.values())
z=k//n
if z==0 :
     print(0)
else:
     o=[]
     if len(a)>=n:
        o.append(1)
     for i in range(2,z+1):
         c=0
         for j in range(len(p)):
             c+=p[j]//i
         if c>=n:
             o.append(i)
     print(max(o))",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def longestSubsequence(self, s, k):
        result, base = 0, 1
        for i in reversed(range(len(s))):
            if s[i] == '0':
                result += 1
            elif base <= k:
                k -= base
                result += 1
            if base <= k:
                base <<= 1
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def main():
  n, k = map(int, input().split())
  v = list(map(int, input().split()))

  d = {}
  ans = 0

  for x in v:
    num_d, mod_k = len(str(x)), x % k
    d.setdefault(num_d, {}).setdefault(mod_k, []).append(x)

  for x in v:
    num_d, mod_k = len(str(x)), x % k
    for add, mods in d.items():
      val_mod = (mod_k * 10 ** add) % k
      need_mod = (k - val_mod) % k
      ans += len(mods.get(need_mod, []))
      if need_mod == mod_k and add == num_d:
        ans -= 1

  print(ans)

if __name__ == ""__main__"":
  main()
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def main():

    n,m = map(int, input().split())
    S = [list(str(input())) for _ in range(n)]

    L = [[0]*m for _ in range(n)]
    R = [[0]*m for _ in range(n)]
    U = [[0]*m for _ in range(n)]
    D = [[0]*m for _ in range(n)]

    for i in range(n):
        cnt = 0
        for j in range(m):
            if S[i][j] == '.':
                cnt = 0
            else:
                cnt += 1
                L[i][j] = cnt
        cnt = 0
        for j in reversed(range(m)):
            if S[i][j] == '.':
                cnt = 0
            else:
                cnt += 1
                R[i][j] = cnt

    for j in range(m):
        cnt = 0
        for i in range(n):
            if S[i][j] == '.':
                cnt = 0
            else:
                cnt += 1
                U[i][j] = cnt
        cnt = 0
        for i in reversed(range(n)):
            if S[i][j] == '.':
                cnt = 0
            else:
                cnt += 1
                D[i][j] = cnt

    imosH = [[0]*(m+1) for _ in range(n)]
    imosV = [[0]*m for _ in range(n+1)]
    ans = []
    for i in range(1, n-1):
        for j in range(1, m-1):
            if S[i][j] == '.':
                continue
            l = L[i][j]-1
            r = R[i][j]-1
            u = U[i][j]-1
            d = D[i][j]-1
            s = min([l, r, u, d])
            if s == 0:
                continue
            ans.append((i+1, j+1, s))
            imosV[i-s][j] += 1
            imosV[i+s+1][j] -= 1
            imosH[i][j-s] += 1
            imosH[i][j+s+1] -= 1

    from itertools import accumulate
    for i in range(n):
        imosH[i] = list(accumulate(imosH[i]))
    for j in range(m):
        for i in range(1, n+1):
            imosV[i][j] += imosV[i-1][j]

    for i in range(n):
        for  j in range(m):
            if S[i][j] == '*':
                if imosH[i][j] <= 0 and imosV[i][j] <= 0:
                    print(-1)
                    exit()
    else:
        print(len(ans))
        for i in range(len(ans)):
            print(*ans[i])

if __name__ == '__main__':
    main()
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def discountPrices(self, sentence, discount):
        def format(discount, x):
            return ""${:d}.{:02d}"".format(*divmod(int(x[1:])*(100-discount), 100)) if x[0] == '$' and x[1:].isdigit() else x

        return "" "".join(format(discount, x) for x in sentence.split())",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

n = int(input())
C = list(map(int, input().split()))
A = list(map(int, input().split()))
A = [a-1 for a in A]

visit = [False]*n
loops = []
for i in range(n):
    if not visit[i]:
        s = [i]
        temp = set()
        temp.add(i)
        flag = False
        while s:
            v = s.pop()
            if visit[A[v]]:
                break
            if A[v] in temp:
                flag = True
                p = A[v]
                break
            else:
                s.append(A[v])
                temp.add(A[v])
        if flag:
            loop = [p]
            nv = A[p]
            cnt = 0
            while nv != p:
                loop.append(nv)
                nv = A[nv]
            loops.append(loop)
        for v in temp:
            visit[v] = True

ans = 0
for l in loops:
    m = 10**18
    for i in l:
        m = min(m, C[i])
    ans += m
print(ans)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: 

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def delNodes(self, root, to_delete):
        def delNodesHelper(to_delete_set, root, is_root, result):
            if not root:
                return None
            is_deleted = root.val in to_delete_set
            if is_root and not is_deleted:
                result.append(root)
            root.left = delNodesHelper(to_delete_set, root.left, is_deleted, result)
            root.right = delNodesHelper(to_delete_set, root.right, is_deleted, result)
            return None if is_deleted else root
        
        result = []
        to_delete_set = set(to_delete)
        delNodesHelper(to_delete_set, root, True, result)
        return result
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: modulo = int(1e9+7)
n = int(input())
arr = [input() for i in range(n)]
dp = [1]
for i in range(n):
    if arr[i] == 'f':
        dp.append(0)
        continue;
    for j in range(1, len(dp)):
        dp[j] = (dp[j] + dp[j-1]) % modulo
print(dp[-1])",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, m, k = map(int, input().split())
A = list(map(int, input().split()))
glans = 0
for s in range(m):
    B = []
    f = s
    su = 0
    sus = 0
    for i in range(s, n):
        su += A[i]
        sus = max(sus, su)
        if (i + 1) % m == s:
            B.append(sus - k)
            B.append(su - sus)
            su = 0
            sus = 0
            f = i + 1
    dob = 0
    klol = 0
    for j in range(f, n):
        dob += A[j]
        klol = max(klol, dob - k)
    B = [0] + B + [klol]
    for i in range(1, len(B)):
        B[i] += B[i - 1]
    cnt = -10 ** 10
    ans = [0, 0]
    minsum = 10 ** 10
    candidat = 0
    for i in range(len(B)):
        if B[i] - minsum > cnt:
            cnt = B[i] - minsum
            ans[1] = i
            ans[0] = candidat
        if B[i] <= minsum:
            minsum = B[i]
            candidat = i
    glans = max(glans, B[ans[1]] - B[ans[0]])
print(glans)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: 
import collections



class Solution(object):
    def killProcess(self, pid, ppid, kill):
        def killAll(pid, children, killed):
            killed.append(pid)
            for child in children[pid]:
                killAll(child, children, killed)

        result = []
        children = collections.defaultdict(set)
        for i in range(len(pid)):
            children[ppid[i]].add(pid[i])
        killAll(kill, children, result)
        return result


",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,m = map(int,input().split())
mat = []

for i in range(n):
    mat.append(list(map(int,input().replace(""*"",""1"").replace(""."",""0""))))

ver,hor = [[0 for i in range(m)] for j in range(n)],[[0 for i in range(m)] for j in range(n)]

dp = [[[0 for i in range(4)]for j in range(m) ] for k in range(n)]
for i in range(1,n):
    for j in range(1,m):
        x,y = n-i-1,m-j-1
        if mat[i][j]==1:
            dp[i][j][0] = max(dp[i][j-1][0],mat[i][j-1]) + 1
            dp[i][j][1] = max(dp[i-1][j][1],mat[i-1][j]) + 1
        if mat[x][y]==1:
            dp[x][y][2] = max(dp[x][y+1][2],mat[x][y+1]) + 1
            dp[x][y][3] = max(dp[x+1][y][3],mat[x+1][y]) + 1

stars = []
for i in range(1,n-1):
    for j in range(1,m-1):
        if mat[i][j]==1:
            s = min(dp[i][j])-1
            if s>0:
                stars.append((i+1,j+1,s))
                ver[i-s][j]+=1
                if i+s+1<n:
                    ver[i+s+1][j] -= 1
                hor[i][j-s]+=1
                if j+s+1<m:
                    hor[i][j+s+1] -= 1

for i in range(1,n):
    for j in range(1,m):
        ver[i][j] += ver[i-1][j]
        hor[i][j] += hor[i][j-1]

chk = True
for i in range(n):
    for j in range(m):
        if mat[i][j] and max(ver[i][j],hor[i][j])<=0:
            chk=False
            break

if chk:
    print(len(stars))
    for i in stars:
        print(*i)
else:
    print(-1)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = map(int, input().split())
c = n + k
p = int(0.5 * ((8 * c + 9) ** 0.5 - 3))
print(n - p)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,u=map(int,input().split())
arr=list(map(int,input().split()))

j,i=1,0
maxi=-1
flag=0
for i in range(n-1):
	if arr[i+1]-arr[i]<=u:
		flag=1
if flag==0:
	print(""-1"")
	exit()
i=0
while(i<n-2):
	while(1):
		if j>=n:
			j=n-1
			break
		if arr[j]-arr[i]>u:
			j-=1
			break
		j+=1
	if i==j:
		j+=1
	elif arr[j]==arr[i]:
		pass
	elif arr[j]-arr[i]<=u:

		maxi=max(maxi,(arr[j]-arr[i+1])/(arr[j]-arr[i]))
	i+=1
if maxi==0:
	print(""-1"")
else:
	print(maxi)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
d = list(map(int, input().split()))
odd = 0
for i in range(n):
    for j in range(i, n):
        if(d[i]>d[j]): odd ^= 1

m = int(input())
ans = []
for i in range(m):
    l, r = map(int, input().split())
    k = r-l+1
    if( (k*(k-1)/2) %2): odd ^= 1
    ans.append( ""odd"" if odd else ""even"")

print('\n'.join(ans))",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maximumAlternatingSubarraySum(self, nums):
        def kadane(nums, start):
            result = float(""-inf"")
            curr = odd = 0
            for i in range(start, len(nums)):
                curr = (curr+nums[i]) if not odd else max(curr-nums[i], 0)
                result = max(result, curr)
                odd ^= 1
            return result

        return max(kadane(nums, 0), kadane(nums, 1))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
a=list(map(int,input().split()))
ans=0
while len(a)>0:
    c=a.pop(0)
    i=a.index(c)
    ans+=i
    del a[i]
print(ans)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin
input = stdin.readline

n = int(input())
a = []
for i in range(4):
    a.append([[int(x) for x in list(input().rstrip())] for _ in range(n)])
    if i < 3: input()
b = []
for i in range(4):
    b.append([])
    for j in range(2):
        c = 0
        for y in range(n):
            for x in range(n):
                if j == 1:
                    z = (x + y) % 2
                else:
                    z = 1 - (x + y) % 2
                c += a[i][y][x] != z
        b[-1].append(c)
ans = float(""inf"")
for i in (3, 5, 6, 9, 10, 12):
    ans = min(ans, b[0][i & 1] + b[1][i >> 1 & 1] + b[2][i >> 2 & 1] + b[3][i >> 3 & 1])
print(ans)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def primecheck(x):
	cnt=0
	for i in range(2,x//2 +1):
		if x%i == 0:
			cnt+=1
			break
	if cnt :
		return 1
	else:
		return 0

n = int(input())
for i in range(4,n):
	if primecheck(i) == 1 and primecheck(n-i) == 1:
		print(str(i) + "" ""+ str(n-i))
		break",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def main():
    n, k = [int(x) for x in input().split(' ')]
    if k==1:
        print(n)
        return
    a = []
    b = {}
    a = [int(x) for x in input().split(' ')]
    a.sort()

    c=dict(zip(a,range(n)))
    a=c
    count = {}

    for x in a:
        if x % k == 0 and int(x / k) in a:
            b[x] = b[int(x / k)]
            count[b[int(x / k)]] += 1
        else:
            b[x] = x
            count[x] = 1

    for x,y in count.items():
        n -= int(y / 2)

    print(n)

main()
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: get = lambda : list(map(int, input().split(' ')))
n, m, k = get()
rlist, clist = [], []
for _ in range(n):
    rlist.append(get())
for _ in range(n-1):
    clist.append(get())

dway = [[0,1],[0,-1],[1,0],[-1,0]]
if k%2:
    res = [[-1]*m for _ in range(n)]
else:
    flist = [[0]*m for _ in range(n)]
    for _ in range(k//2):
        glist = [[10**9]*m for _ in range(n)]
        for dx, dy in dway:
            klist = rlist if dx == 0 else clist
            for x in range(n):
                for y in range(m):
                    xx, yy = x+dx, y+dy
                    if not (0<=xx<n) or not (0<=yy<m):
                        continue
                    tx = xx if dx==-1 else x
                    ty = yy if dy==-1 else y
                    glist[x][y] = min(glist[x][y], flist[xx][yy] + klist[tx][ty] * 2)
        flist = glist
    res = flist
for row in res:
    print(' '.join(map(str, row)))",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = input()
l = map(int, raw_input().split())
r = map(int, raw_input().split())

mp = {i:i for i in range(n)}
out = [-1]*n
v = 0

a = n
done = set()
while v < n:
    ids = set()
    for j in range(n):
        if l[j] == r[j] == 0 and j not in done:
            ids.add(j)
            done.add(j)
    if len(ids) == 0:
        print('NO')
        exit()
    v += len(ids)
    for i in ids:
        out[mp[i]] = a
        for j in range(len(l)):
            if j < i:
                r[j] -= 1
            else:
                l[j] -= 1
    a -= 1
print('YES')
print(' '.join(map(str, out)))
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def numDecodings(self, s: str) -> int:
        dp = {len(s) : 1}

        def dfs(i):
            if i in dp:
                return dp[i]
            if s[i] == ""0"":
                return 0

            res = dfs(i + 1)
            if i + 1 < len(s) and (
                s[i] == ""1"" or s[i] == ""2"" and
                s[i + 1] in ""0123456""
            ):
                res += dfs(i + 2)
            dp[i] = res
            return res

        return dfs(0)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def averageOfLevels(self, root):
        result = []
        q = [root]
        while q:
            total, count = 0, 0
            next_q = []
            for n in q:
                total += n.val
                count += 1
                if n.left:
                    next_q.append(n.left)
                if n.right:
                    next_q.append(n.right)
            q = next_q
            result.append(float(total) / count)
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maxLengthBetweenEqualCharacters(self, s):
        result, lookup = -1, {}
        for i, c in enumerate(s):
            result = max(result, i-lookup.setdefault(c, i)-1)
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())

if bx < ax < cx or bx > ax > cx or by < ay < cy or cy < ay < by:
    print('NO')
else:
    print('YES')
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from copy import deepcopy
def sol(n,m,k,aa,bb):
    if k&1:
        return [[-1] * m] * n
    ans = [[float('inf')]*(m+2) for _ in range(n+2)]
    k >>= 1
    for i in range(1,n+1):
        for j in range(1,m+1):
            ans[i][j] = min(aa[i][j], aa[i][j-1], bb[i][j], bb[i-1][j])
    for _ in range(k-1):
        oans = deepcopy(ans)
        for i in range(1,n+1):
            for j in range(1,m+1):
                ans[i][j] = min(
                    aa[i][j]+oans[i][j+1],
                    aa[i][j-1]+oans[i][j-1],
                    bb[i][j]+oans[i+1][j],
                    bb[i-1][j]+oans[i-1][j])

    ans = ans[1:-1]
    ans = [x[1:-1] for x in ans]
    ans = [[2*x for x in a] for a in ans]
    return ans

n,m,k = map(int, input().split())
aa = [list(map(int, input().split())) for _ in range(n)]
inf = float('inf')
bb = [list(map(int, input().split())) for _ in range(n-1)]
aa = [[inf, *x, inf] for x in aa]
bb = [[inf, *x, inf] for x in bb]
pad = [inf] * (m+1)
aa = [pad, *aa, pad]
pad = [inf] * (m+2)
bb = [pad, *bb, pad]
ans = sol(n,m,k,aa,bb)
print('\n'.join(' '.join(map(str, a)) for a in ans))
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def minOperations(self, n):
        return (n//2)*((n+1)//2)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def uniqueOccurrences(self, arr):
        count = collections.Counter(arr)
        return len(count) == len(set(count.values()))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(sep=None, maxsplit=-1):
        return read().split(sep, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(sep=None, maxsplit=-1):
        return [int(a) for a in read_array(sep, maxsplit)]

    def write(*args, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in args) + end)

    def write_array(array, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in array) + end)

    n = read_int()
    s = read()
    stones = 0
    for c in s:
        if c == '+':
            stones += 1
        else:
            stones -= 1
            if stones < 0:
                stones = 0
    write(stones)

main()
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math
from math import factorial

def combination(n,r):
    return float(factorial(n)) / float(factorial(r)) / float(factorial(n-r))

a = input()
ap = a.count('+')
am = a.count('-')
b = input()
bp = b.count('+')
bm = b.count('-')
n = b.count('?')
x = float(ap - bp)
y = float(am - bm)
if (x < 0 or y < 0 or x+y != n):
    print(0.0)
else:
    print(combination(n,x)/(1<<n))",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = map(int, input().split())
h = k // n
if h * n < k:
    h += 1
print(h)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os
import sys
from io import BytesIO ,IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    pass

def binary(n):
    return (bin(n).replace(""0b"", """"))

def decimal(s):
    return (int(s, 2))

def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)

def lts(l):
    s = ''.join(map(str, l))
    return s

def stl(s):

    l = list(s)

    return l

def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans

def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1

    return (cnt)

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

mod = int(1e9) + 7
def ssinp(): return input()

def iinp(): return int(input())

def nninp(): return map(int ,input().split())

def llinp(): return list(map(int ,input().split()))

def p(xyz): print(xyz)
def p2(a ,b): print(a ,b)
import math

from collections import OrderedDict

a=llinp()
ans=0
for i in range(14):
    temp=a.copy()
    nos=temp[i]
    temp[i]=0
    for j in range(i+1,14):
        temp[j]+=1
        nos-=1
    for j in range(0,14):
        temp[j]+=nos//14
    nos=nos%14
    j=0
    while(nos!=0):
        temp[j]+=1
        nos-=1
        j+=1
    ans1=0
    for c in temp:
        if(c%2==0):
            ans1+=c
    ans=max(ans,ans1)
p(ans)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = list(map(int, input().split()))
u = []
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u[0].sort(reverse=True)
u[1].sort(reverse=True)
u[2].sort(reverse=True)
res = 0
dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]
for i in range(n[0]+1):
    for j in range(n[1]+1):
        for k in range(n[2]+1):
            if i<n[0] and j<n[1]:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + u[0][i]*u[1][j])
            if j<n[1] and k<n[2]:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + u[1][j]*u[2][k])
            if i<n[0] and k<n[2]:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + u[0][i]*u[2][k])
res = max(x for u1 in dp for u2 in u1 for x in u2)
print(res)",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def verifyPreorder(self, preorder):
        low, i = float(""-inf""), -1
        for p in preorder:
            if p < low:
                return False
            while i >= 0 and p > preorder[i]:
                low = preorder[i]
                i -= 1
            i += 1
            preorder[i] = p
        return True",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
from collections import deque
n=int(input())
visited=[False for i in range(n+2)]
dp=[-1 for i in range(n+2)]
l=[[] for i in range(n+2)]
for i in range(n-1):
    a,b=map(int,input().split())
    l[a].append(b)
    l[b].append(a)
b=deque(map(int,input().split()))
b.popleft()
s=deque([1])
visited[1]=True
while len(b)>0 and len(s)>0:
    aux=0
    for i in l[s[0]]:
        if not visited[i]:
            visited[i]=True
            dp[i]=1
            aux+=1
    for i in range(aux):
        x=b.popleft()
        if dp[x]==1:
            s.append(x)
            dp[x]=-1
        else:
            print(""No"")
            sys.exit()
    s.popleft()
print(""Yes"")",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def numPermsDISequence(self, S):
        dp = [1]*(len(S)+1)
        for c in S:
            if c == ""I"":
                dp = dp[:-1]
                for i in range(1, len(dp)):
                    dp[i] += dp[i-1]
            else:
                dp = dp[1:]
                for i in reversed(range(len(dp)-1)):
                    dp[i] += dp[i+1]
        return dp[0] % (10**9+7)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def minimumMoves(self, arr):
        dp = [[0 for _ in range(len(arr)+1)] for _ in range(len(arr)+1)]
        for l in range(1, len(arr)+1):
            for i in range(len(arr)-l+1):
                j = i+l-1
                if l == 1:
                    dp[i][j] = 1
                else:
                    dp[i][j] = 1+dp[i+1][j]
                    if arr[i] == arr[i+1]:
                        dp[i][j] = min(dp[i][j], 1+dp[i+2][j])
                    for k in range(i+2, j+1):
                        if arr[i] == arr[k]:
                            dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k+1][j])
        return dp[0][len(arr)-1]",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections



class Solution(object):
    def countInterestingSubarrays(self, nums, modulo, k):
        cnt = collections.Counter([0])
        result = prefix = 0
        for x in nums:
            if x%modulo == k:
                prefix = (prefix+1)%modulo
            result += cnt[(prefix-k)%modulo]
            cnt[prefix] += 1
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: a = input().split()
st = set([])
cnt = [[0 for i in range(9)] for i in range(3)]
for e in a:
    cnt['mps'.index(e[1])][int(e[0]) - 1] = 1
    st.add(e)
answ = len(st) - 1
for i in range(3):
    for j in range(7):
        answ = min(answ, 3 - sum(cnt[i][j:j + 3]))
print(answ)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def rangeBitwiseAnd(self, m, n):
        while m < n:
            n &= n - 1
        return n",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def resistors(a,b):
    ans=0
    while b:
        ans+=a//b
        a,b=b,a%b
    return ans
a,b=map(int,input().strip().split())
print(resistors(a,b))",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
input = sys.stdin.readline

n,m,k=map(int,input().split())
YOKO=[list(map(int,input().split())) for i in range(n)]
TATE=[list(map(int,input().split())) for i in range(n-1)]

if k%2==1:
    for i in range(n):
        print(*[-1]*m)
    exit()

DP=[[0]*m for i in range(n)]

for i in range(n):
    for j in range(m):

        MIN=1<<30

        if j-1>=0:
            MIN=min(MIN,YOKO[i][j-1]*2)
        if j<m-1:
            MIN=min(MIN,YOKO[i][j]*2)

        if i-1>=0:
            MIN=min(MIN,TATE[i-1][j]*2)
        if i<n-1:
            MIN=min(MIN,TATE[i][j]*2)

        DP[i][j]=MIN

DP0=DP[:]

for tests in range(k//2-1):
    NDP=[[0]*m for i in range(n)]

    for i in range(n):
        for j in range(m):
            MIN=DP[i][j]+DP0[i][j]

            if 0<=i+1<n:
                MIN=min(MIN,TATE[i][j]*2+DP[i+1][j])

            if 0<=i-1<n:
                MIN=min(MIN,TATE[i-1][j]*2+DP[i-1][j])

            if 0<=j+1<m:
                MIN=min(MIN,YOKO[i][j]*2+DP[i][j+1])

            if 0<=j-1<m:
                MIN=min(MIN,YOKO[i][j-1]*2+DP[i][j-1])

            NDP[i][j]=MIN
    DP=NDP

for dp in DP:
    print(*dp)
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def finalPrices(self, prices):
        stk = []
        for i, p in enumerate(prices):
            while stk and prices[stk[-1]] >= p:
                prices[stk.pop()] -= p
            stk.append(i)
        return prices",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import Counter

n, k = [int(x) for x in input().split()]
c = [int(x) for x in input().split()]
f = [int(x) for x in input().split()]
h = [0] + [int(x) for x in input().split()]

cnt_all = Counter(c)
cnt_fav = Counter(f)

ans = 0
for fi in cnt_fav:
    if fi not in cnt_all:
        continue
    m = cnt_fav[fi]
    t = min(cnt_all[fi], m * k)
    dp = [[0] * (t + 1) for _ in range(m + 1)]
    for x in range(1, m + 1):
        for s in range(0, t + 1):
            for ki in range(0, k + 1):
                if ki + s > t:
                    break
                dp[x][ki + s] = max(dp[x][ki + s], dp[x - 1][s] + h[ki])
    ans += dp[m][t]
print(ans)",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
import io, os
import math
from heapq import *
gcd = math.gcd
sqrt = math.sqrt
ceil = math.ceil

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
def print(x, end):
    sys.stdout.write(str(x) + end)
def strinp(testcases):
    k = 5
    if (testcases == -1 or testcases == 1):
        k = 1
    f = str(input())
    f = f[2:len(f) - k]
    return f
def ind(ch):
    return ord(ch)-ord(""a"")
def cleanarr(arr):
    n = len(arr)

    arr.sort()
    c = []
    curr=[arr[0], 1]
    for i in range(n - 1):
        if (arr[i] != arr[i + 1]):
            if(curr[1]>=2):
                c.append(curr)
            curr=[arr[i+1],1]
        else:
            curr[1] += 1
    if(curr[1]>=2):
        c.append(curr)
    return c
def main():
    t=int(input())
    for _ in range(t):
        n=int(input())
        arr=list(map(int, input().split()))
        g=arr[0]
        c=cleanarr(arr)
        if(n>=40000):
            f=0
            for i in range(len(c)):
                if(c[i][1]>=4):
                    f=c[i][0]
                    break
            print(f,"" "")
            print(f,"" "")
            print(f,"" "")
            print(f,""\n"")
            continue
        mi=10**18
        pair=[-1,-1]
        for i in range(len(c)):
            if(c[i][1]>=4):
                pair=[c[i][0],c[i][0]]
                break
            if(i==len(c)-1):
                break
            a=c[i][0]
            b=c[i+1][0]
            if(mi==10**18):
                pair=[a,b]
                mi=0
                continue
            if ((((pair[0]+pair[1])**2)*a*b)-(((a+b)**2)*pair[0]*pair[1])>0):
                pair=[a,b]
        print(pair[0],"" "")
        print(pair[0],"" "")
        print(pair[1],"" "")
        print(pair[1],""\n"")
main()",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections
import operator
from functools import reduce



class Solution(object):
    def beautifulSubsets(self, nums, k):
        def count(x):
            y = x
            while y-k in cnt:
                y -= k
            dp = [1, 0] 
            for i in range(y, x+1, k):
                dp = [dp[0]+dp[1], dp[0]*((1<<cnt[i])-1)]
            return sum(dp)

        cnt = collections.Counter(nums)
        return reduce(operator.mul, (count(i) for i in cnt.keys() if i+k not in cnt))-1",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maxStrength(self, nums):
        if all(x <= 0 for x in nums) and sum(x < 0 for x in nums) <= 1:
            return max(nums)
        result = reduce(lambda x, y: x*y, (x for x in nums if x))
        return result if result > 0 else result//max(x for x in nums if x < 0)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def numtostr(a):
    var=[]
    while a>0:

       if a%26==0:
          var.append(""Z"")
          a=a//26-1
       else:
          var.append(chr(a%26-1+ord(""A"")))
          a=a//26
    var.reverse()
    return """".join(var)

def strtonum(b):
    par=len(b)
    result=0
    for i in range(1,par):
        result+=(26**i)
    par=len(b)-1
    for elem in b:
        if par!=0:
             result+=((ord(elem)-ord(""A""))*((26)**par))
        else:
            result += ((ord(elem) - ord(""A""))+1)

        if par==0:
            break
        par -= 1
    return result

def method1(par1):
    C=par1.index(""C"")
    result=numtostr(int(par1[C+1:]))+str(par1[1:C])
    return result

def method2(par2):
    c=0
    for elem in par2:
        try:
            if int(elem):
                break
        except:
            c+=1
    return ""R""+par2[c:]+""C""+str(strtonum(par2[:c]))

i=input()
inp=[]
for j in range(int(i)):
     x=input()
     inp.append(x)
for key in range(len(inp)):
    if ""R"" in inp[key] and ""C"" in inp[key]:
        try:
            if int(inp[key][1:inp[key].index(""C"")]) and int(inp[key][inp[key].index(""C"")+1:]):
                print(method1(inp[key]))
        except:
            print(method2(inp[key]))
    else:
        print(method2(inp[key]))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import heapq


class Solution(object):
    def eatenApples(self, apples, days):
        min_heap = []
        result = i = 0
        while i < len(apples) or min_heap:
            if i < len(apples) and apples[i] > 0:
                heapq.heappush(min_heap, [i+days[i], i])
            while min_heap and (min_heap[0][0] <= i or apples[min_heap[0][1]] == 0):
                heapq.heappop(min_heap)
            if min_heap:
                apples[min_heap[0][1]] -= 1
                result += 1
            i += 1
        return result",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: 

class Solution(object):
    def restoreString(self, s, indices):
        result = list(s)
        for i, c in enumerate(result):
            if indices[i] == i:
                continue
            move, j = c, indices[i]
            while j != i:
                result[j], move = move, result[j]
                indices[j], j = j, indices[j]
            result[i] = move
        return """".join(result)


",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Node(object):
    def __init__(self, val, children):
        self.val = val
        self.children = children


class Solution(object):
    def maxDepth(self, root):
        if not root:
            return 0
        depth = 0
        for child in root.children:
            depth = max(depth, self.maxDepth(child))
        return 1+depth",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os
import sys
from io import BytesIO, IOBase
from collections import Counter,defaultdict
from heapq import heappush, heappop
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))
def main():
    for _ in range(1):
        n = nmbr()
        d = defaultdict(int)
        for i in range(n):
            u, v = lst()
            d[u] += 1
            d[v + 1] -= 1
        ks = sorted(d.keys())
        ks_n = len(ks)
        for i in range(1, ks_n):
            d[ks[i]] += d[ks[i - 1]]
        l = Counter()
        for i in range(ks_n - 1):
            times = d[ks[i]]
            cnt = ks[i + 1] - ks[i]
            l[times] += cnt
        for i in range(1, n + 1):
            sys.stdout.write(str(l[i]) + ' ')

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    for t in range(1):main()",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import io
import os

def solve(N,):

    if N % 2 != 0:
        return ""NO""
    N //= 2
    if int(N ** 0.5) ** 2 == N:
        return ""YES""
    if N % 2 != 0:
        return ""NO""
    N //= 2
    if int(N ** 0.5) ** 2 == N:
        return ""YES""
    return ""NO""

if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    TC = int(input())
    for tc in range(1, TC + 1):
        (N,) = [int(x) for x in input().split()]
        ans = solve(N,)
        print(ans)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import deque
from sys import stdin
lines = deque(line.strip() for line in stdin.readlines())

def nextline():
    return lines.popleft()

def types(cast, sep=None):
    return tuple(cast(x) for x in strs(sep=sep))

def ints(sep=None):
    return types(int, sep=sep)

def strs(sep=None):
    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))

def main():

    n = int(nextline())
    a = ints()
    bs = set()
    moves = {}
    for i in range(n):
        moves[a[i]] = list(a[j] for j in range(i % a[i], n, a[i]) if a[j] > a[i])
    winners = {}
    for i in range(n, 0, -1):
        winner = 'A' if any(winners[j] == 'B' for j in moves[i]) else 'B'
        if winner == 'B':
            bs.add(i)
        winners[i] = winner
    print(''.join(winners[ai] for ai in a))

if __name__ == '__main__':
    main()
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def findOcurrences(self, text, first, second):
        result = []
        first += ' '
        second += ' '
        third = []
        i, j, k = 0, 0, 0
        while k < len(text):
            c = text[k]
            k += 1
            if i != len(first):
                if c == first[i]:
                    i += 1
                else:
                    i = 0
                continue
            if j != len(second):
                if c == second[j]:
                    j += 1
                else:
                    k -= j+1
                    i, j = 0, 0
                continue
            if c != ' ':
                third.append(c)
                continue
            k -= len(second) + len(third) + 1
            i, j = 0, 0
            result.append("""".join(third))
            third = []
        if third:
            result.append("""".join(third))
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,k=map(int,input().split())
n,k=n-1,k-1
l=0
r=k
g=k*(k+1)//2
ans=-1
while l<=r:
	m=(l+r)//2

	if (g-m*(m+1)//2)>=n:
		ans=k-m
		l=m+1
	else:
		r=m-1
print(ans)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def checkPartitioning(self, s):
        def manacher(s):
            s = '
            P = [0]*len(s)
            C, R = 0, 0
            for i in range(1, len(s)-1):
                i_mirror = 2*C-i
                if R > i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] > R:
                    C, R = i, i+P[i]
            return P

        P = manacher(s)
        prefix, suffix = [], []
        for i in range(2, len(P)-2):
            if i-1-P[i] == 0:
                prefix.append(i)
            if i+1+P[i] == len(P)-1:
                suffix.append(i)
        for i in prefix:
            for j in suffix:
                left, right = i+1+P[i], j-1-P[j]
                if left > right:
                    continue
                mid = left + (right-left)//2
                if P[mid] >= mid-left:
                    return True
        return False",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l < r:
            m = l + (r - l) // 2
            if nums[m] < nums[r]:
                r = m
            else:
                l = m + 1
        return nums[l]
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys, heapq

n, k = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
q = []
for i in range(n):
    heapq.heappush(q, (-arr[i], i))
res = []
temp_k = k
while temp_k:
    val, idx = heapq.heappop(q)
    res.append((-val, idx))
    temp_k -= 1
res.sort(key=lambda x : x[1])
ans = 0
for i in res:
    ans += i[0]
path = []
cnt = 0
for i in range(n):
    if (arr[i], i) in res:
        path.append(cnt + 1)
        cnt = 0
    else:
        cnt += 1
path[-1] += n - sum(path)
print(ans)
print(' '.join(map(str, path)))",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def minOperations(self, nums, target):
        total = sum(nums)
        if total < target:
            return -1

        nums.sort()
        result = 0
        while target:
            x = nums.pop()
            if x <= target:
                target -= x
                total -= x
            elif total-x >= target:
                total -= x
            else:
                nums.append(x//2)
                nums.append(x//2)
                result += 1
        return result",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())

vertices   = []
for _ in range(n):
  x, w = map(int, input().split())
  vertices.append([x - w, x + w])
vertices = sorted(vertices, key = lambda x: x[1])

ans = 0
border = -(10**9 + 100)
for v in vertices:
  if border <= v[0]:
    ans += 1
    border = v[1]
print(ans)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,m = map(int, input().split())
a= input()
b = input()
if '*' in a:
    c = a.replace('*','')
    i = a.index('*')
    if c==b:
        print(""YES"")
    elif a[:i]==b[:i]:
        t = a[i+1:]

        tt = b[m - n+1+i:]

        if t ==tt and n-1<=m:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")
elif n>m:
    print(""NO"")
else:
    if a==b:
        print(""YES"")
    else:
        print(""NO"")
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class MinStack:
    def __init__(self):
        self.stack = []
        self.minStack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        val = min(val, self.minStack[-1] if self.minStack else val)
        self.minStack.append(val)

    def pop(self) -> None:
        self.stack.pop()
        self.minStack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minStack[-1]
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []

        def dfs(node, depth):
            if not node:
                return None
            if depth == len(res):
                res.append(node.val)

            dfs(node.right, depth + 1)
            dfs(node.left, depth + 1)

        dfs(root, 0)
        return res
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import bisect
import copy
import decimal
import fractions
import functools
import heapq
import itertools
import math
import random
import sys
from collections import Counter,deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap)-1)
def _heappushpop_max(heap, item):
    if heap and item < heap[0]:
        item, heap[0] = heap[0], item
        heapq._siftup_max(heap, 0)
    return item
from math import gcd as GCD
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N,Q=map(int,readline().split())
P=Prime(5*10**5)
mebius=[0]+[P.Mebius(i) for i in range(1,5*10**5+1)]
cnt=[0]*(5*10**5+1)
ans=0
A=list(map(int,readline().split()))
used=[False]*(N)
for _ in range(Q):
    q=int(readline())-1
    prime=list(P.Factorize(A[q]).keys())
    l=len(prime)
    for bit in range(1<<l):
        s=1
        for i in range(l):
            if bit>>i&1:
                s*=prime[i]
        if used[q]:
            cnt[s]-=1
            ans-=cnt[s]*mebius[s]
        else:
            ans+=cnt[s]*mebius[s]
            cnt[s]+=1
    if used[q]:
        used[q]=False
    else:
        used[q]=True
    print(ans)",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        output = []
        q = deque()
        l = r = 0

        while r < len(nums):
            while q and nums[q[-1]] < nums[r]:
                q.pop()
            q.append(r)

            if l > q[0]:
                q.popleft()

            if (r + 1) >= k:
                output.append(nums[q[0]])
                l += 1
            r += 1

        return output
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def minEdgeReversals(self, n, edges):
        def dfs1(u, p):
            return sum(adj[u][v]+dfs1(v, u) for v in adj[u] if v != p)

        def dfs2(u, curr):
            result[u] = curr
            for v in adj[u]:
                if result[v] == -1:
                    dfs2(v, curr-adj[u][v]+adj[v][u])
    
        adj = collections.defaultdict(dict)
        for u, v in edges:
            adj[u][v] = 0
            adj[v][u] = 1
        result = [-1]*n
        dfs2(0, dfs1(0, -1))
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=99999999999999999999999999999999
def outIn(x):
    print(x, flush=True)
    return input()
def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        s=rs()
        d=Counter(s)
        if '1' in d:
            news=""""
            for i in s:
                if i!='1':
                    news+=i
            ans=""""
            ind=len(news)
            for i in range(len(news)):
                if news[i]=='2':
                    ind=i
                    break

            ans=news[0:ind]+'1'*d['1']+news[ind:]
            ws(ans)
        else:
            ws(s)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os

import string

from math import inf
from functools import lru_cache

if os.getcwd() == 'C:\\Users\\User\\Desktop\\python\\Prog\\CodeForces' \
        or os.environ['COMPUTERNAME'] == 'RYZEN':
    import pdb

    import sys

    pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout)
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
    from pprint import pprint
    from hypothesis import given, settings
    from hypothesis import strategies as st

def ri():
    return [int(i) for i in input().split()]

MOD = int(1e9 + 7)

def main():
    n, t = ri()
    songs = []
    result = 0
    for i in range(n):
        songs.append(ri())
        songs[-1][1] -= 1

    dp = [[0, 0, 0] for i in range(1 << n)]

    for ind, it in enumerate(songs):
        dp[1 << ind][it[1]] = 1

    for mask in range(1, 1 << n):
        for genre in range(3):
            for nsng, sng in enumerate(songs):
                if sng[1] != genre and ((mask >> nsng) & 1) == 0:
                    dp[mask | (1 << nsng)][sng[1]] += dp[mask][genre]
                    if (mask | (1 << nsng)) == 4:
                        asdddd = 1

            sm = 0
            for ind, it in enumerate(reversed(bin(mask)[2:])):
                if it == '1':
                    sm += songs[ind][0]
            if sm == t:
                result += dp[mask][genre]
                result %= MOD

    print(result)

main()
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math, sys

def mp():
    return list(map(int, input().split()))

def main():
    n, m, k, l = mp()
    ost = n - k
    need = (l + k)
    if ost < l or need > n:
        print(-1)
        return
    ans = (l + k - 1) // m + 1
    if ans * m - k >= l and ans * m <= n:
        print(ans)
    else:
        print(-1)

deb = 0
if deb:
    file = open(""input.txt"", ""r"")
    input = file.readline
else:
    input = sys.stdin.readline

main()

if deb:
    file.close()
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = map(int, input().split())
print(""YES"")
for i in range(n):
    print(""."", end = '')
print()
if k&1:
    if k <= n-2:
        tmp = (n-k)>>1
        for i in range(tmp):
            print(""."", end = '')
        for i in range(k):
            print(""
        for i in range(tmp):
            print(""."", end = '')
        print()
        for i in range(n):
            print(""."", end = '')
        print()
    else:
        print(""."", end = '')
        for i in range(n-2):
            print(""
        print(""."")
        k -= n-2
        print(""."", end = '')
        for i in range(k>>1):
            print(""
        for i in range(n-k-2):
            print(""."", end = '')
        for i in range(k>>1):
            print(""
        print(""."")
else:
    k = k>>1
    for j in range(2):
        print(""."", end = '')
        for i in range(k):
            print(""
        for i in range(n-k-1):
            print(""."", end = '')
        print()
for i in range(n):
    print(""."", end = '')
print()
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: k = int(input().split()[1])
l = sorted(map(int, input().split()))

res = set()
for i in l:
    if i % k != 0 or i / k not in res:
        res.add(i)

print(len(res))
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

n,m = map(int, input().split())
a = []
for i in range(n):
    ai = list(map(int, input().split()))
    a.append(ai)

def check(mid):
    mask = (1<<m)-1
    s = set()
    d = dict()
    for i in range(n):
        state = 0
        for j in range(m):
            if a[i][j] >= mid:
                state += 1<<j
        if state in s:
            continue
        s.add(state)
        k = state
        while k>=0:
            k &= state
            d[k] = i
            k -= 1
        need = mask^state
        if need in d:
            q1, q2 = d[need], i
            if q1 > q2:
                q1, q2 = q2, q1
            return True, (q1, q2)
    return False, (-1, -1)

left = 0
right = 10**9+1
i,j = 0, 0
while right-left>1:
    mid = (right+left)//2
    flag, (q1, q2) = check(mid)
    if flag:
        left = mid
        i,j = q1, q2
    else:
        right = mid
print(i+1, j+1)
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys,os,io
from sys import stdin
import math
from collections import defaultdict
from heapq import heappush, heappop, heapify
from bisect import bisect_left , bisect_right
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

alphabets = list('abcdefghijklmnopqrstuvwxyz')

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,p - 2, p)) % p

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)

    return list(set(l))

def power(x, y, p) :
	res = 1
	x = x % p
	if (x == 0) :
		return 0
	while (y > 0) :
		if ((y & 1) == 1) :
			res = (res * x) % p
		y = y >> 1
		x = (x * x) % p
	return res

def sieveForSmallestPrimeFactor():
    MAXN = 100001
    spf = [0 for i in range(MAXN)]
    spf[1] = 1
    for i in range(2, MAXN):
        spf[i] = i
    for i in range(4, MAXN, 2):
        spf[i] = 2
    for i in range(3, math.ceil(math.sqrt(MAXN))):
        if (spf[i] == i):
            for j in range(i * i, MAXN, i):
                if (spf[j] == j):
                    spf[j] = i
    return spf
def getPrimeFactorizationLOGN(x):
    spf = sieveForSmallestPrimeFactor()
    ret = list()
    while (x != 1):
        ret.append(spf[x])
        x = x // spf[x]
    return ret

def SieveOfEratosthenes(n):

    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def si():
    return input()
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))

n,m,k = li()
dp = [0]*(k+1)
l = []
fk = None
for _ in range(n):
    s = list(si())
    d = []
    if list(set(s))==['0']:
        d.append(0)
        continue
    one = []
    for i in range(len(s)):
        if s[i]=='1':
            one.append(i)
    ni = len(one)
    d = [1e9]*(ni+1)
    d[-1]=0
    for i in range(ni):
        for j in range(i, ni):
            d[ni-(j-i+1)] = min(d[ni-(j-i+1)], one[j]-one[i]+1)
    l.append(d)
    fk = [1e9]*(k+1)
    for i in range(k+1):
        for j in range(ni+1):
            if i+j>k:
                break
            fk[i+j] = min(fk[i+j] , dp[i] +d[j])
    dp = fk[:]

print(min(dp))
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: 
import itertools


class Solution(object):
    def busyStudent(self, startTime, endTime, queryTime):
        return sum(s <= queryTime <= e for s, e in zip(startTime, endTime))
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: N, K = map(int, input().split())
if N == K:
    print(""0""*N)
elif K == 1:
    print(""0""*(N-1) + ""1"")
elif K == 3:
    print(""1"" + ""0""*(N-4) + ""101"")
else:
    res = [""0""]*N
    for i in range(0, N, N//2-K//2+1):
        res[i] = ""1""
    print(''.join(res))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math as mt
import itertools as it
n,l,r,x=map(int,input().split())
a=list(map(int,input().split()))
ans=0
for j in range(2,n+1):
    for i in it.combinations(a,j):
        if max(i)-min(i)>=x and l<=sum(i)<=r:
            ans+=1
print(ans)",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys

def time_distance(v0, a, d):

  return (-v0 + (v0**2 + 2*a*d)**0.5)/a

def time_accelerating(v0, v1, a):
  return (v1 - v0)/a

def time_speed(v, d):
  return d/v

def distance_travelled(v0, t, a):
  return v0*t + (a/2)*t**2

def main():
  a, v = map(int,sys.stdin.readline().strip().split())
  l, d, w = map(int,sys.stdin.readline().strip().split())

  time = 0

  time_to_d = time_distance(0, a, d)
  time_to_v = time_accelerating(0, v, a)

  if (v if time_to_v <= time_to_d else time_to_d * a) <= w:

    acceleration_time = time_to_v
    acceleration_distance = distance_travelled(0, acceleration_time, a)

    if acceleration_distance >= l:

      time = time_distance(0, a, l)
    else:

      time = acceleration_time

      time += time_speed(v, l - acceleration_distance)

  else:
    if time_to_v <= time_to_d:

      acceleration_time = time_to_v
      acceleration_distance = distance_travelled(0, acceleration_time, a)

      deceleration_time = time_accelerating(v, w, -a)
      deceleration_distance = distance_travelled(v, deceleration_time, -a)

    if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:

      acceleration_time = time_accelerating(0, w, a)
      acceleration_distance = distance_travelled(0, acceleration_time, a)

      remaining_distance = d - acceleration_distance

      delta_time = time_distance(w, a, remaining_distance/2)

      time = acceleration_time + 2*delta_time
    else:

      time = time_to_v

      time += time_speed(v, d - deceleration_distance - acceleration_distance)

      time += deceleration_time

    acceleration_time = time_accelerating(w, v, a)
    acceleration_distance = distance_travelled(w, acceleration_time, a)
    if acceleration_distance >= l - d:

      time += time_distance(w, a, l - d)
    else:

      time += acceleration_time

      time += time_speed(v, l - (d + acceleration_distance))

  sys.stdout.write('{0:.5f}'.format(time) + '\n')

if __name__ == '__main__':
  main()",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: N = int(input())
S = [input() for i in range(3)]
bu = []
for s in S:
    cnt = {}
    mx = 0
    for c in s:
        if c not in cnt:
            cnt[c] = 0
        cnt[c] += 1
        mx = max(mx, cnt[c])
    if mx == len(s) and N == 1:
        bu.append(mx - 1)
    else:
        bu.append(min(len(s), mx + N))

ans = -1
ansmx = -1
for i in range(3):
    if bu[i] > ansmx:
        ans = i
        ansmx = bu[i]
    elif bu[i] == ansmx:
        ans = -1

if ans == -1:
    print('Draw')
elif ans == 0:
    print('Kuro')
elif ans == 1:
    print('Shiro')
else:
    print('Katie')
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def superPow(self, a, b):
        def myPow(a, n, b):
            result = 1
            x = a % b
            while n:
                if n & 1:
                    result = result * x % b
                n >>= 1
                x = x * x % b
            return result % b

        result = 1
        for digit in b:
            result = myPow(result, 10, 1337) * myPow(a, digit, 1337) % 1337
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import re

inputs = int(input())

for x in range(inputs):
    coordinates = input()
    match = re.match(""R(\d+)C(\d+)"", coordinates)
    if match:
        rows = int(match.group(1))
        columns = int(match.group(2))

        output = """"
        i = 0
        while columns > 0:
            alpha_index = (columns // (26 ** i) - 1) % 26
            output = chr(65 + alpha_index) + output

            columns -= (alpha_index + 1) * (26 ** i)
            i += 1
        output += str(rows)
        print(output)
    else:
        match = re.match(""(\D+)(\d+)"", coordinates)
        letters = match.group(1)
        rows = match.group(2)
        columns = 0
        for i in range(len(letters), 0, -1):
            columns += (ord(letters[i - 1]) - 64) * (26 ** (len(letters) - i))
        output = f""R{rows}C{columns}""
        print(output)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def longestNiceSubarray(self, nums):
        result = left = curr = 0
        for right in range(len(nums)):
            while curr&nums[right]:
                curr ^= nums[left]
                left += 1
            curr |= nums[right]
            result = max(result, right-left+1)
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: for i in range (1000) :
    print(5,end="""")
print()
for i in range (999) :
    print(4,end="""")
print(5)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def findMaximumScore(self, nums):
        result = mx = 0
        for x in nums:
            result += mx
            mx = max(mx, x)
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def main(n,k):

  s=k*(k+1)//2
  if s<n:
    return -1
  l=1
  r=k
  while l<=r:

    mid=(l+r)//2

    curr=s-(mid*(mid-1))//2

    if curr==n:

      return k-mid+1
    elif curr<n:
      r=mid-1
    else:
      l=mid+1

  return k-l+2

n,k=list(map(int,input().split()))
n-=1
k-=1
if n==0:
  print(0)
else:
  print(main(n,k))
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, s = map(int, input().split())
ans = s
for i in range(n):
    f, t = map(int, input().split())
    ans = max(ans, t+f)
print(ans)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def numberGame(self, nums):
        nums.sort()
        for i in range(0, len(nums), 2):
            nums[i], nums[i+1] = nums[i+1], nums[i]
        return nums",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from math import log
k=int(input())
r=k
l=1
t=log(10)
while 1:
	m=(l+r)//2
	x=int(log(m)/t)
	d=((1-10**(x+1))//9) + (m+1)*(x+1)
	if 0<=(k-d)<=13:
		break
	elif d>k:
		r=m-1
	else:
		l=m+1
if m==1000:
	d+=1
if d==k:
	print(str(m)[-1])
	exit()
st=""""
v=k-d
m+=1
for i in range(13):
	st+=str(m)
	m+=1
print(st[v-1])
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys, os
from io import BytesIO, IOBase
import collections, itertools, bisect, heapq, math, string
from decimal import *
from collections import deque

BUFSIZE = 8192

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def main():
    n = int(input())
    a = list(map(int, input().split()))
    s = set(a)
    a.sort()
    ans = []
    for i in range(n):
        for j in range(31):
            tmp = [a[i]]
            x = a[i] + 2 ** j
            y = a[i] + 2 ** (j + 1)
            if x in s:
                tmp.append(x)
            if y in s:
                tmp.append(y)
            if len(tmp) > 1:
                if len(ans) == 0:
                    ans.append(tmp)
                else:
                    if len(tmp) > len(ans[0]):
                        ans[0] = tmp
    if len(ans) == 0:
        print(1)
        print(a[0])
        return
    if len(ans[0]) == 2:
        print(2)
        print(ans[0][0], ans[0][1])
        return
    if len(ans[0]) == 3:
        print(3)
        print(ans[0][0], ans[0][1], ans[0][2])
        return

if __name__ == ""__main__"":
    main()
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
class Graph:
    verticies = {}
    nodesCount = 0

    class Vertex:
        def __init__(self, label, endPoint=None):
            self.label = label
            self.edges = []
            self.visitedToken = 0
            self.endPoint = endPoint

    class Edge:
        residual = None

        def __init__(self, from_, to_, isResidual, maxCapacity):
            self.from_ = from_
            self.to_ = to_
            self.isResidual = isResidual
            self.capacity = maxCapacity
            self.flow = 0

        def augment(self, bootleneck):
            self.flow += bootleneck
            self.residual.flow -= bootleneck

        def remainingCapacity(self):
            return self.capacity - self.flow

    def addEdge(self, from_, to_, capacity):
        from_ = self.verticies[from_]
        to_ = self.verticies[to_]
        if from_.endPoint and from_.endPoint != to_:
            from_ = from_.endPoint

        main = self.Edge(from_, to_, False, capacity)
        residual = self.Edge(to_, from_, True, 0)

        main.residual = residual
        residual.residual = main

        from_.edges.append(main)
        to_.edges.append(residual)

    def addVertex(self, label, *args):
        self.nodesCount += 1
        self.verticies[label] = self.Vertex(label)

    def maxFlow(self, f, t):
        f = self.verticies[f]
        t = self.verticies[t]
        visitedToken = 1
        flow = 0

        def dfs(node, bootleneck=sys.maxsize):
            node.visitedToken = visitedToken
            bootleneck_backup = bootleneck

            if node == t:
                return bootleneck

            for edge in node.edges:
                if edge.remainingCapacity() == 0 or edge.to_.visitedToken == visitedToken:
                    continue

                bootleneck = dfs(edge.to_, min(
                    bootleneck, edge.remainingCapacity()))
                if bootleneck:
                    edge.augment(bootleneck)
                    return bootleneck
                else:
                    bootleneck = bootleneck_backup

            return 0

        while True:
            bootleneck = dfs(f)

            if not bootleneck:
                break

            flow += bootleneck
            visitedToken += 1

        return flow

g = Graph()

n, m = map(int, input().split())
vv = list(map(int, input().split()))

for i in range(n+m+2):
    g.addVertex(i)

for i, v in enumerate(vv):
    g.addEdge(m+i+1, n+m+1, v)

s = 0

for i in range(1, m+1):
    a, b, c = map(int, input().split())
    s += c

    g.addEdge(0, i, c)
    g.addEdge(i, a+m, c)
    g.addEdge(i, b+m, c)

print(s-g.maxFlow(0, n+m+1))
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
arr = input().split()
b = []

for x in arr:
	b.append(int(x))

cnt = {}
ans = 0

for i in range(n):
	ans += b[i]*(i) + (-b[i])*(n - i - 1)

for i in range(n):
	if((b[i] - 1) in cnt.keys()):
		ans -= cnt[b[i] - 1]
	if((b[i] + 1) in cnt.keys()):
		ans += cnt[b[i] + 1]
	if((b[i]) in cnt.keys()):
		cnt[b[i]] += 1
	else:
		cnt[b[i]] = 1

print(ans)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: a, b = sorted(input()), int(input())
for i in range(len(a)):
	for j in range(i+1, len(a)):
		c = int(str.join('', a))
		a[i], a[j] = a[j], a[i]
		d = int(str.join('', a))
		if c <= d <= b:
		    continue
		else:
		    a[i], a[j] = a[j], a[i]
print(str.join('', a))",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import defaultdict, Counter
from bisect import bisect, bisect_left
from math import sqrt, gcd

def read(): return list(map(int, input().strip().split()))

ans_ = []

t_p = [2**i for i in range(31)]
n = int(input());
arr = Counter(read())
d = defaultdict(int)
m = 1; ans_lis = [[list(arr.keys())[0], 1]]

for i in arr:
    for j in t_p:
        a, b, c = i, i+j, i+2*j
        s = arr[a] + arr[b] + arr[c]
        if s > m:
            m = s
            ans_lis = [[x, arr[x]] for x in [a, b, c]]

ans_.append(m)
t = """"
for i in ans_lis:t += (str(i[0])+"" "")*i[1]
ans_.append(t)

for i in ans_:
    print(i)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def losingPlayer(self, x, y):
        return ""Alice"" if min(x, y//4)%2 else ""Bob""",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def f(a,b):
	r=list(bin(b).lstrip(""0b""))
	l=list((len(bin(b))-len(bin(a)))*(""0"")+bin(a).lstrip(""0b""))
	for i in range(len(r)):
		if (r[i]==""1"" and l[i]==""1""):
			r[i]=""0""
			if int("""".join(r),2)>=a:
				pass
			else:
				r[i]=""1""
		if l[i]==""0"" and r[i]==""0"":
			l[i]=""1""
			if int("""".join(l),2)<=b:
				pass
			else:
				l[i]=""0""
	l=int("""".join(l),2)
	r=int("""".join(r),2)
	return l^r

a,b=map(int,input().strip().split())
print(f(a,b))",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class TreeNode(object):
    def __init__(self, x):
        pass


class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        def iter_dfs(node, p, q):
            result = None
            stk = [(1, (node, [0]))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    curr = int(node == p or node == q)
                    if curr+ret1[0]+ret2[0] == 2 and not result:
                        result = node
                    ret[0] = curr+ret1[0]+ret2[0]
            return result

        return iter_dfs(root, p, q)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys;input = sys.stdin.readline;n, k = map(int, input().split());s = input()[:-1];left, right = 0, n
while left < right:
    mid = right - (right - left) // 2;A = [[0] * (n + 2) for _ in range(k)]
    for c in range(k):
        A[c][n] = A[c][n + 1] = n + 1;L = 0
        for i in range(n - 1, -1, -1):L = (L + 1 if s[i] == '?' or ord(s[i]) - ord('a') == c else 0);A[c][i] = i + mid if L >= mid else A[c][i + 1]
    dp = [n + 1] * (1 << k);dp[0] = 0
    for mask in range(1 << k):
        for i in range(k):
            if mask >> k & 1: continue
            t = mask | 1 << i;dp[t] = min(dp[t], A[i][dp[mask]])
    if dp[-1] <= n: left = mid
    else: right = mid - 1
print(left)",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def validPalindrome(self, s):
        def validPalindrome(s, left, right):
            while left < right:
                if s[left] != s[right]:
                    return False
                left, right = left+1, right-1
            return True

        left, right = 0, len(s)-1
        while left < right:
            if s[left] != s[right]:
                return validPalindrome(s, left, right-1) or validPalindrome(s, left+1, right)
            left, right = left+1, right-1
        return True",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin,stdout,setrecursionlimit
stdin.readline
def mp(): return list(map(int, stdin.readline().strip().split()))
def it():return int(stdin.readline().strip())
from collections import defaultdict as dd,Counter as C,deque
from math import ceil,gcd,sqrt,factorial,log2,floor
from bisect import bisect_right as br,bisect_left as bl
from heapq import *
mod = 10**9+7

def solve():
	n = it()
	v=[0]*(n+1)
	for i in range(1,n+1):
		v[i] = input()

	dp=[[0]*(n+2) for _ in range(n+1)]

	for l in range(n+2):
		dp[n][l] = 1

	for i in range(n-1,0,-1):
		curr_sum = 0
		for l in range(n):
			curr_sum += dp[i+1][l]
			curr_sum%=mod
			if v[i] == 'f':
				dp[i][l] = dp[i+1][l+1]
			else:
				dp[i][l]= curr_sum

	print(dp[1][0])

solve()
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,k = map(int,input().split())
B = [1]*(n+1)
B[0] = B[1] = 0
for i in range(2,n+1):
    if B[i] == 1:
        m = 2
        while m*i <= n:
            B[m*i] = 0
            m += 1
C = []
D = []
for i in range(len(B)):
    if B[i] != 0:
        D.append(i)
for i in range(1,len(D)):
    c = D[i] + D[i-1] + 1
    if c <= n:
        C.append(c)
x = 0
for i in range(len(C)):
    if B[C[i]] == 1:
        x += 1
if x >= k:
    print('YES')
else:
    print('NO')",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from math import gcd
from collections import defaultdict as dd
m=int(input())
d=dd(int)
l=[]
ans=[]
for i in range(m):
    s=input().split()[0]
    a=0
    b=0
    c=0
    n=len(s)
    ind=0
    for i in range(1,n):
        if(s[i]=='+'):
            ind=i+1
            break
        a=a*10+int(s[i])
    for i in range(ind,n):
        if(s[i]==')'):
            ind1=i+2
            break
        b=b*10+int(s[i])
    for i in range(ind1,n):
        c=c*10+int(s[i])
    a=a+b
    g=gcd(a,c)
    a=a//g
    c=c//g
    d[(a,c)]+=1
    l.append((a,c))
for i in l:
    ans.append(d[i])
print(*ans)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math
n,d=map(int,input().split())
p=list(map(int,input().split()))
q=[]
for i in range(len(p)-1):
    q.append(abs(p[i+1]-p[i]))
count=0

for k in q:
    if k==2*d:
        count+=1
    elif k>=2*d:
        count+=2

print(count+2)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def sortString(self, s):
        result, count = [], [0]*26
        for c in s:
            count[ord(c)-ord('a')] += 1
        while len(result) != len(s):
            for c in range(len(count)):
                if not count[c]:
                    continue
                result.append(chr(ord('a')+c))
                count[c] -= 1
            for c in reversed(range(len(count))):
                if not count[c]:
                    continue
                result.append(chr(ord('a')+c))
                count[c] -= 1
        return """".join(result)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
l=list(map(int,input().split()))
ans=0
m=[]
for i in range(2*n-1,-1,-1):
    if l[i] not in m:
        m.append(l[i])

for tt in range(0,n):
    i=m[tt]
    j=l.index(i)
    l.pop(j)
    k=l.index(i)
    l.insert(k,j)
    ans+=k-j
print(ans)
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = map(int,input().split())
arr = list(map(int, input().split()))

def find_segment(arr, n, k):
  f = [0]*100001
  L = count = 0
  R = -1
  while R < n-1:
    R += 1
    if f[arr[R]] == 0:
      count += 1
    f[arr[R]] += 1
    while count == k:
      f[arr[L]] -= 1
      if f[arr[L]] == 0:
        print(L+1, R+1)
        return
      L += 1
  print(-1,-1)
find_segment(arr, n, k)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = map(int, input().split())
a = list(map(int, input().split()))
sz = []
t = [1] * 11

cnt = dict()
for i in range(n):
    sz.append(len(str(a[i])))
    tmp = (sz[i], a[i] % k)
    if tmp in cnt:
        cnt[tmp] += 1
    else:
        cnt[tmp] = 1

t[0] = 1
for i in range(1, 11):
    t[i] = (t[i - 1] * 10) % k

ans = 0
for i in range(n):
    for l in range(1, 11):
        cur = (k - a[i] * t[l]) % k
        tmp = (l, cur)
        if tmp in cnt:
            ans += cnt[tmp]
        if (sz[i] == l and cur == a[i] % k):
            ans -= 1
print(ans)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os
import sys
from io import BytesIO, IOBase
from collections import Counter
import math as mt

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def lcm(a, b):
    return (a * b) / gcd(a, b)

mod = int(1e9) + 7

def power(k, n):
    if n == 0:
        return 1
    if n % 2:
        return (power(k, n - 1) * k) % mod
    t = power(k, n // 2)
    return (t * t) % mod

def totalPrimeFactors(n):
    count = 0
    if (n % 2) == 0:
        count += 1
        while (n % 2) == 0:
            n //= 2

    i = 3
    while i * i <= n:
        if (n % i) == 0:
            count += 1
            while (n % i) == 0:
                n //= i
        i += 2
    if n > 2:
        count += 1
    return count

def main():
    n, m=map(int, input().split())
    a=list(map(int, input().split()))
    k=a.index(m)
    t=[0]
    for i in range(k-1, -1, -1):
        z=-1 if a[i]<a[k] else 1
        t.append(t[-1]+z)
    d={0:1}
    now=0
    for i in range(k+1, n):
        now+=-1 if a[i]<a[k] else 1
        if now not in d.keys():
            d[now]=0
        d[now]+=1

    ans=0
    for i in t:
        if -i in d.keys():
            ans+=d[-i]
        if 1-i in d.keys():
            ans+=d[1-i]
    print(ans)

    return

if __name__ == ""__main__"":
    main()
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]

        memo = [[-1] * 2 for _ in range(len(nums))]

        def dfs(i, flag):
            if i >= len(nums) or (flag and i == len(nums) - 1):
                return 0
            if memo[i][flag] != -1:
                return memo[i][flag]
            memo[i][flag] = max(dfs(i + 1, flag),
                            nums[i] + dfs(i + 2, flag or (i == 0)))
            return memo[i][flag]

        return max(dfs(0, True), dfs(1, False))
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        res = 0
        q = deque()

        q.append((root,-float('inf')))

        while q:
            node,maxval = q.popleft()
            if node.val >= maxval:
                res += 1

            if node.left:
                q.append((node.left,max(maxval,node.val)))

            if node.right:
                q.append((node.right,max(maxval,node.val)))

        return res
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: a, b= map(int,input().split())

if a == b:
    print(0)

else:
    x = a ^ b
    c = 0

    while x:
        x //= 2
        c += 1

    print(2**c-1)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: l, r = map(int, input().split())

if l == r:
    print(0)
    exit()
binr, binl = list(bin(r)[2:]), list(bin(l)[2:])
binl = ['0'] * (len(binr) - len(binl)) + binl

for i in range(len(binl)):
    if binl[i] != binr[i]:
        binl = '1' * (len(binl[i:]))
        break

print(int(binl, 2))",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def minMeetingRooms(self, intervals: List[Interval]) -> int:
        mp = defaultdict(int)
        for i in intervals:
            mp[i.start] += 1
            mp[i.end] -= 1
        prev = 0
        res = 0
        for i in sorted(mp.keys()):
            prev += mp[i]
            res = max(res, prev)
        return res
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
import math
import itertools
import functools
import collections
import operator

def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def wr(arr): return ' '.join(map(str, arr))
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=1):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)

n, k = mi()
t = math.ceil(math.sqrt(2 * (n + k) + 2.25) - 1.5)
print(n - t)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin
input=stdin.readline
def answer():
    dp=[[[1e9 for i in range(k//2 + 1)] for j in range(m)] for i in range(n)]

    for i in range(n):
        for j in range(m):
            dp[i][j][0]=0

    for x in range(1,k//2 + 1):

        for i in range(n):
            for j in range(m):

                if(i > 0):
                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1] + c[i-1][j])
                if(j > 0):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1] + r[i][j-1])
                if(i + 1 < n):
                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1] + c[i][j])
                if(j + 1 < m):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1] + r[i][j])

    for i in range(n):
        for j in range(m):
            print(2*dp[i][j][-1],end=' ')

        print()

n,m,k=map(int,input().split())

r=[list(map(int,input().split())) for i in range(n)]
c=[list(map(int,input().split())) for i in range(n-1)]

if(k & 1):
    for i in range(n):
        for j in range(m):
            print(-1,end=' ')

else:answer()
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import defaultdict
from sys import stdin
input = stdin.readline
def check(mid, m):
    d = defaultdict(int)
    for idx, i in enumerate(a):
        string = ''
        for j in i:
            if j >= mid:
                string+='1'
            else:
                string+='0'
        d[int(string, 2)] = idx
    for i in d.keys():
        for j in d.keys():
            if i|j == 2**m - 1:
                 return [d[i], d[j]]
    return []
def binarySearch(lo, hi, m):
    ans = []
    while lo < hi:
        mid = lo + (hi-lo+1)//2
        x = check(mid, m)
        if x:
            lo = mid
            ans = [x[0]+1, x[1]+1]
        else:
            hi = mid-1
    mid = lo + (hi-lo+1)//2
    x = check(mid, m)
    if x:
        ans = [x[0]+1, x[1]+1]
    return ans
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
print(*binarySearch(0, 10**9, m))",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def dominantIndex(self, nums):
        m = max(nums)
        if all(m >= 2*x for x in nums if x != m):
            return nums.index(m)
        return -1",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def getSmallestString(self, n, k):
        MAX_DIFF = ord('z')-ord('a')

        k -= n
        result = ['a']*n
        for i in reversed(range(n)):
            tmp = min(k, MAX_DIFF)
            result[i] = chr(ord('a')+tmp)
            k -= tmp
            if k == 0:
                break
        return """".join(result)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import itertools


class Solution2(object):
    def restoreString(self, s, indices):
        result = ['']*len(s)
        for i, c in zip(indices, s):
            result[i] = c
        return """".join(result)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: l,r = map(int,input().split())
if l%2:
    l+=1
if r-l<2:
    print(-1)
else:
    print(l,l+1,l+2)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: a, b, c, d, e, f = list(map(int, input().split()))
n, n2 = 1, a * b + c * d + e * f
while n ** 2 < n2:
    n += 1
if n ** 2 > n2:
    print(-1)
    exit()
l = sorted([[max(a, b), min(a, b), 'A'], [max(c, d), min(c, d), 'B'], [max(e, f), min(e, f), 'C']])
if l[2][0] != n:
    print(-1)
    exit()
v = str(n) + '\n' + (l[2][2] * n + '\n') * l[2][1]
if l[0][0] == n and l[1][0] == n:
    for i in range(2):
        v += (l[i][2] * n + '\n') * l[i][1]
else:
    s = n - l[2][1]
    if s not in l[0] or s not in l[1]:
        print(-1)
        exit()
    x, y = l[0][1] if l[0][0] == s else l[0][0], l[1][1] if l[1][0] == s else l[1][0]
    v += (l[0][2] * x + l[1][2] * y + '\n') * s
print(v)",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import deque
n=int(input())
orderedli=list(map(int,input().split("" "")))

indexof={}
for i,x in enumerate(orderedli):
    indexof[x]=i+1

sortedli=list(sorted(orderedli))
i=0

s=input()

st=deque()

for x in s:
    if x==""0"":
        st.append(sortedli[i])
        print(indexof[sortedli[i]],end="" "")
        i += 1
    else:
        temp=st.pop()
        print(indexof[temp],end="" "")
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math
import random
import heapq,bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict
threading.stack_size(10**8)
mod = 10 ** 9 + 7
mod1 = 998244353

import os
import sys
from io import BytesIO, IOBase
sys.setrecursionlimit(300000)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1

class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):

        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n

class SegmentTree1:
    def __init__(self, data, default=2**51, func=lambda a, b: a & b):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a,b:max(a,b)):

        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]

class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD

def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m

def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z

def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por

def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        else:
            right = mid - 1

    return count

def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    leftGreater = n

    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        else:
            l = m + 1

    return (n - leftGreater)

for ik in range(1):
    n,k=map(int,input().split())
    cards=list(map(int,input().split()))
    l=list(map(int,input().split()))
    h=list(map(int,input().split()))
    h=[0]+h
    count=defaultdict(int)
    rt=defaultdict(int)
    def find(x,y):
        dp=[[0 for i in range(y+1)]for i in range(x+1)]
        for i in range(1,x+1):
            for j in range(y+1):
                for t in range(min(j+1,k+1)):
                    dp[i][j]=max(dp[i][j],dp[i-1][j-t]+h[t])
        return dp[x][y]
    for i in range(n*k):
        count[cards[i]]+=1
    for i in range(n):
        rt[l[i]]+=1
    ans=0
    for i in rt:
        if count[i]==0:
            continue
        ans+=find(rt[i],count[i])
    print(ans)",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,m=map(int,input().split())

vert=[]

for i in range(n):
    v=int(input())
    vert.append(v)

horz=[]

for i in range(m):
    x1,x2,y=map(int,input().split())
    if x1==1:
        horz.append(x2)

vert.sort()
horz.sort()

vert.append(1000000000)

def next(k,a,x):
    while k<len(a) and a[k]<x:
        k+=1
    return k

num=next(0,horz,vert[0])

ans=len(horz)-num

for i in range(1,len(vert)):
    num2=next(num,horz,vert[i])
    t=i+len(horz)-num2
    if t<ans: ans=t
    num=num2

print(ans)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import itertools


class Solution(object):
    def minSwaps(self, grid):
        result = 0
        for target in reversed(range(1, len(grid))):
            row_idx = len(grid)-1-target
            while row_idx < len(grid):
                row = grid[row_idx]
                if not sum(itertools.islice(row, len(row)-target, len(row))):
                    break
                row_idx += 1
            else:
                return -1
            while row_idx != len(grid)-1-target:
                grid[row_idx], grid[row_idx-1] = grid[row_idx-1], grid[row_idx]
                result += 1
                row_idx -= 1
        return result",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os,sys
from io import BytesIO,IOBase
from array import array

def main():
    n,M = map(int,input().split())
    comb = [[0]*(n+1) for _ in range(n+1)]
    comb[0][0] = 1
    for i in range(1,n+1):
        for j in range(i+1):
            comb[i][j] = (comb[i-1][j]+comb[i-1][j-1])%M

    dp = [array('i',[0]*(n+1)) for _ in range(n+1)]

    for i in range(1,n+1):
        dp[i][0] = pow(2,i-1,M)
    for j in range(1,n+1):
        for i in range(3,n+1):
            for x in range(1,i-1):
                dp[i][j] = (dp[i][j]+dp[i-1-x][j-1]*dp[x][0]*comb[i-j][x])%M
    su = 0
    for i in range(n+1):
        su = (su+dp[n][i])%M
    print(su)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def minBitFlips(self, start, goal):
        return bin(start^goal).count('1')",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def edgeScore(self, edges):
        score = [0]*len(edges)
        for u, v in enumerate(edges):
            score[v] += u
        return max(range(len(edges)), key=lambda x:score[x])",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections


class Solution(object):
    def stoneGameIX(self, stones):
        count = collections.Counter(x%3 for x in stones)
        if count[0]%2 == 0:
            return count[1] and count[2]
        return abs(count[1]-count[2]) >= 3",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
input=sys.stdin.readline
n=int(input())
a=list(map(int,input().split()))
f=[[0]*n for i in range(n)]
for i in range(n):
    f[0][i]=a[i]
for i in range(1,n):
    for j in range(n-i):
        f[i][j]=f[i-1][j]^f[i-1][j+1]
for i in range(1,n):
    for j in range(n-i):
        f[i][j]=max(f[i][j],f[i-1][j],f[i-1][j+1])
q=int(input())
for _ in range(q):
    l,r=map(int,input().split())
    print(f[r-l][l-1])",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: A = list(map(int, input().split()))

ans = 0
for i in range(14):
    if A[i] == 0:
        continue
    B = A+A
    B[i+14] = 0
    q, r = divmod(B[i], 14)
    for j in range(1, 15):
        if j <= r:
            B[i+j] += (q+1)
        else:
            B[i+j] += q

    temp = 0
    for j in range(i+1, i+15):
        if B[j]%2 == 0:
            temp += B[j]
    ans = max(ans, temp)
print(ans)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def nthPersonGetsNthSeat(self, n):
        return 0.5 if n != 1 else 1.0",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, m = map(int, input().split())
a = [int(i) for i in input().split()]
b = [int(i) for i in input().split()]
for i in a:
    if i in b:
        print(i, end=' ')",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :

    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r')
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w')
    atexit.register(lambda :sys.stdout.close())

N, = getIntList()

za = getIntList()
if N==1:
    print(za[0])
    sys.exit()
t1 = max(za)
t2 = min(za)
if t2>=0:
    print(sum(za) - 2*t2)
    sys.exit()
if t1<=0:
    print(2*t1 - sum(za))
    sys.exit()

res = 0
for x in za:
    res+= abs(x)

print(res)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution3(object):
    def countQuadruplets(self, nums):
        left = [[0]*(len(nums)+1) for _ in range(len(nums))]
        for j in range(len(nums)):
            for i in range(j):
                left[j][i+1] = left[j][i] + int(nums[i] < nums[j])
        right = [[0]*(len(nums)+1) for _ in range(len(nums))]
        for j in range(len(nums)):
            for i in reversed(range(j+1, len(nums))):
                right[j][i] = right[j][i+1] + int(nums[i] > nums[j])
        result = 0
        for k in range(len(nums)):
            for j in range(k):
                if nums[k] < nums[j]:
                    result += left[k][j]*right[j][k+1]
        return result",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections
import functools


class Solution2(object):
    def checkEquivalence(self, root1, root2):
        def add_counter(counter, prev, d, val):
            if val.isalpha():
                counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d
            prev[0] = val

        def inorder_traversal(root, cb):
            def traverseLeft(node, stk):
                while node:
                    stk.append(node)
                    node = node.left 

            stk = []
            traverseLeft(root, stk)
            while stk:
                curr = stk.pop()
                cb(curr.val)
                traverseLeft(curr.right, stk)
                
        counter = collections.defaultdict(int)
        inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1))
        inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1))
        return all(v == 0 for v in counter.values())",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def binarySearch (N,l,r,x):
    if r >= l:
        mid = l + (r - l)//2
        Temp = (mid*(mid+1))//2
        if Temp-x == N-mid:
            return N-mid
        elif Temp-x > N-mid:
            return binarySearch(N,l, mid-1, x)
        else:
            return binarySearch(N,mid + 1, r, x)
    else:
        return -1
n,k=list(map(int,input().split()))
print(binarySearch (n,0,n,k))",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import deque

def top_sort():
    global dag, top, g, n
    q = deque()
    cnt = 0

    for i in range(1, n+1):
        if not dag[i]:
            q.append(i)

    while len(q):
        u = q.popleft()
        cnt += 1
        top[u] = cnt
        for to in g[u]:
            dag[to] -= 1
            if dag[to] == 0:
                q.append(to)
    return cnt == n

def check(mid):
    global n, m, g, u, v, c, dag
    for i in range(1, n+1):
        g[i].clear()
        dag[i] = 0
    for i in range(1, m+1):
        if c[i] > mid:
            g[u[i]].append(v[i])
            dag[v[i]] += 1
    return top_sort()

def input_t():
    return [int(x) for x in input().split()]

MAX = int(10e5 + 42)
n, m = input_t()
r = 0
u, v, c = [0] * MAX, [0] * MAX, [0] * MAX
g, dag, top = [[]  for _ in range(MAX)], [0] * MAX, [0] * MAX
cnt = 0

for i in range(1, m + 1):
    u[i], v[i], c[i] = input_t()
    r = max(r, c[i])

l = 0

while l < r:
    mid = (l+r) >> 1
    if check(mid):
        r = mid
    else:
        l = mid + 1

check(l)
for i in range(1, m+1):
    if c[i] <= l and top[v[i]] < top[u[i]]:
        cnt += 1
print(f""{l} {cnt}"")
for i in range(1, m+1):
    if c[i] <= l and top[v[i]] < top[u[i]]:
        print(i, end="" "")
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: a,b,c,n = map(int,input().split())
a-=c
b-=c
if a>=0 and b>=0:
    if (a+b+c)<n:
        n-=(a+b+c)
        print(n)
    else:
        print(-1)
else:
    print(-1)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution4(object):
    def rotate(self, nums, k):
        nums[:] = nums[len(nums) - k:] + nums[:len(nums) - k]",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def sumOfBeauties(self, nums):
        right = [nums[-1]]*len(nums)
        for i in reversed(range(2, len(nums)-1)):
            right[i] = min(right[i+1], nums[i])
        result, left = 0, nums[0]
        for i in range(1, len(nums)-1):
            if left < nums[i] < right[i+1]:
                result += 2
            elif nums[i-1] < nums[i] < nums[i+1]:
                result += 1
            left = max(left, nums[i])
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
l = sorted(map(int, input().split()))
seen = [False] * n
res = 0
for i in range(n):
    if seen[i]: continue
    res += 1
    for j in range(i, n):
        seen[j] |= l[j] % l[i] == 0
print(res)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = map(int, input().strip().split())
data = map(int, input().strip().split())
sol = []
mapping = [(-1,1000)]*256
for x in data:
    if mapping[x][0] == -1:
        for i in range(max(x-k+1,0), x+1):
            if mapping[i][0] == -1:
                if i > 0 and mapping[i-1][1]+(x-i+1) <= k:
                    p = mapping[i-1][1]+1
                    for j in range(i, x+1):
                        mapping[j] = (mapping[i-1][0], p)
                        p += 1
                else:
                    p = 1
                    for j in range(i, x+1):
                        mapping[j] = (i, p)
                        p += 1
                break
    sol.append(mapping[x][0])
print(' '.join(map(str, sol)))",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None



class Solution(object):
    def balanceBST(self, root):
        def inorderTraversal(root):
            result, stk = [], [(root, False)]
            while stk:
                node, is_visited = stk.pop()
                if node is None:
                    continue
                if is_visited:
                    result.append(node.val)
                else:
                    stk.append((node.right, False))
                    stk.append((node, True))
                    stk.append((node.left, False))
            return result
    
        def sortedArrayToBst(arr):
            ROOT, LEFT, RIGHT = list(range(3))
            result = [None]
            stk = [(0, len(arr), ROOT, result)]
            while stk:
                i, j, update, ret = stk.pop()
                if i >= j:
                    continue
                mid = i + (j-i)//2
                node = TreeNode(arr[mid])
                if update == ROOT:
                    ret[0] = node
                elif update == LEFT:
                    ret[0].left = node
                else:
                    ret[0].right = node
                stk.append((mid+1, j, RIGHT, [node]))
                stk.append((i, mid, LEFT, [node]))
            return result[0]
        
        return sortedArrayToBst(inorderTraversal(root))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())

d = {}

for i in range(n-1):
	a,b = map(int,input().split())

	try:
		d[a].append(b);
	except:
		d[a] = [b]
	try:
		d[b].append(a);
	except:
		d[b] = [a]

array = list(map(int,input().split()))
flag=0;

if array[0]==1:

	i = 1;
	j = 0;

	while ( j < n and i < n ):
		if ( array[j] in d[array[i]] ):
			i+=1;
		else:
			j+=1;
	if j==n and i!=n:
		flag=1;
else:
	flag=1;

if flag==1:
	print(""No"")
else:
	print(""Yes"")",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def minMaxGame(self, nums):
        q = nums[:]
        while len(q) != 1:
            new_q = []
            for i in range(len(q)//2):
                new_q.append(min(q[2*i], q[2*i+1]) if i%2 == 0 else max(q[2*i], q[2*i+1]))
            q = new_q
        return q[0]",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    head = None
    def sortedListToBST(self, head):
        current, length = head, 0
        while current is not None:
            current, length = current.__next__, length + 1
        self.head = head
        return self.sortedListToBSTRecu(0, length)

    def sortedListToBSTRecu(self, start, end):
        if start == end:
            return None
        mid = start + (end - start) / 2
        left = self.sortedListToBSTRecu(start, mid)
        current = TreeNode(self.head.val)
        current.left = left
        self.head = self.head.__next__
        current.right = self.sortedListToBSTRecu(mid + 1, end)
        return current",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def findNumberOfLIS(self, nums):
        result, max_len = 0, 0
        dp = [[1, 1] for _ in range(len(nums))] 
        for i in range(len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    if dp[i][0] == dp[j][0]+1:
                        dp[i][1] += dp[j][1]
                    elif dp[i][0] < dp[j][0]+1:
                        dp[i] = [dp[j][0]+1, dp[j][1]]
            if max_len == dp[i][0]:
                result += dp[i][1]
            elif max_len < dp[i][0]:
                max_len = dp[i][0]
                result = dp[i][1]
        return result",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def catchMaximumAmountofPeople(self, team, dist):
        result = j = 0
        for i in range(len(team)):
            if not team[i]:
                continue
            while j < i-dist:
                j += 1
            while j <= min(i+dist, len(team)-1):
                if team[j] == 0:
                    break
                j += 1
            if j <= min(i+dist, len(team)-1):
                result += 1
                j += 1
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from math import gcd
n, x, y = map(int, input().split())

def solve(n, x, y):
    g = gcd(x, y)
    if gcd(x, y) != 1:
        return solve(n // g + 1, x // g, y // g) * (n % g) + solve(n // g, x // g, y // g) * (g - n % g)
    ans = 0
    for s in [0, 1]:
        dp = [-n, -n]
        dp[s] = 0
        for i in range(x + y):
            dp = [max(dp[0], dp[1]), dp[0] + (n // (x + y)) + (i * x % (x + y) < n % (x + y))]
        ans = max(ans, dp[s])
    return ans

print(solve(n, x, y))",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def find132pattern(self, nums):
        ak = float(""-inf"")
        stk = []
        for i in reversed(range(len(nums))):
            if nums[i] < ak:
                return True
            while stk and stk[-1] < nums[i]:
                ak = stk.pop()
            stk.append(nums[i])
        return False",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
m = int(input())
print(m % (2**n ))",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def sumDistance(self, nums, s, d):
        MOD = 10**9+7
        for i in range(len(nums)):
            nums[i] += d if s[i] == 'R' else -d
        nums.sort()
        return reduce(lambda x, y: (x+y)%MOD, ((i-(len(nums)-(i+1)))*x for i, x in enumerate(nums)))",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: x,y,z,t1,t2,t3 = map(int, input().split())
stairs = abs(x - y) * t1
lift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3
print('YES' if lift <= stairs else 'NO')",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
from collections import defaultdict

readline=sys.stdin.readline

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N,Q=map(int,readline().split())
P=Prime(5*10**5)
mebius=[0]+[P.Mebius(i) for i in range(1,5*10**5+1)]
cnt=[0]*(5*10**5+1)
ans=0
A=list(map(int,readline().split()))
used=[False]*(N)
for _ in range(Q):
    q=int(readline())-1
    prime=list(P.Factorize(A[q]).keys())
    l=len(prime)
    for bit in range(1<<l):
        s=1
        for i in range(l):
            if bit>>i&1:
                s*=prime[i]
        if used[q]:
            cnt[s]-=1
            ans-=cnt[s]*mebius[s]
        else:
            ans+=cnt[s]*mebius[s]
            cnt[s]+=1
    if used[q]:
        used[q]=False
    else:
        used[q]=True
    print(ans)",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
from collections import defaultdict

input = sys.stdin.readline

def main():
    N = int(input())
    A = list(map(int, input().split()))

    sum_A = sum(A)
    cnt = defaultdict(int)
    for a in A:
        cnt[a] += 1

    ans = 0
    for i in range(N):
        a = A[i]
        cnt[a] -= 1
        sum_A -= a

        tmp = sum_A
        n = 0
        for b in (a-1, a, a+1):
            n += cnt[b]
            tmp -= b * cnt[b]
        ans += tmp - a * (N-1-i-n)
    print(ans)

if __name__ == ""__main__"":
    main()
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os
import sys
from io import BytesIO, IOBase
import heapq as h
from bisect import bisect_left

from types import GeneratorType
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

import time
start_time = time.time()

import collections as col
import math, string
from functools import reduce

def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())

def solve():
    L, R = getInts()
    if L == R:
        return 0
    l = len(bin(L)[2:])
    r = len(bin(R)[2:])
    while l == r:
        L -= pow(2,r-1)
        R -= pow(2,r-1)
        l = len(bin(L)[2:])
        r = len(bin(R)[2:])
    return pow(2,r)-1

print(solve())
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,least,most,x = map(int,input().split())
c = list(map(int,input().split()))

ans= 0
_max = lambda x,y: x if x>y else y
_min = lambda x,y: x if x<y else y

for mask in range(1<<n):
    mx = float('-inf')
    mn = float('inf')
    count = 0
    Sum = 0
    for i in range(n):
        if mask&(1<<i):
            count+=1
            Sum+=c[i]
            mx = _max(mx,c[i])
            mn = _min(mn,c[i])
    if mx-mn>=x and Sum>=least and Sum<=most and count >=2:
        ans+=1
print(ans)
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: a,b,c,n = map(int,input().split())
if c > a or c > b or (a+b) - c >=n:
    print(-1)
else:
    print(n -((a+b)-c))",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def isSubsequence(self, s, t):
        if not s:
            return True

        i = 0
        for c in t:
            if c == s[i]:
                i += 1
            if i == len(s):
                break
        return i == len(s)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
ans = 0
if n==1:
    print(1)
    exit()
if n==2:
    print(2)
    exit()
if n==3:
    print(6)
    exit()
if n%2==0:
    if n%3==0:
        ans=(n-1)*(n-2)*(n-3)
    else:
        ans=n*(n-1)*(n-3)
else:
    ans=n*(n-1)*(n-2)

print(ans)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def solve():
	r,g,b=map(int,input().split())
	R=list(map(int,input().split()))
	G=list(map(int,input().split()))
	B=list(map(int,input().split()))
	R.sort(reverse=True)
	G.sort(reverse=True)
	B.sort(reverse=True)
	dp=[[[0]*(b+1) for _ in range(g+1)]for _ in range(r+1)]
	for i in range(r+1):
		for j in range(g+1):
			for k in range(b+1):
				if i<r and j<g:
					dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
				if i<r and k<b:
					dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
				if j<g and k<b:
					dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+B[k]*G[j])
	ans=0
	for i in range(r+1):
		for j in range(g+1):
			for k in range(b+1):
				ans=max(ans,dp[i][j][k])
	return ans
print(solve())",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from math import gcd

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""right"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\right\n"")

def func(left:int, right:int):
    if left == 1:
        left += 1
    if right - left < 2:
        return -1

    if left & 1:
        if right - left > 2:
            left += 1
            return '{} {} {}'.format(left, left + 1, left + 2)
        else:
            if gcd(left, left + 2) != 1:
                return '{} {} {}'.format(left, left + 1, left + 2)
            return -1
    return '{} {} {}'.format(left, left + 1, left + 2)

def main():
    left, right = map(int, input().split())
    print(func(left, right))
    return

if __name__ == '__main__':
    main()
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def pow1(n, k):
    if k == 0:
        return 1
    if k == 1:
        return n
    else:
        if k % 2 == 0:
            a = pow1(n, k // 2) % mod
            return a * a % mod
        else:
            return pow1(n, k - 1) % mod * n % mod

mod = 10 ** 9 + 7
n, k = map(int, input().split())
if n == 0:
    print(0)
else:
    x = pow1(2, k + 1) % mod
    print(((n * x - pow1(2, k) + 1)) % mod)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def decimal_to_26(num):
    num = int(num)
    res = ''
    while num:
        mod = num % 26
        if mod == 0:
            res = 'Z' + res
            num = num // 26 - 1
        else:
            num //= 26
            res = chr(mod+64) + res
    return res

def RXCY_to_Excel(c,r):
    new_row = decimal_to_26(r)
    return new_row + str(c)

n = int(input())
li = []
for i in range(n):
    li.append(input())
for i in li:
    di_index = []
    al_index = []
    temp = i
    for j in range(len(i)):
        if i[j].isalpha():
            al_index.append(j)
            i = i.replace(i[j],' ')

        elif i[j].isdigit():
            di_index.append(j)
            i = i.replace(i[j],' ')

    i = temp
    if min(di_index) < max(al_index):

        row = int(i[1:i.index('C')])
        col = int(i[i.index('C')+1:])

        print(RXCY_to_Excel(row,col))
    else:
        row_num = 0
        for k in range(len(i)):
            if i[k].isdigit():
                num_start = k
                break

        length = len(i[0:k])

        for m in range(num_start):
            row_num += 26 ** (length-1) * (ord(i[m])-64) or (ord(i[m])-64)

            length -= 1
        print('R'+i[num_start:]+'C'+str(row_num))
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import string

n, s, t = int(input()), input(), input()
x, i, j = 0, -1, -1
sc_dict = {c: set() for c in string.ascii_lowercase}
tc_dict = {c: set() for c in string.ascii_lowercase}
sti_dict, tsi_dict = dict(), dict()

for ci, sc, tc in zip(range(n), s, t):
    if sc == tc:
        continue
    sc_dict[sc].add(tc)
    tc_dict[tc].add(sc)
    sti_dict[sc + tc] = ci
    tsi_dict[tc + sc] = ci
    x += 1

for c in string.ascii_lowercase:
    cs = sc_dict[c] & tc_dict[c]
    if not cs:
        continue
    c2 = cs.pop()
    x -= 2
    i = sti_dict[c + c2] + 1
    j = tsi_dict[c + c2] + 1
    break
else:
    for c in string.ascii_lowercase:
        if not sc_dict[c] or not tc_dict[c]:
            continue
        x -= 1
        i = sti_dict[c + sc_dict[c].pop()] + 1
        j = tsi_dict[c + tc_dict[c].pop()] + 1
        break

print(x)
print(i, j)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
print((n//2)+1)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n , m=map(int,input().split())
l1=list(map(int,input().split()))
l2=list(map(int,input().split()))
l3=[]
for i in range(n):
    for j in range(m):
        if l1[i]==l2[j]:
            if l1[i] is not l3:
                l3.append(l1[i])
print(*l3)
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def divideArray(self, nums, k):
        nums.sort()
        return [nums[i:i+3] for i in range(0, len(nums), 3)] if all(nums[i+2]-nums[i] <= k for i in range(0, len(nums), 3)) else []",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def main():
    n, m, k = map(int, input().split())
    inf = 1 << 30
    left = [list(map(int, input().split())) for i in range(n)]
    down = [list(map(int, input().split())) for i in range(n-1)]
    if k & 1:
        for i in range(n):
            print(*[-1]*m)
        exit()
    ans = [[0]*m for i in range(n)]
    for k in range(1, k//2+1):
        _ = [[inf]*m for ii in range(n)]
        for i in range(n):
            for j in range(m):
                if i:
                    _[i][j] = min(_[i][j], ans[i-1][j]+down[i-1][j])
                if i < n-1:
                    _[i][j] = min(_[i][j], ans[i+1][j]+down[i][j])
                if j:
                    _[i][j] = min(_[i][j], ans[i][j-1]+left[i][j-1])
                if j < m-1:
                    _[i][j] = min(_[i][j], ans[i][j+1]+left[i][j])
        ans = _
    for i in range(n):
        for j in range(m):
            print(ans[i][j]*2, end=' ')
        print()

if __name__ == '__main__':
    main()
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: nr, ng, nb = map(int, input().split())
r = sorted([int(i) for i in input().split()])
g = sorted([int(i) for i in input().split()])
b = sorted([int(i) for i in input().split()])

dp = [[[0 for _ in range(nb + 1)] for _ in range(ng + 1)] for _ in range(nr + 1)]
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            val = 0
            if i - 1 >= 0 and j - 1 >= 0:
                val = max(val, r[i - 1] * g[j - 1] + dp[i - 1][j - 1][k])
            if i - 1 >= 0 and k - 1 >= 0:
                val = max(val, r[i - 1] * b[k - 1] + dp[i - 1][j][k - 1])
            if j - 1 >= 0 and k - 1 >= 0:
                val = max(val, g[j - 1] * b[k - 1] + dp[i][j - 1][k - 1])
            dp[i][j][k] = val

print(dp[nr][ng][nb])
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def balance(x1, y1, x2, y2):
    return min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)

def get_lr():
    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 2:
            l = m
        else:
            r = m
    r2 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = n, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res == 2:
            l = m
        else:
            r = m
    l2 = l

    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 1:
            l = m
        else:
            r = m
    r1 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = n, 1, m, n
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res >= 1:
            l = m
        else:
            r = m
    l1 = l
    return r1, r2, l2, l1

def get_ud():
    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 2:
            l = m
        else:
            r = m
    r2 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, n, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res == 2:
            l = m
        else:
            r = m
    l2 = l

    l, r = 0, n
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, 1, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res < 1:
            l = m
        else:
            r = m
    r1 = r
    l, r = 1, n + 1
    while r - l > 1:
        m = (r + l) // 2
        x1, y1, x2, y2 = 1, n, n, m
        x1, y1, x2, y2 = balance(x1, y1, x2, y2)
        print('?', x1, y1, x2, y2)
        res = int(input())
        if res >= 1:
            l = m
        else:
            r = m
    l1 = l
    return r1, r2, l2, l1

n = int(input())
lr = get_lr()
ud = get_ud()
rr = [lr[0], lr[1]]
ll = [lr[2], lr[3]]
uu = [ud[0], ud[1]]
dd = [ud[2], ud[3]]
for r1 in rr:
    r2 = rr[0] if rr[0] != r1 else rr[1]
    for l1 in ll:
        l2 = ll[0] if ll[0] != l1 else ll[1]
        for u1 in uu:
            u2 = uu[0] if uu[0] != u1 else uu[1]
            for d1 in dd:
                d2 = dd[0] if dd[0] != d1 else dd[1]
                if r1 < l1 or r2 < l2 or u1 < d1 or u2 < d2:
                    continue
                print('?', l1, d1, r1, u1)
                res1 = int(input())
                print('?', l2, d2, r2, u2)
                res2 = int(input())
                if res1 == res2 == 1:
                    print('!', l1, d1, r1, u1, l2, d2, r2, u2)
                    __import__('sys').exit(0)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())

a = input().split()

for i in range(n):
    a[i] = int(a[i])

if(n==1):
    print(a[0])
else:
    sm = 0
    havePositive = False
    haveNegative = False

    for c in a:
        if(c==0):
            haveNegative = True
            havePositive = True
        elif(c>0):
            havePositive = True
            sm += c
        else:
            haveNegative = True
            sm -= c

    if(haveNegative and havePositive):
        print(sm)
    else:
        for i in range(n):
            a[i] = abs(a[i])

        ans = sum(a)
        low = a[0]
        for c in a:
            low = min(low,c)

        print(ans-2*low)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))

def modInverse(a , m):
	m0 = m
	y = 0
	x = 1
	if (m == 1):
		return 0
	while (a > 1):
		q = a // m
		t = m
		m = a % m
		a = t
		t = y
		y = x - q * y
		x = t
	if (x < 0):
		x = x + m0
	return x

def num():
	return map(int , input().split())

def nu():
	return int(input())

def find_gcd(x , y):
	while (y):
		x , y = y , x % y
	return x

n,m=num()
a=[0]*n
for i in range(n):
	a[i]=[0]*m
for i in range(n):
	s=input()
	for j in range(m):
		a[i][j]=s[j]
z=["".""]*n
for i in range(n):
	z[i]=["".""]*m
for i in range(n):
	for j in range(m):
		if(j-1>=0 and j+1 <m and i+1<n and i-1>=0):
			if(a[i-1][j]==""
				z[i-1][j]=""
				z[i + 1][j] = ""
				z[i][j - 1] = ""
				z[i][j + 1] = ""
				z[i - 1][j - 1] = ""
				z[i - 1][j + 1] = ""
				z[i + 1][j - 1] = ""
				z[i + 1][j + 1] = ""
ff=True

for i in range(n):
	for j in range(m):
		if(z[i][j]!=a[i][j]):
			ff=False
			break
if(ff):
	print(""YES"")
else:
	print(""NO"")",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = map(int, raw_input().split())
a = map(int, raw_input().split())
for i in range(n):
    ai = a[i]
    nai = ((1<<k) - 1)^ai
    if nai < ai:
        a[i] = nai

from collections import Counter
C = Counter()
C[0] += 1
S = 0
cnt = 0
for j, ai in enumerate(a):
    nai = ((1<<k) - 1)^ai
    v1, v2 = C[S^ai], C[S^nai]
    if v1 <= v2:
        cnt += j + 1 - v1
        S ^= ai
        C[S] += 1
    else:
        cnt += j + 1 - v2
        S ^= nai
        C[S] += 1
print(cnt)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
ax, ay = list(map(int, input().split(' ')))
bx, by = list(map(int, input().split(' ')))
cx, cy = list(map(int, input().split(' ')))

if ((cx < ax) == (bx < ax)) and ((cy < ay) == (by < ay)):
    print('YES')
else:
    print('NO')",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def getStrongest(self, arr, k):
        arr.sort()
        m = arr[(len(arr)-1)//2]
        arr.sort(key=lambda x: (-abs(x-m), -x))
        return arr[:k]",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def escapeGhosts(self, ghosts, target):
        total = abs(target[0])+abs(target[1])
        return all(total < abs(target[0]-i)+abs(target[1]-j) for i, j in ghosts)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def incremovableSubarrayCount(self, nums):
        return sum((left == 0 or right == len(nums)-1 or nums[left-1] < nums[right+1]) and
                   all(nums[i] < nums[i+1] for i in range(left-1)) and
                   all(nums[i] < nums[i+1] for i in range(right+1, len(nums)-1))
                   for left in range(len(nums)) for right in range(left, len(nums)))",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: l,r = [int(x) for x in input().split()]
if l==r or l+1==r:
    print(-1)
elif l%2==0:
    print(l,l+1,l+2)
elif l%2!=0 and r-l+1>3:
    print(l+1,l+2,l+3)
else:
    print(-1)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x]) 
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def earliestAcq(self, logs, N):
        logs.sort()
        union_find = UnionFind(N)
        for t, a, b in logs:
            union_find.union_set(a, b)
            if union_find.count == 1:
                return t
        return -1",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solver:
    def solve(self):
        self.num_people = int(input())

        if self.num_people % 4 == 2:
            return -1

        return self.find_zero_pair()

    def find_zero_pair(self):
        begin = 1
        end = self.num_people // 2 + 1

        begin_value = self.func(begin)
        if begin_value == 0:
            return begin

        while begin < end:
            mid = (begin + end) // 2
            mid_value = self.func(mid)
            if mid_value == 0:
                return mid
            elif begin_value * mid_value > 0:
                begin = mid + 1
            else:
                end = mid - 1

        return begin

    def func(self, pos):
        opposite = (pos - 1 + self.num_people // 2) % self.num_people + 1
        return self.get_value(pos) - self.get_value(opposite)

    def get_value(self, pos):
        print('? {}'.format(pos))
        value = int(input())
        return value

solver = Solver()
pair = solver.solve()
print('! {}'.format(pair))
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: 
class Solution(object):
    def spellchecker(self, wordlist, queries):
        vowels = set(['a', 'e', 'i', 'o', 'u'])
        def todev(word):
            return """".join('*' if c.lower() in vowels else c.lower()
                           for c in word)

        words = set(wordlist)
        caps = {}
        vows = {}

        for word in wordlist:
            caps.setdefault(word.lower(), word)
            vows.setdefault(todev(word), word)

        def check(query):
            if query in words:
                return query
            lower = query.lower()
            if lower in caps:
                return caps[lower]
            devow = todev(lower)
            if devow in vows:
                return vows[devow]
            return """"
        return list(map(check, queries))
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def constructGridLayout(self, n, edges):
        def bfs(u):
            dist = [0]*n
            dist[u] = 1
            q = [u]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[v]:
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                q = new_q
            return dist
    
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        mn = min(len(x) for x in adj)
        corners = [u for u in range(n) if len(adj[u]) == mn]
        dist1 = bfs(corners[0])
        corners.sort(key=lambda x: dist1[x])
        dist2 = bfs(corners[1])
        c = dist1[corners[1]]
        r = n//c
        result = [[0]*c for _ in range(r)]
        for u in range(n):
            i = ((dist1[u]+dist2[u])-(1+c))//2
            j = (dist1[u]-1)-i
            result[i][j] = u
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: k,n,s,p=map(int,input().split(' '))
if (1*n)%s==0:
    need=(1*n)//s
    if need==0 and k%p==0:
        print(k//p)
    elif (k*need)%p==0:
        print((k*need)//p)
    else:
        print(((k*need)//p)+1)
else:
    need=((1*n)//s)+1
    if need==0 and k%p==0:
        print(k//p)
    elif (k*need)%p==0:
        print((k*need)//p)
    else:
        print(((k*need)//p)+1)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def digisum(n):
    count = 0
    while(n>0):
        count+=n%10
        n = n//10
    return count

n,s = list(map(int,input().split()))
l,r = 1,n
flag = 0
while l<r:
    m = l+(r-l)//2
    digi_sum = digisum(m)
    num = m
    if num-digi_sum>=s:
        flag = 1
        cur = m
        r = m
    else:
        l = m+1
    if r-l==1:
        digi_sum = digisum(l)
        num = l
        if num-digi_sum>=s:
            flag = 1
            cur = l
            break
        digi_sum = digisum(r)
        num = r
        if num-digi_sum>=s:
            flag = 1
            cur = r
            break
if flag==0:
    digi_sum = digisum(l)
    num = l
    if num-digi_sum>=s:
        flag = 1
        cur = l
if flag==0:
    print(0)
else:
    print(n-cur+1)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import defaultdict

def main():
    R, G, B = map(int, input().split())
    red = list(map(int, input().split()))
    green = list(map(int, input().split()))
    blue = list(map(int, input().split()))
    red.sort(reverse=True)
    green.sort(reverse=True)
    blue.sort(reverse=True)
    dp = [[[-2*10**9]*(B+10) for i in range(G+10)] for j in range(R+10)]
    dp[0][0][0] = 0
    ans = 0
    for i in range(R+1):
        for j in range(G+1):
            for k in range(B+1):
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+red[i-1]*green[j-1], dp[i]
                                  [j-1][k-1]+green[j-1]*blue[k-1], dp[i-1][j][k-1]+red[i-1]*blue[k-1])
                ans = max(ans, dp[i][j][k])
    print(ans)
    return

if __name__ == ""__main__"":
    main()
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def inp1():
    return int(input())
def inp2():
    return list(map(int,input().split()))
def inp3():
    return map(int,input().split())
if 1:

    n=inp1()
    x=int(n**0.5)
    i=0
    y=n
    ans=[]
    while(i<n):
          arr=[]
          for j in range(x):
              if y==0:
                  break
              arr.append(y)
              y-=1
              i+=1
              if y==0:
                  break
          arr=arr[::-1]
          for j in arr:
              ans.append(j)
    print(*ans)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: read = lambda: map(int, input().split())
def sq(x):
    return int(x ** 0.5) ** 2 == x
t = int(input())
for _ in range(t):
    n = int(input())
    if (n % 2 == 0 and sq(n // 2)) or (n % 4 == 0 and sq(n // 4)):
        print('YES')
    else:
        print('NO')",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: x, k = (int(x) for x in input().split())
mod = 10 ** 9 + 7
if x == 0:
    print(0)
    quit()
if k == 0:
    print(2 * x % mod)
    quit()

ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod)
ans += 1
ans %= mod
ans += mod
ans %= mod
print(ans)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: l, r = map(int, input().split())
print(2**(l ^ r).bit_length() -1)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, d, k = map(int, input().split())

if d+1 > n:
    print('NO')
    exit()

ans = []
dist = [0]*n
deg = [0]*n
for i in range(d+1):
    if i == 0 or i == d:
        deg[i] = 1
    else:
        deg[i] = 2
    if i != d:
        ans.append((i+1, i+2))
    dist[i] = max(i, d-i)

for i in range(n):
    if deg[i] > k:
        print('NO')
        exit()

from collections import deque
q = deque(list(range(d+1)))
cur = d+1
while q and cur < n:
    v = q.pop()
    if dist[v] < d and deg[v] < k:
        deg[v] += 1
        dist[cur] = dist[v]+1
        deg[cur] = 1
        ans.append((v+1, cur+1))
        q.append(v)
        q.append(cur)
        cur += 1
    else:
        continue
if cur != n:
    print('NO')
else:
    print('YES')
    for i in range(len(ans)):
        print(*ans[i])
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections
import itertools


class Solution(object):
    def alertNames(self, keyName, keyTime):
        THRESHOLD = 3
        name_to_times = collections.defaultdict(list)
        for name, hour_minute in zip(keyName, keyTime):
            hour, minute = list(map(int, hour_minute.split(':')))
            name_to_times[name].append(hour*60 + minute)
        names = []    
        for name, times in name_to_times.items():
            times.sort()
            left = 0
            for right, time in enumerate(times):
                while time-times[left] > 60:
                    left += 1
                if right-left+1 >= THRESHOLD:
                    names.append(name)
                    break
        names.sort()
        return names",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
l = [int(i) for i in input().split()]
l.sort()
s = set([l[0]])
res = 1
for i in l:
    f = 1
    for j in s:
        if(i%j == 0):
            f = 0
            break
    if(f):
        s.add(i)
        res += 1
print(res)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maximum69Number (self, num):
        curr, base, change = num, 3, 0
        while curr:
            if curr%10 == 6:
                change = base
            base *= 10
            curr //= 10
        return num+change",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: x,k = map(int,input().split())
if x==0:
    print(0)
    exit()
mod = 10**9+7
print((pow(2,k+1,mod)*x%mod - (pow(2,k,mod) - 1)) % mod )",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import bisect
import copy
import decimal
import fractions
import heapq
import itertools
import math
import random
import sys
from collections import Counter,deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap)-1)
def _heappushpop_max(heap, item):
    if heap and item < heap[0]:
        item, heap[0] = heap[0], item
        heapq._siftup_max(heap, 0)
    return item
from math import gcd as GCD
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N=int(readline())
A=list(map(int,readline().split()))
mod=10**9+7
m=max(A)
cnt=[0]*(m+1)
P=Prime(m)
for a,c in Counter(A).items():
    cnt[a]=c
for p in P.primes:
    for i in range(m//p,0,-1):
        cnt[i]+=cnt[i*p]
for i in range(1,m+1):
    cnt[i]=pow(2,cnt[i],mod)-1
    cnt[i]%=mod
for p in P.primes:
    for i in range(p,m+1,p):
        cnt[i//p]-=cnt[i]
        cnt[i//p]%=mod
ans=cnt[1]
print(ans)",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def makeTheIntegerZero(self, num1, num2):
        def popcount(x):
            result = 0
            while x:
                x &= (x-1)
                result += 1
            return result

        for i in range(1, 60+1):
            if num1-i*num2 < 0:
                break
            if popcount(num1-i*num2) <= i <= num1-i*num2:
                return i
        return -1",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
import sys
pts=[]
for i in range(n):
    x,y=map(int,input().split())
    pts.append([x,y])
if(n<=4):
    print('YES')
    sys.exit()
b1=pts[0][0]-pts[1][0]
a1=pts[1][1]-pts[0][1]
c1=-a1*pts[0][0] - b1*pts[0][1]
a2=0
b2=0
c2=1
p=[]
flag=True
for i in range(n):
    if(a1*pts[i][0]+b1*pts[i][1]+c1!=0 and a2*pts[i][0]+b2*pts[i][1]+c2!=0 ):
        p.append(pts[i])
        if(len(p)==2):

            b2=p[0][0]-p[1][0]
            a2=p[1][1]-p[0][1]
            c2=-a2*p[0][0] - b2*p[0][1]
        if(len(p)>2):
            flag=False
            break
if(flag):
    print(""YES"")

    sys.exit()
P=p
p=[pts[0],P[0]]
b1=p[0][0]-p[1][0]
a1=p[1][1]-p[0][1]
c1=-a1*p[0][0] - b1*p[0][1]
p=[]
a2=0
b2=0
c2=1
flag=True
for i in range(n):
    if(a1*pts[i][0]+b1*pts[i][1]+c1!=0 and a2*pts[i][0]+b2*pts[i][1]+c2!=0 ):
        p.append(pts[i])

        if(len(p)==2):

            b2=p[0][0]-p[1][0]
            a2=p[1][1]-p[0][1]
            c2=-a2*p[0][0] - b2*p[0][1]
        if(len(p)>2):
            flag=False
            break
if(flag):

    print(""YES"")
    sys.exit()

p=[P[0],pts[1]]
b1=p[0][0]-p[1][0]
a1=p[1][1]-p[0][1]
c1=-a1*p[0][0] - b1*p[0][1]
p=[]
a2=0
b2=0
c2=1
flag=True
for i in range(n):
    if(a1*pts[i][0]+b1*pts[i][1]+c1!=0 and a2*pts[i][0]+b2*pts[i][1]+c2!=0 ):
        p.append(pts[i])
        if(len(p)==2):

            b2=p[0][0]-p[1][0]
            a2=p[1][1]-p[0][1]
            c2=-a2*p[0][0] - b2*p[0][1]
        if(len(p)>2):

            flag=False
            break
if(flag):
    print(""YES"")

    sys.exit()
print(""NO"")",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def diStringMatch(self, S):
        result = []
        left, right = 0, len(S)
        for c in S:
            if c == 'I':
                result.append(left)
                left += 1
            else:
                result.append(right)
                right -= 1
        result.append(left)
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from itertools import combinations
n, mn, mx, diff = map(int, input().split())
arr = list(map(int, input().split()))
print(sum(sum(1 for x in combinations(arr, i) if sum(x)>= mn and sum(x) <= mx and max(x)-min(x)>=diff) for i in range(2, n+1)))
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def moveZeroes(self, nums):
        pos = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[pos] = nums[i]
                pos += 1

        for i in range(pos, len(nums)):
            nums[i] = 0",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def isSymmetric(self, root):
        if root is None:
            return True
        stack = []
        stack.append(root.left)
        stack.append(root.right)

        while stack:
            p, q = stack.pop(), stack.pop()

            if p is None and q is None:
                continue

            if p is None or q is None or p.val != q.val:
                return False

            stack.append(p.left)
            stack.append(q.right)

            stack.append(p.right)
            stack.append(q.left)

        return True


",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
A=list(map(int,input().split()))
B=list(map(int,input().split()))

REVA=[None]*(n+1)

for i in range(n):
    REVA[A[i]]=i+1

top=0
ANSLIST=[]

for b in B:
    if REVA[b]>top:
        ANSLIST.append(REVA[b]-top)
        top=REVA[b]
    else:
        ANSLIST.append(0)

for ans in ANSLIST:
    print(ans,end="" "")
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def digitsum(n):
    init=0
    for item in str(n):
        init+=int(item)
    return init
n,s=map(int,input().split())
if n-digitsum(n)<s:
    print(0)
else:
    i=0
    j=n
    while i<j:
        mid=(i+j)//2
        if mid-digitsum(mid)<s:
            i=mid+1
        else:
            j=mid
    else:
        print(n-i+1)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def tree2str(self, t):
        if not t: return """"
        s = str(t.val)
        if t.left or t.right:
            s += ""("" + self.tree2str(t.left) + "")""
        if t.right:
            s += ""("" + self.tree2str(t.right) + "")""
        return s",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, m = map(int, input().split())
xs = list(map(int, input().split()))
ts = list(map(int, input().split()))

ps = [x for x, t in zip(xs, ts) if t == 0]
ds = [x for x, t in zip(xs, ts) if t == 1]
ans = [0] * m

di = 0
for pi, p in enumerate(ps):
    while di < m - 1 and abs(ds[di] - p) > abs(ds[di + 1] - p):
        di += 1

    if di >= m:
        ans[m - 1] += n - pi
        break

    ans[di] += 1

print(' '.join(map(str, ans)))
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def sumImbalanceNumbers(self, nums):
        result = 0
        for right in range(len(nums)):
            lookup = {nums[right]}
            curr = 0
            for left in reversed(range(right)):
                if nums[left] not in lookup:
                    lookup.add(nums[left])
                    curr += 1-(nums[left]-1 in lookup)-(nums[left]+1 in lookup)
                result += curr
        return result",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import io, sys
input = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()

ii = lambda: int(input())
mi = lambda: map(int, input().split())
li = lambda: list(mi())

n, m, k = mi()
a = [None] + li()
p = [0] * (n + 1)
for i in range(1, n + 1):
    p[i] = p[i - 1] + a[i]
s = [10 ** 16 for _ in range(m)]
s[0] = k
ans = 0
for i in range(1, n + 1):
    ans = max(ans, p[i] - min(s))
    s[i % m] = min(s[i % m], p[i])
    s[i % m] += k
print(ans)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
input = lambda: sys.stdin.readline().rstrip()

from collections import defaultdict as ddc

def main():
    n, m, k = map(int,input().split())

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = ''
            for j in range(k):
                if i>>j&1:
                    ans = ''.join([ans, s[j]])
                else:
                    ans = ''.join([ans, '_'])
            Ans.add(ans)
        return Ans

    D = ddc(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = 1
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = 0
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    from collections import deque
    def topological_sort(In, Out):

        dq = deque()
        L = []
        for i, I in enumerate(In):
            if not I:
                dq.append(i)
        while dq:
            v = dq.popleft()
            L.append(v)
            for w in Out[v]:
                In[w].remove(v)
                if not In[w]:
                    dq.append(w)
        if len(L) < len(In):
            return False
        return L

    T = topological_sort(In, Out)
    if flag == 0 or not T:
        print('NO')
    else:
        print('YES')
        print(*[t+1 for t in T], sep = ' ')

main()",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: if __name__ == '__main__':
    cin = input
    n = int(cin())
    s, t = [*cin()], cin()
    i, r = 0, list()

    if sorted(s) != sorted(t):
        print(-1)
    else:
        while i < n:
            j = i
            while j < n and s[j] != t[i]:
                j += 1
            s[i:j + 1] = s[j:j + 1] + s[i:j]
            r.extend(range(j, i, -1))
            i += 1
        print(len(r))
        print(*r)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
a = list(map(int, input()))
b = list(map(int, input()))

ans = sum(q != w for q, w in zip(a, b))
i = 1
while i < n:
    aii = a[i - 1]
    ai = a[i]
    bii = b[i - 1]
    bi = b[i]
    if aii + ai == 1 and bii + bi == 1 and aii != bii and ai != bi:
        ans -= 1
        i += 1
    i += 1

print(ans)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import Counter
import sys
input = sys.stdin.readline
n = int(input())
a = list(map(int, input().split()))
mod = 998244353
a.sort()
dp = [1] + [0] * n
for i in range(1, n + 1):
    x, pt = 1, i - 2
    while pt >= 0 and 2 * a[pt] > a[i - 1]:
        x = x * (n - pt - 2) % mod
        pt -= 1
    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod
print(dp[-1])",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def solve(a):
    aa = sorted(a)
    maxr = aa[0]
    for ai in aa:
        if ai[2] != maxr[2]:
            if ai[1] <= maxr[1] and ai[0] >= maxr[0]:
                return(ai[2], maxr[2])
            if ai[1] >= maxr[1] and ai[0] <= maxr[0]:
                return(maxr[2], ai[2])
        if ai[1] > maxr[1]:
            maxr = ai
    return(-1, -1)

n = int(input())
a = []
for i in range(n):
    l,r = [int(s) for s in input().split()]
    a.append((l, r, i+1))
i,j = solve(a)
print(i,j)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, m = map(int, input().split())
a = []
b = []
while n >= 0:
    a.append(4)
    n -= 4
    b.append(5)

a.append(5)
b.append(5)

print(*a, sep = """")
print(*b, sep = """")
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def divideString(self, s, k, fill):
        return [s[i:i+k] + fill*(i+k-len(s)) for i in range(0, len(s), k)]",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys

Ri = lambda : [int(x) for x in sys.stdin.readline().split()]
ri = lambda : sys.stdin.readline().strip()

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
INF = 10 ** 18
MOD = 10**8
N = 5*10**6

def solve(n):
    arr = []
    while n> 0:
        arr.append(n%2)
        n=n//2
    return arr

l,r = Ri()
arrl = solve(l)
arrr = solve(r)
if len(arrr) > len(arrl):
    ans = (1<<len(arrr))-1
    print(ans)
else:
    ind = -1
    for i in range(len(arrr)-1,-1,-1):
        if arrr[i] != arrl[i]:
            ind = i
            break
    if ind == -1:
        print(0)
    else:
        ans = (1 << (ind+1)) -1
        print(ans)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def minUnlockedIndices(self, nums, locked):
        result = mx = cnt = 0
        for i in range(len(nums)):
            if mx < nums[i]:
                mx = nums[i]
                cnt = 0
            elif mx > nums[i]:
                if mx != nums[i]+1:
                    return -1
                result += cnt
                cnt = 0
            cnt += locked[i]
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def sortEvenOdd(self, nums):
        def partition(index, nums):
            for i in range(len(nums)):
                j = i
                while nums[i] >= 0:
                    j = index(j)
                    nums[i], nums[j] = nums[j], ~nums[i] 
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
        
        partition(lambda i: i//2 if i%2 == 0 else (len(nums)+1)//2+i//2, nums)
        nums[:(len(nums)+1)//2], nums[(len(nums)+1)//2:] = sorted(nums[:(len(nums)+1)//2]), sorted(nums[(len(nums)+1)//2:], reverse=True)
        partition(lambda i: 2*i if i < (len(nums)+1)//2 else 1+2*(i-(len(nums)+1)//2), nums)
        return nums",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
l=list(map(int, input().split()))
r=list(map(int, input().split()))
maxx=0
s=[]
it=0
for i in range(n):
    s.append(l[i]+r[i])
    if l[i]>i or r[i]>n-i-1:
        it=1
its=list(s)
while maxx<n:
    summ=0
    ll=0
    rr=its.count(-1)
    for i in range(n):
        if its[i]==-1:
            ll+=1
            rr-=1
        if its[i]!=-1 and i<n-1 and r[i]<rr:
            it=1
            break
        if its[i]!=-1 and i>0 and l[i]<ll:
            it=1
            break
    if it==1:
        break
    for i in range(n):
        if s[i]==maxx:
            s[i]=-maxx
            its[i]=-1
            summ+=1

    if summ==0:
        it=1
        break
    maxx+=summ
if it==1:
    print('NO')
else:
    print('YES')
    for i in s:
        print(i-min(s)+1, end=' ')
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections


class Solution2(object):
    def countVowelSubstrings(self, word):
        VOWELS = set(""aeiou"")
        k = 5
        def atMostK(word, k):
            cnt = collections.Counter()
            result = left = 0
            for right, c in enumerate(word):
                if c not in VOWELS:
                    cnt = collections.Counter()
                    left = right+1
                    continue
                cnt[c] += 1
                while len(cnt) > k:
                    cnt[word[left]] -=1
                    if not cnt[word[left]]:
                        del cnt[word[left]]
                    left += 1
                result += right-left+1
            return result

        return atMostK(word, k) - atMostK(word, k-1)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: MAX = 1000
f = [0]
for i in range(1, MAX):
    f.append(f[i - 1] + (1 << (2 * i - 2)))

g = [0]
for i in range(1, MAX):
    g.append(g[i - 1] + (1 << i) - 1)

t = int(input())
for _ in range(t):
    n, k = map(int, input().split(' '))
    ans = False
    for i in range(1, n + 1):
        if k >= g[i]:
            if n >= MAX:
                print(""YES %d"" % (n - i))
                ans = True
            elif k <= f[n] - ((1 << (i + 1)) - 1) * f[n - i]:
                print(""YES %d"" % (n - i))
                ans = True
        if ans == True:
            break
    if ans == False:
        print(""NO"")
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def minCostClimbingStairs(self, cost):
        dp = [0] * 3
        for i in reversed(range(len(cost))):
            dp[i%3] = cost[i] + min(dp[(i+1)%3], dp[(i+2)%3])
        return min(dp[0], dp[1])",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def getLonelyNodes(self, root):
        result = []
        stk = [root]
        while stk:
            node = stk.pop()
            if not node:
                continue
            if node.left and not node.right:
                result.append(node.left.val)
            elif node.right and not node.left:
                result.append(node.right.val)
            stk.append(node.right)
            stk.append(node.left)
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math

def get_line(x1, y1, x2, y2):
    a = x2 - x1
    b = y1 - y2
    c = x1 * (y2 - y1) - y1 * (x2 - x1)

    g = math.gcd(math.gcd(a, b), c)
    a //= g
    b //= g
    c //= g
    return a, b, c

n = int(input())
xy = []

for i in range(n):
    x, y = [int(x) for x in input().split()]
    xy.append((x, y))

if n <= 3:
    print(""YES"")
    exit()

def check(x1, y1, x2, y2, xy):
    a1, b1, c1 = get_line(x1, y1, x2, y2)
    other_point = None
    cnt_other = 0
    a2, b2, c2 = 0, 0, 0
    for i in range(len(xy)):
        x, y = xy[i]

        if a1 * y + b1 * x + c1 != 0:
            if other_point is None:
                other_point = x, y
                cnt_other = 1
            elif cnt_other == 1:
                cnt_other = 2
                a2, b2, c2 = get_line(*other_point, x, y)
            else:
                if a2 * y + b2 * x + c2 != 0:
                    return False
    return True

if check(*xy[0], *xy[1], xy[2:]):
    print(""YES"")
elif check(*xy[1], *xy[2], [xy[0]] + xy[3:]):
    print(""YES"")
elif check(*xy[0], *xy[2], [xy[1]] + xy[3:]):
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, m, k, l = map(int, input().split())
k += l
x = (k + m - 1) // (m);
if m * x > n:
    print(-1)
else:
    print(x)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
input = sys.stdin.readline

n,T=map(int,input().split())
S=[list(map(int,input().split())) for i in range(n)]

DP=[[0]*(4) for i in range(T+1)]
mod=10**9+7

from functools import lru_cache
@lru_cache(maxsize=None)
def calc(used,recent,time):
    ANS=0
    for i in range(n):

        if i in used:
            continue
        if time+S[i][0]>T:
            continue
        if S[i][1]==recent:
            continue
        if time+S[i][0]==T:
            ANS+=1
        if time+S[i][0]<T:
            used2=list(used)+[i]
            used2.sort()
            recent2=S[i][1]
            time2=time+S[i][0]
            ANS=(ANS+calc(tuple(used2),recent2,time2))%mod

    return ANS

print(calc(tuple(),-1,0)%mod)
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections


class Solution(object):

    def __init__(self):
        self.__dq = collections.deque()
        self.__printed = set()

    def shouldPrintMessage(self, timestamp, message):
        while self.__dq and self.__dq[0][0] <= timestamp - 10:
            self.__printed.remove(self.__dq.popleft()[1])
        if message in self.__printed:
            return False
        self.__dq.append((timestamp, message))
        self.__printed.add(message)
        return True",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
readline = sys.stdin.readline

def gcd(a, b):
    while b:
        a, b = b, a%b
    return a

def prsh(N):
    prime = [2]
    for L in range(3,N):
        for p in prime:
            if not L % p:
                break
            if p > L**(1/2):
                prime.append(L)
                break
    return prime
limit = 59
prime = prsh(limit+1)
C = set([tuple()])
Cp = []
for i in range(2, limit+1):
    if i >= 30 and i in prime:
        Cp.append(i)
        continue
    for k in C.copy():
        if all(gcd(ki, i) == 1 for ki in k):
            kn = tuple(list(k) + [i])
            C.add(kn)

INF = 10**9+7

N = int(readline())
A = list(map(int, readline().split()))
Ao = A[:]
A.sort()
ans = INF
Ans = None
for ci in C:
    tc = [1]*(N-len(ci)) + list(ci) + Cp
    for j in range(8):
        res = 0
        for a, t in zip(A, tc[j:]):
            res += abs(a-t)
        if ans > res:
            ans = res
            Ans = tc[j:j+N]
buc = [[] for _ in range(limit+1)]
for a, an in zip(A, Ans):
    buc[a].append(an)
AA = []
for ao in Ao:
    AA.append(buc[ao].pop())

print(*AA)",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution3(object):
    def canReachCorner(self, X, Y, circles):
        def check(x1, y1, r1, x2, y2, r2):
            return (x1-x2)**2+(y1-y2)**2 <= (r1+r2)**2

        def iter_dfs(src, dst):
            lookup = [False]*len(adj)
            lookup[src] = True
            stk = [src]
            while stk:
                u = stk.pop()
                if u == dst:
                    return True
                for v in adj[u]:
                    if lookup[v]:
                        continue
                    lookup[v] = True
                    stk.append(v)
            return False

        adj = [[] for _ in range(len(circles)+2)]
        for u in range(len(circles)):
            x1, y1, r1 = circles[u]
            if x1-r1 <= 0 or y1+r1 >= Y:
                adj[u].append(len(circles))
                adj[len(circles)].append(u)
            if x1+r1 >= X or y1-r1 <= 0:
                adj[u].append(len(circles)+1)
                adj[len(circles)+1].append(u)
            for v in range(u):
                x2, y2, r2 = circles[v]
                if not check(x1, y1, r1, x2, y2, r2):
                    continue
                adj[u].append(v)
                adj[v].append(u)
        return not iter_dfs(len(circles), len(circles)+1)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import heapq


class Solution(object):
    def longestDiverseString(self, a, b, c):
        max_heap = []
        if a:
            heapq.heappush(max_heap, (-a, 'a'))
        if b:
            heapq.heappush(max_heap, (-b, 'b'))
        if c:
            heapq.heappush(max_heap, (-c, 'c'))
        result = []
        while max_heap:
            count1, c1 = heapq.heappop(max_heap)
            if len(result) >= 2 and result[-1] == result[-2] == c1:
                if not max_heap:
                    return """".join(result)
                count2, c2 = heapq.heappop(max_heap)
                result.append(c2)
                count2 += 1
                if count2:
                    heapq.heappush(max_heap, (count2, c2))
                heapq.heappush(max_heap, (count1, c1))
                continue
            result.append(c1)
            count1 += 1
            if count1 != 0:
                heapq.heappush(max_heap, (count1, c1))
        return """".join(result)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def intToRoman(self, num):
        numeral_map = {1: ""I"", 4: ""IV"", 5: ""V"", 9: ""IX"", \
                       10: ""X"", 40: ""XL"", 50: ""L"", 90: ""XC"", \
                       100: ""C"", 400: ""CD"", 500: ""D"", 900: ""CM"", \
                       1000: ""M""}
        keyset, result = sorted(numeral_map.keys()), []

        while num > 0:
            for key in reversed(keyset):
                while num / key > 0:
                    num -= key
                    result += numeral_map[key]

        return """".join(result)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os,sys
from io import BytesIO,IOBase
from collections import defaultdict,Counter
from copy import deepcopy

def main():
    n,c = map(int,input().split())
    a = list(map(int,input().split()))
    nums = defaultdict(lambda :[0])
    freq,minus = Counter(),0
    for i in a:
        if i == c:
            minus += 1
        else:
            freq[i] += 1
            nums[i].append(freq[i]-minus)
    tot = minus
    suff = deepcopy(nums)
    for i in nums:
        for j in range(len(nums[i])-2,0,-1):
            suff[i][j] = max(suff[i][j],suff[i][j+1])
    freq,ans = Counter(),tot
    for i in a:
        if i == c:
            continue
        freq[i] += 1
        ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot)
    print(ans)

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import itertools


class Solution(object):
    def dietPlanPerformance(self, calories, k, lower, upper):
        total = sum(itertools.islice(calories, 0, k))
        result = int(total > upper)-int(total < lower)
        for i in range(k, len(calories)):
            total += calories[i]-calories[i-k]
            result += int(total > upper)-int(total < lower)
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

R,G,B=map(int,input().split())
r=sorted(list(map(int,input().split())))
g=sorted(list(map(int,input().split())))
b=sorted(list(map(int,input().split())))
dp=[[[0]*(B+1) for j in range(G+1)] for i in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k - 1] + g[j - 1] * b[k - 1])
print(dp[R][G][B])",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
s=(input())
L=s.split("" "")
L=list(set(L))
for i in range(len(L)):
    L[i]=int(L[i])
L=sorted(L)
if len(L)==1:
    print(""NO"")
else:
    print(L[1])
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: k = int(input())
if (k < 10):
    print(k)
    quit()
c=0
n=k
a = k
while (n > 0):
    c+=1
    sub = 10 ** c - 10 ** (c-1)
    a-=sub*c
    n = a / (c+1) + (10 ** c - 1)
    if (n+1 <= 10 ** (c+1)):
        if (int(n) == n):
            print(int(n%(10)))
            exit()
        else:
            print(str(int(n)+1)[round((n-int(n))*(c+1))-1])
            exit()
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: x,k=[int(i) for i in input().split()]
if x!=0:
    print((pow(2,k,1000000007)*(2*x-1)+1)%1000000007)
else:
    print(0)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections


class Solution(object):
    def findLucky(self, arr):
        count = collections.Counter(arr)
        result = -1
        for k, v in count.items():
            if k == v:
                result = max(result, k)
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n,d=lst()
    a=sorted(lst())
    s=set()
    for i in range(n):
        x=a[i]-d
        left=a[i-1] if i>=1 else float('inf')
        if abs(x-left)>=d:s.add(x)
        x=a[i]+d
        right=a[i+1] if i+1<n else float('inf')
        if abs(x-right)>=d:s.add(x)
    print(len(s))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def addNegabinary(self, arr1, arr2):
        result = []
        carry = 0
        while arr1 or arr2 or carry:
            if arr1:
                carry += arr1.pop()
            if arr2:
                carry += arr2.pop()
            result.append(carry & 1)
            carry = -(carry >> 1)
        while len(result) > 1 and result[-1] == 0:
            result.pop()
        result.reverse()
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections
import string


class Solution(object):
    def longestWord(self, words):
        def iter_dfs(words, node):
            result = -1
            stk = [node]
            while stk:
                node = stk.pop()
                if result == -1 or len(words[node[""_end""]]) > len(words[result]):
                    result = node[""_end""]
                for c in reversed(string.ascii_lowercase):
                    if c not in node or ""_end"" not in node[c]:
                        continue
                    stk.append(node[c])
            return result       
    
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        trie[""_end""] = -1
        for i, word in enumerate(words):
            reduce(dict.__getitem__, word, trie)[""_end""] = i
        result = iter_dfs(words, trie)
        return words[result] if result != -1 else """"",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: index = int(input())

total = 9
n = 1

while index > total:
    total += (n + 1) * (10**n) * 9
    n += 1
last = 10**(n - 1)
total -= n * 9 * last
index = index - total

r = index % (n)
k = index // n

number = last + k

if r == 0:
    print(str(number - 1)[n-1])
else:
    print(str(number)[r - 1])
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: 

class Solution(object):
    def maximumXOR(self, nums):
        return reduce(lambda x, y: x|y, nums)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def valid(node, left, right):
            if not node:
                return True
            if not (left < node.val < right):
                return False

            return valid(node.left, left, node.val) and valid(
                node.right, node.val, right
            )

        return valid(root, float(""-inf""), float(""inf""))
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections



class Solution2(object):
    def maxSubarraySum(self, nums):
        result = float(""-inf"")
        curr = mn = mn0 = 0
        mn1 = collections.defaultdict(int)
        for x in nums:
            curr += x
            result = max(result, curr-mn)
            if x < 0:
                mn1[x] = min(mn1[x], mn0)+x
                mn = min(mn, mn1[x])
            mn0 = min(mn0, curr)
            mn = min(mn, mn0)
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,a,b = list( map(int, input().split()))

if min(a,b) >1:
    print('NO')
    exit()

m = max(a,b)

if m == 1:
    if n == 1:
        print('YES')
        print(0)
        exit()
    elif n < 4:
        print('NO')
        exit()
    else:
        print('YES')
        for row in range(n):
            line = ['0']*n
            if row >0:
                line[row-1] = '1'
            if row <n-1:
                line[row+1] = '1'
            print(''.join(line))
    exit()

print('YES')

if a == 1:
    c = '1'
    d = '0'
else:
    c = '0'
    d = '1'
for row in range(n):
    if row < m-1:
        line = [c]*n
    else:
        line = [c]*(m-1)+ [d]*(n-m+1)
    line[row] = '0'

    print(''.join(line))
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, e = map( int, input().split() )
d = (n - e) // 2
q = []
while n > 0:
    i = min(n, d)
    while i > 0:
        q.append('1')
        i -= 1
        n -= 1
    if n > 0:
        q.append('0')
        n -= 1

print( """".join(q) )",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def postorder(self, root):
        if not root:
            return []
        result, stack = [], [root]
        while stack:
            node = stack.pop()
            result.append(node.val)
            for child in node.children:
                if child:
                    stack.append(child)
        return result[::-1]",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def countCompleteComponents(self, n, edges):
        def bfs(u):
            if lookup[u]:
                return False
            v_cnt = e_cnt = 0
            lookup[u] = True
            q = [u]
            while q:
                new_q = []
                v_cnt += len(q)
                for u in q:
                    e_cnt += len(adj[u])
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                q = new_q
            return v_cnt*(v_cnt-1) == e_cnt

        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        lookup = [False]*n
        return sum(bfs(u) for u in range(n) if not lookup[u])",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,k=map(int,input().split())
l=input()
l=sorted(l)
ans=l[0]
sum=ord(l[0])
index=0
for j in range(1,n):
    if len(ans)<k:
        if ord(l[j])-ord(l[index])>1:
            ans=ans+l[j]
            sum=sum+ord(l[j])
            index=j
    else:
        break
if len(ans)==k:
    sum=sum-96*k
    print(sum)
else:
    print(-1)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: s = input().split()
b = []
b.append((s[0][1], int(s[0][0])))
b.append((s[1][1], int(s[1][0])))
b.append((s[2][1], int(s[2][0])))
b.sort()
if (b[0][0] == b[1][0] and b[1][0] == b[2][0]):
    if (b[0] == b[1] and b[1] == b[2]):
        print(0)
    elif (b[0][1] + 1 == b[1][1] and b[1][1] + 1 == b[2][1]):
        print(0)
    elif (b[0] == b[1]):
        print(1)
    elif (b[1] == b[2]):
        print(1)
    elif b[0][1] + 1 == b[1][1]:
        print(1)
    elif b[0][1] + 2 == b[1][1]:
        print(1)
    elif b[1][1] + 1 == b[2][1]:
        print(1)
    elif b[1][1] + 2 == b[2][1]:
        print(1)
    elif b[0][1] + 1 == b[2][1]:
        print(1)
    elif b[0][1] + 2 == b[2][1]:
        print(1)
    else:
        print(2)
elif (b[0][0] != b[1][0] and b[1][0] != b[2][0] and b[2][0] != b[0][0]):
    print(2)
elif b[0][0] == b[1][0]:
    if b[0] == b[1]:
        print(1)
    elif b[0][1] + 1 == b[1][1]:
        print(1)
    elif b[0][1] + 2 == b[1][1]:
        print(1)
    else:
        print(2)
elif b[1][0] == b[2][0]:
    if (b[1] == b[2]):
        print(1)
    elif b[1][1] + 1 == b[2][1]:
        print(1)
    elif b[1][1] + 2 == b[2][1]:
        print(1)
    else:
        print(2)
else:
    print(2)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = map(int, input().split())
print(k // n + (k % n != 0))
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maxProductDifference(self, nums):
        largest, smallest = [0]*2, [float(""inf"")]*2
        for x in nums:
            if x >= largest[0]:
                largest[:] = [x, largest[0]]
            elif x > largest[1]:
                largest[1] =x
            if x <= smallest[0]:
                smallest[:] = [x, smallest[0]]
            elif x < smallest[1]:
                smallest[1] = x
        return largest[0]*largest[1] - smallest[0]*smallest[1]",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: s=input()
for i in range(len(s),0,-1):
    if s[:i]!=s[i-1::-1]:
        print(i)
        break
else:
    print(0)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def candy(self, ratings):
        candies = [1 for _ in range(len(ratings))]
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i - 1]:
                candies[i] = candies[i - 1] + 1

        for i in reversed(range(1, len(ratings))):
            if ratings[i - 1] > ratings[i] and candies[i - 1] <= candies[i]:
                candies[i - 1] = candies[i] + 1

        return sum(candies)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = list(map(int, input().split()))
u = []
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u[0].sort(reverse=True)
u[1].sort(reverse=True)
u[2].sort(reverse=True)
res = 0
dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]
for i in range(n[0]+1):
    for j in range(n[1]+1):
        for k in range(n[2]+1):
            x0 = (dp[i-1][j-1][k] + u[0][i-1]*u[1][j-1]) if i and j else 0
            x1 = (dp[i][j-1][k-1] + u[1][j-1]*u[2][k-1]) if j and k else 0
            x2 = (dp[i-1][j][k-1] + u[0][i-1]*u[2][k-1]) if i and k else 0
            dp[i][j][k] = max(x0, x1, x2)
            res = max(res, dp[i][j][k])
print(res)",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections



class Solution_TLE(object):
    def maxSubarraySum(self, nums):
        MAX, TOTAL, PREFIX, SUFFIX = list(range(4))
        class SegmentTree(object):
            def __init__(self, N,
                        build_fn=lambda _: None,
                        query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),
                        update_fn=lambda x: x):
                self.tree = [None]*(1<<((N-1).bit_length()+1))
                self.base = len(self.tree)>>1
                self.query_fn = query_fn
                self.update_fn = update_fn
                for i in range(self.base, self.base+N):
                    self.tree[i] = build_fn(i-self.base)
                for i in reversed(range(1, self.base)):
                    self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])

            def update(self, i, h):
                x = self.base+i
                self.tree[x] = self.update_fn(h)
                while x > 1:
                    x >>= 1
                    self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])

            def query(self, L, R):
                L += self.base
                R += self.base
                left = right = None
                while L <= R:
                    if L & 1:
                        left = self.query_fn(left, self.tree[L])
                        L += 1
                    if R & 1 == 0:
                        right = self.query_fn(self.tree[R], right)
                        R -= 1
                    L >>= 1
                    R >>= 1
                return self.query_fn(left, right)
        
        def build(i):
            return [nums[i]]*4
        
        def query(x, y):
            if x is None:
                return y
            if y is None:
                return x
            return [max(x[MAX], y[MAX], x[SUFFIX]+y[PREFIX]),
                    x[TOTAL]+y[TOTAL],
                    max(x[PREFIX], x[TOTAL]+y[PREFIX]),
                    max(y[SUFFIX], x[SUFFIX]+y[TOTAL])]

        mx = max(nums)
        if mx < 0:
            return mx
        mn = min(nums)
        if mn >= 0:
            return sum(nums)
        groups = collections.defaultdict(list)
        for i, x in enumerate(nums):
            groups[x].append(i)
        st = SegmentTree(len(nums), build_fn=build, query_fn=query)
        result = st.tree[1][0] 
        for k, v in groups.items():
            for i in v:
                st.update(i, None)
            result = max(result, st.tree[1][0]) 
            for i in v:
                st.update(i, [k]*4)
        return result",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,p,l,r = map(int,input().split())
if l == 1 and r == n:
    print(0)
elif l==1:
    print(abs(p-r)+1)
elif r == n:
    print(abs(p - l) + 1)
else:
    print(min(abs(p-r),abs(p - l))+r-l+2)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: k=int(input(''))
a=[9]
i=1
if k<10:
    print(k)
else:
    while k>a[-1]:
        a.append((10**(i+1)-10**(i))*(i+1)+a[i-1])
        i+=1

    cat=len(a)
    diff=k-a[-2]
    step=int(diff/(cat))
    rem=diff%(cat)

    if rem==0:
        number=(10**(cat-1)-1)+step

        print(str(number)[-1])
    else:
        number=10**(cat-1)+step

        print(str(number)[rem-1])",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def solve(r, g, b, rs, gs, bs):
    rs.sort(reverse=True)
    gs.sort(reverse=True)
    bs.sort(reverse=True)
    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
    sol = 0
    for ri in range(r+1):
        for gi in range(g+1):
            for bi in range(b+1):
                if ri < r and gi < g:
                    dp[ri+1][gi+1][bi] = max(dp[ri+1][gi+1][bi], rs[ri]*gs[gi] + dp[ri][gi][bi])
                if ri < r and bi < b:
                    dp[ri+1][gi][bi+1] = max(dp[ri+1][gi][bi+1], rs[ri]*bs[bi] + dp[ri][gi][bi])
                if gi < g and bi < b:
                    dp[ri][gi+1][bi+1] = max(dp[ri][gi+1][bi+1], gs[gi]*bs[bi] + dp[ri][gi][bi])
                sol = max(sol, dp[ri][gi][bi])
    return sol

r, g, b = map(int, input().split())
rs = list(map(int, input().split()))
gs = list(map(int, input().split()))
bs = list(map(int, input().split()))
print(solve(r, g, b, rs, gs, bs))",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
s=[4,7,44,77,47,74,444,777,477,447,744,474,747,774]
t=0
for i in s:
    if n%i==0:
        print(""YES"")
        t=1
        break
if t==0:
    print(""NO"")
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import io
import os

from functools import lru_cache
from collections import defaultdict

def solve(N, A):

    valToLeftRight = defaultdict(lambda: defaultdict(set))

    valToRightLeft = defaultdict(lambda: defaultdict(set))

    for i, x in enumerate(A):
        valToLeftRight[x][i].add(i)
        valToRightLeft[x][i].add(i)

    maxVal = 1000 + 100
    for val in range(maxVal):
        for l, rights in valToLeftRight[val - 1].items():
            for r in rights:

                l2 = r + 1
                if l2 in valToLeftRight[val - 1]:
                    for r2 in valToLeftRight[val - 1][l2]:
                        assert l <= r
                        assert r + 1 == l2
                        assert l2 <= r2
                        valToLeftRight[val][l].add(r2)
                        valToRightLeft[val][r2].add(l)

                r2 = l - 1
                if r2 in valToRightLeft[val - 1]:
                    for l2 in valToRightLeft[val - 1][r2]:
                        assert l2 <= r2
                        assert r2 == l - 1
                        assert l <= r
                        valToLeftRight[val][l2].add(r)
                        valToRightLeft[val][r].add(l2)

    intervals = defaultdict(list)
    for val in range(maxVal):
        for l, rights in valToLeftRight[val].items():
            for r in rights:

                intervals[l].append(r)

    dp = {}
    dp[N] = 0
    for left in range(N - 1, -1, -1):
        best = float(""inf"")
        for right in intervals[left]:

            best = min(best, 1 + dp[right + 1])
        dp[left] = best

    return dp[0]

if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    N, = list(map(int, input().split()))
    A = list(map(int, input().split()))
    ans = solve(N, A)
    print(ans)
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def minLength(self, s, numOps):
        def binary_search(left, right, check):
            while left <= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left

        def lengths():
            cnt = 0
            for i in range(len(s)):
                cnt += 1
                if i+1 == len(s) or s[i+1] != s[i]:
                    yield cnt
                    cnt = 0
    
        def check(x):
            if x == 1:
                cnt = sum(int(x) != i%2 for i, x in enumerate(s))
                return min(cnt, len(s)-cnt) <= numOps
            return sum(l//(x+1) for l in lengths()) <= numOps
    
        return binary_search(1, len(s), check)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: 
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def increasingBST(self, root):
        def increasingBSTHelper(root, tail):
            if not root:
                return tail
            result = increasingBSTHelper(root.left, root)
            root.left = None
            root.right = increasingBSTHelper(root.right, tail)
            return result
        return increasingBSTHelper(root, None)

",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin
input=stdin.readline
n,m,k=map(int,input().split())
lr=[list(map(int,input().split())) for i in range(n)]
ud=[list(map(int,input().split())) for i in range(n-1)]
if k%2:
  arr=[-1]*m
  for i in range(n):
    print(*arr)
  exit()
kk=k//2
dp=[[[10**10]*(kk+1) for i in range(m)] for j in range(n)]
for i in range(n):
  for j in range(m):
    dp[i][j][0]=0
for z in range(1,kk+1):
  for i in range(n):
    for j in range(m):
      if i>0:
        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-1]+ud[i-1][j])
      if i<n-1:
        dp[i][j][z]=min(dp[i][j][z],dp[i+1][j][z-1]+ud[i][j])
      if j>0:
        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-1]+lr[i][j-1])
      if j<m-1:
        dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-1]+lr[i][j])
ans=[[dp[i][j][kk]*2 for j in range(m)] for i in range(n)]
for i in range(n):
  print(*ans[i])",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
l=list(map(lambda x:int(x)*2,input().split("" "")))
t=list(map(lambda x:""GWL"".index(x),input()))
mins=[0 for i in range(0,n+1)]
for i in range(n-1,-1,-1):
	if t[i]!=2:mins[i]=max(mins[i+1]-l[i],0)
	else:mins[i]=mins[i+1]+l[i]
curs=ans=st=0
for i in range(0,n):
	if(t[i]==0):
		curs+=l[i];ans+=l[i]*5
		if(curs>mins[i+1]):
			ol=(curs-mins[i+1])//2
			ol=min(ol,l[i])
			ans-=4*ol;curs-=2*ol
	if(t[i]==1):
		st=1;curs+=l[i];ans+=l[i]*3
	if(t[i]==2):
		if(curs<l[i]):
			ol=l[i]-curs;curs=l[i]
			ans+=ol*(3 if st else 5)
		curs-=l[i];ans+=l[i]
if curs>0:ans-=curs//2*2
print(ans//2)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: a,b=map(int,input().split())
if a==b:print(0)
else:
    x=a^b
    c=0
    while x:
        x=x//2
        c+=1
    print(2**c-1)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def maxAmount(self, initialCurrency, pairs1, rates1, pairs2, rates2):
        def find_adj(pairs, rates):
            adj = collections.defaultdict(list)
            for i in range(len(pairs)):
                adj[pairs[i][0]].append((pairs[i][1], rates[i]))
                adj[pairs[i][1]].append((pairs[i][0], 1/rates[i]))
            return adj

        def bfs(dist, adj):
            q = list(dist.keys())
            while q:
                new_q = []
                for u in q:
                    for v, w in adj[u]:
                        if not w*dist[u] > dist[v]:
                            continue
                        dist[v] = w*dist[u]
                        new_q.append(v)
                q = new_q
            return dist
    
        dist = collections.defaultdict(int)
        dist[initialCurrency] = 1.0
        adj1 = find_adj(pairs1, rates1)
        bfs(dist, adj1) 
        adj2 = find_adj(pairs2, rates2)
        bfs(dist, adj2) 
        return dist[initialCurrency]",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: x, k = map(int, input().split())

if x==0:
    print(0)
    exit()

MOD = 10**9+7
ans = (pow(2, k+1, MOD)*x%MOD-(pow(2, k, MOD)-1))%MOD

print(ans)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin, stdout

get_string = lambda: stdin.readline().strip('\n')
get_intmap = lambda: map( int, get_string().split(' ') )

def testcase():
    n = int(input())
    cnt = dict()
    for i in range(n):
        l,r = get_intmap()
        cnt[l] = cnt.get(l,0) + 1
        cnt[r+1] = cnt.get(r+1,0) - 1
    ans = [0] * (n + 1)
    sk = sorted(cnt.keys())

    cnt_i = 0
    for ind, i in enumerate(sk[:-1]):
        cnt_i += cnt[i]
        ans[cnt_i] += sk[ind + 1] - i
    print(' '.join([str(i) for i in ans[1:]]))

testcase();quit()
for t in range(int(input())):
    testcase()
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def fis(sq):
    if sq[2] < sq[0] or sq[3] < sq[1]:
        return [0, 0]
    sc = (sq[0] + sq[1]) % 2
    fc = (sq[2] + sq[3]) % 2
    sxl = sq[2] - sq[0] + 1
    syl = sq[3] - sq[1] + 1
    hf = (sxl * syl) // 2
    cp = -1
    if sc == fc and (sxl+syl) % 2 == 0 and sxl % 2 == 1:
        cp = sc
    return([hf + (1 if cp == 0 else 0), hf + (1 if cp == 1 else 0)])

t = int(input())
for i in range(t):
    n, m = [int(x) for x in input().split()]
    wco = [int(x) for x in input().split()]
    bco = [int(x) for x in input().split()]
    wf, bf = fis([1, 1, m, n])
    btw = fis(wco)[1]
    wtb = fis(bco)[0]
    bnac = [max(wco[0], bco[0]), max(wco[1], bco[1]), min(wco[2], bco[2]), min(wco[3], bco[3])]
    bna = fis(bnac)[1]
    print(wf+btw-wtb-bna, bf+wtb-btw+bna)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math

n,m = map(int, input().strip().split(' '))

s=input()
t=input()
if '*' not in s:
    if s==t:
        print('YES')
    else:
        print('NO')
elif n>m+1:
    print('NO')
elif n==1 and s=='*':
    print('YES')
else:
    s=list(s)
    t=list(t)
    if s[0]=='*':
        if s[1:]==t[-(len(s[1:])):]:
            print('YES')
        else:
            print('NO')
    elif s[-1]=='*':
        if s[:n-1]==t[:n-1]:
            print('YES')
        else:
            print('NO')
    else:
        ind=s.index('*')

        if s[:ind]==t[:ind] and s[ind+1:]==t[-len(s[ind+1:]):]:
            print('YES')
        else:
            print('NO')
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: size = int(input())
x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())
x3, y3 = map(int, input().split())

if (y2 - y1) * (y3 - y1) > 0 and (x2 - x1) * (x3 - x1) > 0 and x1 + y1 != x3 + y3:
    print('YES')
else:
    print('NO')",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,k=map(int,input().split())
mod=int(1e9+7)

if n>0:
    ans=pow(2,k+1,mod)*n-pow(2,k,mod)+1
else:
    ans=0
print(ans%mod)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import deque
import heapq
import sys

def input():
    return sys.stdin.readline().rstrip()

n, T = map(int, input().split())
problems = [tuple(map(int, input().split())) for i in range(n)]

def possible(K):
    d = []
    for a, t in problems:
        if a >= K:
            d.append(t)
    d.sort()
    if len(d) < K:
        return False
    else:
        return sum(d[:K]) <= T

l = 0
r = n + 1
while r - l > 1:
    med = (r + l)//2
    if possible(med):
        l = med
    else:
        r = med
print(l)
print(l)
d = []
for i, (a, t) in enumerate(problems):
    if a >= l:
        d.append((t, i+1))
d.sort(key=lambda x: x[0])
ans = [v[1] for v in d[:l]]
print(*ans)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
input = sys.stdin.readline
q = int( input() )
rgb = ""RGB""
for _ in range( q ):
    n, k = map( int, input().split() )
    s = input()
    ans = n
    for i in range( 3 ):
        r = [ 0 ]
        l = i
        for c in s:
            r.append( r[ -1 ] + ( 1 if c != rgb[ l ] else 0 ) )
            l = ( l + 1 ) % 3
            if len( r ) > k:
                ans = min( ans, r[ -1 ] - r[ len( r ) - 1 - k ] )
    print( ans )
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
l=[-1 for i in range(n+1)]
s=input().split()
ll=[int(i) for i in s]
for i in range(n):
    j=ll[i]
    l[j]=i
res=[""."" for i in range(n+1)]
res[n]=""B""
for i in range(n-1,0,-1):
    toadd=""B""
    pos=l[i]%i
    while pos<n:
        j=ll[pos]
        if j<=i:
            pos+=i
            continue
        if abs(l[i]-l[j])%i==0 and res[j]==""B"":
            toadd=""A""
            break
        pos+=i
    res[i]=toadd
for i in ll:
    print(res[i],end="""")
print("""")
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections



class Solution(object):
    def minLengthAfterRemovals(self, nums):
        mx = max(collections.Counter(nums).values())
        return mx-(len(nums)-mx) if mx > (len(nums)-mx) else len(nums)%2",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: 
import pandas as pd



def Solution(players: pd.DataFrame) -> List[int]:
    return list(players.shape)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maxDepth(self, s):
        result = curr = 0
        for c in s:
            if c == '(':
                curr += 1
                result = max(result, curr)
            elif c == ')':
                curr -= 1
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def dfs(root):
            if not root:
                return [True, 0]

            left, right = dfs(root.left), dfs(root.right)
            balanced = left[0] and right[0] and abs(left[1] - right[1]) <= 1
            return [balanced, 1 + max(left[1], right[1])]

        return dfs(root)[0]
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
l = tuple(map(int,input().split()))
r = tuple(map(int,input().split()))
s = [ (i,sum(v)) for i,(v) in enumerate(zip(l,r)) ]
ss = sorted(s, key= lambda a:a[1] )

candies = [0]*n
for p in ss:
    candies[p[0]] = n-p[1]

ll = [0]
for i in range(1,n):
    ll.append(sum([1 for c in candies[:i] if c > candies[i]]))

rr = [0]
for i in range(n-2,-1,-1):
    rr.append(sum([1 for c in candies[i:] if c > candies[i]]))

for i in range(n):
    if ll[i] != l[i]:
        print(""NO"")
        break
    if rr[n-1-i] != r[i]:
        print(""NO"")
        break
    if i == n-1:
        print(""YES"")
        print(' '.join(map(str,candies)))
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def isCircularSentence(self, sentence):
        return sentence[0] == sentence[-1] and all(sentence[i-1] == sentence[i+1]for i in range(len(sentence)) if sentence[i] == ' ')",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def f(ar):
	mx = ar.index(max(ar))
	cmark = 0
	ans = 0
	big = [0] * (len(ar))
	for i in range(len(ar) - 1, -1, -1):

		cmark = max(cmark - 1, ar[i] + 1, 0)
		big[i] = cmark
	cmark = 0
	t=[0]*(len(ar))
	for i in range(len(ar)):
		cmark = max(cmark, big[i])
		t[i]=cmark
	ans=0
	for i in range(len(ar)):
		t[i]=t[i]-ar[i]-1
	return (sum(t))

a = input()
print(f([*map(int, input().strip().split())]))
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,k = map(int,input().split())
r = 0
for _ in range(n):
    h,m = map(int,input().split())
    t = 60*h+m
    if(t>r+k):
        break
    r = t+k+1
print(r//60,r%60)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys,os,io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def fun(a,b):
    return (2*(a+b))**2/(a*b)

for i in range (int(input())):
    n = int(input())
    a = [int(i) for i in input().split()]
    a.sort()
    b = []
    i=0
    while(i<n-1):
        if i<n-1 and a[i]==a[i+1]:
            b.append(a[i])
            i+=2
        else:
            i+=1
    m = 10**14
    mi = -1
    for i in range (len(b)-1):
        curr = fun(b[i],b[i+1])
        if curr<m:
            m = curr
            mi = i
    print(b[mi],b[mi],b[mi+1],b[mi+1])",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections


class Solution(object):
    def longestPalindrome(self, words):
        cnt = collections.Counter(words)
        result = remain = 0
        for x, c in cnt.items():
            if x == x[::-1]:
                result += c//2
                remain |= c%2
            elif x < x[::-1] and x[::-1] in cnt:
                result += min(c, cnt[x[::-1]])
        return result*4+remain*2",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = map(int, input().split())
a = list(map(int, input().split()))
j = 0
a.sort()
n1 = n
for i in range(n):
    while a[j] < a[i]:
        if a[i] <= a[j] + k:
            n1 -= 1
        j += 1
print(n1)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from itertools import permutations as p
rd = lambda: map(int, input())
def f(n, t):
    a = 0
    f = 1
    for i in range(n):
        for x in rd():
            if x != f:
                a += 1
            f = 1 - f
    if t < 3:
        rd()
    return a
n = int(input())
m = []
b = [-1, -1, 1, 1]
for i in range(4):
    m.append(f(n, i))
print(2 * n ** 2 + min(sum(x * y for x, y in zip(q, m)) for q in set(p(b))))
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
for i in range(n):
    k = int(input())
    s = list(map(int, input().split()))
    s.sort()
    print(min(k-2,s[k-2]-1))
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: x,k=list(map(int,input().split()))
md=1000000007
print((pow(2,k+1,md)*x-pow(2,k,md)+1)%md if x>0 else 0)",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import io,os,bisect
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
prime = [2]

for i in range(3,4*10**3,2):
    flag = False
    if i%2==0: continue
    for j in range(3,int(i**0.5)+1,2):
        if i%j==0:
            flag = True
            break
    if not flag:  prime.append(i)

def primefactor(num):

    index = 0
    output = []

    while num>=prime[index]**2:

        times = 0
        while num%prime[index]==0:
            num = num // prime[index]
            times += 1
        if times&1:  output.append(prime[index])
        index += 1

    if num>1: output.append(num)

    return tuple(output)

for _ in range(int(input())):
    n,k = map(int,input().split());arr = list(map(int,input().split()));seg = 1;fact = {};left = [[0 for j in range(k+1)] for i in range(n)];dp = [[300000 for j in range(k+1)] for i in range(n)];stack = [0]
    for i in range(n):
        factor = primefactor(arr[i])
        if factor in fact:            bisect.insort(stack,fact[factor]+1)
        fact[factor] = i
        for j in range(k+1):
            if j<len(stack):  left[i][j] = stack[-j-1]
    for i in range(n):
        for j in range(k+1):
            for t in range(j+1):l = left[i][t];dp[i][j] = (min(dp[l-1][j-t] + 1, dp[i][j]) if l > 0 else 1)
    print(dp[-1][-1])",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: k,n,s,p=map(int,input().split())
a=n//s
if(n%s!=0):
    a+=1
q=k*a
m=q//p
if(q%p!=0):
    m+=1
print(m)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def sum(self, num1, num2):
        return num1+num2",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, = map(int,input().split())
arr = set(map(int,input().split()))
print(len(arr)-(0 in arr))
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maxProfit(self, prices):
        if not prices:
            return 0
        buy, sell, coolDown = [0] * 2, [0] * 2, [0] * 2
        buy[0] = -prices[0]
        for i in range(1, len(prices)):
            buy[i % 2] = max(buy[(i - 1) % 2],
                             coolDown[(i - 1) % 2] - prices[i])
            sell[i % 2] = buy[(i - 1) % 2] + prices[i]
            coolDown[i % 2] = max(coolDown[(i - 1) % 2], sell[(i - 1) % 2])
        return max(coolDown[(len(prices) - 1) % 2],
                   sell[(len(prices) - 1) % 2])",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def quadrant(x, y, rx, ry):
	if x>rx and y>ry:
		return 1
	elif x<rx and y>ry:
		return 2
	elif x<rx and y<ry:
		return 3
	else:
		return 4

n = int(input())

qx, qy = map(int, input().split())
kx, ky = map(int, input().split())
cx, cy = map(int, input().split())

if quadrant(kx, ky, qx, qy) == quadrant(cx, cy, qx, qy):
	print(""YES"")
else:
	print(""NO"")
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def numWays(self, steps, arrLen):
        MOD = int(1e9+7)
        l = min(1+steps//2, arrLen)
        dp = [0]*(l+2)
        dp[1] = 1
        while steps > 0:
            steps -= 1
            new_dp = [0]*(l+2)
            for i in range(1, l+1):
                new_dp[i] = (dp[i] + dp[i-1] + dp[i+1]) % MOD
            dp = new_dp
        return dp[1]",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: x, y, z, t1, t2, t3 = map(int, input().split())
dp = abs(x - y) * t1;
dl = abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3;
if dp < dl:
    print(""NO"")
else:
    print(""YES"")
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
print(2*n**2-2*n+1)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate

int1 = lambda x: int(x) - 1
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
ilele = lambda: map(int,input().split())
alele = lambda: list(map(int, input().split()))
ilelec = lambda: map(int1,input().split())
alelec = lambda: list(map(int1, input().split()))
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]

def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

MOD = 998244353

N,K = ilele()
if K == 1 or K == 2*N:
    print(2)
    exit(0)
dp = list3d(N+1,4,K+1,0)
dp[1][0][1] = 1
dp[1][3][1] = 1
dp[1][1][2] = 1
dp[1][2][2] = 1

for n in range(2,N+1):
    for k in range(1,K+1):
        dp[n][0][k] = ((dp[n-1][0][k]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD
        dp[n][3][k] = ((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k])%MOD)%MOD
        if k > 1:
            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k-2] +dp[n-1][3][k-1])%MOD)%MOD
            dp[n][2][k]=((dp[n-1][0][k-1]+dp[n-1][1][k-2])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD
        else:
            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][3][k-1])%MOD)%MOD
            dp[n][2][k]=((dp[n-1][0][k-1])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD

print(((dp[N][0][K]+dp[N][1][K])%MOD+(dp[N][2][K]+dp[N][3][K])%MOD)%MOD)
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def triangularSum(self, nums):
        def exp_mod(p, mod):
            result = [p]
            while result[-1]*p%10 != result[0]:
                 result.append(result[-1]*p%10)
            return [result[-1]]+result[:-1]

        def inv_mod(x, mod):
            y = x
            while y*x%10 != 1:
                y = y*x%10
            return y

        def factor_p(x, p, cnt, diff):
            if x == 0:
                return x, cnt
            while x%p == 0:
                x //= p
                cnt += diff
            return x, cnt
    
        EXP = {p:exp_mod(p, 10) for p in (2, 5)} 
        INV = {i:inv_mod(i, 10) for i in range(1, 10) if i%2 and i%5} 
        result = 0
        nCr = 1
        cnt = {2:0, 5:0}
        for i in range(len(nums)):
            if not cnt[2] and not cnt[5]:
                result = (result + nCr*nums[i])%10
            elif cnt[2] and not cnt[5]:
                result = (result + nCr*EXP[2][cnt[2]%len(EXP[2])]*nums[i])%10
            elif not cnt[2] and cnt[5]:
                result = (result + nCr*EXP[5][cnt[5]%len(EXP[5])]*nums[i])%10
            mul, cnt[2] = factor_p((len(nums)-1)-i, 2, cnt[2], 1)
            mul, cnt[5] = factor_p(mul, 5, cnt[5], 1)
            div, cnt[2] = factor_p(i+1, 2, cnt[2], -1)
            div, cnt[5] = factor_p(div, 5, cnt[5], -1)
            nCr = nCr*mul%10
            nCr = nCr*INV[div%10]%10
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def countAlternatingSubarrays(self, nums):
        result = curr = 0
        for i in range(len(nums)):
            if i-1 >= 0 and nums[i-1] == nums[i]:
                curr = 0
            curr += 1
            result += curr
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def doesValidArrayExist(self, derived):
        return reduce(lambda total, x: total^x, derived, 0) == 0",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import defaultdict, Counter,deque
from math import sqrt, log10, log, floor, factorial,gcd
from bisect import bisect_left, bisect_right
from itertools import permutations,combinations
import sys, io, os
input = sys.stdin.readline
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

inf = float('inf')
mod = 10 ** 9 + 7
def yn(a): print(""YES"" if a else ""NO"")
ceil = lambda a, b: (a + b - 1) // b
lim=22
po=[1<<j for j in range(lim+1)]
maxbits=lim
masks=po[lim]
dp=[-1]*masks
t=1

for i in range(1):
    n=int(input())
    l=[int(i) for i in input().split()]
    for i in l:
        dp[i]=i
    for i in range(masks):
        for j in range(maxbits):
            if dp[i]==-1 and i&(1<<j):
                dp[i]=dp[i-(1<<j)]
    ans=[dp[i^(masks-1)] for i in l]
    print(*ans)
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math
def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):
	    d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
n,x,y=map(int,input().split());
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));
y+=x;
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os
import sys
from math import *
from collections import *

from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=10**9+7
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]

l,r=value()
ans=0

R=len(bin(r))-2

for i in range(61):
    if(l&(1<<i) ^ r&(1<<i)):
        ans=2**(i+1)-1

print(ans)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def maximumSubtreeSize(self, edges, colors):
        def dfs(u, p):
            cnt = 1
            for v in adj[u]:
                if v == p:
                    continue
                c = dfs(v, u)
                if cnt == -1:
                    continue
                if c == -1 or colors[v] != colors[u]:
                    cnt = -1
                    continue
                cnt += c
            result[0] = max(result[0], cnt)
            return cnt

        adj = [[] for _ in range(len(colors))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]
        dfs(0, -1)
        return result[0]",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
n=int(input())
if n==0:
	print(0)
	sys.exit()
if (n+1)%2==0:
	print((n+1)//2)
else:
	print(n+1)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,k=map(int,input().split())
a=list(map(int,input().split()))
t=list(map(int,input().split()))
ans=0
m=0
for i in range(n):
    if t[i]:
        ans+=a[i]
        a[i]=0
cf=[0]*(n+1)
for i in range(1,n+1):
    cf[i]=cf[i-1]+a[i-1]
for i in range(n-k+1):
    m=max(m,cf[i+k]-cf[i])
print(ans+m)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def getMaximumGenerated(self, n):
        if n == 0:
            return 0
        nums = [0]*(n+1)
        nums[1] = 1
        result = 1
        for i in range(2, n+1):
            if i%2 == 0:
                nums[i] = nums[i//2]
            else:
                nums[i] = nums[i//2] + nums[i//2+1]
            result = max(result, nums[i])
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: N, K = map(int, input().split())

print((K+N-1)//N)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from math import ceil

n, k = list(map(int, input().strip().split()))
r = 2*n
g = 5*n
b = 8*n

print(ceil(r/k)+ceil(g/k)+ceil(b/k))",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math
res = [0, 1, 0, 3, 0, 15, 0, 133, 0, 2025, 0, 37851, 0, 1030367, 0, 36362925, 0]
n = int(input())
print(res[n] * math.factorial(n) % (10 ** 9 + 7))
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections


class Solution(object):
    def majorityElement(self, nums):
        k, n, cnts = 3, len(nums), collections.defaultdict(int)

        for i in nums:
            cnts[i] += 1
            if len(cnts) == k:
                for j in list(cnts.keys()):
                    cnts[j] -= 1
                    if cnts[j] == 0:
                        del cnts[j]

        for i in list(cnts.keys()):
            cnts[i] = 0

        for i in nums:
            if i in cnts:
                cnts[i] += 1

        result = []
        for i in list(cnts.keys()):
            if cnts[i] > n / k:
                result.append(i)

        return result

    def majorityElement2(self, nums):
        return [i[0] for i in list(collections.Counter(nums).items()) if i[1] > len(nums) / 3]",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,k=map(int,input().strip().split())
d=(n-k)//2+1
x=['1' if (i+1)%d==0 else '0' for i in range(n)]
print(''.join(x))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def main():
    n, q = map(int, input().split())
    for _ in range(q):
        node = int(input())
        s = input()

        for i in s:
            if i == 'L':
                if node % 2:
                    continue
                k = node & (-node)
                node -= k
                k //= 2
                node += k

            if i == 'R':
                if node % 2:
                    continue
                k = node & (-node)
                k //= 2
                node += k

            if i == 'U':
                if node == (n + 1) // 2:
                    continue
                k = node & (-node)
                node -= k
                k *= 2
                node |= k
        print(node)
    return

if __name__ == ""__main__"":
    main()",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import bisect


class Solution(object):
    def minOperations(self, target, arr):
        lookup = {x:i for i, x in enumerate(target)}
        lis = []
        for x in arr:
            if x not in lookup:
                continue
            i = bisect.bisect_left(lis, lookup[x])
            if i == len(lis):
                lis.append(lookup[x])
            else:
                lis[i] = lookup[x]
        return len(target)-len(lis)
class SegmentTree(object): 
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y), 
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x < self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h): 
        def pull(x):
            while x > 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L <= R:
            if L & 1: 
                self.__apply(L, h) 
                L += 1
            if R & 1 == 0: 
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R): 
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L > R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L <= R:
            if L & 1: 
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R & 1 == 0: 
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in range(self.N):
            showList.append(self.query(i, i))
        return "","".join(map(str, showList))",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: k=int(input())
x=0
c=0
while(x<k):
    x+=9*(10**c)*(c+1)
    c+=1
p=(x-k)%c
k=((10**c)-int(((x-k)/c))-1)
k=str(k)
print(k[len(k)-(p)-1])",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import itertools

n, l, r, x = [int(x) for x in input().split()]
c = [int(x) for x in input().split()]

counter = 0
for i, val in enumerate(["""".join(seq) for seq in itertools.product(""01"", repeat=n)]):
    if val.count('1') < 2:
        continue
    dif = 0; mx = float(""-inf""); mn = float(""inf"")
    for i, bit in enumerate(val):
        if bit == '1':
            dif += c[i]
            mx = max(c[i], mx)
            mn = min(c[i], mn)
    if l <= dif <= r and  mx - mn >= x:
        counter += 1

print(counter)
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def subStrHash(self, s, power, modulo, k, hashValue):
        h, idx = 0, -1
        pw = pow(power, k-1, modulo)
        for i in reversed(range(len(s))):
            if i+k < len(s):
                h = (h-(ord(s[i+k])-ord('a')+1)*pw)%modulo
            h = (h*power+(ord(s[i])-ord('a')+1))%modulo
            if h == hashValue:
                idx = i
        return s[idx:idx+k]",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,m=map(int,input().split())
a=list(map(int,input().split()))
dic={}
for i in range(m):
  if a[i] in dic:
    dic[a[i]]+=1
  else:
    dic[a[i]]=1
for i in range(1,102):
  r=0
  for j in dic:
    r+=dic[j]//i
  if r<n:
    print(i-1)
    break",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

INF=999999999999999999999999
alphabets=""abcdefghijklmnopqrstuvwxyz""
class SortedList:
    def __init__(self, iterable=[], _load=200):

        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):

        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):

        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):

        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):

        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):

        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):

        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):

        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):

        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):

        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):

        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):

        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):

        return self._len

    def __getitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):

        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):

        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):

        return (value for _list in self._lists for value in _list)

    def __reversed__(self):

        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):

        return 'SortedList({0})'.format(list(self))

class SegTree:

    def __init__(self, n):
        self.N = 1 << n.bit_length()
        self.tree = [0] * (self.N<<1)

    def update(self, i, j, v):
        i += self.N
        j += self.N
        while i <= j:
            if i%2==1: self.tree[i] += v
            if j%2==0: self.tree[j] += v
            i, j = (i+1) >> 1, (j-1) >> 1

    def query(self, i):
        v = 0
        i += self.N
        while i > 0:
            v += self.tree[i]
            i >>= 1
        return v

def SieveOfEratosthenes(limit):

    isPrime = [True]*(limit+1)
    isPrime[0] = isPrime[1] = False
    primes = []
    for i in range(2, limit+1):
        if not isPrime[i]:continue
        primes += [i]
        for j in range(i*i, limit+1, i):
            isPrime[j] = False
    return primes

def main():

    mod=1000000007

    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")

    tc = 1
    for _ in range(tc):
        a,b=ria()

        op=0
        while min(a,b):
            if a>b:
                op+=a//b
                a%=b
            else:
                op+=b//a
                b%=a

        wi(op)

    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,m=map(int,input().split())
a=[int(input(),2)for _ in range(n)]

s=t=0
for x in a:
    t|=s&x
    s|=x
print(('YES','NO')[all(x&s&~t for x in a)])",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def totalHammingDistance(self, nums):
        result = 0
        for i in range(32):
            counts = [0] * 2
            for num in nums:
                counts[(num >> i) & 1] += 1
            result += counts[0] * counts[1]
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def findDistance(self, root, p, q):
        def iter_dfs(root, p, q):
            result = 0
            dist = [-1]
            stk = [(1, [root, dist])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [-1], [-1]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    if node.val in (p, q):
                        if ret1[0] == ret2[0] == -1:
                            ret[0] = 0
                        else:
                            result = ret1[0]+1 if ret1[0] != -1 else ret2[0]+1
                    elif ret1[0] != -1 and ret2[0] != -1:
                        result = ret1[0]+ret2[0]+2
                    elif ret1[0] != -1:
                        ret[0] = ret1[0]+1
                    elif ret2[0] != -1:
                        ret[0] = ret2[0]+1
            return result
        
        return iter_dfs(root, p, q)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections


class Solution(object):
    def areOccurrencesEqual(self, s):
        return len(set(collections.Counter(s).values())) == 1",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import heapq


class Solution(object):
    def connectSticks(self, sticks):
        heapq.heapify(sticks)
        result = 0
        while len(sticks) > 1:
            x, y = heapq.heappop(sticks), heapq.heappop(sticks)
            result += x+y
            heapq.heappush(sticks, x+y)
        return result",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def cross(a, b):
    return a[0] * b[1] - a[1] * b[0]

def f(v, i1, i2):
    d = [v[i2][i] - v[i1][i] for i in range(len(v[i1]))]

    res = []
    for x in v:
        d2 = [x[i] - v[i1][i] for i in range(len(v[i1]))]
        if cross(d, d2) != 0:
            res.append(x)

    return res

n = int(input())
if n <= 4:
    print(""YES"")
    exit(0)

v = []
for i in range(n):
    v.append(list(map(int, input().split())))

ok = False
for first in range(3):
    if ok:
        break

    for second in range(first+1, 3):
        other = f(v, first, second)

        if len(other) <= 2:
            ok = True
            break

        remainder = f(other, 0, 1)

        if not remainder:
            ok = True

if ok:
    print(""YES"")
else:
    print(""NO"")
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, m, k = map(int, input().strip().split())

a = list(map(int, input().strip().split()))
a = [0] + a
dp = [0] * 300005
ans = 0
for i in range(1, n + 1):
    a[i] += a[i - 1]
    for j in range(1, m + 1):
        if i - j >= 0:
            dp[i] = max(dp[i], a[i] - a[i - j] - k)
    if i - m >= 0:
        dp[i] = max(dp[i], a[i] - a[i - m] + dp[i - m] - k)
    ans = max(ans, dp[i])

print(ans)
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: k = int(input())

for i in range(20):
    if k > 10**i * 9 * (i+1):
        k -= 10**i * 9 * (i+1)
    else:
        a, b = (k-1) // (i+1) + 10**i, (k-1) % (i+1)
        print(str(a)[b])
        break",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: actions, end_total_candies = [int(i) for i in input().split()]
candies = 1
if(actions == 1):
    print(0)
else:
    for i in range(1, actions):
        candies = candies + i + 1

        if(candies >= end_total_candies + (actions - i - 2)):
            print(candies - end_total_candies)
            exit()
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin, stdout

def check(k, b, T):
	c = [e for e in b if e[0] >= k]

	if len(c) < k:
		return False, None

	first_k_probs = c[:k]
	s = sum([e[1] for e in first_k_probs])

	if s > T:
		return False, None

	return True, first_k_probs

def solve(n, T, a, t):
	b = []

	for i in range(n):
		b.append((a[i], t[i], i + 1))

	b.sort(key=lambda x: x[1])

	low, high = 0, n
	result = 0
	final_probs = []

	while low <= high:
		mid = (low + high) // 2

		(possible, probs) = check(mid, b, T)
		if possible:
			result, final_probs = mid, probs
			low = mid + 1
		else:
			high = mid - 1

	return (result, [e[2] for e in final_probs])

n, T = (int(x) for x in stdin.readline().split())

a = [0] * n
t = [0] * n

for i in range(n):
	a[i], t[i] = (int(x) for x in stdin.readline().split())

point, probs = solve(n, T, a, t)
stdout.write(""%s\n"" % point)
stdout.write(""%s\n"" % len(probs))
if len(probs) > 0:
	stdout.write(""%s\n"" % "" "".join([str(x) for x in probs]))
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        oldToCopy = collections.defaultdict(lambda: Node(0))
        oldToCopy[None] = None

        cur = head
        while cur:
            oldToCopy[cur].val = cur.val
            oldToCopy[cur].next = oldToCopy[cur.next]
            oldToCopy[cur].random = oldToCopy[cur.random]
            cur = cur.next
        return oldToCopy[head]
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin, stdout
from collections import *
from math import gcd, floor, ceil
def st(): return list(stdin.readline().strip())

def li(): return list(map(int, stdin.readline().split()))
def mp(): return map(int, stdin.readline().split())
def inp(): return int(stdin.readline())
def pr(n): return stdout.write(str(n)+""\n"")

mod = 1000000007
INF = float('inf')

def solve():
    n = inp() - 1
    pre = 0
    cur = 1
    point = 1
    while pre + 9*cur*point < n:
        pre += 9*cur*point
        cur *= 10
        point += 1
    n -= pre
    num, pos = divmod(n, point)
    num += pow(10, point-1)
    pr(str(num)[pos])

for _ in range(1):
    solve()
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def totalSteps(self, nums):
        dp = [0]*len(nums) 
        stk = []
        for i in range(len(nums)):
            curr = 0
            while stk and nums[stk[-1]] <= nums[i]:
                curr = max(curr, dp[stk.pop()])
            if stk:
                dp[i] = curr+1
            stk.append(i)
        return max(dp)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys, math
import io, os

from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter

def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
from decimal import Decimal
from fractions import Fraction

INF = float('inf')
mod = int(1e9)+7

def recur(r,g,b):
    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:
        return 0
    if dp[r][g][b]:
        return dp[r][g][b]
    if r>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+recur(r-1,g-1,b))
    if r>0 and b>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+recur(r-1,g,b-1))
    if b>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+recur(r,g-1,b-1))
    return dp[r][g][b]

r,g,b=mdata()
R=sorted(mdata())
G=sorted(mdata())
B=sorted(mdata())
dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]
out(recur(r,g,b))
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
a = set(map(int, input().split()))

ans = len(a) - 1 if 0 in a else len(a)
print(ans)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections


class Solution(object):
    def sortFeatures(self, features, responses):
        features_set = set(features)
        order = {word: i for i, word in enumerate(features)}
        freq = collections.defaultdict(int)
        for r in responses:
            for word in set(r.split(' ')):
                if word in features_set:
                    freq[word] += 1
        features.sort(key=lambda x: (-freq[x], order[x]))
        return features",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda pair: pair[0])
        output = [intervals[0]]

        for start, end in intervals:
            lastEnd = output[-1][1]

            if start <= lastEnd:
                output[-1][1] = max(lastEnd, end)
            else:
                output.append([start, end])
        return output
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def findMin(self, nums):
        left, right = 0, len(nums) - 1
        while left < right and nums[left] >= nums[right]:
            mid = left + (right - left) / 2

            if nums[mid] < nums[left]:
                right = mid
            else:
                left = mid + 1

        return nums[left]",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,m=input().split()
i=j=-1
while(j<0):
    mat=input()
    j=mat.find('B')
    i+=1
    c=mat.count('B')//2+1
print(i+c,j+c)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def checkRecord(self, s):
        count_A = 0
        for i in range(len(s)):
            if s[i] == 'A':
                count_A += 1
                if count_A == 2:
                    return False
            if i < len(s) - 2 and s[i] == s[i+1] == s[i+2] == 'L':
                return False
        return True",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
a = li()
b = li()

done = set()
j = 0
ans = []
for i in range(n):
    if b[i] in done:
        ans.append(0)
    else:
        c = 0
        while a[j] != b[i]:
            done.add(a[j])
            j += 1
            c += 1
        done.add(a[j])
        j += 1
        ans.append(c + 1)
print(*ans)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def countNumbersWithUniqueDigits(self, n):
        fact = [1]*2
        def nPr(n, k):
            while len(fact) <= n: 
                fact.append(fact[-1]*len(fact))
            return fact[n]//fact[n-k]

        return 1+9*sum(nPr(9, i) for i in range(n))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def orderOfLargestPlusSign(self, N, mines):
        lookup = {tuple(mine) for mine in mines}
        dp = [[0] * N for _ in range(N)]
        result = 0
        for i in range(N):
            l = 0
            for j in range(N):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = l
            l = 0
            for j in reversed(range(N)):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)

        for j in range(N):
            l = 0
            for i in range(N):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)
            l = 0
            for i in reversed(range(N)):
                l = 0 if (i, j) in lookup else l+1
                dp[i][j] = min(dp[i][j], l)
                result = max(result, dp[i][j])
        return result",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    l=sorted(zip(lst(),range(n)))
    p=0;ans=[0]*(2*n)
    st=[0]*n;ln=0
    s=input()
    for i in range(2*n):

        ch=s[i]
        if ch=='0':
            st[ln]=p
            ans[i]=l[p][1]+1
            ln+=1
            p+=1
        else:
            ans[i]=l[st[ln-1]][1]+1
            ln-=1
    print(*ans)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def f(a, ind):
    if a[ind] == 0:
        return -1
    k = a[ind] // 14
    x = a[ind] % 14
    b = a[:]
    b[ind] = 0
    for j in range(14):
        b[j] += k
    for j in range(ind + 1, ind + x + 1):
        j1 = j % 14
        b[j1] += 1
    res = 0
    for j in range(14):
        if b[j] % 2 == 0:
            res += b[j]
    return res
a = list(map(int, input().split()))
ans = 0
for i in range(14):
    cur = f(a, i)
    ans = max(ans, cur)
print(ans)",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def bstFromPreorder(self, preorder):
        def bstFromPreorderHelper(preorder, left, right, index):
            if index[0] == len(preorder) or \
               preorder[index[0]] < left or \
               preorder[index[0]] > right:
                return None

            root = TreeNode(preorder[index[0]])
            index[0] += 1
            root.left = bstFromPreorderHelper(preorder, left, root.val, index)
            root.right = bstFromPreorderHelper(preorder, root.val, right, index)
            return root
        
        return bstFromPreorderHelper(preorder, float(""-inf""), float(""inf""), [0])",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os
import sys
from io import BytesIO, IOBase

def get(a,x):
    return (a[0][x] == ""0"") + (a[1][x] == ""0"")

def main():
    a=[input().rstrip() for _ in range(2)]
    n=len(a[0])
    if n==1:
        print(0)
    else:
        dp=[[-1,-1,-1] for _ in range(n)]
        z=get(a,0)
        dp[0][z]=0
        for i in range(1,n):
            z=get(a,i)
            if z==0:
                dp[i][0]=max(dp[i-1])
            elif z==1:
                dp[i][0]=dp[i-1][2]+1
                dp[i][1]=max(dp[i-1])
            elif z==2:
                dp[i][0]=max(dp[i-1][1]+1,dp[i-1][2]+(i!=1))
                dp[i][1]=dp[i-1][2]+1
                dp[i][2]=max(dp[i-1])
        print(max(dp[-1]))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from operator import itemgetter
n = int(input())
ai = list(map(int,input().split()))
ai2 = [[ai[i], i] for i in range(n)]
answer = [0] * n
ai2.sort(key = itemgetter(0))
answer[ai2[0][1]] = 1
answer[ai2[-1][1]] = 0
for i in range(n-2,0,-1):
    num = ai2[i][1] % ai2[i][0]
    for j in range(num,n,ai2[i][0]):
        if ai[j] > ai2[i][0] and answer[j] == 0:
            answer[ai2[i][1]] = 1
            break
for i in range(n):
    if answer[i] == 1:
        print(""A"",end="""")
    else:
        print(""B"",end="""")
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maxCoins(self, nums):
        coins = [1] + [i for i in nums if i > 0] + [1]
        n = len(coins)
        max_coins = [[0 for _ in range(n)] for _ in range(n)]

        for k in range(2, n):
            for left in range(n - k):
                right = left + k
                for i in range(left + 1, right):
                    max_coins[left][right] = \
                        max(max_coins[left][right],
                            coins[left] * coins[i] * coins[right] +
                            max_coins[left][i] +
                            max_coins[i][right])

        return max_coins[0][-1]",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def minDistance(self, height, width, tree, squirrel, nuts):
        def distance(a, b):
            return abs(a[0] - b[0]) + abs(a[1] - b[1])

        result = 0
        d = float(""inf"")
        for nut in nuts:
            result += (distance(nut, tree) * 2)
            d = min(d, distance(nut, squirrel) - distance(nut, tree))
        return result + d",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math
def cm(n,r):
    i = n - r
    C = (math.factorial(n))/(math.factorial(i)*math.factorial(r))
    return C

s1 = input()
s2 = input()
d1={}
d2={}
d1['+']=0
d1['-']=0
d2['+']=0
d2['-']=0
d2['?']=0
r=0
ans=-1
for c in s1:
    d1[c]+=1
for c in s2:
    d2[c]+=1

np = d1['+']-d2['+']
nn = d1['-']-d2['-']
if np<0 or nn<0:
    ans=0
else:
    n=d2['?']
    r=min(np,nn)
    ans=cm(n,r)
    ans = round(float(ans)/float(math.pow(2,n)),9)
print(ans)",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n ,m  = list(map(int, input().split()))
a = list(map(int, input().split()))
b = list(map(int, input().split()))
ans = 0
for i in range(len(a)):
    if (len(b) == 0):
        break
    if (b[0] >= a[i]):
        ans += 1
        del b[0]
print(ans)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
input = sys.stdin.readline
q = int(input())
for i in range(q):
    n, k = map(int, input().split())
    s = input()
    R, G, B = 0, 0, 0
    ans = float('inf')
    for j in range(n):
        if j % 3 == 0:
            if s[j] == 'R':
                G += 1
                B += 1
            elif s[j] == 'G':
                R += 1
                B += 1
            else:
                R += 1
                G += 1
        elif j % 3 == 1:
            if s[j] == 'R':
                G += 1
                R += 1
            elif s[j] == 'G':
                G += 1
                B += 1
            else:
                R += 1
                B += 1
        else:
            if s[j] == 'R':
                R += 1
                B += 1
            elif s[j] == 'G':
                R += 1
                G += 1
            else:
                G += 1
                B += 1
        if j >= k - 1:
            ans = min(ans, R, G, B)
            if (j - k + 1) % 3 == 0:
                if s[j - k + 1] == 'R':
                    G -= 1
                    B -= 1
                elif s[j - k + 1] == 'G':
                    R -= 1
                    B -= 1
                else:
                    R -= 1
                    G -= 1
            elif (j - k + 1) % 3 == 1:
                if s[j - k + 1] == 'R':
                    G -= 1
                    R -= 1
                elif s[j - k + 1] == 'G':
                    G -= 1
                    B -= 1
                else:
                    R -= 1
                    B -= 1
            else:
                if s[j - k + 1] == 'R':
                    R -= 1
                    B -= 1
                elif s[j - k + 1] == 'G':
                    R -= 1
                    G -= 1
                else:
                    G -= 1
                    B -= 1

    print(ans)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: m = int(input())
values = []
idx = []
for i in range(m):
    x = int(input())
    ans = 0
    for xx,ii in zip(values,idx):
        if (xx^x) < x:
            x^=xx
            ans^=ii
    if x == 0:
        anss = []
        for j in range(i):
            if (ans&1)!=0:
                anss.append(j)
            ans>>=1
        print(len(anss),*anss)
    else:
        print(0)
        values.append(x)
        idx.append(ans^(2**i))
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys

from bisect import bisect_right as lb
from collections import deque

from queue import PriorityQueue as pq
from math import *
input_ = lambda: sys.stdin.readline().strip(""\r\n"")
ii = lambda : int(input_())
il = lambda : list(map(int, input_().split()))
ilf = lambda : list(map(float, input_().split()))
ip = lambda : input_()
fi = lambda : float(input_())
ap = lambda ab,bc,cd : ab[bc].append(cd)
li = lambda : list(input_())
pr = lambda x : print(x)
prinT = lambda x : print(x)
f = lambda : sys.stdout.flush()
inv =lambda x:pow(x,mod-2,mod)
mod = 10**9 + 7

n,s = il()

l = s
h = n
ans = n+1

while (l<=h) :
    m = (l+h)//2

    t = 0

    for i in str(m) :
        t += int(i)

    if (m-t >= s) :
        ans = m
        h = m-1
    else :
        l = m+1

print(n-ans+1)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: stones = list(map(int,input().split()))
initial_sum = 0

def even_sum(arr):
    temp_sum = 0
    for each in arr:
        if(each%2 == 0):
            temp_sum += each

    return temp_sum

initial_sum = even_sum(stones)
dup_sum = initial_sum

for i in range(14):
    duplicate = list(stones)
    temp = stones[i]
    duplicate[i] = 0
    j = i

    for each in range(14):
        duplicate[each] += temp//14
    temp = temp%14
    while temp > 0 :
        if( j == 13):
            j = -1
        j += 1
        duplicate[j] += 1
        temp -= 1

    ts = even_sum(duplicate)
    if(ts > initial_sum ):
        initial_sum = ts

print(initial_sum)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,l,r,x = map(int,input().split())
c = list(map(int,input().split()))
ans = 0

for mask in range(1 << n):
    a = []
    for bit in range(n):
        if mask & (1 << bit):
           a.append(c[bit])
    if len(a) >= 2 and max(a) - min(a) >= x and l <= sum(a) and sum(a) <= r:
        ans += 1
print(ans)
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def catMouseGame(self, graph):
        HOLE, MOUSE_START, CAT_START = list(range(3))
        DRAW, MOUSE, CAT = list(range(3))
        def parents(m, c, t):
            if t == CAT:
                for nm in graph[m]:
                    yield nm, c, MOUSE^CAT^t
            else:
                for nc in graph[c]:
                    if nc != HOLE:
                        yield m, nc, MOUSE^CAT^t

        degree = {}
        ignore = set(graph[HOLE])
        for m in range(len(graph)):
            for c in range(len(graph)):
                degree[m, c, MOUSE] = len(graph[m])
                degree[m, c, CAT] = len(graph[c])-(c in ignore)
        color = collections.defaultdict(int)
        q = collections.deque()
        for i in range(len(graph)):
            if i == HOLE:
                continue
            color[HOLE, i, CAT] = MOUSE
            q.append((HOLE, i, CAT, MOUSE))
            for t in [MOUSE, CAT]:
                color[i, i, t] = CAT
                q.append((i, i, t, CAT))
        while q:
            i, j, t, c = q.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if nt == c:
                    color[ni, nj, nt] = c
                    q.append((ni, nj, nt, c))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = c
                    q.append((ni, nj, nt, c))
        return color[MOUSE_START, CAT_START, MOUSE]

import collections",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maximumTripletValue(self, nums):
        NEG_INF = float(""-inf"")
        result = 0
        mx_diff = mx = NEG_INF
        for x in nums:
            if mx_diff != NEG_INF:
                result = max(result, mx_diff*x)
            if mx != NEG_INF:
                mx_diff = max(mx_diff, mx-x)
            mx = max(mx, x)
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def numberOfWays(self, corridor):
        MOD = 10**9+7
        result, cnt, j = 1, 0, -1
        for i, x in enumerate(corridor):
            if x != 'S':
                continue
            cnt += 1
            if cnt >= 3 and cnt%2:
                result = result*(i-j)%MOD
            j = i
        return result if cnt and cnt%2 == 0 else 0",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
a = list(map(int, input().split()))
max_el = -1;
er = -1;
for i in range(len(a)):
    if a[i] - max_el > 1:
        er = i + 1;
        break
    if a[i] > max_el:
        max_el = a[i]

print(er)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: s = input()
for i in range(len(s), 0, -1):
	for j in range(len(s) - i + 1):
		if s[j: j + i] in s[j + 1:]:
			print(i)
			exit()
print(0)",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: dp=[]
n,k=map(int,input().split())
for _ in range(n):
    p,t=map(int,input().split())
    dp.append((p,-t))
dp.sort(reverse=True)
print(dp.count(dp[k-1]))",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())

print(0, 0, n)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import itertools


class Solution(object):
    def maxWidthOfVerticalArea(self, points):
        sorted_x = sorted({x for x, y in points})
        return max([b-a for a, b in zip(sorted_x, sorted_x[1:])] + [0])",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
input=sys.stdin.readline
def getsum(BITTree,i):
    i=i+1
    s = 0
    while i > 0:
        s += BITTree[i]
        i -= i & (-i)
    return(s)
def updatebit(BITTree , n , i ,v):
    i=i+1
    while i <= n:
        BITTree[i] += v
        i += i & (-i)

n=int(input())
lista=[int(i) for i in input().split()]
invercount=0
bitTree=[0]*(n+2)
for k in reversed(lista):
        updatebit(bitTree,n+1,k,1)
        counter=getsum(bitTree,k-1)
        invercount+=counter
m=int(input())
for i in range(m):
    l,r=map(int,input().split())
    summa=((r-l+1)*(r-l))/2
    if (invercount+summa)%2:
        print('odd')
        invercount=1
    else:
        print('even')
        invercount=0
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys

class ADIYWoodenLadder:
    def solve(self):
        t = int(input())
        for _ in range(t):
            n = int(input())
            a = [int(_) for _ in input().split()]
            a.sort()
            print(min(a[-2] - 1, n - 2))

solver = ADIYWoodenLadder()
input = sys.stdin.readline

solver.solve()
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def missingNumber(self, nums):
        return reduce(operator.xor, nums,
                      reduce(operator.xor, range(len(nums) + 1)))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
input = sys.stdin.readline
from collections import deque

n,q=map(int,input().split())
A=deque(map(int,input().split()))
Q=[int(input()) for i in range(q)]

ANS=[0]

for l in range(10**5+1):
    x=A.popleft()
    y=A.popleft()

    ANS.append((x,y))

    if x>y:
        A.appendleft(x)
        A.append(y)
    else:
        A.appendleft(y)
        A.append(x)

ANS0=A[0]
B=list(A)[1:]

for q in Q:
    if q<=10**5+1:
        print(*ANS[q])
    else:
        print(ANS0,B[(q-10**5-2)%(n-1)])
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def largestSquareArea(self, bottomLeft, topRight):
        result = 0
        for i in range(len(bottomLeft)):
            for j in range(i+1, len(bottomLeft)):
                max_x = max(bottomLeft[i][0], bottomLeft[j][0])
                min_x = min(topRight[i][0], topRight[j][0])
                max_y = max(bottomLeft[i][1], bottomLeft[j][1])
                min_y = min(topRight[i][1], topRight[j][1])
                result = max(result, min(min_x-max_x, min_y-max_y))
        return result**2",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from sys import stdin
MOD = 1000000007
s = stdin.readline().strip()
n = len(s)
buc = [0] * 101
fac = [0] * (n + 1)
inv = [0] * (n + 1)
dp = [0] * (n + 1)

ans = [[0] * 55 for _ in range(55)]

def find(c: 'str') -> 'int':
    if 'A' <= c <= 'Z':
        return ord(c) - ord('A') + 26
    else:
        return ord(c) - ord('a')

for i in s:
    buc[find(i)] += 1

fac[0] = 1
for i in range(1, n + 1):
    fac[i] = (fac[i - 1] * i) % MOD
inv[n] = pow(fac[n], MOD - 2, MOD)
for i in range(n - 1, -1, -1):
    inv[i] = (inv[i + 1] * (i + 1)) % MOD

num = pow(fac[n // 2], 2, MOD)
for i in range(0, 52):
    num = (num * inv[buc[i]]) % MOD

dp[0] = 1

for i in range(0, 52):
    if not buc[i]:
        continue
    for j in range(n, buc[i] - 1, -1):
        dp[j] += dp[j - buc[i]]
        if dp[j] >= MOD:
            dp[j] -= MOD
for i in range(52):
    ans[i][i] = dp[n // 2]

for i in range(52):
    if not buc[i]:
        continue
    temp_dp = dp.copy()
    for k in range(buc[i], n + 1):
        temp_dp[k] -= temp_dp[k - buc[i]]
        if temp_dp[k] < 0:
            temp_dp[k] += MOD

    for j in range(i + 1, 52):
        if not buc[j]:
            continue
        for k in range(buc[j], n + 1):
            temp_dp[k] -= temp_dp[k - buc[j]]
            if temp_dp[k] < 0:
                temp_dp[k] += MOD
        ans[i][j] = (2 * temp_dp[n // 2]) % MOD

        for k in range(n, buc[j] - 1, -1):
            temp_dp[k] += temp_dp[k - buc[j]]
            if temp_dp[k] >= MOD:
                temp_dp[k] -= MOD

q = int(input())
l = stdin.read().splitlines()
for i in l:
    x, y = map(int, i.split())
    l, r = find(s[x - 1]), find(s[y - 1])
    if l > r:
        l, r = r, l
    print(num * ans[l][r] % MOD)
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def sss(l,r,tt):
    f = -1
    while(l<=r):
        mid = (l + r) >> 1
        if(a[mid]-a[tt] <= m):
           f = mid
           l = mid + 1
        else :
           r = mid - 1
    return f

n , m =  map(int, input().split())
a = [int(x) for x in input().split()]
f = 0
l  = len(a)

Maxx = -1
for i in range(0,l-2):
    if(a[i+2] - a[i]<= m):
         k = sss(i+2,l-1,i)
         if(k != -1):
             Maxx = max(Maxx,(a[k] - a[i+1])/(a[k]-a[i]))
if(Maxx == -1):
    print(-1)
else: print(""%.15f\n"" % Maxx)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def findWords(self, words):
        keyboard_rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']
        single_row_words = []
        for word in words:
            for row in keyboard_rows:
                if all(letter in row for letter in word.lower()):
                    single_row_words.append(word)
        return single_row_words",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp = defaultdict(lambda :-1)
M=1000001
for i in range(N):
    dp[i+M] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp[j+M*k], dp[j+k+M*(i-k)]
            if u == -1 or v == -1 or u != v:
                continue
            dp[j+M*i] = u+1;break

dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp[j+(i+1-j)*M] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n=int(input())
answer=0
for i in range(1,2*n-2,2):
    answer+=i
print(answer*2+2*n-1)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) < len(nums)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections



class Solution(object):
    def maxStudentsOnBench(self, students):
        lookup = collections.defaultdict(set)
        for s, b in students:
            lookup[b].add(s)
        return max(len(x) for x in lookup.values()) if lookup else 0",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
from collections import deque, defaultdict
input = lambda: sys.stdin.readline().rstrip()
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = [s[j] if i>>j&1 else '_' for j in range(k)]
            Ans.add(''.join(ans))
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = 1
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = 0
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag == 0 or not T:
        print('NO')
    else:
        print('YES')
        print(*[t+1 for t in T], sep = ' ')

main()",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def canBeValid(self, s, locked):
        if len(s)%2:
            return False
        for direction, c in ((lambda x:x, '('), (reversed, ')')):
            cnt = bal = 0
            for i in direction(range(len(s))):
                if locked[i] == '0':
                    cnt += 1
                else:
                    bal += 1 if s[i] == c else -1
                    if cnt+bal < 0:
                        return False
        return True",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution(object):
    def str2tree(self, s):
        def str2treeHelper(s, i):
            start = i
            if s[i] == '-': i += 1
            while i < len(s) and s[i].isdigit(): i += 1
            node = TreeNode(int(s[start:i]))
            if i < len(s) and s[i] == '(':
                i += 1
                node.left, i = str2treeHelper(s, i)
                i += 1
            if i < len(s) and s[i] == '(':
                i += 1
                node.right, i = str2treeHelper(s, i)
                i += 1
            return node, i

        return str2treeHelper(s, 0)[0] if s else None",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: k,n,s,p = map(int,input().split())
x = (n+s-1)//s
x *= k
print((x+p-1)//p)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: s = input()
t = s.count('1')
s = s.replace('1', '')
i = s.find('2')
if i == -1:
    print(s + '1'*t)
else:
    print(s[:i] + '1'*t + s[i:])",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,x=map(int,input().split())
a=[]
k={}
for _ in range(n):
    p,q=map(int,input().split())
    if p not in k:
        k[p]=1
    a.append([p,q])
a.sort()
k=sorted(k)
p=[]
k=k[::-1]
for i in k:
    for j in a:
        if j[0]==i:
            p.append(j)
print(p.count(p[x-1]))",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections



class Solution(object):
    def minimumOperationsToMakeKPeriodic(self, word, k):
        cnt = collections.Counter(word[i:i+k]for i in range(0, len(word), k))
        return len(word)//k-max(cnt.values())",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,U=map(int,input().split())
Ar=list(map(int,input().split()))
R = 0;
ans = -1;
for i in range(n):
    while R + 1 < n and Ar[R + 1] - Ar[i] <= U:
        R+=1
    if i+1 < R:
        ans = max((Ar[R] - Ar[i + 1]) / (Ar[R] - Ar[i]),ans);
print(ans)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        result, prev, curr = 0, 0, 0
        for n in nums:
            if n == 0:
                result = max(result, prev+curr+1)
                prev, curr = curr, 0
            else:
                curr += 1
        return min(max(result, prev+curr+1), len(nums))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def specialArray(self, nums):
        MAX_NUM = 1000
        def inplace_counting_sort(nums, reverse=False): 
            count = [0]*(MAX_NUM+1)
            for num in nums:
                count[num] += 1
            for i in range(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(range(len(nums))): 
                while nums[i] >= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in range(len(nums)):
                nums[i] = ~nums[i] 
            if reverse: 
                nums.reverse()
    
        inplace_counting_sort(nums, reverse=True)
        left, right = 0, len(nums)-1
        while left <= right: 
            mid = left + (right-left)//2
            if nums[mid] <= mid:
                right = mid-1
            else:
                left = mid+1
        return -1 if left < len(nums) and nums[left] == left else left",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

a = {0:0}

for i in range(n):
    b = a.copy()
    for p in a.items():
        d = gcd(p[0], l[i])
        cost = p[1] + c[i]
        if d not in b: b[d] = cost
        elif b[d] > cost: b[d] = cost
    a = b

if 1 not in a: a[1] = -1
print(a[1])
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import random



class Solution(object):
    def miceAndCheese(self, reward1, reward2, k):
        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid <= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right
            
            right = len(nums)-1
            while left <= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left <= n <= pivot_right:
                    return
                elif pivot_left > n:
                    right = pivot_left-1
                else: 
                    left = pivot_right+1
    
        for i in range(len(reward1)):
            reward1[i] -= reward2[i]
        nth_element(reward1, k-1, compare=lambda a, b: a > b)
        return sum(reward2)+sum(reward1[i] for i in range(k))",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: l, r = map(int, input().split())

if l == r:
    print(0)
    exit()

x = 1
while x <= r:
    x = x << 1
x = x >> 1

k = x
while x <= l or x > r:
    if x <= l:
        x += k
    else:
        x -= k
    k = k >> 1

print(x ^ (x - 1))
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, k = map(int, input().split())
values, single, l, r = [int(i) for i in input().split()], set(), -1, -1
for i in range(n):
    single.add(values[i])
    if len(single) == k:
        l, r = 1, i + 1
        break
single = set()
for i in range(r - 1, max(-1, l - 2), -1):
    single.add(values[i])
    if len(single) == k:
        l = i + 1
        break

if len(single) < k:
    print(-1, -1)
else:
    print(l, r)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys, heapq

def binary(num):
    left = 0
    right = n
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < num:
            left = mid + 1
        elif arr[mid] > num:
            right = mid
        else:
            return True
    return False

n = int(sys.stdin.readline())
arr = list(map(int, sys.stdin.readline().split()))
arr.sort()
cnt = dict().fromkeys(set(arr), 0)
ans = 0
for i in arr:
    cnt[i] += 1
for i in range(n):
    now = arr[i]
    can = False
    for j in range(31):
        target = pow(2, j) - now
        if binary(target):
            if target == now:
                if cnt[now] >= 2:
                    can = True
                    break
            else:
                can = True
                break
    if not can:
        ans += 1
print(ans)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
ar = [int(i) for i in input().split()]

if n == 1:
    print(1)
    exit()

if ar[1] > ar[0]:
    li = [1]
elif ar[1] < ar[0]:
    li = [5]
else:
    li = [3]

c = 1
while c != n:
    j = 0

    if ar[c] > ar[c - 1]:
        while c != n and ar[c] > ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] + 1)
            if li[-1] == 6:
                print(-1)

                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] + 1)
        else:
            li.append(5)

    elif ar[c] < ar[c - 1]:
        while c != n and ar[c] < ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] - 1)
            if li[-1] == 0:
                print(-1)

                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] - 1)
        else:
            li.append(1)

    else:
        while c != n and ar[c] == ar[c - 1]:
            c += 1
            j += 1
        for i in range(j):
            if li[-1] > 3:
                li.append(li[-1] - 1)
            else:
                li.append(li[-1] + 1)
        if c != n and ar[c] > ar[c - 1]:
            if li[-2] == 1:
                li[-1] = 2
            else:
                li[-1] = 1
        elif c != n and ar[c] < ar[c - 1]:
            if li[-2] == 5:
                li[-1] = 4
            else:
                li[-1] = 5

if max(li) > 5 or min(li) < 1:
    print(-1)
else:
    print(*li)",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def moveZeroes(self, nums):
        pos = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[i], nums[pos] = nums[pos], nums[i]
                pos += 1

    def moveZeroes2(self, nums):
        nums.sort(cmp=lambda a, b: 0 if b else -1)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from functools import lru_cache

P = 10**9+7
N, T = map(int, input().split())
A = [[], [], []]
X = []
for _ in range(N):
    t, g = map(int, input().split())
    X.append((t, g))

@lru_cache(maxsize=None)
def calc(x, pr, t):
    if t < 0:
        return 0
    if t == 0:
        return 1
    if x == 0:
        return 0

    ans = 0
    for i in range(15):
        if x & (1<<i):
            if X[i][1] != pr:
                y = x ^ (1<<i)
                ans = (ans + calc(y, X[i][1], t-X[i][0])) % P
    return ans

print(calc(2**N-1, -1, T))",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,m,k=map(int,input().split())
y_axis=[list(map(int,input().split())) for i in range(n)]
x_axis=[list(map(int,input().split())) for i in range(n-1)]
if(k%2==1):
    for i in range(n):
        for j in range(m):
            print(-1,end="" "")
        print()
else:
    inf=10**9
    dp=[[[inf for z in range(k+1)]for y in range(m)]for x in range(n)]
    for i in range(n):
        for j in range(m):
            if(i>0):
                if(i<n-1):
                    dp[i][j][2]=min(dp[i][j][2],2*x_axis[i][j],2*x_axis[i-1][j])
                else:
                    dp[i][j][2]=min(dp[i][j][2],2*x_axis[i-1][j])
            else:
                dp[i][j][2]=min(dp[i][j][2],2*x_axis[i][j])
            if(j>0):
                if(j<m-1):
                    dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j],2*y_axis[i][j-1])
                else:
                    dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j-1])
            else:
                dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j])
    for z in range(4,k+1,2):
        for i in range(n):
            for j in range(m):
                if(i>0):
                    if(i<n-1):
                        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-2]+2*x_axis[i-1][j],dp[i+1][j][z-2]+2*x_axis[i][j])
                    else:
                        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-2]+2*x_axis[i-1][j])
                else:
                    dp[i][j][z]=min(dp[i][j][z],dp[i+1][j][z-2]+2*x_axis[i][j])
                if(j>0):
                    if(j<m-1):
                        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*y_axis[i][j-1],dp[i][j+1][z-2]+2*y_axis[i][j])
                    else:
                        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*y_axis[i][j-1])
                else:
                    dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-2]+2*y_axis[i][j])
    for i in range(n):
        for j in range(m):
            if(dp[i][j][k]==inf):
                print(-1,end="" "")
            else:
                print(dp[i][j][k],end="" "")
        print()
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: t = int(input())

for i in range(0, t) :
    n, k = [int(x) for x in input().split()]
    if (n >= 32) :
        print(""YES %d"" % (n-1))
    else :
        low=0
        co=-1
        md = [0]
        for j in range(1, n):
            md.append(md[-1]*4 + 1)
        kk = 0
        found=0
        for cut in range(1,n+1) :
            low += (1<<cut)-1
            co = 2*co + 3
            kk += co*md[n-cut]
            if (k>=low and k<=low+kk) :
                print(""YES %d"" % (n-cut))
                found=1
                break
        if (found == 0) : print(""NO"")
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
from array import array
from typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

def main():
    n, m = map(int, input().split())
    mat = [array('i', map(int, input().split())) for _ in range(n)]
    bit = array('h', [1 << i for i in range(m)])
    max_bit = 1 << m
    fullbit = max_bit - 1

    def solve(x: int) -> Tuple[int, int]:
        dp = array('i', [-1]) * max_bit
        for i in range(n):
            dp[sum(bit[j] for j in range(m) if mat[i][j] >= x)] = i

        for i in range(max_bit):
            if dp[i] == -1:
                continue
            for j in range(i, max_bit):
                if dp[j] != -1 and i | j == fullbit:
                    return dp[i], dp[j]

        return -1, -1

    ok, ng = 0, 10**9 + 1
    ans_i, ans_j = 1, 1

    while abs(ok - ng) > 1:
        mid = (ok + ng) >> 1
        x, y = solve(mid)
        if x == -1:
            ng = mid
        else:
            ok = mid
            ans_i, ans_j = x + 1, y + 1

    print(ans_i, ans_j)

if __name__ == '__main__':
    main()
",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import collections



class Solution(object):
    def countNonDecreasingSubarrays(self, nums, k):
        result = cnt = 0
        dq = collections.deque()
        right = len(nums)-1
        for left in reversed(range(len(nums))):
            while dq and nums[dq[-1]] < nums[left]:
                l = dq.pop()
                r = dq[-1]-1 if dq else right
                cnt += (r-l+1)*(nums[left]-nums[l])
            dq.append(left)
            while cnt > k:
                cnt -= nums[dq[0]]-nums[right]
                if dq[0] == right:
                    dq.popleft()
                right -= 1
            result += right-left+1
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys

from collections import deque

from queue import PriorityQueue
from math import gcd
from math import log
from math import ceil
from math import pi
input_ = lambda: sys.stdin.readline().strip(""\r\n"")
ii = lambda : int(input_())
il = lambda : list(map(int, input_().split()))
ilf = lambda : list(map(float, input_().split()))
ip = lambda : input_()
fi = lambda : float(input_())
ap = lambda ab,bc,cd : ab[bc].append(cd)
li = lambda : list(input_())
pr = lambda x : print(x)
prinT = lambda x : print(x)
f = lambda : sys.stdout.flush()
mod = 10**9 + 7

n,mod = il()
N = 406

fact = [1 for i in range (N)]
inver = [1 for i in range (N)]
power2 = [1 for i in range (N)]
ncr = [[1 for i in range (N)] for j in range (N)]
dp = [[0 for i in range (N)] for j in range (N)]

def precom() :

    fact[0] = 1
    inver[0] = 1

    for i in range (1,N) :
        fact[i] = (fact[i-1]*i)%mod
        inver[i] = pow(fact[i],mod-2,mod)

    for i in range (N) :
        for j in range (i+1) :
            ncr[i][j] = (((fact[i]*inver[j])%mod)*inver[i-j])%mod

    for i in range(1,N) :
        power2[i] = (power2[i-1]*2)%mod

precom()

dp[0][0] = 1

for i in range (n) :
    for j in range (i+1) :
        k = 1
        while (k+i <= n) :

            dp[i+k+1][j+k] = (dp[i+k+1][j+k] + ((dp[i][j]*power2[k-1])%mod*ncr[j+k][k])%mod)%mod

            k += 1

ans = 0

for i in range (n+1) :
    ans = (ans + dp[n+1][i])%mod

print(ans)
",O(n ^ 3)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution2(object):
    def maxSubarrayLength(self, nums):
        idxs = list(range(len(nums)))
        idxs.sort(key=lambda x: nums[x], reverse=True)
        result = 0
        for left in range(len(nums)):
            while idxs and nums[idxs[-1]] < nums[left]:
                result = max(result, idxs.pop()-left+1)
        return result",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: print(""? 0 0"")
t = int(input())
A=[]
B=[]
a=0
b=0
for i in range(30):
    A.append(-1)
    B.append(-1)
i = 29
d = 2**i
while i>=0:
    a+=d
    b+=d
    print(""?"", end=' ')
    print(a, end=' ')
    print(b)
    s=int(input())
    if s == -t:
        if s==1:
            A[i]=0
            B[i]=1
            b-=d
            print(""?"", end=' ')
            print(a, end=' ')
            print(b)
            t=int(input())
        elif s==-1:
            A[i]=1
            a-=d
            B[i]=0
            print(""?"", end=' ')
            print(a, end=' ')
            print(b)
            t=int(input())
    i-=1
    d//=2
d=1
for j in range(30):
    if A[j]==-1:
        a = a^d
        print(""?"", end=' ')
        print(a, end=' ')
        print(b)
        s = int(input())
        if s==1:
            A[j]=1
            B[j]=1
        else:
            A[j]=0
            B[j]=0
        a = a^d
    d*=2
d=1
a=0
b=0
for i in range(30):
    a+=d*A[i]
    b+=d*B[i]
    d*=2
print(""!"", end=' ')
print(a, end=' ')
print(b)
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: 
class Solution(object):
    def kidsWithCandies(self, candies, extraCandies):
        max_num = max(candies)
        return [x + extraCandies >= max_num for x in candies]
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: l,r = map(int, input().split())

def maxXor(low, high):

    highestPower = high.bit_length()-1
    if high == 1 and low == 0:
        return 1
    if highestPower <= 0:
        return 0
    if low < 2** highestPower:
        return (2**(highestPower+1))-1
    return maxXor(low -2**highestPower, high-2**highestPower)

print(maxXor(l,r))
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: a = []
n = int(input())
for _ in range(n):
    a.append(input())
if n==1:
    print(""YES"")
    print(a[0])
else:
    a.sort(key = len)
    for i in range(1,n):
        if a[i-1] not in a[i]:
            print(""NO"")
            break
    else:
        print(""YES"")
        for i in a:
            print(i)
",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, m = map(int, input().split("" ""))
numbers = list(map(int, input().split("" "")))

smaller_greater = [(0, 0)]
for k in numbers:
    s, g = smaller_greater[-1]
    if k < m:
        smaller_greater.append((s + 1, g))
    elif k > m:
        smaller_greater.append((s, g + 1))
    else:
        smaller_greater.append((s, g))

i = numbers.index(m)
s_median, g_median = smaller_greater[i]

difference = {}
for pack in smaller_greater[i + 1:]:
    s, g = pack
    s -= s_median
    g -= g_median
    if s - g in difference:
        difference[s - g] += 1
    else:
        difference[s - g] = 1

count = 0
for start in range(i + 1):
    s, g = smaller_greater[start]
    s -= s_median
    g -= g_median
    if s - g in difference.keys():
        count += difference[s - g]

    if s - g - 1 in difference.keys():
        count += difference[s - g - 1]

print(count)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from itertools import combinations
n , l , r ,x = map(int,input().split())
a = list(map(int, input().split()))
c = 0
for i in range(1,n+1):
    for j in combinations(a,i):
        if (l<=sum(j)<=r and max(j)-min(j)>=x):
            c+=1
print(c)",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from math import ceil, sqrt, log

def mod_expo(n, p, m):

	result = 1
	while p != 0:
		if p%2 == 1:
			result = (result * n)%m
		p //= 2
		n = (n * n)%m
	return result

def is_square(n):
	return int(sqrt(n))*int(sqrt(n)) == n

def find_div(n):
	d = []
	for i in range(2, int(sqrt(n))+1):
		if n%i == 0:
			if i*i != n:
				d.append(i)
				d.append(n/i)
			else:
				d.append(i)
	return d

def find_x(n):
	d = find_div(2*n)
	for div in d:
		x2 = div*(div + 2*n)
		if is_square(x2):
			return sqrt(x2)
	return -1

def find_base_side(n):
	squares = [x*x for x in range(ceil(sqrt(n)))]
	for i in range(len(squares)):
		for j in range(len(squares)):
			if squares[i] + squares[j] == n*n:
				return squares[i]
	return -1

def str_add(n):
	n = list(n)
	for i in range(1, len(n)+1):
		if n[-i] == '9':
			n[-i] = '0'
		else:
			n[-i] = int(int(n[-i]) + 1)
			break
	n = str(n)
	return n

def str_sub(n):
	n = list(n)
	for i in range(1, len(n)+1):
		if n[-i] == '0':
			n[-i] = '9'
		else:
			n[-i] = int(int(n[-i]) - 1)
			break
	n = str(n)
	return n

def find_massive_x(n):
	if n%2 == 0:
		n2 = str(int(pow(n/2, 2)))
		x = str_sub(n2)
		y = str_add(n2)
	else:
		n2 = str(int(pow(n, 2)/2))
		x = str_sub(n2)
		y = str_add(n2)
	x = str(x)
	y = str(y)
	print(x, y)
def find_triples(n):
	if n <= 2:
		print(-1)
		return
	else:

		x = find_massive_x(n)

	print(-1)

def find_max_xor(l, r):
	lxr = l^r
	msb_pos = 0
	while lxr > 0:
		msb_pos += 1
		lxr //= 2
	return pow(2, msb_pos)-1

t = 1

while t:
	t = t - 1

	print(find_max_xor(l, r))
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from collections import defaultdict

class Solution(object):

    def __init__(self):
        self.lookup = defaultdict(int)



    def add(self, number):
        self.lookup[number] += 1


    def find(self, value):
        for key in self.lookup:
            num = value - key
            if num in self.lookup and (num != key or self.lookup[key] > 1):
                return True
        return False",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: from math import factorial
s = input().strip()
new = input().strip()
questions = 0
plus = s.count('+')
minus = s.count('-')
for i in new:
	if i == '+':
		plus -= 1
	elif i == '-':
		minus -= 1
	else:
		questions += 1
if plus < 0 or minus < 0:
	print(0)
else:
	num = factorial(questions)/(factorial(plus)*factorial(minus))
	den = 2**questions
	print(""{0:.10f}"".format(num/den))",np
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
ax,ay = list(map(int,input().split()))
bx,by = list(map(int,input().split()))
cx,cy = list(map(int,input().split()))

if (ax-bx)*(ax-cx) > 0 and (ay-by)*(ay-cy) > 0:
    print(""YES"")
else:
    print(""NO"")
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class UnionFind(object):
    def __init__(self, n):
        self.set = list(range(n))
        self.count = n

    def find_set(self, x):
       if self.set[x] != x:
           self.set[x] = self.find_set(self.set[x]) 
       return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = list(map(self.find_set, (x, y)))
        if x_root != y_root:
            self.set[min(x_root, y_root)] = max(x_root, y_root)
            self.count -= 1


class Solution(object):
    def regionsBySlashes(self, grid):
        def index(n, i, j, k):
            return (i*n + j)*4 + k
    
        union_find = UnionFind(len(grid)**2 * 4)
        N, E, S, W = list(range(4))
        for i in range(len(grid)):
            for j in range(len(grid)):
                if i:
                    union_find.union_set(index(len(grid), i-1, j, S),
                                         index(len(grid),i, j, N))
                if j:
                    union_find.union_set(index(len(grid), i, j-1, E),
                                         index(len(grid), i, j, W))
                if grid[i][j] != ""/"":
                    union_find.union_set(index(len(grid), i, j, N),
                                         index(len(grid), i, j, E))
                    union_find.union_set(index(len(grid), i, j, S),
                                         index(len(grid), i, j, W))
                if grid[i][j] != ""\\"":
                    union_find.union_set(index(len(grid), i, j, W),
                                         index(len(grid), i, j, N))
                    union_find.union_set(index(len(grid), i, j, E),
                                         index(len(grid), i, j, S))
        return union_find.count",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def maxNiceDivisors(self, primeFactors):
        MOD = 10**9 + 7
        if primeFactors <= 3:
            return primeFactors
        if primeFactors % 3 == 0: 
            return pow(3, primeFactors//3, MOD)
        if primeFactors % 3 == 1: 
            return (2*2*pow(3, (primeFactors-4)//3, MOD)) % MOD
        return (2*pow(3, (primeFactors-2)//3, MOD)) % MOD",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, m = map(int, input().split())
arr = list(map(int, input().split()))
d = {}
i = 1
for x in arr:
	if len(d) == m:
		break
	d[x] = i
	i += 1
if len(d) == m:
	print(min(d.values()), max(d.values()))
else:
	print(-1,-1)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: def max_profit(n,k,l,d):
    a=[]
    s,p,i=0,0,-1
    while(len(a)!=k-1):
        p+=1
        i+=1
        if l[i] in d:
            s+=l[i]
            a.append(p)
            p=0
            d.remove(l[i])
    print(s+d[0])
    a.append(n-sum(i for i in a))
    print(*a)

n,k=map(int,input().split())
l=list(map(int,input().split()))
m=[]
m[:]=l[:]
d=[]
m.sort(reverse=True)
for i in range(k):
    d.append(m[i])
max_profit(n,k,l,d)",O(nlogn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys
input = sys.stdin.buffer.readline

from collections import deque

n,d,k=map(int,input().split())

if d>=n:
    print(""NO"")
    exit()

graph=[[] for i in range(n+1)]

for i in range(1,d+2):
    graph[i].append(min(i-1,d+1-i))

for i in range(1,d+1):
    graph[i].append(i+1)
    graph[i+1].append(i)

deg=[0]*(n+1)
deg[1]=1
deg[d+1]=1
for i in range(2,d+1):
    deg[i]=2

for i in deg:
    if i>k:
        print(""NO"")
        exit()

p=d+2
for i in range(1,d+2):
    q=deque()
    q.append(i)
    while len(q)!=0:
        x=q.popleft()
        while (graph[x][0]>0 and deg[x]<k and p<=n):
            graph[x].append(p)
            deg[x]=deg[x]+1
            graph[p].append(graph[x][0]-1)
            graph[p].append(x)
            deg[p]=deg[p]+1
            q.append(p)
            p=p+1

if p<=n:
    print(""NO"")
else:
    print(""YES"")
    vis=[-1]*(n+1)

    for i in range(1,d+2):
        if vis[i]==-1:
            q=deque()
            q.append(i)
            while len(q)!=0:
                x=q.popleft()
                vis[x]=1
                for j in range(1,len(graph[x])):
                    if vis[graph[x][j]]==-1:
                        print(x,graph[x][j])
                        q.append(graph[x][j])
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n = int(input())
a = list(map(int, input().split()))

mex = -1
for i in range(n):
    if a[i] <= mex:
        continue
    elif a[i] == mex + 1:
        mex += 1
    else:
        print(i+1)
        exit()
print(-1)",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: N, K = map(int, input().split())

def in_bounds(k):
    return N <= K*(K+1)//2 - (K-k)*(K-k+1)//2 - k + 1

l = 0
r = K
while l <= r:
    c = (l + r) // 2
    if in_bounds(c):
        r = c - 1
    else:
        l = c + 1
if in_bounds(K):
    print(l)
else:
    print(-1)
",O(logn)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def countOfPairs(self, n, x, y):
        x, y = x-1, y-1
        if x > y:
            x, y = y, x
        diff = [0]*n
        for i in range(n):
            diff[0] += 1+1                                        
            diff[min(abs(i-x), abs(i-y)+1)] += 1                  
            diff[min(abs(i-y), abs(i-x)+1)] += 1                  
            diff[min(abs(i-0), abs(i-y)+1+abs(x-0))] -= 1         
            diff[min(abs(i-(n-1)), abs(i-x)+1+abs(y-(n-1)))] -= 1 
            diff[max(x-i, 0)+max(i-y, 0)+((y-x)+0)//2] -= 1       
            diff[max(x-i, 0)+max(i-y, 0)+((y-x)+1)//2] -= 1       
        for i in range(n-1):
            diff[i+1] += diff[i]
        return diff",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import math

input()
all_days_problems = list(map(int, input().split()))
sum_count = sum(all_days_problems)
half_problems = math.ceil(sum_count/2)
current_sum = 0
answer = 0
for num in all_days_problems:
    answer += 1
    current_sum +=num
    if current_sum >=half_problems:
        break

print(answer)
",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: class Solution(object):
    def numSub(self, s):
        MOD = 10**9+7
        result, count = 0, 0
        for c in s:
            count = count+1 if c == '1' else 0
            result = (result+count)%MOD
        return result",O(n)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: import sys, math

def mp():
    return list(map(int, input().split()))

def quer(x1, y1, x2, y2):
    if x1 > x2 or y1 > y2:
        return [0, 0]
    s = (x2 - (x1 - 1)) * (y2 - (y1 - 1))
    if s % 2 == 0:
        return [s // 2, s // 2]
    if (x1 + y1) & 1:
        return [s // 2 + 1, s // 2]
    return [s // 2, s // 2 + 1]

def main():
    q = int(input())
    for i in range(q):
        n, m = mp()
        x1, y1, x2, y2 = mp()
        s = quer(1, 1, n, m)
        s1 = quer(x1, y1, x2, y2)
        s[0] -= s1[0]
        s[1] += s1[0]

        x3, y3, x4, y4 = mp()
        xmn = max(x1, x3)
        xmx = min(x2, x4)
        ymn = max(y1, y3)
        ymx = min(y2, y4)
        s1 = quer(x3, y3, x4, y4)
        s[0] += s1[1]
        s[1] -= s1[1]
        s1 = quer(xmn, ymn, xmx, ymx)
        s[0] += s1[0]
        s[1] -= s1[0]
        print(*s[::-1])

debug = 0
if debug:
    file = open(""input.txt"", ""r"")
    input = file.readline
main()
if debug:
    file.close()",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: one = list(map(int, input().split()))
two = list(map(int, input().split()))

one_ = sorted([(one[i], one[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))
two_ = sorted([(two[i], two[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))

ones = [one_[0], one_[2], one_[3], one_[1]]
twos = [two_[1], two_[3], two_[2], two_[0]]

L, D, U, R = ones[0][0], ones[0][1], ones[2][1], ones[2][0]

def in_one(point):
    x, y = point

    return L <= x <= R and D <= y <= U

def in_two(point):
    x_0, y_0 = twos[0]

    def U_p(x_):
        return x_ + y_0 - x_0

    def D_m(x_):
        return -x_ + y_0 + x_0

    x_1, y_1 = twos[2]

    def U_m(x_):
        return -x_ + y_1 + x_1

    def D_p(x_):
        return x_ + y_1 - x_1

    x, y = point

    return D_m(x) <= y <= U_p(x) and D_p(x) <= y <= U_m(x)

c_one = ((L + R) / 2, (U + D) / 2)
c_two = ((twos[0][0] + twos[2][0]) / 2, (twos[1][1] + twos[3][1]) / 2)

ones.append(c_one)
twos.append(c_two)

for p in ones:
    if in_two(p):
        print('YES')
        exit()

for p in twos:
    if in_one(p):
        print('YES')
        exit()

print('NO')
",O(1)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n,m,k = [int(w) for w in input().split()]
a = [int(w) for w in input().split()]

def f(o):
    r = e = 0
    for i, x in enumerate(a):
        if i < o:
            continue
        if i % m == o:
            e -= k
            if e < -k:
                e = -k
        e += x
        if e > r:
            r = e
    return r

print(max(f(o) for o in range(m)))
",O(n ^ 2)
"
            Classify the code snippet into: O(1), O(logn), O(n), O(nlogn),
              O(n ^ 2), O(n ^ 3), np. And return the answer as the corresponding
                big O time complexity label.
            Code: n, mod = map(int, input().split())

le = 500

def pow(x, y):
    ans = 1
    while y > 0:
        if y % 2 == 1:
            ans = (ans * x) % mod
        x = (x**2) % mod
        y //= 2
    return ans

def inv(x):
    return pow(x, mod-2)

M = [1]
mul = 1
for i in range(1, le):
    mul = (mul * i) % mod
    M.append(mul)

L0 = n//2+3
L1 = n+1

D = [[0 for i in range(L1)] for j in range(L0)]

ND = [[0 for i in range(L1)] for j in range(L0)]

INVS = [0] + [inv(i) for i in range(1, n+1)]

D[1][1] = 1
for z in range(2, n+1):

    l0 = z//2+3
    l1 = z+1

    for i in range(l0):
        for j in range(l1):
            ND[i][j] = 0

    for i in range(l0):
        if i >= 1:
            ND[i][1] += D[i-1][0] * (z-(i-1))
            ND[i][1] %= mod

    for i in range(l0):
        for j in range(1, n+1):
            ND[i][0] += D[i][j]
            ND[i][0] %= mod

    for i in range(l0):
        for j in range(l1):
            if j >= 2:
                p = D[i][j-1]
                p *= (z-(i-1))
                p %= mod
                p *= INVS[j] * 2
                p %= mod
                ND[i][j] += p
                ND[i][j] %= mod

    for i in range(l0):
        for j in range(l1):
            D[i][j] = ND[i][j]

ans = 0
for i in range(L0):
    for j in range(1, L1):
        ans += D[i][j]
        ans %= mod
print(ans)
",O(n ^ 3)
